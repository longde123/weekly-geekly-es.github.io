<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüî¨ üöÖ üèÜ Crear un sombreador de c√©sped en el motor de Unity ü§ñ üë¥üèº üçÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este tutorial le mostrar√° c√≥mo escribir un sombreador geom√©trico para generar briznas de hierba desde la parte superior de la malla entrante y utiliza...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear un sombreador de c√©sped en el motor de Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este tutorial le mostrar√° c√≥mo escribir un sombreador geom√©trico para generar briznas de hierba desde la parte superior de la malla entrante y utilizar la teselaci√≥n para controlar la densidad de la hierba. <br><br>  El art√≠culo describe el proceso paso a paso de escribir un sombreador de c√©sped en Unity.  El sombreador recibe la malla entrante, y de cada v√©rtice de la malla genera una brizna de hierba utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sombreador geom√©trico</a> .  En aras del inter√©s y el realismo, las briznas de hierba tendr√°n un <strong>tama√±o</strong> y <strong>rotaci√≥n</strong> <strong>aleatorios</strong> , y tambi√©n se ver√°n afectados por el <strong>viento</strong> .  Para controlar la densidad de la hierba, utilizamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teselaci√≥n</a> para separar la malla entrante.  La hierba podr√° <strong>proyectar</strong> y <strong>recibir</strong> sombras. <br><br>  <strong>El proyecto terminado</strong> se publica al final del art√≠culo.  El archivo de sombreador generado contiene una gran cantidad de comentarios que facilitan la comprensi√≥n. <br><a name="habracut"></a><br><h3>  Requisitos </h3><br>  Para completar este tutorial, necesitar√° conocimientos pr√°cticos sobre el motor de Unity y una comprensi√≥n inicial de la sintaxis y la funcionalidad de los sombreadores. <br><br>  <a href="">Descargue el borrador del proyecto (.zip)</a> . <br><br><h2>  Llegar al trabajo </h2><br>  Descargue el borrador del proyecto y √°bralo en el editor de Unity.  Abra la escena <code>Main</code> y luego abra el sombreador <code>Grass</code> en su editor de c√≥digo. <br><br>  Este archivo contiene un sombreador que produce color blanco, as√≠ como algunas funciones que usaremos en este tutorial.  Notar√° que estas funciones junto con el sombreador de v√©rtices est√°n incluidas en el bloque <code>CGINCLUDE</code> ubicado <em>fuera de</em> <code>SubShader</code> .  El c√≥digo colocado en este bloque se incluir√° <strong>autom√°ticamente en todos los pases</strong> en el sombreador;  Esto ser√° √∫til m√°s tarde porque nuestro sombreador tendr√° varias pasadas. <br><br>  Comenzaremos escribiendo un <strong>sombreador geom√©trico</strong> que genere tri√°ngulos a partir de cada v√©rtice en la superficie de nuestra malla. <br><br><h2>  1. Shaders geom√©tricos </h2><br>  Los sombreadores geom√©tricos son una parte opcional de la canalizaci√≥n de renderizado.  Se ejecutan <strong>despu√©s del</strong> sombreador de v√©rtices (o sombreador de teselaci√≥n si se utiliza la teselaci√≥n) y antes de que se procesen los v√©rtices para el sombreador de fragmentos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Direct3D Graphics Pipeline 11. Observe que en este diagrama el sombreador de fragmentos se llama <em>sombreador de p√≠xeles</em> .</i> <br><br>  Los sombreadores geom√©tricos reciben una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primitiva</a> √∫nica en la entrada y pueden generar cero, una o muchas primitivas.  Comenzaremos escribiendo un sombreador geom√©trico que reciba un <strong>v√©rtice</strong> (o <em>punto</em> ) en la entrada, y que alimente <strong>un tri√°ngulo que</strong> represente una brizna de hierba. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } ‚Ä¶ // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  El c√≥digo anterior declara un sombreador geom√©trico llamado <code>geo</code> con dos par√°metros.  El primer <code>triangle float4 IN[3]</code> informa que tomar√° un tri√°ngulo (que consta de tres puntos) como entrada.  El segundo, como <code>TriangleStream</code> , configura un sombreador para generar una secuencia de tri√°ngulos para que cada v√©rtice use la estructura <code>geometryOutput</code> para transmitir sus datos. <br><br><div class="spoiler">  <b class="spoiler_title">Dijimos anteriormente que el sombreador recibir√° un v√©rtice y generar√° una brizna de hierba.</b>  <b class="spoiler_title">¬øPor qu√© entonces obtenemos un tri√°ngulo?</b> <div class="spoiler_text">  Ser√° menos costoso tomar un <code></code> como entrada.  Esto se puede hacer de la siguiente manera. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  Sin embargo, dado que nuestra malla entrante (en este caso <code>GrassPlane10x10</code> , ubicada en la carpeta <code>Mesh</code> ) tiene una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">topolog√≠a de tri√°ngulo</a> , esto provocar√° una falta de coincidencia entre la topolog√≠a de malla entrante y la primitiva de entrada requerida.  Aunque esto est√° <strong>permitido</strong> en DirectX HLSL, no est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">permitido en OpenGL</a> , por lo que se mostrar√° un error. </div></div><br>  Adem√°s, agregamos el √∫ltimo par√°metro entre corchetes sobre la declaraci√≥n de la funci√≥n: <code>[maxvertexcount(3)]</code> .  √âl le dice a la GPU que sacaremos (pero no estamos <strong>obligados</strong> a hacerlo) <em>no m√°s de</em> 3 v√©rtices.  Tambi√©n hacemos que <code>SubShader</code> use un sombreador geom√©trico al declararlo dentro de <code>Pass</code> . <br><br>  Nuestro sombreador geom√©trico no est√° haciendo nada todav√≠a;  Para dibujar un tri√°ngulo, agregue el siguiente c√≥digo dentro del sombreador geom√©trico. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Esto dio resultados muy extra√±os.  Cuando mueve la c√°mara, queda claro que el tri√°ngulo se representa en el <strong>espacio de</strong> la <strong>pantalla</strong> .  Esto es l√≥gico: dado que el sombreador geom√©trico se ejecuta inmediatamente antes de procesar los v√©rtices, le quita al sombreador de v√©rtices la responsabilidad de que los v√©rtices se muestren en <strong>el espacio de truncamiento</strong> .  Cambiaremos nuestro c√≥digo para reflejar esto. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; ‚Ä¶ // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Ahora nuestro tri√°ngulo se representa correctamente en el mundo.  Sin embargo, parece que solo se crea uno.  De hecho, se <em>dibuja</em> un tri√°ngulo para cada v√©rtice de nuestra malla, pero las posiciones asignadas a los v√©rtices del tri√°ngulo son <strong>constantes</strong> ; no cambian para cada v√©rtice entrante.  Por lo tanto, todos los tri√°ngulos est√°n ubicados uno encima del otro. <br><br>  Arreglaremos esto haciendo que las posiciones de v√©rtice salientes se <strong>desplacen en</strong> relaci√≥n con el punto entrante. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; ‚Ä¶ // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© algunos v√©rtices no crean un tri√°ngulo?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Aunque hemos determinado que la primitiva entrante ser√° un <strong>tri√°ngulo</strong> , una brizna de hierba se transmite solo desde <strong>uno</strong> de los puntos del tri√°ngulo, descartando los otros dos.  Por supuesto, podemos transferir una brizna de hierba desde los tres puntos entrantes, pero esto conducir√° al hecho de que los tri√°ngulos vecinos crean excesivamente briznas de hierba una encima de la otra. <br><br>  O puede resolver este problema tomando mallas que tengan el tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntos</a> de topolog√≠a como mallas entrantes del sombreador geom√©trico. </div></div><br>  Los tri√°ngulos ahora se dibujan correctamente, y su base se encuentra en el pico que los emite.  Antes de continuar, haga que el objeto <code>GrassPlane</code> <strong>inactivo</strong> en la escena y <code>GrassBall</code> objeto <code>GrassBall</code> .  Queremos que el c√©sped se genere correctamente en diferentes tipos de superficies, por lo que es importante probarlo en mallas de diferentes formas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  Hasta ahora, todos los tri√°ngulos se emiten en una direcci√≥n, y no hacia afuera de la superficie de la esfera.  Para resolver este problema, crearemos briznas de hierba en un <strong>espacio tangente</strong> . <br><br><h2>  2. Espacio tangente </h2><br>  Idealmente, nos gustar√≠a crear briznas de hierba estableciendo un ancho, altura, curvatura y rotaci√≥n diferentes, sin tener en cuenta el √°ngulo de la superficie desde la que se emite la brizna de hierba.  En pocas palabras, definimos una brizna de hierba en un espacio <strong>local para el v√©rtice que la emite</strong> , y luego la transformamos para que sea <strong>local a la malla</strong> .  Este espacio se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espacio tangente</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>En el espacio tangente, los ejes <strong>X</strong> , <strong>Y</strong> y <strong>Z</strong> se definen en relaci√≥n con la posici√≥n normal de la superficie (en nuestro caso, los v√©rtices).</i> <br><br>  Como cualquier otro espacio, podemos definir el espacio tangente de un v√©rtice con tres vectores: <strong>derecho</strong> , <strong>adelante</strong> y <strong>arriba</strong> .  Usando estos vectores, podemos crear una matriz para convertir la brizna de hierba de la tangente al espacio local. <br><br>  Puede acceder a los vectores a la <strong>derecha</strong> y <strong>hacia arriba</strong> agregando nuevos datos de v√©rtice de entrada. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; ‚Ä¶ // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } ‚Ä¶ // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) ‚Ä¶ // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  El tercer vector puede calcularse tomando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">producto</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vector</a> entre otros dos.  Un producto vectorial devuelve un vector <strong>perpendicular</strong> a dos vectores entrantes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© el resultado del producto vectorial se multiplica por la coordenada de la tangente w?</b> <div class="spoiler_text">  Al exportar una malla desde un editor 3D, generalmente tiene binormales (tambi√©n llamados <em>tangentes a dos puntos</em> ) ya almacenados en los datos de la malla.  En lugar de importar estos binormales, Unity simplemente toma la direcci√≥n de cada binormal y los asigna a la coordenada de la tangente <strong>w</strong> .  Esto le permite ahorrar memoria y, al mismo tiempo, ofrece la posibilidad de recrear el binormal correcto.  Una discusi√≥n detallada de este tema se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </div></div><br>  Teniendo los tres vectores, podemos crear una matriz para la transformaci√≥n entre tangentes y espacios locales.  Multiplicaremos cada v√©rtice de la brizna de hierba por esta matriz antes de pasarlo a <code>UnityObjectToClipPos</code> , que espera un v√©rtice en el espacio local. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Antes de usar la matriz, transferimos el c√≥digo de salida del v√©rtice a la funci√≥n para no escribir las mismas l√≠neas de c√≥digo una y otra vez.  Esto se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el principio DRY</a> , o <strong>no se repita</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } ‚Ä¶ // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Finalmente, multiplicamos los v√©rtices de salida por la matriz <code>tangentToLocal</code> , aline√°ndolos correctamente con la normalidad de su punto de entrada. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="imagen"></div><br>  Esto es m√°s parecido a lo que necesitamos, pero no del todo correcto.  El problema aqu√≠ es que inicialmente asignamos la direcci√≥n "arriba" (arriba) del eje <strong>Y</strong> ;  sin embargo, en el espacio tangente, la direcci√≥n hacia arriba generalmente se encuentra a lo largo del eje <strong>Z.</strong>  Ahora haremos estos cambios. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Apariencia de hierba </h2><br>  Para que los tri√°ngulos se vean m√°s como briznas de hierba, debes agregar colores y variaciones.  Comenzamos agregando un <strong>gradiente</strong> que baja desde la parte superior de la brizna de hierba. <br><br><h3>  3.1 gradiente de color </h3><br>  Nuestro objetivo es permitir que el artista establezca dos colores: superior e inferior, e interpolar entre estos dos colores, inclinar a la base de la brizna de hierba.  Estos colores ya est√°n definidos en el archivo de sombreado como <code>_TopColor</code> y <code>_BottomColor</code> .  Para su muestreo adecuado, debe pasar <strong>las coordenadas UV</strong> al sombreador de fragmentos. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; ‚Ä¶ // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) ‚Ä¶ // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; ‚Ä¶ // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Creamos coordenadas UV para una brizna de hierba en forma de tri√°ngulo, cuyos dos v√©rtices de la base se encuentran en la parte inferior izquierda y derecha, y el v√©rtice de la punta se encuentra en el centro en la parte superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>Coordenadas UV de los tres v√©rtices de las briznas de hierba.</i>  <i>Aunque pintamos las briznas de hierba con un degradado simple, una disposici√≥n similar de texturas le permite superponer texturas.</i> <br><br>  Ahora podemos muestrear los colores superior e inferior en el fragment shader con UV y luego interpolarlos con <code>lerp</code> .  Tambi√©n necesitaremos modificar los par√°metros del sombreador de fragmentos, haciendo <code>geometryOutput</code> como entrada, y no solo la posici√≥n de <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target ‚Ä¶ // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Direcci√≥n aleatoria de la cuchilla </h3><br>  Para crear variabilidad y darle al c√©sped un aspecto m√°s natural, haremos que cada brizna se vea en una direcci√≥n aleatoria.  Para hacer esto, necesitamos crear una matriz de rotaci√≥n que rote la brizna de hierba una cantidad aleatoria alrededor de su eje <strong>superior</strong> . <br><br>  Hay dos funciones en el archivo de sombreador que nos ayudar√°n a hacer esto: <code>rand</code> , que genera un n√∫mero aleatorio a partir de la entrada tridimensional, y <code>AngleAxis3x3</code> , que recibe el √°ngulo (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">radianes</a> ) y devuelve una matriz que gira este valor alrededor del eje especificado.  La √∫ltima funci√≥n funciona exactamente igual que la funci√≥n C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quaternion.AngleAxis</a> (solo <code>AngleAxis3x3</code> devuelve una matriz, no un cuaterni√≥n). <br><br>  La funci√≥n <code>rand</code> devuelve un n√∫mero en el rango 0 ... 1;  lo multiplicamos por <strong>2 Pi</strong> para obtener el rango completo de valores angulares. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Utilizamos la posici√≥n de entrada como semilla para una rotaci√≥n aleatoria.  Debido a esto, cada brizna de hierba tendr√° su propia rotaci√≥n, constante en cada cuadro. <br><br>  La rotaci√≥n se puede aplicar a la brizna de hierba multiplic√°ndola por la matriz <code>tangentToLocal</code> creada.  Tenga en cuenta que la multiplicaci√≥n de matrices <strong>no</strong> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conmutativa</a> ;  El orden de los operandos es <strong>importante</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Doblado aleatorio hacia adelante </h3><br>  Si todas las briznas de hierba est√°n perfectamente alineadas, aparecer√°n igual.  Esto puede ser adecuado para c√©sped bien cuidado, por ejemplo, en un c√©sped recortado, pero en la naturaleza el c√©sped no crece as√≠.  Crearemos una nueva matriz para rotar el c√©sped a lo largo del eje <strong>X</strong> , as√≠ como una propiedad para controlar esta rotaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 ‚Ä¶ // Add to the CGINCLUDE block. float _BendRotationRandom; ‚Ä¶ // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Nuevamente usamos la posici√≥n de la brizna de hierba como una semilla aleatoria, esta vez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">barriendo</a> para crear una semilla √∫nica.  Tambi√©n multiplicaremos <code>UNITY_PI</code> por <strong>0.5</strong> ;  Esto nos dar√° un intervalo aleatorio de 0 ... 90 grados. <br><br>  Nuevamente aplicamos esta matriz a trav√©s de la rotaci√≥n, multiplicando todo en el orden correcto. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Ancho y alto </h3><br>  Mientras que el tama√±o de la brizna de hierba se limita a un ancho de 1 unidad y una altura de 1 unidad.  Agregaremos propiedades para controlar el tama√±o, as√≠ como propiedades para agregar variaci√≥n aleatoria. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; ‚Ä¶ // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; ‚Ä¶ // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Los tri√°ngulos ahora son mucho m√°s como briznas de hierba, pero tambi√©n muy poco.  Simplemente no hay suficientes picos en la malla entrante para crear la impresi√≥n de un campo densamente cubierto. <br><br>  Una soluci√≥n es crear una nueva malla m√°s densa, ya sea usando C # o en un editor 3D.  Esto funcionar√°, pero no nos permitir√° controlar din√°micamente la densidad del c√©sped.  En su lugar, dividiremos la malla entrante mediante <strong>teselaci√≥n</strong> . <br><br><h2>  4. Teselaci√≥n </h2><br>  <strong>La teselaci√≥n</strong> es una etapa opcional de la canalizaci√≥n de representaci√≥n, realizada despu√©s del sombreador de v√©rtices y antes del sombreador geom√©trico (si lo hay).  Su tarea es subdividir una superficie entrante en muchas primitivas.  La teselaci√≥n se implementa en dos pasos programables: sombreadores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">casco</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dominio</a> . <br><br>  Para los sombreadores de superficie, Unity tiene una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n de teselaci√≥n incorporada</a> .  Sin embargo, dado que <strong>no usamos</strong> sombreadores de superficie, tendremos que implementar nuestros propios sombreadores de shell y dominio.  En este art√≠culo, no discutir√© la implementaci√≥n de teselaci√≥n en detalle, y simplemente usaremos el archivo <code>CustomTessellation.cginc</code> existente.  Este archivo est√° adaptado del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de Catlike Coding</a> , que es una excelente fuente de informaci√≥n sobre la implementaci√≥n de teselaci√≥n en Unity. <br><br>  Si incluimos el objeto <code>TessellationExample</code> en la escena, veremos que ya tiene material que implementa la teselaci√≥n.  Cambiar la propiedad <strong>Uniforme de teselaci√≥n</strong> demuestra el efecto de subdivisi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Implementamos teselaci√≥n en el sombreador de hierba para controlar la densidad del plano y, por lo tanto, para controlar la cantidad de briznas de hierba generadas.  Primero debe agregar el archivo <code>CustomTessellation.cginc</code> .  Nos referiremos a √©l por su ruta <em>relativa</em> al sombreador. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Si abre <code>CustomTessellation.cginc</code> , notar√° que las <code>vertexOutput</code> <code>vertexInput</code> y <code>vertexOutput</code> , as√≠ como los sombreadores de v√©rtices, ya est√°n definidos en √©l.  No es necesario redefinirlos en nuestro sombreador de hierba;  Pueden ser eliminados. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Tenga en cuenta que el sombreador de v√©rtices <code>vert</code> en <code>CustomTessellation.cginc</code> simplemente pasa la entrada directamente a la etapa de teselaci√≥n;  La funci√≥n <code>vertexOutput</code> , llamada dentro del sombreador de dominio, asume la tarea de crear la estructura <code>vertexOutput</code> . <br><br>  Ahora podemos agregar sombreadores de <strong>shell</strong> y <strong>dominio al</strong> sombreador de hierba.  Tambi√©n agregaremos una nueva propiedad <code>_TessellationUniform</code> para controlar el tama√±o de la unidad: la variable correspondiente a esta propiedad ya se ha declarado en <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 ‚Ä¶ // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  Ahora, cambiar la propiedad <strong>Uniforme de teselaci√≥n</strong> nos permite controlar la densidad del c√©sped.  Encontr√© que se obtienen buenos resultados con un valor de <strong>5</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. El viento </h2><br>  Implementamos el viento muestreando la <strong>textura de distorsi√≥n</strong> .  Esta textura se ver√° como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un mapa normal</a> , solo en ella habr√° solo dos en lugar de tres canales.  Utilizaremos estos dos canales como direcciones del viento a lo largo de <strong>X</strong> e <strong>Y.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Antes de muestrear la textura del viento, necesitamos crear una coordenada UV.  En lugar de usar las coordenadas de textura asignadas a la malla, aplicamos la posici√≥n del punto entrante.  Gracias a esto, si hay varias mallas de hierba en el mundo, se crear√° la ilusi√≥n de que todas son parte del mismo sistema e√≥lico.  Tambi√©n utilizamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">variable incorporada</a> <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shader</a> para desplazar la textura del viento a lo largo de la superficie de la hierba. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) ‚Ä¶ // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; ‚Ä¶ // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Aplicamos la escala y el desplazamiento de <code>_WindDistortionMap</code> a la posici√≥n, y luego lo <code>_Time.y</code> a <code>_Time.y</code> , escalado a <code>_WindFrequency</code> .  Ahora usaremos estos rayos UV para tomar muestras de la textura y crear una propiedad para controlar la fuerza del viento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 ‚Ä¶ // Add to the CGINCLUDE block. float _WindStrength; ‚Ä¶ // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Tenga en cuenta que escalamos el valor muestreado de la textura del intervalo 0 ... 1 al intervalo -1 ... 1.  A continuaci√≥n, podemos crear un vector normalizado que denote la direcci√≥n del viento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Ahora podemos crear una matriz para rotar alrededor de este vector y multiplicarlo por nuestra matriz de <code>transformationMatrix</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); ‚Ä¶ // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Finalmente, transferimos la textura <code>Wind</code> (ubicada en la ra√≠z del proyecto) al campo <strong>Mapa de distorsi√≥n</strong> del <strong>viento</strong> del material de hierba en el editor de Unity.  Tambi√©n establecemos el par√°metro de <strong>mosaico</strong> de la textura en <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Si el c√©sped no se est√° animando en la ventana de <strong>Escena</strong> , haga clic en el bot√≥n <strong>Alternar skybox, niebla y otros efectos</strong> para habilitar materiales animados. <br><br>    ,      ,  ,    , -       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i>      ,     ( <strong></strong> ),      ( <strong></strong> ).</i> <br><br>   ,    ,       .    <strong> </strong>   <code>windRotation</code>  <code>bendRotationMatrix</code> ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2> 6.   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora las hojas individuales de hierba est√°n definidas por un tri√°ngulo. A grandes distancias, esto no es un problema, pero cerca de la brizna de hierba se ven muy r√≠gidos y geom√©tricos, en lugar de org√°nicos y vivos. Arreglaremos esto construyendo briznas de hierba a partir de varios tri√°ngulos y dobl√°ndolos a lo largo de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curva</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada brizna de hierba se dividir√° en varios </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmentos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cada segmento tendr√° una forma rectangular y constar√° de dos tri√°ngulos, con la excepci√≥n del segmento superior: ser√° un tri√°ngulo que denota la punta de la brizna de hierba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, hemos dibujado solo tres v√©rtices, creando un solo tri√°ngulo. ¬øC√≥mo, entonces, si hay m√°s v√©rtices, el sombreador geom√©trico sabe cu√°les unir y formar tri√°ngulos? La respuesta est√° en la estructura de datos.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despojar tri√°ngulo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Los primeros tres v√©rtices se unen y forman un tri√°ngulo, y cada nuevo v√©rtice forma un tri√°ngulo con los dos anteriores.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una brizna de hierba subdividida, representada como una franja triangular y creaba un v√©rtice a la vez. Despu√©s de los primeros tres v√©rtices, cada nuevo v√©rtice forma un nuevo tri√°ngulo con los dos v√©rtices anteriores.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto no solo es m√°s eficiente en t√©rminos de uso de memoria, sino que tambi√©n le permite crear de forma f√°cil y r√°pida secuencias de tri√°ngulos en su c√≥digo. Si quisi√©ramos crear varias franjas de tri√°ngulos, podr√≠amos llamar a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">RestartStrip</font></a><font style="vertical-align: inherit;"> para la </font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funci√≥n </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Antes de comenzar a dibujar m√°s v√©rtices desde el sombreador geom√©trico, necesitamos aumentarlo </font><font style="vertical-align: inherit;">. Usaremos el dise√±o </font><font style="vertical-align: inherit;">para permitir que el autor del sombreador controle el n√∫mero de segmentos y calcule el n√∫mero de v√©rtices mostrados a partir de √©l.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>maxvertexcount</code><font style="vertical-align: inherit;"></font><code>#define</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 ‚Ä¶ // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, establecemos el n√∫mero de segmentos en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y actualizamos </font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular el n√∫mero de v√©rtices en funci√≥n del n√∫mero de segmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear una brizna de hierba segmentada, usamos un ciclo </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cada iteraci√≥n del bucle agregar√° </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos v√©rtices</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">izquierdo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">derecho</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Despu√©s de completar la punta, agregamos el √∫ltimo v√©rtice en la punta de la brizna de hierba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de hacer esto, ser√° √∫til mover parte de la posici√≥n inform√°tica de los v√©rtices de las hojas de hierba del c√≥digo a la funci√≥n, porque usaremos este c√≥digo varias veces dentro y fuera del bucle. Agregue lo </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente </font><font style="vertical-align: inherit;">al bloque </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta funci√≥n realiza las mismas tareas porque pasa los argumentos que pasamos previamente </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para generar los v√©rtices de la brizna de hierba. </font><font style="vertical-align: inherit;">Al obtener una posici√≥n, altura y ancho, transforma correctamente el v√©rtice utilizando la matriz transmitida y le asigna una coordenada UV. </font><font style="vertical-align: inherit;">Actualizaremos el c√≥digo existente para que la funci√≥n funcione correctamente.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n comenz√≥ a funcionar correctamente y estamos listos para mover el c√≥digo de generaci√≥n de v√©rtices al bucle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agregue lo </font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente </font><font style="vertical-align: inherit;">debajo de la l√≠nea </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anunciamos un ciclo que se ejecutar√° una vez para cada segmento de brizna de hierba. </font><font style="vertical-align: inherit;">Dentro del bucle, agregue una variable </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta variable almacenar√° un valor en el rango 0 ... 1, que indica qu√© tan lejos nos hemos movido a lo largo de la brizna de hierba. </font><font style="vertical-align: inherit;">Usamos este valor para calcular el ancho y la altura del segmento en cada iteraci√≥n del bucle.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al subir una brizna de hierba, la altura aumenta y el ancho disminuye. </font><font style="vertical-align: inherit;">Ahora podemos agregar llamadas al bucle </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para agregar v√©rtices a la secuencia de tri√°ngulos. </font><font style="vertical-align: inherit;">Tambi√©n agregaremos una llamada </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuera del bucle para crear la punta de la brizna de hierba.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); ‚Ä¶ // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); ‚Ä¶ // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eche un vistazo a la l√≠nea con la declaraci√≥n </font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: aqu√≠ seleccionamos una de las dos matrices de transformaci√≥n: tomamos </font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los v√©rtices de la base y </font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los dem√°s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las briznas de hierba ahora se dividen en muchos segmentos, pero la superficie de la brizna todav√≠a es plana: los nuevos tri√°ngulos a√∫n no est√°n involucrados. </font><font style="vertical-align: inherit;">Vamos a a√±adir una brizna de hierba curvatura, cambiando la posici√≥n del v√©rtice de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Primero, necesitamos modificar la funci√≥n </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que obtenga un desplazamiento en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que llamaremos </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) ‚Ä¶ // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular el desplazamiento de cada v√©rtice, sustituimos un </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font><font style="vertical-align: inherit;">en la funci√≥n </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Despu√©s de subir </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a una potencia, su efecto sobre el desplazamiento hacia adelante ser√° </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no lineal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y convertir√° la brizna de hierba en una curva.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; ‚Ä¶ // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; ‚Ä¶ // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; ‚Ä¶ // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); ‚Ä¶ // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un c√≥digo bastante extenso, pero todo el trabajo se realiza de manera similar al ancho y la altura de la brizna de hierba. </font><font style="vertical-align: inherit;">Con valores m√°s bajos </font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtenemos un c√©sped ordenado y bien cuidado, y valores m√°s grandes dar√°n el efecto contrario.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Iluminaci√≥n y sombras. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como paso final para completar el sombreador, agregaremos la capacidad de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyectar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recibir</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sombras. </font><font style="vertical-align: inherit;">Tambi√©n agregaremos iluminaci√≥n simple desde la fuente principal de luz direccional.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 Sombras de fundici√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para proyectar sombras en Unity, debe agregar una segunda pasada al sombreador. Este pasaje ser√° utilizado por las fuentes de luz creadoras de sombras en la escena para representar la profundidad de la hierba en su </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa de sombras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto significa que el sombreador geom√©trico tendr√° que ser lanzado en el pasaje de sombra, para que las hojas de hierba puedan proyectar sombras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el sombreador geom√©trico est√° escrito dentro de bloques </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos usarlo en cualquier paso del archivo. Cree un segundo pase que use los mismos sombreadores que el primero, con la excepci√≥n del sombreador de fragmentos: definiremos uno nuevo en el que escribiremos una macro que procese la salida.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de crear un nuevo sombreador de fragmentos, hay un par de diferencias importantes en este pasaje. </font><font style="vertical-align: inherit;">La etiqueta </font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">importa </font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esto le dice a Unity que este pasaje debe usarse para representar el objeto en mapas de sombras. </font><font style="vertical-align: inherit;">Tambi√©n hay una directiva de preprocesador aqu√≠ </font></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Asegura que el sombreador compila todas las opciones necesarias para proyectar sombras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haz que el objeto del juego est√© </font></font><code>Fence</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la escena; </font><font style="vertical-align: inherit;">entonces obtenemos una superficie sobre la cual las briznas de hierba pueden proyectar una sombra.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 Obteniendo sombras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de que Unity renderiza el mapa de sombras desde el punto de vista de la fuente de luz que crea la sombra, lanza un pasaje que "recoge" las sombras en la textura del </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espacio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><strong><font style="vertical-align: inherit;">pantalla</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para muestrear esta textura, necesitaremos calcular las posiciones de los v√©rtices en el espacio de la pantalla y transferirlos al sombreador de fragmentos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; ‚Ä¶ // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el sombreador de fragmentos del pasaje, </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos usar una macro para obtener un valor que </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indique si la superficie est√° en sombras o no. </font><font style="vertical-align: inherit;">Este valor est√° en el rango 0 ... 1, donde 0 es sombreado completo, 1 es iluminaci√≥n completa.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© la coordenada UV del espacio de la pantalla se llama _ShadowCoord? </font><font style="vertical-align: inherit;">Esto no cumple con las convenciones de nomenclatura anteriores.</font></font></b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, necesitamos hacer que el sombreador est√© configurado correctamente para recibir sombras. </font><font style="vertical-align: inherit;">Para hacer esto, agregaremos una </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directiva de preprocesador </font><font style="vertical-align: inherit;">al pase </font><font style="vertical-align: inherit;">para que compile todas las opciones de sombreador necesarias.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al acercar la c√°mara, podemos observar artefactos en la superficie de las briznas de hierba; </font><font style="vertical-align: inherit;">son causadas por el hecho de que las hojas individuales de hierba proyectan sombras sobre s√≠ mismas. </font><font style="vertical-align: inherit;">Podemos solucionar esto aplicando un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desplazamiento lineal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o moviendo las posiciones de los v√©rtices en el espacio de truncamiento ligeramente lejos de la pantalla. </font><font style="vertical-align: inherit;">Utilizaremos la macro Unity para esto y la incluiremos en el dise√±o </font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que la operaci√≥n se realice solo en la ruta de la sombra.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de aplicar el desplazamiento de sombra lineal, los artefactos de sombra en forma de rayas desaparecen de la superficie de los tri√°ngulos.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© hay artefactos a lo largo de los bordes de las hojas de hierba sombreadas?</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    ‚Äî  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3 Iluminaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaremos la iluminaci√≥n utilizando un algoritmo de c√°lculo de iluminaci√≥n difusa muy simple y com√∫n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... donde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es lo normal a la superficie, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la direcci√≥n normalizada de la fuente principal de iluminaci√≥n direccional, e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la iluminaci√≥n calculada. </font><font style="vertical-align: inherit;">En este tutorial </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementaremos iluminaci√≥n indirecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, las normales no est√°n asignadas a los v√©rtices de las briznas de hierba. </font><font style="vertical-align: inherit;">Al igual que con las posiciones de v√©rtice, primero calculamos las normales en el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espacio tangente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y luego las convertimos a locales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cantidad de curvatura de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la </font><strong><font style="vertical-align: inherit;">hoja</font></strong><font style="vertical-align: inherit;"> es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , todas las hojas de hierba en el espacio tangente se dirigen en una direcci√≥n: directamente opuestas al eje </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como primer paso de nuestra soluci√≥n, calculamos lo normal, suponiendo que no haya curvatura.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definido como directamente opuesto al eje </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se transforma mediante la misma matriz que usamos para convertir los puntos tangentes al espacio local. </font><font style="vertical-align: inherit;">Ahora podemos pasarlo a una funci√≥n </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego a una estructura </font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); ‚Ä¶ // Add to the geometryOutput struct. float3 normal : NORMAL; ‚Ä¶ // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) ‚Ä¶ // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note que antes de la conclusi√≥n, transformamos lo normal en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espacio mundial</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">La unidad transmite a los sombreadores la direcci√≥n de la fuente principal de luz direccional en el espacio mundial, por lo que esta transformaci√≥n es necesaria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos visualizar las normales en el fragmento de sombreador </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para verificar el resultado de nuestro trabajo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se asigna </font><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">valor </font><font style="vertical-align: inherit;">en nuestro sombreador </font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se representan ambos lados de la brizna de hierba. </font><font style="vertical-align: inherit;">Para que lo normal se dirija en la direcci√≥n correcta, usamos un par√°metro auxiliar </font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que agregamos al sombreador de fragmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El argumento </font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver√° un </font><font style="vertical-align: inherit;">n√∫mero </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positivo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si mostramos la cara frontal de la superficie, y un </font><font style="vertical-align: inherit;">n√∫mero </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negativo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si es lo contrario. </font><font style="vertical-align: inherit;">Usamos esto en el c√≥digo anterior para voltear lo normal si es necesario.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cantidad de curvatura de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la </font><strong><font style="vertical-align: inherit;">cuchilla es</font></strong><font style="vertical-align: inherit;"> mayor que 1, la posici√≥n </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tangente de </font><font style="vertical-align: inherit;">cada v√©rtice se desplazar√° por la cantidad que se </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasa a la funci√≥n </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usaremos este valor para escalar proporcionalmente el eje </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de las </font><font style="vertical-align: inherit;">normales.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, agregue el c√≥digo al sombreador de fragmentos para combinar las sombras, la iluminaci√≥n direccional y la iluminaci√≥n ambiental. </font><font style="vertical-align: inherit;">Recomiendo estudiar informaci√≥n m√°s detallada sobre la implementaci√≥n de iluminaci√≥n personalizada en sombreadores en mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial sobre sombreadores de toon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este tutorial, el c√©sped cubre un √°rea peque√±a de 10x10 unidades. </font><font style="vertical-align: inherit;">Para que el sombreador cubra grandes espacios abiertos mientras mantiene un alto rendimiento, se deben introducir optimizaciones. </font><font style="vertical-align: inherit;">Puede aplicar la teselaci√≥n en funci√≥n de la distancia, de modo que se eliminen menos briznas de hierba de la c√°mara. </font><font style="vertical-align: inherit;">Adem√°s, a largas distancias, en lugar de hojas individuales de hierba, se pueden dibujar grupos de hojas de hierba usando un solo cuadril√°tero con una textura superpuesta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Standard Assets</a>  Unity.      ,      .</i> <br><br>            ,               Unity   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  GitHub</a> ,           G-. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     GitHub</a> <br><br><h3> :  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin interoperabilidad, los efectos gr√°ficos pueden parecer est√°ticos o sin vida para los jugadores. </font><font style="vertical-align: inherit;">Este tutorial ya es muy largo, por lo que no agregu√© una secci√≥n sobre la interacci√≥n de los objetos del mundo con la hierba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una implementaci√≥n ingenua de hierbas interactivas contendr√≠a dos componentes: algo en el mundo del juego que puede </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmitir datos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al sombreador para decirle con qu√© parte de la hierba se est√° interactuando y codificar en el sombreador para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpretar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estos datos. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Aqu√≠</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se muestra un ejemplo de c√≥mo se puede implementar esto con agua </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se puede adaptar para trabajar con hierba; </font><font style="vertical-align: inherit;">en lugar de dibujar ondas en el lugar donde est√° el personaje, puedes girar la brizna de hierba hacia abajo para simular los efectos de los pasos.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458060/">https://habr.com/ru/post/458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458046/index.html">Hoja de trucos de Gradle</a></li>
<li><a href="../458048/index.html">Delegaci√≥n como herramienta de gesti√≥n</a></li>
<li><a href="../458050/index.html">¬øC√≥mo fue el Mobius 2019 Piter (y un poco sobre el pr√≥ximo Mobius)</a></li>
<li><a href="../458052/index.html">AMA con Habr.10. √öltimo * problema</a></li>
<li><a href="../458056/index.html">La gran entrevista con Martin Kleppmann: "Descubrir el futuro de los sistemas de datos distribuidos"</a></li>
<li><a href="../458062/index.html">Descripci√≥n general de la plataforma UserGate</a></li>
<li><a href="../458064/index.html">PVS-Studio en las nubes - Ejecuci√≥n del an√°lisis en Travis CI</a></li>
<li><a href="../458068/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../458070/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../458072/index.html">PVS-Studio va a las nubes: an√°lisis de lanzamiento en Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>