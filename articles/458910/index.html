<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙈 🗼 👨🏾‍🤝‍👨🏼 Benchmarking PostgreSQL con grandes páginas de Linux 👨🏿‍🤝‍👨🏼 ❗️ 🏆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El kernel de Linux proporciona una amplia gama de opciones de configuración que pueden afectar el rendimiento. Se trata de obtener la configuración co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmarking PostgreSQL con grandes páginas de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458910/"><img width="40%" align="left" src="https://habrastorage.org/webt/u0/hs/uc/u0hsucgpyp_pgw1mwtyzdtkvd1o.jpeg">  El kernel de Linux proporciona una amplia gama de opciones de configuración que pueden afectar el rendimiento.  Se trata de obtener la configuración correcta para su aplicación y carga de trabajo.  Como cualquier otra base de datos, PostgreSQL usa el kernel de Linux para una configuración óptima.  Las configuraciones mal ajustadas pueden dar como resultado un bajo rendimiento.  Por lo tanto, es importante que mida el rendimiento de la base de datos después de cada sesión de ajuste para evitar la degradación del rendimiento.  En una de mis publicaciones anteriores, "Ajuste de los parámetros del kernel de Linux para la optimización de PostgreSQL", describí algunos de los parámetros del kernel de Linux más útiles y cómo pueden ayudarlo a mejorar el rendimiento de la base de datos.  Ahora voy a compartir los resultados de mi prueba después de configurar grandes páginas de Linux con una carga de trabajo PostgreSQL diferente.  Realicé un conjunto exhaustivo de pruebas para diferentes tamaños de carga de PostgreSQL y el número simultáneo de clientes. <br><br><h2>  Máquina de prueba </h2><br><ul><li>  Servidor Supermicro: <br><ul><li>  CPU Intel® Xeon® E5-2683 v3 @ 2.00GHz </li><li>  2 enchufes / 28 núcleos / 56 hilos </li><li>  Memoria: 256 GB de RAM </li><li>  Almacenamiento: SAMSUNG SM863 1.9TB Enterprise SSD </li><li>  Sistema de archivos: ext4 / xfs </li></ul></li><li>  SO: Ubuntu 16.04.4, kernel 4.13.0-36-generic </li><li>  PostgreSQL: versión 11 </li></ul><a name="habracut"></a><br><h2>  Configuración del kernel de Linux </h2><br>  Usé la configuración predeterminada del kernel sin ninguna optimización / ajuste que no sea deshabilitar páginas grandes transparentes (Transparent HugePages).  Las páginas grandes transparentes están habilitadas de forma predeterminada y resaltan el tamaño de la página, que puede no recomendarse para la base de datos.  Las bases de datos generalmente requieren páginas grandes de tamaño fijo que no están cubiertas por páginas grandes transparentes.  Por lo tanto, siempre se recomienda deshabilitar esta función y usar páginas grandes clásicas de forma predeterminada. <br><br><h2>  Configuración de PostgreSQL </h2><br>  Utilicé la configuración uniforme de PostgreSQL para todas las pruebas para registrar diferentes cargas de trabajo de PostgreSQL con diferentes configuraciones para grandes páginas de Linux.  Aquí está la configuración de PostgreSQL utilizada para todas las pruebas: <br><br>  <sup>postgresql.conf</sup> <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">shared_buffers</span></span> = <span class="hljs-string"><span class="hljs-string">'64GB'</span></span> work_mem = <span class="hljs-string"><span class="hljs-string">'1GB'</span></span> random_page_cost = <span class="hljs-string"><span class="hljs-string">'1'</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'2GB'</span></span> synchronous_commit = <span class="hljs-string"><span class="hljs-string">'on'</span></span> seq_page_cost = <span class="hljs-string"><span class="hljs-string">'1'</span></span> max_wal_size = <span class="hljs-string"><span class="hljs-string">'100GB'</span></span> checkpoint_timeout = <span class="hljs-string"><span class="hljs-string">'10min'</span></span> synchronous_commit = <span class="hljs-string"><span class="hljs-string">'on'</span></span> checkpoint_completion_target = <span class="hljs-string"><span class="hljs-string">'0.9'</span></span> autovacuum_vacuum_scale_factor = <span class="hljs-string"><span class="hljs-string">'0.4'</span></span> effective_cache_size = <span class="hljs-string"><span class="hljs-string">'200GB'</span></span> min_wal_size = <span class="hljs-string"><span class="hljs-string">'1GB'</span></span> wal_compression = <span class="hljs-string"><span class="hljs-string">'ON'</span></span></code> </pre> <br><h2>  Esquema de prueba </h2><br>  En las pruebas, el esquema de pruebas juega un papel importante.  Todas las pruebas se realizan tres veces durante 30 minutos para cada ejecución.  Tomé el promedio de estos tres indicadores.  Las pruebas se realizaron utilizando la herramienta de prueba de rendimiento PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgbench</a> .  pgbench funciona con un factor de escala, con un factor de escala de aproximadamente 16 MB de carga de trabajo. <br><br><h2>  Páginas grandes (páginas enormes) </h2><br>  Linux, por defecto, usa páginas de memoria 4K junto con páginas grandes.  BSD tiene Super páginas, mientras que Windows tiene páginas grandes.  PostgreSQL solo admite páginas grandes (Linux).  En casos de alto uso de memoria, las páginas pequeñas reducen el rendimiento.  Al instalar páginas grandes, aumenta la memoria asignada para la aplicación y, en consecuencia, reduce los costos operativos que surgen durante la asignación / intercambio;  es decir, aumenta la productividad con páginas grandes. <br><br>  Aquí está la configuración para páginas grandes cuando se utiliza un tamaño de página grande de 1 GB.  Siempre puede obtener esta información de / proc. <br><br>  <sup>$ cat / proc / meminfo |</sup>  <sup>grep -i enorme</sup> <br><br><pre> <code class="nginx hljs">AnonHugePages: 0 <span class="hljs-attribute"><span class="hljs-attribute">kB</span></span> ShmemHugePages: <span class="hljs-number"><span class="hljs-number">0</span></span> kB HugePages_Total: <span class="hljs-number"><span class="hljs-number">100</span></span> HugePages_Free: <span class="hljs-number"><span class="hljs-number">97</span></span> HugePages_Rsvd: <span class="hljs-number"><span class="hljs-number">63</span></span> HugePages_Surp: <span class="hljs-number"><span class="hljs-number">0</span></span> Hugepagesize: <span class="hljs-number"><span class="hljs-number">1048576</span></span> kB</code> </pre> <br>  Para obtener más información sobre páginas grandes, lea mi publicación de blog anterior. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.percona.com/blog/2018/08/29/tune-linux-kernel-parameters-for-postgresql-optimization/</a> <br><br>  Por lo general, las páginas grandes tienen 2 MB y 1 GB, por lo que tiene sentido usar 1 GB en lugar de los 2 MB mucho más pequeños. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-transhuge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://kerneltalks.com/services/what-is-huge-pages-in-linux/</a> <br><br><h2>  Resultados de la prueba </h2><br>  Esta prueba muestra el efecto general de varios tamaños de páginas grandes.  El primer conjunto de pruebas se creó con el tamaño de página predeterminado en Linux 4K sin incluir páginas grandes.  Tenga en cuenta que las páginas enormes transparentes también se deshabilitaron y permanecieron deshabilitadas durante todas estas pruebas. <br><br>  Luego, el segundo conjunto de pruebas se realizó en páginas grandes de 2 MB.  Finalmente, el tercer conjunto de pruebas se ejecuta con páginas grandes de 1 GB. <br><br>  Todas estas pruebas se realizaron en PostgreSQL versión 11. Los conjuntos incluyen una combinación de diferentes tamaños de la base de datos y los clientes.  El siguiente gráfico muestra los resultados comparativos de rendimiento para estas pruebas con TPS (transacciones por segundo) en el eje Y, el tamaño de la base de datos y el número de clientes por tamaño de base de datos en el eje X. <br><br><img src="https://habrastorage.org/webt/1k/pu/1r/1kpu1rufj-fpl3iszxtzvnjxfgg.png"><br><br>  Se puede ver en el gráfico anterior que la ganancia de rendimiento con páginas grandes aumenta con el número de clientes y el tamaño de la base de datos, si el tamaño permanece en el búfer previamente asignado en la memoria compartida. <br><br>  Esta prueba muestra TPS en comparación con el número de clientes.  En este caso, el tamaño de la base de datos es de 48 GB.  En el eje Y, tenemos TPS, y en el eje X, tenemos el número de clientes conectados.  El tamaño de la base de datos es lo suficientemente pequeño como para caber en un búfer compartido que se establece en 64 GB. <br><br><img src="https://habrastorage.org/webt/fc/j_/kn/fcj_knw5ujqg-vvyzcxnl2wkclu.png"><br><br>  Si las páginas grandes se configuran en 1 GB, cuantos más clientes, mayor será la ganancia relativa de rendimiento. <br><br>  El siguiente gráfico es el mismo que el anterior, excepto por el tamaño de la base de datos de 96 GB.  Esto excede el tamaño del búfer compartido, que se establece en 64 GB. <br><br><img src="https://habrastorage.org/webt/z8/6r/je/z86rjeljjqfr_nyaylzzpv7xf9q.png"><br><br>  La observación clave aquí es que el rendimiento con páginas grandes de 1 GB aumenta a medida que aumenta el número de clientes y, en última instancia, proporciona más rendimiento que las páginas grandes de 2 MB o el tamaño de página estándar de 4 KB. <br><br>  Esta prueba muestra TPS dependiendo del tamaño de la base de datos.  En este caso, el número de clientes conectados es 32. En el eje Y, tenemos TPS, y en el eje X - tamaños de base de datos. <br><br><img src="https://habrastorage.org/webt/cg/90/oi/cg90oidu2mlqyp40deo9fzcmlki.png"><br><br>  Como se esperaba, cuando la base de datos va más allá de las páginas grandes preasignadas, el rendimiento se reduce significativamente. <br><br><h2>  Resumen </h2><br>  Una de mis recomendaciones clave es que debemos desactivar Transparent HugePages.  Verá la mayor ganancia de rendimiento cuando la base de datos se coloca en un búfer compartido con páginas grandes habilitadas.  Elegir el tamaño de páginas grandes requiere una pequeña cantidad de prueba y error, pero esto puede conducir a un aumento significativo en TPS cuando el tamaño de la base de datos es grande, pero sigue siendo lo suficientemente pequeño como para caber en un búfer compartido. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458910/">https://habr.com/ru/post/458910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458900/index.html">Cartuchos de consola como módems</a></li>
<li><a href="../458902/index.html">5 errores comunes de Python para principiantes</a></li>
<li><a href="../458904/index.html">Visualización del número de victorias para los equipos de la NBA utilizando gráficos de barras animados en R</a></li>
<li><a href="../458906/index.html">[Ekaterimburgo, anuncio] Flutteron - un taller sobre desarrollo en Flutter</a></li>
<li><a href="../458908/index.html">Escaneo de documentos a través de la red</a></li>
<li><a href="../458912/index.html">Migrar a Zimbra con imapsync</a></li>
<li><a href="../458914/index.html">Qué (no) necesitas saber para crear juegos en Unity</a></li>
<li><a href="../458916/index.html">Debajo del capó de React. Escribimos nuestra implementación desde cero</a></li>
<li><a href="../458918/index.html">Lo que puedes aprender del diseño de juegos hiper-casuales</a></li>
<li><a href="../458920/index.html">Conferencia para fanáticos de DevOps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>