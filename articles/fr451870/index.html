<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ±Ô∏è üßíüèª ü§± Fonctionnalit√©s C ++ modernes que tous les programmeurs doivent conna√Ætre ü•• üçú üë©üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur du document, dont nous publions la traduction aujourd'hui, dit que le C ++, dans sa forme moderne, par rapport √† ce qu'√©tait ce langage il y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnalit√©s C ++ modernes que tous les programmeurs doivent conna√Ætre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  L'auteur du document, dont nous publions la traduction aujourd'hui, dit que le C ++, dans sa forme moderne, par rapport √† ce qu'√©tait ce langage il y a plusieurs ann√©es, a consid√©rablement chang√© pour le mieux.  Bien s√ªr, ces changements ne se sont pas produits tout de suite.  Par exemple, dans l'ancien temps, C ++ manquait de dynamisme.  Ce n'√©tait pas facile de trouver une personne qui pourrait dire qu'il a de tendres sentiments pour cette langue.  Tout a chang√© lorsque les responsables de la normalisation de la langue ont d√©cid√© de c√©der la place aux innovations.  En 2011, le C ++ est devenu un langage dynamique, un langage en constante √©volution et qui provoque chez les programmeurs des √©motions beaucoup plus positives. <br><br>  Ne pensez pas que la langue est devenue plus facile.  Il peut encore √™tre appel√© l'un des langages de programmation les plus complexes et les plus utilis√©s, sinon le plus complexe.  Mais le C ++ moderne est devenu beaucoup plus convivial qu'auparavant. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Aujourd'hui, nous allons parler de certaines des nouvelles fonctionnalit√©s du langage (√† commencer par C ++ 11, qui, soit dit en passant, a d√©j√† 8 ans), qui seront utiles pour tout programmeur. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mot-cl√© automatique</font> </h2><br>  Depuis que le mot cl√© <code>auto</code> est apparu en C ++ 11, la vie des programmeurs est devenue plus facile.  Gr√¢ce √† ce mot-cl√©, le compilateur peut sortir des types de variables au moment de la compilation, ce qui nous √©vite d'avoir √† toujours sp√©cifier les types nous-m√™mes.  Cela s'est av√©r√© tr√®s pratique, par exemple, dans les cas o√π vous devez travailler avec des types de donn√©es tels que <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Lorsque vous utilisez le mot cl√© <code>auto</code> , il y a quelques √©l√©ments √† consid√©rer.  Prenons un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Faites attention √† la derni√®re ligne de cet exemple, le commentaire sur lequel est marqu√© <code>#1</code> (ci-apr√®s, de mani√®re similaire, nous marquerons les lignes que nous analyserons apr√®s les exemples).  Il n'y a pas d'initialiseur dans cette ligne, vous ne pouvez pas le faire.  Le code situ√© sur cette ligne emp√™che le compilateur de savoir quel doit √™tre le type de la variable correspondante. <br><br>  Initialement, le mot cl√© <code>auto</code> en C ++ √©tait assez limit√©.  Ensuite, dans les versions plus r√©centes de la langue, <code>auto</code> fonctionnalit√©s ajout√©es <code>auto</code> .  Voici un autre exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  Les lignes <code>#1</code> et <code>#2</code> appliquent l'initialisation variable √† l'aide d'accolades - une autre nouvelle fonctionnalit√© de C ++ 11. <br><br>  N'oubliez pas que lors de l'utilisation du mot cl√© <code>auto</code> , le compilateur doit avoir un moyen d'inf√©rer le type de la variable. <br><br>  Maintenant, une question int√©ressante.  Que se passe-t-il si vous utilisez un mod√®le comme <code>auto a = {1, 2, 3}</code> ?  Qu'est ce que c'est  Vecteur ou cause d'erreur de compilation? <br><br>  En fait, une construction de la forme <code>std::initializer_list&lt;type&gt;</code> est apparue en C ++ 11.  La liste entre parenth√®ses des valeurs d'initialisation sera trait√©e comme un conteneur √† l'aide du mot cl√© <code>auto</code> . <br><br>  Et enfin, comme d√©j√† mentionn√©, l'inf√©rence de type par le compilateur peut √™tre extr√™mement utile si vous devez travailler avec des structures de donn√©es complexes.  Voici un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Jetez un oeil √† la ligne <code>#1</code> .  L'expression <code>auto [v1,v2] = itr.second</code> repr√©sente une nouvelle fonctionnalit√© de C ++ 17. Il s'agit de la soi-disant d√©composition lors de la d√©claration de variables.  Dans les versions pr√©c√©dentes de la langue, chaque valeur devait √™tre extraite individuellement.  Gr√¢ce √† ce m√©canisme, effectuer de telles op√©rations est devenu beaucoup plus pratique. <br><br>  De plus, si vous devez travailler avec des donn√©es √† l'aide de liens, il suffit d'ajouter un seul caract√®re √† cette construction, en le convertissant sous la forme suivante: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Expressions lambda</font> </h2><br>  C ++ 11 introduit la prise en charge des expressions lambda.  Ils ressemblent √† des fonctions anonymes en JavaScript, ils peuvent √™tre compar√©s √† des objets fonctionnels sans nom.  Ils capturent des variables dans diff√©rentes port√©es en fonction de leur description, pour lesquelles des constructions syntaxiques compactes sont utilis√©es.  De plus, ils peuvent √™tre affect√©s √† des variables. <br><br>  Les expressions lambda sont un outil tr√®s utile dans les cas o√π vous devez effectuer une petite op√©ration dans le code, mais vous ne voulez pas √©crire de fonction distincte pour cela.  Un autre exemple courant de leur utilisation est la cr√©ation de fonctions utilis√©es pour comparer des valeurs.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  Vous pouvez trouver beaucoup de choses int√©ressantes dans ce court exemple. <br><br>  Tout d'abord, faites attention √† la commodit√© d'utiliser l'initialisation variable √† l'aide d'accolades.  Ensuite, nous pouvons voir les constructions standard <code>begin()</code> et <code>end()</code> , qui sont √©galement apparues en C ++ 11. Vient ensuite la fonction lambda, qui est utilis√©e comme m√©canisme de comparaison des donn√©es.  Les param√®tres de cette fonction sont d√©clar√©s √† l'aide du mot <code>auto</code> cl√© <code>auto</code> , cette fonctionnalit√© est apparue en C ++ 14. Auparavant, ce mot-cl√© ne pouvait pas √™tre utilis√© pour d√©crire les param√®tres des fonctions. <br><br>  Notez maintenant que l'expression lambda commence par des crochets - <code>[]</code> .  Il s'agit du soi-disant masque de variables.  Il d√©termine la port√©e de l'expression, c'est-√†-dire qu'il vous permet de contr√¥ler la relation de l'expression lambda avec les variables et les objets locaux. <br><br>  Voici un extrait de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> r√©f√©rentiel d√©di√© aux fonctionnalit√©s C ++ modernes: <br><br><ul><li>  <code>[]</code> - l'expression ne capture rien.  Cela signifie que dans une expression lambda, il est impossible d'utiliser des variables locales √† partir de la port√©e qui lui est externe.  Seuls les param√®tres peuvent √™tre utilis√©s dans l'expression. </li><li>  <code>[=]</code> - l'expression capture les valeurs des objets locaux (c'est-√†-dire les variables locales, les param√®tres).  Cela signifie qu'ils peuvent √™tre utilis√©s, mais pas modifi√©s. </li><li>  <code>[&amp;]</code> - l'expression capture des r√©f√©rences √† des objets locaux.  Ils peuvent √™tre modifi√©s, comme illustr√© dans l'exemple suivant. </li><li>  <code>[this]</code> - l'expression capture la valeur du pointeur <code>this</code> . </li><li>  <code>[a, &amp;b]</code> - l'expression capture la valeur de l'objet <code>a</code> et une r√©f√©rence √† l'objet <code>b</code> . </li></ul><br>  Par cons√©quent, si √† l'int√©rieur de la fonction lambda vous avez besoin de convertir les donn√©es dans un autre format, vous pouvez utiliser les m√©canismes ci-dessus.  Prenons un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Ici, si la variable de <code>factor</code> √©tait accessible par valeur (alors le masque de variable <code>[factor]</code> serait utilis√© pour d√©crire l'expression lambda), alors √† la ligne <code>#1</code> la valeur de <code>factor</code> ne pourrait pas √™tre modifi√©e - simplement parce que nous n'aurions pas le droit de effectuer une telle op√©ration.  Dans cet exemple, nous avons le droit de telles actions.  Dans de telles situations, il est important de ne pas abuser des capacit√©s que les variables d'acc√®s fournissent par r√©f√©rence. <br><br>  De plus, notez que <code>val</code> √©galement accessible par r√©f√©rence.  Cela garantit que les modifications de donn√©es qui se produisent dans la fonction lambda affectent le <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Expressions d'initialisation variables dans les constructions if et switch</font> </h2><br>  J'ai vraiment aim√© cette innovation C ++ 17 juste apr√®s l'avoir d√©couverte.  Prenons un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Il s'av√®re que vous pouvez maintenant initialiser les variables et comparer avec leur utilisation dans un bloc <code>if</code> ou <code>switch</code> .  Cela aide √† √©crire du code pr√©cis.  Voici une description sch√©matique de la structure consid√©r√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Effectuer des calculs au moment de la compilation √† l'aide de constexpr</font> </h2><br>  Le <code>constexpr</code> nous offre de grandes opportunit√©s.  Supposons que nous ayons une sorte d'expression qui doit √™tre calcul√©e, tandis que sa valeur, apr√®s l'avoir initialis√©e avec la variable correspondante, ne changera pas.  Une telle expression peut √™tre calcul√©e √† l'avance et utilis√©e comme macro.  Ou, ce qui est devenu possible en C ++ 11, utilisez le <code>constexpr</code> . <br><br>  Les programmeurs s'efforcent de minimiser la quantit√© de calculs effectu√©s pendant l'ex√©cution du programme.  Par cons√©quent, si certaines op√©rations peuvent √™tre effectu√©es pendant le processus de compilation et ainsi supprimer la charge du syst√®me pendant l'ex√©cution du programme, cela aura un bon effet sur le comportement du programme pendant l'ex√©cution.  Voici un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Il s'agit d'un exemple tr√®s courant d'utilisation de <code>constexpr</code> . <br><br>  Puisque nous avons d√©clar√© la fonction de calcul de la factorielle comme <code>constexpr</code> , le compilateur peut pr√©-calculer la valeur <code>fact(20)</code> au moment de la compilation du programme.  Par cons√©quent, apr√®s la compilation, la cha√Æne <code>const long long bigval = fact(20);</code>  peut √™tre remplac√© par <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Notez que l'argument pass√© √† la fonction est repr√©sent√© par une constante.  Il s'agit d'une caract√©ristique importante de l'utilisation de fonctions d√©clar√©es √† l'aide du <code>constexpr</code> .  Les arguments qui leur sont transmis doivent √©galement √™tre d√©clar√©s avec le <code>constexpr</code> ou avec le mot cl√© <code>const</code> .  Sinon, ces fonctions se comporteront comme des fonctions ordinaires, c'est-√†-dire que lors de la compilation, leurs valeurs ne seront pas calcul√©es √† l'avance. <br><br>  Les variables peuvent √©galement √™tre d√©clar√©es √† l'aide du <code>constexpr</code> .  Dans ce cas, comme vous pouvez le deviner, les valeurs de ces variables doivent √™tre calcul√©es au moment de la compilation.  Si cela ne peut pas √™tre fait, un message d'erreur de compilation s'affichera. <br><br>  Il est int√©ressant de noter que plus tard, en C ++ 17, les constructions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constexpr-if</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constexpr-lambda</a> sont apparues. <br><br><h2>  <font color="#3AC1EF">Structures de donn√©es de tuple</font> </h2><br>  Comme la structure de donn√©es de <code>pair</code> , la structure de donn√©es de <code>tuple</code> (tuple) est une collection de valeurs de diff√©rents types d'une taille fixe.  Voici un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Parfois, au lieu d'une structure de donn√©es de <code>tuple</code> , il est plus pratique d'utiliser <code>std::array</code> .  Cette structure de donn√©es est similaire aux tableaux simples utilis√©s dans le langage C, √©quip√©s de fonctionnalit√©s suppl√©mentaires de la biblioth√®que standard C ++.  Cette structure de donn√©es est apparue en C ++ 11. <br><br><h2>  <font color="#3AC1EF">D√©duire automatiquement le type d'argument du mod√®le de classe</font> </h2><br>  Le nom de cette fonctionnalit√© semble assez long et complexe, mais en fait il n'y a rien de compliqu√© ici.  L'id√©e principale ici est qu'en C ++ 17, la sortie des types d'arguments de mod√®le est √©galement effectu√©e pour les mod√®les de classe standard.  Auparavant, cela n'√©tait pris en charge que pour les mod√®les fonctionnels.  En cons√©quence, il s'av√®re qu'ils √©crivaient comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Avec la sortie de C ++ 17, cette construction peut maintenant √™tre remplac√©e par ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  L'inf√©rence de type se fait implicitement.  Ce m√©canisme est encore plus pratique √† utiliser pour les tuples.  √Ä savoir, avant de devoir √©crire ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Maintenant, la m√™me chose ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Il convient de noter que ces fonctionnalit√©s ne sembleront pas dignes d'attention √† ceux qui ne sont pas particuli√®rement familiers avec les mod√®les C ++. <br><br><h2>  <font color="#3AC1EF">Pointeurs intelligents</font> </h2><br>  Travailler avec des pointeurs en C ++ peut √™tre un vrai cauchemar.  Gr√¢ce √† la libert√© que donne le langage au programmeur, il lui est parfois tr√®s difficile, comme on dit, de "ne pas se tirer une balle dans le pied".  Dans de nombreux cas, les pointeurs font pression pour un tel ¬´coup¬ª du programmeur. <br><br>  Heureusement, C ++ 11 a introduit des pointeurs intelligents qui sont beaucoup plus pratiques que les pointeurs classiques.  Ils aident le programmeur √† √©viter les fuites de m√©moire en lib√©rant des ressources lorsque cela est possible.  De plus, ils offrent une garantie de s√©curit√© pour les exceptions. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un</a> bon r√©f√©rentiel qui, √† notre avis, sera int√©ressant √† d√©couvrir par ceux qui suivent les innovations du C ++.  Quelque chose de nouveau appara√Æt constamment dans cette langue.  Ici, nous n'avons abord√© que quelques caract√©ristiques modernes de la langue.  En fait, il y en a beaucoup.  Il est possible que nous en parlions encore. <br><br>  <b>Chers lecteurs!</b>  Quelles fonctionnalit√©s C ++ modernes trouvez-vous les plus int√©ressantes et utiles? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451870/">https://habr.com/ru/post/fr451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451858/index.html">Faire un simple disjoncteur bas√© sur le cache au printemps</a></li>
<li><a href="../fr451860/index.html">Les math√©maticiens ont d√©couvert le moyen id√©al pour multiplier les nombres</a></li>
<li><a href="../fr451862/index.html">Musical Lightning de Joe Diprim: un ing√©nieur autodidacte fabrique des bobines Tesla pour le divertissement et le gain</a></li>
<li><a href="../fr451864/index.html">Vuln√©rabilit√© RCE critique du niveau EternalBlue d√©tect√©e dans le syst√®me d'exploitation Windows</a></li>
<li><a href="../fr451866/index.html">Choisissez les n≈ìuds les plus proches du r√©seau</a></li>
<li><a href="../fr451872/index.html">Python est un assistant pour trouver des vols pas chers pour ceux qui aiment voyager</a></li>
<li><a href="../fr451874/index.html">Meilleures tendances SEO chez Google</a></li>
<li><a href="../fr451876/index.html">Centre de donn√©es de Francfort: Centre de donn√©es Telehouse</a></li>
<li><a href="../fr451878/index.html">Diffusion en direct de vid√©o st√©r√©o sur des lunettes VR (Oculus Go)</a></li>
<li><a href="../fr451880/index.html">DevPRO'19: vue depuis le stand Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>