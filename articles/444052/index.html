<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüíº üë®‚Äçüë®‚Äçüëß‚Äçüëß üöï C√≥mo en IntelliJ IDEA buscamos expresiones lambda üë©üèª‚Äç‚úàÔ∏è üìó üíÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una caracter√≠stica importante de cualquier IDE es la b√∫squeda y navegaci√≥n a trav√©s del c√≥digo. Una de las opciones de b√∫squeda de Java utilizadas con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo en IntelliJ IDEA buscamos expresiones lambda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/444052/"><p><img alt="Jerarqu√≠a de tipos en IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Una caracter√≠stica importante de cualquier IDE es la b√∫squeda y navegaci√≥n a trav√©s del c√≥digo.  Una de las opciones de b√∫squeda de Java utilizadas con frecuencia es buscar todas las implementaciones de esta interfaz.  A menudo, dicha funci√≥n se denomina Jerarqu√≠a de tipos y se parece a la imagen de la derecha. </p><br><p>  Iterar a trav√©s de todas las clases de un proyecto cuando se llama a esta funci√≥n es ineficiente.  Puede guardar la jerarqu√≠a de clases completa en el √≠ndice en tiempo de compilaci√≥n, ya que el compilador la construye de todos modos.  Hacemos esto si el IDE inicia la compilaci√≥n y no se delega, por ejemplo, en Gradle.  Pero esto solo funciona si nada ha cambiado en el m√≥dulo despu√©s de la compilaci√≥n.  Pero en el caso general, los c√≥digos fuente son la fuente de informaci√≥n m√°s relevante, y los √≠ndices se basan en c√≥digos fuente. </p><br><p> Encontrar herederos inmediatos es una tarea simple si no se trata de una interfaz funcional.  Al buscar implementaciones de la interfaz <code>Foo</code> , debe encontrar todas las clases donde hay <code>implements Foo</code> , e interfaces donde hay <code>extends Foo</code> , as√≠ como clases an√≥nimas de la <code>new Foo(...) {...}</code> forma <code>new Foo(...) {...}</code> .  Para hacer esto, es suficiente construir de antemano el √°rbol de sintaxis de cada archivo de proyecto, encontrar las construcciones correspondientes y agregarlas al √≠ndice. </p><a name="habracut"></a><br><p>  Por supuesto, aqu√≠ hay una leve sutileza: quiz√°s est√© buscando la interfaz <code>com.example.goodcompany.Foo</code> , pero en alg√∫n <code>org.example.evilcompany.Foo</code> se usa <code>org.example.evilcompany.Foo</code> .  ¬øEs posible poner previamente el nombre completo de la interfaz principal en el √≠ndice?  Hay dificultades con esto.  Por ejemplo, el archivo donde se usa la interfaz puede verse as√≠: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Mirando solo el archivo, no podemos entender cu√°l es el verdadero nombre completo de <code>Foo</code> .  Tienes que mirar el contenido de varios paquetes.  Y cada paquete se puede definir en varios lugares (por ejemplo, en varios archivos jar).  La indexaci√≥n llevar√° mucho tiempo si, al analizar este archivo, tenemos que hacer la resoluci√≥n completa del personaje.  Pero el problema principal ni siquiera es esto, sino que el √≠ndice creado en el archivo <code>MyFoo.java</code> depender√° no solo de √©l, sino tambi√©n de otros archivos.  Despu√©s de todo, podemos transferir la descripci√≥n de la interfaz de <code>Foo</code> , por ejemplo, del paquete <code>org.example.bar</code> paquete <code>org.example.bar</code> , y no cambiar nada en el archivo <code>MyFoo.java</code> , y el nombre completo de <code>Foo</code> cambiar√°. </p><br><p>  Los √≠ndices en IntelliJ IDEA dependen solo del contenido de un solo archivo.  Por un lado, esto es muy conveniente: el √≠ndice relacionado con un archivo en particular deja de ser v√°lido cuando este archivo cambia.  Por otro lado, esto impone grandes restricciones sobre lo que se puede colocar en el √≠ndice.  Por ejemplo, no puede almacenar de manera confiable los nombres completos de las clases principales en el √≠ndice.  Pero, en principio, esto no es tan aterrador.  Al consultar la jerarqu√≠a de tipos, podemos encontrar todo lo que se adapte al nombre corto y luego, para estos archivos, realicemos una resoluci√≥n honesta del personaje y determinemos si realmente nos conviene.  En la mayor√≠a de los casos, no habr√° demasiados caracteres adicionales, y dicha verificaci√≥n ser√° bastante r√°pida. </p><br><p><img alt="Jerarqu√≠a de interfaz funcional en IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  La situaci√≥n cambia dram√°ticamente cuando la clase cuyos descendientes estamos buscando es una interfaz funcional.  Luego, adem√°s de los herederos expl√≠citos y an√≥nimos, obtenemos expresiones lambda y enlaces de m√©todos.  ¬øQu√© hacer ahora en un √≠ndice y qu√© calcular directamente en la b√∫squeda? </p><br><p>  Supongamos que tenemos una interfaz funcional: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Hay diferentes expresiones lambda en el c√≥digo.  Por ejemplo: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">//   :   (a, b) -&gt; a + b //   :   s -&gt; { return list.add(s); //   :   } s -&gt; list.add(s); //   </span></span></code> </pre> <br><p>  Es decir, podemos filtrar r√°pidamente solo aquellas lambdas que tienen el n√∫mero incorrecto de par√°metros o, obviamente, el tipo de retorno incorrecto, por ejemplo, nulo frente a no nulo.  Por lo general, es imposible determinar el tipo de retorno con mayor precisi√≥n.  Digamos, en lambda <code>s -&gt; list.add(s)</code> para esto, necesita resolver la <code>list</code> caracteres y <code>add</code> , y, posiblemente, iniciar un procedimiento de inferencia de tipo completo.  Todo esto es largo y requerir√° una fijaci√≥n en el contenido de otros archivos. </p><br><p>  Tenemos suerte si nuestra interfaz funcional toma cinco argumentos.  Pero si solo se necesita un argumento, dicho filtro dejar√° una gran cantidad de lambdas adicionales.  Peor a√∫n con las referencias de m√©todos.  En principio, la aparici√≥n de cualquier referencia a un m√©todo no se puede decir de ninguna manera si es adecuado o no. </p><br><p>  ¬øQuiz√°s deber√≠as mirar alrededor de la lambda para entender algo?  S√≠, a veces funciona.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        Predicate&lt;String&gt; p = s -&gt; list.add(s); //      IntPredicate getPredicate() { return s -&gt; list.add(s); } //      SomeType fn; fn = s -&gt; list.add(s); //     foo((SomeFunctionalType)(s -&gt; list.add(s))); //     Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  En todos estos casos, el nombre corto de la interfaz funcional correspondiente se puede encontrar en el archivo actual y poner en el √≠ndice al lado de la expresi√≥n funcional, ya sea una referencia lambda o de m√©todo.  Desafortunadamente, en proyectos reales, estos casos cubren una fracci√≥n muy peque√±a de todas las lambdas.  En la gran mayor√≠a de los casos, lambda se usa como argumento de un m√©todo: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  ¬øCu√°l de estas tres lambdas puede ser de tipo <code>StringConsumer</code> ?  Est√° claro para el programador que ninguno.  Como es obvio que aqu√≠ tenemos la cadena Stream API, y solo hay interfaces funcionales de la biblioteca est√°ndar, nuestro tipo no puede estar all√≠. </p><br><p>  Sin embargo, el IDE no debe dejarse enga√±ar, debe dar una respuesta precisa.  ¬øQu√© <code>list.stream()</code> si <code>list</code> no es <code>java.util.List</code> en absoluto y <code>list.stream()</code> no devuelve <code>java.util.stream.Stream</code> ?  Para hacer esto, debe resolver el s√≠mbolo de la <code>list</code> , que, como sabemos, no se puede hacer de manera confiable solo en funci√≥n del contenido del archivo actual.  E incluso si lo instalamos, la b√∫squeda no debe establecerse en la implementaci√≥n de la biblioteca est√°ndar.  ¬øTal vez espec√≠ficamente en este proyecto reemplazamos la clase <code>java.util.List</code> con la nuestra?  La b√∫squeda debe responder a esto.  Bueno, por supuesto, las lambdas se usan no solo en transmisiones est√°ndar, sino que hay muchos otros m√©todos donde se transfieren. </p><br><p>  Como resultado, resulta que podemos consultar el √≠ndice para obtener una lista de todos los archivos Java que usan lambdas con el n√∫mero requerido de par√°metros y un tipo de retorno v√°lido (de hecho, solo rastreamos cuatro opciones: vac√≠o, no vac√≠o, booleano y cualquiera).  ¬øY luego que?  Para cada uno de estos archivos, construya un √°rbol PSI completo (¬øes como un √°rbol de an√°lisis, pero con resoluci√≥n de caracteres, inferencia de tipos y otras cosas inteligentes) y honestamente ejecute la inferencia de tipos para lambda?  Luego, en un proyecto grande, no esperar√° una lista de todas las implementaciones de la interfaz, incluso si solo hay dos de ellas. </p><br><p>  Resulta que tenemos que hacer los siguientes pasos: </p><br><ul><li>  Pregunta el √≠ndice (barato) </li><li>  Construir una PSI (costosa) </li><li>  Imprimir tipo lambda (muy caro) </li></ul><br><p>  En Java versi√≥n 8 y posterior, la inferencia de tipos es una operaci√≥n incre√≠blemente costosa.  En una cadena compleja de llamadas, puede tener muchos par√°metros gen√©ricos comod√≠n, cuyos valores deben determinarse utilizando el procedimiento furioso descrito en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cap√≠tulo 18 de la</a> especificaci√≥n.  Esto se puede hacer en segundo plano para el archivo actual que se est√° editando, pero ser√° dif√≠cil hacerlo para miles de archivos sin abrir. </p><br><p>  Aqu√≠, sin embargo, puede reducir un poco la esquina: en la mayor√≠a de los casos no necesitamos el tipo final.  Si solo lambda no se pasa a un m√©todo que toma un par√°metro gen√©rico en este lugar, podemos deshacernos del √∫ltimo paso de la sustituci√≥n de par√°metros.  Digamos, si dedujimos el tipo lambda <code>java.util.function.Function&lt;T, R&gt;</code> , no podemos calcular los valores de los par√°metros de sustituci√≥n <code>T</code> y <code>R</code> : por lo tanto, est√° claro si devolverlo al resultado de la b√∫squeda o no.  Aunque esto no funcionar√° al llamar a un m√©todo como este: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Este m√©todo se puede llamar as√≠: <code>doSmth(Runnable.class, () -&gt; {})</code> .  Luego, el tipo lambda se mostrar√° como <code>T</code> , y tendr√° que sustituirlo de todos modos.  Pero este es un caso raro.  Por lo tanto, resulta ahorrar, pero no m√°s del 10%.  El problema no est√° resuelto fundamentalmente. </p><br><p>  Otra idea: si la inferencia de tipo exacta es compleja, hagamos una conclusi√≥n aproximada.  Deje que funcione solo en tipos de clases borrados y no reduzca el conjunto de restricciones, como est√° escrito en la especificaci√≥n, sino simplemente siga la cadena de llamadas.  Mientras el tipo borrado no incluya par√°metros gen√©ricos, entonces todo est√° bien.  Por ejemplo, tome la secuencia del ejemplo anterior y determine si la √∫ltima lambda implementa nuestro <code>StringConsumer</code> : </p><br><ul><li>  <code>list</code> variables -&gt; tipo <code>java.util.List</code> </li><li>  <code>List.stream()</code> - <code>List.stream()</code> tipo <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> ‚Üí escriba <code>java.util.stream.Stream</code> , ni siquiera miramos los argumentos del <code>filter</code> , ¬øcu√°l es la diferencia? </li><li>  <code>Stream.map(...)</code> - <code>Stream.map(...)</code> tipo <code>java.util.stream.Stream</code> , de manera similar </li><li>  El <code>Stream.forEach(...)</code> ‚Üí existe dicho m√©todo, su par√°metro es del tipo <code>Consumer</code> , que, obviamente, no es <code>StringConsumer</code> . </li></ul><br><p>  Bueno, lo hicieron sin una inferencia de tipo completo.  Sin embargo, con un enfoque tan simple, es f√°cil encontrar m√©todos sobrecargados.  Si no comenzamos la inferencia de tipo por completo, entonces no puede seleccionar la versi√≥n correcta sobrecargada.  Aunque no, a veces es posible si el n√∫mero de par√°metros del m√©todo difiere.  Por ejemplo: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Aqu√≠ podemos entender f√°cilmente que </p><br><ul><li>  Hay dos m√©todos <code>CompletableFuture.supplyAsync</code> , pero uno toma un argumento y el segundo toma dos, as√≠ que elija el que tome dos.  Devuelve un <code>CompletableFuture</code> . </li><li>  <code>thenRunAsync</code> m√©todos <code>thenRunAsync</code> tambi√©n <code>thenRunAsync</code> dos, y de ellos puede elegir de manera similar el que tome un argumento.  El par√°metro correspondiente es de tipo <code>Runnable</code> , lo que significa que no es <code>StringConsumer</code> . </li></ul><br><p>  Si varios m√©todos aceptan el mismo n√∫mero de par√°metros, o algunos tienen un n√∫mero variable de par√°metros y tambi√©n parecen adecuados, entonces deber√° realizar un seguimiento de todas las opciones.  Pero a menudo esto tampoco da miedo.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> obviamente crea <code>java.lang.StringBuilder</code> .  Para los dise√±adores, todav√≠a permitimos el enlace, pero aqu√≠ no se requiere inferencia de tipos complejos.  Incluso si hubiera un <code>new Foo&lt;&gt;(x, y, z)</code> , no mostramos los valores de los par√°metros t√≠picos, solo estamos interesados ‚Äã‚Äãen <code>Foo</code> . </li><li>  Hay <code>StringBuilder.append</code> m√©todos <code>StringBuilder.append</code> que toman un argumento, pero todos devuelven el tipo <code>java.lang.StringBuilder</code> , por lo que no importa de qu√© tipo sean <code>foo</code> y <code>bar</code> . </li><li>  El m√©todo <code>StringBuilder.chars</code> uno y devuelve <code>java.util.stream.IntStream</code> . </li><li>  El m√©todo <code>IntStream.forEach</code> uno y acepta el tipo <code>IntConsumer</code> . </li></ul><br><p>  Incluso si quedan varias opciones en alg√∫n lugar, puede rastrearlas todas.  Por ejemplo, el tipo de lambda pasado a <code>ForkJoinPool.getInstance().submit(...)</code> puede ser <code>Runnable</code> o <code>Callable</code> , pero si estamos buscando algo tercero, a√∫n podemos descartar ese lambda. </p><br><p>  Una situaci√≥n desagradable ocurre cuando un m√©todo devuelve un par√°metro gen√©rico.  Luego, el procedimiento se descompone y debe ejecutar la inferencia de tipo completo.  Sin embargo, apoyamos un caso.  Se muestra bien en mi biblioteca StreamEx, que tiene una clase abstracta <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> contiene m√©todos como el <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Por lo general, las personas trabajan con una clase espec√≠fica <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  En este caso, puede realizar la sustituci√≥n del par√°metro de tipo y descubrir que <code>S = StreamEx</code> . </p><br><p>  Bueno, en muchos casos nos libramos de una inferencia de tipos muy costosa.  Pero no hicimos nada con la construcci√≥n de la ISP.  Es una l√°stima analizar un archivo en quinientas l√≠neas solo para descubrir que el lambda en la l√≠nea 480 no se ajusta a nuestra consulta.  Volvamos a nuestra transmisi√≥n: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Si <code>list</code> es una variable local, par√°metro de m√©todo o campo en la clase actual, entonces ya en la etapa de indexaci√≥n podemos encontrar su declaraci√≥n y establecer que el nombre corto del tipo es <br>  <code>List</code>  En consecuencia, en el √≠ndice de la √∫ltima lambda podemos poner la siguiente informaci√≥n: </p><br><blockquote>  El tipo de este lambda es el tipo de par√°metro del m√©todo <code>forEach</code> de un argumento, invocado en el resultado del m√©todo <code>map</code> de un argumento, invocado en el resultado del m√©todo de <code>filter</code> de un argumento, invocado en el resultado del m√©todo <code>stream</code> de cero argumentos, invocado en un objeto de tipo <code>List</code> . </blockquote><p>  Toda esta informaci√≥n est√° disponible en el archivo actual, lo que significa que se puede colocar en el √≠ndice.  Durante la b√∫squeda, solicitamos al √≠ndice dicha informaci√≥n sobre todas las lambdas e intentamos restaurar el tipo de lambda sin construir un PSI.  Primero tendr√° que hacer una b√∫squeda global de clases con el nombre abreviado <code>List</code> .  Por supuesto, encontraremos no solo <code>java.util.List</code> , sino tambi√©n <code>java.awt.List</code> o algo del c√≥digo del proyecto del usuario.  Adem√°s, enviaremos todas estas clases al mismo procedimiento de resoluci√≥n de tipo impreciso que usamos antes.  A menudo, las clases adicionales se filtran r√°pidamente.  Por ejemplo, en <code>java.awt.List</code> no hay ning√∫n m√©todo de <code>stream</code> , por lo tanto, se excluye a√∫n m√°s.  Pero incluso si algo superfluo nos acompa√±a hasta el final y encontramos varios candidatos para el tipo de nuestro lambda, hay buenas posibilidades de que no encajen en la consulta de b√∫squeda, y a√∫n as√≠ evitaremos construir una PSI completa. </p><br><p>  Es posible que la b√∫squeda global sea demasiado costosa (hay muchas clases de <code>List</code> en el proyecto), o el comienzo de la cadena no est√° permitido en el contexto de un solo archivo (por ejemplo, este es el campo de la clase principal), o la cadena se interrumpir√° en alg√∫n lugar porque el m√©todo devuelve un par√°metro gen√©rico.  Entonces no nos rendimos de inmediato e intentamos nuevamente comenzar con una b√∫squeda global en el pr√≥ximo m√©todo de encadenamiento.  Por ejemplo, para la <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , la siguiente instrucci√≥n entr√≥ en el √≠ndice: </p><br><blockquote>  El tipo de lambda es el tipo del √∫nico par√°metro del m√©todo <code>updateAndGet</code> , invocado en el resultado del m√©todo <code>get</code> con un par√°metro, invocado en el objeto del tipo <code>Map</code> . </blockquote><p>  Seamos afortunados y en el proyecto solo hay un tipo de <code>Map</code> : <code>java.util.Map</code> .  Tiene un m√©todo <code>get(Object)</code> , pero desafortunadamente devuelve el par√°metro gen√©rico <code>V</code>  Luego dejamos caer la cadena y buscamos globalmente el m√©todo <code>updateAndGet</code> con un par√°metro (usando el √≠ndice, por supuesto).  <code>AtomicInteger</code> , solo hay tres m√©todos de este tipo en el proyecto, en las <code>AtomicInteger</code> , <code>AtomicLong</code> y <code>AtomicReference</code> con par√°metros de tipo <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> y <code>UnaryOperator</code> , respectivamente.  Si estamos buscando otro tipo, descubrimos que este lambda no encaja y que PSI no se puede construir. </p><br><p>  Sorprendentemente, este es un v√≠vido ejemplo de una caracter√≠stica que, con el tiempo, comienza a funcionar m√°s lentamente.  Por ejemplo, est√° buscando la implementaci√≥n de una interfaz funcional, solo hay tres de ellas en el proyecto e IntelliJ IDEA las busca durante diez segundos.  Y recuerdas muy bien que hace tres a√±os tambi√©n hab√≠a tres de ellos, tambi√©n los estabas buscando, pero luego el entorno dio una respuesta en dos segundos en la misma m√°quina.  Y su proyecto, aunque enorme, ha crecido en tres a√±os, tal vez en un cinco por ciento.  Por supuesto, comienzas a resentirte justamente con lo que estos desarrolladores se equivocaron con que el IDE comenz√≥ a desacelerarse tan terriblemente.  Manos para arrancar a estos desafortunados programadores. </p><br><p>  Y tal vez no cambiamos nada en absoluto.  Tal vez la b√∫squeda funciona igual que hace tres a√±os.  Hace solo tres a√±os, se cambi√≥ a Java 8 y ten√≠a, digamos, cien lambdas en su proyecto.  Y ahora sus colegas convirtieron las clases an√≥nimas en lambdas, comenzaron a usar secuencias de forma activa o conectaron alg√∫n tipo de biblioteca reactiva, como resultado de lambdas se convirti√≥ en no cien, sino diez mil.  Y ahora, para desenterrar las tres lambdas necesarias, se debe buscar el IDE cien veces m√°s. </p><br><p>  Dije "tal vez" porque, por supuesto, volvemos a esta b√∫squeda de vez en cuando y tratamos de acelerarla.  Pero aqu√≠ tienes que remar, ni siquiera contra la corriente, sino hasta la cascada.  Lo intentamos, pero el n√∫mero de lambdas en los proyectos est√° creciendo muy r√°pidamente. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444052/">https://habr.com/ru/post/444052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444038/index.html">Experiencia en el uso de "coordinadores" en un verdadero proyecto "iOS"</a></li>
<li><a href="../444040/index.html">Clasificaci√≥n autoc√©ntrica. Informe Yandex sobre c√≥mo encontrar audiencias relevantes para autores Zen</a></li>
<li><a href="../444044/index.html">Europa reciclar√° el hierro del centro de datos</a></li>
<li><a href="../444048/index.html">Consejos y trucos forenses digitales: c√≥mo detectar cambios en la pol√≠tica de grupo impulsados ‚Äã‚Äãpor intrusos</a></li>
<li><a href="../444050/index.html">Discusi√≥n: ¬øSe volver√° masivo el almacenamiento de ADN?</a></li>
<li><a href="../444056/index.html">Los proveedores de Internet en Crimea aumentaron dr√°sticamente los precios de los servicios.</a></li>
<li><a href="../444058/index.html">Cuando los ni√±os entienden que toda su vida ya est√° en l√≠nea</a></li>
<li><a href="../444060/index.html">Migrar de Nagios a Icinga2 en Australia</a></li>
<li><a href="../444062/index.html">Iluminar! Transformaciones nocturnas del Centro Lakhta</a></li>
<li><a href="../444064/index.html">Nuevas ideas para un nuevo futuro.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>