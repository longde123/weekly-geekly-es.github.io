<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎨 ✂️ 👵🏿 HolyJS 2019: Nachbesprechung von SEMrush (Teil 2) 🍴 🌐 🥧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil der Analyse der Aufgaben von unserem Stand auf der HolyJS- Konferenz, die vom 24. bis 25. Mai in St. Petersburg stattfand. Fü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HolyJS 2019: Nachbesprechung von SEMrush (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/453466/"><img src="https://habrastorage.org/webt/lu/af/0g/luaf0gd14raqav4knnokeboltkk.jpeg"><br><br>  Dies ist der zweite Teil der Analyse der Aufgaben von unserem Stand auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS-</a> Konferenz, die vom 24. bis 25. Mai in St. Petersburg stattfand.  Für einen größeren Kontext wird empfohlen, zuerst den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> dieses Materials zu lesen.  Wenn der <i>Countdown-Ausdruck</i> bereits abgeschlossen ist, fahren Sie mit dem nächsten Schritt fort. <br><a name="habracut"></a><br>  Im Gegensatz zum Obskurantismus in der ersten Aufgabe haben die nächsten beiden bereits einen Hinweis auf die Anwendbarkeit normaler Anwendungen im Leben.  JavaScript entwickelt sich immer noch recht schnell und Lösungen für die vorgeschlagenen Probleme heben einige der neuen Funktionen der Sprache hervor. <br><br><h2>  Aufgabe 2 ~ Von den Einen erledigt </h2><br>  Es wurde angenommen, dass der Code Antworten auf drei Anforderungen ausführen und an die Konsole drucken würde, und dann „fertig“.  Aber etwas ist schief gelaufen ... Korrigieren Sie die Situation. <br><br><pre><code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } } }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre> <br><h4>  Forschungsproblem </h4><br>  Was haben wir hier?  Dies ist ein <i>iterierbares</i> <i>Iter-</i> Objekt, bei dem ein <i>bekanntes</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Symbol.iterator-</i></a> Symbol über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Generatorfunktion</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>definiert</i></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> .  Im Hauptteil der Funktion wird ein Array <i>fs</i> deklariert, dessen Elemente wiederum in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Abruffunktion</i></a> fallen, um eine Anforderung zu senden, und das Ergebnis jedes Funktionsaufrufs wird durch <i>Yield zurückgegeben</i> .  Welche Anfragen sendet die <i>Abruffunktion</i> ?  Alle Elemente des <i>fs-</i> Arrays sind relative Pfade zu Ressourcen mit den Nummern 1, 2 bzw. 3.  Die vollständige URL erhalten Sie also, indem Sie <i>location.origin</i> mit der nächsten Nummer verketten, zum Beispiel: <br><br> <code>GET https://www.example.com/1 <br></code> <br>  Als nächstes wollen wir das <i>iter-</i> Objekt durch <i>for-of</i> iterieren, um schließlich jede Anforderung der Reihe nach mit der Ausgabe des Ergebnisses auszuführen - print "done".  Das geht aber nicht!  Das Problem ist, dass das <i>Abrufen</i> asynchron ist und ein Versprechen zurückgibt, keine Antwort.  Daher sehen wir in der Konsole ungefähr Folgendes: <br><br> <code>Promise {pending} <br> Promise {pending} <br> Promise {pending} <br> done <br></code> <br>  Tatsächlich besteht die Aufgabe darin, dieselben Versprechen zu lösen. <br><br><h4>  Wir haben async / warten </h4><br>  Der erste Gedanke könnte sein, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Promise.all</i></a> zu spielen: Geben Sie ihm unser <i>iterierbares</i> Objekt, <i>dann ist die</i> Ausgabe an die Konsole "erledigt".  Er wird uns jedoch keine sequentielle Ausführung von Anforderungen (wie von der Bedingung gefordert) zur Verfügung stellen, sondern einfach alle senden und auf die letzte Antwort vor der allgemeinen Lösung warten. <br><br>  Die einfachste Lösung hier wäre, im <i>For-of-</i> Body auf die Lösung des nächsten Versprechens zu warten, bevor es an die Konsole ausgegeben wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); }</code> </pre><br>  Damit das <i>Warten auf</i> Arbeit und "Fertig" am Ende angezeigt wird, müssen Sie die Hauptfunktion über <i>Async</i> asynchron machen: <br><br><pre> <code class="javascript hljs">;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  In diesem Fall wurde das Problem bereits (fast) gelöst: <br><br> <code>GET 1st <br> Response 1st <br> GET 2nd <br> Response 2nd <br> GET 3rd <br> Response 3rd <br> done <br></code> <br><h4>  Asynchroner Iterator und Generator </h4><br>  Wir werden die Hauptfunktion asynchron lassen, aber für das <i>Warten</i> gibt es einen eleganteren Platz in dieser Aufgabe als im <i>For-of-</i> Body: Dies ist die Verwendung der asynchronen Iteration durch <a href=""><i>For-Wait-of</i></a> , nämlich: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }</code> </pre><br>  Alles wird funktionieren!  Wenn Sie sich jedoch der Beschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses <i>Vorschlags</i></a> zur asynchronen Iteration zuwenden, ist Folgendes interessant: <br><br><blockquote>  Wir führen eine Variation der for-of-Iterationsanweisung ein, die über asynchrone iterierbare Objekte iteriert.  Asynchrone for-of-Anweisungen sind nur in asynchronen Funktionen und asynchronen Generatorfunktionen zulässig </blockquote><br>  Das heißt, unser Objekt sollte nicht nur <i>iterierbar</i> , sondern durch das neue <i>bekannte</i> Symbol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Symbol.asyncIterator</i></a> und in unserem Fall bereits eine asynchrone Generatorfunktion „asynchronisierbar“ sein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator]: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(req); } } };</code> </pre><br>  Wie funktioniert es dann mit einem regulären Iterator und Generator?  Ja, nur implizit, wie so viel mehr in dieser Sprache.  Dieses <i>Warten</i> ist schwierig: Wenn das Objekt nur <i>iterierbar ist</i> , "konvertiert" es das Objekt bei asynchroner Iteration in asynchronisierbar, indem die Elemente (falls erforderlich) in <i>Promise</i> mit der Erwartung einer Auflösung eingeschlossen werden.  Er sprach ausführlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Artikel von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Axel Rauschmayer</a> . <br><br>  Wahrscheinlich wird es durch <i>Symbol.asyncIterator</i> noch korrekter sein, da wir das <i>asyncIterable-</i> Objekt für unsere asynchrone Iteration explizit durch <i>for-await-of erstellt haben</i> , während wir die Möglichkeit haben, das Objekt bei Bedarf durch einen regulären Iterator für <i>for</i> <i>von</i> zu ergänzen.  Wenn Sie in einem Artikel über asynchrone Iterationen in JavaScript etwas Nützliches und Ausreichendes lesen möchten, dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist es hier</a> ! <br><br>  Asynchrones <i>For-of</i> befindet sich teilweise noch im Entwurf, wird jedoch bereits von modernen Browsern (außer Edge) und Node.js ab 10.x unterstützt.  Wenn dies jemanden stört, können Sie immer Ihr eigenes kleines Polyphil für eine Kette von Versprechungen schreiben, zum Beispiel für ein <i>iterierbares</i> Objekt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chain = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = it.next(); i.done ? resolve() : i.value.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { callback(res); next(it); }); }(promises[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]()) ); ;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* iterable */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> chain(iter, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  Auf diese und jene Weise haben wir herausgefunden, wie Anfragen gesendet und Antworten verarbeitet werden.  Aber in diesem Problem gibt es noch ein kleines, aber ärgerliches Problem ... <br><br><h4>  Achtsamkeitstest </h4><br>  Wir waren von all dieser Asynchronität so begeistert, dass wir, wie so oft, ein kleines Detail aus den Augen verloren haben.  Werden diese Anfragen von unserem Skript gesendet?  Sehen wir uns das <i>Netzwerk an</i> : <br><br> <code>GET https://www.example.com/0 <br> GET https://www.example.com/1 <br> GET https://www.example.com/2 <br></code> <br>  Aber unsere Zahlen sind 1, 2, 3. Als ob eine Dekrementierung stattgefunden hätte.  Warum so?  Nur im Quellcode der Aufgabe gibt es hier ein weiteres Problem mit der Iteration: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); }</code> </pre><br>  Hier wird ein <i>For-In verwendet</i> , das anstelle von Array-Werten seine aufgezählten Eigenschaften umgeht: und dies sind die Indizes von Elementen von 0 bis 2. Die <i>Abruffunktion</i> führt sie weiterhin zu Zeichenfolgen und wird trotz des Fehlens eines Schrägstrichs zuvor (dies ist kein <i>Pfad</i> mehr) relativ aufgelöst URL der aktuellen Seite.  Das Reparieren ist viel einfacher als das Bemerken.  Zwei Optionen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(fs[req]); }</code> </pre><br>  Im ersten Fall haben wir dasselbe <i>for-of verwendet</i> , um die Werte des Arrays zu durchlaufen, im zweiten Fall - Zugriff auf das Array-Element per Index. <br><br><h4>  Motivation </h4><br>  Wir haben 3 Lösungen in Betracht gezogen: 1) durch <i>Warten</i> im <i>For-of-</i> Body, 2) durch <i>For-</i> Wait-Of und 3) durch unsere Polydatei (rekursive Funktion, <i>Pipe-</i> Pipeline usw.).  Es ist merkwürdig, dass diese Optionen die Konferenzteilnehmer ungefähr zu gleichen Teilen teilten und kein offensichtlicher Favorit bekannt wurde.  In großen Projekten wird für solche realen Aufgaben normalerweise eine reaktive Bibliothek (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJS</a> ) verwendet. Es lohnt sich jedoch, sich an die modernen nativen Merkmale einer asynchronen Sprache zu erinnern. <br><br>  Etwa die Hälfte der Teilnehmer bemerkte keine Fehler in der Iteration der Ressourcenliste, was ebenfalls eine interessante Beobachtung ist.  Wenn wir uns auf ein nicht triviales, aber offensichtliches Problem konzentrieren, können wir diese scheinbar Kleinigkeit leicht überspringen, aber mit möglichen schwerwiegenden Konsequenzen. <br><br><h2>  Problem 3 ~ Faktor 19 </h2><br>  Wie oft in der Aufzeichnung der Nummer 2019!  (Fakultät ab 2019) tritt die Zahl 19 auf?  Stellen Sie zusammen mit der Antwort eine JavaScript-Lösung bereit. <br><br><h4>  Forschungsproblem </h4><br>  Das Problem liegt an der Oberfläche: Wir benötigen eine Aufzeichnung einer sehr großen Anzahl, um die Anzahl aller Vorkommen des Teilstrings „19“ darin zu finden.  Als wir das Problem mit den <i>Zahlen</i> lösten, stießen wir sehr schnell auf <i>Infinity</i> (nach 170) und bekamen nichts.  Darüber hinaus garantiert das Format zur Darstellung von Zahlen <i>float64</i> die Genauigkeit von nur 15-17 Zeichen, und wir müssen nicht nur eine vollständige, sondern auch eine genaue Aufzeichnung der Zahl erhalten.  Daher besteht die Hauptschwierigkeit darin, die Struktur für die Akkumulation dieser großen Anzahl zu bestimmen. <br><br><h4>  Große ganze Zahlen </h4><br>  Wenn Sie den Neuerungen der Sprache folgen, wird die Aufgabe einfach gelöst: Anstelle der Typennummer <i>können</i> Sie den neuen Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>BigInt</i> (Stufe 3) verwenden</a> , mit dem Sie mit Zahlen mit beliebiger Genauigkeit arbeiten können.  Mit der klassischen rekursiven Funktion zum Berechnen der Fakultät und zum Finden von Übereinstimmungen über <i>String.prototype.split</i> sieht <i>die</i> erste Lösung folgendermaßen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>n ? n * fn(n - <span class="hljs-number"><span class="hljs-number">1</span></span>n) : <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">2019</span></span>n).toString().split(<span class="hljs-string"><span class="hljs-string">'19'</span></span>).length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Zweitausend Funktionsaufrufe auf dem Stack können jedoch bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefährlich sein</a> .  Selbst wenn Sie die Lösung für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail-Rekursion verwenden</a> , unterstützt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Tail-Call-Optimierung</i></a> nur Safari.  Das faktorielle Problem ist hier angenehmer durch einen <i>Rechenzyklus</i> oder <i>Array.prototype.reduce</i> zu lösen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...Array(<span class="hljs-number"><span class="hljs-number">2019</span></span>)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> p * BigInt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>n).toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Dies mag wie ein wahnsinnig langer Vorgang erscheinen.  Aber dieser Eindruck täuscht.  Wenn Sie schätzen, müssen wir nur etwas mehr als zweitausend Multiplikationen ausgeben.  Bei i5-4590 3.30GHz in Chrom ist das Problem durchschnittlich in 4-5ms (!) Gelöst. <br><br>  Eine weitere Option zum Suchen von Übereinstimmungen in einer Zeichenfolge mit dem Ergebnis einer Berechnung ist <i>String.prototype.match</i> durch regulären Ausdruck mit dem globalen <i>Suchflag</i> : <i>/ 19 / g</i> . <br><br><h4>  Große Arithmetik </h4><br>  Aber was ist, wenn wir dieses <i>BigInt</i> (und auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken</a> ) noch nicht haben?  In diesem Fall können Sie die lange Arithmetik selbst durchführen.  Um das Problem zu lösen, reicht es aus, nur die Funktion des Multiplizierens von groß mit klein zu implementieren (wir multiplizieren mit Zahlen von 1 bis 2019).  Wir können eine große Zahl und das Ergebnis der Multiplikation zum Beispiel in der Zeile halten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} big * @param {number} int * @returns {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = <span class="hljs-string"><span class="hljs-string">''</span></span>, carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = big[i] * int + carry; res = prod % <span class="hljs-number"><span class="hljs-number">10</span></span> + res; carry = prod / <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">carry || </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">) + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2019</span></span></span></span></span><span class="hljs-function">)].</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'1'</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Hier multiplizieren wir einfach die Spalte in Bits vom Ende der Zeile bis zum Anfang, wie wir in der Schule unterrichtet wurden.  Die Lösung benötigt aber schon ca. 170ms. <br><br>  Wir können den Algorithmus etwas verbessern, indem wir mehr als eine Ziffer in einem Nummernsatz gleichzeitig verarbeiten.  Dazu ändern wir die Funktion und gehen gleichzeitig zu den Arrays, um nicht jedes Mal mit den Zeilen herumzuspielen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {Array&lt;number&gt;} big * @param {number} int * @param {number} digits * @returns {Array&lt;number&gt;} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = [], carry = <span class="hljs-number"><span class="hljs-number">0</span></span>, div = <span class="hljs-number"><span class="hljs-number">10</span></span> ** digits; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || carry; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : big[i] * int) + carry; res.push(prod % div); carry = prod / div | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.reverse(); }</code> </pre><br>  Hier werden große Zahlen durch ein Array dargestellt, in dem jedes Element Informationen über <i>Ziffern</i> Ziffern aus dem Nummernsatz unter Verwendung von <i>Zahlen</i> speichert.  Beispielsweise wird die Nummer 2016201720182019 mit <i>Ziffern</i> = 3 wie folgt dargestellt: <br><br> <code>'2|016|201|720|182|019' =&gt; [2,16,201,720,182,19] <br></code> <br>  Wenn Sie vor einem Join in eine Zeile konvertieren, müssen Sie sich die führenden Nullen merken.  Die <i>Faktorfunktion</i> gibt die berechnete Fakultät durch eine Zeichenfolge zurück, wobei die <i>Multifunktion</i> mit der angegebenen Anzahl von verarbeiteten Ziffern gleichzeitig in der "massiven" Darstellung der Zahl bei der Berechnung verwendet wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> [...Array(n)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, digits), [<span class="hljs-number"><span class="hljs-number">1</span></span>]) .map(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(digits - el.length) + el) .join(<span class="hljs-string"><span class="hljs-string">''</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/^0+/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(factor(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Die "knielange" Implementierung durch Arrays erwies sich als schneller als durch Strings und berechnet mit <i>Ziffern</i> = 1 die Antwort bereits im Durchschnitt in 90 ms, <i>Ziffern</i> = 3 in 35 ms, <i>Ziffern</i> = 6 in nur 20 ms.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Denken</i></a> Sie jedoch daran, dass wir uns mit zunehmender Anzahl von Ziffern einer Situation nähern, in der das Multiplizieren von <i>Zahlen</i> mit <i>Zahlen</i> „unter der Haube“ außerhalb des sicheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>MAX_SAFE_INTEGER liegen kann</i></a> .  Hier können Sie damit spielen.  Was ist der maximale Stellenwert, den wir uns für diese Aufgabe leisten können? <br><br>  Die Ergebnisse sind bereits ziemlich bezeichnend, <i>BigInt</i> ist wirklich ziemlich schnell: <br><br><img src="https://habrastorage.org/webt/qq/wb/-j/qqwb-jhmypgogtk94bg-pqnrxhy.png"><br><br><h4>  Motivation </h4><br>  Es ist cool, dass 2/3 der Konferenzteilnehmer den neuen <i>BigInt-</i> Typ in der Lösung verwendeten (jemand gab zu, dass dies die erste Erfahrung war).  Das verbleibende Drittel der Lösungen enthielt eigene Implementierungen langer Arithmetik für Strings oder Arrays.  Die meisten implementierten Funktionen multiplizierten große Zahlen mit großen, während es für eine Lösung ausreichte, mit einer "kleinen" <i>Zahl</i> zu multiplizieren und etwas weniger Zeit zu verbringen.  Okay Aufgabe, verwenden Sie <i>BigInt bereits</i> in Ihren Projekten? <br><br><h2>  Danksagung </h2><br>  Diese beiden Konferenztage waren sehr voller Diskussionen und des Lernens von etwas Neuem.  Ich möchte dem Programmkomitee für die nächste unvergessliche Konferenz und allen Teilnehmern für ihre einzigartige Vernetzung und gute Laune danken. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453466/">https://habr.com/ru/post/de453466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453454/index.html">Software Defined Radio - wie funktioniert es? Teil 5</a></li>
<li><a href="../de453456/index.html">Funktionsweise der Lokalisierung in Netflix - Übersetzung</a></li>
<li><a href="../de453458/index.html">Echte reaktive Programmierung in Svelte 3.0</a></li>
<li><a href="../de453460/index.html">Wenn ich das Virtuelle satt habe</a></li>
<li><a href="../de453464/index.html">Quantum Future (Fortsetzung)</a></li>
<li><a href="../de453468/index.html">Die Entwicklung von Java-Webanwendungen</a></li>
<li><a href="../de453470/index.html">Ihre verteilten Monolithen zeichnen hinter Ihnen</a></li>
<li><a href="../de453472/index.html">Fahrrad vom Energiemonitor PZEM004T und ESP8266 mit People's Monitoring</a></li>
<li><a href="../de453474/index.html">Computersteuerung über Fernbedienung von einem Verstärker mit Arduino und Node.js.</a></li>
<li><a href="../de453478/index.html">Wir untersuchen die Gesundheit der Starlink-Satelliten Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>