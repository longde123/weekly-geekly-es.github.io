<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👀 👩🏿‍🤝‍👩🏼 🏈 O back-end para o front-end ou How Yandex.Market cria uma API sem muletas 👵 📀 🏟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que algumas APIs são mais convenientes de usar do que outras? O que podemos fazer como fornecedores front-end do nosso lado para trabalhar com uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O back-end para o front-end ou How Yandex.Market cria uma API sem muletas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428141/"><p>  Por que algumas APIs são mais convenientes de usar do que outras?  O que podemos fazer como fornecedores front-end do nosso lado para trabalhar com uma API de qualidade aceitável?  Hoje vou contar aos leitores da Habr sobre opções técnicas e medidas organizacionais que ajudarão os provedores de front-end e back-end a encontrar uma linguagem comum e estabelecer um trabalho eficaz. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  Neste outono, a Yandex.Market faz 18 anos.  Todo esse tempo, a interface do mercado afiliado vem se desenvolvendo.  Em resumo, este é o painel de administração com o qual as lojas podem fazer upload de catálogos, trabalhar com o sortimento, acompanhar estatísticas, responder a críticas etc.  As especificidades do projeto são tais que você precisa interagir muito com vários back-ends.  No entanto, os dados nem sempre podem ser obtidos em um local, a partir de um back-end específico. </p><br><p><a name="habracut"></a></p><h3>  Sintomas de um problema </h3><br>  Então, imagine, havia algum tipo de problema.  O gerente vai com a tarefa para os designers - eles desenham o layout.  Então ele vai para o back-end - eles fazem algumas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canetas</a> e escrevem uma lista de parâmetros e o formato da resposta no wiki interno. <br><p>  Em seguida, o gerente vai para o front-end com as palavras "Trouxe a API para você" e oferece um script rápido de tudo, porque, na opinião dele, quase todo o trabalho já foi feito. </p><br><p>  Você olha a documentação e vê isso: </p><br><pre><code class="xml hljs">№ |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Não percebe nada de estranho?  Camel, Snake e Kebab Case em uma caneta.  Eu não estou falando sobre o parâmetro fesh.  O que é fesh?  Tal palavra nem existe.  Tente adivinhar antes de abrir o spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh é um filtro por ID da loja.  Você pode passar vários identificadores separados por vírgulas.  Um ID pode ser precedido por um sinal de menos, o que significa que esse armazenamento deve ser excluído dos resultados. </p></div></div><br><p>  Ao mesmo tempo, a partir do JavaSctipt, é claro, não consigo acessar as propriedades de um objeto por meio de notação pontilhada.  Sem mencionar o fato de que, se você tiver mais de 50 parâmetros em um local, então, obviamente, na sua vida você se virou para outro lugar. </p><br><p>  Existem muitas opções para uma API inconveniente.  Um exemplo clássico - a API pesquisa e retorna resultados: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Se as mercadorias forem encontradas, obtemos uma matriz.  Se um produto for encontrado, obteremos um objeto com esse produto.  Se nada for encontrado, na melhor das hipóteses, ficaremos nulos.  Na pior das hipóteses, o back-end responde com 404 ou mesmo 400 (Solicitação incorreta). </p><br><p>  Situações são mais fáceis.  Por exemplo, você precisa obter uma lista de lojas em um back-end e configurações de loja em outro.  Em algumas canetas, não há dados suficientes, em alguns dados, há muitos.  Filtrar tudo isso no cliente ou fazer várias solicitações de ajax é uma má idéia. </p><br><p>  Então, quais podem ser as soluções para esse problema?  O que podemos fazer como fornecedores front-end do nosso lado para trabalhar com uma API de qualidade aceitável? </p><br><h3>  Front-end back-end </h3><br><p>  Usamos o cliente React / Redux na interface do parceiro.  Sob o cliente, encontra-se o Node.js, que faz muitas coisas auxiliares, por exemplo, lança-o na página InitialState para editores.  Se você tiver uma renderização do lado do servidor, não importa com qual estrutura do cliente, provavelmente, ela será renderizada por um nó.  Mas e se você der um passo adiante e não entrar em contato diretamente com o cliente no back-end, mas criar sua API de proxy no nó, adaptada ao máximo para as necessidades do cliente? <br>  Essa técnica é chamada BFF (back-end para front-end).  Este termo foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introduzido pela</a> primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vez pelo</a> SoundCloud em 2015 e a ideia pode ser esquematicamente representada da seguinte maneira: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Portanto, você deixa de passar do código do cliente diretamente para a API.  Cada identificador, cada método da API real que você duplica no nó e do cliente vai exclusivamente para o nó.  E o nó já proxies a solicitação para a API real e retorna uma resposta para você. </p><br><p>  Isso se aplica não apenas a solicitações de obtenção primitivas, mas geralmente a todas as solicitações, inclusive com dados de várias partes / formulário.  Por exemplo, uma loja carrega um arquivo .xls com seu catálogo por meio de um formulário em um site.  Portanto, nesta implementação, o diretório não é carregado diretamente na API, mas no identificador do Nod, que proxies transmitem para um back-end real. </p><br><p>  Lembra-se do exemplo com resultado quando o back-end retornou nulo, uma matriz ou um objeto?  Agora podemos voltar ao normal - algo como isto: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  Esse código parece horrível.  Porque ele é terrível.  Mas ainda precisamos fazer isso.  Nós temos uma escolha: faça no servidor ou no cliente.  Eu escolho um servidor. </p><br><p>  Também podemos mapear todos esses casos de kebab e cobra em um estilo conveniente para nós e colocar imediatamente o valor padrão, se necessário. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  Que outras vantagens temos? </p><br><ol><li>  <strong>Filtragem</strong> .  O cliente recebe apenas o que precisa, nem mais nem menos. </li><li>  <strong>Agregação</strong>  Não é necessário desperdiçar a rede e a bateria do cliente para fazer várias solicitações de ajax.  Um ganho de velocidade notável devido ao fato de abrir uma conexão ser uma operação cara. </li><li>  <strong>Armazenamento em cache</strong>  Sua chamada agregada repetida não atrairá mais ninguém, mas simplesmente retornará 304 Não Modificado. </li><li>  <strong>Esconder</strong> dados.  Por exemplo, você pode ter tokens necessários entre os back-ends e não deve ir para o cliente.  O cliente pode não ter o direito de saber sobre a existência desses tokens, para não mencionar seu conteúdo. </li><li>  <strong>Microsserviços</strong> .  Se você tiver um monólito nas costas, o BFF é o primeiro passo para os microsserviços. </li></ol><br><p>  Agora sobre os contras. </p><br><ol><li>  <strong>Dificuldade</strong> crescente.  Qualquer abstração é outra camada que precisa ser codificada, implantada e suportada.  Outra parte móvel do mecanismo que pode falhar. </li><li>  <strong>Duplicação de</strong> alças.  Por exemplo, vários pontos de extremidade podem executar o mesmo tipo de agregação. </li><li>  O BFF é uma <strong>camada de limite</strong> que deve suportar roteamento geral, restrições de direitos do usuário, registro de consultas, etc. </li></ol><br><p>  Para nivelar essas desvantagens, basta seguir regras simples.  O primeiro é separar a lógica comercial e de front-end.  Seu melhor amigo não deve alterar a lógica de negócios da API principal.  Segundo, sua camada só deve converter dados se for absolutamente necessário.  Não estamos falando de uma API abrangente e independente, mas apenas de um proxy que preenche essa lacuna, corrigindo as falhas de back-end. </p><br><h3>  GraphQL </h3><br><p>  Problemas semelhantes são resolvidos pelo GraphQL.  Com o GraphQL, em vez de muitos pontos de extremidade "estúpidos", você tem uma caneta inteligente que pode trabalhar com consultas complexas e gerar dados na forma em que o cliente solicita. </p><br><p>  Ao mesmo tempo, o GraphQL pode funcionar sobre o REST, ou seja, a fonte de dados não é o banco de dados, mas a API restante.  Devido à natureza declarativa do GraphQL, devido ao fato de tudo isso ser amigo do React e Editors, seu cliente se torna mais fácil. </p><br><p>  De fato, vejo o GraphQL como uma implementação do BFF com seu protocolo e uma linguagem de consulta estrita. </p><br><p>  Essa é uma excelente solução, mas apresenta várias desvantagens, em particular com tipificação, diferenciação de direitos e, em geral, é uma abordagem relativamente nova.  Portanto, ainda não mudamos, mas no futuro me parece a melhor maneira de criar uma API. </p><br><h3>  Melhores amigas para sempre </h3><br><p>  Nenhuma solução técnica funcionará corretamente sem alterações organizacionais.  Você ainda precisa de documentação, garante que o formato da resposta não seja alterado repentinamente etc. </p><br><p>  Deve-se entender que estamos todos no mesmo barco.  Para um cliente abstrato, seja um gerente ou seu gerente, em geral, não faz diferença - você tem o GraphQL lá ou o BFF.  É mais importante para ele que o problema seja resolvido e que os erros não apareçam no prod.  Para ele, não há muita diferença devido a cuja falha ocorreu um erro no produto - pela falha da frente ou de trás.  Portanto, você precisa negociar com os backders. </p><br><p>  Além disso, as falhas nas quais eu falei no início do relatório nem sempre surgem devido a ações maliciosas de alguém.  É possível que o parâmetro fesh também tenha algum significado. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Preste atenção na data do commit.  Acontece que, recentemente, fesh comemorou seu décimo sétimo aniversário. </p><br><p>  Vê alguns identificadores estranhos à esquerda?  Este é o SVN, simplesmente porque não havia gita em 2001.  Não é um github como serviço, mas um github como sistema de controle de versão.  Ele apareceu apenas em 2005. </p><br><h3>  A documentação </h3><br><p>  Portanto, tudo o que precisamos não é brigar com o back-end, mas concordar.  Isso só pode ser feito se encontrarmos uma única fonte de verdade.  Essa fonte deve ser a documentação. </p><br><p>  O mais importante aqui é escrever a documentação antes de começarmos a trabalhar na funcionalidade.  Como em um acordo pré-nupcial, é melhor concordar com tudo na praia. </p><br><p>  Como isso funciona?  Relativamente falando, três vão para: gerente, front-end e back-end.  Fronteder é bem versado na área de assunto, então sua participação é extremamente importante.  Eles se reúnem e começam a pensar na API: de que maneira, quais respostas devem ser retornadas, até o nome e o formato dos campos. </p><br><h3>  Swagger </h3><br><p>  Uma boa opção para a documentação da API é o formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Swagger</a> , agora chamado OpenAPI.  É melhor usar o Swagger no formato YAML, porque, diferentemente do JSON, é melhor lido por humanos, mas não há diferença para a máquina. </p><br><p>  Como resultado, todos os contratos são corrigidos no formato Swagger e publicados em um repositório comum.  A documentação para o back-end de vendas deve estar no assistente. </p><br><p>  O mestre está protegido contra confirmações, o código entra nele apenas através do pool de solicitações, e você não pode enviá-lo.  O representante da equipe de frente é obrigado a realizar uma revisão do pool de solicitações, sem a atualização dele, o código não vai para o mestre.  Isso protege você contra alterações inesperadas da API sem aviso prévio. </p><br><p>  Então vocês se reuniram, escreveu Swagger, e assinaram o contrato.  A partir deste momento, você como front-end pode iniciar seu trabalho sem esperar pela criação de uma API real.  Afinal, qual era o ponto de separação entre cliente e servidor, se não podemos trabalhar em paralelo e os desenvolvedores de clientes precisam esperar pelos desenvolvedores de servidores?  Se temos um "contrato", podemos paralisar com segurança esse assunto. </p><br><h3>  Faker.js </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Faker</a> é ótimo para esses propósitos.  Esta é uma biblioteca para gerar uma enorme quantidade de dados falsos.  Pode gerar diferentes tipos de dados: datas, nomes, endereços, etc., tudo isso está bem localizado, há suporte para o idioma russo. </p><br><p>  Ao mesmo tempo, o falsificador é amigo do arrogante, e você pode aumentar com calma o servidor Mock, que, com base no esquema do Swagger, irá gerar respostas falsas para você das formas necessárias. </p><br><h3>  Validação </h3><br><p>  O Swagger pode ser convertido em um esquema json e, com a ajuda de ferramentas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ajv,</a> você pode validar respostas de back-end diretamente em tempo de execução, no seu BFF e reportar aos testadores, aos próprios back-ends, no caso de discrepâncias, etc. </p><br><p>  Suponha que um testador encontre algum tipo de bug no site, por exemplo, quando um botão é clicado, nada acontece.  O que o testador faz?  Ele coloca um ingresso no front-end: "este é o seu botão, não está pressionado, repare". </p><br><p>  Se houver um validador entre você e o back, o testador saberá que o botão está realmente pressionado, apenas o back-end envia a resposta errada.  Errado - é uma resposta que a frente não espera, ou seja, não corresponde ao “contrato”.  E aqui já é necessário reparar as costas ou alterar o contrato. </p><br><h3>  Conclusões </h3><br><ol><li>  Estamos ativamente envolvidos no design da API.  Projetamos a API para que seja conveniente usá-la após 17 anos. </li><li>  Exigimos documentação do Swagger.  Nenhuma documentação - a operação de back-end não foi concluída. </li><li>  Há documentação - nós a publicamos no git, e qualquer alteração na API deve ser atualizada pelo representante da equipe de frente. </li><li>  Aumentamos o servidor falso e começamos a trabalhar de frente sem esperar pela API real. </li><li>  Colocamos o nó no frontend e validamos todas as respostas.  Além disso, temos a capacidade de agregar, normalizar e armazenar em cache dados. </li></ol><br><h4>  Veja também </h4><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar uma API semelhante a REST em um projeto grande</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Back-end No front-end</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o GraphQL como implementação de padrão BFF</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428141/">https://habr.com/ru/post/pt428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428129/index.html">Lógica fuzzy simples colada “do que era” para um motor de turbina a gás</a></li>
<li><a href="../pt428131/index.html">Toda a verdade sobre o RTOS. Artigo 17. Grupos de Sinalizadores de Eventos: Introdução e Serviços Básicos</a></li>
<li><a href="../pt428133/index.html">Hasura. Arquitetura GraphQL para SQL Server de alto desempenho</a></li>
<li><a href="../pt428135/index.html">Como configurar ou desativar o linting no editor de código interno</a></li>
<li><a href="../pt428137/index.html">Olimpíada, concurso de ideias, palestras sobre gerenciamento de projetos de TI e exibição de filmes: 10 próximos eventos na ITMO University</a></li>
<li><a href="../pt428143/index.html">Abordagem de implementação do ReactJS RBAC</a></li>
<li><a href="../pt428147/index.html">Script para coletar citações e reconhecer texto de vídeo em Python</a></li>
<li><a href="../pt428149/index.html">Seu novo Mavic 2 Enterprise Sky Ally</a></li>
<li><a href="../pt428151/index.html">Análise de desempenho do PostgreSQL 10.5 nos mais recentes serviços em nuvem Yandex.Cloud</a></li>
<li><a href="../pt428155/index.html">Limite de velocidade para veículos elétricos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>