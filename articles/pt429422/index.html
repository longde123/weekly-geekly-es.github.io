<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüîß üëäüèº üï£ UHCI, ou o primeiro USB üë®üèΩ‚Äçüåæ üõí üåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia, querido leitor! Me pediram para escrever sobre UHCI - bem, eu escrevo. 

 Voc√™ pode achar este artigo √∫til se, por exemplo, voc√™ n√£o tiver ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UHCI, ou o primeiro USB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429422/"><img src="https://habrastorage.org/webt/89/wk/ye/89wkyeuwi_jbnzlge2bawtlabum.png"><br><br>  Bom dia, querido leitor!  Me pediram para escrever sobre UHCI - bem, eu escrevo. <br><br>  Voc√™ pode achar este artigo √∫til se, por exemplo, voc√™ n√£o tiver habilidades suficientes de escrita para drivers e leitura de documenta√ß√£o para um hardware.  Um exemplo simples: voc√™ deseja gravar seu sistema operacional para um mini PC, para que algumas distribui√ß√µes do Windows ou de outro Linux n√£o fa√ßam o download do ferro, e voc√™ use todo o seu poder exclusivamente para seus pr√≥prios fins. <br><a name="habracut"></a><br><h2>  O que √© UHCI? </h2><br>  Penso que, para n√£o falar novamente sobre o que e por qu√™, basta deixar um link para o meu artigo anterior sobre EHCI.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pique aqui</a> <br>  UHCI - Universal Host Controller Interface, opera como um dispositivo PCI, mas, diferentemente do EHCI, usa portas em vez de MMIO (Memory-Mapped-IO). <br><br><img src="https://habrastorage.org/webt/nk/bl/--/nkbl--cqrxvs21lcitfothfcw4k.png"><br><br><h2>  Termos a serem usados ‚Äã‚Äãa seguir </h2><br><ul><li>  Driver USB (USBD) - o pr√≥prio driver USB </li><li>  HC (Host Controller) - um controlador host ou apenas o nosso UHCI </li><li>  Host Controller Driver (HCD) - um driver que conecta hardware e USBD </li><li>  Dispositivo USB - o pr√≥prio dispositivo USB </li></ul><br><h2>  Tipos de transfer√™ncia de dados </h2><br>  Is√≥crono - transmiss√£o isoss√≠ncrona, que possui uma determinada frequ√™ncia de transfer√™ncia de dados.  Pode ser usado, por exemplo, para microfones USB, etc. <br><br>  Interrup√ß√£o - Transfer√™ncias de dados pequenas e espont√¢neas de um dispositivo.  O tipo de transmiss√£o de interrup√ß√£o suporta dispositivos que requerem um intervalo de servi√ßo previs√≠vel, mas n√£o fornecem necessariamente um fluxo de dados previs√≠vel.  Geralmente usado para dispositivos como teclados e dispositivos apontadores que podem n√£o fornecer dados por longos per√≠odos de tempo, mas exigem uma resposta r√°pida quando eles t√™m dados para enviar. <br><br>  Controle - Tipo de transmiss√£o de informa√ß√µes sobre o status, status e configura√ß√£o do dispositivo.  O tipo de transfer√™ncia de controle √© usado para fornecer um canal de controle do host para os dispositivos USB.  As transmiss√µes de controle sempre consistem em uma fase de configura√ß√£o e zero ou mais fases de dados seguidas por uma fase de status.  √â imperativo que a transfer√™ncia de controle para um determinado terminal seja processada no modo FIFO.  Se o controle for passado para o mesmo terminal, a intercala√ß√£o pode levar a um comportamento imprevis√≠vel. <br><br>  Bulk - tipo de transfer√™ncia de matrizes de dados.  Usado, por exemplo, em dispositivos MassStorage. <br><br><img src="https://habrastorage.org/webt/j1/d5/4a/j1d54aqfs0iicr_-dfpmkwx8d_e.png"><br><br>  √â assim que se parece a distribui√ß√£o de tempo de 1 ms - processamento de um quadro. <br><br><h2>  Distribui√ß√£o de tempo </h2><br>  O controlador host suporta a entrega de dados em tempo real, gerando um pacote Start Of Frame (SOF) a cada 1 ms.  Um pacote SOF √© gerado quando o contador SOF no controlador host expira (Figura 3).  O controlador host inicializa o contador SOF por um tempo de quadro de 1 ms.  Pequenas altera√ß√µes podem ser feitas nesse valor (e, portanto, no per√≠odo de tempo do quadro) programando o registro de altera√ß√µes SOF.  Esse recurso permite que voc√™ fa√ßa pequenas altera√ß√µes no per√≠odo do quadro, se necess√°rio, para manter a sincroniza√ß√£o em tempo real em todo o sistema USB. <br><br>  O controlador host inclui o n√∫mero do quadro em cada pacote SOF.  Esse n√∫mero de quadro determina exclusivamente o per√≠odo do quadro em tempo real.  A condi√ß√£o de fim de quadro (EOF) ocorre no final do intervalo de 1 ms quando o controlador host inicia o pr√≥ximo tempo de quadro, gerando outro pacote SOF com o n√∫mero de quadro correspondente.  Durante o per√≠odo do quadro, os dados s√£o transmitidos como pacotes de informa√ß√µes.  O per√≠odo do quadro √© rigorosamente imposto pelo controlador host, e os pacotes de dados no quadro atual n√£o podem ir al√©m do EOF (consulte o Cap√≠tulo 11 na especifica√ß√£o USB).  O controlador host suporta a sincroniza√ß√£o da transmiss√£o de dados entre quadros em tempo real, vinculando o n√∫mero do quadro para executar uma entrada espec√≠fica na lista de quadros.  O contador de quadros do controlador host gera um n√∫mero de quadro (valor de 11 bits) e o inclui em cada pacote SOF.  O contador √© programado atrav√©s de registradores e cada per√≠odo de quadro √© incrementado.  O controlador host usa os 10 bits inferiores do n√∫mero de quadros como um √≠ndice na lista de quadros com 1024 quadros, armazenados na mem√≥ria do sistema.  Assim, como o contador de quadros controla a sele√ß√£o de uma entrada da lista de quadros, o controlador host processa cada entrada da lista em um determinado per√≠odo de quadros.  O controlador host se expande para a pr√≥xima entrada na lista de quadros para cada novo quadro.  Isso garante que as transmiss√µes is√≥cronas sejam executadas em um quadro espec√≠fico. <br><br>  Figura 3: <br><br><img src="https://habrastorage.org/webt/d8/pj/iw/d8pjiwyjanx3yse7tmmtnyeooqe.png"><br><br><h2>  Estrutura UHCI </h2><br>  Tudo √© exatamente igual ao EHCI.  Solicita√ß√µes de exemplo para HC: <br><br><img src="https://habrastorage.org/webt/io/1d/sm/io1dsmtielklqhm84nhekufybj4.png"><br><br><h2>  Configurar e acessar UHCI </h2><br>  E assim, como eu disse anteriormente, o UHCI funciona atrav√©s de portas, portanto, do PCI, precisamos descobrir a base dos registros UHCI. <br><br><img src="https://habrastorage.org/webt/gz/ql/3f/gzql3fejuar2ko92q8dnok-ehpi.png"><br><br>  No deslocamento 0x20, existem 4 bytes - IO Base.  Em rela√ß√£o ao IO Base, podemos usar os seguintes registros: <br><br><img src="https://habrastorage.org/webt/jk/a5/od/jka5odl_cbgmqxcdsix8e-1tkl0.png"><br><br><h2>  Registradores UHCI </h2><br><ul><li>  USBCMD √© um registro para controlar o HC.  Bits: <ul><li>  Bit 6 √© um sinalizador que o dispositivo est√° configurado e inicializado com sucesso. </li><li>  Bit 1 - Redefini√ß√£o HC.  Defina para redefinir HC. </li><li>  Bit 0 - Executar / Parar.  Exibe o status HC.  1 - obras, 0 - n√£o. </li></ul></li><li>  USBSTS - Registro de status.  Bits: <ul><li>  Bit 5 - HC parado.  Ocorreu um erro ou o controlador concluiu com √™xito a redefini√ß√£o do HC. </li><li>  Bit 4 - Erro no processo do controlador host.  O bit √© definido como 1 quando ocorre um erro cr√≠tico e o HC n√£o pode continuar na fila e no TD. </li><li>  Bit 3 - Erro no sistema host.  Erro de PCI. </li><li>  Bit 1 - Erro de interrup√ß√£o.  Indica que ocorreu um erro e o HC gerou uma interrup√ß√£o. </li><li>  Bit 0 - Interromper.  Indica que HC gerou uma interrup√ß√£o. </li></ul></li><li>  USBINTR - Registro das configura√ß√µes de interrup√ß√£o.  Bits: <ul><li>  O Bit 2 - COI - Interromper na conclus√£o - gera uma interrup√ß√£o no final da transa√ß√£o. </li></ul></li><li>  FRNUM - N√∫mero do quadro atual (pegue &amp; 0x3FF para o valor correto). </li><li>  FLBASEADD - Endere√ßo base da lista de quadros - endere√ßo da lista de quadros. </li><li>  PORTSC - Status e controle da porta - registro de status e controle de porta.  Bits: <ul><li>  Bit 9 - Redefini√ß√£o de porta - 1 - porta a redefinir. </li><li>  Bit 8 - indica que um dispositivo de baixa velocidade est√° conectado √† porta </li><li>  Bit 3 - Indica que a porta no estado mudou </li><li>  Bit 2 - Indica se a porta est√° ativada </li><li>  Bit 1 - indica que o status do dispositivo est√° conectado √† porta </li><li>  Bit 0 - indica que o dispositivo est√° conectado √† porta. </li></ul></li></ul><br><h2>  Estruturas </h2><br><h3>  Ponteiro da lista de quadros </h3><br><img src="https://habrastorage.org/webt/oc/y8/a6/ocy8a6is-xd60i9bxmtdjjyqcdy.png"><br><br><h3>  Descritor de transfer√™ncia </h3><br><img src="https://habrastorage.org/webt/jz/sh/bl/jzshblpig4inzxxtzkzxlmvsvq8.png"><br><br><h5>  TD CONTROLE E ESTADO </h5>  .  Bits: <br><ul><li>  Bits 28-27 - contador de erros, semelhante ao EHCI. </li><li><ul><li>  Bit 26 - 1 = Dispositivo de baixa velocidade, 0 = Dispositivo de velocidade total. </li><li>  Bit 25 - 1 = TD isoss√≠ncrono </li><li>  Bit 24 - COI </li><li>  Bits 23-16 - Status: </li><li>  Bit 23 - Indica que √© um TD ativo </li><li>  Bit 22 - Parado </li><li>  Bit 21 - Erro no Buffer de Dados </li><li>  Bit 20 - Babble Detected </li><li>  Bit 19 - NAK </li></ul></li><li>  Bits 10‚Äì0: O n√∫mero de bytes transmitidos pelo controlador host. </li></ul><br><h5>  TD Token </h5><br><ul><li>  Bits 31:21 - Max Packet Len, semelhante ao EHCI </li><li>  Bit 19 - Altern√¢ncia de dados, semelhante ao EHCI </li><li>  Bits 18:15 - N√∫mero do ponto final </li><li>  Bits 18:14 - endere√ßo do dispositivo </li><li>  Bits 7: 0 - PID.  Entrada = 0x69, Sa√≠da = 0xE1, Instala√ß√£o = 0x2D </li></ul><br><h3>  Cabe√ßa da fila </h3><br><img src="https://habrastorage.org/webt/-4/pb/ia/-4pbiakp01iozcmkne4q1tums4i.png"><br><br><h2>  C√≥digo </h2><br>  Inicialize e configure o HC: <br><br><pre><code class="cpp hljs">PciBar bar; PciGetBar(&amp;bar, id, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~bar.flags &amp; PCI_BAR_IO) { <span class="hljs-comment"><span class="hljs-comment">// Only Port I/O supported return; } unsigned int ioAddr = bar.u.port; UhciController *hc = VMAlloc(sizeof(UhciController)); hc-&gt;ioAddr = ioAddr; hc-&gt;frameList = VMAlloc(1024 * sizeof(u32) + 8292); hc-&gt;frameList = ((int)hc-&gt;frameList / 4096) * 4096 + 4096; hc-&gt;qhPool = (UhciQH *)VMAlloc(sizeof(UhciQH) * MAX_QH + 8292); hc-&gt;qhPool = ((int)hc-&gt;qhPool / 4096) * 4096 + 4096; hc-&gt;tdPool = (UhciTD *)VMAlloc(sizeof(UhciTD) * MAX_TD + 8292); hc-&gt;tdPool = ((int)hc-&gt;tdPool / 4096) * 4096 + 4096; memset(hc-&gt;qhPool, 0, sizeof(UhciQH) * MAX_QH); memset(hc-&gt;tdPool, 0, sizeof(UhciTD) * MAX_TD); memset(hc-&gt;frameList, 0, 4 * 1024); // Frame list setup UhciQH *qh = UhciAllocQH(hc); qh-&gt;head = TD_PTR_TERMINATE; qh-&gt;element = TD_PTR_TERMINATE; qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;asyncQH = qh; for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = 2 | (u32)(uintptr_t)qh; IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); IoWrite16(hc-&gt;ioAddr + REG_CMD, IoRead16(hc-&gt;ioAddr + REG_CMD)&amp;(~1)); unsigned short cfg = PciRead16(id, 4); PciWrite16(id, 4, cfg &amp; (~1)); PciWrite16(id, 0x20, (short)-1); unsigned short size = ~(PciRead16(id, 0x20)&amp;(~3)) + 1; PciWrite16(id, 0x20, hc-&gt;ioAddr); PciWrite16(id, 4, cfg | 5); // Disable Legacy Support IoWrite16(hc-&gt;ioAddr + REG_LEGSUP, 0x8f00); // Disable interrupts IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); // Assign frame list IoWrite16(hc-&gt;ioAddr + REG_FRNUM, 0); IoWrite32(hc-&gt;ioAddr + REG_FRBASEADD, (int)hc-&gt;frameList); IoWrite16(hc-&gt;ioAddr + REG_SOFMOD, 0x40); // Clear status IoWrite16(hc-&gt;ioAddr + REG_STS, 0xffff); // Enable controller IoWrite16(hc-&gt;ioAddr + REG_CMD, 0x1); // Probe devices UhciProbe(hc, size);</span></span></code> </pre> <br>  Solicita√ß√µes de terminal e controle: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static void UhciDevControl(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = 0; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { return; } UhciTD *head = td; UhciTD *prev = 0; // Setup packet uint toggle = 0; uint packetType = TD_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_IN : TD_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; while (it &lt; end) { td = UhciAllocTD(hc); if (!td) { return; } toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) { packetSize = maxSize; } UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet td = UhciAllocTD(hc); if (!td) { return; } toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_OUT : TD_PACKET_IN; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, 0, 0); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Wait until queue has been processed UhciInsertQH(hc, qh); UhciWaitForQH(hc, qh); } // ------------------------------------------------------------------------------------------------ static void UhciDevIntr(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } UhciTD *head = td; UhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = TD_PACKET_IN; //Here for compiler, on some last expression hadn't worked if (t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80) packetType = TD_PACKET_IN; else packetType = TD_PACKET_OUT; uint packetSize = t-&gt;len; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Schedule queue UhciInsertQH(hc, qh); if(t-&gt;w) UhciWaitForQH(hc, qh); }</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429422/">https://habr.com/ru/post/pt429422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../In146149/index.html">‡§ì‡§°‡•á‡§∏‡§æ ‡§Æ‡•á‡§Ç ‡§ó‡•ç‡§∞‡•Ä‡§∑‡•ç‡§Æ‡§ï‡§æ‡§≤‡•Ä‡§® ‡§¨‡§æ‡§∞‡§ï‡•à‡§Æ‡•ç‡§™</a></li>
<li><a href="../In146150/index.html">‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§™‡•ç‡§≤‡•á‡§Ø‡§∞ ‡§ï‡•ã ‡§®‡•á‡§ü‡§ü‡•â‡§™ ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§∏‡•á ‡§¨‡§¶‡§≤‡•á‡§Ç?</a></li>
<li><a href="../In146151/index.html">‡§è‡§ú‡§æ‡§á‡§≤ ‡§°‡§æ‡§á‡§µ ‡§°‡•á‡§™‡•ç‡§•: ‡§è‡§ú‡§æ‡§á‡§≤ ‡§á‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç‡§è‡§∂‡§® ‡§´‡•ç‡§∞‡•á‡§Æ‡§µ‡§∞‡•ç‡§ï</a></li>
<li><a href="../In146152/index.html">‡§ü‡•à‡§≤‡•á‡§Ç‡§ü ‡§Æ‡•à‡§™ ‡§∞‡§ø‡§ú‡•ç‡§Ø‡•Ç‡§Æ‡•á ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤‡§æ‡§á‡§ú‡§º‡§∞ - ‡§∞‡§ø‡§≤‡•Ä‡§ú‡§º ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§™‡§∞ ‡§è‡§°‡§µ‡•á‡§Ç‡§ö‡§∞‡•ç‡§∏</a></li>
<li><a href="../pt429420/index.html">O PlayStation Classic usa o emulador PCSX ReARMed para opera√ß√£o, sem solu√ß√µes propriet√°rias</a></li>
<li><a href="../pt429424/index.html">Robotaxi da Daimler e Bosch aparecer√° na Calif√≥rnia</a></li>
<li><a href="../pt429426/index.html">QGIS e exporta√ß√£o de ladrilhos</a></li>
<li><a href="../pt429448/index.html">N√≥s escrevemos o carregador FPGA no LabVIEW. Parte 2</a></li>
<li><a href="../pt429450/index.html">T√©cnicas de programa√ß√£o generalizada em Rust: como traduzimos Exonum de Iron para actix-web</a></li>
<li><a href="../pt429452/index.html">O Pent√°gono come√ßou a desclassificar o malware de outras pessoas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>