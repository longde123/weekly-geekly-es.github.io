<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèá üóùÔ∏è üêπ Wir entwickeln einen Telegramm-Bot zum Verfolgen von Filmen auf NodeJS und TypeScript üö∂üèæ üôà üôá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist Ihnen passiert, dass Sie vor Beginn des Films ins Kino kommen und Trailer anschauen, w√§hrend einige von ihnen ziemlich stark an Ihnen festhalte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir entwickeln einen Telegramm-Bot zum Verfolgen von Filmen auf NodeJS und TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443876/"><img src="https://habrastorage.org/webt/k8/du/50/k8du50aoufwmy7qczw9n6opy2mq.png"><br><br>  Es ist Ihnen passiert, dass Sie vor Beginn des Films ins Kino kommen und Trailer anschauen, w√§hrend einige von ihnen ziemlich stark an Ihnen festhalten und Sie sich das Versprechen geben, diesen Film zu sehen, wenn er nicht im Kino ist, dann zumindest sp√§ter, wenn er zum Download zur Verf√ºgung steht ?  Ich wage es vorzuschlagen, dass ja.  Aber oft endet es damit, dass Sie es erfolgreich vergessen und diesen Film im besten Fall versehentlich finden, indem Sie durch die Liste der bereits ver√∂ffentlichten Filme scrollen. <br><br>  Ich bin oft auf ein solches Problem gesto√üen und habe beschlossen, es mit Eve - Telegram-bot zu erstellen, was mir hilft, die Ver√∂ffentlichungen meiner Lieblingsfilme nicht zu vergessen.  Was ist es, wie es funktioniert und wie es entwickelt wurde, k√∂nnen Sie unter dem Schnitt lesen! <br><a name="habracut"></a><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorwort</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologieauswahl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegraf.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektstruktur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierung und Start</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzereingaben verarbeiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lokalisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><a name="foreword"></a><h3>  Vorwort </h3><br>  Dieser Artikel ist keine detaillierte Anleitung zum Erstellen von Telegramm-Bots.  Und obwohl ich im Verlauf des Artikels h√§ufig auf mein Projekt verweise, ist der Zweck dieses Materials eine Geschichte √ºber die Entwicklung im Allgemeinen, n√§mlich die Auswahl der Technologien, Schl√ºsselpunkte und Fallstricke, auf die ich gesto√üen bin. <br><a name="why"></a><br><h3>  Warum? </h3><br>  Wie ich oben schrieb, vergesse ich oft, mir die Filme anzuschauen, deren Trailer mir gefallen hat.  Ich habe lange √ºber eine L√∂sung f√ºr dieses Problem nachgedacht.  Das erste, was mir einfiel, war die Erstellung einer nativen Anwendung f√ºr Smartphones, aber seitdem  Ich habe dies noch nie zuvor getan, es w√ºrde viel Zeit in Anspruch nehmen und nicht die Tatsache, dass das Endergebnis meine Bed√ºrfnisse sowie die Bed√ºrfnisse potenzieller Benutzer befriedigen w√ºrde. <br><br>  Die n√§chste Idee war, eine PWA zu erstellen.  Es ist eine interessante Option, um sich mit der Technologie vertraut zu machen, aber ich habe beschlossen, sie f√ºr die Zukunft zu belassen.  Gleichzeitig benutze ich Telegramm schon lange und habe w√§hrend dieser ganzen Zeit genug Bots gesammelt, die mir das Leben in regelm√§√üigen Abst√§nden ein wenig erleichtern.  Nachdem ich alle Vor- und Nachteile abgewogen hatte, entschied ich, dass diese Plattform perfekt f√ºr diese Idee ist. <br><a name="technologies"></a><br><h3>  Technologieauswahl </h3><br>  Wenn Sie Github nach Telegramm-Bots durchsuchen, k√∂nnen Sie sehen, dass die meisten davon in Python geschrieben sind.  Python ist wirklich eine gro√üartige Sprache und gro√üartig f√ºr diese Idee, aber ich wollte dieses Projekt speziell auf NodeJS + TypeScript implementieren.  Bei Anwendung der entsprechenden Filter stie√ü ich auf zwei recht beliebte Tools: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node-Telegramm-Bot-API</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegraf.js</a> . <br><br>  Vor dieser Erfahrung in der Entwicklung von Bots hatte ich keine, daher war bei der Auswahl dieser beiden nicht klar, welche Parameter betrachtet werden sollten.  Nachdem ich mir die Dokumentation angesehen und die Probleme f√ºr jede der Bibliotheken durchgesehen hatte, entschied ich mich f√ºr Telegraf.js.  Ausschlaggebend war die Verf√ºgbarkeit von Middleware, die auf die gleiche Weise wie im beliebten Express.js-Framework gestaltet ist.  Telegraf.js hat auch einen h√§ufigeren Update-Verlauf und eine gut strukturierte Dokumentation, was darauf hindeutet, dass die Entwickler gen√ºgend Anstrengungen unternehmen, um das Tool zu verbessern.  Dar√ºber hinaus enth√§lt es Tipps f√ºr TypeScript, was definitiv ein Plus f√ºr den ausgew√§hlten Stapel ist. <br><a name="telegraf"></a><br><h3>  Telegraf.js </h3><br>  Telegraf.js ist die Hauptbibliothek, in der das Projekt geschrieben wurde.  Es werden verschiedene interessante Ans√§tze verwendet, mit denen Sie komplexe Bots erstellen und gleichzeitig die Einfachheit des Codes beibehalten k√∂nnen.  Nachfolgend sind die interessantesten Mechanismen aufgef√ºhrt: <br><br><ul><li>  <b>Middleware</b> - Ja, dies sind dieselben Middleware, die in Express.js verf√ºgbar sind.  Wenn der Benutzer etwas an den Bot sendet, durchl√§uft die Nachricht zuerst alle registrierten Middlewares und gelangt anschlie√üend zum Controller.  Middlewares k√∂nnen den Kontext √§ndern und die Ausf√ºhrung der Anforderung unterbrechen, beispielsweise wenn ein normaler Benutzer versucht, in den Bereich f√ºr Administratoren zu gelangen.  Telegraf.js bietet sofort einige √§u√üerst n√ºtzliche Middlewares, die Sie jedoch auch selbst verwenden k√∂nnen.  Middlewares gelten n√§mlich als Killer-Features von Telegraf.js </li><li>  <b>Sitzungen</b> - Sitzungen, in denen Informationen gespeichert werden k√∂nnen, die nicht an den Controller gebunden sind.  Sie k√∂nnen eine Analogie zu globalen Variablen geben, auf die von √ºberall im Bot aus zugegriffen werden kann.  Eine sehr praktische Sache, die zum Beispiel zur Lokalisierung verwendet wird.  Es ist m√∂glich, Sitzungen in verschiedenen Modi zu speichern - DB, Redis, lokale Dateien usw. </li><li>  <b>Webooks</b> - der Bot kann in zwei Modi arbeiten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Long Polling</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webhooks</a> .  Und obwohl sie gleich schnell arbeiten, ist es besser, die zweite Option in einer Produktionsumgebung zu verwenden.  Somit muss der Bot nicht auf den Telegrammserver klopfen, sondern erh√§lt alle Updates selbst. <br><br>  <b>Wichtig:</b> Voraussetzung f√ºr Webhooks ist die Unterst√ºtzung des SSL / TLS-Servers.  Stellen Sie au√üerdem sicher, dass der Port, auf dem Webhook ausgef√ºhrt wird, offen und von au√üen zug√§nglich ist. </li><li>  <b>Markup</b> - Mit dieser Klasse k√∂nnen Sie dem Bot beibringen, in Markup / Markdown-Markup zu antworten.  Dies ist wichtig, wenn Sie beispielsweise ein HTML-Spiel erstellen.  In meinem Projekt habe ich es jedoch nur f√ºr fett / kursiven Text verwendet. </li><li>  <b>Stage</b> ist ein √§u√üerst interessantes Modul, das mir geholfen hat, meine Nerven und einige Stunden Entwicklungszeit zu bewahren.  Hier werde ich n√§her darauf eingehen. <br>  Der Bot kann Nachrichten vom Benutzer abh√∂ren und je nach Art oder Inhalt der Nachricht an den einen oder anderen Controller umleiten, der seine Funktion ausf√ºhrt und eine Antwort an den Benutzer sendet.  Es sieht so aus: <br><br><pre><code class="javascript hljs">bot.hears(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ctx =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ctx.reply(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); });</code> </pre> <br>  Es funktioniert einfach: Wenn Sie dem Bot Hallo schreiben, antwortet er einfach Hallo!  Wenn wir diesen Aspekt der Arbeit kennen, wollen wir uns vorstellen, wie der Bot bei der Suche nach Filmen arbeiten kann: <br><br><ol><li>  Der Benutzer schreibt, dass er zur Suche nach Filmen gehen m√∂chte; </li><li>  Der Benutzer gibt den Namen des Films an. </li><li>  Der Bot gibt eine Liste von Filmen zur√ºck und fordert den Benutzer auf, den ausgew√§hlten Film in seiner Bibliothek zu speichern. </li><li>  ... </li></ol><br>  Achtung, eine Frage!  Wie kann ein Bot unterscheiden, wenn ein Benutzer ihm schreibt, dass er nach einem Film suchen m√∂chte, und wenn er den Namen des Films schreibt, nach dem gesucht werden soll? <br><br>  <i>Ja, Sie k√∂nnen jeden gesendeten Text als Namen des Films verwenden, aber wir m√∂chten den Bot mit <s>Blackjack und Nutten zu einer</s> guten Schnittstelle machen.</i> <br><br>  Und hier kommen die Szenen (B√ºhnen) ins Spiel!  Am einfachsten l√§sst sich dies anhand des obigen Beispiels erkennen.  Wenn der Benutzer sagt, dass er zur Suche nach Filmen gehen m√∂chte, starten wir die Szene.  Innerhalb dieser Szene gibt es separate Texthandler - bot.hears (...).  Somit beziehen sich alle nachfolgenden Nachrichten direkt auf die Suche nach Filmen, bis der Benutzer eine Nachricht zum Beenden schreibt und die Szene verl√§sst.  Danach werden die Handler in dieser Szene deaktiviert, bis der Benutzer wieder dorthin zur√ºckkehrt.  Als n√§chstes werde ich beschreiben, wie ich Szenen verwendet habe, um die Ereignisbehandlung so einfach wie m√∂glich zu gestalten. <br></li></ul><br><a name="structure"></a><br><h3>  Projektstruktur </h3><br>  Es besteht der Verdacht, dass sich der Artikel als ziemlich umfangreich herausstellen wird, und deshalb werde ich einige Punkte weglassen, um ihn nicht noch weiter auszudehnen.  Damit der Bot beispielsweise funktioniert, m√ºssen Sie zun√§chst das Telegramm-Bot-API-Token abrufen.  Informationen dazu finden Sie in der offiziellen Telegrammdokumentation oder in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zu Telegraf.js. <br><br>  Die Dateistruktur des Projekts ist wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Projektstruktur</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/44/ps/n8/44psn8gqdploz320kpoh0yzmwxg.png"><br></div></div><br>  Es funktioniert wie folgt: <br><br><ul><li>  <b>src / controller</b> - das sind <b>genau</b> die szenen, √ºber die es oben geschrieben wurde.  In diesem Projekt ist jede Szene eine separate Steuerung, die die entsprechenden Anforderungen verarbeitet. </li><li>  <b>src / locales</b> - √úbersetzungen f√ºr verschiedene Sprachen.  Telegraf.js macht es relativ einfach, dem Bot mithilfe von Middlewares eine Lokalisierung hinzuzuf√ºgen. </li><li>  <b>src / models</b> - Modelle f√ºr MongoDB. </li><li>  <b>src / types</b> - Tipps f√ºr TypeScript.  Leider haben nicht alle im Projekt verwendeten Bibliotheken Standardzeiten. </li><li>  <b>src / util</b> - verschiedene <b>Hilfsfunktionen</b> , die in verschiedenen Teilen des Projekts verwendet werden.  Hier k√∂nnen Sie sehen, wie die Verf√ºgbarkeit des Films zum Herunterladen, zur Sitzungsverwaltung, zum Erstellen von Tastaturen, zur Fehlerbehandlung und f√ºr vieles mehr funktioniert. </li><li>  <b>src / bot.ts</b> - die Hauptdatei, in der die gesamte Vorbereitung und der Start des Bots durchgef√ºhrt werden. </li><li>  <b>src / telegram.ts</b> - In diesem Fall erstellen wir ein Objekt der Telegram-Klasse aus der Telegraf.js-Bibliothek.  Mit diesem Objekt k√∂nnen wir zuerst Nachrichten mit ihrer ID an Benutzer senden und nicht warten, bis sie etwas schreiben.  In diesem Projekt senden wir dem Benutzer beispielsweise eine Nachricht, dass der Film, den er verfolgt hat, bereits heruntergeladen werden kann.  Nat√ºrlich bietet dieses Objekt viel mehr Funktionen. </li><li>  <b>Alles andere</b> sind Konfigurationen f√ºr verschiedene Teile des Projekts, die in diesem Artikel nicht behandelt werden. </li></ul><br><a name="start"></a><h3>  Initialisierung und Start </h3><br>  Wenn wir die Struktur des Projekts herausgefunden haben, wollen wir sehen, wie der Bot tats√§chlich startet.  Um den Artikel zu verk√ºrzen, werde ich hier nicht den gesamten Code einf√ºgen, sondern nur √ºber die wichtigsten Momente meiner Meinung nach sprechen.  Sie k√∂nnen den vollst√§ndigen Code im Repository sehen, dessen Link am Ende des Artikels verf√ºgbar ist. <br><br>  Alles beginnt mit der Verbindung zur Datenbank, in der Informationen zu Benutzern und den von ihnen verfolgten Filmen gespeichert sind.  Nach einer erfolgreichen Verbindung registrieren wir alle im Projekt verwendeten Szenen, legen Parameter f√ºr die Lokalisierung fest und f√ºgen mehrere Middlewares hinzu - Verarbeitungssitzungen, Lokalisierung, Einrichten von Szenen sowie einige unserer eigenen.  Einer von ihnen empf√§ngt beispielsweise alle Informationen √ºber den Benutzer gem√§√ü seiner ID und f√ºgt sie dem Kontext hinzu, der in den Controllern verwendet wird.  Nach all den grundlegenden Vorbereitungen starten wir den Bot entweder im Entwicklungsmodus (Long Polling) oder im Produktionsmodus (Webhooks). <br><br>  <b>Wichtig:</b> Wenn Sie verschiedene Methoden zum Empfangen von Updates verwenden (Long Polling und Webhooks), l√∂schen Sie beim Starten des Bots im Long Polling-Modus zuerst den abh√∂renden Webhook mithilfe der GET-Anforderung unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">api.telegram.org/botYOUR_TOKEN/deleteWebhook</a> .  Andernfalls funktioniert der Bot m√∂glicherweise nicht richtig. <br><a name="userinput"></a><br><h3>  Benutzereingaben verarbeiten </h3><br>  Hurra!  Der Bot funktioniert, ist mit der Datenbank verbunden und bereit, Nachrichten von Benutzern zu empfangen.  Aber wie macht man es richtig? <br><br>  Zun√§chst ist es f√ºr Benutzer bequem, die integrierte Telegrammtastatur zu verwenden.  Wenn Sie auf die Schaltfl√§chen auf dieser Tastatur klicken, werden Nachrichten mit dem Inhalt dieser Schaltfl√§chen gesendet.  Als N√§chstes f√ºgen wir einfach Handler f√ºr diesen Text hinzu und f√ºhren bestimmte Aktionen aus. <br><br>  Die Datei <a href="">bot.ts enth√§lt</a> solche Handler.  Da der Bot zwei Sprachen unterst√ºtzt, k√∂nnen die Schaltfl√§chen auch unterschiedlichen Text enthalten - in Russisch und Englisch.  Telegraf-i18n verf√ºgt √ºber eine √úbereinstimmungsfunktion, mit der Sie auf dieselbe Schaltfl√§che in verschiedenen Sprachen klicken k√∂nnen. <br><br>  Die meisten Handler in bot.ts f√ºhren eine einzige Funktion aus - sie starten den Benutzer in die entsprechende Szene.  Wir haben also mehrere Abschnitte - Suche nach Filmen, meiner Sammlung, Einstellungen und Kontakten.  Jeder Abschnitt hat eine eigene Szene und eine eigene Schaltfl√§che. Wenn Sie darauf klicken, wechselt der Benutzer zur entsprechenden Szene. <br><br>  <b>Wichtig:</b> F√ºgen Sie unbedingt einen Handler hinzu, der den Benutzer von der Szene befreit, da er sonst Gefahr l√§uft, f√ºr immer dort zu bleiben!  Es ist auch n√ºtzlich, einen allgemeinen Befehl zu erstellen (/ saveme wird im Bot verwendet), der jeder Szene und der Hauptdatei hinzugef√ºgt wird.  Dieser Befehl dient zum Beenden einer beliebigen Szene sowie zum Zur√ºcksetzen der Benutzereinstellungen. <br><br>  Und jetzt m√∂chte der Benutzer zur Suche nach Filmen gehen.  Durch Klicken auf die entsprechende Schaltfl√§che verschieben wir sie in die Suchszene.  Der Einfachheit halber verf√ºgt jede Szene √ºber einen eigenen Ordner mit Dateien, von denen jede eine bestimmte Funktion ausf√ºhrt. <br><br>  Innerhalb der Szene k√∂nnen Sie Ihre Middlewares verwenden, die sich in der Datei middlewares.ts befinden.  Wenn Sie beispielsweise Middleware in der Suchszene verwenden, k√∂nnen Sie einfach alle Informationen zum Film an die entsprechenden Methoden weiterleiten, anstatt jedes Mal dieselbe Funktion in ihnen auszuf√ºhren. <br><br>  Telegramm hat auch eine Inline-Tastatur.  Vielleicht sind Sie auf Nachrichten mit Stimmen gesto√üen, unter denen sich mehrere durchscheinende Schaltfl√§chen befinden, und wenn Sie auf eine davon klicken, √§ndert sich die Anzahl der Stimmen.  Diese Schaltfl√§chen sind die Inline-Tastatur <br><br><div class="spoiler">  <b class="spoiler_title">So sieht es bei Eva aus</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gz/sn/-n/gzsn-nvolazzilaylnhy-ugacny.png"><br></div></div><br>  Jede Schaltfl√§che enth√§lt Informationen. Wenn Sie auf die Schaltfl√§che klicken, werden diese an den entsprechenden Handler √ºbertragen.  <b>Die Gr√∂√üe der √ºbertragenen Informationen sollte 64 Bytes nicht √ºberschreiten!</b>  Um dem Bot das Abh√∂ren von Tastenklicks beizubringen, m√ºssen wir sie mit bot.action (/ trigger /, callback) registrieren.  Der erste Parameter enth√§lt alle Daten, die an die Schaltfl√§che gebunden wurden.  Ich habe mich f√ºr Aktionen wie Redux entschieden, bei denen an jede Schaltfl√§che ein Objekt der Form {a: actionName, p: payload} angeh√§ngt ist.  Bei der Registrierung von Listenern k√∂nnen wir ein einfaches RegExp verwenden, zum Beispiel: bot.action (/ actionName /, callBack).  Alle Handler f√ºr die Inline-Tastatur befinden sich in den Dateien action.ts. <br><br>  Dar√ºber hinaus gibt es in einigen Szenen helpers.ts-Dateien, die kleine Funktionen enthalten, die zum Entladen der verbleibenden Dateien herausgenommen wurden.  Zum gr√∂√üten Teil gibt es Tastaturgeneratoren f√ºr verschiedene Aktionen des Benutzers. <br><a name="localization"></a><br><h3>  Lokalisierung </h3><br>  Da dies ein wichtiges Thema ist, halte ich es f√ºr gesondert zu erw√§hnen.  Wie ich bereits sagte, enth√§lt Telegraf.js eine ziemlich gro√üe Anzahl von Middlewares, von denen eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegraf-i18n ist</a> .  Das Repository enth√§lt detaillierte Anweisungen und ich hatte keine besonderen Probleme damit, aber ich werde trotzdem ein paar Worte dazu hinzuf√ºgen, wie dies in diesem Projekt funktioniert. <br><br>  Es gibt einen Gebietsschema-Ordner, in dem sich die zu lokalisierenden Dateien befinden, bei denen es sich um ein JSON-Objekt der Form {"key": "translation"} handelt.  Wo immer wir verschiedene Sprachen verwenden m√ºssen, verwenden wir die Methode aus dieser Bibliothek, wo wir die ben√∂tigte √úbersetzung per Schl√ºssel √ºbertragen und am Ausgang die entsprechende √úbersetzung erhalten.  In einer Sitzung k√∂nnen Informationen zur vom Benutzer ausgew√§hlten Sprache gespeichert werden.  Erw√§hnenswert auch noch einmal √ºber die Tasten.  In derselben Bibliothek befindet sich eine √úbereinstimmungsfunktion. Wenn sich der Text auf der Schaltfl√§che je nach Sprache √§ndert, k√∂nnen Sie mit dieser Funktion den richtigen Listener aufh√§ngen. <br><br>  <b>Wichtig:</b> Wenn Sie die Lokalisierung verwenden und einen Bot in TypeScript schreiben m√∂chten, vergessen Sie nicht, den √úbersetzungsordner zu tsconfig.json hinzuzuf√ºgen, da sonst der Code nicht kompiliert wird.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"include"</span></span>: [<span class="hljs-string"><span class="hljs-string">"src/locales/*.json"</span></span>]</code> </pre> <br><a name="conclusion"></a><h3>  Fazit </h3><br>  Vielen Dank f√ºr das Lesen bis zum Ende!  In diesem Artikel habe ich versucht, den Prozess der Erstellung eines Telegramm-Bots als Ganzes so detailliert wie m√∂glich zu beschreiben, ohne eine starke Bindung an mein Projekt zu haben.  Ich hoffe, dass Sie nach dem Lesen dieses Artikels und dem Studium des Quellcodes f√ºr Eve ganz einfach einen Bot erstellen k√∂nnen, der Ihnen helfen kann. <br><br>  Wie versprochen k√∂nnen Sie sich den Quellcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ansehen und Eve hier in Aktion ausprobieren.  F√ºr Kritik und Verbesserungsvorschl√§ge bin ich sehr dankbar. <br><br>  Ich m√∂chte auch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt</a> in der Dokumentation von Telegraf.js mit interessanten Open-Source-Projekten erw√§hnen, die Sie sich ansehen und von Architektur und L√∂sungen inspirieren lassen k√∂nnen.  Ich m√∂chte wiederum einen von ihnen erw√§hnen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Guard Bot</a> .  Ein wirklich gro√üer und gut gemachter Bot, von dem ich einige L√∂sungen f√ºr meine Entwicklung ausgeliehen habe. <br><br>  Und im Moment habe ich alles gesagt, was ich wollte, ich werde gerne Ihre Fragen, Vorschl√§ge und Kommentare beantworten! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443876/">https://habr.com/ru/post/de443876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443862/index.html">Das Auto des Staatsanwalts schlie√üt. Bestchange ist wieder gesperrt</a></li>
<li><a href="../de443868/index.html">Als Programmierer ging ich ins Fitnessstudio und was daraus wurde</a></li>
<li><a href="../de443870/index.html">Einheit: Prozedurale Netzbearbeitung</a></li>
<li><a href="../de443872/index.html">√úbersicht √ºber die neuen Funktionen von nanoCAD SPDS Steelwork Version 1.2</a></li>
<li><a href="../de443874/index.html">Vergleich von Deep-Learning-Frameworks: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe usw.</a></li>
<li><a href="../de443878/index.html">DEV Labs 2019. Python zur L√∂sung nicht trivialer Aufgaben. Online Mitap</a></li>
<li><a href="../de443882/index.html">MOSDROID # 15 Phosphor: Leistungsvideo</a></li>
<li><a href="../de443884/index.html">3 Schl√ºsselqualit√§ten eines erfolgreichen Produktmanagers: Anton Danilov</a></li>
<li><a href="../de443886/index.html">L√∂sen einer Aufgabe aus einem Google-Interview mit JavaScript: 4 verschiedene M√∂glichkeiten</a></li>
<li><a href="../de443894/index.html">Die vierte Ebene von Max Tegmarks Multiuniversum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>