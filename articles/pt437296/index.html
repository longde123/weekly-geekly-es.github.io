<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÆÔ∏è üôÇ ü§æüèª Por que as pessoas n√£o usam m√©todos formais? ü¶ë üå† üßìüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No Software Engineering Stack Exchange, vi a seguinte pergunta : "O que est√° impedindo a ampla ado√ß√£o de m√©todos formais?" A pergunta foi encerrada co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que as pessoas n√£o usam m√©todos formais?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437296/"> No Software Engineering Stack Exchange, vi a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguinte pergunta</a> : "O que est√° impedindo a ampla ado√ß√£o de m√©todos formais?"  A pergunta foi encerrada como tendenciosa, e a maioria das respostas foram coment√°rios como "Muito caro !!!"  ou "Um site n√£o √© um avi√£o !!!"  De certa forma, isso √© verdade, mas n√£o explica muito.  Eu escrevi este artigo para fornecer uma imagem hist√≥rica mais ampla dos m√©todos formais (FM), por que eles n√£o s√£o realmente usados ‚Äã‚Äãe o que estamos fazendo para corrigir a situa√ß√£o. <br><br>  Antes de come√ßar, voc√™ precisa formular algumas condi√ß√µes.  De fato, n√£o existem muitos m√©todos formais: apenas <abbr title="O TLA + √© uma das linguagens de especifica√ß√£o mais populares e todos os especialistas em TLA + cabem em um grande √¥nibus escolar">alguns pequenos grupos</abbr> .  Isso significa que grupos diferentes usam os termos de maneira diferente.  Em termos gerais, existem dois grupos de m√©todos formais: a <b>especifica√ß√£o formal</b> estuda a reda√ß√£o de especifica√ß√µes precisas e inequ√≠vocas e a <b>verifica√ß√£o formal</b> estuda os m√©todos de prova.  Isso inclui sistemas de c√≥digo e abstratos.  N√£o apenas usamos termos diferentes para c√≥digo e sistemas, como tamb√©m usamos ferramentas diferentes para verific√°-los.  Para tornar as coisas ainda mais confusas, se algu√©m diz que est√° criando uma especifica√ß√£o formal, isso <i>geralmente</i> significa verifica√ß√£o de design.  E se algu√©m disser que est√° fazendo verifica√ß√£o formal, isso <i>geralmente</i> se refere √† verifica√ß√£o de c√≥digo. <br><a name="habracut"></a><br>  Para maior clareza, dividimos a <b>verifica√ß√£o de verifica√ß√£o de c√≥digo</b> (CV) e <b>a verifica√ß√£o de design</b> (DV) e da mesma forma dividimos as especifica√ß√µes em CS e DS.  Tais termos n√£o s√£o comumente usados ‚Äã‚Äãna ampla comunidade de FM.  Vamos come√ßar com CS e CV, depois passar para DS e DV. <br><br>  Al√©m disso, <b>a verifica√ß√£o parcial</b> √© poss√≠vel, onde apenas um subconjunto da especifica√ß√£o √© verificado ou <b>a verifica√ß√£o completa</b> .  Essa pode ser a diferen√ßa entre as evid√™ncias das alega√ß√µes de que "o sistema nunca falha e n√£o aceita a senha errada" ou "o sistema nunca falha e bloqueia a conta se voc√™ digitar a senha errada tr√™s vezes".  Basicamente, assumiremos que estamos fazendo uma verifica√ß√£o completa. <br><br>  Voc√™ tamb√©m deve esclarecer o tipo de software que estamos formalizando.  A maioria das pessoas identifica implicitamente programas <b>altamente confi√°veis</b> , como dispositivos m√©dicos e avi√µes.  As pessoas assumem que os m√©todos formais s√£o amplamente utilizados, mas n√£o s√£o necess√°rios para o resto.  Isso √© <i>otimista</i> demais: o software mais confi√°vel n√£o usa m√©todos formais.  Em vez disso, focaremos no software "regular". <br><br>  Finalmente, o aviso: n√£o sou um historiador profissional e, embora tenha tentado verificar cuidadosamente as informa√ß√µes, pode haver erros no artigo.  Al√©m disso, sou especialista em especifica√ß√µes formais (DS e DV), para que haja mais chances de erro quando falo sobre verifica√ß√£o de c√≥digo.  Se voc√™ vir, escreva para mim, vou corrigi-lo (e mais uma coisa: ganho dinheiro com semin√°rios sobre TLA + e Alloy, portanto, sou muito tendencioso em rela√ß√£o a esses idiomas; tento ser o mais objetivo poss√≠vel, mas voc√™ entende: vi√©s √© preconceito). <br><br><h1>  Programa√ß√£o formal </h1><br><h2>  Obtendo especifica√ß√£o </h2><br>  Antes de provar a exatid√£o do c√≥digo, voc√™ precisa obter o padr√£o da verdade.  Isso significa alguma <b>especifica√ß√£o do</b> que o c√≥digo deve fazer.  Devemos ter certeza de que o resultado corresponde √† especifica√ß√£o.  N√£o basta dizer que a lista est√° "classificada": n√£o sabemos o que estamos classificando, quais crit√©rios usamos e at√© mesmo o que queremos dizer com "classifica√ß√£o".  Em vez disso, podemos dizer: "A lista de n√∫meros inteiros <code>l</code> <i>classificada em ordem crescente</i> para quaisquer dois √≠ndices iej, se <code>i &lt; j</code> , ent√£o <code>l[i] &lt;= l[j]</code> ". <br><br>  As especifica√ß√µes de c√≥digo s√£o divididas em tr√™s tipos principais: <br><br><ol><li>  O primeiro √© escrever instru√ß√µes independentes de c√≥digo.  Escrevemos nossa fun√ß√£o de classifica√ß√£o e, em um arquivo separado, escrevemos o teorema ‚Äúisto retorna listas ordenadas‚Äù.  Essa √© a forma mais antiga de especifica√ß√£o, mas Isabelle e ACL2 ainda funcionam dessa maneira (o ML foi inventado especificamente para ajudar a escrever essas especifica√ß√µes). <br></li><li>  O segundo implementa especifica√ß√µes no c√≥digo na forma de pr√© e p√≥s-condi√ß√µes, instru√ß√µes e invariantes.  Voc√™ pode adicionar uma p√≥s-condi√ß√£o √† fun√ß√£o que "o valor retornado √© uma lista classificada".  As especifica√ß√µes baseadas em declara√ß√µes foram formalizadas inicialmente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a l√≥gica de Hoar</a> .  Eles apareceram pela primeira vez na linguagem de programa√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Euclid</a> no in√≠cio dos anos 1970 (n√£o est√° claro quem come√ßou a us√°-los: Euclid ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SPV</a> , mas, tanto quanto eu sei, o Euclid j√° havia sido apresentado ao p√∫blico antes).  Esse estilo tamb√©m √© chamado de <b>programa√ß√£o de contratos</b> - a forma mais popular de verifica√ß√£o na ind√∫stria moderna (aqui, os contratos s√£o usados ‚Äã‚Äãcomo especifica√ß√µes de c√≥digo). <br></li><li>  Finalmente, existem sistemas de tipos.  Pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">correspond√™ncia de Curry-Howard,</a> qualquer teorema ou prova matem√°tica pode ser codificado como um tipo dependente.  Definiremos o tipo de lista classificada e declararemos o tipo <code>[Int] -&gt; Sorted [Int]</code> para a fun√ß√£o. </li></ol><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Let's Prove Leftpad,</a> voc√™ pode ver como fica.  HOL4 e Isabelle s√£o bons exemplos das especifica√ß√µes do "teorema independente", SPARK e Dafny s√£o as especifica√ß√µes da "declara√ß√£o aninhada" e Coq e Agda s√£o o "tipo dependente". <br><br>  Se voc√™ observar atentamente, essas tr√™s formas de especifica√ß√£o de c√≥digo s√£o comparadas com as tr√™s principais √°reas de valida√ß√£o autom√°tica: testes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contratos</a> e tipos.  Isto n√£o √© uma coincid√™ncia.  A corre√ß√£o √© uma ampla variedade e a verifica√ß√£o formal √© um de seus extremos.  √Ä medida que o rigor (e o esfor√ßo) da verifica√ß√£o diminui, obtemos verifica√ß√µes mais simples e mais restritas, seja limitando o espa√ßo de estados em estudo, usando tipos mais fracos ou for√ßando a verifica√ß√£o em tempo de execu√ß√£o.  Ent√£o, qualquer meio de especifica√ß√£o completa se transforma em meio de especifica√ß√£o parcial e vice-versa: muitos consideram a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sala limpa uma</a> t√©cnica de verifica√ß√£o formal, onde uma revis√£o de c√≥digo vai muito al√©m das capacidades humanas. <br><br><h3>  Quais especifica√ß√µes est√£o corretas? </h3><br>  A verifica√ß√£o verifica se o c√≥digo est√° em conformidade com a especifica√ß√£o.  Surge a pergunta: como sabemos que temos a especifica√ß√£o correta?  Encontrar a especifica√ß√£o certa √© um dos maiores problemas nos m√©todos formais.  Essa tamb√©m √© uma das principais obje√ß√µes a eles.  Mas os c√©ticos aqui n√£o significam <i>exatamente o</i> que os especialistas formais t√™m em mente. <br><br>  Quando pessoas de fora perguntam: "Como voc√™ obt√©m as especifica√ß√µes corretas?" Eles <i>geralmente</i> pensam em <b>valida√ß√£o</b> , ou seja, especifica√ß√µes que n√£o atendem aos requisitos do cliente.  Se voc√™ provar formalmente que seu c√≥digo classifica a lista, e o cliente realmente deseja o Uber para sopas (tm), voc√™ gasta muito tempo.  Assim, apenas itera√ß√µes r√°pidas e curtos loops de feedback podem confirmar seus requisitos. <br><br>  √â verdade que a verifica√ß√£o de c√≥digo n√£o a valida.  Mas h√° dois problemas com esse argumento.  A primeira √© que o est√°gio de aplica√ß√£o de m√©todos formais √© simplesmente adiado, mas n√£o desaparece completamente.  Depois de todas essas itera√ß√µes r√°pidas, voc√™ provavelmente j√° tem uma id√©ia do que o cliente deseja.  E <i>ent√£o voc√™</i> come√ßa a verifica√ß√£o do c√≥digo.  Em segundo lugar, embora n√£o saibamos exatamente o que o cliente deseja, podemos assumir o que ele definitivamente <i>n√£o</i> quer.  Por exemplo, para travar acidentalmente o software.  Eles n√£o precisam de brechas de seguran√ßa.  Todo mundo concorda com isso: no final, ningu√©m diz que voc√™ precisa pular testes de unidade durante as itera√ß√µes.  Portanto, pelo menos, verifique se o seu sistema de controle de vers√£o n√£o exclui dados aleat√≥rios do usu√°rio (nota: n√£o pense que estou amargurado ou algo parecido). <br><br>  O problema de encontrar a especifica√ß√£o correta √© mais fundamental: <i>geralmente n√£o sabemos o que escrever l√°</i> .  Pensamos em nossos requisitos em termos humanos, n√£o matem√°ticos.  Se eu disser: "O programa deve distinguir √°rvores de p√°ssaros", ent√£o o que √© isso?  Eu posso explicar para uma pessoa mostrando um monte de fotos de √°rvores e p√°ssaros, mas esses s√£o apenas exemplos concretos, n√£o uma descri√ß√£o da <i>id√©ia</i> .  De fato, para traduzir isso em uma especifica√ß√£o formal, √© necess√°rio formalizar conceitos humanos, e isso √© um problema s√©rio. <br><br>  N√£o me interpretem mal.  As especifica√ß√µes relevantes podem ser definidas aqui, e especialistas fazem isso o tempo todo.  Mas escrever as especifica√ß√µes apropriadas √© uma habilidade que precisa ser desenvolvida, bem como habilidades de programa√ß√£o.  √â por isso que muitos dos sucessos recentes da verifica√ß√£o de c√≥digo s√£o explicados por um mapeamento claro do que queremos e do que podemos expressar.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CompCert</a> √© um compilador formalmente verificado em C. A especifica√ß√£o para isso √©: ‚ÄúEvitar erros de compila√ß√£o‚Äù. <br><br>  Mas tudo isso n√£o tem nada a ver com verifica√ß√£o.  Quando voc√™ tem uma especifica√ß√£o, ainda precisa provar que o c√≥digo corresponde a ela. <br><br><h3>  Prova de especifica√ß√£o </h3><br>  A primeira ferramenta de verifica√ß√£o de c√≥digo de todos os tempos √© o m√©todo ‚Äúpense sobre por que isso √© verdade‚Äù, no estilo Dijkstra, principalmente para o ALGOL.  Por exemplo, eu posso "provar" a corre√ß√£o da classifica√ß√£o pelo m√©todo insert da seguinte maneira: <br><br><ol><li>  <i>A op√ß√£o b√°sica</i> : se voc√™ adicionar um elemento √† lista vazia, ele ser√° o √∫nico elemento e, portanto, ser√° classificado. <br></li><li>  Se tivermos uma lista classificada com elementos k e adicionarmos um elemento, inseriremos o elemento para que ele fique depois de todos os n√∫meros menores e antes de todos os n√∫meros maiores.  Isso significa que a lista ainda est√° classificada. <br></li><li>  Por indu√ß√£o, a classifica√ß√£o por inser√ß√£o classificar√° a lista inteira. </li></ol><br>  Obviamente, na realidade, a prova parecer√° mais rigorosa, mas essa √© uma ideia geral.  Dijkstra e outros usaram esse estilo para provar a corre√ß√£o de muitos algoritmos, incluindo muitos dos conceitos b√°sicos de simultaneidade.  Este tamb√©m √© o estilo ao qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as palavras de Knuth</a> est√£o associadas: "Cuidado com os erros neste c√≥digo;  S√≥ provei que estava correto, mas n√£o o iniciei. "  Voc√™ pode arruinar facilmente uma prova matem√°tica para que ningu√©m perceba.  Segundo algumas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estimativas</a> , aproximadamente 20% da evid√™ncia matem√°tica publicada cont√©m erros.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20140630071239/">Peter Guttmann</a> tem um excelente ensaio sobre as evid√™ncias da integridade de um programa rid√≠culo, em que toneladas de c√≥digo "testado" caem imediatamente se voc√™ os executar. <br><br>  Ao mesmo tempo, estudamos maneiras de provar automaticamente teoremas matem√°ticos.  O primeiro <b>programa para provar os teoremas</b> foi publicado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1967</a> .  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">in√≠cio</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">d√©cada de 1970,</a> esses programas come√ßaram a ser usados ‚Äã‚Äãpara testar o c√≥digo Pascal e, no meio da d√©cada, apareceram linguagens formais especiais.  O programador formula algumas propriedades do c√≥digo e cria uma prova verific√°vel de que o c√≥digo tem essas propriedades.  Os primeiros programas para provar teoremas simplesmente ajudaram as pessoas a verificar as provas, enquanto ferramentas mais sofisticadas poderiam provar independentemente partes do teorema. <br><br>  O que leva ao seguinte problema. <br><br><h3>  √â dif√≠cil obter evid√™ncias </h3><br>  A evid√™ncia √© dif√≠cil e √© um trabalho muito desagrad√°vel.  √â dif√≠cil parar de programar e ir ao circo.  Surpreendentemente, as provas formais de c√≥digo s√£o muitas vezes mais rigorosas que as escritas pela maioria dos matem√°ticos!  A matem√°tica √© uma atividade muito criativa, onde a resposta ao teorema √© v√°lida apenas se voc√™ o mostrar.  Criatividade vai mal com formalismo e computadores. <br><br>  Pegue o mesmo exemplo de classifica√ß√£o de inser√ß√£o em que aplicamos a indu√ß√£o.  Qualquer matem√°tico entender√° imediatamente o que √© a indu√ß√£o, como funciona em geral e como funciona neste caso.  Mas no programa para provar os teoremas tudo precisa ser estritamente formalizado.  O mesmo se aplica √† prova por contradi√ß√£o, prova por contraposi√ß√£o, etc. Al√©m disso, todas as suposi√ß√µes devem ser formalizadas, mesmo aquelas em que a maioria dos matem√°ticos n√£o se preocupa com a prova.  Por exemplo, <code>a + (b + c) = (a + b) + c</code> .  O programa de verifica√ß√£o de teoremas a priori n√£o sabe que isso √© verdade.  Voc√™ tem que provar isso (dif√≠cil) ou declar√°-lo como verdade de acordo com a lei associativa de adi√ß√£o (perigosa), ou comprar uma biblioteca de teoremas de algu√©m que j√° foi capaz de provar isso (caro).  Os primeiros programas de prova de teoremas competiam no n√∫mero de t√°ticas de prova integradas e bibliotecas de teoremas relacionadas.  Um dos primeiros programas SPADE difundidos apresentou a biblioteca aritm√©tica completa como a principal vantagem. <br><br>  Em seguida, voc√™ precisa obter a prova em si.  Voc√™ pode confiar isso ao programa ou escrever voc√™ mesmo.  Normalmente, a defini√ß√£o autom√°tica de evid√™ncia n√£o √© decid√≠vel.  Para casos extremamente estreitos, como l√≥gica proposicional ou verifica√ß√£o de tipo HM, √© "apenas" NP-completo.  De fato, n√≥s mesmos escrevemos a maioria das evid√™ncias e o computador verifica sua exatid√£o.  Isso significa que voc√™ precisa saber bem: <br><br><ul><li>  matem√°tica <br></li><li>  ci√™ncia da computa√ß√£o; <br></li><li>  a √°rea em que voc√™ trabalha: compiladores, hardware, etc; <br></li><li>  as nuances do seu programa e especializa√ß√£o; <br></li><li>  as nuances do programa para provar os teoremas que voc√™ usa, o que por si s√≥ √© uma especialidade inteira. </li></ul><br>  Pior, paus espec√≠ficos para computadores s√£o colocados nas rodas.  Lembre-se, eu disse que era perigoso assumir uma lei associativa de adi√ß√£o?  Alguns idiomas n√£o cumprem.  Por exemplo, em C ++ <code>INT_MAX. ((-1) + INT_MAX) + 1</code>  <code>INT_MAX. ((-1) + INT_MAX) + 1</code> √© <code>INT_MAX. -1 + (INT_MAX + 1)</code>  <code>INT_MAX. -1 + (INT_MAX + 1)</code> , que √© indetect√°vel.  Assumindo a adi√ß√£o associativa em C ++, sua prova estar√° incorreta e o c√≥digo ser√° quebrado.  Voc√™ deve evitar essa declara√ß√£o ou provar que nunca haver√° transbordamento para seu fragmento espec√≠fico. <br><br>  Voc√™ pode dizer que a adi√ß√£o indefinida √© um erro, mas voc√™ precisa usar um idioma com n√∫meros inteiros n√£o relacionados.  Mas a maioria dos idiomas possui recursos espec√≠ficos que interferem nas evid√™ncias.  Pegue o seguinte c√≥digo: <br><br><pre> <code class="plaintext hljs">a = true; b = false; f(a); assert a;</code> </pre> <br>  Esse √© sempre o caso?  N√£o √© um fato.  Talvez <code>f</code> mude <code>a</code> .  Talvez isso mude o fluxo paralelo.  Talvez <code>b</code> atribu√≠do um alias <code>a</code> , portanto, alter√°-lo tamb√©m mudar√° <code>a</code> (nota: aliases tornam t√£o dif√≠cil escrever evid√™ncias de que John C. Reynolds teve que criar uma <b>l√≥gica de separa√ß√£o</b> completamente nova para lidar com esse problema).  Se algo assim for poss√≠vel no seu idioma, voc√™ deve provar claramente que isso n√£o acontece aqui.  O c√≥digo limpo ajudar√° aqui, em outro caso, ele pode destruir a prova, porque for√ßa voc√™ a usar a recurs√£o e fun√ß√µes de ordem superior.  A prop√≥sito, ambos s√£o a base para escrever bons programas funcionais.  O que √© bom para a programa√ß√£o √© ruim para a prova!  (Nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta palestra,</a> Edmund Clark listou algumas propriedades dif√≠ceis de verificar: ‚Äúpontos flutuantes, seq√º√™ncias de caracteres, tipos definidos pelo usu√°rio, procedimentos, simultaneidade, modelos universais, armazenamento, bibliotecas ...‚Äù). <br><br>  Os verificadores formais t√™m um dilema: quanto mais expressiva a linguagem, mais dif√≠cil √© provar algo.  Mas quanto menos expressiva a linguagem, mais dif√≠cil √© escrever nela.  As primeiras linguagens formais de trabalho eram subconjuntos muito limitados de idiomas mais expressivos: ACL2 era um subconjunto do Lisp, Euclid era um subconjunto do Pascal etc. E nada do que discutimos at√© agora prova programas reais, s√£o apenas tentativas de abordagem. para escrever provas. <br><br>  A evid√™ncia √© dif√≠cil.  Mas est√° ficando mais f√°cil.  Os pesquisadores desse campo acrescentam novas heur√≠sticas, bibliotecas de teoremas, componentes pr√©-testados, etc. O progresso t√©cnico tamb√©m ajuda: quanto mais r√°pido os computadores, mais r√°pida a pesquisa. <br><br><h3>  Revolu√ß√£o SMT </h3><br>  Uma das inova√ß√µes em meados da d√©cada de 2000 foi a inclus√£o de solucionadores de SMT em programas para provar teoremas.  Em termos gerais, um solucionador SMT pode transformar (alguns) teoremas matem√°ticos em problemas de conformidade com restri√ß√µes.  Isso transforma uma tarefa criativa em uma computacional.  Talvez voc√™ ainda precise fornecer problemas intermedi√°rios (lemas) como etapas no teorema, mas isso √© melhor do que provar tudo voc√™ mesmo.  Os primeiros solucionadores de SMT apareceram por volta de 2004, primeiro como projetos acad√™micos.  Alguns anos depois, a Microsoft Research lan√ßou o Z3, um solucionador SMT pronto para uso.  A grande vantagem do Z3 foi que ele se tornou muito mais conveniente do que outros SMTs, que, francamente, n√£o disseram quase nada.  A Microsoft Research o utilizou internamente para ajudar a provar as propriedades do kernel do Windows, para que n√£o se limitassem ao UX m√≠nimo. <br><br>  O SMT atingiu a comunidade de FM por baixo do f√¥lego porque, de repente, fez muitas evid√™ncias simples triviais e permitiu que ele abordasse problemas muito complexos.  Assim, as pessoas podiam trabalhar em linguagens mais expressivas, j√° que agora os problemas das declara√ß√µes expressivas come√ßaram a ser resolvidos.  Um progresso incr√≠vel √© evidente no projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IronFleet</a> : usando os melhores solucionadores de SMT e uma linguagem de verifica√ß√£o avan√ßada, a Microsoft conseguiu escrever 5.000 linhas de c√≥digo Dafny comprovado em apenas 3,7 homens-ano!  Este √© um ritmo incrivelmente r√°pido: <i>at√© quatro linhas inteiras por dia</i> (nota: o registro anterior pertencia ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seL4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cujos</a> desenvolvedores escreviam <i>duas linhas por dia em C.</i> <br><br>  A evid√™ncia √© dif√≠cil. <br><br><h3>  Por que isso √© necess√°rio? </h3><br>  √â hora de dar um passo atr√°s e perguntar: "Qual √© o objetivo?"  Estamos tentando provar que algum programa atende a alguma especifica√ß√£o.  A corre√ß√£o √© um intervalo.  H√° duas partes na verifica√ß√£o: qu√£o objetivamente "correto" √© o seu programa e com que cuidado voc√™ verificou a exatid√£o.  Obviamente, quanto mais verificado, melhor, mas a verifica√ß√£o vale tempo e dinheiro.  Se tivermos v√°rias restri√ß√µes (desempenho, tempo de coloca√ß√£o no mercado, custo, etc.), uma valida√ß√£o completa n√£o √© necessariamente a melhor op√ß√£o.  Em seguida, surge a pergunta: qual √© a verifica√ß√£o m√≠nima de que precisamos e quanto custa.  Na maioria dos casos, por exemplo, 90% ou 95% ou 99% de corre√ß√£o √© suficiente para voc√™.  Talvez voc√™ deva gastar algum tempo melhorando a interface, em vez de verificar os 1% restantes? <br><br>  Em seguida, a pergunta: "Um cheque de 90/95/99% √© muito mais barato que 100%?"  A resposta √© sim.  √â bastante confort√°vel dizer que a base de c√≥digo, que testamos e digitamos bem, <i>est√° basicamente</i> correta, exceto por algumas corre√ß√µes na produ√ß√£o, e at√© escrevemos mais de quatro linhas de c√≥digo por dia.  De fato, a grande maioria das falhas em sistemas distribu√≠dos poderia ter sido evitada com testes um pouco mais abrangentes.  E √© apenas uma extens√£o dos testes, para n√£o mencionar distor√ß√µes, testes baseados em propriedades ou testes de modelos.  Voc√™ pode obter um resultado verdadeiramente not√°vel com esses truques simples sem precisar obter a prova completa. <br><br>  E se a digita√ß√£o e o teste n√£o fornecerem verifica√ß√£o suficiente?  Ainda √© muito mais f√°cil alternar de 90% para 99% do que de 99% para 100%.  Como mencionado anteriormente, o Cleanroom √© uma pr√°tica do desenvolvedor que inclui documenta√ß√£o abrangente, an√°lise completa do fluxo e extensas revis√µes de c√≥digo.  Nenhuma evid√™ncia, nenhuma verifica√ß√£o formal, nem mesmo testes de unidade.  Mas uma Sala Limpa adequadamente organizada reduz a densidade de defeitos para menos de 1 bug por 1000 linhas de c√≥digo na produ√ß√£o (nota: n√∫meros do estudo Stavley em <i>Toward Zero-Deect Programming</i> &gt; mas sempre seja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√©tico e verifique a fonte</a> ).  A programa√ß√£o de salas limpas n√£o diminui o ritmo do desenvolvimento e certamente ultrapassa 4 linhas por dia.  E a pr√≥pria sala limpa √© apenas um dos muitos m√©todos de desenvolvimento de software altamente confi√°veis ‚Äã‚Äãque est√£o entre o desenvolvimento usual e a verifica√ß√£o de c√≥digo.  Voc√™ n√£o precisa de verifica√ß√£o completa para escrever um bom software ou at√© quase perfeito.  H√° momentos em que √© necess√°rio, mas para a maioria das ind√∫strias √© um desperd√≠cio de dinheiro. <br><br>  No entanto, isso n√£o significa que os m√©todos formais geralmente n√£o sejam econ√¥micos.  Muitos dos m√©todos altamente confi√°veis ‚Äã‚Äãmencionados acima s√£o baseados em especifica√ß√µes de c√≥digo de escrita que voc√™ n√£o prova formalmente.  Em termos de verifica√ß√£o, existem duas maneiras comuns pelas quais o setor se beneficia.  Primeiro, verifique a verifica√ß√£o em vez do c√≥digo, que discutiremos mais adiante.  Em segundo lugar, uma verifica√ß√£o parcial do c√≥digo, que consideraremos agora. <br><br><h2>  Verifica√ß√£o parcial do c√≥digo </h2><br>  Para tarefas di√°rias, √© muito caro fazer uma verifica√ß√£o completa.  Que tal parcial?  Afinal, voc√™ pode se beneficiar da prova de algumas propriedades de fragmentos de c√≥digo individuais.  Em vez de provar que minha fun√ß√£o sempre classifica os n√∫meros corretamente, posso pelo menos provar que ela n√£o se repete para sempre e nunca sai da faixa.  Esta tamb√©m √© uma informa√ß√£o muito √∫til.  Portanto, mesmo a evid√™ncia mais simples dos programas C √© uma √≥tima maneira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de eliminar uma grande parte do comportamento indefinido</a> . <br><br>  O problema √© a <i>acessibilidade</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maioria dos idiomas √© projetada para verifica√ß√£o completa ou n√£o √© compat√≠vel com isso. No primeiro caso, voc√™ perde muitos recursos bons de linguagens mais expressivas e, no segundo caso, precisa de uma maneira de provar as coisas em uma linguagem hostil ao pr√≥prio conceito. Por esse motivo, a maioria dos estudos sobre verifica√ß√£o parcial se concentra em v√°rias linguagens de alta prioridade, como C e Java. Muitos trabalham com subconjuntos limitados de idiomas. Por exemplo, SPARK √© um subconjunto limitado do Ada, para que voc√™ possa escrever um c√≥digo cr√≠tico do SPARK e interagir com um c√≥digo Ada menos cr√≠tico. Mas a maioria desses idiomas √© bastante nicho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com mais freq√º√™ncia, certos tipos de verifica√ß√£o s√£o incorporados na estrutura b√°sica dos idiomas. </font><font style="vertical-align: inherit;">Os sistemas de tipifica√ß√£o usados ‚Äã‚Äãna produ√ß√£o s√£o uma variante comum: voc√™ pode n√£o saber que a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cauda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sempre retorna a cauda, ‚Äã‚Äãmas sabe exatamente qual √© o seu tipo </font></font><code>[a] -&gt; [a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Existem tamb√©m exemplos como Rust, com seguran√ßa de mem√≥ria comprovada, e Pony, com prova de seguran√ßa, com exce√ß√µes. </font><font style="vertical-align: inherit;">Eles s√£o um pouco diferentes de SPARK e Frama-C, na medida em que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√≥</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podem executar </font><font style="vertical-align: inherit;">verifica√ß√µes parciais. </font><font style="vertical-align: inherit;">E eles geralmente s√£o desenvolvidos por especialistas em linguagens de programa√ß√£o, e n√£o especialistas em m√©todos formais: h√° muito em comum entre as duas disciplinas, mas n√£o s√£o id√™nticos. </font><font style="vertical-align: inherit;">Talvez por isso, linguagens como Rust e Haskell s√£o realmente adequadas para uso pr√°tico.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Especifica√ß√£o de projeto </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, falamos apenas sobre a verifica√ß√£o de c√≥digo. No entanto, os m√©todos formais t√™m outro lado, que √© mais abstrato e verifica o design em si, a arquitetura do projeto. Essa an√°lise √© t√£o profunda que √© sin√¥nimo de uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especifica√ß√£o formal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se algu√©m diz que est√° cumprindo uma especifica√ß√£o formal, provavelmente significa que ele define e verifica o design.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como j√° dissemos, provar todas as linhas de c√≥digo √© muito, muito dif√≠cil. Mas muitos problemas na produ√ß√£o surgem n√£o por causa do c√≥digo, mas por causa da intera√ß√£o dos componentes do sistema. Se ignorarmos os detalhes da implementa√ß√£o, por exemplo, considerarmos que o sistema √© capaz de reconhecer p√°ssaros, ser√° mais f√°cil analisar como as √°rvores e os p√°ssaros se encaixam no design geral como m√≥dulos de alto n√≠vel. Nessa escala, fica muito mais f√°cil descrever coisas que voc√™ n√£o conseguia entender, como um ambiente de tempo de execu√ß√£o, intera√ß√µes humanas ou um </font></font><abbr title="se o estudo de m√©todos formais me ensinou o que √©, o tempo √© mau e eu odeio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fluxo de tempo impiedoso</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nesta escala, formalizamos nossas inten√ß√µes usando um sistema comum, em vez de linhas de c√≥digo. Isso √© muito mais pr√≥ximo do n√≠vel humano, onde projetos e requisitos podem ser muito mais amb√≠guos do que no n√≠vel do c√≥digo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, vamos seguir um procedimento com uma especifica√ß√£o aproximada ‚Äúse for chamado, ele faz uma chamada do sistema para salvar dados no reposit√≥rio e processa erros do sistema‚Äù. </font><font style="vertical-align: inherit;">As propriedades s√£o dif√≠ceis de verificar, mas √© bastante claro como fazer isso. </font><font style="vertical-align: inherit;">Os dados est√£o serializados corretamente? </font><font style="vertical-align: inherit;">Nossas garantias s√£o violadas devido a informa√ß√µes incorretas? </font><font style="vertical-align: inherit;">Estamos lidando com todas as formas poss√≠veis de uma falha de chamada do sistema? </font><font style="vertical-align: inherit;">Agora compare o sistema de registro de alto n√≠vel com a especifica√ß√£o "todas as mensagens s√£o registradas" e responda √†s seguintes perguntas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as mensagens s√£o gravadas ou todas as mensagens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que entram no sistema</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">As mensagens s√£o gravadas uma vez ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantidas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma vez?</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as mensagens s√£o enviadas? </font><font style="vertical-align: inherit;">Essa √© a vez? </font><font style="vertical-align: inherit;">O canal os entrega apenas uma vez? </font><font style="vertical-align: inherit;">Est√° tudo bem com a entrega?</font></font><br></li><li>          ?      ,    ?    ¬´¬ª     ,     ? <br></li><li>  ,       ?   ? <br></li><li>     ?    ¬´  ¬ª      ? <br></li><li>   GDPR? <br></li><li>      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem um design formal, √© mais dif√≠cil expressar os requisitos realmente necess√°rios para o sistema. Se voc√™ n√£o pode express√°-los, n√£o tem id√©ia se o design realmente atende aos requisitos ou se parece com eles, mas pode levar a consequ√™ncias imprevis√≠veis. Ao expressar formalmente inten√ß√µes e design, podemos facilmente verificar se estamos realmente desenvolvendo o que precisamos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como usamos linguagens de programa√ß√£o para representar c√≥digo, usamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linguagens de especifica√ß√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para representar projetos. Os idiomas de especifica√ß√£o geralmente s√£o orientados para especifica√ß√µes de design, e n√£o para especifica√ß√µes de c√≥digo, embora alguns idiomas possam ser usados ‚Äã‚Äãnos dois casos (observa√ß√£o: o processo de correspond√™ncia das especifica√ß√µes de design com as especifica√ß√µes de c√≥digo √© chamado de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refinamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No futuro, chamarei linguagens de especifica√ß√£o (DL) para minimizar as confus√µes (novamente, essa n√£o √© uma terminologia comum; a maioria das pessoas usa a "linguagem de especifica√ß√£o", mas quero distinguir claramente entre as especifica√ß√µes de c√≥digo e as especifica√ß√µes de design). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente, o primeiro DL completo foi o VDM por volta de 1972. </font><font style="vertical-align: inherit;">Desde ent√£o, vimos uma enorme variedade de diferentes linguagens de especifica√ß√£o. </font><font style="vertical-align: inherit;">O espa√ßo DL √© muito mais diversificado e fragmentado do que com as linguagens de verifica√ß√£o de c√≥digo (CVL). </font><font style="vertical-align: inherit;">Grosso modo, as pessoas inventaram o DL como um meio para atingir um fim, e o CVL como um objetivo em si. </font><font style="vertical-align: inherit;">Como eles s√£o fortemente influenciados por √°reas problem√°ticas espec√≠ficas, o DL implementa todos os tipos de id√©ias e sem√¢nticas. </font><font style="vertical-align: inherit;">Aqui est√° uma vis√£o geral muito, muito breve de alguns dos primeiros DLs:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linguagem </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Årea de modelagem </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meios </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Z </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requisitos de neg√≥cios </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √°lgebra relacional </font></font></td></tr><tr><td> Promela </td><td>  </td><td> CSP </td></tr><tr><td> SDL </td><td>  </td><td> - </td></tr><tr><td>    </td><td>  </td><td>  </td></tr><tr><td>    </td><td>  </td><td>  </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as DLs geralmente s√£o criadas para resolver problemas espec√≠ficos, a maioria delas possui pelo menos dois ou tr√™s aplicativos reais. Como regra, os resultados s√£o muito positivos. Os profissionais dizem que o DL fornece uma compreens√£o dos problemas e facilita a localiza√ß√£o de solu√ß√µes. Por um longo tempo, o principal campe√£o foi Praxis (agora Altran), que aplicou o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúreparo por projeto‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - uma combina√ß√£o de constru√ß√µes em Z e c√≥digo SPARK - para criar sistemas cr√≠ticos de seguran√ßa. As especifica√ß√µes economizam tempo e dinheiro porque voc√™ n√£o encontrar√° erros de design na fase final do projeto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pamela Zave experimentou o Alloy e descobriu um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug fundamental</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no Chord, uma das principais tabelas de hash distribu√≠das. AWS come√ßa a encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erros cr√≠ticos de 35 etapas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrevendo especifica√ß√µes TLA +. Na minha experi√™ncia, quando as pessoas tentam escrever especifica√ß√µes, elas logo se tornam grandes f√£s desse neg√≥cio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas os f√£s de m√©todos formais e pessoas de fora avaliam de maneira completamente diferente o valor das especifica√ß√µes de reda√ß√£o. Para os f√£s, a maior vantagem √© que o pr√≥prio processo de design faz voc√™ entender o que est√° escrevendo. Quando voc√™ precisa expressar formalmente o que seu sistema est√° fazendo, muitos erros impl√≠citos se tornam repentinamente √≥bvios. Pessoas de fora n√£o conseguem entender isso. Se voc√™ quiser experimentar algu√©m com um DL, uma pessoa deve ter uma maneira de verificar se o design realmente possui as propriedades que deseja.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Felizmente, isso tamb√©m √© extremamente importante para muitos especificadores; portanto, a verifica√ß√£o do projeto √© uma grande √°rea de pesquisa. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica√ß√£o do modelo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no c√≥digo, podemos verificar o design escrevendo teoremas. Felizmente, temos mais um truque: voc√™ pode usar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o programa de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verifica√ß√£o de modelos. Em vez de compilar evid√™ncias de que o design est√° correto, simplesmente for√ßamos o espa√ßo dos poss√≠veis estados e vemos se o estado errado existe nele. Se n√£o encontrarmos nada, tudo est√° bem (nota: os programas de verifica√ß√£o de modelo tamb√©m s√£o usados ‚Äã‚Äãpara verificar o c√≥digo, como o JMBC, mas a verifica√ß√£o de modelo √© muito mais usada na verifica√ß√£o de design do que na verifica√ß√£o de c√≥digo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A valida√ß√£o do modelo tem muitas vantagens. Em primeiro lugar, n√£o h√° necessidade de escrever evid√™ncias, o que economiza muito tempo e esfor√ßo. Em segundo lugar, n√£o h√° necessidade </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de aprender</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escreva evid√™ncias, para que a barreira de entrada seja muito menor. Terceiro, se o design for quebrado, a verifica√ß√£o do modelo dar√° um contra-exemplo expl√≠cito. Isso </font><font style="vertical-align: inherit;">torna </font><font style="vertical-align: inherit;">muito, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais f√°cil corrigir o erro, especialmente se forem necess√°rias 35 etapas para reproduzi-lo. Tente encontrar voc√™ mesmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem algumas desvantagens. Primeiro de tudo, essas ferramentas n√£o s√£o t√£o poderosas. Em particular, voc√™ pode encontrar um n√∫mero </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ilimitado de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ilimitado) por um modelo que possui um n√∫mero infinito de estados diferentes. Por exemplo, voc√™ define um manipulador de fila de mensagens: ele normalmente funciona com uma lista de dez mensagens. Mas se voc√™ precisa acreditar em qualquer lista ... bem, h√° um n√∫mero infinito deles, ent√£o o modelo tem um n√∫mero infinito de estados. A maioria das ferramentas de valida√ß√£o de modelo possui truques diferentes para essas situa√ß√µes, como a defini√ß√£o de classes de equival√™ncia ou simetria, mas cada caso √© diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra grande desvantagem - a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explos√£o no espa√ßo de estados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (explos√£o em espa√ßo de estado). Imagine que voc√™ tem tr√™s processos, cada um dos quais consiste em quatro etapas consecutivas, e eles podem alternar as etapas de qualquer maneira. Se eles n√£o afetam o comportamento um do outro, acontece que</font></font><code>(4*3)! / (4!)^3 = 34 650</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poss√≠veis execu√ß√µes (comportamentos). Se cada processo tiver um dos cinco estados iniciais, o n√∫mero total de comportamentos aumentar√° para 4.300.000.E a verifica√ß√£o dos modelos deve garantir que todos se comportem bem. E isso √© fornecido, pois eles n√£o interagem entre si! Se eles come√ßarem a fazer isso, o espa√ßo de estados crescer√° ainda mais r√°pido. Uma explos√£o combinat√≥ria √© considerada o principal problema para testar modelos, e ainda resta muito trabalho para resolver esse problema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, ao mesmo tempo, h√° outra maneira de lidar com a explos√£o do espa√ßo estadual: jogar mais equipamentos nele. O maior problema para verificar o modelo √© "apenas" o problema de desempenho, e resolvemos os problemas de desempenho muito bem. A maioria das verifica√ß√µes de modelo (mas n√£o todas) √© facilmente paralelizada. Ap√≥s otimizar o modelo e test√°-lo com pequenos par√¢metros, voc√™ pode implantar o cluster da AWS e execut√°-lo com grandes par√¢metros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√°tica, muitos qualificadores usam valida√ß√£o de modelo e, quando necess√°rio, mudam para programas para provar teoremas (nota: lembre-se de que ‚Äúmuitos qualificadores‚Äù s√£o cerca de dez). </font><font style="vertical-align: inherit;">Ainda mais compiladores de especifica√ß√µes come√ßam a testar modelos e, quando atingem o limite de seus recursos, eles alternam para formas menos intensivas de verifica√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problema de especifica√ß√£o de projeto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, a verifica√ß√£o do projeto √© mais simples e r√°pida que a verifica√ß√£o do c√≥digo e demonstrou muitos sucessos impressionantes. Ent√£o, por que as pessoas n√£o usam? O problema com DV √© muito mais insidioso. A verifica√ß√£o de c√≥digo √© um problema t√©cnico e a verifica√ß√£o de design √© um problema social: as pessoas simplesmente n√£o entendem o ponto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso se deve em grande parte ao fato de o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">design n√£o ser um c√≥digo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Na maioria das DLs, n√£o existe uma maneira autom√°tica de criar c√≥digo, nem existe uma maneira de pegar o c√≥digo existente e compar√°-lo com o design (observa√ß√£o: a gera√ß√£o de c√≥digo a partir das especifica√ß√µes √© chamada de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√≠ntese</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; para orienta√ß√£o, veja o trabalho de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nadya Polikarpova</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; prova de que o c√≥digo atende √† especifica√ß√£o (ou especifica√ß√£o corresponde a outra especifica√ß√£o) √© chamado</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esclarecimento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a pesquisa ativa est√° sendo realizada nas duas dire√ß√µes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os programadores tendem a desconfiar de artefatos de software que n√£o s√£o c√≥digo ou n√£o s√£o for√ßados a sincronizar com o c√≥digo. Pelo mesmo motivo, documenta√ß√£o, coment√°rios, gr√°ficos, wikis e confirma√ß√µes s√£o frequentemente ignoradas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que os programadores simplesmente n√£o acreditam que as especifica√ß√µes sejam √∫teis. Na minha experi√™ncia, eles sugerem que as ferramentas atuais (pseudo-c√≥digo, diagramas, TDD) s√£o mais que suficientes para o design adequado. N√£o sei o qu√£o difundida √© essa opini√£o e n√£o posso explic√°-la com outra coisa sen√£o conservadorismo geral.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas exatamente toda comunidade de metodologia tem reclama√ß√µes que eu conhe√ßo: os apoiadores do TDD reclamam que os programadores n√£o querem experimentar o TDD, os f√£s de Haskell reclamam que os programadores n√£o pensam em tipagem est√°tica e assim por diante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvi o argumento de que o Agile n√£o aceita um design pr√©-projetado; portanto, ningu√©m deseja fazer uma especifica√ß√£o formal. Talvez. Mas muitas das pessoas que conheci rejeitam o Agile e o FM. Outro argumento √© que os m√©todos historicamente formais eram constantemente reavaliados e n√£o cumpriam o prometido. Isso tamb√©m √© poss√≠vel, mas a maioria das pessoas nem sequer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ouviu falar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre m√©todos formais, e mais ainda sobre sua hist√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â simplesmente muito dif√≠cil fazer as pessoas se preocuparem com o que ainda n√£o est√£o fazendo, mesmo que reconhe√ßam os benef√≠cios.</font></font><br><br><h1>  Sum√°rio </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificar o c√≥digo √© uma tarefa dif√≠cil. </font><font style="vertical-align: inherit;">Mais e mais pessoas est√£o se envolvendo, embora os programas de prova de teoremas e os solucionadores de SMT estejam se tornando mais complexos. </font><font style="vertical-align: inherit;">Mas ainda assim, no futuro pr√≥ximo, provavelmente, isso continuar√° sendo um monte de especialistas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verifica√ß√£o do projeto √© muito mais simples, mas seu uso requer a supera√ß√£o da barreira cultural. </font><font style="vertical-align: inherit;">Eu acho que a situa√ß√£o pode ser mudada. </font><font style="vertical-align: inherit;">Vinte anos atr√°s, testes automatizados e revis√µes de c√≥digo eram t√≥picos bastante ex√≥ticos e de nicho, mas acabaram se tornando populares. </font><font style="vertical-align: inherit;">Novamente, a programa√ß√£o de contratos era um nicho e continua sendo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este artigo explique um pouco melhor por que os m√©todos formais s√£o t√£o raramente usados. </font><font style="vertical-align: inherit;">Pelo menos essa √© uma explica√ß√£o melhor do que o argumento usual "a web n√£o √© um avi√£o". </font><font style="vertical-align: inherit;">Sinta-se √† vontade para gritar se vir algum erro √≥bvio.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437296/">https://habr.com/ru/post/pt437296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437280/index.html">Log√≠stica f√°cil de fazer voc√™ mesmo</a></li>
<li><a href="../pt437282/index.html">Uma introdu√ß√£o ao Kubernetes para usu√°rios do VMware. Parte 2. Pr√°tica</a></li>
<li><a href="../pt437284/index.html">Profiss√µes de zool√≥gico relacionadas √† ind√∫stria do √°udio</a></li>
<li><a href="../pt437286/index.html">Eu tento o .NET Core + Kubernetes + appmetrics + prometheus + grafana + jobs + health checks</a></li>
<li><a href="../pt437292/index.html">Por que o modelo tradicional de loja de varejo j√° est√° morto</a></li>
<li><a href="../pt437298/index.html">Sobre um cara</a></li>
<li><a href="../pt437300/index.html">10 habilidades e conhecimentos necess√°rios para um desenvolvedor iOS iniciante</a></li>
<li><a href="../pt437304/index.html">Como comprar batatas se voc√™ √© dalt√¥nico</a></li>
<li><a href="../pt437306/index.html">Habilidades n√£o √≥bvias exigidas pelo gerente de produto</a></li>
<li><a href="../pt437308/index.html">Ciclo de aula do SDL 2.0: li√ß√£o 4 - manipula√ß√£o de eventos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>