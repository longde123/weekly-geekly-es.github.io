<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✡️ 🤛🏾 ☪️ Pinterest Sharding: Wie wir unseren MySQL Park skaliert haben 📊 🔻 🤘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gruß, Chabrowiten! Herzlichen Glückwunsch an alle am Tag des Programmierers und teilen Sie die Übersetzung des Artikels, der speziell für Studenten de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pinterest Sharding: Wie wir unseren MySQL Park skaliert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467389/">  <i>Gruß, Chabrowiten!</i>  <i>Herzlichen Glückwunsch an alle am Tag des Programmierers und teilen Sie die Übersetzung des Artikels, der speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"High Load Architect"</a> vorbereitet wurde.</i> <br><br><img src="https://habrastorage.org/webt/3o/s-/k6/3os-k6l2f122mbs6d1lufcif6ke.png"><br><br>  <b><i>"Scherben.</i></b>  <b><i>Oder nicht scherben.</i></b>  <b><i>Ohne es zu versuchen. "</i></b> <b><i><br></i></b>  <b><i>- Yoda</i></b> <br><br>  Heute werden wir uns mit der Trennung von Daten zwischen mehreren MySQL-Servern befassen.  Wir haben das Sharding Anfang 2012 beendet und dieses System wird immer noch zum Speichern unserer Basisdaten verwendet. <a name="habracut"></a><br><br>  Bevor wir uns mit dem Teilen von Daten befassen, sollten wir sie besser kennenlernen.  Stellen Sie ein schönes Licht auf, holen Sie sich Erdbeeren in Schokolade, erinnern Sie sich an Zitate aus Star Trek ... <br><br>  Pinterest ist eine Suchmaschine für alles, was Sie interessiert.  In Bezug auf Daten ist Pinterest die weltweit größte Grafik menschlicher Interessen.  Es enthält über 50 Milliarden Pins, die von Benutzern auf mehr als einer Milliarde Boards gespeichert wurden.  Die Leute behalten einige Pins für sich und abonnieren wie andere Pins andere Pins, Boards und Interessen, sehen sich den Home-Feed aller Pins, Boards und Interessen an, die sie abonniert haben.  Großartig!  Jetzt machen wir es skalierbar! <br><br><h3>  Schmerzhaftes Wachstum </h3><br>  Im Jahr 2011 haben wir begonnen, an Dynamik zu gewinnen.  Nach einigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schätzungen</a> sind wir schneller gewachsen als jedes damals bekannte Startup.  Um den September 2011 herum war jede Komponente unserer Infrastruktur überlastet.  Wir hatten mehrere NoSQL-Technologien zur Verfügung, die alle katastrophal versagten.  Wir hatten auch viele MySQL-Slaves, die wir gelesen haben, was viele außergewöhnliche Fehler verursachte, insbesondere beim Caching.  Wir haben unser gesamtes Speichermodell umgebaut.  Um effizient zu arbeiten, haben wir uns sorgfältig mit der Entwicklung der Anforderungen befasst. <br><br><h3>  Anforderungen </h3><br><ul><li>  Das gesamte System sollte sehr stabil, einfach zu bedienen und von der Größe eines kleinen Kastens bis zur Größe des Mondes skalierbar sein, wenn der Standort wächst. </li><li>  Alle vom Pinner generierten Inhalte sollten jederzeit auf der Website verfügbar sein. </li><li>  Das System sollte die Anforderung von N Pins auf der Karte in einer deterministischen Reihenfolge unterstützen (z. B. in umgekehrter Reihenfolge der Erstellungszeit oder in der vom Benutzer angegebenen Reihenfolge).  Das gleiche gilt für Pinner, deren Pins usw. </li><li> Der Einfachheit halber sollten Sie auf jede mögliche Weise nach Updates streben.  Um die erforderliche Konsistenz zu erzielen, werden zusätzliche Spielzeuge benötigt, z. B. ein verteiltes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionsjournal</a> .  Es macht Spaß und ist (nicht zu) einfach! </li></ul><br><h3>  Architekturphilosophie und Notizen </h3><br>  Da diese Daten mehrere Datenbanken umfassen sollen, können wir nicht nur einen Join, Fremdschlüssel und Indizes verwenden, um alle Daten zu erfassen, obwohl sie für Unterabfragen verwendet werden können, die sich nicht über die Datenbank erstrecken. <br><br>  Wir mussten auch den Lastausgleich für die Daten aufrechterhalten.  Wir haben beschlossen, dass das Verschieben von Daten Element für Element das System unnötig komplex macht und viele Fehler verursacht.  Wenn wir Daten verschieben mussten, war es besser, den gesamten virtuellen Knoten auf einen anderen physischen Knoten zu verschieben. <br><br>  Damit unsere Implementierung schnell in Umlauf gebracht werden konnte, benötigten wir die einfachste und bequemste Lösung und sehr stabile Knoten in unserer verteilten Datenplattform. <br>  Alle Daten mussten auf den Slave-Computer repliziert werden, um ein Backup mit hoher Verfügbarkeit zu erstellen und für MapReduce auf S3 zu sichern.  Wir interagieren mit dem Meister nur in der Produktion.  In der Produktion möchten Sie nicht in Slave schreiben oder lesen.  Slave Lag, und es verursacht seltsame Fehler.  Wenn das Sharding durchgeführt wird, macht es keinen Sinn, mit einem Slave in der Produktion zu interagieren. <br><br>  Schließlich brauchen wir eine gute Möglichkeit, universelle eindeutige Kennungen (UUIDs) für alle unsere Objekte zu generieren. <br><br><h3>  Wie wir Scherben gemacht haben </h3><br>  Was wir schaffen wollten, musste die Anforderungen erfüllen, stabil arbeiten, im Allgemeinen funktionsfähig und wartbar sein.  Aus diesem Grund haben wir die bereits recht ausgereifte MySQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologie</a> als zugrunde liegende Technologie ausgewählt.  Wir sind absichtlich vorsichtig mit neuen Technologien für die automatische Skalierung von MongoDB, Cassandra und Membase, weil sie weit genug von der Reife entfernt waren (und in unserem Fall auf beeindruckende Weise kaputt gingen!). <br><blockquote>  Außerdem: Ich empfehle immer noch Startups, um neue bizarre Dinge zu vermeiden - versuchen Sie einfach, MySQL zu verwenden.  Vertrau mir.  Ich kann es mit Narben beweisen. </blockquote>  MySQL - die Technologie ist bewährt, stabil und einfach - es funktioniert.  Wir verwenden es nicht nur, es ist auch bei anderen Unternehmen beliebt, deren Waage noch beeindruckender ist.  MySQL erfüllt unsere Anforderungen an die Optimierung von Datenabfragen, die Auswahl bestimmter Datenbereiche und Transaktionen auf Zeilenebene.  Tatsächlich gibt es in seinem Arsenal viel mehr Möglichkeiten, aber wir alle brauchen sie nicht.  Da MySQL jedoch eine "Boxed" -Lösung ist, mussten Daten gesplittet werden.  Hier ist unsere Lösung: <br>  Wir haben mit acht EC2-Servern begonnen, jeweils eine Instanz von MySQL: <br><br><img src="https://habrastorage.org/webt/e0/d0/o0/e0d0o0fijurp6mabuvbwecacnfi.png"><br><br>  Jeder MySQL-Master-Master-Server wird im Falle eines primären Fehlers auf den Sicherungshost repliziert.  Unsere Produktionsserver lesen oder schreiben nur an den Master.  Ich empfehle Ihnen, dies auch zu tun.  Dies vereinfacht und vermeidet Fehler mit Replikationsverzögerungen erheblich. <br><br>  Jede MySQL-Entität verfügt über viele Datenbanken: <br><br><img src="https://habrastorage.org/webt/zf/vl/sx/zfvlsxbhhh6uict7kf9ly6f2y9m.png"><br><br>  Beachten Sie, dass jede Datenbank eindeutig benannt ist: db00000, db00001 bis dbNNNNN.  Jede Datenbank ist ein Splitter unserer Daten.  Wir haben eine architektonische Entscheidung getroffen, auf deren Grundlage nur ein Teil der Daten in den Shard fällt und der nie über diesen Shard hinausgeht.  Sie können jedoch mehr Kapazität erhalten, indem Sie Shards auf andere Computer verschieben (darüber werden wir später sprechen). <br><br>  Wir arbeiten mit einer Konfigurationstabelle, die angibt, welche Maschinen Shards haben: <br><br><pre><code class="bash hljs">[{“range”: (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”}, {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”}, ... {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]</code> </pre> <br>  Diese Konfiguration ändert sich nur, wenn Shards verschoben oder der Host ersetzt werden muss.  Wenn der <code>master</code> stirbt, können wir den vorhandenen <code>slave</code> und dann einen neuen aufnehmen.  Die Konfiguration befindet sich in <a href="">ZooKeeper</a> und wird bei Aktualisierung an Dienste gesendet, die MySQL-Shard bereitstellen. <br><br>  Jeder Shard hat den gleichen Satz von Tabellen: <code>pins</code> , <code>boards</code> , <code>users_has_pins</code> , <code>users_likes_pins</code> , <code>pin_liked_by_user</code> usw.  Ich werde etwas später darüber sprechen. <br><br>  Wie verteilen wir Daten für diese Shards? <br><br>  Wir erstellen eine 64-Bit-ID, die die ID des Shards, den darin enthaltenen Datentyp und die Stelle enthält, an der sich diese Daten in der Tabelle befinden (lokale ID).  Die Shard-ID besteht aus 16 Bit, die Typ-ID beträgt 10 Bit und die lokale ID beträgt 36 Bit.  Fortgeschrittene Mathematiker werden feststellen, dass es nur 62 Bit gibt.  Meine Erfahrung als Compiler und Leiterplattenentwickler hat mich gelehrt, dass Backup-Bits Gold wert sind.  Wir haben also zwei solche Bits (auf Null gesetzt). <br><br><pre> <code class="bash hljs">ID = (shard ID &lt;&lt; 46) | (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ID &lt;&lt; 36) | (<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> ID&lt;&lt;0)</code> </pre> <br>  Nehmen wir diesen Pin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.pinterest.com/pin/241294492511762325/</a> , analysieren wir seine ID 241294492511762325: <br><br><pre> <code class="bash hljs">Shard ID = (241294492511762325 &gt;&gt; 46) &amp; 0xFFFF = 3429 Type ID = (241294492511762325 &gt;&gt; 36) &amp; 0x3FF = 1 Local ID = (241294492511762325 &gt;&gt; 0) &amp; 0xFFFFFFFFF = 7075733</code> </pre> <br>  Somit lebt das Stiftobjekt in 3429 Shard.  Sein Typ ist "1" (dh "Pin") und er steht in Zeile 7075733 in der Pin-Tabelle.  Stellen wir uns zum Beispiel vor, dieser Shard befindet sich in MySQL012A.  Wir können es wie folgt erreichen: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”MySQL012A”) conn.execute(“SELECT data FROM db03429.pins <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> local_id=7075733”)</code> </pre> <br><br>  Es gibt zwei Arten von Daten: Objekte und Zuordnungen.  Objekte enthalten Teile wie Pin-Daten. <br><br><h4>  Objekttabellen </h4><br>  Objekttabellen wie Pins, Benutzer, Boards und Kommentare haben eine ID (lokale ID mit einem automatisch ansteigenden Primärschlüssel) und einen Blob, der JSON mit allen Objektdaten enthält. <br><br><pre> <code class="bash hljs">CREATE TABLE pins ( local_id INT PRIMARY KEY AUTO_INCREMENT, data TEXT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ENGINE=InnoDB;</code> </pre> <br>  Pin-Objekte sehen beispielsweise folgendermaßen aus: <br><br><pre> <code class="bash hljs">{“details”: “New Star Wars character”, “link”: “http://webpage.com/asdf”, “user_id”: 241294629943640797, “board_id”: 241294561224164665, …}</code> </pre> <br>  Um einen neuen Pin zu erstellen, sammeln wir alle Daten und erstellen einen JSON-Blob.  Dann wählen wir die Shard-ID aus (wir bevorzugen es, dieselbe Shard-ID wie die Karte zu wählen, auf der sie platziert ist, dies ist jedoch nicht erforderlich).  Für Pin-Typ 1. Wir stellen eine Verbindung zu dieser Datenbank her und fügen JSON in die Pin-Tabelle ein.  MySQL gibt eine automatisch erhöhte lokale ID zurück.  Jetzt haben wir einen Shard, einen Typ und eine neue lokale ID, damit wir eine vollständige 64-Bit-ID kompilieren können! <br><br>  Um den Pin zu bearbeiten, lesen, ändern und schreiben wir JSON mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MySQL-Transaktion</a> : <br><br><pre> <code class="bash hljs">&gt; BEGIN &gt; SELECT blob FROM db03429.pins WHERE local_id=7075733 FOR UPDATE [Modify the json blob] &gt; UPDATE db03429.pins SET blob=<span class="hljs-string"><span class="hljs-string">'&lt;modified blob&gt;'</span></span> WHERE local_id=7075733 &gt; COMMIT</code> </pre> <br>  Um einen Pin zu entfernen, können Sie seine Zeile in MySQL löschen.  Es ist jedoch besser, das Feld <i>"aktiv"</i> in JSON hinzuzufügen und auf <i>"falsch"</i> zu setzen sowie die Ergebnisse auf der Clientseite zu filtern. <br><br><h4>  Zuordnungstabellen </h4><br>  Die Zuordnungstabelle verknüpft ein Objekt mit einem anderen, z. B. einer Karte mit Stiften.  Die MySQL-Tabelle für Zuordnungen enthält drei Spalten: 64-Bit für die ID "from", 64-Bit für die ID "where" und die Sequenz-ID.  In diesem Tripel (von wo, wo, Sequenz) gibt es Indexschlüssel, und sie befinden sich auf dem Shard des Bezeichners "von". <br><br><pre> <code class="bash hljs">CREATE TABLE board_has_pins ( board_id INT, pin_id INT, sequence INT, INDEX(board_id, pin_id, sequence) ) ENGINE=InnoDB;</code> </pre> <br>  Zuordnungstabellen sind beispielsweise unidirektional, wie die Tabelle <code>board_has_pins</code> .  Wenn Sie die entgegengesetzte Richtung benötigen, benötigen Sie eine separate <code>pin_owned_by_board</code> Tabelle.  Die Sequenz-ID definiert die Sequenz (unsere IDs können nicht zwischen Shards verglichen werden, da die neuen lokalen IDs unterschiedlich sind).  Normalerweise fügen wir neue Pins auf einer neuen Karte mit einer Sequenz-ID ein, die der Zeit in Unix (Unix-Zeitstempel) entspricht.  Eine beliebige Anzahl kann in der Sequenz enthalten sein, aber die Unix-Zeit ist eine gute Möglichkeit, neue Materialien nacheinander zu speichern, da dieser Indikator monoton ansteigt.  Sie können sich die Daten in der Zuordnungstabelle ansehen: <br><br><pre> <code class="bash hljs">SELECT pin_id FROM board_has_pins WHERE board_id=241294561224164665 ORDER BY sequence LIMIT 50 OFFSET 150</code> </pre> <br>  Dadurch erhalten Sie mehr als 50 pin_id, mit denen Sie dann nach Pin-Objekten suchen können. <br>  Was wir gerade gemacht haben, ist ein Join auf Anwendungsebene (board_id -&gt; pin_id -&gt; pin-Objekte).  Eine der erstaunlichen Eigenschaften von Verbindungen auf Anwendungsebene besteht darin, dass Sie das Bild getrennt vom Objekt zwischenspeichern können.  Wir speichern pin_id im Cache des Pin-Objekts im Memcache-Cluster, speichern jedoch board_id in pin_id im Redis-Cluster.  Auf diese Weise können wir die richtige Technologie auswählen, die am besten zum zwischengespeicherten Objekt passt. <br><br><h3>  Kapazität erhöhen </h3><br>  Es gibt drei Möglichkeiten, um die Kapazität in unserem System zu erhöhen.  Der einfachste Weg, die Maschine zu aktualisieren (um den Speicherplatz zu vergrößern, schnellere Festplatten zu installieren, mehr RAM). <br>  Der nächste Weg, um die Kapazität zu erhöhen, besteht darin, neue Bereiche zu erschließen.  Zunächst haben wir insgesamt 4096 Shards erstellt, obwohl die Shard-ID aus 16 Bit bestand (insgesamt 64.000 Shards).  Neue Objekte können nur in diesen ersten 4k-Shards erstellt werden.  Irgendwann beschlossen wir, neue MySQL-Server mit Shards von 4096 bis 8191 zu erstellen und diese zu füllen. <br><br>  Der letzte Weg, die Kapazität zu erhöhen, besteht darin, einige Scherben auf neue Maschinen zu verlagern.  Wenn wir die Kapazität von MySQL001A (mit Shards von 0 auf 511) erhöhen möchten, erstellen wir ein neues Master-Master-Paar mit den folgenden möglichen Namen (z. B. MySQL009A und B) und starten die Replikation von MySQL001A. <br><br><img src="https://habrastorage.org/webt/d2/uf/gd/d2ufgd1tttsa6tmxvpywfzgqugs.png"><br><br>  Sobald die Replikation abgeschlossen ist, ändern wir unsere Konfiguration so, dass in MySQL001A nur Shards von 0 bis 255 und in MySQL009A von 256 bis 511 vorhanden sind. Jetzt sollte jeder Server nur die Hälfte der zuvor verarbeiteten Shards verarbeiten. <br><br><img src="https://habrastorage.org/webt/4f/cp/do/4fcpdo2g16molbdkkfbf8xvujbi.png"><br><br><h3>  Einige coole Features </h3><br>  Diejenigen, die bereits Systeme zur Generierung neuer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UUIDs hatten,</a> werden verstehen, dass wir sie in diesem System kostenlos erhalten!  Wenn Sie ein neues Objekt erstellen und in die Objekttabelle einfügen, wird eine neue lokale Kennung zurückgegeben.  Diese lokale ID gibt Ihnen in Kombination mit der Shard-ID und der Typ-ID eine UUID. <br><br>  Diejenigen unter Ihnen, die ALTERs ausgeführt haben, um MySQL-Tabellen weitere Spalten hinzuzufügen, wissen, dass sie extrem langsam arbeiten und zu einem großen Problem werden können.  Unser Ansatz erfordert keine Änderungen der MySQL-Ebene.  Auf Pinterest haben wir in den letzten drei Jahren wahrscheinlich nur einen ALTER gemacht.  Um Objekten neue Felder hinzuzufügen, teilen Sie Ihren Diensten einfach mit, dass das JSON-Schema mehrere neue Felder enthält.  Sie können den Standardwert so ändern, dass Sie beim Deserialisieren von JSON von einem Objekt ohne neues Feld den Standardwert erhalten.  Wenn Sie eine Zuordnungstabelle benötigen, erstellen Sie eine neue Zuordnungstabelle und füllen Sie sie, wann immer Sie möchten.  Und wenn Sie fertig sind, können Sie senden! <br><br><h3>  Mod Shard </h3><br>  Es ist fast wie bei einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mod-Team</a> , nur völlig anders. <br><br>  Einige Objekte müssen ohne ID gefunden werden.  Wenn sich ein Benutzer beispielsweise mit einem Facebook-Konto anmeldet, muss die Zuordnung von der Facebook-ID zur Pinterest-ID erfolgen.  Für uns sind Facebook-IDs nur Bits, daher speichern wir sie in einem separaten Shard-System namens Mod Shard. <br><br>  Andere Beispiele sind IP-Adressen, Benutzername und E-Mail-Adresse. <br>  Mod Shard ist dem im vorherigen Abschnitt beschriebenen Sharding-System sehr ähnlich. Der einzige Unterschied besteht darin, dass Sie mit beliebigen Eingabedaten nach Daten suchen können.  Diese Eingabe wird gehasht und entsprechend der Gesamtzahl der Shards im System geändert.  Als Ergebnis wird ein Shard erhalten, auf dem sich die Daten befinden oder bereits befinden.  Zum Beispiel: <br><br><pre> <code class="bash hljs">shard = md5(“1.2.3.4<span class="hljs-string"><span class="hljs-string">") % 4096</span></span></code> </pre> <br>  In diesem Fall ist der Shard gleich 1524. Wir verarbeiten die Konfigurationsdatei entsprechend der Shard-ID: <br><br><pre> <code class="bash hljs">[{“range”: (0, 511), “master”: “msdb001a”, “slave”: “msdb001b”}, {“range”: (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”}, {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”}, …]</code> </pre> <br>  Um Daten auf der IP-Adresse 1.2.3.4 zu finden, müssen wir daher Folgendes tun: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”msdb003a”) conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip=<span class="hljs-string"><span class="hljs-string">'1.2.3.4'</span></span>”)</code> </pre> <br>  Sie verlieren einige gute Eigenschaften der Shard-ID, z. B. die räumliche Lokalität.  Sie müssen mit allen am Anfang erstellten Shards beginnen und den Schlüssel selbst erstellen (er wird nicht automatisch generiert).  Es ist immer besser, Objekte auf Ihrem System mit unveränderlichen IDs darzustellen.  So müssen Sie nicht viele Links aktualisieren, wenn der Benutzer beispielsweise seinen "Benutzernamen" ändert. <br><br><h3>  Letzte Gedanken </h3><br>  Dieses System läuft seit 3,5 Jahren auf Pinterest und wird wahrscheinlich für immer dort bleiben.  Die Implementierung war relativ einfach, aber die Inbetriebnahme und das Verschieben aller Daten von alten Maschinen war schwierig.  Wenn Sie beim Erstellen eines neuen Shards auf ein Problem stoßen, sollten Sie einen Cluster von Hintergrunddatenverarbeitungsmaschinen erstellen (Hinweis: Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pyren</a> ), um Ihre Daten mit Skripten aus alten Datenbanken in Ihren neuen Shard zu verschieben.  Ich garantiere, dass einige der Daten verloren gehen, egal wie sehr Sie es versuchen (es sind alles Gremlins, ich schwöre), also wiederholen Sie die Datenübertragung immer wieder, bis die Menge an neuen Informationen im Shard sehr gering oder gar nicht mehr wird. <br><br>  Es wurden alle Anstrengungen unternommen, um dieses System zu erreichen.  Aber es bietet in keiner Weise Atomizität, Isolation oder Kohärenz.  Wow!  Das hört sich schlecht an!  Aber mach dir keine Sorgen.  Sicherlich werden Sie sich ohne sie ausgezeichnet fühlen.  Sie können diese Ebenen bei Bedarf jederzeit mit anderen Prozessen / Systemen erstellen, aber standardmäßig und kostenlos erhalten Sie bereits eine Menge: Arbeitskapazität.  Zuverlässigkeit durch Einfachheit erreicht und arbeitet sogar schnell! <br><br>  Aber was ist mit Fehlertoleranz?  Wir haben einen Dienst für die Wartung von MySQL-Shards erstellt und die Shard-Konfigurationstabelle in ZooKeeper gespeichert.  Wenn der Master-Server abstürzt, heben wir den Slave-Computer an und dann den Computer, der ihn ersetzen wird (immer auf dem neuesten Stand).  Wir verwenden bis heute keine automatische Fehlerbearbeitung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467389/">https://habr.com/ru/post/de467389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467377/index.html">Drei in Folge: Top 10 Berichte von Mobius 2019 Piter</a></li>
<li><a href="../de467381/index.html">Mehrstöckige LEDs, intelligente Lichter und Glühbirnen für 18 Rubel</a></li>
<li><a href="../de467383/index.html">"Der Manager muss weiter codieren": Interview mit Stephen Chin</a></li>
<li><a href="../de467385/index.html">Eine Auswahl psychologischer und atypischer technischer Fragen aus Java-Entwicklerinterviews</a></li>
<li><a href="../de467387/index.html">Lösungen für die Arbeit mit Feedback und Kundenerfahrung: von kleinen Diensten bis zu schweren Plattformen</a></li>
<li><a href="../de467391/index.html">Yandex stellt RPKI vor</a></li>
<li><a href="../de467393/index.html">Das NX Bootcamp startet im Oktober</a></li>
<li><a href="../de467395/index.html">Habr Weekly # 18 / New Apple Gadgets, ein vollmodulares Smartphone, das Dorf der Programmierer in Weißrussland, das XY-Phänomen</a></li>
<li><a href="../de467399/index.html">Sie können nicht verbieten, Folgendes mitzubringen: wie Sie das BYOD-Konzept implementieren und die Informationssicherheit nicht beeinträchtigen</a></li>
<li><a href="../de467401/index.html">Vergleich von Tesla Model S und Porsche Taycan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>