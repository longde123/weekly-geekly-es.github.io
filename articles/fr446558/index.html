<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👩 👨🏾‍🏭 📝 Structures de données exotiques: Merkle modifiée Patricia Trie 💘 🆕 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Quel genre de diable devrais-je me souvenir par cœur de tous ces fichus algorithmes et structures de données?" 


 À ce sujet se résume aux commentai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de données exotiques: Merkle modifiée Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"Quel genre de diable devrais-je me souvenir par cœur de tous ces fichus algorithmes et structures de données?"</em> </p><br><p>  À ce sujet se résume aux commentaires de la plupart des articles sur le passage des entretiens techniques.  La thèse principale, en règle générale, est que tout ce qui est utilisé d'une manière ou d'une autre a déjà été mis en œuvre dix fois et il est très peu probable que ce programmeur ordinaire doive y faire face.  Eh bien, dans une certaine mesure, cela est vrai.  Mais, il s'est avéré que tout n'était pas implémenté, et moi, malheureusement (ou heureusement?), Je devais encore créer une structure de données. </p><br><p>  Mystérieuse Merkle modifiée Patricia Trie. </p><br><p>  Puisqu'il n'y a aucune information sur cet arbre sur le habr et sur le milieu - un peu plus, je veux vous dire de quel type d'animal il s'agit et avec quoi il est mangé. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Qu'est ce que c'est </h2><br><p>  <em>Avertissement: la principale source d'informations pour la mise en œuvre pour moi était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le papier jaune</a> , ainsi que les codes source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parity-ethereum</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-ethereum</a> .</em>  <em>Il y avait un minimum d'informations théoriques sur la justification de certaines décisions, donc toutes les conclusions sur les raisons de prendre certaines décisions m'appartiennent.</em>  <em>Au cas où je me tromperais sur quelque chose - je serai heureux des corrections dans les commentaires.</em> </p><br><p>  <em>Un arbre</em> est une structure de données qui est un graphe acyclique connecté.  Ici, tout est simple, tout le monde le sait. </p><br><p>  <em>L'arbre des préfixes</em> est l'arbre racine dans lequel les paires clé-valeur peuvent être stockées car les nœuds sont divisés en deux types: ceux qui contiennent une partie du chemin (préfixe) et les nœuds feuilles qui contiennent la valeur stockée.  Une valeur est présente dans un arbre si et seulement si, à l'aide de la clé, nous pouvons aller jusqu'à la racine de l'arbre et trouver un nœud avec une valeur à la fin. </p><br><p>  <em>L'arbre PATRICIA</em> est un arbre de préfixe dans lequel les préfixes sont binaires - c'est-à-dire que chaque nœud clé stocke des informations sur un bit. </p><br><p>  <em>L'</em> arbre <em>Merkle</em> est un arbre de hachage construit sur une sorte de chaîne de données, agrégeant ces mêmes hachages en un seul (racine), stockant des informations sur l'état de tous les blocs de données.  Autrement dit, le hachage racine est une sorte de "signature numérique" de l'état de la chaîne de blocs.  Cette chose est utilisée activement dans la blockchain, et plus d'informations à ce sujet peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Le travail acharné est ..."></p><br><p>  Total: Merkle modifié Patricia Trie (ci-après MPT pour faire court) est un arbre de hachage qui stocke les paires clé-valeur, et les clés sont présentées sous forme binaire.  Et en quoi consiste exactement «Modifié», nous le découvrirons un peu plus tard lorsque nous discuterons de l'implémentation. </p><br><h2 id="zachem-eto">  Pourquoi ça? </h2><br><p>  MPT est utilisé dans le projet Ethereum pour stocker des données sur les comptes, les transactions, les résultats de leur exécution et d'autres données nécessaires au fonctionnement du système. <br>  Contrairement au Bitcoin, dans lequel l'état est implicite et est calculé par chaque nœud indépendamment, le solde de chaque compte (ainsi que les données qui lui sont associées) sont stockés directement sur la blockchain en direct.  De plus, l'emplacement et l'immuabilité des données doivent être fournis cryptographiquement - peu de gens utiliseront la crypto-monnaie dans laquelle le solde d'un compte aléatoire peut changer sans raisons objectives. </p><br><p>  Le principal problème rencontré par les développeurs d'Ethereum est la création d'une structure de données capable de stocker efficacement des paires clé-valeur et en même temps de vérifier les données stockées.  Alors MPT est apparu. </p><br><h2 id="kak-eto">  Comment est-ce? </h2><br><p>  MPT est un arbre de préfixe PATRICIA dans lequel les clés sont des séquences d'octets. </p><br><p>  Les bords de cet arbre sont des séquences de quartets (demi-octets).  En conséquence, un nœud peut avoir jusqu'à seize descendants (correspondant aux branches de 0x0 à 0xF). </p><br><p>  Les nœuds sont divisés en 3 types: </p><br><ul><li>  Noeud de branche.  Le nœud utilisé pour la ramification.  Contient jusqu'à 1 à 16 liens vers des nœuds enfants.  Peut également contenir une valeur. </li><li>  Noeud d'extension.  Un nœud auxiliaire qui stocke une partie du chemin commun à plusieurs nœuds enfants, ainsi qu'un lien vers le nœud de branche, qui se trouve ci-dessous. </li><li>  Nœud foliaire.  Un nœud contenant une partie du chemin et la valeur stockée.  C'est la fin de la chaîne. </li></ul><br><p> Comme déjà mentionné, MPT est construit au-dessus d'un autre référentiel kv, qui stocke les nœuds sous la forme de "lien" =&gt; "nœud codé <code>RLP</code> ". </p><br><p>  <em>Et nous arrivons ici avec un nouveau concept: RLP.</em>  <em>En bref, il s'agit d'une méthode de codage de données représentant des listes ou des séquences d'octets.</em>  <em>Exemple: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>Je n'entrerai pas dans les détails en particulier, et dans la mise en œuvre, j'utilise une bibliothèque prête à l'emploi, car la couverture de ce sujet gonflera également un article déjà assez volumineux.</em>  <em>Si vous êtes toujours intéressé, vous pouvez en savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</em>  <em>Nous nous limitons au fait que nous pouvons encoder des données en <code>RLP</code> et les décoder à nouveau.</em> </p><br><p>  Un lien vers un nœud est défini comme suit: si la longueur du nœud codé <code>RLP</code> est de 32 octets ou plus, alors le lien est un hachage <code>keccak</code> de la représentation <code>RLP</code> du nœud.  Si la longueur est inférieure à 32 octets, le lien est la représentation <code>RLP</code> du nœud lui-même. </p><br><p>  De toute évidence, dans le deuxième cas, vous n'avez pas besoin d'enregistrer le nœud dans la base de données, car  il sera entièrement enregistré dans le nœud parent. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Les nœuds sont différents"></p><br><p>  La combinaison de trois types de nœuds vous permet de stocker efficacement des données dans le cas où il y a peu de clés (alors la plupart des chemins seront stockés dans les nœuds d'extension et de feuille, et il y aura peu de nœuds de branche), et dans le cas où il y a beaucoup de nœuds (les chemins ne seront pas stockés explicitement, mais ils "se rassembleront" pendant le passage à travers des nœuds de branche). </p><br><p>  Un exemple complet d'arbre utilisant toutes sortes de nœuds: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="L'arbre est plein mais pas épais"></p><br><p>  Comme vous l'avez peut-être remarqué, les parties stockées des chemins sont préfixées.  Les préfixes sont nécessaires à plusieurs fins: </p><br><ol><li>  Distinguer les nœuds d'extension des nœuds feuilles. </li><li>  Pour aligner des séquences d'un nombre impair de grignotages. </li></ol><br><p>  Les règles de création des préfixes sont très simples: </p><br><ul><li>  Le préfixe prend 1 quartet.  Si la longueur du chemin (à l'exclusion du préfixe) est impaire, le chemin commence immédiatement après le préfixe.  Si la longueur du chemin est pair, pour aligner après le préfixe, le quartet 0x0 est ajouté en premier. </li><li>  Le préfixe est initialement 0x0. </li><li>  Si la longueur du chemin est impaire, alors 0x1 est ajouté au préfixe, si pair - 0x0. </li><li>  Si le chemin mène à un nœud Leaf, 0x2 est ajouté au préfixe, si 0x0 est ajouté au nœud Extension. </li></ul><br><p>  Sur les beatiks, je pense que ce sera plus clair: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Suppression qui n'est pas une suppression </h3><br><p>  Malgré le fait que l'arborescence ait pour effet de supprimer des nœuds, en fait, tout ce qui a été ajouté une fois reste dans l'arborescence pour toujours. </p><br><p>  Cela est nécessaire pour ne pas créer une arborescence complète pour chaque bloc, mais pour ne stocker que la différence entre l'ancienne et la nouvelle version de l'arborescence. </p><br><p>  Par conséquent, en utilisant différents hachages racine comme point d'entrée, nous pouvons obtenir l'un des états dans lesquels l'arbre a déjà été. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Qu'est-ce qui est écrit avec un stylo ..."></p><br><p>  Ce ne sont pas toutes des optimisations.  Il y a plus, mais nous n'en parlerons pas - et donc l'article est volumineux.  Cependant, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lire par</a> vous-même. </p><br><h2 id="realizaciya">  Implémentation </h2><br><p>  La théorie est terminée, passons à la pratique.  Nous utiliserons la lingua franca du monde informatique, c'est-à-dire le <code>python</code> . </p><br><p>  Puisqu'il y aura beaucoup de code, et pour le format de l'article beaucoup devra être réduit et divisé, je laisserai immédiatement un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br>  Si nécessaire, vous pouvez voir l'image entière. </p><br><p>  Tout d'abord, nous définissons l'interface d'arbre que nous voulons obtenir en conséquence: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  L'interface est extrêmement simple.  Les opérations disponibles sont l'obtention, la suppression, l'insertion et la modification (combinées dans la mise à jour), ainsi que l'obtention du hachage racine. </p><br><p>  Le stockage sera transféré à la méthode <code>__init__</code> - une structure de données de type <code>dict</code> dans laquelle nous <code>__init__</code> les nœuds, ainsi que la <code>root</code> - le "sommet" de l'arborescence.  Si <code>None</code> est passé en tant que <code>root</code> , nous supposons que l'arborescence est vide et fonctionne à partir de zéro. </p><br><p>  _Remarque: vous vous demandez peut-être pourquoi les variables dans les méthodes sont nommées en tant que <code>encoded_key</code> et <code>encoded_value</code> , et pas seulement <code>key</code> / <code>value</code> .  La réponse est simple: selon la spécification, toutes les clés et valeurs doivent être encodées en <code>RLP</code> .  Nous ne nous en préoccuperons pas et laisserons cette occupation sur les épaules des utilisateurs de la bibliothèque._ </p><br><p>  Cependant, avant de commencer à implémenter l'arbre lui-même, deux choses importantes doivent être faites: </p><br><ol><li>  Implémentez la classe <code>NibblePath</code> , qui est une chaîne de grignotages, afin de ne pas les coder manuellement. </li><li>  Pour implémenter la classe <code>Node</code> dans le cadre de cette classe - <code>Extension</code> , <code>Leaf</code> et <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Nibblepath </h3><br><p>  Alors, <code>NibblePath</code> .  Puisque nous nous déplacerons activement dans l'arborescence, la base de la fonctionnalité de notre classe devrait être la possibilité de définir le "décalage" depuis le début du chemin, ainsi que de recevoir un quartet spécifique.  Sachant cela, nous définissons la base de notre classe (ainsi que quelques constantes utiles pour travailler avec les préfixes ci-dessous): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  C'est assez simple, non? </p><br><p>  Il ne reste plus qu'à écrire des fonctions d'encodage et de décodage d'une séquence de quartets. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  En principe, c'est le minimum nécessaire pour un travail pratique avec des amuse-gueules.  Bien sûr, dans l'implémentation actuelle, il existe encore un certain nombre de méthodes auxiliaires (telles que <code>combine</code> , fusionner deux chemins en un seul), mais leur implémentation est très triviale.  Si vous êtes intéressé, la version complète peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h3 id="node">  Noeud </h3><br><p>  Comme nous le savons déjà, nos nœuds sont divisés en trois types: Leaf, Extension et Branch.  Tous peuvent être encodés et décodés, et la seule différence réside dans les données stockées à l'intérieur.  Pour être honnête, c'est ce que les types de données algébriques sont demandés, et dans <code>Rust</code> , par exemple, j'écrirais quelque chose dans l'esprit: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  Cependant, il n'y a pas d'ADT en python en tant que tel, nous allons donc définir la classe <code>Node</code> , et à l'intérieur, il y a trois classes correspondant aux types de nœuds.  Nous implémentons le codage directement dans les classes de nœuds et le décodage dans la classe de <code>Node</code> . </p><br><p>  La mise en œuvre est cependant élémentaire: </p><br><p>  Feuille: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Extension: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Succursale: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Tout est très simple.  La seule chose qui peut poser des questions est la fonction <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Ensuite, je l'avoue, j'ai dû utiliser une petite béquille.</em>  <em>Le fait est que la bibliothèque <code>rlp</code> décode les données de manière récursive, et le lien vers un autre nœud, comme nous le savons, peut être des données <code>rlp</code> (dans le cas où le nœud codé fait moins de 32 caractères).</em>  <em>Travailler avec des liens dans deux formats - octets de hachage et nœud décodé - est très gênant.</em>  <em>Par conséquent, j'ai écrit deux fonctions qui, après décodage du nœud, renvoient les liens au format octet, et les décodent si nécessaire, avant d'enregistrer.</em>  <em>Ces fonctions sont:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Terminez avec les nœuds en écrivant une classe <code>Node</code> .  Il n'y aura que 2 méthodes: décoder le nœud et transformer le nœud en lien. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Une pause </h2><br><p>  Fuh!  Il y a beaucoup d'informations.  Je pense qu'il est temps de se détendre.  Voici un autre chat pour vous: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Vous pouvez prendre une bouchée pendant la pause"></p><br><p>  Milota, c'est ça?  Bon, revenons à nos arbres. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hourra - les éléments auxiliaires sont prêts, nous passons aux plus délicieux.  Au cas où, je rappellerai l'interface de notre arbre.  Dans le même temps, nous implémentons la méthode <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Mais avec les méthodes restantes, nous traiterons un par un. </p><br><h3 id="get">  obtenir </h3><br><p>  La méthode <code>get</code> (comme, en principe, les autres méthodes) comprendra deux parties.  La méthode elle-même préparera les données et amènera le résultat à la forme attendue, tandis que le vrai travail se fera à l'intérieur de la méthode auxiliaire. </p><br><p>  La méthode de base est extrêmement simple: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  Cependant, <code>_get</code> pas beaucoup plus compliqué: pour arriver au nœud souhaité, nous devons aller de la racine à l'ensemble du chemin fourni.  Si à la fin nous avons trouvé un nœud avec des données (feuille ou branche) - hourra, les données sont reçues.  S'il n'a pas été possible de passer, la clé requise est manquante dans l'arborescence. </p><br><p>  Réalisation: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Eh bien, en même temps, nous écrirons des méthodes pour sauvegarder et charger des nœuds.  Ils sont simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  mettre à jour </h3><br><p>  La méthode de <code>update</code> est déjà plus intéressante.  Il suffit d'aller jusqu'au bout et d'insérer le nœud Feuille ne fonctionnera pas toujours.  Il est probable que le point de séparation des clés se trouve quelque part à l'intérieur du nœud Feuille ou Extension déjà enregistré.  Dans ce cas, vous devrez les séparer et créer plusieurs nouveaux nœuds. </p><br><p>  En général, toute la logique peut être décrite par les règles suivantes: </p><br><ol><li>  Alors que le chemin coïncide entièrement avec les nœuds existants, nous descendons récursivement l'arbre. </li><li>  Si le chemin est terminé et que nous sommes dans le nœud Branche ou Feuille, cela signifie que la <code>update</code> met simplement à jour la valeur correspondant à cette clé. </li><li>  Si les chemins sont divisés (c'est-à-dire que nous ne mettons pas à jour la valeur, mais en insérons une nouvelle), et que nous sommes dans le nœud Branche, créez un nœud Feuille et spécifiez un lien vers celui-ci dans la branche de branche branche correspondante. </li><li>  Si les chemins sont divisés et que nous sommes dans le nœud Feuille ou Extension, nous devons créer un nœud Branche qui sépare les chemins et, si nécessaire, un nœud Extension pour la partie commune du chemin. </li></ol><br><p>  Exprimons progressivement cela dans le code.  Pourquoi progressivement?  Parce que la méthode est volumineuse et il sera difficile de la comprendre en vrac. <br>  Cependant, je vais laisser un lien vers la méthode complète <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  Il n'y a pas assez de logique générale, le plus intéressant est à l'intérieur <code>if</code> art. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Voyons d'abord les nœuds Leaf.  Seuls 2 scénarios sont possibles avec eux: </p><br><ol><li><p>  Le reste du chemin que nous suivons est exactement le même que le chemin stocké dans le nœud Feuille.  Dans ce cas, il suffit de modifier la valeur, d'enregistrer le nouveau nœud et de lui renvoyer un lien. </p><br></li><li><p>  Les chemins sont différents. <br>  Dans ce cas, vous devez créer un nœud de branche qui sépare les deux chemins. <br>  Si l'un des chemins est vide, sa valeur sera transférée directement au nœud de branche. <br>  Sinon, il faudra créer deux nœuds Leaf raccourcis de la longueur de la partie commune des chemins + 1 quartet (ce quartet sera indiqué par l'index de la branche correspondante du nœud Branch). </p><br></li></ol><br><p>  Vous devrez également vérifier s'il existe une partie commune du chemin afin de comprendre si nous devons également créer un nœud d'extension. </p><br><p>  Dans le code, cela ressemblera à ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  La procédure <code>_create_branch_node</code> est la suivante: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  Dans le cas du nœud Extension, tout ressemble à un nœud Leaf. </p><br><ol><li><p>  Si le chemin du nœud Extension est un préfixe pour notre chemin, nous allons simplement de manière récursive. </p><br></li><li><p>  Sinon, nous devons faire la séparation en utilisant le nœud Branch, comme dans le cas décrit ci-dessus. </p><br></li></ol><br><p>  En conséquence, le code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  La procédure <code>_create_branch_extension</code> logiquement équivalente à la procédure <code>_create_branch_leaf</code> , mais fonctionne avec le nœud Extension. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Mais avec le nœud Branch, tout est simple.  Si le chemin est vide, nous enregistrons simplement la nouvelle valeur dans le nœud Branch actuel.  Si le chemin n'est pas vide, nous en «mordons» un quartet et descendons récursivement. </p><br><p>  Le code, je pense, n'a pas besoin de commentaires. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  effacer </h3><br><p>  Fuh!  La dernière méthode reste.  Il est le plus gai.  La complexité de la suppression est que nous devons remettre la structure dans l'état dans lequel elle serait tombée si nous avions fait toute la chaîne de <code>update</code> , à l'exclusion uniquement de la clé supprimée. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est extrêmement important, car sinon une situation est possible dans laquelle le hachage racine différera pour deux arbres contenant les mêmes données. </font><font style="vertical-align: inherit;">Et une telle «fonctionnalité», comme vous le comprenez, effacera tout le sens de cette structure de données.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette exigence donne lieu à un assez grand nombre de scénarios d'action possibles. </font><font style="vertical-align: inherit;">De plus, la fonction au N-ème niveau d'imbrication après suppression directe devra savoir ce qui s'est passé au niveau N + 1. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons introduire une énumération supplémentaire - </font></font><code>DeleteAction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous reviendrons en haut.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cadre de la méthode </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressemblera à ceci:</font></font></p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      —     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" —    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   —    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    —   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     … </p><br><p>  Pourquoi?   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    —     Leaf-.          —      Extension-.         ,    ,    2   —  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> — <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    — Leaf  Extension,           ,   . </p><br><p>     — Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  Le reste </h3><br><p>      .  , …    <code>root</code> . </p><br><p>  Ici: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  …  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> —  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="That's all folks!"></p><br><h2 id="rezultaty">  Résultats </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    —  ,       . </p><br><p> -,   ,  ,            — .  ,        skip list  interval tree,     — , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     —   . </p><br><p>   ,  ,        —    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446558/">https://habr.com/ru/post/fr446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446546/index.html">Microsoft étend Azure IP Advantage avec de nouveaux avantages IP pour les innovateurs et les startups Azure IoT</a></li>
<li><a href="../fr446548/index.html">Analyse des statistiques sur les campagnes publicitaires - créer une nouvelle métrique dans le DataFrame (python)</a></li>
<li><a href="../fr446550/index.html">Problèmes de modèle de coordinateur et qu'est-ce que RouteComposer a à voir avec cela</a></li>
<li><a href="../fr446552/index.html">Utilisation des commandes APDU à l'aide de l'exemple EToken</a></li>
<li><a href="../fr446554/index.html">Programme résident Yandex, ou Comment un back-end expérimenté devient ingénieur ML</a></li>
<li><a href="../fr446560/index.html">"Courtesy Exchange": l'essence du conflit entre les deux sociétés de streaming les plus célèbres</a></li>
<li><a href="../fr446562/index.html">Asynchronie dans la programmation</a></li>
<li><a href="../fr446566/index.html">Project Zero. Comment Amazon veut gérer les contrefaçons</a></li>
<li><a href="../fr446568/index.html">Mise à jour CMS à grande échelle d'Umbraco 8: Quoi de neuf</a></li>
<li><a href="../fr446570/index.html">L'histoire du premier GPU: Rendition Vérité 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>