<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üë®üèæ‚Äçüè≠ üìù Structures de donn√©es exotiques: Merkle modifi√©e Patricia Trie üíò üÜï üëàüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Quel genre de diable devrais-je me souvenir par c≈ìur de tous ces fichus algorithmes et structures de donn√©es?" 


 √Ä ce sujet se r√©sume aux commentai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de donn√©es exotiques: Merkle modifi√©e Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"Quel genre de diable devrais-je me souvenir par c≈ìur de tous ces fichus algorithmes et structures de donn√©es?"</em> </p><br><p>  √Ä ce sujet se r√©sume aux commentaires de la plupart des articles sur le passage des entretiens techniques.  La th√®se principale, en r√®gle g√©n√©rale, est que tout ce qui est utilis√© d'une mani√®re ou d'une autre a d√©j√† √©t√© mis en ≈ìuvre dix fois et il est tr√®s peu probable que ce programmeur ordinaire doive y faire face.  Eh bien, dans une certaine mesure, cela est vrai.  Mais, il s'est av√©r√© que tout n'√©tait pas impl√©ment√©, et moi, malheureusement (ou heureusement?), Je devais encore cr√©er une structure de donn√©es. </p><br><p>  Myst√©rieuse Merkle modifi√©e Patricia Trie. </p><br><p>  Puisqu'il n'y a aucune information sur cet arbre sur le habr et sur le milieu - un peu plus, je veux vous dire de quel type d'animal il s'agit et avec quoi il est mang√©. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Qu'est ce que c'est </h2><br><p>  <em>Avertissement: la principale source d'informations pour la mise en ≈ìuvre pour moi √©tait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le papier jaune</a> , ainsi que les codes source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parity-ethereum</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-ethereum</a> .</em>  <em>Il y avait un minimum d'informations th√©oriques sur la justification de certaines d√©cisions, donc toutes les conclusions sur les raisons de prendre certaines d√©cisions m'appartiennent.</em>  <em>Au cas o√π je me tromperais sur quelque chose - je serai heureux des corrections dans les commentaires.</em> </p><br><p>  <em>Un arbre</em> est une structure de donn√©es qui est un graphe acyclique connect√©.  Ici, tout est simple, tout le monde le sait. </p><br><p>  <em>L'arbre des pr√©fixes</em> est l'arbre racine dans lequel les paires cl√©-valeur peuvent √™tre stock√©es car les n≈ìuds sont divis√©s en deux types: ceux qui contiennent une partie du chemin (pr√©fixe) et les n≈ìuds feuilles qui contiennent la valeur stock√©e.  Une valeur est pr√©sente dans un arbre si et seulement si, √† l'aide de la cl√©, nous pouvons aller jusqu'√† la racine de l'arbre et trouver un n≈ìud avec une valeur √† la fin. </p><br><p>  <em>L'arbre PATRICIA</em> est un arbre de pr√©fixe dans lequel les pr√©fixes sont binaires - c'est-√†-dire que chaque n≈ìud cl√© stocke des informations sur un bit. </p><br><p>  <em>L'</em> arbre <em>Merkle</em> est un arbre de hachage construit sur une sorte de cha√Æne de donn√©es, agr√©geant ces m√™mes hachages en un seul (racine), stockant des informations sur l'√©tat de tous les blocs de donn√©es.  Autrement dit, le hachage racine est une sorte de "signature num√©rique" de l'√©tat de la cha√Æne de blocs.  Cette chose est utilis√©e activement dans la blockchain, et plus d'informations √† ce sujet peuvent √™tre trouv√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Le travail acharn√© est ..."></p><br><p>  Total: Merkle modifi√© Patricia Trie (ci-apr√®s MPT pour faire court) est un arbre de hachage qui stocke les paires cl√©-valeur, et les cl√©s sont pr√©sent√©es sous forme binaire.  Et en quoi consiste exactement ¬´Modifi√©¬ª, nous le d√©couvrirons un peu plus tard lorsque nous discuterons de l'impl√©mentation. </p><br><h2 id="zachem-eto">  Pourquoi √ßa? </h2><br><p>  MPT est utilis√© dans le projet Ethereum pour stocker des donn√©es sur les comptes, les transactions, les r√©sultats de leur ex√©cution et d'autres donn√©es n√©cessaires au fonctionnement du syst√®me. <br>  Contrairement au Bitcoin, dans lequel l'√©tat est implicite et est calcul√© par chaque n≈ìud ind√©pendamment, le solde de chaque compte (ainsi que les donn√©es qui lui sont associ√©es) sont stock√©s directement sur la blockchain en direct.  De plus, l'emplacement et l'immuabilit√© des donn√©es doivent √™tre fournis cryptographiquement - peu de gens utiliseront la crypto-monnaie dans laquelle le solde d'un compte al√©atoire peut changer sans raisons objectives. </p><br><p>  Le principal probl√®me rencontr√© par les d√©veloppeurs d'Ethereum est la cr√©ation d'une structure de donn√©es capable de stocker efficacement des paires cl√©-valeur et en m√™me temps de v√©rifier les donn√©es stock√©es.  Alors MPT est apparu. </p><br><h2 id="kak-eto">  Comment est-ce? </h2><br><p>  MPT est un arbre de pr√©fixe PATRICIA dans lequel les cl√©s sont des s√©quences d'octets. </p><br><p>  Les bords de cet arbre sont des s√©quences de quartets (demi-octets).  En cons√©quence, un n≈ìud peut avoir jusqu'√† seize descendants (correspondant aux branches de 0x0 √† 0xF). </p><br><p>  Les n≈ìuds sont divis√©s en 3 types: </p><br><ul><li>  Noeud de branche.  Le n≈ìud utilis√© pour la ramification.  Contient jusqu'√† 1 √† 16 liens vers des n≈ìuds enfants.  Peut √©galement contenir une valeur. </li><li>  Noeud d'extension.  Un n≈ìud auxiliaire qui stocke une partie du chemin commun √† plusieurs n≈ìuds enfants, ainsi qu'un lien vers le n≈ìud de branche, qui se trouve ci-dessous. </li><li>  N≈ìud foliaire.  Un n≈ìud contenant une partie du chemin et la valeur stock√©e.  C'est la fin de la cha√Æne. </li></ul><br><p> Comme d√©j√† mentionn√©, MPT est construit au-dessus d'un autre r√©f√©rentiel kv, qui stocke les n≈ìuds sous la forme de "lien" =&gt; "n≈ìud cod√© <code>RLP</code> ". </p><br><p>  <em>Et nous arrivons ici avec un nouveau concept: RLP.</em>  <em>En bref, il s'agit d'une m√©thode de codage de donn√©es repr√©sentant des listes ou des s√©quences d'octets.</em>  <em>Exemple: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>Je n'entrerai pas dans les d√©tails en particulier, et dans la mise en ≈ìuvre, j'utilise une biblioth√®que pr√™te √† l'emploi, car la couverture de ce sujet gonflera √©galement un article d√©j√† assez volumineux.</em>  <em>Si vous √™tes toujours int√©ress√©, vous pouvez en savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</em>  <em>Nous nous limitons au fait que nous pouvons encoder des donn√©es en <code>RLP</code> et les d√©coder √† nouveau.</em> </p><br><p>  Un lien vers un n≈ìud est d√©fini comme suit: si la longueur du n≈ìud cod√© <code>RLP</code> est de 32 octets ou plus, alors le lien est un hachage <code>keccak</code> de la repr√©sentation <code>RLP</code> du n≈ìud.  Si la longueur est inf√©rieure √† 32 octets, le lien est la repr√©sentation <code>RLP</code> du n≈ìud lui-m√™me. </p><br><p>  De toute √©vidence, dans le deuxi√®me cas, vous n'avez pas besoin d'enregistrer le n≈ìud dans la base de donn√©es, car  il sera enti√®rement enregistr√© dans le n≈ìud parent. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Les n≈ìuds sont diff√©rents"></p><br><p>  La combinaison de trois types de n≈ìuds vous permet de stocker efficacement des donn√©es dans le cas o√π il y a peu de cl√©s (alors la plupart des chemins seront stock√©s dans les n≈ìuds d'extension et de feuille, et il y aura peu de n≈ìuds de branche), et dans le cas o√π il y a beaucoup de n≈ìuds (les chemins ne seront pas stock√©s explicitement, mais ils "se rassembleront" pendant le passage √† travers des n≈ìuds de branche). </p><br><p>  Un exemple complet d'arbre utilisant toutes sortes de n≈ìuds: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="L'arbre est plein mais pas √©pais"></p><br><p>  Comme vous l'avez peut-√™tre remarqu√©, les parties stock√©es des chemins sont pr√©fix√©es.  Les pr√©fixes sont n√©cessaires √† plusieurs fins: </p><br><ol><li>  Distinguer les n≈ìuds d'extension des n≈ìuds feuilles. </li><li>  Pour aligner des s√©quences d'un nombre impair de grignotages. </li></ol><br><p>  Les r√®gles de cr√©ation des pr√©fixes sont tr√®s simples: </p><br><ul><li>  Le pr√©fixe prend 1 quartet.  Si la longueur du chemin (√† l'exclusion du pr√©fixe) est impaire, le chemin commence imm√©diatement apr√®s le pr√©fixe.  Si la longueur du chemin est pair, pour aligner apr√®s le pr√©fixe, le quartet 0x0 est ajout√© en premier. </li><li>  Le pr√©fixe est initialement 0x0. </li><li>  Si la longueur du chemin est impaire, alors 0x1 est ajout√© au pr√©fixe, si pair - 0x0. </li><li>  Si le chemin m√®ne √† un n≈ìud Leaf, 0x2 est ajout√© au pr√©fixe, si 0x0 est ajout√© au n≈ìud Extension. </li></ul><br><p>  Sur les beatiks, je pense que ce sera plus clair: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Suppression qui n'est pas une suppression </h3><br><p>  Malgr√© le fait que l'arborescence ait pour effet de supprimer des n≈ìuds, en fait, tout ce qui a √©t√© ajout√© une fois reste dans l'arborescence pour toujours. </p><br><p>  Cela est n√©cessaire pour ne pas cr√©er une arborescence compl√®te pour chaque bloc, mais pour ne stocker que la diff√©rence entre l'ancienne et la nouvelle version de l'arborescence. </p><br><p>  Par cons√©quent, en utilisant diff√©rents hachages racine comme point d'entr√©e, nous pouvons obtenir l'un des √©tats dans lesquels l'arbre a d√©j√† √©t√©. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Qu'est-ce qui est √©crit avec un stylo ..."></p><br><p>  Ce ne sont pas toutes des optimisations.  Il y a plus, mais nous n'en parlerons pas - et donc l'article est volumineux.  Cependant, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lire par</a> vous-m√™me. </p><br><h2 id="realizaciya">  Impl√©mentation </h2><br><p>  La th√©orie est termin√©e, passons √† la pratique.  Nous utiliserons la lingua franca du monde informatique, c'est-√†-dire le <code>python</code> . </p><br><p>  Puisqu'il y aura beaucoup de code, et pour le format de l'article beaucoup devra √™tre r√©duit et divis√©, je laisserai imm√©diatement un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br>  Si n√©cessaire, vous pouvez voir l'image enti√®re. </p><br><p>  Tout d'abord, nous d√©finissons l'interface d'arbre que nous voulons obtenir en cons√©quence: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  L'interface est extr√™mement simple.  Les op√©rations disponibles sont l'obtention, la suppression, l'insertion et la modification (combin√©es dans la mise √† jour), ainsi que l'obtention du hachage racine. </p><br><p>  Le stockage sera transf√©r√© √† la m√©thode <code>__init__</code> - une structure de donn√©es de type <code>dict</code> dans laquelle nous <code>__init__</code> les n≈ìuds, ainsi que la <code>root</code> - le "sommet" de l'arborescence.  Si <code>None</code> est pass√© en tant que <code>root</code> , nous supposons que l'arborescence est vide et fonctionne √† partir de z√©ro. </p><br><p>  _Remarque: vous vous demandez peut-√™tre pourquoi les variables dans les m√©thodes sont nomm√©es en tant que <code>encoded_key</code> et <code>encoded_value</code> , et pas seulement <code>key</code> / <code>value</code> .  La r√©ponse est simple: selon la sp√©cification, toutes les cl√©s et valeurs doivent √™tre encod√©es en <code>RLP</code> .  Nous ne nous en pr√©occuperons pas et laisserons cette occupation sur les √©paules des utilisateurs de la biblioth√®que._ </p><br><p>  Cependant, avant de commencer √† impl√©menter l'arbre lui-m√™me, deux choses importantes doivent √™tre faites: </p><br><ol><li>  Impl√©mentez la classe <code>NibblePath</code> , qui est une cha√Æne de grignotages, afin de ne pas les coder manuellement. </li><li>  Pour impl√©menter la classe <code>Node</code> dans le cadre de cette classe - <code>Extension</code> , <code>Leaf</code> et <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Nibblepath </h3><br><p>  Alors, <code>NibblePath</code> .  Puisque nous nous d√©placerons activement dans l'arborescence, la base de la fonctionnalit√© de notre classe devrait √™tre la possibilit√© de d√©finir le "d√©calage" depuis le d√©but du chemin, ainsi que de recevoir un quartet sp√©cifique.  Sachant cela, nous d√©finissons la base de notre classe (ainsi que quelques constantes utiles pour travailler avec les pr√©fixes ci-dessous): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  C'est assez simple, non? </p><br><p>  Il ne reste plus qu'√† √©crire des fonctions d'encodage et de d√©codage d'une s√©quence de quartets. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  En principe, c'est le minimum n√©cessaire pour un travail pratique avec des amuse-gueules.  Bien s√ªr, dans l'impl√©mentation actuelle, il existe encore un certain nombre de m√©thodes auxiliaires (telles que <code>combine</code> , fusionner deux chemins en un seul), mais leur impl√©mentation est tr√®s triviale.  Si vous √™tes int√©ress√©, la version compl√®te peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h3 id="node">  Noeud </h3><br><p>  Comme nous le savons d√©j√†, nos n≈ìuds sont divis√©s en trois types: Leaf, Extension et Branch.  Tous peuvent √™tre encod√©s et d√©cod√©s, et la seule diff√©rence r√©side dans les donn√©es stock√©es √† l'int√©rieur.  Pour √™tre honn√™te, c'est ce que les types de donn√©es alg√©briques sont demand√©s, et dans <code>Rust</code> , par exemple, j'√©crirais quelque chose dans l'esprit: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  Cependant, il n'y a pas d'ADT en python en tant que tel, nous allons donc d√©finir la classe <code>Node</code> , et √† l'int√©rieur, il y a trois classes correspondant aux types de n≈ìuds.  Nous impl√©mentons le codage directement dans les classes de n≈ìuds et le d√©codage dans la classe de <code>Node</code> . </p><br><p>  La mise en ≈ìuvre est cependant √©l√©mentaire: </p><br><p>  Feuille: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Extension: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Succursale: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Tout est tr√®s simple.  La seule chose qui peut poser des questions est la fonction <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Ensuite, je l'avoue, j'ai d√ª utiliser une petite b√©quille.</em>  <em>Le fait est que la biblioth√®que <code>rlp</code> d√©code les donn√©es de mani√®re r√©cursive, et le lien vers un autre n≈ìud, comme nous le savons, peut √™tre des donn√©es <code>rlp</code> (dans le cas o√π le n≈ìud cod√© fait moins de 32 caract√®res).</em>  <em>Travailler avec des liens dans deux formats - octets de hachage et n≈ìud d√©cod√© - est tr√®s g√™nant.</em>  <em>Par cons√©quent, j'ai √©crit deux fonctions qui, apr√®s d√©codage du n≈ìud, renvoient les liens au format octet, et les d√©codent si n√©cessaire, avant d'enregistrer.</em>  <em>Ces fonctions sont:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Terminez avec les n≈ìuds en √©crivant une classe <code>Node</code> .  Il n'y aura que 2 m√©thodes: d√©coder le n≈ìud et transformer le n≈ìud en lien. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Une pause </h2><br><p>  Fuh!  Il y a beaucoup d'informations.  Je pense qu'il est temps de se d√©tendre.  Voici un autre chat pour vous: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Vous pouvez prendre une bouch√©e pendant la pause"></p><br><p>  Milota, c'est √ßa?  Bon, revenons √† nos arbres. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hourra - les √©l√©ments auxiliaires sont pr√™ts, nous passons aux plus d√©licieux.  Au cas o√π, je rappellerai l'interface de notre arbre.  Dans le m√™me temps, nous impl√©mentons la m√©thode <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Mais avec les m√©thodes restantes, nous traiterons un par un. </p><br><h3 id="get">  obtenir </h3><br><p>  La m√©thode <code>get</code> (comme, en principe, les autres m√©thodes) comprendra deux parties.  La m√©thode elle-m√™me pr√©parera les donn√©es et am√®nera le r√©sultat √† la forme attendue, tandis que le vrai travail se fera √† l'int√©rieur de la m√©thode auxiliaire. </p><br><p>  La m√©thode de base est extr√™mement simple: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  Cependant, <code>_get</code> pas beaucoup plus compliqu√©: pour arriver au n≈ìud souhait√©, nous devons aller de la racine √† l'ensemble du chemin fourni.  Si √† la fin nous avons trouv√© un n≈ìud avec des donn√©es (feuille ou branche) - hourra, les donn√©es sont re√ßues.  S'il n'a pas √©t√© possible de passer, la cl√© requise est manquante dans l'arborescence. </p><br><p>  R√©alisation: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Eh bien, en m√™me temps, nous √©crirons des m√©thodes pour sauvegarder et charger des n≈ìuds.  Ils sont simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  mettre √† jour </h3><br><p>  La m√©thode de <code>update</code> est d√©j√† plus int√©ressante.  Il suffit d'aller jusqu'au bout et d'ins√©rer le n≈ìud Feuille ne fonctionnera pas toujours.  Il est probable que le point de s√©paration des cl√©s se trouve quelque part √† l'int√©rieur du n≈ìud Feuille ou Extension d√©j√† enregistr√©.  Dans ce cas, vous devrez les s√©parer et cr√©er plusieurs nouveaux n≈ìuds. </p><br><p>  En g√©n√©ral, toute la logique peut √™tre d√©crite par les r√®gles suivantes: </p><br><ol><li>  Alors que le chemin co√Øncide enti√®rement avec les n≈ìuds existants, nous descendons r√©cursivement l'arbre. </li><li>  Si le chemin est termin√© et que nous sommes dans le n≈ìud Branche ou Feuille, cela signifie que la <code>update</code> met simplement √† jour la valeur correspondant √† cette cl√©. </li><li>  Si les chemins sont divis√©s (c'est-√†-dire que nous ne mettons pas √† jour la valeur, mais en ins√©rons une nouvelle), et que nous sommes dans le n≈ìud Branche, cr√©ez un n≈ìud Feuille et sp√©cifiez un lien vers celui-ci dans la branche de branche branche correspondante. </li><li>  Si les chemins sont divis√©s et que nous sommes dans le n≈ìud Feuille ou Extension, nous devons cr√©er un n≈ìud Branche qui s√©pare les chemins et, si n√©cessaire, un n≈ìud Extension pour la partie commune du chemin. </li></ol><br><p>  Exprimons progressivement cela dans le code.  Pourquoi progressivement?  Parce que la m√©thode est volumineuse et il sera difficile de la comprendre en vrac. <br>  Cependant, je vais laisser un lien vers la m√©thode compl√®te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  Il n'y a pas assez de logique g√©n√©rale, le plus int√©ressant est √† l'int√©rieur <code>if</code> art. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Voyons d'abord les n≈ìuds Leaf.  Seuls 2 sc√©narios sont possibles avec eux: </p><br><ol><li><p>  Le reste du chemin que nous suivons est exactement le m√™me que le chemin stock√© dans le n≈ìud Feuille.  Dans ce cas, il suffit de modifier la valeur, d'enregistrer le nouveau n≈ìud et de lui renvoyer un lien. </p><br></li><li><p>  Les chemins sont diff√©rents. <br>  Dans ce cas, vous devez cr√©er un n≈ìud de branche qui s√©pare les deux chemins. <br>  Si l'un des chemins est vide, sa valeur sera transf√©r√©e directement au n≈ìud de branche. <br>  Sinon, il faudra cr√©er deux n≈ìuds Leaf raccourcis de la longueur de la partie commune des chemins + 1 quartet (ce quartet sera indiqu√© par l'index de la branche correspondante du n≈ìud Branch). </p><br></li></ol><br><p>  Vous devrez √©galement v√©rifier s'il existe une partie commune du chemin afin de comprendre si nous devons √©galement cr√©er un n≈ìud d'extension. </p><br><p>  Dans le code, cela ressemblera √† ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  La proc√©dure <code>_create_branch_node</code> est la suivante: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  Dans le cas du n≈ìud Extension, tout ressemble √† un n≈ìud Leaf. </p><br><ol><li><p>  Si le chemin du n≈ìud Extension est un pr√©fixe pour notre chemin, nous allons simplement de mani√®re r√©cursive. </p><br></li><li><p>  Sinon, nous devons faire la s√©paration en utilisant le n≈ìud Branch, comme dans le cas d√©crit ci-dessus. </p><br></li></ol><br><p>  En cons√©quence, le code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  La proc√©dure <code>_create_branch_extension</code> logiquement √©quivalente √† la proc√©dure <code>_create_branch_leaf</code> , mais fonctionne avec le n≈ìud Extension. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Mais avec le n≈ìud Branch, tout est simple.  Si le chemin est vide, nous enregistrons simplement la nouvelle valeur dans le n≈ìud Branch actuel.  Si le chemin n'est pas vide, nous en ¬´mordons¬ª un quartet et descendons r√©cursivement. </p><br><p>  Le code, je pense, n'a pas besoin de commentaires. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  effacer </h3><br><p>  Fuh!  La derni√®re m√©thode reste.  Il est le plus gai.  La complexit√© de la suppression est que nous devons remettre la structure dans l'√©tat dans lequel elle serait tomb√©e si nous avions fait toute la cha√Æne de <code>update</code> , √† l'exclusion uniquement de la cl√© supprim√©e. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est extr√™mement important, car sinon une situation est possible dans laquelle le hachage racine diff√©rera pour deux arbres contenant les m√™mes donn√©es. </font><font style="vertical-align: inherit;">Et une telle ¬´fonctionnalit√©¬ª, comme vous le comprenez, effacera tout le sens de cette structure de donn√©es.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette exigence donne lieu √† un assez grand nombre de sc√©narios d'action possibles. </font><font style="vertical-align: inherit;">De plus, la fonction au N-√®me niveau d'imbrication apr√®s suppression directe devra savoir ce qui s'est pass√© au niveau N + 1. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons introduire une √©num√©ration suppl√©mentaire - </font></font><code>DeleteAction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous reviendrons en haut.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cadre de la m√©thode </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressemblera √† ceci:</font></font></p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      ‚Äî     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" ‚Äî    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   ‚Äî    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    ‚Äî   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     ‚Ä¶ </p><br><p>  Pourquoi?   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    ‚Äî     Leaf-.          ‚Äî      Extension-.         ,    ,    2   ‚Äî  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> ‚Äî <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    ‚Äî Leaf  Extension,           ,   . </p><br><p>     ‚Äî Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  Le reste </h3><br><p>      .  , ‚Ä¶    <code>root</code> . </p><br><p>  Ici: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  ‚Ä¶  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> ‚Äî  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="That's all folks!"></p><br><h2 id="rezultaty">  R√©sultats </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    ‚Äî  ,       . </p><br><p> -,   ,  ,            ‚Äî .  ,        skip list  interval tree,     ‚Äî , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     ‚Äî   . </p><br><p>   ,  ,        ‚Äî    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446558/">https://habr.com/ru/post/fr446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446546/index.html">Microsoft √©tend Azure IP Advantage avec de nouveaux avantages IP pour les innovateurs et les startups Azure IoT</a></li>
<li><a href="../fr446548/index.html">Analyse des statistiques sur les campagnes publicitaires - cr√©er une nouvelle m√©trique dans le DataFrame (python)</a></li>
<li><a href="../fr446550/index.html">Probl√®mes de mod√®le de coordinateur et qu'est-ce que RouteComposer a √† voir avec cela</a></li>
<li><a href="../fr446552/index.html">Utilisation des commandes APDU √† l'aide de l'exemple EToken</a></li>
<li><a href="../fr446554/index.html">Programme r√©sident Yandex, ou Comment un back-end exp√©riment√© devient ing√©nieur ML</a></li>
<li><a href="../fr446560/index.html">"Courtesy Exchange": l'essence du conflit entre les deux soci√©t√©s de streaming les plus c√©l√®bres</a></li>
<li><a href="../fr446562/index.html">Asynchronie dans la programmation</a></li>
<li><a href="../fr446566/index.html">Project Zero. Comment Amazon veut g√©rer les contrefa√ßons</a></li>
<li><a href="../fr446568/index.html">Mise √† jour CMS √† grande √©chelle d'Umbraco 8: Quoi de neuf</a></li>
<li><a href="../fr446570/index.html">L'histoire du premier GPU: Rendition V√©rit√© 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>