<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐰 🖖🏻 🎉 DMA: Mitos dan Realita 🚝 👇🏼 ⛴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Dalam artikel sebelumnya ( "Bagian 2: Menggunakan blok PSoC UDB Cypress untuk mengurangi jumlah interupsi dalam printer 3D" ), saya menc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DMA: Mitos dan Realita</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437112/"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  Pendahuluan </h2><br>  Dalam artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagian 2: Menggunakan blok PSoC UDB Cypress untuk mengurangi jumlah interupsi dalam printer 3D"</a> ), saya mencatat satu fakta yang sangat menarik: jika sebuah mesin di UDB menghapus data dari FIFO terlalu cepat, ia berhasil melihat keadaan bahwa ada yang baru tidak ada data di FIFO, setelah itu masuk ke kondisi false <b>Idle</b> .  Tentu saja, saya tertarik pada fakta ini.  Saya menunjukkan hasil yang terbuka kepada sekelompok kenalan.  Satu orang menjawab bahwa ini semua sangat jelas, dan bahkan menyebutkan alasannya.  Sisanya tidak kalah terkejutnya dengan saya di awal penelitian.  Jadi, beberapa ahli tidak akan menemukan sesuatu yang baru di sini, tetapi akan lebih baik untuk membawa informasi ini kepada masyarakat umum sehingga semua programmer untuk mikrokontroler memilikinya. <br><a name="habracut"></a><br>  Bukan berarti itu adalah semacam penutup.  Ternyata semua ini terdokumentasi dengan baik, tetapi masalahnya bukan di utama, tetapi di dokumen tambahan.  Dan secara pribadi, saya dalam ketidaktahuan bahagia, percaya bahwa DMA adalah subsistem yang sangat gesit yang dapat secara dramatis meningkatkan efisiensi program, karena ada transfer data yang sistematis tanpa mengganggu kenaikan register dan mengatur siklus ke perintah yang sama.  Adapun meningkatkan efisiensi - semuanya benar, tetapi karena hal-hal yang sedikit berbeda. <br><br>  Tetapi hal pertama yang pertama. <br><br><h2>  Eksperimen dengan Cypress PSoC </h2><br>  Mari kita membuat mesin sederhana.  Secara kondisional akan memiliki dua status: status siaga dan status akan jatuh ke dalamnya ketika setidaknya ada satu byte data di FIFO.  Memasuki kondisi ini, ia hanya akan mengambil data ini, dan sekali lagi gagal dalam keadaan istirahat.  Kata "kondisional" tidak saya kutip tanpa sengaja.  Kami memiliki dua FIFO, jadi saya akan membuat dua keadaan seperti itu, satu untuk setiap FIFO, untuk memastikan bahwa mereka benar-benar identik dalam perilaku.  Grafik transisi untuk mesin ternyata seperti ini: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Bendera untuk keluar dari kondisi Idle didefinisikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  Jangan lupa untuk mengirimkan bit dari nomor status ke input Datapath: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  Untuk bagian luar kami menampilkan dua kelompok sinyal: sepasang sinyal yang FIFO memiliki ruang kosong (sehingga DMA dapat mulai mengunggah data ke mereka), dan beberapa sinyal bahwa FIFO kosong (untuk menampilkan fakta ini pada osiloskop). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  ALU akan secara fiktif mengambil data dari FIFO: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  Biarkan saya menunjukkan kepada Anda rincian untuk negara “0001”: <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  Saya juga mengatur lebar bus, yang ada di proyek di mana saya perhatikan efek ini, 16 bit: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  Kami lolos ke skema proyek itu sendiri.  Dari luar, saya memberikan tidak hanya sinyal bahwa FIFO kosong, tetapi juga pulsa clock.  Ini akan memungkinkan saya melakukannya tanpa pengukuran kursor pada osiloskop.  Saya hanya bisa mengambil tindakan dengan jari saya. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  Ternyata, saya membuat kecepatan clock 24 megahertz.  Frekuensi inti prosesor persis sama.  Semakin rendah frekuensinya, semakin sedikit gangguan yang ada pada osiloskop Cina (secara resmi memiliki pita 250 MHz, tetapi kemudian megahertz Cina), dan semua pengukuran akan dilakukan sehubungan dengan pulsa clock.  Apa pun frekuensinya, sistem akan tetap bekerja sehubungan dengan mereka.  Saya akan menetapkan satu megahertz, tetapi lingkungan pengembangan melarang saya untuk memasukkan nilai frekuensi inti prosesor kurang dari 24 MHz. <br><br>  Sekarang soal tes.  Untuk menulis ke FIFO0, saya membuat fungsi ini: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre> <br>  Kata ROM dalam nama fungsi disebabkan oleh fakta bahwa array yang akan dikirim disimpan di area ROM, dan Cortex M3 memiliki arsitektur Harvard.  Kecepatan akses ke bus RAM dan bus ROM dapat bervariasi, saya ingin memeriksanya, jadi saya memiliki fungsi yang sama untuk mengirim array dari RAM (array <b>langkah</b> tidak memiliki pengubah <b>konstanta statis</b> di tubuhnya).  Nah, ada pasangan fungsi yang sama untuk mengirim ke FIFO1, register penerima berbeda di sana: bukan F0, tetapi F1.  Jika tidak, semua fungsi identik.  Karena saya tidak melihat banyak perbedaan dalam hasil, saya akan mempertimbangkan hasil memanggil persis fungsi di atas.  Sinar kuning - pulsa clock, biru - output <b>FIFO0empty</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  Pertama, periksa masuk akal mengapa FIFO diisi selama dua siklus clock.  Mari kita lihat situs ini lebih terinci: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  Di tepi 1, data jatuh ke FIFO, bendera <b>FIFO0enmpty</b> turun.  Di tepi 2, otomat memasuki kondisi <b>GetDataFromFifo1</b> .  Pada tepi 3, dalam keadaan ini, data dari FIFO disalin ke register ALU, FIFO dikosongkan, bendera kosong FIFO <b>dinaikkan</b> lagi.  Artinya, bentuk gelombang berperilaku masuk akal, Anda dapat mengandalkannya pada siklus jam.  Kami mendapat 9 buah. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>Secara total, di area yang diinspeksi, dibutuhkan 9 siklus clock untuk menyalin satu kata data dari RAM ke UDB menggunakan DMA.</b> <br><br>  Dan sekarang sama, tetapi dengan bantuan inti prosesor.  Pertama, kode ideal yang sulit dicapai dalam kehidupan nyata: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  apa yang akan berubah menjadi kode rakitan: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  Tidak ada istirahat, tidak ada siklus tambahan.  Dua pasang tindakan berturut-turut ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Mari kita buat kode sedikit lebih nyata (dengan overhead mengatur siklus, mengambil data dan menambah pointer): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  menerima kode assembler: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  Pada osilogram kita hanya melihat 7 siklus per siklus versus sembilan dalam kasus DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Sedikit tentang mitos </h2><br>  Sejujurnya, bagi saya itu awalnya mengejutkan.  Entah bagaimana saya dulu percaya bahwa mekanisme DMA memungkinkan Anda mentransfer data dengan cepat dan efisien.  1/9 dari frekuensi bus tidak secepat itu.  Tapi ternyata tidak ada yang menyembunyikannya.  Dokumen TRM untuk PSoC 5LP bahkan berisi sejumlah pertimbangan teoretis, dan dokumen “AN84810 - PSoC 3 dan PSoC 5LP Advanced DMA Topics” menjelaskan secara terperinci proses mengakses DMA.  Latensi yang harus disalahkan.  Siklus pertukaran dengan bus membutuhkan sejumlah kutu.  Sebenarnya, langkah-langkah inilah yang memainkan peran menentukan dalam terjadinya penundaan.  Secara umum, tidak ada yang menyembunyikan apa pun, tetapi Anda perlu tahu ini. <br><br>  <b>Jika GPIF terkenal yang digunakan dalam FX2LP (arsitektur lain yang diproduksi oleh Cypress) tidak membatasi apa pun, maka di sini batas kecepatannya adalah karena latensi yang terjadi saat mengakses bus.</b> <br><br><h2>  Periksa DMA pada STM32 </h2><br>  Saya sangat terkesan sehingga saya memutuskan untuk melakukan percobaan pada STM32.  STM32F103 yang memiliki inti prosesor Cortex M3 yang sama diambil sebagai kelinci percobaan.  Tidak memiliki UDB dari mana sinyal layanan dapat diturunkan, tetapi sangat mungkin untuk memeriksa DMA.  Apa itu GPIO?  Ini adalah satu set register di ruang alamat umum.  Tidak apa-apa.  Kami mengkonfigurasi DMA dalam mode salin "memori-memori", menentukan memori nyata (ROM atau RAM) sebagai sumber, dan register data GPIO tanpa penambahan alamat sebagai penerima.  Kami akan mengirim ke sana secara bergantian 0 atau 1, dan memperbaiki hasilnya dengan osiloskop.  Untuk memulai, saya memilih port B, lebih mudah untuk menghubungkannya di papan tempat memotong roti. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  Saya sangat menikmati menghitung langkah dengan jari, bukan kursor.  Apakah mungkin untuk melakukan hal yang sama pada pengontrol ini?  Cukup!  Ambil frekuensi clock referensi untuk osiloskop dari kaki MCO, yang terhubung ke port PA8 pada STM32F10C8T6.  Pilihan sumber untuk kristal murah ini tidak besar (STM32F103 yang sama, tetapi lebih mengesankan, memberikan lebih banyak pilihan), kami akan mengirimkan sinyal SYSCLK ke output ini.  Karena frekuensi pada MCO tidak boleh lebih tinggi dari 50 MHz, kami akan mengurangi kecepatan jam sistem keseluruhan menjadi 48 MHz.  Kami akan mengalikan frekuensi kuarsa 8 MHz bukan dengan 9, tetapi dengan 6 (karena 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  Kami akan memprogram MCO menggunakan perpustakaan <b>mcucpp</b> dari Konstantin Chizhov (mulai sekarang saya akan melakukan semua panggilan ke peralatan melalui perpustakaan yang luar biasa ini): <br><br><pre> <code class="plaintext hljs"> //  MCO Mcucpp::Clock::McoBitField::Set (0x4); //   MCO    Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); //     Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Nah, sekarang kita atur output dari array data di GPIOB: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... //  GPIOB      dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; //    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // ,    DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  Bentuk gelombang yang dihasilkan sangat mirip dengan yang ada di PSoC. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  Di tengah adalah punuk biru besar.  Ini adalah proses inisialisasi DMA.  Pulsa biru di sebelah kiri diterima sepenuhnya oleh perangkat lunak pada PB1.  Regangkan mereka lebih lebar: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 langkah per pulsa.  Pengoperasian sistem seperti yang diharapkan.  Tapi sekarang mari kita lihat area yang lebih besar ditandai pada bentuk gelombang utama dengan latar belakang biru gelap.  Blok DMA sudah berjalan di lokasi ini. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 siklus per perubahan jalur GPIO.  Sebenarnya, pekerjaan berjalan dengan RAM, dan program ini dilingkarkan dalam siklus konstan.  Tidak ada panggilan ke RAM dari inti prosesor.  Bus sepenuhnya tersedia untuk unit DMA, tetapi 10 siklus.  Tetapi pada kenyataannya, hasilnya tidak jauh berbeda dari yang terlihat di PSoC, jadi mulailah mencari Catatan Aplikasi yang terkait dengan DMA di STM32.  Ada beberapa dari mereka.  Ada AN2548 di F0 / F1, ada AN3117 di L0 / L1 / L3, ada AN4031 di F2 / F4 / F77.  Mungkin ada lagi ... <br><br>  Tetapi, bagaimanapun, dari mereka kita melihat bahwa di sini juga, latensi yang harus disalahkan.  Selain itu, akses batch F103 ke bus dengan DMA tidak mungkin.  Mereka dimungkinkan untuk F4, tetapi tidak lebih dari empat kata.  Kemudian lagi masalah latensi akan muncul. <br><br>  Mari kita coba melakukan tindakan yang sama, tetapi dengan bantuan catatan program.  Di atas, kami melihat bahwa perekaman langsung ke port dilakukan secara instan.  Tapi ada catatan yang agak sempurna.  Baris: <br><br><pre> <code class="plaintext hljs">//    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  tunduk pada pengaturan optimasi tersebut (Anda harus menentukan optimasi untuk waktu): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  berubah menjadi kode assembler berikut: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  Dalam penyalinan nyata, akan ada panggilan ke sumber, ke penerima, perubahan dalam variabel loop, bercabang ... Secara umum, banyak overhead (yang, seperti yang diyakini, hanya menghilangkan DMA).  Berapa kecepatan perubahan di port?  Jadi, kami menulis: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Kode C ++ ini berubah menjadi kode rakitan seperti itu: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  Dan kita mendapatkan: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 langkah di setengah siklus atas dan 6 di bagian bawah (saya periksa, hasilnya diulang untuk semua setengah periode).  Perbedaan muncul karena pengoptimal membuat 2 salinan per iterasi.  Oleh karena itu, 2 langkah dalam salah satu setengah periode ditambahkan ke operasi cabang. <br><br>  <b>Secara kasar, dengan menyalin perangkat lunak, 14 langkah dihabiskan untuk menyalin dua kata terhadap 20 langkah yang sama, tetapi oleh DMA.</b>  <b>Hasilnya cukup terdokumentasi, tetapi sangat tidak terduga bagi mereka yang belum membaca literatur yang diperluas.</b> <br><br>  Bagus  Tetapi apa yang terjadi jika Anda mulai menulis data dalam dua aliran DMA sekaligus?  Berapa kecepatan jatuh?  Hubungkan blue ray ke PA0 dan tulis ulang program sebagai berikut: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Pertama, mari kita periksa sifat dari pulsa: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  Saat saluran kedua sedang dicari, kecepatan salin untuk yang pertama lebih tinggi.  Kemudian, saat menyalin berpasangan, kecepatan turun.  Ketika saluran pertama selesai, saluran kedua mulai bekerja lebih cepat.  Semuanya logis, tetap hanya untuk mengetahui dengan tepat berapa kecepatan turun. <br><br>  Meskipun hanya ada satu saluran, perekaman membutuhkan 10 hingga 12 tindakan (digit mengambang). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  Selama kolaborasi, kami mendapatkan 16 siklus per catatan di setiap port: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  Artinya, kecepatannya tidak terbelah dua.  Tetapi bagaimana jika Anda mulai menulis dalam tiga utas sekaligus?  Kami menambahkan pekerjaan dengan PC15, karena PC0 bukan output (itu sebabnya bukan 0, 1, 0, 1 ..., tetapi 0x0000,0x8001, 0x0000, 0x8001 ... dikeluarkan dalam larik). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Di sini hasilnya sangat tidak terduga sehingga saya mematikan balok yang menampilkan frekuensi jam.  Kami tidak punya waktu untuk pengukuran.  Kami melihat logika kerja. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  Sampai saluran pertama selesai bekerja, yang ketiga tidak mulai bekerja.  Tiga saluran sekaligus tidak berfungsi!  Sesuatu tentang topik ini dapat disimpulkan dari AppNote ke DMA, dikatakan bahwa F103 hanya memiliki dua Engine dalam satu blok (dan kami menyalin menggunakan satu blok DMA, yang kedua adalah idle sekarang, dan volume artikel sudah sedemikian sehingga saya dapat menggunakannya Saya tidak akan).  Kami menulis ulang program sampel sehingga saluran ketiga dimulai lebih awal dari yang lain: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Gambar akan berubah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  Saluran ketiga diluncurkan, bahkan bekerja sama dengan yang pertama, tetapi ketika yang kedua memasuki bisnis, yang ketiga digantikan sampai saluran pertama selesai. <br><br><h2>  Sedikit tentang prioritas </h2><br>  Sebenarnya, gambar sebelumnya terkait dengan prioritas DMA, ada beberapa.  Jika semua saluran yang berfungsi memiliki prioritas yang sama, jumlah mereka ikut bermain.  Dalam satu prioritas yang diberikan, yang memiliki jumlah lebih kecil adalah yang memiliki prioritas.  Mari kita coba saluran ketiga untuk menunjukkan prioritas global yang berbeda, menaikkannya di atas yang lain (sepanjang jalan, kami juga akan meningkatkan prioritas saluran kedua): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Sekarang yang pertama yang paling keren akan dirugikan. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  Secara total, kami melihat bahwa walaupun bermain dalam prioritas, STM32F103 tidak dapat meluncurkan lebih dari dua utas pada satu blok DMA.  Pada prinsipnya, thread ketiga dapat dijalankan pada inti prosesor.  Ini akan memungkinkan kami untuk membandingkan kinerja. <br><br><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Pertama, gambaran umum, yang menunjukkan bahwa semuanya bekerja secara paralel dan inti prosesor memiliki kecepatan penyalinan tertinggi: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  Dan sekarang saya akan memberikan semua orang kesempatan untuk menghitung langkah-langkah pada saat semua aliran salinan aktif: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  Inti prosesor memprioritaskan semua </h2><br>  Sekarang mari kita kembali ke fakta bahwa selama operasi dua-threaded, sementara saluran kedua disetel, yang pertama memberikan data untuk jumlah siklus clock yang berbeda.  Fakta ini juga didokumentasikan dengan baik di AppNote pada DMA.  Faktanya adalah bahwa selama pengaturan saluran kedua, permintaan untuk RAM dikirim secara berkala, dan inti prosesor memiliki prioritas lebih tinggi ketika mengakses RAM daripada inti DMA.  Ketika prosesor meminta beberapa data, DMA mengambil siklus clock, ia menerima data dengan penundaan, oleh karena itu, itu disalin lebih lambat.  Mari kita lakukan percobaan terakhir untuk hari ini.  Mari kita bawa pekerjaan ke yang lebih nyata.  Setelah memulai DMA, kami tidak akan masuk ke siklus kosong (ketika pasti tidak ada akses ke RAM), tetapi akan melakukan operasi penyalinan dari RAM ke RAM, tetapi operasi ini tidak akan berhubungan dengan operasi inti DMA: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  Di beberapa tempat, siklus tersebut membentang dari 16 hingga 17 langkah.  Saya takut itu akan menjadi lebih buruk. <br><br><h2>  Mulailah menggambar kesimpulan </h2><br>  Sebenarnya, kita beralih ke apa yang ingin saya katakan. <br><br>  Saya akan mulai dari jauh.  Beberapa tahun yang lalu, mulai mempelajari STM32, saya mempelajari versi MiddleWare untuk USB yang ada pada waktu itu dan bertanya-tanya mengapa pengembang menghapus transfer data melalui DMA.  Jelaslah bahwa pada awalnya pilihan semacam itu sudah terlihat, kemudian dipindahkan ke halaman belakang, dan pada akhirnya hanya ada dasar-dasar darinya.  Sekarang saya mulai curiga bahwa saya memahami pengembang. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama tentang UDB,</a> saya mengatakan bahwa meskipun UDB dapat bekerja dengan data paralel, tidak mungkin itu dapat menggantikan GPIF dengan dirinya sendiri, karena bus USB PSoC berjalan pada Kecepatan Penuh versus Kecepatan Tinggi untuk FX2LP.  Ternyata ada faktor pembatas yang lebih serius.  DMA sama sekali tidak punya waktu untuk mengirimkan data pada kecepatan yang sama dengan yang diberikan GPIF, bahkan di dalam pengontrol, tanpa memperhitungkan bus USB. <br><br>  Seperti yang Anda lihat, tidak ada DMA entitas tunggal.  Pertama, masing-masing produsen membuatnya dengan caranya sendiri.  Tidak hanya itu, bahkan satu produsen untuk keluarga yang berbeda dapat memvariasikan pendekatan untuk membangun DMA.  Jika Anda berencana untuk memuat unit ini dengan serius, Anda harus mempertimbangkan apakah kebutuhan akan terpenuhi. <br><br>  Mungkin, perlu untuk mengencerkan aliran pesimistis dengan satu komentar optimis.  Saya bahkan akan menyorotnya. <br><br>  <b>DMA dari pengendali Cortex M memungkinkan Anda untuk meningkatkan kinerja sistem berdasarkan prinsip Javelins yang terkenal: "Luncurkan dan lupakan."</b>  <b>Ya, menyalin data perangkat lunak sedikit lebih cepat.</b>  <b>Tetapi jika Anda perlu menyalin banyak utas, pengoptimal tidak dapat membuat prosesor menggerakkan semuanya tanpa overhead register yang memuat ulang dan memutar putaran.</b>  <b>Selain itu, untuk port yang lambat, prosesor masih harus menunggu ketersediaan, dan DMA melakukan ini di tingkat perangkat keras.</b> <br><br>  Tetapi bahkan di sini berbagai nuansa dimungkinkan.  Jika port hanya relatif lambat ... Nah, katakanlah, SPI beroperasi pada frekuensi setinggi mungkin, maka ada situasi yang secara teoritis memungkinkan ketika DMA tidak punya waktu untuk mengumpulkan data dari buffer dan terjadi luapan.  Atau sebaliknya - letakkan data dalam register buffer.  Ketika aliran data tunggal, ini tidak mungkin terjadi, tetapi ketika ada banyak dari mereka, kami melihat apa yang bisa terjadi overlay menakjubkan.  Untuk mengatasinya, Anda harus mengembangkan tugas tidak secara terpisah, tetapi dalam kombinasi.  Dan penguji mencoba untuk memprovokasi masalah seperti itu (seperti pekerjaan yang merusak bagi penguji). <br><br>  Sekali lagi, tidak ada yang menyembunyikan data ini.  Tetapi untuk beberapa alasan, semua ini biasanya tidak terdapat dalam dokumen utama, tetapi dalam Catatan Aplikasi.  Jadi tugas saya adalah untuk menarik perhatian programmer ke fakta bahwa DMA bukanlah obat mujarab, tetapi hanya alat yang nyaman. <br><br>  Tapi, tentu saja, tidak hanya programmer, tetapi juga pengembang perangkat keras.  Katakanlah, di organisasi kami, kompleks perangkat lunak dan perangkat keras yang besar sedang dikembangkan untuk debugging jarak jauh dari sistem tertanam.  Idenya adalah seseorang sedang mengembangkan perangkat, tetapi ingin memesan "firmware" di samping.  Dan untuk beberapa alasan, tidak bisa menyediakan peralatan ke samping.  Itu bisa sangat besar, bisa mahal, bisa unik dan “membutuhkannya sendiri”, kelompok yang berbeda dapat bekerja dengannya dalam zona waktu yang berbeda, menyediakan semacam pekerjaan multi-shift, dapat selalu diingat ... Secara umum, Anda dapat menemukan alasan banyak, kelompok kami membiarkan tugas ini begitu saja. <br><br>  Dengan demikian, kompleks debugging harus dapat mensimulasikan sebanyak mungkin perangkat eksternal, dari simulasi sepele dari penekanan tombol ke berbagai protokol SPI, I2C, CAN, 4-20 mA dan lainnya, hal-hal lain, sehingga melalui mereka emulator dapat menciptakan kembali perilaku eksternal yang berbeda. blok yang terhubung ke peralatan yang sedang dikembangkan (saya pribadi pada suatu waktu membuat banyak simulator untuk debugging ground attachment untuk helikopter, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kasus yang sesuai dicari dengan kata Cassel Aero</a> ). <br><br>  Jadi, dalam persyaratan teknis untuk pengembangan persyaratan tertentu.  Begitu banyak SPI, begitu banyak I2C, begitu banyak GPIO.  Mereka harus beroperasi pada frekuensi ekstrim ini dan itu.  Segalanya tampak jelas.  Kami menempatkan STM32F4 dan ULPI untuk bekerja dengan USB dalam mode HS.  Teknologi ini terbukti.  Tapi di sinilah akhir pekan yang panjang dengan liburan November, yang saya temukan bersama UDB.  Melihat ada yang tidak beres, di malam hari saya mendapat hasil praktis yang diberikan di awal artikel ini.  Dan saya menyadari bahwa semuanya, tentu saja, bagus, tetapi tidak untuk proyek ini.  Seperti yang telah saya catat, ketika kinerja sistem puncak yang mungkin mendekati batas atas, semuanya harus dirancang tidak secara terpisah, tetapi dalam kompleks. <br><br>  Tapi di sini desain tugas yang terintegrasi tidak bisa pada prinsipnya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hari ini kami bekerja dengan satu peralatan pihak ketiga, besok - dengan sangat berbeda. Bus akan digunakan oleh programmer untuk setiap kasus emulasi sesuai kebijakan mereka. Oleh karena itu, opsi ditolak, sejumlah jembatan FTDI berbeda ditambahkan ke sirkuit. Di dalam bridge, satu, dua atau empat fungsi akan diselesaikan sesuai dengan skema yang kaku, dan di antara bridge-host USB host akan menyelesaikan semuanya.</font></font> Sayang<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam tugas ini, saya tidak bisa mempercayai DMA. </font><font style="vertical-align: inherit;">Anda dapat, tentu saja, mengatakan bahwa programmer kemudian akan keluar, tetapi jam untuk proses trik adalah biaya tenaga kerja yang harus dihindari. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi ini ekstrem. </font><font style="vertical-align: inherit;">Paling sering, Anda hanya perlu mengingat keterbatasan subsistem DMA (misalnya, memperkenalkan faktor koreksi 10: jika Anda memerlukan aliran 1 juta transaksi per detik, pertimbangkan bahwa ini bukan 1 juta, tetapi 10 juta siklus) dan pertimbangkan kinerja dalam kombinasi.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437112/">https://habr.com/ru/post/id437112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437102/index.html">Pertemuan Lego Champion Baru: Lego Boost</a></li>
<li><a href="../id437104/index.html">Introscope: baik, unit pengujian sangat malas</a></li>
<li><a href="../id437106/index.html">IT di zona .it</a></li>
<li><a href="../id437108/index.html">Sebagian besar teks di Internet ditulis oleh orang gila.</a></li>
<li><a href="../id437110/index.html">Nanomaterial mengubah dunia kita, dan kita masih belum memiliki prosedur untuk memeriksa keamanannya</a></li>
<li><a href="../id437114/index.html">Buka webinar: "SSH / NC / Socat: tips & trik"</a></li>
<li><a href="../id437116/index.html">AWS, MongoDB, dan realitas ekonomi open source</a></li>
<li><a href="../id437118/index.html">AI dan 2048. Bagian 1: Metode Monte Carlo</a></li>
<li><a href="../id437120/index.html">Kursi kantor Korea: Sensasi Keajaiban Harachair</a></li>
<li><a href="../id437122/index.html">Memberi nama benda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>