<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 👋🏻 🐓 Erstellen Sie ein einfaches neuronales Netzwerk ⛲️ 🚂 📳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Übersetzung eines einfachen neuronalen Netzes 

 Was werden wir tun? Wir werden versuchen, ein einfaches und sehr kleines neuronales Netzwerk zu erste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie ein einfaches neuronales Netzwerk</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/423647/"><img src="https://habrastorage.org/webt/ac/tt/kj/acttkjv76eyz3ban4o0lroam6i0.jpeg"><br><br>  <i>Übersetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eines einfachen neuronalen Netzes</a></i> <br><br>  Was werden wir tun?  Wir werden versuchen, ein einfaches und sehr kleines neuronales Netzwerk zu erstellen, das wir Ihnen <b>erklären</b> und <b>beibringen werden</b> , etwas zu unterscheiden.  Gleichzeitig werden wir nicht in die Geschichte und den mathematischen Dschungel gehen (solche Informationen sind sehr leicht zu finden) - stattdessen werden wir versuchen, Ihnen und uns selbst das Problem (nicht die Tatsache, dass es möglich sein wird) mit Zeichnungen und Code zu erklären. <br><a name="habracut"></a><br>  Viele der Begriffe in neuronalen Netzen beziehen sich auf die Biologie. Beginnen wir also von vorne: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/894/2ca/932/8942ca932bbcae69fa905d941a0986c4.png"><br>  Das Gehirn ist eine komplizierte Sache, kann aber auch in mehrere Hauptteile und Operationen unterteilt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/70c/3dc/a9d70c3dc81c6ee4987be8808c442b9c.png"><br><br>  Der Erreger kann auch <b>intern sein</b> (z. B. ein Bild oder eine Idee): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/070/0c3/85a/0700c385ae4bd6581ccacfe3ee34df97.png"><br><br>  Schauen wir uns nun die grundlegenden und vereinfachten <b>Teile des</b> Gehirns an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/8a6/4df/f0e8a64df55c24fdf44bd7ee6a330c37.png"><br>  <i>Das Gehirn sieht im Allgemeinen wie ein Kabelnetz aus.</i> <br><br>  <b>Ein Neuron</b> ist die Haupteinheit des Kalküls im Gehirn, es empfängt und verarbeitet die chemischen Signale anderer Neuronen und erzeugt abhängig von einer Reihe von Faktoren entweder nichts oder erzeugt einen elektrischen Impuls oder ein Aktionspotential, das dann über Synapsen Signale an benachbarte <b>verbundene</b> Neuronen sendet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/946/b58/2c7/946b582c7606740ba399856e9a9b9682.png"><br><br>  Träume, Erinnerungen, selbstregulierende Bewegungen, Reflexe und alles, was Sie denken oder tun, sind auf diesen Prozess zurückzuführen: Millionen oder sogar Milliarden von Neuronen arbeiten auf verschiedenen Ebenen und stellen Verbindungen her, die verschiedene parallele Subsysteme bilden und ein biologisches neuronales <b>Netzwerk darstellen</b> . <br><br>  Natürlich sind dies alles Vereinfachungen und Verallgemeinerungen, aber dank ihnen können wir eine einfache beschreiben <br>  neuronales Netzwerk: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4c/1fa/0f5/b4c1fa0f54936c62cedf6670af34c410.png"><br><br>  Und beschreiben Sie es formal anhand des Diagramms: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/642/1db/8ab/6421db8ab21c127565d20728a72cf25a.png"><br><br>  Hier ist eine Klarstellung erforderlich.  Kreise sind Neuronen und Linien sind Verbindungen zwischen ihnen, <br>  und um dies in diesem Stadium nicht zu komplizieren, ist die <b>Beziehung</b> eine direkte Bewegung von Informationen <b>von links nach rechts</b> .  Das erste Neuron ist derzeit aktiv und ausgegraut.  Wir haben ihm auch eine Nummer zugewiesen (1 - wenn es funktioniert, 0 - wenn nicht).  Die Zahlen zwischen Neuronen geben das <b>Gewicht der</b> Verbindung an. <br><br>  Die obigen Grafiken zeigen den Zeitpunkt des Netzwerks. Für eine genauere Anzeige müssen Sie ihn in Zeiträume unterteilen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daf/6cc/b7b/daf6ccb7ba582e13f2a1acf9bb1c56f6.png"></div><br><br>  Um Ihr eigenes neuronales Netzwerk zu erstellen, müssen Sie verstehen, wie sich Gewichte auf Neuronen auswirken und wie Neuronen trainiert werden.  Nehmen Sie als Beispiel ein Kaninchen (Testkaninchen) und setzen Sie es unter die Bedingungen eines klassischen Experiments. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a78/51c/9d1/a7851c9d12bddb08627ecd7b8c695d81.png"><br><br>  Wenn ein sicherer Luftstrom auf sie gerichtet ist, blinken Kaninchen wie Menschen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a84/bda/606/a84bda606848164e1e4525d29ea111cb.png"><br><br>  Dieses Verhaltensmodell kann grafisch dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c6/0f0/484/1c60f04842b60cb027019b4154ae43ee.png"><br><br>  Wie im vorherigen Diagramm zeigen diese Grafiken nur den Moment, in dem das Kaninchen einen Atemzug spürt, und auf diese Weise <b>codieren</b> wir <b>den</b> Schlag als logischen Wert.  Zusätzlich berechnen wir anhand des Gewichtswerts, ob das zweite Neuron ausgelöst wird.  Wenn es 1 ist, dann wird das sensorische Neuron ausgelöst, wir blinken;  Wenn das Gewicht weniger als 1 beträgt, blinken wir nicht: Das zweite Neuron hat eine <b>Grenze von</b> 1. <br><br>  Wir führen ein weiteres Element ein - ein sicheres Tonsignal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/364/be7/436/364be743605b4a8ceff1b7e9c64304c0.png"><br><br>  Wir können das Interesse eines Kaninchens wie folgt modellieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db2/8c3/c4b/db28c3c4bbff5a1f7d782c2589748e22.png"><br><br>  Der Hauptunterschied besteht darin, dass das Gewicht jetzt <b>Null ist</b> , so dass wir zumindest vorerst kein blinkendes Kaninchen erhalten haben.  Bringen Sie nun dem Kaninchen bei, im Team zu blinken und zu mischen <br>  Reizstoffe (Tonsignal und Atem): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/396/a91/5cc/396a915cc38d2215dde0d7a30639ed49.png"><br><br>  Es ist wichtig, dass diese Ereignisse in unterschiedlichen <b>Zeiträumen auftreten</b> . In Diagrammen sieht dies folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b6/a90/d38/6b6a90d3846b88fb71cbc77160076785.png"><br><br>  Der Ton selbst macht nichts, aber der Luftstrom lässt das Kaninchen immer noch blinken, und wir zeigen dies durch Gewichte multipliziert mit den Reizen (rot). <br><br>  <b>Das Erlernen</b> komplexer Verhaltensweisen kann vereinfacht als allmähliche Gewichtsänderung zwischen verbundenen Neuronen im Laufe der Zeit ausgedrückt werden. <br><br>  Wiederholen Sie die Schritte, um das Kaninchen zu trainieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/291/a8c/762/291a8c76287ca4f3c2724a5f94760f1e.png"><br><br>  Bei den ersten drei Versuchen sehen die Schemata folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c42/e46/98c/c42e4698c4b1e0efc2a2ded0a5ee8b60.png"><br><br>  Beachten Sie, dass das Gewicht für den Schallreiz nach jeder Wiederholung zunimmt (rot hervorgehoben). Dieser Wert ist jetzt beliebig - wir haben 0,30 gewählt, aber die Zahl kann beliebig sein, auch negativ.  Nach der dritten Wiederholung werden Sie keine Änderung im Verhalten des Kaninchens bemerken, aber nach der vierten Wiederholung wird etwas Überraschendes passieren - das Verhalten wird sich ändern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbc/787/122/fbc7871226276d67bad346023bed3b32.png"><br><br>  Wir haben den Effekt aus der Luft entfernt, aber der Hase blinkt immer noch, als er einen Piepton hörte!  Dieses letzte Verhalten kann dieses Verhalten erklären: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e31/559/8cf/e315598cf6e3413cfbd72a1043ff07e5.png"><br><br>  Wir haben das Kaninchen trainiert, auf Geräusche durch Blinken zu reagieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/126/fe8/3ad126fe866c4fcac73f4f6eee588c20.png"><br>  <i>In einem realen Experiment dieser Art können mehr als 60 Wiederholungen erforderlich sein, um ein Ergebnis zu erzielen.</i> <br><br>  Jetzt werden wir die biologische Welt des Gehirns und der Kaninchen verlassen und versuchen, alles daran anzupassen <br>  lernte ein künstliches neuronales Netzwerk zu schaffen.  Versuchen wir zunächst, eine einfache Aufgabe zu erledigen. <br><br>  Nehmen wir an, wir haben eine Maschine mit vier Knöpfen, die Essen ausgibt, wenn Sie rechts drücken <br>  Tasten (gut, oder Energie, wenn Sie ein Roboter sind).  Die Aufgabe besteht darin herauszufinden, welcher Knopf die Belohnung gibt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ea/32b/83c/2ea32b83cc7f0a696d1f5b47dd42a1f0.png"><br><br>  Wir können (schematisch) wie folgt darstellen, was die Schaltfläche beim Klicken bewirkt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/771/f53/53c/771f5353cbf9ded96ece3c9c807243b9.png"><br><br>  Dieses Problem lässt sich am besten in seiner Gesamtheit lösen. Schauen wir uns also alle möglichen Ergebnisse an, einschließlich der richtigen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/928/588/b8b/928588b8b7f455775659cbd0e611061d.png"><br>  <i>Drücken Sie die 3. Taste, um Ihr Abendessen zu erhalten.</i> <br><br>  Um ein neuronales Netzwerk im Code zu reproduzieren, müssen wir zuerst ein Modell oder einen Graphen erstellen, mit dem das Netzwerk verknüpft werden kann.  Hier ist ein Diagramm, das für die Aufgabe geeignet ist. Außerdem zeigt es sein biologisches Gegenstück gut an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7bd/d7e/008/7bdd7e0083616476b74edbc2ca4d6961.png"><br><br>  Dieses neuronale Netzwerk empfängt nur eingehende Informationen - in diesem Fall ist es die Wahrnehmung, welche Taste gedrückt wurde.  Ferner ersetzt das Netzwerk die eingehenden Informationen durch Gewichte und zieht eine Schlussfolgerung basierend auf dem Hinzufügen einer Schicht.  Es klingt etwas verwirrend, aber lassen Sie uns sehen, wie die Schaltfläche in unserem Modell dargestellt wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/512/69e/c23/51269ec23b57cea2b96121da45437515.png"><br>  <i>Beachten Sie, dass alle Gewichte 0 sind, sodass das neuronale Netzwerk wie ein Säugling vollständig leer, aber vollständig miteinander verbunden ist.</i> <br><br>  Daher vergleichen wir das externe Ereignis mit der Eingangsschicht des neuronalen Netzwerks und berechnen den Wert an seiner Ausgabe.  Es kann mit der Realität übereinstimmen oder auch nicht, aber im Moment werden wir es ignorieren und beginnen, die Aufgabe auf computerfreundliche Weise zu beschreiben.  Beginnen wir mit der Eingabe von Gewichten (wir werden JavaScript verwenden): <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputs = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weights = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre> <br>  Der nächste Schritt besteht darin, eine Funktion zu erstellen, die Eingabewerte und Gewichte sammelt und den Wert am Ausgang berechnet: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluateNeuralNetwork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputVector, weightVector</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; inputVector.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputValue, weightIndex</span></span></span><span class="hljs-function">) </span></span>{ layerValue = inputValue*weightVector[weightIndex]; result += layerValue; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result.toFixed(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-comment"><span class="hljs-comment">//   ,  ,    —    /   </span></span></code> </pre> <br>  Wenn wir diesen Code ausführen, erhalten wir erwartungsgemäß das gleiche Ergebnis wie in unserem Modell oder Diagramm ... <br><br><pre> <code class="javascript hljs">evaluateNeuralNetwork(inputs, weights); <span class="hljs-comment"><span class="hljs-comment">// 0.00</span></span></code> </pre> <br>  Live-Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuronales Netz 001</a> . <br><br>  Der nächste Schritt zur Verbesserung unseres neuronalen Netzwerks besteht darin, die eigenen Ausgabe- oder Ergebniswerte zu überprüfen, die mit der tatsächlichen Situation vergleichbar sind. <br>  Lassen Sie uns zuerst diese besondere Realität in eine Variable kodieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f98/7ca/0cc/f987ca0cce416afcb2e1e5a2293f570c.png"><br><br>  Um Inkonsistenzen (und wie viele) zu erkennen, fügen wir eine Fehlerfunktion hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> = Reality - Neural Net Output</code> </pre> <br>  Damit können wir die Leistung unseres neuronalen Netzwerks bewerten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52f/0d1/a5b/52f0d1a5bf44f21b12259e8f71cbb723.png"><br><br>  Aber was ist noch wichtiger mit Situationen, in denen die Realität ein positives Ergebnis liefert? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/270/ef9/da1/270ef9da17dd3b36b9133f82982ebf91.png"><br><br>  Jetzt wissen wir, dass unser neuronales Netzwerkmodell nicht funktioniert (und wir wissen, wie viel), großartig!  Das ist großartig, weil wir jetzt die Fehlerfunktion verwenden können, um unser Lernen zu steuern.  All dies ist jedoch sinnvoll, wenn wir die Fehlerfunktion wie folgt neu definieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> = <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Desired Output</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> - Neural Net Output</code> </pre> <br>  Eine schwer fassbare, aber so wichtige Diskrepanz, die stillschweigend zeigt, dass wir es tun werden <br>  Verwenden Sie zuvor erhaltene Ergebnisse, um sie mit zukünftigen Aktionen zu vergleichen <br>  (und für das Training, wie wir später sehen werden).  Es existiert im wirklichen Leben, voll von <br>  Muster wiederholen, so dass es eine evolutionäre Strategie werden kann (na ja, in <br>  die meisten Fälle). <br><br>  Als nächstes fügen wir in unserem Beispielcode eine neue Variable hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weights = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredResult = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Und eine neue Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluateNeuralNetError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">desired,actual</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (desired — actual); } <span class="hljs-comment"><span class="hljs-comment">// After evaluating both the Network and the Error we would get: // "Neural Net output: 0.00 Error: 1"</span></span></code> </pre> <br>  Live-Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuronales Netz 002</a> . <br><br>  <b>Um die Zwischensumme zusammenzufassen</b> .  Wir haben mit der Aufgabe begonnen, ihr einfaches Modell in Form eines biologischen neuronalen Netzwerks erstellt und eine Möglichkeit gefunden, seine Leistung im Vergleich zur Realität oder zum gewünschten Ergebnis zu messen.  Jetzt müssen wir einen Weg finden, um die Diskrepanz zu korrigieren - ein Prozess, der als Schulung für Computer und Menschen angesehen werden kann. <br><br>  <b>Wie trainiere ich ein neuronales Netzwerk?</b> <br><br>  Die Grundlage für das Unterrichten sowohl biologischer als auch künstlicher neuronaler Netze ist die Wiederholung <br>  und <b>Trainingsalgorithmen</b> , daher werden wir separat mit ihnen arbeiten.  Beginnen Sie mit <br>  Lernalgorithmen. <br><br>  In der Natur werden Lernalgorithmen als Änderungen der physikalischen oder chemischen Eigenschaften verstanden <br>  Eigenschaften von Neuronen nach Experimenten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28f/064/15d/28f06415d6cbefd3c2c68bc23670e847.png"><br><br>  Ein dramatisches Beispiel dafür, wie sich zwei Neuronen im Code im Laufe der Zeit ändern, und unser Modell „Lernalgorithmus“ bedeuten, dass wir im Laufe der Zeit nur etwas ändern, um unser Leben einfacher zu machen.  Fügen wir daher eine Variable hinzu, um den Grad der Erleichterung des Lebens anzugeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> learningRate = <span class="hljs-number"><span class="hljs-number">0.20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,      :)</span></span></code> </pre> <br>  <b>Und was wird sich ändern?</b> <br><br>  Dies ändert das Gewicht (genau wie bei einem Kaninchen!), Insbesondere das Gewicht der Ausgabe, die wir wollen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/6ee/f16/17a6eef16de58a4aaa856d4361c06284.png"><br><br>  Wie Sie einen solchen Algorithmus codieren, ist Ihre Wahl. Der Einfachheit halber addiere ich den Trainingskoeffizienten zum Gewicht, hier in Form einer Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">learn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputVector, weightVector</span></span></span><span class="hljs-function">) </span></span>{ weightVector.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weight, index, weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inputVector[index] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { weights[index] = weight + learningRate; } }); }</code> </pre> <br>  Bei Verwendung dieser Lernfunktion wird einfach unser Lernkoeffizient zum Gewichtsvektor des <b>aktiven Neurons</b> addiert. Vor und nach dem Trainingskreis (oder der Wiederholung) sind die Ergebnisse wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Original weight vector: [0,0,0,0] // Neural Net output: 0.00 Error: 1 learn(input, weights); // New Weight vector: [0,0.20,0,0] // Neural Net output: 0.20 Error: 0.8 //    ,      1 ( ) — ,    ,    ,      </span></span></code> </pre> <br>  Live-Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuronales Netz 003</a> . <br><br>  Okay, jetzt, da wir uns in die richtige Richtung bewegen, wird das letzte Detail dieses Puzzles die Einführung von <b>Wiederholungen sein</b> . <br><br>  Es ist nicht so schwierig, in der Natur machen wir immer wieder dasselbe und im Code geben wir nur die Anzahl der Wiederholungen an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trials = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Und die Einführung der Funktion der Anzahl der Wiederholungen in unser neuronales Trainingsnetzwerk wird folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trials</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; trials; i++) { neuralNetResult = evaluateNeuralNetwork(input, weights); learn(input, weights); } }</code> </pre> <br>  Nun, unser Abschlussbericht: <br><br><pre> <code class="javascript hljs">Neural Net output: <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">1.00</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] Neural Net output: <span class="hljs-number"><span class="hljs-number">0.20</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">0.80</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] Neural Net output: <span class="hljs-number"><span class="hljs-number">0.40</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">0.60</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] Neural Net output: <span class="hljs-number"><span class="hljs-number">0.60</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">0.40</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] Neural Net output: <span class="hljs-number"><span class="hljs-number">0.80</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">0.20</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] Neural Net output: <span class="hljs-number"><span class="hljs-number">1.00</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: <span class="hljs-number"><span class="hljs-number">0.00</span></span> Weight Vector: [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">// Chicken Dinner !</span></span></code> </pre> <br>  Live-Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuronales Netz 004</a> . <br><br>  Jetzt haben wir einen Gewichtsvektor, der nur ein Ergebnis liefert (Huhn zum Abendessen), wenn der Eingabevektor der Realität entspricht (Drücken der dritten Taste). <br><br>  <b>Was ist so cool, was wir gerade gemacht haben?</b> <br><br>  In diesem speziellen Fall kann unser neuronales Netzwerk (nach dem Training) die Eingabedaten erkennen und sagen, was zum gewünschten Ergebnis führt (wir müssen noch bestimmte Situationen programmieren): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/497/2ab/de2/4972abde2828a4bbe83505eaf2ace1f2.png"><br><br>  Darüber hinaus ist es ein skalierbares Modell, Spielzeug und Werkzeug für unser Training.  Wir konnten etwas Neues über maschinelles Lernen, neuronale Netze und künstliche Intelligenz lernen. <br><br>  Achtung für Benutzer: <br><br><ul><li>  Ein Speichermechanismus für die untersuchten Skalen ist nicht vorgesehen, sodass dieses neuronale Netzwerk alles vergisst, was es weiß.  Wenn Sie den Code aktualisieren oder neu starten, benötigen Sie mindestens sechs erfolgreiche Wiederholungsversuche, damit das Netzwerk vollständig geschult ist, wenn Sie der Meinung sind, dass eine Person oder ein Computer zufällig Tasten drückt ... Dies dauert einige Zeit. <br></li><li>  Biologische Netzwerke zum Lernen wichtiger Dinge haben eine Lerngeschwindigkeit von 1, sodass Sie nur eine erfolgreiche Wiederholung benötigen. <br></li><li>  Es gibt einen Lernalgorithmus, der biologischen Neuronen sehr ähnlich ist. Er hat einen eingängigen Namen: <b>Widroff-Hoff-Regel</b> oder <b>Widroff-Hoff-Training</b> . <br></li><li>  Schwellenwerte von Neuronen (1 in unserem Beispiel) und die Auswirkungen der Umschulung (bei einer großen Anzahl von Wiederholungen beträgt das Ergebnis mehr als 1) werden nicht berücksichtigt, sind jedoch von Natur aus sehr wichtig und für große und komplexe Blöcke von Verhaltensreaktionen verantwortlich.  Wie negative Gewichte. <br></li></ul><br><h2>  Hinweise und Referenzen zur weiteren Lektüre </h2><br>  Ich habe versucht, Mathematik und strenge Begriffe zu vermeiden, aber wenn Sie interessiert sind, haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perzeptron erstellt</a> , das als Algorithmus für das überwachte Lernen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lehren mit einem Lehrer</a> ) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doppelklassifikatoren definiert ist</a> - eine schwierige Sache. <br><br>  Die biologische Struktur des Gehirns ist kein einfaches Thema, teils wegen Ungenauigkeit, teils wegen seiner Komplexität.  Beginnen Sie am besten mit Neurowissenschaften (Purves) und kognitiven Neurowissenschaften (Gazzaniga).  Ich habe das Kaninchenbeispiel von Gateway to Memory (Gluck) modifiziert und angepasst, das auch eine großartige Anleitung für die Graphwelt ist. <br><br>  Eine weitere großartige Ressource, Eine Einführung in neuronale Netze (Gurney), ist für alle Ihre AI-bezogenen Anforderungen geeignet. <br><br>  Und jetzt in Python!  Vielen Dank an Ilya Andschmidt für die bereitgestellte Python-Version: <br><br><pre> <code class="python hljs">inputs = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] weights = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] desired_result = <span class="hljs-number"><span class="hljs-number">1</span></span> learning_rate = <span class="hljs-number"><span class="hljs-number">0.2</span></span> trials = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate_neural_network</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_array, weight_array)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(input_array)): layer_value = input_array[i] * weight_array[i] result += layer_value print(<span class="hljs-string"><span class="hljs-string">"evaluate_neural_network: "</span></span> + str(result)) print(<span class="hljs-string"><span class="hljs-string">"weights: "</span></span> + str(weights)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate_error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(desired, actual)</span></span></span><span class="hljs-function">:</span></span> error = desired - actual print(<span class="hljs-string"><span class="hljs-string">"evaluate_error: "</span></span> + str(error)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">learn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_array, weight_array)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"learning..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(input_array)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input_array[i] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: weight_array[i] += learning_rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trials)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(trials): neural_net_result = evaluate_neural_network(inputs, weights) learn(inputs, weights) train(trials)</code> </pre> <br>  Und jetzt auf GO!  Vielen Dank für diese Version von Kieran Maher. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"math"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Creating inputs and weights ..."</span></span>) inputs := []<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>{<span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">1.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>} weights := []<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>{<span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>} desired := <span class="hljs-number"><span class="hljs-number">1.00</span></span> learningRate := <span class="hljs-number"><span class="hljs-number">0.20</span></span> trials := <span class="hljs-number"><span class="hljs-number">6</span></span> train(trials, inputs, weights, desired, learningRate) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trials </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, inputs []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, weights []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, desired </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, learningRate </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; trials; i++ { weights = learn(inputs, weights, learningRate) output := evaluate(inputs, weights) errorResult := evaluateError(desired, output) fmt.Print(<span class="hljs-string"><span class="hljs-string">"Output: "</span></span>) fmt.Print(math.Round(output*<span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) fmt.Print(<span class="hljs-string"><span class="hljs-string">"\nError: "</span></span>) fmt.Print(math.Round(errorResult*<span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) fmt.Print(<span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">learn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inputVector []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, weightVector []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, learningRate </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, inputValue := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> inputVector { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inputValue &gt; <span class="hljs-number"><span class="hljs-number">0.00</span></span> { weightVector[index] = weightVector[index] + learningRate } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weightVector } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inputVector []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, weightVector []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { result := <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, inputValue := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> inputVector { layerValue := inputValue * weightVector[index] result = result + layerValue } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(desired </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, actual </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desired - actual }</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423647/">https://habr.com/ru/post/de423647/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423637/index.html">7 praktische Lektionen zu UX</a></li>
<li><a href="../de423639/index.html">Effizienteres Schreiben von Arrays in den dauerhaften Speicher eines intelligenten Vertrags in Solidity</a></li>
<li><a href="../de423641/index.html">Deep Learning und OpenVINO Toolkit. Intel Experten Antworten</a></li>
<li><a href="../de423643/index.html">Banken überwachen zunehmend die Reputation ihrer Kunden: Business Insider-Untersuchung</a></li>
<li><a href="../de423645/index.html">Wie wir der Luzhniki-IT-Infrastruktur während der Weltmeisterschaft gedient haben</a></li>
<li><a href="../de423651/index.html">Wir laden alle zum Hackathon SmartMail Hack: About Welcome ein</a></li>
<li><a href="../de423655/index.html">Generika + Frühling: Möge die Macht mit dir sein</a></li>
<li><a href="../de423657/index.html">Ich respektiere die Kapselung nicht oder verwende keine andere Art von Methodentabelle, um schnell private Methoden aufzurufen</a></li>
<li><a href="../de423663/index.html">Wir schreiben einen einfachen Übersetzer in Lisp - III</a></li>
<li><a href="../de423677/index.html">Jetpack-Piloten: Frankie West</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>