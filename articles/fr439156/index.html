<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üåÅ ü•ï t1ha = hachage positif rapide üí¢ ü§úüèº üíáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä peu pr√®s la fonction de hachage portable 64 bits la plus rapide avec une qualit√© d√©cente. 


 Il s'agit d'une traduction de l' article original de L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = hachage positif rapide</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  √Ä peu pr√®s la fonction de hachage portable 64 bits la plus rapide avec une qualit√© d√©cente. </p><br><p> Il s'agit d'une traduction de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Au lieu d'une clause de non-responsabilit√©</b> <div class="spoiler_text"><p>  Je vais omettre la d√©finition des fonctions de hachage ainsi que la liste d√©taill√©e des propri√©t√©s et des exigences de leur application cryptographique, et je suppose que le lecteur a les connaissances minimales n√©cessaires ou qu'il les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lira</a> .  Il convient √©galement de noter que je parlerai ci-apr√®s de fonctions de hachage non cryptographiques (ne conviennent pas √† la cryptographie), sauf indication contraire explicite. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalit√©s</b> <div class="spoiler_text"><p>  Le hachage est utilis√© dans de nombreux algorithmes, et presque toujours le traitement de donn√©es le plus efficace (rapide) est requis, avec un certain niveau minimum de qualit√© de hachage.  Ici, le terme ¬´qualit√©¬ª signifie tout d'abord une sorte de ¬´hasard¬ª (stochasticit√©) par rapport aux donn√©es initiales.  Un peu moins souvent, des exigences suppl√©mentaires sont impos√©es, telles que la r√©sistance √† la g√©n√©ration d√©lib√©r√©e de collisions ou l'irr√©versibilit√©. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pour √™tre un peu plus fastidieux</b> <div class="spoiler_text"><p>  Pour plus de clart√©, il est n√©cessaire de d√©finir un peu plus en d√©tail le concept de ¬´qualit√©¬ª de la fonction de hachage et le reste des exigences: <br>  Qualit√© de r√©f√©rence et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet d'avalanche</a> : la modification d'un ou plusieurs bits arbitraires dans un ensemble arbitraire de donn√©es source entra√Æne une modification de chaque bit du r√©sultat avec une probabilit√© de ¬Ω. </p><br><ul><li>  Irr√©versibilit√© ou premi√®re r√©sistance √† la pr√©-image: l'impossibilit√© d'obtenir les donn√©es originales ou les bits individuels du r√©sultat de hachage. </li><li>  R√©sistance aux collisions de premier ordre et / ou deuxi√®me r√©sistance √† la pr√©-image: la difficult√© de trouver / ajuster l'ensemble de donn√©es d'origine pour obtenir un r√©sultat sp√©cifi√© ou une partie de celui-ci, y compris lorsque l'ensemble de donn√©es initial est connu. </li><li>  R√©sistance aux collisions de second ordre: la difficult√© de trouver / ajuster deux ensembles de donn√©es diff√©rents qui donneraient le m√™me r√©sultat ou une correspondance d'une partie significative. </li></ul></div></div><br><p>  En omettant de longues citations des math√©matiques sous-jacentes, il peut √™tre r√©sum√©: </p><br><ul><li>  Satisfaire √† toutes les exigences ci-dessus tout en garantissant des performances √©lev√©es est un probl√®me assez difficile √† r√©soudre, ce qui nous donnerait une bonne fonction de hachage cryptographique.  Mais nous n'allons pas encore le faire. </li><li>  La fourniture d'une qualit√© de base n√©cessite un nombre suffisamment important d'op√©rations ALU.  En termes simples, la qualit√© est toujours compromise avec la vitesse. </li><li>  L'obtention d'un r√©sultat de haute qualit√© avec une largeur de bit sup√©rieure √† la largeur de bit des op√©rations ALU n√©cessite plus d'une multiplication par plusieurs du nombre de m√©langes, et donc des op√©rations ALU de base. </li><li>  En g√©n√©ral, la <em>cr√©ation d'une fonction de hachage rapide implique la r√©alisation d'un compromis pond√©r√© entre la vitesse, la qualit√© et le r√©sultat bitness</em> . </li></ul><br><p>  Par cons√©quent, je peux dire que <strong>t1ha</strong> est apparu √† la suite de la recherche d'un compromis entre la qualit√© et la vitesse, en tenant compte √† la fois des capacit√©s des processeurs modernes et des m√©thodes d√©j√† trouv√©es (combinaisons arithm√©tiques et logiques) de m√©lange et de propagation des d√©pendances ( effet avalanche). </p><br><p>  La version de base de <strong>t1ha</strong> est l'une des fonctions de hachage portables les plus rapides pour la construction de tables de hachage et d'autres applications connexes.  La version de base de <strong>t1ha</strong> se concentre sur les architectures little-endian 64 bits, prend une valeur de sel 64 bits (seed) et produit un r√©sultat 64 bits, qui comprend le renforcement par la longueur de cl√© et le seed.  Il convient de noter que <strong>t1ha</strong> est intentionnellement con√ßu pour renvoyer 0 pour des donn√©es d'entr√©e nulles (une cl√© de taille z√©ro et de z√©ro graine). </p><br><div class="spoiler">  <b class="spoiler_title">R√©pondre aux questions les plus fr√©quentes</b> <div class="spoiler_text"><p>  <strong>Op√©rations 64 bits</strong> : Il convient peut-√™tre de noter que ce sont les op√©rations 64 bits qui offrent vitesse et qualit√© sans nuire √† la portabilit√©.  En fait, plus la capacit√© num√©rique des op√©rations arithm√©tiques est large, plus elles produisent d'effet avalanche et mieux elles m√©langent les donn√©es.  De plus, le traitement des donn√©es, toutes choses √©tant √©gales par ailleurs, est certainement plus rapide de 8 octets que de 4. D'autre part, des op√©rations exactement 64 bits sont nativement disponibles sur de nombreux processeurs modernes et peuvent √™tre plus ou moins correctement traduites en 32- les petits.  Toutes les autres options, y compris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> op√©rations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SIMD</a> , nous obligent √† sacrifier consid√©rablement la portabilit√© et / ou la vitesse sur des plates-formes non natives. </p><br><p>  <strong>R√©sultat 64 bits</strong> : pour construire des tables de hachage, dans de nombreux cas, un r√©sultat de largeur de bit plus petit suffit.  M√™me 32 bits peuvent √™tre plus que suffisants.  Cependant, lorsque vous utilisez des op√©rations 64 bits, le r√©sultat 64 bits vient naturellement.  Dans le m√™me temps, un r√©sultat de hachage 64 bits de qualit√© suffisamment √©lev√©e vous permet d'effectuer rapidement une comparaison pour la non-√©galit√© et avec une bonne pr√©cision de comparer pour l'√©galit√©. </p><br><p>  La "magie" ci-dessus de remplacer les comparaisons peut sembler peu claire et inutile, ou elle peut <strong>augmenter la vitesse de hachage d'un ordre de grandeur</strong> uniquement au moyen de la localisation des donn√©es, c'est-√†-dire moins de pollution du cache du processeur.  Autrement dit, on peut construire une structure de table de hachage de telle mani√®re que les valeurs de hachage calcul√©es se trouvent c√¥te √† c√¥te (regroup√©es dans des lignes de cache).  Le CPU ne r√©cup√®re alors les donn√©es r√©elles que si les valeurs de hachage correspondent.  Et dans ce cas, les <em>64 bits de t1ha permettent d'obtenir le meilleur r√©sultat possible</em> .  Cela √©tant dit, 128 bits ne fourniront plus d'avantage, tandis que prendre moins de 64 bits est toujours possible. </p><br><p>  <strong>Comparaison avec HighwayHash</strong> : J'ai des sentiments mitig√©s sur ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet non officiel des employ√©s de Google</a> . </p><br><ol><li>  D'une part, il a un bon code et une excellente impl√©mentation technique.  D'un autre c√¥t√©, <em>HighwayHash</em> est positionn√© comme <em>possiblement</em> fort cryptographiquement (au moins √©gal √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SipHash</a> ).  √Ä l'int√©rieur de HighwayHash, il y a pas mal de manipulations qui nous permettent de nous attendre √† ce que le r√©sultat ne soit pas mauvais.  Cependant, il n'y a aucune preuve qui nous permettrait de le dire de mani√®re fiable.  La preuve de ¬´force¬ª fournie se r√©sume aux r√©sultats des tests statistiques, mais sans pouvoir les reproduire (√† un moment donn√©, je me suis m√™me permis un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaire</a> quelque peu superflu). </li><li>  HighwayHash est vraiment rapide uniquement sur x86_64 avec AVX2 ou SSE41.  N'est-il pas plus facile alors d'utiliser simplement l'acc√©l√©ration AES-NI ou SHA? </li></ol><br><p>  Si tout se passe bien, des options suppl√©mentaires seront ajout√©es √† la suite t1ha (principalement pour le r√©sultat bitness) et optimis√©es pour E2K.  Sur ce, je voudrais clore le sujet des comparaisons avec HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  La qualit√© </h2><br><p>  L'√©valuation de la qualit√© d'une fonction de hachage sous tous ses aspects peut √™tre assez difficile.  Cela peut se faire soit analytiquement, soit en mettant en ≈ìuvre divers tests statistiques.  Malheureusement, l'approche analytique n'est pas tr√®s efficace pour √©valuer les fonctions de hachage avec un compromis entre qualit√© et rapidit√©.  De plus, une √©valuation analytique comparative de ces fonctions a tendance √† √™tre subjective. </p><br><p>  En revanche, les tests statistiques peuvent fournir des estimations quantitatives claires.  √Ä ces fins, il existe des packages de test √©prouv√©s, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMHasher</a> .  Pour <em>t1ha</em> , les r√©sultats sont simples - toutes les <strong>options de t1ha</strong> r√©ussissent tous les tests sans aucun commentaire.  En revanche, il ne faut pas supposer que t1ha poss√®de des propri√©t√©s sup√©rieures √† celles qui sont n√©cessaires pour l'application cible (cr√©ation de tables de hachage). </p><br><p>  Le nombre de collisions √† tous les niveaux (variantes) de <strong>t1ha</strong> correspond au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paradoxe d'anniversaire</a> .  Pour le formuler strictement - la probabilit√© de collision en <strong>t1ha</strong> correspond √† la probabilit√© de co√Øncidence de valeurs discr√®tes al√©atoires avec le bitness correspondant. <br>  Une probabilit√© de collision similaire est observ√©e dans toutes les fonctions de hachage de haute qualit√©.  Cependant, il ne s'agit que de probabilit√©, de sorte que le nombre r√©el de collisions peut varier pour chaque ensemble de donn√©es sp√©cifique. </p><br><p> Apr√®s la premi√®re publication de cet article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yves Orton a d√©couvert</a> que le premier <code>t1ha1()</code> ne r√©pond pas toujours au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crit√®re strict des avalanches</a> .  Cet inconv√©nient est insignifiant pour les applications cibl√©es de <code>t1ha1()</code> et imperceptible d'un point de vue pratique.  Cependant, cet inconv√©nient est √©limin√© dans le prochain niveau / variante <code>t1ha2()</code> , qui √©tait initialement pr√©vu pour fournir une qualit√© l√©g√®rement sup√©rieure.  Sur les nouveaux processeurs, qui utilisent les versions actuelles des compilateurs, <code>t1ha2()</code> est en moyenne un cycle plus rapide que <code>t1ha1()</code> , et dans le reste des cas, il peut √™tre un cycle plus lent.  Il convient de noter que <code>t1ha2()</code> offre en outre un mode de hachage de flux et un r√©sultat de 128 bits. </p><br><p>  Les lecteurs appr√©cieraient certainement une analyse approfondie et approfondie de la qualit√© et / ou de la force du <strong>t1ha</strong> .  Cependant, sur la <strong>base</strong> des zones d'application <strong>t1ha</strong> cibles, cela semble redondant.  En termes simples, la vitesse √©tait plus importante pour nous, m√™me pour les touches courtes.  Par cons√©quent, le m√©lange √† plusieurs tours n'a pas √©t√© envisag√©.  La version <em>t1ha</em> actuelle <em>permet d'</em> √©conomiser sur les cycles et donne un r√©sultat 64 bits - il est pratiquement inutile de mesurer le compromis trouv√© autrement que statistiquement, et ses r√©sultats sont tout simplement bons. </p><br><div class="spoiler">  <b class="spoiler_title">En fait</b> <div class="spoiler_text"><p>  Je viens de suivre mes coll√®gues de Google sur la fa√ßon dont ils fournissent leur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preuve statistique</a> </p></div></div><br><hr><br><h2 id="benchmarks">  Rep√®res </h2><br><p>  Concernant la pr√©tention d'√™tre " <em>la plus rapide</em> ".  il est important de noter qu'il est √©videmment peu probable qu'il existe une fonction de hachage qui soit √† la fois utile et la plus rapide sur toutes les plateformes / architectures.  Diff√©rents processeurs ont diff√©rents ensembles d'instructions disponibles et ex√©cutent des instructions similaires avec diff√©rentes efficacit√©s.  De toute √©vidence, la fonction " <em>universellement la plus rapide</em> " ne peut tr√®s probablement pas √™tre cr√©√©e.  Cependant, il semble acceptable d'utiliser le terme <br>  le plus rapide ¬ªpour une fonction qui est portable et en m√™me temps la plus rapide, au moins sur la plate-forme la plus courante (x86_64), tout en ayant peu de chance de perdre sur n'importe quel processeur moderne avec un compilateur d'optimisation d√©cent. </p><br><p>  Le code source du projet comprend un test qui v√©rifie √† la fois l'exactitude du r√©sultat et mesure la vitesse de chaque variante impl√©ment√©e.  En m√™me temps, sur x86, en fonction des capacit√©s du processeur (et du compilateur), des variantes de fonctions suppl√©mentaires peuvent √™tre v√©rifi√©es et les mesures sont effectu√©es en cycles de processeur. </p><br><p>  En outre, le site Web du projet contient des tableaux avec les r√©sultats des mesures de performance via une version modifi√©e de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMHasher de Reini Urban</a> .  On peut rev√©rifier tous les chiffres et / ou obtenir des r√©sultats sur un processeur sp√©cifique en utilisant un compilateur sp√©cifique. </p><br><p>  Ici, vous pouvez comparer t1ha avec certains de ses concurrents les plus proches. </p><br><p>  <strong>Hachage de touches courtes</strong> (moyenne de 1 √† 31 octets). <br>  <em>Regardez la colonne de droite "Cycles / Hash" (plus petite est meilleure)</em> : </p><br><table><thead><tr><th>  Fonction </th><th>  Mio / seconde </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43,42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46,33 </td></tr></tbody></table><br><p>  <strong>Hachage de cl√©s longues</strong> (256 Ko). <br>  <em>Regardez la colonne du milieu "MiB / Second" (plus c'est gros, mieux c'est)</em> : </p><br><table><thead><tr><th>  Fonction </th><th>  Mio / seconde </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Variantes de t1ha </h2><br><p>  D√©veloppement de <strong>t1ha</strong> Le premier de ces objectifs √©tait d'obtenir une fonction portable rapide de qualit√© suffisamment √©lev√©e pour construire des tables de hachage. </p><br><p>  Ensuite, nous voulions avoir la version la plus rapide de la fonction de hachage qui donnerait un r√©sultat de qualit√© comparable mais qui serait autant que possible adapt√©e √† la plateforme cible.  Par exemple, la version de base de <strong>t1ha</strong> fonctionne avec un ordre d'octets petit- <strong>boutien</strong> , ce qui n√©cessite une conversion pour les architectures grand-boutiens avec une perte de performances in√©vitable.  Alors pourquoi ne pas se d√©barrasser des op√©rations inutiles sur une plateforme cible sp√©cifique?  De cette fa√ßon, plusieurs autres options ont √©t√© ajout√©es: </p><br><ul><li>  Version simplifi√©e pour les plates-formes 32 bits, petites et grandes. </li><li>  Variante utilisant les instructions AES-NI, mais sans AVX. </li><li>  Deux variantes utilisant les instructions AES-NI et AVX. </li></ul><br><p>  Plus tard, il est devenu clair que davantage d'options con√ßues pour diverses applications seraient n√©cessaires, y compris des r√©sultats de largeur de m√®che diff√©rents, des exigences de qualit√© et de durabilit√©.  Cette diversit√© n√©cessite une syst√©matisation appropri√©e.  Ceci a √©t√© r√©alis√© en changeant le sch√©ma de nommage, dans lequel le suffixe num√©rique indique le ¬´niveau¬ª de la fonction: </p><br><ul><li>  <code>t1ha0()</code> - est l'option la plus rapide pour le processeur actuel. </li><li>  <code>t1ha1()</code> - est la version 64 bits portable de base de t1ha. </li><li>  <code>t1ha2()</code> - est une version portable 64 bits avec un peu plus de souci de qualit√©. </li><li>  <code>t1ha3()</code> - est une version portable rapide de 128 bits pour les empreintes digitales. </li><li>  etc. </li></ul><br><p>  Dans ce sch√©ma, on suppose que <code>t1ha0()</code> est un r√©partiteur qui impl√©mente la redirection en fonction de la plate-forme et des capacit√©s du processeur actuel.  De plus, l'utilisation des suffixes "_le" et "_be" pour un choix explicite entre les variantes little-endian et big-endian peut √™tre introduite.  Ainsi, sous l'enseigne ¬´t1ha¬ª, il y a maintenant plusieurs fonctions de hachage, et cette famille va grandir dans le futur, y compris une version optimis√©e pour l'E2K russe ¬´Elbrus¬ª. </p><br><p>  Une id√©e g√©n√©rale de l'ensemble actuel des fonctions et de leurs propri√©t√©s peut √™tre saisie en regardant la sortie de test int√©gr√©e ( <code>make check</code> ).  Il convient de noter que toutes les fonctions r√©ussissent tous les tests SM Hasher et que les performances des variantes AES-NI varient consid√©rablement en fonction du mod√®le de processeur: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Un peu sur la structure interne</b> <div class="spoiler_text"><p>  Pour approfondir un peu plus les d√©tails, <strong>t1ha</strong> est construit selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©ma de Merkle-Damg√•rd</a> (version ¬´wipe-pipe¬ª) avec un renforcement √† partir de la taille des donn√©es et de la valeur de d√©part.  √Ä l'int√©rieur de la boucle de compression principale, un √©tat de 256 bits est utilis√©, avec la m√™me taille du bloc d'entr√©e.  De plus, pour chaque op√©rande de donn√©es, il existe deux points d'injection avec pollinisation crois√©e.  √Ä la fin du cycle de compression, l'√©tat 256 bits est compress√© √† 128 bits. </p><br><p>  Lors de l'ex√©cution des actions ci-dessus, des op√©rations 64 bits, combin√©es dans les m√©langeurs ARX (Add-Rotate-Xor) et MUX / MRX (Mul-Rotate-Xor), sont utilis√©es.  Il est important que tous ces calculs soient construits de mani√®re √† garantir la possibilit√© d'ex√©cution parall√®le de la plupart des op√©rations et un compactage des op√©rations op√©rationnelles √† la fois dans le pipeline et dans les unit√©s d'ex√©cution x86_64.  De ce fait, une qualit√© suffisamment bonne est obtenue avec un taux de hachage presque maximal pour les touches longues. </p><br><p>  Il convient de noter que la boucle de compression ne fonctionne que pour des blocs de taille suffisante.  S'il y a moins de donn√©es, l'√©tat interm√©diaire de 128 bits consistera uniquement en la taille de cl√© et la valeur de sel. </p><br><p>  Ensuite, la queue restante des donn√©es est m√©lang√©e en portions de 64 bits alternativement aux moiti√©s de l'√©tat 128 bits.  Enfin, l'√©tat est m√©lang√© et compress√© simultan√©ment en un r√©sultat 64 bits.  Une caract√©ristique importante de t1ha ici est l'utilisation d'un m√©langeur bas√© sur une multiplication large (produit 128 bits de deux multiplicateurs 64 bits).  Cela permet un m√©lange de bonne qualit√© avec un bon effet d'avalanche et moins d'op√©rations.  M√™me si une multiplication large est une op√©ration relativement co√ªteuse, moins de telles op√©rations permettent √† t1ha de traiter des cl√©s courtes dans un nombre record de cycles de processeur. </p><br><p>  Il convient de noter que le m√©langeur bas√© sur une large multiplication et un OU exclusif n'est pas parfait.  Bien que <em>t1ha r√©ussisse</em> tous les tests <em>SMHasher</em> , l'auteur comprend les cons√©quences de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">non-injectivit√©</a> ).  N√©anmoins, la qualit√© qui en r√©sulte semble √™tre rationnellement suffisante, et les plans de d√©veloppement de la ligne t1ha refl√®tent d√©j√† l'intention de proposer des options de qualit√© l√©g√®rement sup√©rieures. </p></div></div><br><p>  Vous pouvez trouver plus d'informations et le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  <em>Merci d'avoir lu!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439156/">https://habr.com/ru/post/fr439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439142/index.html">Mod√®les de maturit√© de conception</a></li>
<li><a href="../fr439148/index.html">Travailler avec nRF51822 en utilisant ST-Link et Clion + OpenOCD</a></li>
<li><a href="../fr439150/index.html">Qui devrait payer les frais de transaction</a></li>
<li><a href="../fr439152/index.html">Salaires en informatique au second semestre 2018: selon le calculateur de salaire "My Circle"</a></li>
<li><a href="../fr439154/index.html">Comment vivent les pigistes: conception de la couverture du livre, production de son propre sac √† dos et voyages</a></li>
<li><a href="../fr439158/index.html">DataArt lance un service gratuit d'am√©lioration du CV de canards CV</a></li>
<li><a href="../fr439160/index.html">√âtat de l'algorithme: qu'advient-il des d√©veloppeurs ind√©pendants sur Steam?</a></li>
<li><a href="../fr439162/index.html">Comment d√©boguer le frontend et le backend: instructions √©tape par √©tape</a></li>
<li><a href="../fr439166/index.html">mmWave en route vers la commercialisation dans le format smartphone</a></li>
<li><a href="../fr439168/index.html">Syst√®mes d'analyse client</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>