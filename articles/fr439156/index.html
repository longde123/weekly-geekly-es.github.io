<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌁 🌁 🥕 t1ha = hachage positif rapide 💢 🤜🏼 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À peu près la fonction de hachage portable 64 bits la plus rapide avec une qualité décente. 


 Il s'agit d'une traduction de l' article original de L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = hachage positif rapide</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  À peu près la fonction de hachage portable 64 bits la plus rapide avec une qualité décente. </p><br><p> Il s'agit d'une traduction de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Au lieu d'une clause de non-responsabilité</b> <div class="spoiler_text"><p>  Je vais omettre la définition des fonctions de hachage ainsi que la liste détaillée des propriétés et des exigences de leur application cryptographique, et je suppose que le lecteur a les connaissances minimales nécessaires ou qu'il les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lira</a> .  Il convient également de noter que je parlerai ci-après de fonctions de hachage non cryptographiques (ne conviennent pas à la cryptographie), sauf indication contraire explicite. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalités</b> <div class="spoiler_text"><p>  Le hachage est utilisé dans de nombreux algorithmes, et presque toujours le traitement de données le plus efficace (rapide) est requis, avec un certain niveau minimum de qualité de hachage.  Ici, le terme «qualité» signifie tout d'abord une sorte de «hasard» (stochasticité) par rapport aux données initiales.  Un peu moins souvent, des exigences supplémentaires sont imposées, telles que la résistance à la génération délibérée de collisions ou l'irréversibilité. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pour être un peu plus fastidieux</b> <div class="spoiler_text"><p>  Pour plus de clarté, il est nécessaire de définir un peu plus en détail le concept de «qualité» de la fonction de hachage et le reste des exigences: <br>  Qualité de référence et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet d'avalanche</a> : la modification d'un ou plusieurs bits arbitraires dans un ensemble arbitraire de données source entraîne une modification de chaque bit du résultat avec une probabilité de ½. </p><br><ul><li>  Irréversibilité ou première résistance à la pré-image: l'impossibilité d'obtenir les données originales ou les bits individuels du résultat de hachage. </li><li>  Résistance aux collisions de premier ordre et / ou deuxième résistance à la pré-image: la difficulté de trouver / ajuster l'ensemble de données d'origine pour obtenir un résultat spécifié ou une partie de celui-ci, y compris lorsque l'ensemble de données initial est connu. </li><li>  Résistance aux collisions de second ordre: la difficulté de trouver / ajuster deux ensembles de données différents qui donneraient le même résultat ou une correspondance d'une partie significative. </li></ul></div></div><br><p>  En omettant de longues citations des mathématiques sous-jacentes, il peut être résumé: </p><br><ul><li>  Satisfaire à toutes les exigences ci-dessus tout en garantissant des performances élevées est un problème assez difficile à résoudre, ce qui nous donnerait une bonne fonction de hachage cryptographique.  Mais nous n'allons pas encore le faire. </li><li>  La fourniture d'une qualité de base nécessite un nombre suffisamment important d'opérations ALU.  En termes simples, la qualité est toujours compromise avec la vitesse. </li><li>  L'obtention d'un résultat de haute qualité avec une largeur de bit supérieure à la largeur de bit des opérations ALU nécessite plus d'une multiplication par plusieurs du nombre de mélanges, et donc des opérations ALU de base. </li><li>  En général, la <em>création d'une fonction de hachage rapide implique la réalisation d'un compromis pondéré entre la vitesse, la qualité et le résultat bitness</em> . </li></ul><br><p>  Par conséquent, je peux dire que <strong>t1ha</strong> est apparu à la suite de la recherche d'un compromis entre la qualité et la vitesse, en tenant compte à la fois des capacités des processeurs modernes et des méthodes déjà trouvées (combinaisons arithmétiques et logiques) de mélange et de propagation des dépendances ( effet avalanche). </p><br><p>  La version de base de <strong>t1ha</strong> est l'une des fonctions de hachage portables les plus rapides pour la construction de tables de hachage et d'autres applications connexes.  La version de base de <strong>t1ha</strong> se concentre sur les architectures little-endian 64 bits, prend une valeur de sel 64 bits (seed) et produit un résultat 64 bits, qui comprend le renforcement par la longueur de clé et le seed.  Il convient de noter que <strong>t1ha</strong> est intentionnellement conçu pour renvoyer 0 pour des données d'entrée nulles (une clé de taille zéro et de zéro graine). </p><br><div class="spoiler">  <b class="spoiler_title">Répondre aux questions les plus fréquentes</b> <div class="spoiler_text"><p>  <strong>Opérations 64 bits</strong> : Il convient peut-être de noter que ce sont les opérations 64 bits qui offrent vitesse et qualité sans nuire à la portabilité.  En fait, plus la capacité numérique des opérations arithmétiques est large, plus elles produisent d'effet avalanche et mieux elles mélangent les données.  De plus, le traitement des données, toutes choses étant égales par ailleurs, est certainement plus rapide de 8 octets que de 4. D'autre part, des opérations exactement 64 bits sont nativement disponibles sur de nombreux processeurs modernes et peuvent être plus ou moins correctement traduites en 32- les petits.  Toutes les autres options, y compris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> opérations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SIMD</a> , nous obligent à sacrifier considérablement la portabilité et / ou la vitesse sur des plates-formes non natives. </p><br><p>  <strong>Résultat 64 bits</strong> : pour construire des tables de hachage, dans de nombreux cas, un résultat de largeur de bit plus petit suffit.  Même 32 bits peuvent être plus que suffisants.  Cependant, lorsque vous utilisez des opérations 64 bits, le résultat 64 bits vient naturellement.  Dans le même temps, un résultat de hachage 64 bits de qualité suffisamment élevée vous permet d'effectuer rapidement une comparaison pour la non-égalité et avec une bonne précision de comparer pour l'égalité. </p><br><p>  La "magie" ci-dessus de remplacer les comparaisons peut sembler peu claire et inutile, ou elle peut <strong>augmenter la vitesse de hachage d'un ordre de grandeur</strong> uniquement au moyen de la localisation des données, c'est-à-dire moins de pollution du cache du processeur.  Autrement dit, on peut construire une structure de table de hachage de telle manière que les valeurs de hachage calculées se trouvent côte à côte (regroupées dans des lignes de cache).  Le CPU ne récupère alors les données réelles que si les valeurs de hachage correspondent.  Et dans ce cas, les <em>64 bits de t1ha permettent d'obtenir le meilleur résultat possible</em> .  Cela étant dit, 128 bits ne fourniront plus d'avantage, tandis que prendre moins de 64 bits est toujours possible. </p><br><p>  <strong>Comparaison avec HighwayHash</strong> : J'ai des sentiments mitigés sur ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet non officiel des employés de Google</a> . </p><br><ol><li>  D'une part, il a un bon code et une excellente implémentation technique.  D'un autre côté, <em>HighwayHash</em> est positionné comme <em>possiblement</em> fort cryptographiquement (au moins égal à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SipHash</a> ).  À l'intérieur de HighwayHash, il y a pas mal de manipulations qui nous permettent de nous attendre à ce que le résultat ne soit pas mauvais.  Cependant, il n'y a aucune preuve qui nous permettrait de le dire de manière fiable.  La preuve de «force» fournie se résume aux résultats des tests statistiques, mais sans pouvoir les reproduire (à un moment donné, je me suis même permis un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaire</a> quelque peu superflu). </li><li>  HighwayHash est vraiment rapide uniquement sur x86_64 avec AVX2 ou SSE41.  N'est-il pas plus facile alors d'utiliser simplement l'accélération AES-NI ou SHA? </li></ol><br><p>  Si tout se passe bien, des options supplémentaires seront ajoutées à la suite t1ha (principalement pour le résultat bitness) et optimisées pour E2K.  Sur ce, je voudrais clore le sujet des comparaisons avec HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  La qualité </h2><br><p>  L'évaluation de la qualité d'une fonction de hachage sous tous ses aspects peut être assez difficile.  Cela peut se faire soit analytiquement, soit en mettant en œuvre divers tests statistiques.  Malheureusement, l'approche analytique n'est pas très efficace pour évaluer les fonctions de hachage avec un compromis entre qualité et rapidité.  De plus, une évaluation analytique comparative de ces fonctions a tendance à être subjective. </p><br><p>  En revanche, les tests statistiques peuvent fournir des estimations quantitatives claires.  À ces fins, il existe des packages de test éprouvés, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMHasher</a> .  Pour <em>t1ha</em> , les résultats sont simples - toutes les <strong>options de t1ha</strong> réussissent tous les tests sans aucun commentaire.  En revanche, il ne faut pas supposer que t1ha possède des propriétés supérieures à celles qui sont nécessaires pour l'application cible (création de tables de hachage). </p><br><p>  Le nombre de collisions à tous les niveaux (variantes) de <strong>t1ha</strong> correspond au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paradoxe d'anniversaire</a> .  Pour le formuler strictement - la probabilité de collision en <strong>t1ha</strong> correspond à la probabilité de coïncidence de valeurs discrètes aléatoires avec le bitness correspondant. <br>  Une probabilité de collision similaire est observée dans toutes les fonctions de hachage de haute qualité.  Cependant, il ne s'agit que de probabilité, de sorte que le nombre réel de collisions peut varier pour chaque ensemble de données spécifique. </p><br><p> Après la première publication de cet article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yves Orton a découvert</a> que le premier <code>t1ha1()</code> ne répond pas toujours au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">critère strict des avalanches</a> .  Cet inconvénient est insignifiant pour les applications ciblées de <code>t1ha1()</code> et imperceptible d'un point de vue pratique.  Cependant, cet inconvénient est éliminé dans le prochain niveau / variante <code>t1ha2()</code> , qui était initialement prévu pour fournir une qualité légèrement supérieure.  Sur les nouveaux processeurs, qui utilisent les versions actuelles des compilateurs, <code>t1ha2()</code> est en moyenne un cycle plus rapide que <code>t1ha1()</code> , et dans le reste des cas, il peut être un cycle plus lent.  Il convient de noter que <code>t1ha2()</code> offre en outre un mode de hachage de flux et un résultat de 128 bits. </p><br><p>  Les lecteurs apprécieraient certainement une analyse approfondie et approfondie de la qualité et / ou de la force du <strong>t1ha</strong> .  Cependant, sur la <strong>base</strong> des zones d'application <strong>t1ha</strong> cibles, cela semble redondant.  En termes simples, la vitesse était plus importante pour nous, même pour les touches courtes.  Par conséquent, le mélange à plusieurs tours n'a pas été envisagé.  La version <em>t1ha</em> actuelle <em>permet d'</em> économiser sur les cycles et donne un résultat 64 bits - il est pratiquement inutile de mesurer le compromis trouvé autrement que statistiquement, et ses résultats sont tout simplement bons. </p><br><div class="spoiler">  <b class="spoiler_title">En fait</b> <div class="spoiler_text"><p>  Je viens de suivre mes collègues de Google sur la façon dont ils fournissent leur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preuve statistique</a> </p></div></div><br><hr><br><h2 id="benchmarks">  Repères </h2><br><p>  Concernant la prétention d'être " <em>la plus rapide</em> ".  il est important de noter qu'il est évidemment peu probable qu'il existe une fonction de hachage qui soit à la fois utile et la plus rapide sur toutes les plateformes / architectures.  Différents processeurs ont différents ensembles d'instructions disponibles et exécutent des instructions similaires avec différentes efficacités.  De toute évidence, la fonction " <em>universellement la plus rapide</em> " ne peut très probablement pas être créée.  Cependant, il semble acceptable d'utiliser le terme <br>  le plus rapide »pour une fonction qui est portable et en même temps la plus rapide, au moins sur la plate-forme la plus courante (x86_64), tout en ayant peu de chance de perdre sur n'importe quel processeur moderne avec un compilateur d'optimisation décent. </p><br><p>  Le code source du projet comprend un test qui vérifie à la fois l'exactitude du résultat et mesure la vitesse de chaque variante implémentée.  En même temps, sur x86, en fonction des capacités du processeur (et du compilateur), des variantes de fonctions supplémentaires peuvent être vérifiées et les mesures sont effectuées en cycles de processeur. </p><br><p>  En outre, le site Web du projet contient des tableaux avec les résultats des mesures de performance via une version modifiée de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMHasher de Reini Urban</a> .  On peut revérifier tous les chiffres et / ou obtenir des résultats sur un processeur spécifique en utilisant un compilateur spécifique. </p><br><p>  Ici, vous pouvez comparer t1ha avec certains de ses concurrents les plus proches. </p><br><p>  <strong>Hachage de touches courtes</strong> (moyenne de 1 à 31 octets). <br>  <em>Regardez la colonne de droite "Cycles / Hash" (plus petite est meilleure)</em> : </p><br><table><thead><tr><th>  Fonction </th><th>  Mio / seconde </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43,42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46,33 </td></tr></tbody></table><br><p>  <strong>Hachage de clés longues</strong> (256 Ko). <br>  <em>Regardez la colonne du milieu "MiB / Second" (plus c'est gros, mieux c'est)</em> : </p><br><table><thead><tr><th>  Fonction </th><th>  Mio / seconde </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Variantes de t1ha </h2><br><p>  Développement de <strong>t1ha</strong> Le premier de ces objectifs était d'obtenir une fonction portable rapide de qualité suffisamment élevée pour construire des tables de hachage. </p><br><p>  Ensuite, nous voulions avoir la version la plus rapide de la fonction de hachage qui donnerait un résultat de qualité comparable mais qui serait autant que possible adaptée à la plateforme cible.  Par exemple, la version de base de <strong>t1ha</strong> fonctionne avec un ordre d'octets petit- <strong>boutien</strong> , ce qui nécessite une conversion pour les architectures grand-boutiens avec une perte de performances inévitable.  Alors pourquoi ne pas se débarrasser des opérations inutiles sur une plateforme cible spécifique?  De cette façon, plusieurs autres options ont été ajoutées: </p><br><ul><li>  Version simplifiée pour les plates-formes 32 bits, petites et grandes. </li><li>  Variante utilisant les instructions AES-NI, mais sans AVX. </li><li>  Deux variantes utilisant les instructions AES-NI et AVX. </li></ul><br><p>  Plus tard, il est devenu clair que davantage d'options conçues pour diverses applications seraient nécessaires, y compris des résultats de largeur de mèche différents, des exigences de qualité et de durabilité.  Cette diversité nécessite une systématisation appropriée.  Ceci a été réalisé en changeant le schéma de nommage, dans lequel le suffixe numérique indique le «niveau» de la fonction: </p><br><ul><li>  <code>t1ha0()</code> - est l'option la plus rapide pour le processeur actuel. </li><li>  <code>t1ha1()</code> - est la version 64 bits portable de base de t1ha. </li><li>  <code>t1ha2()</code> - est une version portable 64 bits avec un peu plus de souci de qualité. </li><li>  <code>t1ha3()</code> - est une version portable rapide de 128 bits pour les empreintes digitales. </li><li>  etc. </li></ul><br><p>  Dans ce schéma, on suppose que <code>t1ha0()</code> est un répartiteur qui implémente la redirection en fonction de la plate-forme et des capacités du processeur actuel.  De plus, l'utilisation des suffixes "_le" et "_be" pour un choix explicite entre les variantes little-endian et big-endian peut être introduite.  Ainsi, sous l'enseigne «t1ha», il y a maintenant plusieurs fonctions de hachage, et cette famille va grandir dans le futur, y compris une version optimisée pour l'E2K russe «Elbrus». </p><br><p>  Une idée générale de l'ensemble actuel des fonctions et de leurs propriétés peut être saisie en regardant la sortie de test intégrée ( <code>make check</code> ).  Il convient de noter que toutes les fonctions réussissent tous les tests SM Hasher et que les performances des variantes AES-NI varient considérablement en fonction du modèle de processeur: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Un peu sur la structure interne</b> <div class="spoiler_text"><p>  Pour approfondir un peu plus les détails, <strong>t1ha</strong> est construit selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma de Merkle-Damgård</a> (version «wipe-pipe») avec un renforcement à partir de la taille des données et de la valeur de départ.  À l'intérieur de la boucle de compression principale, un état de 256 bits est utilisé, avec la même taille du bloc d'entrée.  De plus, pour chaque opérande de données, il existe deux points d'injection avec pollinisation croisée.  À la fin du cycle de compression, l'état 256 bits est compressé à 128 bits. </p><br><p>  Lors de l'exécution des actions ci-dessus, des opérations 64 bits, combinées dans les mélangeurs ARX (Add-Rotate-Xor) et MUX / MRX (Mul-Rotate-Xor), sont utilisées.  Il est important que tous ces calculs soient construits de manière à garantir la possibilité d'exécution parallèle de la plupart des opérations et un compactage des opérations opérationnelles à la fois dans le pipeline et dans les unités d'exécution x86_64.  De ce fait, une qualité suffisamment bonne est obtenue avec un taux de hachage presque maximal pour les touches longues. </p><br><p>  Il convient de noter que la boucle de compression ne fonctionne que pour des blocs de taille suffisante.  S'il y a moins de données, l'état intermédiaire de 128 bits consistera uniquement en la taille de clé et la valeur de sel. </p><br><p>  Ensuite, la queue restante des données est mélangée en portions de 64 bits alternativement aux moitiés de l'état 128 bits.  Enfin, l'état est mélangé et compressé simultanément en un résultat 64 bits.  Une caractéristique importante de t1ha ici est l'utilisation d'un mélangeur basé sur une multiplication large (produit 128 bits de deux multiplicateurs 64 bits).  Cela permet un mélange de bonne qualité avec un bon effet d'avalanche et moins d'opérations.  Même si une multiplication large est une opération relativement coûteuse, moins de telles opérations permettent à t1ha de traiter des clés courtes dans un nombre record de cycles de processeur. </p><br><p>  Il convient de noter que le mélangeur basé sur une large multiplication et un OU exclusif n'est pas parfait.  Bien que <em>t1ha réussisse</em> tous les tests <em>SMHasher</em> , l'auteur comprend les conséquences de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">non-injectivité</a> ).  Néanmoins, la qualité qui en résulte semble être rationnellement suffisante, et les plans de développement de la ligne t1ha reflètent déjà l'intention de proposer des options de qualité légèrement supérieures. </p></div></div><br><p>  Vous pouvez trouver plus d'informations et le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  <em>Merci d'avoir lu!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439156/">https://habr.com/ru/post/fr439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439142/index.html">Modèles de maturité de conception</a></li>
<li><a href="../fr439148/index.html">Travailler avec nRF51822 en utilisant ST-Link et Clion + OpenOCD</a></li>
<li><a href="../fr439150/index.html">Qui devrait payer les frais de transaction</a></li>
<li><a href="../fr439152/index.html">Salaires en informatique au second semestre 2018: selon le calculateur de salaire "My Circle"</a></li>
<li><a href="../fr439154/index.html">Comment vivent les pigistes: conception de la couverture du livre, production de son propre sac à dos et voyages</a></li>
<li><a href="../fr439158/index.html">DataArt lance un service gratuit d'amélioration du CV de canards CV</a></li>
<li><a href="../fr439160/index.html">État de l'algorithme: qu'advient-il des développeurs indépendants sur Steam?</a></li>
<li><a href="../fr439162/index.html">Comment déboguer le frontend et le backend: instructions étape par étape</a></li>
<li><a href="../fr439166/index.html">mmWave en route vers la commercialisation dans le format smartphone</a></li>
<li><a href="../fr439168/index.html">Systèmes d'analyse client</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>