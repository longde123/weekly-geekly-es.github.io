<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîú ü§¶üèø üíπ WinForms: erros, Holmes üßôüèº üíñ üïù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Adoramos procurar bugs em projetos da Microsoft. Porque √â simples: seus projetos geralmente s√£o f√°ceis de verificar (o trabalho pode ser feito imediat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: erros, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462807/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Quadro 5"></div><br>  Adoramos procurar bugs em projetos da Microsoft.  Porque  √â simples: seus projetos geralmente s√£o f√°ceis de verificar (o trabalho pode ser feito imediatamente no ambiente do Visual Studio, para o qual o PVS-Studio possui um plug-in conveniente) e eles cont√™m poucos erros.  Portanto, o algoritmo usual de trabalho √© o seguinte: encontre e baixe um projeto aberto do MS;  confira;  escolha erros interessantes;  certifique-se de que s√£o poucos;  escreva um artigo sem esquecer de elogiar os desenvolvedores.  √ìtimo!  Ganha-ganha-ganha: demorou um pouco, o manual tem prazer em ver novos materiais no blog e o karma est√° em perfeita ordem.  Mas desta vez algo deu errado.  Vamos ver o que foi encontrado interessante no c√≥digo fonte do Windows Forms e se a Microsoft deve ser elogiada desta vez. <br><a name="habracut"></a><br>  <b>1. Introdu√ß√£o</b> <br><br>  No in√≠cio de dezembro de 2018, a Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anunciou</a> o lan√ßamento do .NET Core 3 Preview 1. Um pouco antes (aproximadamente de meados de outubro), o GitHub come√ßou a trabalhar ativamente na publica√ß√£o do c√≥digo-fonte do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows Forms</a> , a plataforma de interface do usu√°rio do .NET Core para criar aplicativos de desktop do Windows.  Voc√™ pode ver as estat√≠sticas de confirma√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Agora qualquer pessoa pode baixar o c√≥digo fonte do WinForms para revis√£o. <br><br>  Tamb√©m baixei as fontes para procurar erros usando o PVS-Studio.  O cheque n√£o causou dificuldades.  Necess√°rio: Visual Studio 2019, Visualiza√ß√£o do SDK do .NET Core 3.0, PVS-Studio.  E agora o log de aviso do analisador √© recebido. <br><br>  Depois de receber o log do PVS-Studio, costumo classific√°-lo em ordem crescente de n√∫meros de diagn√≥stico (a janela com o log de mensagens do PVS-Studio no Visual Studio possui v√°rias op√ß√µes para classificar e filtrar a lista).  Isso permite que voc√™ trabalhe com grupos de erros do mesmo tipo, o que simplifica bastante a an√°lise do c√≥digo fonte.  Eu marquei erros interessantes na lista com um asterisco e s√≥ ent√£o, depois de analisar o log inteiro, escrevo fragmentos de c√≥digo e fa√ßo uma descri√ß√£o.  E, como geralmente h√° poucos erros, eu os misturo, tentando colocar o mais interessante no in√≠cio e no final do artigo.  Mas desta vez, os erros acabaram sendo um pouco demais (eh, n√£o foi poss√≠vel salvar a intriga por muito tempo), e eu os trarei na ordem dos n√∫meros de diagn√≥stico. <br><br>  O que foi encontrado?  833 avisos do n√≠vel de confian√ßa Alto e M√©dio (249 e 584, respectivamente) foram emitidos para 540.000 linhas de c√≥digo (excluindo as vazias) em arquivos de 1670 cs.  E sim, de acordo com a tradi√ß√£o, n√£o verifiquei os testes e n√£o considerei os avisos do baixo n√≠vel de confian√ßa (foram emitidos 215).  De acordo com minhas observa√ß√µes anteriores, existem muitos avisos para o projeto do MS.  Mas nem todos os avisos s√£o erros. <br><br>  Para este projeto, o n√∫mero de falsos positivos foi de cerca de 30%.  Em cerca de 20% dos casos, eu simplesmente n√£o consegui concluir exatamente se isso √© um erro ou n√£o, pois n√£o conhe√ßo bem o c√≥digo.  Bem, pelo menos 20% dos erros que eu perdi podem ser atribu√≠dos ao fator humano: pressa, fadiga, etc.  O efeito oposto tamb√©m √© poss√≠vel: a prop√≥sito, observei alguns dos mesmos tipos de disparos, cujo n√∫mero poderia chegar a 70-80, ou outro que ocasionalmente poderia aumentar o n√∫mero de erros que eu considerava reais. <br><br>  De qualquer forma, 30% dos avisos indicam erros reais, uma porcentagem muito grande, pois o analisador n√£o foi pr√©-configurado. <br><br>  Portanto, o n√∫mero de erros que eu consegui detectar era de cerca de 240, o que est√° dentro dos limites das estat√≠sticas.  Repito, na minha opini√£o, para um projeto da MS, esse n√£o √© o resultado mais destacado (embora sejam apenas 0,44 erros por 1.000 linhas de c√≥digo) e provavelmente haja mais erros reais no c√≥digo WinForms.  Proponho falar sobre os motivos no final do artigo, mas agora vamos ver os erros mais interessantes. <br><br>  <b>Erros</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3003</a> O uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o</a> 'if (A) {...} else if (A) {...}' foi detectado.  H√° uma probabilidade de presen√ßa de erro l√≥gico.  Verifique as linhas: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  Nos blocos <i>if</i> e <i>else if</i> , a mesma condi√ß√£o √© verificada.  Parece copiar e colar.  Isso √© um erro?  Se voc√™ observar a declara√ß√£o do m√©todo <i>IsHighContrastHighlighted</i> , h√° d√∫vidas: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  O m√©todo provavelmente pode retornar valores diferentes em chamadas sucessivas.  E o que √© feito no m√©todo de chamada parece estranho, √© claro, mas tem direito √† vida.  No entanto, eu aconselho os autores a dar uma olhada neste peda√ßo de c√≥digo.  Apenas no caso.  E, no entanto, este √© um bom exemplo de qu√£o dif√≠cil √© tirar conclus√µes ao analisar c√≥digo desconhecido. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3004</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√£o</a> 'then' √© equivalente √† instru√ß√£o 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  E aqui o erro de copiar e colar √© definitivamente feito.  Independentemente da condi√ß√£o, a vari√°vel <i>selCharOffset</i> sempre obter√° o mesmo valor. <br><br>  Havia mais dois erros semelhantes no c√≥digo WinForms: <ul><li>  V3004 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  SplitContainer.cs 1700 </li><li>  V3004 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3008</a> A vari√°vel recebe valores duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  O m√©todo preenche o dicion√°rio <i>rgbTable</i> .  O analisador apontou para um peda√ßo de c√≥digo no qual dois valores diferentes s√£o gravados seq√ºencialmente na mesma chave.  E tudo ficaria bem, mas havia mais 16 lugares nesse m√©todo, o que n√£o parece mais um √∫nico erro.  Mas por que fazer isso, para mim, continua sendo um mist√©rio.  N√£o encontrei sinais de c√≥digo gerado automaticamente.  No editor, fica assim: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Quadro 3"></div><br>  Vou dar as dez primeiras opera√ß√µes com uma lista: <br><br><ol><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 A vari√°vel recebe valores atribu√≠dos duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3011</a> Foram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontradas</a> duas condi√ß√µes opostas.  A segunda condi√ß√£o √© sempre falsa.  Verifique as linhas: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  A <i>declara√ß√£o de retorno</i> nunca ser√° executada.  Provavelmente, a condi√ß√£o <i>myGridTable! = Nulo</i> no externo <i>se o</i> bloco foi adicionado posteriormente durante a refatora√ß√£o.  E agora verificar <i>myGridTable == null n√£o faz</i> sentido.  Para melhorar a qualidade do c√≥digo, remova esta verifica√ß√£o. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3019</a> Possivelmente uma vari√°vel incorreta √© comparada a nula ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'left', 'cscLeft'.  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3019</a> Possivelmente uma vari√°vel incorreta √© comparada a nula ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'right', 'cscRight'.  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  O analisador emitiu imediatamente dois avisos para o m√©todo <i>Compare</i> .  Qual √© o problema?  √â que os valores de <i>cscLeft</i> e <i>cscRight</i> n√£o s√£o verificados quanto √† igualdade <i>nula</i> .  Eles podem obter esse valor ap√≥s a convers√£o sem √™xito no tipo <i>OrderedCodeStatementCollection</i> .  Em seguida, uma exce√ß√£o ser√° lan√ßada na √∫ltima <i>declara√ß√£o de retorno</i> .  Essa situa√ß√£o √© poss√≠vel quando todas as verifica√ß√µes para aprova√ß√£o da <i>esquerda</i> e da <i>direita</i> e n√£o levam a uma sa√≠da preliminar do m√©todo. <br><br>  Para corrigir o c√≥digo, <i>cscLeft</i> / <i>cscRight</i> deve ser usado em <i>qualquer</i> lugar, <i>em</i> vez de <i>esquerdo</i> / <i>direito</i> . <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3020</a> Uma 'quebra' incondicional dentro de um loop.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Este fragmento refere-se, antes, ao c√≥digo "com cheiro".  N√£o h√° erro aqui.  Mas surgem d√∫vidas sobre a organiza√ß√£o do ciclo <i>foreach</i> .  Por que √© necess√°rio aqui - √© claro: devido √† necessidade de extrair os elementos da cole√ß√£o, passados ‚Äã‚Äãcomo <i>ICollection</i> .  Mas por que, no loop, originalmente projetado para uma √∫nica itera√ß√£o (uma condi√ß√£o pr√©via √© a presen√ßa de um √∫nico elemento na cole√ß√£o de <i>componentes</i> ), <i>era</i> necess√°ria uma rede de seguran√ßa adicional na forma de <i>quebra</i> ?  Provavelmente, a resposta pode ser considerada: "Ele se desenvolveu historicamente".  O c√≥digo parece feio. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3022 A</a> express√£o 'ocxState! = Null' sempre √© verdadeira.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  Devido a um erro l√≥gico, um "c√≥digo morto" foi formado nesse fragmento.  Express√µes no bloco <i>else</i> nunca ser√£o executadas. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3027</a> A vari√°vel 'e' foi utilizada na express√£o l√≥gica antes de ser verificada contra nula na mesma express√£o l√≥gica.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  A vari√°vel <i>e</i> na condi√ß√£o √© usada primeiro e depois verificada quanto √† desigualdade <i>nula</i> .  Ol√°, <i>NullReferenceException</i> . <br><br>  Outro erro semelhante: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3027</a> A vari√°vel 'dropDownItem' foi utilizada na express√£o l√≥gica antes de ser verificada contra nula na mesma express√£o l√≥gica.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  Uma situa√ß√£o semelhante √† anterior, apenas com a vari√°vel <i>dropDownItem</i> .  Eu acho que esses erros aparecem como resultado de desaten√ß√£o durante a refatora√ß√£o.  Provavelmente parte da condi√ß√£o <i>! (DropDownItem.Owner √© ToolStripDropDownMenu)</i> foi adicionado ao c√≥digo posteriormente. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3030</a> Verifica√ß√£o recorrente.  A condi√ß√£o 'columnCount&gt; 0' j√° foi verificada na linha 3900. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Um erro que pode parecer inofensivo.  De fato, bem, uma verifica√ß√£o extra √© realizada, o que n√£o afeta a l√≥gica do trabalho.  E √†s vezes eles fazem isso quando voc√™ precisa verificar novamente o status de um componente visual, por exemplo, obtendo o n√∫mero de entradas na lista.  Somente nesse caso, eles verificam a vari√°vel <i>local</i> <i>columnCount</i> .  Isso √© muito suspeito.  Eles queriam verificar outra vari√°vel ou em uma das verifica√ß√µes eles usam a condi√ß√£o errada. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3061 O</a> par√¢metro 'lprcClipRect' sempre √© reescrito no corpo do m√©todo antes de ser usado.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Erro n√£o √≥bvio.  Sim, o par√¢metro <i>lprcClipRect √©</i> realmente inicializado com um novo valor, sem us√°-lo de forma alguma.  Mas no que isso resulta?  Eu acho que em algum lugar no c√≥digo de chamada, o link passado por esse par√¢metro permanecer√° inalterado, embora tenha sido planejado de maneira diferente.  De fato, veja como trabalhar com outras vari√°veis ‚Äã‚Äãnesse m√©todo.  At√© o nome (o prefixo "Get") sugere que alguma inicializa√ß√£o ser√° feita dentro do m√©todo atrav√©s dos par√¢metros passados.  E assim √©.  Os dois primeiros par√¢metros ( <i>ppFrame</i> e <i>ppDoc</i> ) s√£o passados ‚Äã‚Äãcom o modificador <i>out</i> e obt√™m novos valores.  Os links <i>lprcPosRect</i> e <i>lpFrameInfo</i> s√£o usados ‚Äã‚Äãpara acessar os campos da classe e inicializ√°-los.  E apenas <i>lprcClipRect</i> sai da lista geral.  Muito provavelmente, o modificador <i>out</i> ou <i>ref</i> √© necess√°rio para este par√¢metro. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3066</a> Poss√≠vel ordem incorreta de argumentos passada para o m√©todo 'AdjustCellBorderStyle': 'isFirstDisplayedRow' e 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  O analisador suspeitou que os dois √∫ltimos argumentos foram confusos.  Vamos dar uma olhada na declara√ß√£o do m√©todo <i>AdjustCellBorderStyle</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  Parece um erro.  Sim, frequentemente alguns argumentos s√£o passados ‚Äã‚Äãintencionalmente na ordem inversa, por exemplo, para trocar algumas vari√°veis.  Mas n√£o acho que esse seja exatamente o caso.  Nada nos m√©todos de chamada ou chamado diz esse padr√£o de uso.  Primeiro, as vari√°veis ‚Äã‚Äãdo tipo <i>bool</i> s√£o confusas.  Em segundo lugar, os nomes dos m√©todos tamb√©m s√£o comuns: sem ‚ÄúSwap‚Äù ou ‚ÄúReverse‚Äù.  Al√©m disso, n√£o √© t√£o dif√≠cil cometer um erro como esse.  As pessoas geralmente percebem a ordem do par de linhas / colunas de maneira diferente.  Para mim, por exemplo, apenas "linha / coluna" √© familiar.  Mas para o autor do m√©todo chamado <i>AdjustCellBorderStyle</i> , obviamente, a ordem mais familiar √© "coluna / linha". <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3070 A</a> vari√°vel n√£o inicializada 'LANG_USER_DEFAULT' √© usada ao inicializar a vari√°vel 'LOCALE_USER_DEFAULT'.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Um erro raro.  A ordem de inicializa√ß√£o dos campos da classe √© misturada.  Para calcular o valor do campo <i>LOCALE_USER_DEFAULT</i> , use o campo <i>LANG_USER_DEFAULT</i> , que ainda n√£o foi inicializado e tem um valor 0. A prop√≥sito, a vari√°vel <i>LANG_USER_DEFAULT</i> n√£o √© usada em nenhum outro lugar do c√≥digo.  Eu n√£o estava com pregui√ßa e escrevi um pequeno programa de console que simula a situa√ß√£o.  Em vez dos valores de algumas constantes usadas no c√≥digo WinForms, substitu√≠ seus valores reais: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  Como resultado do lan√ßamento, o seguinte ser√° exibido no console: 0. Agora, trocamos a declara√ß√£o dos <i>campos LOCALE_USER_DEFAULT</i> e <i>LANG_USER_DEFAULT</i> .  O resultado do programa desta forma: 1024. Acho que n√£o h√° mais nada a comentar aqui. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'ces'.  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  O c√≥digo que deve "cair" √© est√°vel o suficiente, porque voc√™ pode entrar no ramo <i>else</i> apenas quando a refer√™ncia <i>ces</i> √© <i>nula</i> . <br><br>  Outro exemplo semelhante: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'comboBox'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  O c√≥digo paradoxal.  Aparentemente, eles confundiram o teste escrevendo <i>if (comboBox! = Null) em</i> vez de <i>if (comboBox == null)</i> .  E assim - receberemos a pr√≥xima <i>NullReferenceException</i> . <br><br>  Examinamos dois erros bastante √≥bvios da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> , nos quais voc√™ pode acompanhar visualmente a situa√ß√£o do poss√≠vel uso de refer√™ncias nulas no m√©todo.  Mas o diagn√≥stico do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080 √©</a> muito mais inteligente e pode procurar erros semelhantes para cadeias de chamadas de m√©todo.  N√£o faz muito tempo, fortalecemos significativamente os mecanismos de fluxo de dados e an√°lise interprocedural.  Voc√™ pode ler sobre isso no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de refer√™ncia anul√°veis ‚Äã‚Äãno C # 8.0 e an√°lise est√°tica</a> ".  E aqui est√° um erro semelhante encontrado no WinForms: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> Poss√≠vel desrefer√™ncia nula dentro do m√©todo em 'reader.NameTable'.  Considere inspecionar o primeiro argumento: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Veja o que acontece com a vari√°vel <i>contentReader</i> no corpo do m√©todo.  Ap√≥s a inicializa√ß√£o com uma refer√™ncia nula, como resultado de uma das verifica√ß√µes, o link ser√° inicializado.  No entanto, uma s√©rie de verifica√ß√µes n√£o termina com um bloco <i>else</i> .  Isso significa que, em alguns casos raros (ou devido √† refatora√ß√£o no futuro), o link ainda pode permanecer zero.  Em seguida, ele ser√° passado para o m√©todo <i>SetupNameTable</i> , onde √© usado sem nenhuma verifica√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Este √© um c√≥digo potencialmente inseguro. <br><br>  E mais um erro, em que o analisador teve que passar por uma cadeia de chamadas para identificar um problema: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> Poss√≠vel desrefer√™ncia nula.  Considere inspecionar o 'layout'.  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  O analisador afirma que √© poss√≠vel obter uma refer√™ncia nula do m√©todo <i>GetAnchorInfo</i> , que emitir√° uma exce√ß√£o ao calcular o valor <i>esquerdo</i> .  Vamos percorrer toda a cadeia de chamadas e verificar se √© assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  De fato, em alguns casos, o m√©todo <i>GetObject</i> que fecha a cadeia de chamadas retornar√° <i>nulo</i> , que sem nenhuma verifica√ß√£o adicional ser√° passado para o m√©todo de chamada.  Provavelmente, o m√©todo <i>GetAnchorDestination</i> deve prever essa situa√ß√£o. <br><br>  No c√≥digo WinForms, havia alguns desses erros, <b>mais de 70</b> .  Eles s√£o todos semelhantes e eu n√£o darei sua descri√ß√£o no artigo. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3091</a> An√°lise emp√≠rica.  √â poss√≠vel que um erro de digita√ß√£o esteja presente dentro da cadeia literal: "ShowCheckMargin".  A palavra 'ShowCheckMargin' √© suspeita.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Um bom exemplo de erro que n√£o √© t√£o f√°cil de detectar.  Ao inicializar os campos de classe, eles usam o mesmo valor, embora o autor do c√≥digo obviamente n√£o tenha pensado (culpar copiar e colar).  O analisador chegou a essa conclus√£o comparando os nomes das vari√°veis ‚Äã‚Äãe os valores das seq√º√™ncias atribu√≠das.  Eu dei apenas as linhas de erro, mas veja como fica no editor de c√≥digo: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Quadro 2"></div><br>  √â a detec√ß√£o de tais erros que demonstra o poder e o cuidado infinito das ferramentas de an√°lise est√°tica. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3095</a> O objeto 'currentForm' foi usado antes de ser verificado com valor nulo.  Verifique as linhas: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  Cl√°ssico  A vari√°vel <i>currentForm √©</i> usada sem nenhuma verifica√ß√£o.  Mas ainda mais no c√≥digo, verifica-se a igualdade <i>nula</i> .  Nesse caso, posso aconselh√°-lo a ter mais cuidado ao trabalhar com tipos de refer√™ncia, al√©m de usar analisadores est√°ticos :). <br><br>  Outro erro semelhante: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3095</a> O objeto 'backgroundBrush' foi usado antes de ser verificado com valor nulo.  Verifique as linhas: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  No c√≥digo WinForms, encontrei mais <b>de 60</b> desses erros.  Na minha opini√£o, todos eles s√£o bastante cr√≠ticos e requerem a aten√ß√£o dos desenvolvedores.  Mas no artigo n√£o √© t√£o interessante falar sobre eles, ent√£o vou me limitar aos dois discutidos acima. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3125</a> O objeto '_propInfo' foi usado e verificado contra nulo em diferentes ramifica√ß√µes de execu√ß√£o.  Verifique as linhas: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Para completar a imagem - tamb√©m uma esp√©cie de cl√°ssico, bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3125</a> .  A situa√ß√£o inversa.  No in√≠cio, uma refer√™ncia potencialmente nula √© usada com seguran√ßa, verificando se √© <i>nula</i> , mas elas n√£o fazem mais isso no c√≥digo. <br><br>  E outro erro semelhante: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3125</a> O objeto 'propriet√°rio' foi usado depois que foi verificado contra nulo.  Verifique as linhas: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  Beleza  Mas isso √© do ponto de vista de um pesquisador externo.  De fato, al√©m desses dois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3125s</a> , o analisador encontrou mais <b>de 50</b> padr√µes semelhantes no c√≥digo WinForms.  Os desenvolvedores t√™m trabalho a fazer. <br><br>  E finalmente - um erro bastante interessante, na minha opini√£o. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3137</a> A vari√°vel 'hCurrentFont' √© atribu√≠da, mas n√£o √© usada no final da fun√ß√£o.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Vamos ver o que o analisador alertou e por que o fato de uma vari√°vel receber um valor, mas n√£o ser usado mais no m√©todo, pode indicar um problema. <br><br>  Uma classe parcial √© declarada no arquivo <i>DeviceContext2.cs</i> .  O m√©todo <i>DisposeFont √©</i> usado para liberar recursos depois de trabalhar com gr√°ficos: contexto do dispositivo e fontes.  Para uma melhor compreens√£o, <i>forne√ßo o</i> m√©todo <i>DisposeFont</i> inteiro.  Preste aten√ß√£o na vari√°vel local <i>hCurrentFont</i> .  O problema √© que declarar essa vari√°vel em um m√©todo oculta o campo de classe com o mesmo nome.  Encontrei dois m√©todos da classe <i>DeviceContext em</i> que um <b>campo</b> chamado <i>hCurrentFont √© usado</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  D√™ uma olhada no m√©todo <i>ResetFont</i> .  A √∫ltima linha √© exatamente o que o m√©todo <i>DisposeFont faz</i> no bloco aninhado <i>se</i> (o analisador aponta para esse local).  E esse campo <i>hCurrentFont</i> com o mesmo nome foi <i>declarado</i> em outra parte da classe parcial no arquivo <i>DeviceContext.cs</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Assim, um erro √≥bvio foi cometido.  Outra quest√£o √© a sua criticidade.  Agora, como resultado do m√©todo <i>DisposeFont trabalhando</i> na se√ß√£o marcada com o coment√°rio ‚Äúselecione a fonte inicial de volta‚Äù, o campo <i>hCurrentFont</i> n√£o receber√° um valor inicial.  Eu acho que apenas os autores do c√≥digo podem dar um veredicto exato. <br><br>  <b>Conclus√µes</b> <br><br>  Ent√£o, desta vez eu tenho que "repreender" a MS um pouco.  No WinForms, houve muitos erros que exigem muita aten√ß√£o dos desenvolvedores.  Talvez isso se deva a alguma pressa com a qual a MS est√° trabalhando no .NET Core 3 e componentes, incluindo o WinForms.  Na minha opini√£o, o c√≥digo WinForms ainda est√° "√∫mido", mas espero que a situa√ß√£o mude em breve para melhor. <br><br>  A segunda raz√£o para um grande n√∫mero de erros pode ser que nosso analisador ficou melhor ao procurar por eles :). <br><br>  A prop√≥sito, um artigo do meu colega Sergey Vasiliev ser√° publicado em breve, no qual ele pesquisar√° e encontrar√° alguns problemas no c√≥digo das bibliotecas do .NET Core.  Espero que o trabalho dele tamb√©m contribua para melhorar o desempenho da plataforma .NET, porque sempre tentamos comunicar os resultados da an√°lise de seus projetos aos desenvolvedores. <br><br>  Bem, para aqueles que desejam melhorar seus produtos por conta pr√≥pria ou realizar pesquisas para encontrar erros nos projetos de outras pessoas, sugiro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fazer o download e experimentar o</a> PVS-Studio. <br><br>  Todo o c√≥digo limpo! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WinForms: erros, Holmes</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462807/">https://habr.com/ru/post/pt462807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462795/index.html">Esquema declarativo e o que h√° de errado com ele no Magento 2</a></li>
<li><a href="../pt462797/index.html">E novamente sobre as nuvens, n√£o apenas os profissionais</a></li>
<li><a href="../pt462799/index.html">RAVIS e DAB em um come√ßo baixo. DRM ofendido. O estranho futuro do r√°dio digital da Federa√ß√£o Russa</a></li>
<li><a href="../pt462803/index.html">Migra√ß√£o de um sistema ERP para outro</a></li>
<li><a href="../pt462805/index.html">An√°lise: como o dinheiro √© realmente protegido ao negociar na bolsa</a></li>
<li><a href="../pt462809/index.html">WinForms: erros, Holmes</a></li>
<li><a href="../pt462813/index.html">Ecaterimburgo, 14 de agosto - Grupo de Usu√°rios Atlassian mitap</a></li>
<li><a href="../pt462815/index.html">Meu terceiro dia com o Haiku: todo o cen√°rio come√ßa a tomar forma</a></li>
<li><a href="../pt462817/index.html">Relat√≥rio Kotlin / Everywhere - Pr√°tica de demonstra√ß√£o: 31 de julho</a></li>
<li><a href="../pt462819/index.html">Defici√™ncias no ensino de idiomas na CEI: uma vis√£o poliglota</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>