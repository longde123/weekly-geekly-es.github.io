<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏫 ❗️ 🎅🏻 ZIO & Cats Effect: aliansi yang berhasil ✖️ ⤵️ 🐁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect telah menjadi semacam “Aliran Reaktif” untuk dunia Scala fungsional, memungkinkan Anda untuk menggabungkan seluruh ekosistem perpustakaan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: aliansi yang berhasil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect telah menjadi semacam “Aliran Reaktif” untuk dunia Scala fungsional, memungkinkan Anda untuk menggabungkan seluruh ekosistem perpustakaan yang beragam menjadi satu. <br><br>  Banyak perpustakaan yang luar biasa: http4s, fs2, doobie - diimplementasikan hanya berdasarkan kelas tipe dari Cats Effect.  Dan pustaka seperti ZIO dan Monix, pada gilirannya, menyediakan instance dari kelas tipe ini untuk tipe efeknya.  Meskipun ada beberapa masalah yang akan diperbaiki pada versi 3.0, Cats Effect membantu banyak kontributor open source untuk secara organik mendukung seluruh ekosistem fungsional bahasa Scala.  Pengembang yang menggunakan Efek Kucing dihadapkan pada pilihan yang sulit: penerapan efek yang akan digunakan untuk aplikasi mereka. <br><br>  Hari ini ada tiga alternatif: <br><br><ul><li>  IO Kucing, implementasi referensi; </li><li>  Monix, tipe data Tugas dan reaktivitasnya dalam kode; </li><li>  ZIO, tipe data ZIO dan cakupan lintas-threading-nya. </li></ul><br>  Dalam posting ini saya akan mencoba membuktikan kepada Anda bahwa untuk membuat aplikasi Anda menggunakan Cats Effect, ZIO adalah pilihan yang baik dengan solusi desain dan kemampuan yang sangat berbeda dari implementasi referensi di Cats IO. <br><a name="habracut"></a><br><h2>  1. Arsitektur MTL / Tagless-Final yang lebih baik </h2><br>  MTL (Monad Transformers Library) adalah gaya pemrograman yang fungsinya polimorfik berdasarkan jenis efeknya dan mengekspresikan kebutuhannya melalui “type class constraint”.  Di Scala, ini sering disebut gaya tagless-final (meskipun bukan hal yang sama), terutama ketika kelas jenis tidak memiliki undang-undang. <br><br>  Telah diketahui secara umum bahwa tidak mungkin untuk mendefinisikan instance global untuk kelas tipe MTL klasik seperti Writer and State, serta untuk tipe efek seperti Kucing IO.  Masalahnya adalah bahwa instance dari kelas tipe ini untuk jenis efek ini memerlukan akses ke keadaan bisa berubah, yang tidak dapat dibuat secara global, karena membuat keadaan bisa berubah juga merupakan efek. <br><br>  Untuk kinerja terbaik, bagaimanapun, penting untuk menghindari "transformator monad" dan memberikan implementasi Write dan State secara langsung, di atas jenis efek utama. <br><br>  Untuk mencapai ini, pemrogram Scala menggunakan trik: mereka membuat contoh (tetapi bersih) di tingkat atas program mereka dengan efek dan kemudian memberikan mereka lebih lanjut dalam program sebagai implikasi lokal: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Terlepas dari kenyataan bahwa trik semacam itu berguna, itu masih "penopang".  Dalam dunia yang ideal, semua instance kelas tipe bisa koheren (satu instance per tipe), dan tidak dibuat secara lokal, menghasilkan efek, dan kemudian secara ajaib membungkus diri dalam nilai implisit untuk digunakan dengan metode selanjutnya. <br><br>  Fitur hebat dari MTL / tagless-final adalah Anda dapat langsung mendefinisikan sebagian besar contoh di atas tipe data ZIO menggunakan lingkungan ZIO. <br><br>  Berikut adalah salah satu cara untuk membuat definisi MonadState global untuk tipe data ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Sebuah instance sekarang didefinisikan secara global untuk setiap lingkungan yang mendukung setidaknya <code>State[S]</code> . <br><br>  Demikian pula untuk <code>FunctorListen</code> , atau dikenal sebagai <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Dan tentu saja, kita dapat melakukan hal yang sama untuk <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Teknik ini mudah diterapkan pada kelas tipe lain, termasuk kelas tipe tag-final, yang instansinya mungkin memerlukan efek hasil (perubahan, konfigurasi), fungsi pengujian yang menghasilkan efek (menggabungkan efek lingkungan dengan tagless-final), atau hal lain yang mudah diakses dari lingkungan . <br><br>  Tidak ada lagi transformasi monadik yang lambat!  Katakanlah “tidak” untuk menciptakan efek ketika menginisialisasi instance kelas kelas, ke implikasi lokal.  Tidak perlu lagi kruk.  Perendaman langsung dalam pemrograman fungsional murni. <br><br><h2>  2. Menyimpan sumber daya untuk manusia biasa </h2><br>  Salah satu fitur pertama ZIO adalah interraption - kemampuan runtime ZIO untuk secara instan menginterupsi setiap efek yang dapat dieksekusi dan dijamin untuk membebaskan semua sumber daya.  Implementasi kasar fitur ini mengenai Cats IO. <br><br>  Haskell menyebut pengecualian fungsi seperti itu sebagai sinkronisasi, yang memungkinkan Anda untuk membuat dan menggunakan latensi secara efisien, operasi paralel dan kompetitif yang efisien, dan perhitungan yang optimal secara global.  Gangguan seperti itu tidak hanya membawa manfaat besar, tetapi juga menimbulkan tugas rumit di bidang mendukung akses yang aman ke sumber daya. <br><br>  Pemrogram digunakan untuk melacak kesalahan dalam program melalui analisis sederhana.  Ini juga dapat dilakukan dengan ZIO, yang menggunakan sistem tipe untuk membantu mendeteksi kesalahan.  Tetapi gangguan adalah hal lain.  Efek yang dibuat dari banyak efek lain dapat terganggu di perbatasan mana pun. <br><br>  Pertimbangkan efek berikut: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  Sebagian besar pengembang tidak akan terkejut dengan skenario ini: <code>closeFile</code> tidak akan dieksekusi jika <code>readFile</code> lumpuh.  Untungnya, sistem efek memiliki <code>ensuring</code> ( <code>guarantee</code> dalam Efek Kucing) yang memungkinkan Anda untuk menambahkan penangan akhir ke efek finalizer, mirip dengan akhirnya. <br><br>  Jadi, masalah utama dari kode di atas dapat dengan mudah diselesaikan: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Sekarang efeknya telah menjadi "tahan jatuh", dalam arti bahwa jika <code>readFile</code> rusak, file akan tetap ditutup.  Dan jika <code>readFile</code> berhasil, file tersebut juga akan ditutup.  Dalam semua kasus, file akan ditutup. <br><br>  Tapi masih belum sepenuhnya.  Gangguan berarti bahwa efeknya dapat terganggu di mana-mana, bahkan antara <code>openFile</code> dan <code>openFile</code> .  Jika ini terjadi, file yang terbuka tidak akan ditutup dan kebocoran sumber daya akan terjadi. <br><br>  Pola mendapatkan dan melepaskan sumber daya begitu luas sehingga ZIO memperkenalkan operator braket, yang juga muncul dalam Cats Effect 1.0.  Pernyataan Bracket melindungi terhadap gangguan: jika sumber daya diterima dengan sukses, maka pelepasan akan terjadi bahkan jika efek menggunakan sumber daya terganggu.  Selanjutnya, baik penerimaan maupun pelepasan sumber daya tidak dapat terganggu, sehingga memberikan jaminan keamanan sumber daya. <br><br>  Menggunakan braket, contoh di atas akan terlihat seperti ini: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Sayangnya, braket merangkum hanya satu pola konsumsi sumber daya (cukup umum).  Ada banyak lainnya, terutama dengan struktur data kompetitif, akses yang harus dapat diakses untuk interupsi, jika tidak, kebocoran mungkin terjadi. <br><br>  Secara umum, semua pekerjaan interupsi bermuara pada dua hal utama: <br><br><ul><li>  mencegah interupsi di beberapa area yang mungkin terganggu; </li><li>  memungkinkan gangguan di area yang mungkin membeku. </li></ul><br>  ZIO memiliki kemampuan untuk mengimplementasikan keduanya.  Misalnya, kita dapat mengembangkan versi braket sendiri menggunakan abstraksi ZIO tingkat rendah: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  Dalam kode ini, <code>use(a)</code> adalah satu-satunya bagian yang dapat diinterupsi.  Kode di sekitarnya menjamin eksekusi <code>release</code> dalam hal apa pun. <br><br>  Kapan saja, Anda dapat memeriksa apakah ada peluang untuk gangguan.  Untuk ini, hanya dua operasi primitif yang diperlukan (semua sisanya berasal dari mereka). <br><br>  Model interupsi fitur lengkap komposisi ini memungkinkan Anda untuk menerapkan tidak hanya implementasi braket sederhana, tetapi juga menerapkan skenario lain dalam manajemen sumber daya, di mana keseimbangan ditemukan antara kelebihan dan kekurangan interupsi. <br><br>  IO Kucing hanya menyediakan satu operasi untuk mengendalikan interupsi: kombinator yang tidak dapat dibatalkan.  Itu membuat seluruh blok kode tidak terganggu.  Meskipun operasi ini jarang digunakan, ini dapat menyebabkan kebocoran sumber daya atau kunci. <br><br>  Pada saat yang sama, ternyata Anda dapat mendefinisikan primitif di dalam Cats IO, yang memungkinkan Anda mencapai kontrol lebih besar atas interupsi.  Implementasi Fabio Labella yang sangat rumit ternyata sangat lambat. <br><br>  ZIO memungkinkan Anda untuk menulis kode dengan interupsi, beroperasi pada tingkat tinggi dengan pernyataan gabungan deklaratif, dan tidak memaksa Anda untuk memilih antara kerumitan parah yang dikombinasikan dengan kinerja rendah dan pemblokiran kebocoran. <br><br>  Selain itu, Memori Transaksional Perangkat Lunak yang baru ditambahkan dalam ZIO memungkinkan pengguna untuk secara deklaratif menulis struktur data dan kode yang secara otomatis tidak sinkron, kompetitif, dan memungkinkan gangguan. <br><br><h2>  3. Finalizers yang Dijamin </h2><br>  Blok coba / akhirnya dalam banyak bahasa pemrograman memberikan jaminan yang diperlukan untuk menulis kode sinkron tanpa membocorkan sumber daya. <br><br>  Secara khusus, blok ini menjamin yang berikut: jika blok try memulai eksekusi, maka blok akhirnya akan mengeksekusi ketika try berhenti. <br><br>  Garansi ini berlaku untuk: <br><br><ul><li>  ada blok "coba / akhirnya" bersarang; </li><li>  ada kesalahan dalam "coba blok"; </li><li>  ada kesalahan di blok akhirnya bersarang. </li></ul><br>  Operasi “memastikan” ZIO dapat digunakan seperti mencoba / akhirnya: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO memberikan jaminan berikut untuk "effect.ensuring (finalizer)": jika "effect" mulai dieksekusi, maka "finalizer" akan memulai eksekusi ketika "effect" berhenti. <br><br>  Seperti coba / akhirnya, jaminan ini tetap dalam kasus berikut: <br><br><ul><li>  Ada komposisi "memastikan" bersarang; </li><li>  ada kesalahan dalam "efek"; </li><li>  ada kesalahan dalam "finalizer" bersarang. </li></ul><br>  Selain itu, jaminan dipertahankan bahkan jika efeknya terganggu (jaminan pada "braket" serupa, pada kenyataannya, "braket" diterapkan pada "memastikan"). <br><br>  Tipe data IO Kucing memberikan jaminan lain yang lebih lemah.  Untuk "effect.guarantee (finalizer)", itu dilemahkan sebagai berikut: jika "effect" mulai dieksekusi, "finalizer" akan memulai eksekusi ketika "effect" berhenti, jika efek masalah tidak dimasukkan ke dalam "effect". <br><br>  Jaminan yang lebih lemah juga ditemukan dalam penerapan "braket" di Kucing IO. <br><br>  Untuk mendapatkan sumber daya bocor, cukup gunakan efek yang digunakan di dalam efek "jaminan" atau "bracket.use", buat dengan sesuatu seperti ini: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Ketika bigTrouble dimasukkan dengan cara ini ke efek lain, efeknya menjadi tidak terganggu - tidak ada "finalizers" yang ditetapkan melalui "jaminan", atau pembersihan sumber daya melalui "braket" tidak akan dieksekusi.  Semua ini mengarah pada pengurasan sumber daya, bahkan ketika ada "finalizer" di blok. <br><br>  Misalnya, "finalizer" dalam kode berikut tidak akan pernah memulai eksekusi: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!«)))</span></span></code> </pre> <br>  Ketika mengevaluasi kode tanpa mempertimbangkan konteks global, tidak mungkin untuk menentukan apakah suatu efek, seperti "bigTrouble", akan dimasukkan di mana saja dalam efek "penggunaan" operasi "braket" atau di dalam blok "finalizer". <br><br>  Karenanya, Anda tidak akan dapat mengetahui apakah program IO Kucing akan bekerja dengan kebocoran sumber daya atau kehilangan blok "penyelesai" tanpa mengevaluasi keseluruhan program.  Seluruh program hanya dapat dievaluasi secara manual, dan proses ini selalu disertai dengan kesalahan yang tidak dapat diverifikasi oleh kompiler.  Selain itu, proses ini harus diulang setiap kali terjadi perubahan penting pada kode. <br><br>  ZIO memiliki implementasi kustom "jaminan" dari Cats Effect, "guaranteeCase" dan "bracket".  Implementasi menggunakan semantik ZIO asli (bukan Semantik Kucing IO), yang memungkinkan kami untuk mengevaluasi kemungkinan masalah dengan kebocoran sumber daya di sini dan sekarang, mengetahui bahwa dalam semua situasi, finalizer akan diluncurkan dan sumber daya akan dibebaskan. <br><br><h2>  4. Pergantian yang stabil </h2><br>  Cats Effect memiliki metode "evalOn" dari "ContextShift", yang memungkinkan Anda untuk memindahkan eksekusi beberapa kode ke konteks eksekusi lainnya. <br><br>  Ini berguna karena sejumlah alasan: <br><br><ul><li>  banyak perpustakaan klien memaksa Anda untuk melakukan beberapa pekerjaan di kumpulan utangnya; </li><li>  Perpustakaan UI memerlukan beberapa pembaruan untuk terjadi di utas UI; </li><li>  beberapa efek memerlukan isolasi pada kolam ulir yang disesuaikan dengan fitur spesifiknya. </li></ul><br>  Operasi "EvalOn" mengeksekusi efek di mana ia harus dijalankan, dan kemudian kembali ke konteks eksekusi asli.  Sebagai contoh: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Catatan: Kucing IO memiliki konstruksi "shift" yang serupa, yang memungkinkan Anda untuk beralih ke konteks yang berbeda tanpa kembali, tetapi dalam praktiknya, perilaku ini jarang diperlukan, jadi "evalOn" lebih disukai. <br><br>  Implementasi ZIO dari "evalOn" (dibuat pada "kunci" ZIO primitif) memberikan jaminan yang diperlukan untuk secara unik memahami di mana efek bekerja - efeknya akan selalu dieksekusi dalam konteks tertentu. <br><br>  IO Kucing memiliki jaminan yang berbeda dan lebih lemah - efeknya akan dieksekusi dalam konteks tertentu hingga operasi asinkron pertama atau pengalihan internal. <br><br>  Mempertimbangkan sepotong kecil kode, tidak mungkin untuk mengetahui dengan pasti apakah efek asinkron (atau pengalihan bersarang) akan dibangun ke dalam efek yang akan beralih, karena asinkron tidak ditampilkan dalam tipe. <br><br>  Oleh karena itu, seperti dalam hal keamanan sumber daya, untuk memahami di mana efek IO Kucing akan diluncurkan, perlu mempelajari seluruh program.  Dalam praktiknya, dan dari pengalaman saya, pengguna Cats IO terkejut ketika, ketika menggunakan "evalOn" dalam satu konteks, kemudian ditemukan bahwa sebagian besar efeknya secara tidak sengaja dilakukan di lain. <br><br>  ZIO memungkinkan Anda untuk menentukan di mana efek harus dipicu, dan percaya bahwa itu akan terjadi dalam semua kasus, tidak peduli bagaimana efek dibangun ke efek lainnya. <br><br><h2>  5. Keamanan pesan kesalahan </h2><br>  Setiap efek yang mendukung konkurensi, konkurensi, atau akses aman ke sumber daya akan mengalami model kesalahan linier: secara umum, tidak semua kesalahan dapat disimpan. <br><br>  Ini berlaku untuk `Throwable`, tipe kesalahan tetap yang ada pada Kucing IO, dan tipe kesalahan polimorfik yang didukung oleh ZIO. <br><br>  Contoh situasi dengan beberapa kesalahan satu kali: <br><br><ul><li>  Finalizer melempar pengecualian; </li><li>  dua (jatuh) efek digabungkan dalam eksekusi paralel; </li><li>  dua efek (jatuh) dalam kondisi balap; </li><li>  efek terputus turun sebelum meninggalkan bagian terlindung dari gangguan. </li></ul><br>  Karena tidak semua kesalahan disimpan, ZIO menyediakan struktur data "Penyebab [E]" berdasarkan semiring gratis (abstraksi dari aljabar abstrak, pengetahuannya tidak seharusnya ada di sini), yang memungkinkan menghubungkan kesalahan serial dan paralel untuk semua jenis kesalahan.  Selama semua operasi (termasuk pembersihan untuk efek yang jatuh atau terganggu), ZIO mengumpulkan kesalahan ke dalam struktur data "Penyebab [E]".  Struktur data ini tersedia kapan saja.  Sebagai hasilnya, ZIO selalu menyimpan semua kesalahan: mereka selalu tersedia, mereka dapat dicatat, dipelajari, dan ditransformasikan sesuai dengan persyaratan bisnis. <br><br>  IO Kucing memilih model dengan informasi kesalahan yang hilang.  Sementara ZIO akan menghubungkan dua kesalahan melalui Penyebab [E], Kucing IO akan "kehilangan" salah satu pesan kesalahan, misalnya, dengan memanggil "e.printStackTrace ()" pada kesalahan yang terjadi. <br><br>  Misalnya, kesalahan dalam "finalizer" dalam kode ini akan hilang. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2«)))</span></span></code> </pre> <br>  Pendekatan ini untuk melacak kesalahan berarti bahwa Anda tidak dapat menemukan dan memproses seluruh spektrum kesalahan yang terjadi secara lokal karena kombinasi efek.  ZIO memungkinkan Anda untuk menggunakan jenis kesalahan apa pun, termasuk "Throwable" (atau subtipe lebih spesifik seperti "IOExceptio" atau hierarki pengecualian kustom lainnya), memastikan bahwa tidak ada kesalahan yang hilang selama eksekusi program. <br><br><h2>  6. Asynchrony tanpa deadlock </h2><br>  Baik ZIO dan Cats IO menyediakan konstruktor yang memungkinkan Anda untuk mengambil kode dengan panggilan balik dan membungkusnya dengan efektif <br><br>  Fitur ini disediakan melalui kelas pipa Async di Cats Effect: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Ini menciptakan efek asinkron, yang, ketika dieksekusi, akan menunggu sampai nilai muncul, dan kemudian melanjutkan, dan semua ini akan jelas bagi pengguna efek.  Oleh karena itu, pemrograman fungsional sangat menarik untuk mengembangkan kode asinkron. <br><br>  Perhatikan bahwa segera setelah kode panggilan balik berubah menjadi efek, fungsi panggilan balik (ini disebut `k`) dipanggil.  Fungsi panggilan balik ini keluar dengan nilai sukses / kesalahan.  Ketika fungsi panggilan balik ini dipanggil, eksekusi efek (yang sebelumnya dijeda) dilanjutkan. <br><br>  ZIO menjamin bahwa efek akan melanjutkan eksekusi pada kumpulan thread runtime jika efek tidak ditugaskan ke konteks khusus tertentu, atau ke konteks lain di mana efek itu dilampirkan. <br><br>  IO Kucing melanjutkan efeknya pada utas panggilan balik.  Perbedaan antara opsi-opsi ini cukup dalam: utas yang menyebabkan panggilan balik tidak mengharapkan kode panggilan balik dijalankan selamanya, tetapi hanya memungkinkan sedikit penundaan sebelum kontrol kembali.  Di sisi lain, Kucing IO sama sekali tidak memberikan jaminan seperti itu: utas panggilan, panggilan balik peluncuran, dapat membeku, menunggu waktu yang tidak terbatas ketika kontrol eksekusi kembali. <br><br>  Versi sebelumnya dari struktur data kompetitif dalam Cats Effect ("Deferred", "Semaphore") melanjutkan efek yang tidak mengembalikan kontrol eksekusi ke utas panggilan.  Akibatnya, masalah yang terkait dengan kebuntuan dan penjadwalan eksekusi yang rusak ditemukan di dalamnya.  Meskipun semua masalah ini telah ditemukan, mereka hanya diperbaiki untuk struktur data kompetitif di Cats Effect. <br><br>  Kode pengguna yang menggunakan pendekatan yang sama seperti pada Kucing IO akan masuk ke masalah seperti itu, karena tugas-tugas seperti itu tidak deterministik, kesalahan hanya bisa terjadi sangat jarang di runtime, membuat debugging dan deteksi masalah menjadi proses yang sulit. <br><br>  ZIO memberikan perlindungan kebuntuan dan penjadwal tugas normal di luar kotak, dan juga membuat pengguna secara eksplisit memilih perilaku Kucing IO (misalnya, menggunakan "unsafeRun" pada "Janji", yang berakhir dengan efek asinkron yang dilanjutkan). <br><br>  Meskipun tidak ada solusi yang cocok untuk semua kasus, dan ZIO dan Kucing IO memberikan fleksibilitas yang cukup untuk menyelesaikan semua situasi (dengan cara yang berbeda), memilih ZIO berarti menggunakan "Async" tanpa kekhawatiran dan memaksa Anda untuk memasukkan kode masalah ke "unsafeRun", yang diketahui menyebabkan kebuntuan <br><br><h2>  7. Kompatibel dengan Masa Depan </h2><br>  Menggunakan "Masa Depan" dari perpustakaan standar Scala adalah kenyataan untuk sejumlah besar basis kode.  ZIO hadir dengan metode "fromFuture", yang menyediakan konteks eksekusi yang sudah jadi: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Ketika metode ini digunakan untuk membungkus masa depan dalam efek, ZIO dapat mengatur di mana masa depan akan dieksekusi, dan metode lain, seperti evalOn, akan mentransfer masa depan dengan benar ke konteks eksekusi yang diinginkan.  Cats IO menerima "Future", yang dibuat dengan "ExecutionContext" eksternal.  Ini berarti bahwa IO Kucing tidak dapat memindahkan eksekusi Masa Depan sesuai dengan persyaratan metode evalOn atau shift.  Selain itu, ini membebani pengguna dengan menentukan konteks eksekusi untuk Masa Depan, yang berarti seleksi yang sempit dan lingkungan yang terpisah. <br><br>  Karena ExecutionContext yang diberikan dapat diabaikan, ZIO dapat direpresentasikan sebagai jumlah fitur IO Kucing, yang menjamin interaksi yang lebih lancar dan lebih akurat dengan Future dalam kasus umum, tetapi masih ada pengecualian. <br><br><h2>  8. Memblokir IO </h2><br>  Seperti yang ditunjukkan pada artikel “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thread Pool.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik terbaik dengan ZIO</a> ”, untuk aplikasi server, setidaknya dua kumpulan terpisah diperlukan untuk efisiensi maksimum: <br><br><ul><li>  kumpulan tetap untuk efek CPU / asinkron; </li><li>  dinamis, dengan kemungkinan meningkatkan jumlah utas pemblokiran. </li></ul><br>  Keputusan untuk menjalankan semua efek pada kumpulan utas tetap suatu hari akan menyebabkan kebuntuan, sementara memicu semua efek pada kumpulan dinamis dapat menyebabkan hilangnya kinerja. <br><br>  Pada JVM, ZIO menyediakan dua operasi yang mendukung efek pemblokiran: <br><br><ul><li>  "Blocking (effect" operator, yang mengalihkan eksekusi efek tertentu dalam kumpulan thread yang memiliki preset yang baik yang dapat diubah jika diinginkan); </li><li> «effectBlocking(effect)» ,          ,        . </li></ul><br>     ,     ,       ,       «blocking».   ,    -    ,  ,       «effectBlocking»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     «blocking»,    «evalOn», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> «ReaderT»/ «Kleisli»,       ; </li><li> «EitherT»,      ( «OptionT»,     «EitherT»   «Unit»    ). </li></ul><br>    ,          (, http4s   «Kleisli»  «OptionT»).        («effect totation»), ZIO   «reader»  «typed error»      ZIO.         «reader»  «typed error» , ZIO    ,    . , «Task[A]»,    «reader»  «typed errors». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   «reader»  «typed errors»      «state», «writer»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    «typed errors»  ,       —     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  «Runtime»,      Cats Effect  -   Cats Effect).  —        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br></li><li>      ,        «».   ZIO    IDE. </li><li>      Scala  ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry». </li><li>         «». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO —  - ,           . <br><br>     : <br><br><ul><li>     ,  «Ref», «Promise», «Queue», «Semaphore»   «Stream»    //; </li><li> STM,       , ,     ; </li><li> «Schedule»,    ; </li><li>    «Clock», «Random», «Console»  «System» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Kesimpulan </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      —    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472386/">https://habr.com/ru/post/id472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472372/index.html">Otomatisasi Android Panduan super mudah untuk membuat tes Espresso pertama Anda</a></li>
<li><a href="../id472374/index.html">Mengapa kami memindahkan server ke Islandia</a></li>
<li><a href="../id472378/index.html">Keandalan flash: diharapkan dan tidak terduga. Bagian 2. Konferensi XIV dari asosiasi USENIX. Teknologi penyimpanan file</a></li>
<li><a href="../id472380/index.html">MIRO - platform robot terbuka dalam ruangan</a></li>
<li><a href="../id472384/index.html">Melihat pembaruan Android dari perspektif pengembang</a></li>
<li><a href="../id472388/index.html">Walmart menyatakan perang harga Amazon</a></li>
<li><a href="../id472392/index.html">Kenaikan, kejatuhan, dan kemungkinan kembalinya kaset audio - kita berurusan dengan mitos dan memberikan gambaran tentang situasinya</a></li>
<li><a href="../id472394/index.html">Menilai dampak kecerdasan buatan pada minyak dan gas lepas pantai</a></li>
<li><a href="../id472396/index.html">Around the World dalam 4 Detik di Columnstore (Bagian 1)</a></li>
<li><a href="../id472402/index.html">Streaming panggilan video RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>