<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚖️ 👨🏻‍🌾 📈 Pourquoi Jaop? Pourquoi raquette? 🖐🏾 🔌 🥪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la suite de l'article «Pourquoi une raquette? Pourquoi Lisp? " J'ai écrit environ un an après avoir découvert Racket . En tant que débuta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi Jaop? Pourquoi raquette?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445822/"> Il s'agit de la suite de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Pourquoi une raquette?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi Lisp? "</a>  J'ai écrit environ un an après avoir découvert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Racket</a> .  En tant que débutant, je ne pouvais pas comprendre les éloges qui ont coulé sur Lisp de tous les côtés.  Je ne savais que penser.  Comment comprendre que Lisp finira par provoquer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«illumination profonde»</a> .  D'accord, mon frère, dites-vous. <br><br>  J'avais une question simple: à <b>quoi</b> ça <b>sert?</b>  Dans un article précédent, j'ai essayé d'y répondre et j'ai résumé les raisons pour lesquelles quelqu'un voudrait apprendre le Lisp ou, en particulier, le Racket. <br><br>  J'ai compilé une liste des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">neuf fonctionnalités linguistiques les</a> plus précieuses pour moi en tant que novice de Racket.  Par exemple, la caractéristique numéro 5 est «la création de nouveaux langages de programmation».  Cette méthode est également appelée <i>programmation orientée langage</i> ou <i>JOP</i> . <br><a name="habracut"></a><br>  Depuis lors, IOP est devenu ma partie préférée de Racket, et j'ai partagé mon admiration dans le livre en ligne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Beautiful Racket</a> , qui explique la technique ROP et l'outil Racket. <br><br>  Un exemple dans mon travail est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pollen</a> .  J'ai écrit ce langage de programmation pour une typographie pratique de mes livres en ligne.  Dans Pollen, le paragraphe précédent est programmé comme suit: <br><br><pre><code class="plaintext hljs">#lang pollen     ◊link["https://beautifulracket.com/appendix/why-racket-why-lisp.html#so-really-whats-in-it-for-me-now"]{  },        Racket. ,  № 5 — «   ».     ◊em{- },  ◊em{}.</code> </pre> <br>  Un autre exemple est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">brag</a> , un générateur d'analyseur (dans le style de <code>lex/yacc</code> ), qui prend la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grammaire BNF</a> comme code source.  Un exemple simple pour le langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bf</a> : <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Les deux langues sont implémentées dans Racket et peuvent être exécutées avec l'interpréteur Racket habituel ou à l'intérieur de Racket IDE (appelé DrRacket). <br><br><h1>  Problèmes principaux </h1><br>  Et pourtant ... Malgré le fait que le livre ait forcé des milliers de personnes à commencer à explorer Racket, il me semble parfois que je marche sur le même terrain rapide que les fans de Lisp que j'ai un jour critiqué. <br><br>  Si NOP est si cool, alors pourquoi passer quelques jours à lire un livre.  Non?  Je peux tout expliquer brièvement, sans plus tarder.  Il faut répondre à deux questions simples: <br><br><ol><li>  Quels problèmes conviennent le mieux à la programmation linguistique? <br></li><li>  Pourquoi Racket est-il le meilleur pour créer des langues? </li></ol><br>  La deuxième question est simple.  Le premier ne l'est pas.  On m'a demandé à plusieurs reprises.  J'ai souvent cité la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">célèbre</a> phrase du juge Potter Stewart: vous la comprendrez quand vous la verrez.  La réponse est assez bonne pour ceux qui sont vraiment intéressés.  Mais pas pour ceux qui sont du côté et qui aimeraient entendre des arguments de fond. <br><br>  Je vais donc essayer.  Gardez à l'esprit que je ne suis pas professeur d'informatique et que je ne peux pas parler de la théorie des langages de programmation.  J'utilise plutôt le racket et les langages spécifiques au domaine (DSL) à des fins pratiques: mon travail quotidien en dépend.  Par conséquent, je me concentrerai sur les aspects pratiques. <br><br><h1>  Réponse courte </h1><br><ol><li>  JOP est en fait une méthode de conception d'interface.  Il est idéal pour les tâches qui nécessitent <b>une notation minimale</b> tout en conservant <b>une précision maximale</b> .  La notation minimale signifie la seule notation autorisée.  Rien de plus.  La précision maximale, c'est-à-dire la signification de cette notation, est exactement ce que vous dites.  Aucune ambiguïté ou schéma.  IOP arrive au point comme rien d'autre. <br><br>  (L'impatient peut passer à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des catégories spécifiques de tâches</a> qui bénéficieront du NOP). <br></li><li>  La raquette est idéale pour OOP en raison de son <b>système de macro</b> .  Ils fonctionnent dans le style du compilateur, simplifiant la conversion de code.  Le système de macro Racket est meilleur que tout autre. </li></ol><br>  À ce stade, la moitié des lecteurs de l'article voudront publier des commentaires anonymes critiquant mes thèses.  Mais n'oubliez pas: en tout cas, j'ai gagné.  JOP et Racket ont incroyablement augmenté ma productivité de programmation.  Je suis heureux de partager ces connaissances afin que vous puissiez vous aussi profiter de ces avantages.  Mais je serai également heureux si ces outils restent mon arme secrète.  Dans ce cas, je resterai dans 0,01% des programmeurs les plus productifs, obtenant un résultat plus impressionnant et rentable que les 99,9% restants <br><br>  Donc, le choix vous appartient. <br><br><h1>  Réponse longue </h1><br>  Si vous pensez aux questions les plus importantes, elles se résument à une méta-question: pourquoi est-il difficile d'expliquer les avantages des armes nucléaires? <br><br>  Peut-être que lorsque nous parlons de <i>langues</i> , le terme est chargé d'attentes sur ce qu'est une langue et ce qu'elle fait.  Bien que nous soyons à l'intérieur de ce paradigme, il est difficile de comprendre la valeur des langages de programmation. <br><br>  Mais si vous réduisez l'échelle et considérez les langues comme faisant partie d'une catégorie plus large d'interfaces homme-ordinateur, il est plus facile de voir les avantages spécifiques de la POO.  Alors faisons-le. <br><br><h1>  Langues à usage général et langues thématiques </h1><br>  Tout d'abord, un peu de terminologie.  La programmation orientée langage (également connue sous le nom de POO) est l'idée de résoudre des problèmes de programmation en créant un nouveau langage, puis en écrivant un programme dessus.  Ces "petites langues" sont souvent appelées langues spécifiques au domaine (DSL). <br><br>  Comme son nom l'indique, une langue orientée sujet est adaptée aux tâches d'un certain domaine.  Par exemple, PostScript, SQL, <code>make</code> , les expressions régulières, <code>.htaccess</code> et HTML sont considérés comme des langages orientés sujet.  Ils n'essaient pas de tout faire.  Ils visent plutôt à bien faire une chose. <br><br>  À l'autre extrémité du spectre se <i>trouvent les langages à usage général</i> .  Nous voyons ici C, Pascal, Perl, Java, Python, Ruby, Racket, etc. Pourquoi ne sont-ils pas considérés comme orientés sujet?  Parce qu'ils se positionnent pour un large éventail de tâches informatiques. <br><br>  Dans la pratique, les langues d'usage général se spécialisent souvent dans un domaine particulier.  Par exemple, C est meilleur que d'autres pour la programmation système.  Perl - pour les scripts dans l'administration système.  Python s'impose comme un langage pour les débutants.  Raquette pour une programmation orientée langage.  Dans chaque cas, c'est à cela que la langue a été conçue à l'origine. <br><br>  Il y a une fine ligne entre le DSL et les langages à usage général.  Par exemple, Ruby a été créé en tant que langage à usage général, mais est devenu populaire principalement pour les applications Web grâce à son association avec Ruby on Rails.  JavaScript, d'autre part, était à l'origine un langage orienté sujet pour les scripts de navigateur Web.  Mais il a muté comme un virus et depuis, il a grandi bien au-delà de la tâche d'origine. <br><br><h1>  Qu'est-ce qu'une langue? </h1><br>  Si tout ce large spectre est appelé langues, alors quelles sont les caractéristiques qui définissent la langue? <br><br>  Je sais ce que vous pensez: «C'est là que vous vous trompez.  HTML n'est pas une langue.  C'est juste du balisage.  Il ne peut pas décrire l'algorithme. "  Ou: «Les expressions régulières ne sont pas une langue.  Ils ne travaillent pas seuls.  C'est juste une syntaxe pour une autre langue. " <br><br>  Je le pensais aussi.  Mais plus je regardais de plus près, plus ces différences semblaient floues.  Ainsi, ma première déclaration principale (sur trois): le langage de programmation est intrinsèquement un moyen d'échange - <b>un système de notation qui est compréhensible pour les personnes et les ordinateurs</b> . <br><br>  Le système de notation (notation) signifie que le langage a une syntaxe.  «Clair» signifie qu'avec sa syntaxe le langage véhicule un <i>sens</i> (ou une <i>sémantique</i> , si vous utilisez un mot plus sophistiqué).  Cette définition couvre tous les langages de programmation à usage général.  Et tout DSL.  (Mais pas tous les flux de données, qui seront discutés plus en détail plus tard). <br><br>  (Soit dit en passant, bien que «programmation» et «langage» soient des mots idiomatiquement utilisés ensemble, ces langages ne sont pas seulement utilisés par des personnes pour programmer des ordinateurs. Parfois, ils sont utilisés par des ordinateurs pour communiquer avec nous (par exemple, des expressions S), parfois pour communiquer entre eux. (par exemple, XML, JSON, HTML.) Certainement, il semble incorrect d'exclure ces fonctionnalités. Mais dans la pratique, oui - ce que nous faisons habituellement avec un langage de programmation est, en fait, de la programmation). <br><br>  Considérez le code HTML: un moyen de dire à un ordinateur - en particulier un navigateur Web - comment dessiner une page Web.  Il s'agit d'un système de notation (crochets, balises, attributs, etc.) compréhensible pour les humains et les ordinateurs (l'attribut <code>charset</code> indique l'encodage des caractères, la balise <code>p</code> contient un paragraphe, etc.). <br><br>  Voici une petite page HTML: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My web page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>world<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Supposons que vous ne conveniez pas que HTML est un langage de programmation.  Bon.  Nous afficherons notre page en Python.  C'est un vrai langage de programmation, non? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;!DOCTYPE html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;meta charset=\"UTF-8\"&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;title&gt;My web page&lt;/title&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;p&gt;Hello &lt;strong&gt;world&lt;/strong&gt;&lt;/p&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span></code> </pre> <br>  Si Python est un langage de programmation, mais pas HTML, alors cet exemple Python est un programme, mais l'exemple HTML ne l'est pas. <br><br>  Évidemment, c'est une différence torturée.  Ici, la pythonisation n'ajoute rien d'autre que de la complexité et des stéréotypes.  Ce qui est piquant, c'est que le seul contenu sémantique intéressant dans un programme Python - du point de vue de la gestion d'un navigateur Web - est qu'il est incorporé en HTML (peut-être que les balises HTML telles que <code>DOCTYPE</code> , <code>meta</code> et <code>strong</code> peuvent être considérées comme des fonctions qui prennent des arguments).  La logique nous amène à conclure que le HTML, bien que plus simple et moins flexible, est toujours un langage de programmation. <br><br><h1>  Langues intégrées </h1><br>  Un exemple avec HTML et Python que nous avons trouvé.  Mais l'intégration de DSL dans une autre langue est omniprésente.  Les langages utilisés de cette manière sont appelés <i>embarqués</i> .  Ils représentent la forme de programmation linguistique la plus courante.  En tant que programmeur, vous comptez sur JOP depuis de nombreuses années, même si vous ne connaissiez pas son nom. <br><br>  Par exemple, les expressions régulières (autres exemples: <code>printf</code> pour formater les chaînes, CLDR pour les modèles de date / heure, SQL).  Nous ne pouvons pas considérer l'expression régulière comme une langue indépendante.  Mais chaque programmeur sait ce que c'est: <br><br><pre> <code class="plaintext hljs">^fo+(bar)*$</code> </pre> <br>  De plus, vous pouvez probablement saisir cette expression régulière dans votre langage de programmation préféré et cela fonctionnera simplement.  Ce comportement cohérent n'est possible que parce que la notation des expressions régulières est un langage externe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POSIX</a> ). <br><br>  Comme avec HTML, nous pourrions écrire une expression équivalente dans la notation du langage hôte.  Par exemple, Racket prend en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les expressions régulières Scheme</a> (SRE): ce sont des expressions régulières avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> notation d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expression S.</a>  Le modèle ci-dessus sera écrit comme ceci: <br><br><pre> <code class="plaintext hljs">(seq bos "f" (+ "o") (* (submatch "bar")) eos)</code> </pre> <br>  Mais les programmeurs de raquettes utilisent rarement les expressions SRE.  Ils sont trop longs et difficiles à retenir. <br><br>  Un autre exemple omniprésent de DSL intégré: les expressions mathématiques.  Chaque programmeur sait ce que cela signifie: <br><br><pre> <code class="plaintext hljs">(1 + 2) * (3 / 4) - 5</code> </pre> <br>  Les expressions mathématiques seules ne créent pas de programmes intéressants.  Nous devons les combiner avec d'autres constructions de langage.  Mais, comme pour les expressions régulières, il s'agit d'un dossier ergonomique et pratique.  Les expressions mathématiques ont leur propre notation et leurs propres significations qui sont compréhensibles à la fois pour les personnes et les ordinateurs, elles peuvent donc être considérées comme un langage intégré distinct. <br><br><h1>  Plaisantez-vous que HTML est en train de programmer? </h1><br>  Non, ça l'est.  J'affirme que le HTML (à la fois les expressions régulières et les expressions mathématiques) peut être considéré comme un langage de programmation rudimentaire.  Cela signifie que l'écriture de HTML (ou d'expressions régulières ou d'expressions mathématiques) est considérée comme une programmation rudimentaire. <br><br>  Ne paniquez pas.  Bien sûr, un "programmeur" sur LinkedIn ne connaissant que le HTML et l'arithmétique, cela n'a aucun sens (bien que dans une semaine, il obtiendra probablement un emploi pour 180 000 $).  Mais c'est une question distincte, que signifie «programmeur» sur le marché du travail.  Nous n'en parlons pas. <br><br><h1>  Piège de la totalité de Turing </h1><br>  Si cette définition des langages de programmation vous agace encore, vous pensez peut-être qu'un vrai langage de programmation devrait exprimer tous les algorithmes possibles - c'est-à-dire qu'il devrait être <i>Turing complet</i> . <br><br>  Je comprends qu'une telle pensée se suggère intuitivement.  Chaque langage de programmation à usage général est Turing complet. <br><br>  Mais le problème est qu'il s'agit d'une barre basse.  L'exhaustivité de Turing est une métrique technique qui ne correspond pas à l'utilisation du langage dans le monde réel.  Par exemple, les expressions régulières ne sont pas complètes de Turing, mais elles sont utiles pour exprimer de nombreux calculs avec des notations minimales.  HTML n'est pas non plus Turing complet, mais c'est un moyen utile de contrôler le navigateur.  Au contraire, le langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bf</a> est Turing complet, mais même les tâches les plus triviales nécessitent des kilomètres de code infranchissable. <br><br><h1>  Restrictions linguistiques </h1><br>  Est-ce que quelque chose relève de ma définition de la langue?  Non. <br><br><ul><li>  <i>Les formats de données binaires ne sont</i> pas considérés comme des langues.  Par exemple, un fichier <code>jpeg</code> .  Bien qu'un ordinateur puisse les comprendre, une personne ne le comprend pas.  Ou PDF: si vous le piratez, il y a des parties lisibles par l'homme.  Mais cela est dû au fonctionnement du PDF.  Il est inutile d'écrire des idées à l'aide de constructions PDF. <br></li><li>  <i>Les fichiers texte ne</i> sont pas des langues.  Supposons que nous ayons un dossier avec l'Iliade d'Homère.  Nous, humains, pouvons le lire et le comprendre.  Bien que l'ordinateur puisse traiter le fichier de manière triviale en imprimant, par exemple, son contenu, le texte qu'il contient est incompréhensible pour l'ordinateur. <br></li><li>  <i>Les interfaces utilisateur graphiques</i> ne sont pas des langues.  Oui, ce sont des systèmes de notation (qui dépendent du texte et de l'image).  Mais ils ne sont compréhensibles que par les gens.  Les ordinateurs dessinent une interface graphique mais ne les comprennent pas. </li></ul><br><h1>  Les langues comme interfaces </h1><br>  Ci-dessus, j'ai décrit le langage de programmation comme un "moyen d'échange" entre les gens et les ordinateurs.  Ainsi, les langues entrent dans une catégorie plus large, que nous appelons <i>interfaces</i> . <br><br>  Cela conduit à la deuxième affirmation de base (sur trois): que la <b>programmation de langage est fondamentalement une méthode de conception d'une interface</b> .  Si vous aimez penser aux interfaces, vous aimerez JOP.  Sinon, vous aimerez toujours JOP pour avoir rendu possibles des interfaces qui seraient autrement inaccessibles. <br><br>  Un de mes exemples préférés de langage en tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'interface</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">brag</a> , un langage générateur d'analyseur créé avec Racket.  Si vous avez déjà utilisé la chaîne d'outils lex / yacc, vous savez que souvent l'objectif est de générer un analyseur à partir d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grammaire BNF</a> .  Par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bf,</a> cela ressemble à ceci: <br><br><pre> <code class="plaintext hljs">bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre><br>  Pour créer un analyseur dans un langage à usage général, vous devez traduire cette grammaire en un tas de code natif.  C'est un travail fastidieux.  Et inutile - n'avons-nous pas déjà écrit la grammaire?  Pourquoi recommencer? <br><br>  Cependant, <code>brag</code> répond à notre désir.  Pour faire l'analyseur, nous ajoutons simplement la ligne <code>#Lang brag</code> au fichier, qui convertit comme par magie la grammaire BNF en code source de <code>brag</code> : <br><br><pre> <code class="plaintext hljs">#Lang brag bf- : (Bf-op | Bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "."| "," Bf-loop : "["(Bf-op | Bf-loop)* "]"</code> </pre> <br>  C'est fait!  Lors de la compilation, ce fichier exporte la fonction d' <code>parse</code> , qui implémente cette grammaire BNF. <br><br>  C'est l'un de mes exemples préférés car il est indéniablement supérieur aux autres options.  De plus, avec un langage généraliste, une telle interface est pratiquement impossible. <br><br>  Mais un programmeur JOP crée constamment de telles interfaces. <br><br><a name="1"></a><h1>  Où la langue est la meilleure interface </h1><br>  Cela m'amène à ma troisième et dernière thèse de base selon laquelle les <b>langues ont des avantages uniques par rapport aux interfaces</b> .  Bien entendu, les catégories ci-dessous ne sont ni exhaustives ni exclusives.  Mais j'ai trouvé que l'IOP a beaucoup à offrir dans de telles situations: <br><br>  1. Lorsque vous souhaitez créer une interface pour des programmeurs moins qualifiés, des non-programmeurs ou des programmeurs paresseux (ne sous-estimez pas la taille de cette dernière catégorie). <br><br>  Par exemple, Racket possède une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque d'applications Web</a> sophistiquée.  Mais un simple serveur Web peut également être démarré rapidement en utilisant le langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>web-server/insta</code></a> : <br><br><pre> <code class="plaintext hljs">#lang web-server/insta (define (start request) (response/xexpr '(html (body "Hello LOP World"))))</code> </pre> <br>  Matthew Flatt dans son article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Créer des langues dans une raquette"</a> montre le langage qui génère des aventures de texte jouables.  Comme <code>brag</code> , cela ressemble plus à une spécification qu'à un programme, mais cela fonctionne: <br><br><pre> <code class="plaintext hljs">#lang txtadv ===VERBS=== north, n "go north" south, s "go south" get _, grab _, take _ "get" ===THINGS=== ---cactus--- get "Ouch!" ===PLACES=== ---desert--- "You're in a desert. There is nothing for miles around." [cactus, key] north meadow south desert</code> </pre> <br>  2. Lorsque vous souhaitez simplifier la notation.  Un exemple est les expressions régulières.  Un autre exemple est ma langue orientée sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pollen</a> pour écrire des livres en ligne.  Pollen est similaire à Racket, seulement ici vous commencez à travailler en mode texte et utilisez des caractères spéciaux pour indiquer les commandes Racket qui sont intégrées dans le contenu (Pollen est basé sur le langage de documentation de Racket appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scribble</a> , qui prend la majeure partie de la charge).  Ainsi, le début de ce paragraphe est programmé comme suit: <br><br><pre> <code class="plaintext hljs">    .    —  .   —  -  ◊link["https://pollenpub.com/"]{Pollen}   -.</code> </pre> <br>  Pollen se soucie de coller toutes les balises nécessaires et de les convertir en HTML infaillible.  J'ai toujours tous les avantages du balisage manuel (contrôle total sur la page), mais pas d'inconvénients (par exemple, je ne peux pas accidentellement laisser une balise non fermée). <br><br>  Un autre exemple de notation simplifiée est <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lindenmayer</a></code> , le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système de</a> génération et de dessin fractal du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système Lindenmayer</a> , comme celui-ci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/e10/ffe/f98e10ffe99b9f7efbb052ddaf4097a5.png"></div><br><br>  Dans une raquette typique, un programme Lindenmayer pourrait ressembler à ceci: <br><br><pre> <code class="plaintext hljs">#lang racket/base (require lindenmayer/simple/compile) (define (finish val) (newline)) (define (A value) (display 'A)) (define (B value) (display 'B)) (lindenmayer-system (void) finish 3 (A) (A -&gt; AB) (B -&gt; A))</code> </pre> <br>  Mais vous pouvez utiliser la notation simplifiée en changeant simplement la notation <code>#lang</code> en haut du fichier: <br><br><pre> <code class="plaintext hljs">#lang lindenmayer/simple ## axiom ## A ## rules ## A -&gt; AB B -&gt; A ## variables ## n=3</code> </pre> <br>  La langue suppose que vous connaissez déjà le système L.  Mais une notation simplifiée permet d'écrire facilement vos souhaits dans un programme qui fait ce que vous voulez. <br><br>  3. Lorsque vous souhaitez travailler avec une notation existante.  Nous avons vu ci-dessus comment <code>brag</code> utilise la grammaire BNF comme code source. <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Un autre exemple.  Les gens qui ont essayé Pollen ont dit: «Oui, c'est super, mais je préfère Markdown.»  Pas de problème: <code>pollen/markdown</code> est un dialecte Pollen qui offre la sémantique Pollen mais accepte la notation Markdown habituelle: <br><br><pre> <code class="markdown hljs">    .    —  .   —  -  [<span class="hljs-string"><span class="hljs-string">Pollen</span></span>](<span class="hljs-link"><span class="hljs-link">"https://pollenpub.com/"</span></span>)   -.</code> </pre> <br>  La chose la plus agréable?  J'ai écrit ce dialecte en seulement une heure, en combinant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur Markdown</a> avec le code existant. <br><br>  4. Si vous souhaitez créer une cible intermédiaire pour d'autres langues.  JSON, YAML, les expressions S et XML sont tous des langages orientés sujet qui définissent les formats de données pour la lecture et l'écriture sur machine. <br><br>  Dans Perfect Racket, un langage de formation est appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>jsonic</code></a> .  Il vous permet d'incorporer des expressions de raquette dans JSON, rendant ainsi JSON programmable.  Le code source ressemble à ceci: <br><br><pre> <code class="json hljs">#lang jsonic // a line comment [ @$ '<span class="hljs-literal"><span class="hljs-literal">null</span></span> $@, @$ (* <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) $@, @$ (= <span class="hljs-number"><span class="hljs-number">2</span></span> (+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) $@, @$ (list <span class="hljs-string"><span class="hljs-string">"array"</span></span> <span class="hljs-string"><span class="hljs-string">"of"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span>) $@, @$ (hash 'key<span class="hljs-number"><span class="hljs-number">-1</span></span> '<span class="hljs-literal"><span class="hljs-literal">null</span></span> 'key<span class="hljs-number"><span class="hljs-number">-2</span></span> (even? <span class="hljs-number"><span class="hljs-number">3</span></span>) 'key<span class="hljs-number"><span class="hljs-number">-3</span></span> (hash 'subkey <span class="hljs-number"><span class="hljs-number">21</span></span>)) $@ ]</code> </pre> <br>  Compile en JSON ordinaire: <br><br><pre> <code class="json hljs">[ <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-string"><span class="hljs-string">"array"</span></span>,<span class="hljs-string"><span class="hljs-string">"of"</span></span>,<span class="hljs-string"><span class="hljs-string">"strings"</span></span>], {<span class="hljs-attr"><span class="hljs-attr">"key-1"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-attr"><span class="hljs-attr">"key-3"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"subkey"</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span>},<span class="hljs-attr"><span class="hljs-attr">"key-2"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} ]</code> </pre> <br>  5. Lorsque la partie principale du programme est la configuration.  Par exemple, les fichiers Dot peuvent être décrits comme DSL.  Un exemple plus complexe de Racket est le Riposte de Jesse Alama, un langage pour tester l'API HTTP basée sur JSON: <br><br><pre> <code class="plaintext hljs">#lang riposte $productId := 41966 $qty := 5 $campaignId := 1 $payload := { "product_id": $productId, "campaign_id": $campaignId, "qty": $qty } POST $payload cart/{uuid}/items responds with 200 $itemId := /items/0/cart_item_id GET cart responds with 200</code> </pre> <br>  En tant que langage de script miniature, Riposte est beaucoup plus intelligent que le dotfile moyen.  Il masque tout le code intermédiaire nécessaire pour les transactions HTTP et permet à l'utilisateur de se concentrer sur l'écriture de tests.  C'est toujours le ménage.  Mais au moins, vous pouvez vous concentrer sur le ménage dont vous vous souciez. <br><br><h1>  Pourquoi raquette? </h1><br>  Souvent, les critiques de JOP demandent: «Pourquoi créer un langage orienté sujet?  Est-il plus facile d'écrire une bibliothèque native? " <br><br>  Non, ce n'est pas plus facile si vous avez le bon outil.  La raquette est inhabituelle: elle est conçue de A à Z spécifiquement pour YOP.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, l'implémentation de DSL sur Racket est plus rapide, moins chère et plus facile que les alternatives. Par exemple, dans la première leçon de mon livre, j'ai montré comment développer un nouveau langage en une heure - même si vous n'avez jamais utilisé Racket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous le capot de chaque DSL dans Racket, le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilateur source à source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionne réellement </font><font style="vertical-align: inherit;">, ce qui convertit la notation et la sémantique DSL en un programme Racket équivalent. Pour cette raison, Racket DSL ne pourra pas fonctionner aussi vite que le code C écrit manuellement. Mais alors tous les outils et bibliothèques Racket sont disponibles pour chaque DSL. Vous perdez en productivité, mais gagnez à plusieurs reprises en commodité. Et lorsque la création d'une DSL est pratique et facile, elle devient une option réaliste pour un éventail de problèmes beaucoup plus large.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, pour répondre à la critique - non, DSL ne nécessite pas nécessairement plus de travail que la bibliothèque native. </font><font style="vertical-align: inherit;">De plus, comme nous l'avons déjà vu, en tant qu'interface, un langage peut faire ce qu'une bibliothèque native ne peut pas faire.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourquoi macro? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que tous les DSL sont compilés dans Racket, le programmeur doit écrire des transformateurs de syntaxe qui convertissent la notation DSL en Racket natif. </font><font style="vertical-align: inherit;">Ces convertisseurs de syntaxe sont appelés </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En fait, ils peuvent être décrits comme des extensions du compilateur Racket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système macro Racket est vaste, élégant et est sans aucun doute la perle de sa couronne. </font><font style="vertical-align: inherit;">Une grande partie de mon livre traite du plaisir de travailler avec les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Racket. </font><font style="vertical-align: inherit;">Je peux nommer deux fonctions exceptionnelles:</font></font><br><br><ol><li>  Racket    ,   <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a></i> .     .    ,      ,   Racket   ,     ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> .           ( .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">« »</a> ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les macros de raquette sont </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hygiéniques</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire que par défaut le code créé par la macro préserve le contexte lexical à partir duquel la macro est définie. </font><font style="vertical-align: inherit;">En pratique, cela élimine l'énorme quantité de gestes inutiles qui sont généralement requis pour DSL (pour plus de détails, voir le chapitre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Hygiène»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est-il possible d'implémenter DSL dans, disons, Python? </font></font> Bien sûr.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, j'ai écrit ma première DSL spécifiquement en Python - et je l'utilise toujours dans mon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travail de conception de type</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eh bien, ça. </font><font style="vertical-align: inherit;">Une seule fois a suffi. </font><font style="vertical-align: inherit;">Depuis lors, j'utilise Racket.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion: victoire avec YaOP </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour le moment, vous pouvez avoir l'une des deux réactions suivantes: </font></font><br><br><ol><li> <i>«  ,    ,    »</i> . ,          . ,    ,       .       .        .      ,       .         . <br></li><li> <i>«,   ,     c    Racket    »</i> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>  ,     -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Riposte</a> , —         (  ): <br><br><blockquote> [ ]     -  Racket. ,  ,    -     …             : «     API  ,   ?»  : «  Riposte».  ,   ,  [DSL],   ,   .    «» Racket.   <b> DSL  ,   </b> . </blockquote></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À la fin de l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Pourquoi une raquette? </font><font style="vertical-align: inherit;">Pourquoi Lisp? " </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit que le langage Lisp "vous donne l'opportunité de libérer votre potentiel en tant que programmeur et penseur et ainsi augmenter vos attentes sur ce que vous pouvez réaliser." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOP offre une opportunité similaire: augmenter nos attentes concernant ce que les langages de programmation peuvent faire pour nous. </font><font style="vertical-align: inherit;">Les langues ne sont pas des boîtes noires. </font><font style="vertical-align: inherit;">Ce sont les interfaces que nous pouvons concevoir. </font><font style="vertical-align: inherit;">Dans le même temps, nous ouvrons de nouvelles possibilités pour ce qui peut être fait à l'aide de programmes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous pouvez trouver la meilleure technique de programmation, utilisez-la. </font><font style="vertical-align: inherit;">Maintenant que j'ai OOP et Racket, je ne reviendrai jamais.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lectures complémentaires </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">« Racket»</a>   ( ).       .    —    ,     Racket     . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Racket 2019</a> .    Racket     :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">« Racket»</a> ( )   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«  »</a> (  Racket). <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«   Racket:  »</a>  .  ,   —     ,      «» ( ),     ,      . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«   Racket»</a>  .  —   Racket (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   ).           DSL   DSL    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> DSL,   Racket,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445822/">https://habr.com/ru/post/fr445822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445806/index.html">Comment l'intelligence artificielle change la science</a></li>
<li><a href="../fr445808/index.html">Nous détestons et chassons: la vie dangereuse d'un pirate de virus qui se fait de puissants ennemis</a></li>
<li><a href="../fr445814/index.html">Comment un robot de livraison a changé les habitudes culinaires des étudiants américains</a></li>
<li><a href="../fr445816/index.html">Comment nous avons vu le rendu du serveur et ce qui en est ressorti</a></li>
<li><a href="../fr445820/index.html">MVCC-3. Versions en ligne</a></li>
<li><a href="../fr445824/index.html">Génération de code dans Dart. Partie 1. Bases</a></li>
<li><a href="../fr445826/index.html">On marche sagement autour de la ville - 2: on fait le tour de la ville en rond en utilisant l'algorithme génétique</a></li>
<li><a href="../fr445828/index.html">Spectre solaire chinois</a></li>
<li><a href="../fr445832/index.html">Rayonnement: le tueur invisible et ses filles ou un peu sur le radon</a></li>
<li><a href="../fr445834/index.html">Développer les compétences d'utilisation du regroupement et de la visualisation des données en Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>