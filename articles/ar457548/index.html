<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏼 🕸️ 🌔 توليد إشارة PWM متعددة المراحل على TMS320F28027 👩🏻‍🎨 🔎 🏴󠁧󠁢󠁥󠁮󠁧󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ذات مرة  في مجرة ​​بعيدة بعيدة  كتبت مقالة قصيرة حول وحدة التحكم Piccolo المتخصصة من Texas Instruments ، والتي صممت للتحكم في محولات الطاقة والمحركات ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>توليد إشارة PWM متعددة المراحل على TMS320F28027</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  ذات مرة <del>  في مجرة ​​بعيدة بعيدة </del>  كتبت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالة قصيرة</a> حول وحدة التحكم Piccolo المتخصصة من Texas Instruments ، والتي صممت للتحكم في محولات الطاقة والمحركات الكهربائية.  أدوات التحكم هذه أدوات تطوير قوية جدًا في العديد من المهام وأردت أن أكتب شيئًا آخر عنها ... بسيط ومفيد. </p><br><p style=";text-align:right;direction:rtl">  لقد شعرت بالحيرة مؤخرًا لتطوير وحدة تحكم للتحكم في المحركات ، وبناءً على ذلك ، تم تشكيل موضوع لهذه المقالة - اليوم سأتحدث عن عملية تشكيل PWM ثلاثية الطور للتحكم في المحركات ، وكذلك شرح الاختلافات المفيدة بين TMS320F28 ووحدات التحكم الأخرى مثل STM32F334 و STM32G484 و XMC4200 وغيرها. </p><br><p style=";text-align:right;direction:rtl">  كحامل ، سأستخدم وحدة التحكم قيد التطوير ، للأسف ، لا أستطيع التحدث عن الجزء الحديدي بالتفصيل.  ومع ذلك ، إذا قلت أن وحدة التحكم مبنية على أساس حزمة TMS320F28027 + DRV8353RSRGZT ، فيمكنك الاطلاع على ورقة بيانات برنامج التشغيل ورؤية مفهوم الدائرة العامة + هناك تصحيح الأخطاء على هذا الحجر والتصميم المرجعي مفتوح عليه. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="سائق BLDC"></p><br><p style=";text-align:right;direction:rtl">  من حيث المبدأ ، على نفس النوع من الدوائر ، من الممكن التحكم في محركات BLDC التي تستهلك مستويات الجهد و 3 مراحل العادية ، والتي تريد بالفعل إخراج الجيبية.  سأعرض كلا الخيارين ، كما  الطريق إلى الجيب يكمن في تشكيل مستويات الجهد. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="الذبذبات رقم 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze" style=";text-align:right;direction:rtl">  قليلا عن الحديد </h1><br><p style=";text-align:right;direction:rtl">  يتكون الجزء القوي للسائق من الناحية الأيديولوجية من 3 محولات نصف جسر ، وربما يتم تصنيع جميع أجهزة التحكم والتحكم في محركات BLDC في جميع المروحيات بطريقة مماثلة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="ثلاث مراحل الجسر"></p><br><p style=";text-align:right;direction:rtl">  فرق واحد - ليس لدي المعدل المدخلات ، لأنه  يتم تشغيل وحدة التحكم في البداية بجهد ثابت.  مصدر الطاقة في حالتي هو مجموعة من بطاريات li-ion في شكل 18650 خلية ، يمكن للسائق DRV8353RSRGZT المستخدم التحكم في 3 جسور نصف فقط من الطاقة ، وكذلك في الإصدار المستخدم من الحجر ، كما يوجد أيضًا مضخمات صوتية مدمجة للعمل مع shunts كمستشعرات حالية مدمجة العاصمة / العاصمة ، والتي يمكن أن تهضم ما يصل إلى 70 ... 80V ويتم تكوين كل هذا بمرونة كبيرة عبر SPI.  على سبيل المثال ، من المريح للغاية أن تكون قادرًا على ضبط الحد الأقصى الحالي لنبض التحكم في الترانزستور. </p><br><p style=";text-align:right;direction:rtl">  أيضًا في هذه السلسلة ، توجد برامج تشغيل مع مجموعة مختلفة من الوظائف ، على سبيل المثال ، هناك مع التحكم التناظرية ، وليس SPI أو بدون العاصمة / العاصمة وبدون المرجع أمبير.  بالنسبة للسعر ، فهي ليست مختلفة تمامًا وأخذت أكثر "جرأة" كما قد تكون فهمت بالفعل.  هذا الأمر كله يبدو جميلًا جدًا ، لكنني اقتربت تصميمًا ملائمًا من تصميم السائق وتسببت في مشكلتين كبيرتين.  في الواقع ، هناك مشكلة واحدة فقط - وهذه مشكلة ارتفاع درجة الحرارة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="تصوير حراري"></p><br><p style=";text-align:right;direction:rtl">  ولكن سبب هذه المشكلة سببان.  في الواقع جوهر المشكلة هو ارتفاع درجة حرارة السائق نفسه.  على الرسم البياني ، يتم تحميل السائق مع تيار 5A (بالنسبة له هو تقريبا الخمول) ولا شيء سوى السائق و MK نفسه يتم تسخينها قليلا.  الترانزستورات ليست واضحة حتى ، لديهم درجة حرارة ثنائي الفينيل متعدد الكلور ، في 5A هناك خسائر حرارة ضئيلة. </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>خطأ رقم 1</strong> <br>  لقد طلب مني صديق لي ، بصراحة ، كنت أفكر في هذا الأمر باعتباره آخر شيء - لدى السائق وحدة تحكم تيار مستمر / تيار مستمر ، والذي يستقبل 15 ... 50V مدخلات ومخرجات 3.3 فولت لتشغيل MK ، والمنطق ، والمقارنة ، ومكبرات الصوت التشغيلية.  يبدو أن مشاريعي تحتوي على رقائق LM5008 و LM5017 في شكل رقائق منفصلة وقد خفضت بهدوء 60 فولت إلى 3.3 فولت دون تسخين ملحوظ بمعدل 100-150 مللي أمبير ، لكن تبين أن كل شيء أصبح أكثر صعوبة - تحولت الكفاءة الإجمالية للمحول إلى حوالي 65-70٪ في الوقت الحالي 300 مللي أمبير!  والحقيقة هي أن المحول نفسه يمكن أن يعطي 3.3V ، ولكن الكفاءة ستكون ضئيلة ، فمن الأفضل لضبط الجهد الناتج 10-12-15V.  عندما كان الناتج 12V 100 مللي أمبير ، توقف السائق عن الاحماء عملياً ، وبلغت الكفاءة 88٪.  <strong>يكمن حل المشكلة</strong> في خفض المدخلات 15 ... من 50 فولت إلى 12 فولت مع العاصمة / العاصمة المدمجة ، ومن ثم خفضها من 12V إلى 3.3V مع العاصمة / العاصمة الخارجية رخيصة بالفعل. </li></ul><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>خطأ رقم 2</strong> <br>  الخطأ الثاني هو أكثر وضوحا وأول ما أخطأت فيه هو ما استطعت.  والحقيقة هي أنه بالنسبة للرقائق الموجودة في حزمة QFN ، تتم إزالة الحرارة الرئيسية من خلال "البطن" ، وعادةً ما يتم وضعها على GND ، ومن خلال عدة vias (عبر) ، تتمسك بالأرض وتنتقل الحرارة إلى هناك بهدوء.  في البداية ، لم أضع في الحسبان الكفاءة الهزيلة للتيار المدمج / المستمر مع اختلاف الجهد الكهربائي الكبير ، لذلك لم يزعجني أن القطرة الحرارية ("البطن") تشبثت بمضلع GND صلب على الطبقة الداخلية ، على الطبقة الخارجية التي لم يكن فيها النحاس تحت البطن كمضلع GND.  نتيجة لذلك ، اتضح أن حوالي 0.5 واط من الحرارة يتم إطلاقها على الرقاقة ، وأنها تتبدد في الطبقة الداخلية للوحة ، أي أن الكفاءة رديئة للغاية.  <strong>يكمن حل المشكلة في</strong> أنك تحتاج إلى إجراء اختبار أرضي على الطبقة الخارجية (الطبقة السفلية) وعدم القيام بذلك: </li></ul><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="لوحة الدوائر"></p><br><p style=";text-align:right;direction:rtl">  نتيجةً لذلك ، في المراجعة الثانية للحديد ، تم تصحيح هذه الأخطاء: تمت إضافة محول تيار مستمر / تيار 12-3.3V وتم إضافة مضلع GND بشكل إضافي على الطبقة السفلية وتم زرع وسادة الرقاقة عليه + وتم الحفاظ على مضلع الأرضية الصلبة الداخلي.  بعد هذه التحسينات ، انخفضت درجة الحرارة في التشغيل المستمر من +82 إلى +43 <sup>درجة</sup> مئوية: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="حراري"></p><br><p style=";text-align:right;direction:rtl">  كما ترون ، نظرًا لانخفاض الفقدان ، انخفضت درجة الحرارة بشكل كبير في ظل نفس الظروف ، كما أن الحرارة موزعة الآن بشكل أكثر توازناً على مساحة اللوحة ولا تسخن محلياً إما السائق أو المتحكم الدقيق.  من حيث المبدأ ، كان كل شيء من الحديد ، ولم يحدث شيء أكثر إثارة للاهتمام وعمل بشكل مستقر.  نتيجة لذلك ، قد يوصون باستخدام برنامج التشغيل <strong>DRV8353</strong> . </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup" style=";text-align:right;direction:rtl">  تنفيذ مرحلة التحول الأجهزة من 120 <sup>س</sup> </h1><br><p style=";text-align:right;direction:rtl">  تتمثل إحدى ميزات الشبكة ثلاثية الطور في أن التيار في المراحل ليس متزامنًا ، ولكن يتم إزاحته بمقدار 120 <sup>o</sup> بالنسبة إلى المرحلة المجاورة.  ما هو هذا التحول 120 <sup>س</sup> المرحلة بشكل عام؟  بعبارات بسيطة ، هذا هو تحول نقطة بداية الجيل بمقدار 1/3 من هذه الفترة.  من وجهة النظر الرياضية ، تكون فترة الإشارة <em>2π</em> ، مما يعني أنه يجب تحريك الإشارة الثانية بمقدار 2π / 3 ، والثالثة بمقدار 4π / 3.  من وجهة نظر إلكترونية ، يتم تعيين الفترة من خلال فترة العد التنازلي لجهاز ضبط الوقت.  على سبيل المثال ، عند تسجيل الوقت بتردد 60 MHz ، نريد الحصول على PWM بتردد 50 كيلو هرتز ، مما يعني أن فترة العد التنازلي المؤقت ستكون من 0 إلى 1200 (60000 Hz / 50 000 Hz = 1200).  الآن ، للحصول على 3 مراحل مع التحول من 120 <sup>درجة ،</sup> لا نحتاج إلى لمس المرحلة الأولى ، إضافة +400 إلى القيمة الحالية للمرحلة الثانية ، إضافة + 800 إلى المرحلة الحالية. </p><br><p style=";text-align:right;direction:rtl">  إذا استخدمنا ميكروكنترولر على لب القشرة ، فيمكننا تنفيذ هذا التحول إما عن طريق كتابة صيغة رياضية أو باستخدام تزامن الأحداث.  كان من المدهش دومًا بالنسبة لي أن ST و NXP وغيرهم لم يسجلوا فقط حيث سيتم كتابة قيمة التحول.  لحسن الحظ ، فعلت TI هذا في TMS320F28xxx ، لتعيين التحول ، فقط اكتب سجل واحد!  لن أخبركم عن السبب في أن حل البرنامج ليس هو الأمثل ، سأقول فقط أنه يعتبر صيغ MK غير سريعة جدًا.  إن الموالية المزامنة من الأحداث أكثر ملاءمة بالفعل ، وفي هذا الوقت سأفعل ذلك ، لكن هذا الخيار لا يسمح بتغيير قيمة الطور أثناء الطيران ، أي بالنسبة لبعض الجسور التي تحولت طورًا مرة أخرى ، يبقى إصدار البرنامج فقط.  هي ميزة القدرة على التحكم في أجهزة المرحلة؟  الأمر متروك لك لتقرير ، ومهمتي هي أن أقول لك أنه من الممكن.  بالنسبة لي ، تعد هذه ميزة إضافية عندما نتحدث عن التحكم في محرك كهربائي أو محولات الجهد الكهربائي بإخراج ثلاثي الطور. </p><br><p style=";text-align:right;direction:rtl">  الآن دعونا تكوين توليد إشارات PWM في شكل 3 أزواج تكميلية مع الوقت الميت وتحول المرحلة.  حتى الآن دون شرط.  سأستخدم الأزواج التالية: EPWM1A + EPWM1B ، EPWM2A + EPWM2B و EPWM4A + EPWM4B.  هذه هي الإشارات التي تنتقل من متحكم إلى السائق. </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>الخطوة 1</strong> <br>  من الضروري تكوين مُضاعِف GPIO بمساعدة سجل <em>GPAMUX</em> للعمل مع PWM وإيقاف عمليات <em>سحب</em> الإخراج إلى مصدر الطاقة ، بحيث عند تشغيل جميع الأرجل لا يكون لها سجل .1 ولا تفتح المفاتيح.  بالتأكيد ستوفر الحماية الحالية ، لكن من الأفضل عدم القيام بذلك.  تجدر الإشارة أيضًا إلى أنه للوصول إلى سجلات الإعداد ، تحتاج إلى الحصول عليها باستخدام الأمر <em>EALLOW</em> ثم إعادة تشغيل الحماية من الكتابة الفوقية باستخدام أمر <em>EDIS</em> . </li></ul><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>الخطوة 2</strong> <br>  إعداد توليد إشارة PWM.  من الضروري الحصول على تردد قدره 50 كيلو هرتز وتحول طور قدره 120 <sup>درجة مئوية</sup> .  في هذه الحالة ، يمكنني استخدام PWM المعتاد ، لأنه في وحدة التحكم هذه توجد أيضًا HRPWM ، من المهم تذكر ذلك.  تم تسجيل الوحدة النمطية PWM في التردد الأساسي ، أي 60 ميجا هرتز ، وأظهرت كيفية ضبط تردد PLL في المقالة الأولى على TMS320 ، ولن أكرر ذلك ، ولكن في نهاية المقالة سيكون هناك أرشيف مع الرمز وسيكون من الممكن إلقاء نظرة خاطفة عليه. </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن ، المزيد من التفاصيل ... في سجل <em>TBPRD</em> ، اكتب الفترة ، أو بالأحرى ، "الفترة / 2" ، لأن  يتم حساب الموقت في كلا الاتجاهين ، واتضح أن الفترة 600 تتوافق مع تردد إشارة خرج PWM البالغة 50 كيلو هرتز في وضع الزوج التكميلي.  في سجل <em>TBPHS</em> نكتب قيمة المرحلة التي نحتاج إلى <em>تحويلها</em> ، في هذه الحالة 400 من 600 ، أي ما يعادل 2π / 3.  تجدر الإشارة إلى أننا لا نتحرك في المرحلة الأولى ، لذلك التحول هو 0 ، بالنسبة للمرحلة الثانية ، يكون التحول 400 ، على التوالي ، ولكن بالنسبة للمرحلة الثالثة ، من المنطقي أن تكتب 800 ، ولكن 800 من 600 بطريقة ما ليس حقًا ... لذلك يكتبون التحول غير المتعلق بالمرحلة الأولى ، ولكن بالنسبة إلى المرحلة السابقة ، أي المرحلة الثانية.  نتيجة لذلك ، حصلنا على ذلك في المرحلة الثالثة نكتب 400 ، وهذا يقابل 2π / 3 بين المرحلة 2 و 3 ، وبما أن المرحلة الثانية قد تحولت بالفعل ، فسيكون هناك "2π / 3 + 2π / 3 = 4π" بين المرحلتين 1 و 3 / 3 "ومن وجهة نظر الإلكترونيات كل شيء يبدو منطقيا. </p><br><p style=";text-align:right;direction:rtl">  من أجل أن تفهم المراحل من يتحرك بالنسبة لمن ، هناك حاجة إلى رئيس ، لذلك تم تعيين <em>EPWM1</em> باستخدام بت <em>PHSEN</em> لإتقان الوضع ، و EPWM2 و EPWM4 ، على التوالي ، كعبيد.  باستخدام بت <em>SYNCOSEL</em> ، يتم <em>أيضًا</em> ضبط "نقطة" <em>التزامن</em> ، أي من أين تقرأ التحول من.  تتم مزامنة EPWM1 ​​مع بداية المؤقت ، أي مع فترة الصفر ، ومزامنة EPWM2 و EPWM4 بالفعل بالنسبة لحافة إشارة القناة السابقة: القناة السابقة لـ EPWM2 هي EPWM1 ​​، وهي EPWM2. </p><br><p style=";text-align:right;direction:rtl">  الآن يبقى لتشغيل أزواج تكميلية وتعيين مدة الميت.  باستخدام بتات <em>POLSEL</em> ، <em>قمنا</em> بتعيين PWM غير معكوس ، أي عند الوصول إلى القيمة المحددة للمقارنة (المرجع) ، يتم إنشاء سجل عند الإخراج.  1. في <em>OUT_MODE ، حددنا</em> توليد الوقت <em>الموقت</em> على الحافة وسقوط الإشارة.  وفقا لذلك ، في سجلات <em>DBFED</em> و <em>DBRED</em> اكتب مدة الوقت الميت في القراد. </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>الخطوة 3</strong> <br>  الآن يبقى لكتابة قيمة عامل الواجب في سجل <em>CMPA</em> المقابلة لكل قناة ويمكنك مراقبة النتيجة. </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="ثلاث مراحل PWM"></p><br><p style=";text-align:right;direction:rtl">  فويلا!  ترتبط تحقيقات الذبذبات بإخراج برنامج التشغيل.  القناة الصفراء هي EPWM1 ​​لدينا ، وهذا هو ، سيد.  القناة الزرقاء هي EPWM2 ويتم إزاحتها 2π / 3 (أو 400 عينة) نسبة إلى القناة الصفراء ، ويتم إزاحة القناة الخضراء 400 عينة أخرى.  وبالتالي نحصل على 3 مراحل ، حيث يتم تبديل كل مرحلة بمقدار 120 <sup>درجة مئوية</sup> . </p><br><p style=";text-align:right;direction:rtl">  دعنا الآن ننقل تحقيقات الذبذبات من مخرج جسر القدرة إلى إشارات التحكم التي تخرج من المتحكم الدقيق وتأكد من وجود وقت وفاة داخل الزوج التكميلي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="الذبذبات رقم 2"></p><br><p style=";text-align:right;direction:rtl">  كما ترون ، فإن الوقت الميت المحدد يتوافق مع الوقت الحقيقي.  مدة العينة الواحدة هي <em>1 / 60،000،000 هرتز = 16.6 نانوثانية</em> ونحصل على 20 عينة ، أي ما يعادل الوقت الميت 20.6 <em>16</em> نانوثانية = 332 نانوثانية ، * وهو ما يقرب من ما لوحظ على الذبذبات. </p><br><p style=";text-align:right;direction:rtl">  في الواقع حيث يمكن أن يأتي هذا في متناول يدي ، في الشكل الذي هو عليه الآن.  الخيار الأكثر وضوحًا هو محولات dc / dc متعددة الأطوار ، للراغبين في google <strong>بمحول dc / dc المتداخل</strong> .  هذا هو حل تقني مثير للاهتمام للغاية يمكن أن يقلل بشكل كبير من حجم محاثات الطاقة ، ويقلل من السعة الإخراج للمكثفات ، وكذلك زيادة الكفاءة.  على TMS320F28027 بسيط ، يمكنك تنفيذ محول من 4 مراحل وسيتم تنفيذ كل هذا ببساطة في الكود وفي الأجهزة فقط. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie" style=";text-align:right;direction:rtl">  نحن نولد جهد التيار المتردد ثلاثي المراحل </h1><br><p style=";text-align:right;direction:rtl">  في العديد من المشاكل ، لن يكون كافياً للحصول على قيم منفصلة من 0 أو VCC عند الخرج ؛ هناك حاجة إلى موجة جيبية.  لدي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقال</a> يتحدث عن تشكيل جهد التيار المتردد أحادي الطور ويتم استخدام الطريقة "المجدولة" هناك ، أي تم حساب قيم الموجة الجيبية في البداية.  من حيث المبدأ ، يمكن القيام بذلك أيضًا من أجل المراحل الثلاث ، لكنني أرغب في عرض خيار بديل ، ألا وهو حساب قيمة الواجب في الوقت الفعلي أو أثناء الطيران. </p><br><p style=";text-align:right;direction:rtl">  هناك ميزة واحدة.  تردد PWM في هذه الحالة هو أيضًا 50 كيلو هرتز ويتم ضبط إزاحة الطور بين فترات هذه الإشارة.  وفقًا لذلك ، عندما نقوم بتعديل الجيوب الأنفية بتردد 50 هرتز ، سيتم "تغيُّر" مرحلة طور الأجهزة ، وستظل موجودة بين PWMs ، ولكن ليس داخل الجيوب الأنفية ، لذلك يجب أن يتم ذلك برمجيات.  علم المثلثات هو شيء ثقيل بالنسبة إلى TMS320F28027 ، لكنه ليس مشغولًا جدًا معي ، لذلك دعه يحسب.  إذا كان لديك مهمة تتطلب الكثير من العمليات الحسابية ، فأنت بحاجة إلى وحدة تحكم مع TMU و FPU ، على سبيل المثال ، TMS320F280049 ، والتي يمكن أن تحول الرياضيات بشكل أسرع. </p><br><p style=";text-align:right;direction:rtl">  لتحميل قيم الواجب في PWM ، نحتاج إلى مؤقت ، ستحدد الفترة الزمنية تردد أخذ العينات.  أحتاج إلى فترة 20 مللي ثانية (1/50 هرتز = 20 مللي ثانية) وسأخذ عدد الخطوات في الجيوب الأنفية ، دعنا نقول 20 ، ونتيجة لذلك ، يجب إنشاء مقاطعة بتردد قدره 0.02 ثانية / 20 = 0.001 مللي ثانية = 1 كيلو هرتز وفي هذه المقاطعة سأكتب القيمة إلى PWM .  للبساطة ، <em>سأستغرق</em> مؤقت <em>CPU0 مؤقتًا وأهيئه</em> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  تعد <em>وظائف InitCpuTimers</em> و <em>ConfigCpuTimer</em> قياسية ، وجميع الإعدادات موجودة فيها ، نحتاج فقط إلى نقل التردد الأساسي (60 ميجاهرتز) وفترة الحساب بالميكروثانية (1000 μs = 1 مللي ثانية) ، أي ما يعادل 1 كيلو هرتز ، ونحن في حاجة إليها.  لذا ، في وظيفة التكوين ، يمكننا تمكين المقاطعات وتمرير عنوان معالج المقاطعة ، حيث سيحدث كل شيء. </p><br><p style=";text-align:right;direction:rtl">  من الضروري الآن "اختراع" صيغة الجيب مرة أخرى ، لذلك تحتاج إلى معرفة علم المثلثات المدرسية وهذا كل شيء.  وهكذا ... لدينا وظيفة <strong><em>y = sin (x)</em></strong> لنرسم هذه الوظيفة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="ذ = الخطيئة (س)"></p><br><p style=";text-align:right;direction:rtl">  كما ترون في الرسم البياني ، تتراوح سعة y من -1 إلى 1 ، لكننا نريد من 0 إلى 1 ، لأن  مع الحد الأدنى من السعة لدينا 0V ، وبحد أقصى (أي ما يعادل 1) لدينا + VCC.  "لرسم" -1 ... + 1 نحتاج إلى تغذية ثنائية القطب ، لكن الأمر ليس كذلك.  تحتاج إلى تحويل المخطط في اتجاه إيجابي.  إذا قمنا برفعها فقط ، فسيصبح من 0 إلى +2 ، ويمكننا فقط +1.  لذلك تحتاج إلى القسمة على 2 وشيء فقط!  لنبدأ بمجرد القسمة والتخطيط لـ <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="ص = (الخطيئة (س) / 2)"></p><br><p style=";text-align:right;direction:rtl">  آها!  يحتوي الرسم البياني الآن على نطاق من -0.5 إلى +0.5 ، أي أن السعة هي 1. إنه بالفعل أفضل ، لكننا لم نتخلص بعد من القيم السلبية ، لذلك دعونا نحول الرسم البياني إلى 0.5 ، لذلك نحن بحاجة فقط إلى إضافة هذه القيمة إلى النتيجة والحصول على الصيغة <strong><em>y = 0.5 + (sin (x) / 2)</em></strong> ورسم الرسم البياني لهذه الوظيفة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="ذ = 0.5 + (الخطيئة (س) / 2)"></p><br><p style=";text-align:right;direction:rtl">  الآن أصبح كل شيء مثاليًا تمامًا: الجيوب الأنفية لها سعة 0 إلى 1 ، والقيم السلبية غائبة.  تصف الصيغة <strong><em>y = 0.5 + (sin (x) / 2)</em></strong> المرحلة الأولى ، والآن من الضروري إضافة تحول مرحلة للحصول على المرحلتين 2 و 3. للقيام بذلك ، قم بطرح 2π / 3 و 4π / 3 من <em>x ،</em> على التوالي ، والحصول على الصيغ المتبقية المراحل <strong><em>y = 0.5 + (sin (x-2π / 3) / 2)</em></strong> و <strong><em>y = 0.5 + (sin (x-4π / 3) / 2).</em></strong>  نحن نبني 3 رسوم بيانية ونرى ما إذا كانت تبدو الحقيقة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 مراحل"></p><br><p style=";text-align:right;direction:rtl">  ليس سيئا!  تشبه الصورة ما يتم رسمه عادة في كتب الهندسة الكهربائية عندما يتحدثون عن شبكة ثلاثية الطور أو محركات غير متزامنة.  بالمناسبة ، 2.0943 هي 2π / 3 ، و 4.1866 هي 4π / 3 ، على التوالي ، لقد عدتها للتو على الفور وتظهر في شفرتي.  المجموع لدينا 3 معادلات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المرحلة أ - <strong><em>ص = 0.5 + (الخطيئة (س) / 2)</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة ب - <strong><em>ص = 0.5 + (الخطيئة (x-2π / 3) / 2)</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة C - <strong><em>y = 0.5 + (sin (x-4π / 3) / 2)</em></strong> </li></ul><br><p style=";text-align:right;direction:rtl">  من جانب الرياضيات ، يبدو أن كل شيء بسيط وواضح ، ولكن يجب الآن تكييفه ليتناسب مع حقائق المتحكم الدقيق.  موجة الجيب الخاصة بنا ليست تناظرية ، ولكنها تحتوي على "خطوات" ، أي أنها منفصلة ، لأننا لا نستطيع ضبط الجهد الكهربائي أو الجهد الكهربي فقط إلا على 0V أو + 15V (VCC) في حالتي.  في وقت سابق ، كتبت أنه سيكون لدي 20 خطوة ، لذلك سيكون لدي 20 حسابًا لفترة واحدة. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، لنقرر ما يجب استبداله بـ <em>x</em> .  فترة الجيبية هي <em>2π</em> ، مما يعني أن خطوة أخذ العينات ستكون <em>2π / 20</em> .  وفقًا لذلك ، سيتألف الجيوب الأنفية من 20 نقطة ، كما لو كنا نبني رسمًا بيانيًا على النقاط ، ونقارب بينهما.  نتيجة لذلك ، ستكون القيمة في الخطوة الأولى هي <strong><em>sin (2π * (1/20) ،</em></strong> في الخطوة الثانية <strong><em>sin (2π * (2/20)) ،</em></strong> في الخطوة الثالثة * <strong>sin (2π <em>(3/20))</em></strong> وهكذا ، عندما نكون إذا وصل إلى <em>20/20</em> ، فإن هذا يعني نهاية الفترة وسيكون من الضروري البدء في الحساب مرة أخرى ، وبناءً على البيانات الواردة ، فلنصحح الصيغ: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المرحلة A - <strong><em>y = 0.5 + (sin (2π * (n / N)) / 2)</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة ب - <strong><em>ص = 0.5 + (الخطيئة (2π * (n / N) -2π / 3) / 2)</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة C - <strong><em>y = 0.5 + (sin (2π * (n / N) -4π / 3) / 2)</em></strong> </li></ul><br><p style=";text-align:right;direction:rtl">  الآن ، نعتبر الآن قيمة الجيب في كل نقطة محددة على الرسم البياني.  وفقًا لذلك ، <strong>n</strong> هي الخطوة الحالية ، <strong>N</strong> هي الخطوة الكلية (20).  بعد هذه الصيغ ، نحصل على قيمة من 0 إلى 1 ، ولكن في الواقع نحن لا نعمل بسعة مجردة.  السعة في حالتنا تعتمد على دورة العمل ، لأن  يختلف الواجب من 0 إلى 600 (من إعدادات PWM) ، ثم 0 تساوي 0 وواحد يعادل 600. وبناءً على ذلك ، دعنا نعيد حسابه في صيغة حقيقية للحصول على القيمة التي سيتم تحميلها في سجل CMPA <em>PWM</em> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المرحلة A - <strong><em>الواجب 1 = A <em>(0.5 + (sin (2π</em> (n / N)) / 2))</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة B - <strong><em>الواجب 2 = A <em>(0.5 + (sin (2π</em> (n / N) -2π / 3) / 2))</em></strong> </li><li style=";text-align:right;direction:rtl">  المرحلة C - <strong><em>الواجب 4 = A <em>(0.5 + (sin (2π</em> (n / N) -4π / 3) / 2))</em></strong> </li></ul><br><p style=";text-align:right;direction:rtl">  وفقًا لذلك ، <strong>A</strong> هي القيمة القصوى للسعة ، أي 600 ، <strong>n</strong> هي الخطوة الحالية ، <strong>N</strong> هو العدد الإجمالي للخطوات (20).  قيم <strong><em>الواجب 1 ، الواجب 2 ، الواجب 4</em></strong> هي القيم الحقيقية المحولة لعامل الواجب ، والتي يتم تحميلها في <em>CMPA.</em>  الآن دعنا نكتب الكود الخاص بمعالج المقاطعة المحدث ونعلن عن كل المتغيرات الضرورية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// π const float piTwo = 6.2831; // 2π const float phaseShifted120deg = 2.0943; // 2π/3 const float phaseShifted240deg = 4.1866; // 4π/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p style=";text-align:right;direction:rtl">  الشفرة ، كما ترى ، هي أبسطها ، إذا فهمت ما هو مطلوب للقيام به والرياضيات البسيطة في المشكلة التي يتعين حلها.  في كل مرة يتم استدعاء المقاطعة ، نقوم بزيادة متغير <em>activeStep</em> ، الذي يحتوي على رقم الخطوة ، ويتغير من 0 إلى 20 ثم تتم إعادة تعيينه.  اتضح أننا في فترة واحدة نقوم بتنفيذ 20 خطوة و 20 عملية حسابية لكل مرحلة.  لكي لا أحسب <em>2π / 3</em> و <em>4π / 3</em> في الصيغة طوال الوقت ، <em>أحسبهم على</em> الفور لاستخدامهم في الثوابت. </p><br><p style=";text-align:right;direction:rtl">  تحولت الحسابات إلى الحد الأدنى ، لهذا MK هو لا شيء على الإطلاق.  إذا رغبت في ذلك ، يمكن زيادة عدد النقاط بشكل كبير ، على سبيل المثال ، ما يصل إلى 200. كل هذا يتوقف على المهمة.  يحدث تغيير تردد PWM عن طريق تغيير تكرار مكالمة المقاطعة وعدد الخطوات.  يمكنك أيضًا تغيير <em>السعة</em> المتغيرة وتغيير الجهد عند إخراج محول الطاقة. </p><br><p style=";text-align:right;direction:rtl">  بعد تنزيل الرمز إلى متحكم ، سوف تحصل على الصورة المقابلة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="الذبذبات رقم 1"></p><br><p style=";text-align:right;direction:rtl">  إذا قمت بتمديد الرسم البياني على طول <em>Y</em> ، فسيصبح من الأفضل رؤية عيوب الإشارة.  هذا ناتج عن قلة عدد خطوات أخذ العينات ، يتم تطبيق قاعدة شرطية: <strong>كلما زاد عدد النقاط ، زاد عدد الإشارة.</strong> </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="الذبذبات رقم 3"></p><br><h1 id="zaklyuchenie" style=";text-align:right;direction:rtl">  استنتاج </h1><br><p style=";text-align:right;direction:rtl">  تحدثت اليوم عن عملية تشكيل تحول المرحلة في الأنظمة متعددة المراحل ، لا يوجد شيء معقد من حيث المبدأ ، خاصة عند استخدام TMS320F28.  الباقي يعود إلى الخوارزميات ، من حيث المبدأ ، على شبكة الإنترنت ، وهناك العديد من المقالات التي تحكم المضغ والمحركات بدون فرش ، وغير متزامن وجميع أنواع الآخرين ، يمكنك فقط تحويل المنطق. </p><br><p style=";text-align:right;direction:rtl">  آمل أن تكون هذه المواد مفيدة وليست مملة بشكل خاص للقراءة.  كما هو الحال دائمًا ، يتم إرفاق المصدر: </p><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أرشفة مع المشروع ل Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar457548/">https://habr.com/ru/post/ar457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar457534/index.html">الإصدارات المعتمدة - أشعل النار التي نختارها</a></li>
<li><a href="../ar457538/index.html">كيف يمكنني استخدام الأجهزة الافتراضية التي تمت مقاطعتها في Yandex.Cloud وحفظها على حل المشكلات واسعة النطاق</a></li>
<li><a href="../ar457540/index.html">ذاكرة Intel Optane DC الدائمة ، بعد عام</a></li>
<li><a href="../ar457542/index.html">القرصنة وحماية تشفير محركات الأقراص LUKS</a></li>
<li><a href="../ar457546/index.html">يوم العرض التوضيحي: لماذا هو كل شيء وكيف نفعل ذلك UPD + البث</a></li>
<li><a href="../ar457550/index.html">ما تحتاج الصناعة الرقمية لتكون محمية من</a></li>
<li><a href="../ar457552/index.html">المتسلقون في زافاساديا. كيف تعمل الحفلات على برج مركز لختا</a></li>
<li><a href="../ar457558/index.html">تحليل الضعف EvilParcel</a></li>
<li><a href="../ar457560/index.html">الأسهم المشفرة: كيف تصبح مستثمرا قبل الحصول على الاكتتاب العام</a></li>
<li><a href="../ar457562/index.html">Ivideon Counter 3D: من ، وكيف ولماذا حساب عدد الزوار</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>