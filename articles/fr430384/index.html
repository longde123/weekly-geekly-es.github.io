<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 💩 😅 Création de cartes à partir d'entités de bruit 🤲🏿 👐🏽 🧝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'un des articles les plus populaires de mon site est consacré à la génération de cartes polygonales ( traduction en Habré). La création de telles car...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création de cartes à partir d'entités de bruit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  L'un des articles les plus populaires de mon site est consacré à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">génération de cartes polygonales</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habré).  La création de telles cartes nécessite beaucoup d'efforts.  Mais je n'ai pas commencé par cela, mais par une tâche <em>beaucoup</em> plus simple, que je décrirai ici.  Cette technique simple vous permet de créer de telles cartes en moins de 50 lignes de code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Je ne vais pas expliquer comment <em>dessiner de</em> telles cartes: cela dépend de la langue, de la bibliothèque graphique, de la plateforme, etc.  Je vais simplement expliquer comment <em>remplir le tableau</em> avec des données cartographiques. <br><br><h2>  Le bruit </h2><br>  La méthode standard pour générer des cartes 2D consiste à utiliser le bruit avec une bande de fréquence limitée comme bloc de construction, comme le bruit Perlin ou le bruit simplex.  Voici à quoi ressemble la fonction de bruit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="image"></div><br>  Nous attribuons un nombre de 0,0 à 1,0 à chaque point de la carte.  Dans cette image, 0,0 est noir et 1,0 est blanc. <a name="habracut"></a>  Voici comment définir la couleur de chaque point de grille dans la syntaxe d'un langage de type C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  La boucle fonctionnera de la même manière en Javascript, Python, Haxe, C ++, C #, Java et la plupart des autres langages populaires, je vais donc l'afficher dans une syntaxe de type C afin que vous puissiez la convertir dans la langue dont vous avez besoin.  Dans la suite du tutoriel, je montrerai comment le corps du cycle change ( <code>value[y][x]=…</code> ligne <code>value[y][x]=…</code> ) lors de l'ajout de nouvelles fonctions.  La démo montrera un exemple complet. <br><br>  Dans certaines bibliothèques, il sera nécessaire de décaler ou de multiplier les valeurs résultantes afin de les renvoyer dans la plage de 0,0 à 1,0. <br><br><h2>  La hauteur </h2><br>  Le bruit en lui-même n'est qu'une collection de chiffres.  Nous devons lui donner un <em>sens</em> .  La première chose à laquelle vous pouvez penser est de lier la valeur du bruit à la hauteur (c'est ce qu'on appelle une «carte de hauteur»).  Prenons le bruit montré ci-dessus et dessinons-le en hauteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  Le code est resté presque le même, à l'exception de la boucle intérieure.  Maintenant, cela ressemble à ceci: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Oui, et c'est tout.  Les données cartographiques sont restées les mêmes, mais maintenant je vais les appeler <code>elevation</code> (hauteur), pas <code>value</code> . <br><br>  Nous avons eu beaucoup de collines, mais rien de plus.  Qu'est-ce qui ne va pas? <br><br><h3>  La fréquence </h3><br>  Le bruit peut être généré à n'importe quelle <em>fréquence</em> .  Jusqu'à présent, je n'ai choisi qu'une seule fréquence.  Voyons comment cela affecte. <br><br>  <strong>Essayez de changer la valeur avec le curseur</strong> (dans l'article d'origine) et voyez ce qui se passe à différentes fréquences: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Cela change simplement l'échelle.  Au début, cela ne semble pas très utile, mais ce n'est pas le cas.  J'ai un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habré), qui explique la <em>théorie</em> : des concepts tels que la fréquence, l'amplitude, les octaves, le bruit rose et bleu, etc. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Il est également parfois utile de rappeler la <em>longueur d'onde</em> , qui est l'inverse de la grandeur.  Lorsque la fréquence est doublée, la taille n'est que de moitié.  Le doublement de la longueur d'onde double.  La longueur d'onde est la distance mesurée en pixels / tuiles / mètres ou toute autre unité que vous avez sélectionnée pour les cartes.  Elle est liée à la fréquence: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Octaves </h3><br>  Pour rendre la carte des hauteurs plus intéressante, nous <em>ajouterons du bruit avec différentes fréquences</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Mélangeons de grandes collines à basse fréquence avec de petites collines à haute fréquence sur une seule carte.  <strong>Déplacez le curseur</strong> (dans l'article d'origine) pour ajouter de petites collines au mélange: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Maintenant, cela ressemble beaucoup plus au soulagement fractal dont nous avons besoin!  Nous pouvons obtenir des collines et des montagnes accidentées, mais nous n'avons toujours pas de plaines plates.  Pour ce faire, vous avez besoin d'autre chose. <br><br><h3>  Redistribution </h3><br>  La fonction de bruit nous donne des valeurs comprises entre 0 et 1 (ou de -1 à +1, selon la bibliothèque).  Pour créer des plaines plates, nous pouvons <em>augmenter la hauteur à une puissance</em> .  <strong>Déplacez le curseur</strong> (dans l'article d'origine) pour obtenir différents degrés. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Des valeurs élevées <em>abaissent les hauteurs moyennes des plaines</em> et des valeurs faibles élèvent les hauteurs moyennes vers les sommets des montagnes.  Nous devons les omettre.  J'utilise les fonctions de puissance car elles sont plus simples, mais vous pouvez utiliser n'importe quelle courbe;  J'ai une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> plus compliquée. <br><br>  Maintenant que nous avons une carte d'élévation réaliste, ajoutons des biomes! <br><br><h2>  Biomes </h2><br>  Le bruit donne des chiffres, mais nous avons besoin d'une carte des forêts, des déserts et des océans.  La première chose que vous pouvez faire est de transformer de petites hauteurs en eau: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, cela devient déjà comme un monde généré par la procédure!  Nous avons de l'eau, de l'herbe et de la neige.  Et si nous en avons besoin de plus?  Faisons une séquence d'eau, de sable, d'herbe, de forêt, de savane, de désert et de neige: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Relief basé sur la hauteur</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, ça a l'air super!  Pour votre jeu, vous pouvez modifier les valeurs et les biomes.  Crysis aura beaucoup plus de jungle;  Skyrim a beaucoup plus de glace et de neige.  Mais peu importe comment vous changez les chiffres, cette approche est assez limitée.  Les types de relief correspondent aux hauteurs, forment donc des bandes.  Pour les rendre plus intéressants, nous devons choisir des biomes basés sur autre chose.  Créons une <em>deuxième</em> carte de bruit pour l'humidité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Au-dessus, le bruit des hauteurs;</i>  <i>fond - bruit d'humidité</i> <br><br>  Utilisons maintenant la hauteur et l'humidité <em>ensemble</em> .  Dans la première image illustrée ci-dessous, l'axe y est la hauteur (tirée de l'image ci-dessus) et l'axe x est l'humidité (la deuxième image est plus élevée).  Cela nous donne une carte convaincante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Soulagement basé sur deux valeurs de bruit</i> <br><br>  Les petites hauteurs sont les océans et les côtes.  Les grandes hauteurs sont rocheuses et neigeuses.  Entre les deux, nous obtenons une large gamme de biomes.  Le code ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Si nécessaire, vous pouvez modifier toutes ces valeurs en fonction des exigences de votre jeu. <br><br>  Si nous n'avons pas besoin de biomes, des dégradés lisses (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> ) peuvent créer des couleurs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Pour les biomes et les gradients, une seule valeur de bruit n'offre pas une variabilité suffisante, mais deux suffisent. <br><br><h2>  Le climat </h2><br>  Dans la section précédente, j'ai utilisé l' <em>altitude</em> comme substitut de la <em>température</em> .  Plus la hauteur est élevée, plus la température est basse.  Cependant, la latitude géographique affecte également les températures.  Utilisons à la fois la hauteur et la latitude pour contrôler la température: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Près des pôles (grandes latitudes), le climat est plus froid et sur les sommets des montagnes (grandes hauteurs), le climat est également plus froid.  Jusqu'à présent, je l'ai travaillé pas très dur: pour la bonne approche de ces paramètres, vous avez besoin de beaucoup de réglages subtils. <br><br>  Il y a aussi le changement climatique <em>saisonnier</em> .  En été et en hiver, les hémisphères nord et sud deviennent plus chauds et plus froids, mais à l'équateur la situation ne change pas beaucoup.  Beaucoup peut également être fait ici, par exemple, on peut simuler les vents dominants et les courants océaniques, l'effet des biomes sur le climat et l'effet moyen des océans sur les températures. <br><br><h2>  Les îles </h2><br>  Dans certains projets, j'avais besoin que les bordures de la carte soient de l'eau.  Cela transforme le monde en une ou plusieurs îles.  Il y a plusieurs façons de le faire, mais j'ai utilisé une solution assez simple dans mon générateur de carte polygonale: j'ai changé la hauteur en <code>e = e + a - b*d^c</code> , où <code>d</code> est la distance du centre (sur une échelle de 0-1).  Une autre option consiste à modifier <code>e = (e + a) * (1 - b*d^c)</code> .  La constante <code>a</code> élève tout, <code>b</code> abaisse les bords et <code>c</code> contrôle le taux de déclin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Je ne suis pas entièrement satisfait de cela</em> et beaucoup reste à explorer.  Faut-il que ce soit Manhattan ou la distance euclidienne?  Doit-elle dépendre de la distance au centre ou de la distance au bord?  La distance doit-elle être carrée, linéaire, ou avoir un autre degré?  Doit-il s'agir d'une addition / soustraction, ou d'une multiplication / division, ou autre chose?  Dans l'article d'origine, <b>essayez</b> Ajouter, a = 0,1, b = 0,3, c = 2,0, ou <b>essayez</b> Multiplier, a = 0,05, b = 1,00, c = 1,5.  Les options qui vous conviennent dépendent de votre projet. <br><br>  Pourquoi s'en tenir aux fonctions mathématiques standard?  Comme je l'ai dit dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur les dégâts en RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> sur Habré), tout le monde (y compris moi) utilise des fonctions mathématiques, comme les polynômes, les distributions exponentielles, etc., mais sur l'ordinateur on ne peut pas se limiter à elles.  Nous pouvons prendre <em>n'importe quelle</em> fonction de formation et l'utiliser ici, en utilisant la table de recherche <code>e = e + height_adjust[d]</code> .  Jusqu'à présent, je n'ai pas étudié cette question. <br><br><h2>  Bruit épineux </h2><br>  Au lieu d'augmenter la hauteur à une puissance, nous pouvons utiliser la valeur absolue pour créer des pics nets: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Pour ajouter des octaves, nous pouvons faire varier les amplitudes des hautes fréquences afin que seules les montagnes reçoivent le bruit supplémentaire: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Je n'ai pas beaucoup d'expérience avec cette technique, j'ai donc besoin d'expérimenter pour apprendre à bien l'utiliser.  Il peut également être intéressant de mélanger du bruit de basse fréquence hérissé avec du bruit de haute fréquence non hérissé. <br><br><h2>  Terrasses </h2><br>  Si nous arrondissons la hauteur aux n niveaux suivants, nous obtenons des terrasses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Ceci est le résultat de l'application de la fonction de redistribution de la hauteur sous la forme <code>e = f(e)</code> .  Ci-dessus, nous avons utilisé <code>e = Math.pow(e, exponent)</code> pour aiguiser les sommets des montagnes;  ici, nous utilisons <code>e = Math.round(e * n) / n</code> pour créer des terrasses.  Si vous utilisez une fonction sans marche, les terrasses peuvent être arrondies ou se produire uniquement à certaines hauteurs. <br><br><h2>  Placement des arbres </h2><br>  Habituellement, nous avons utilisé le bruit fractal pour la hauteur et l'humidité, mais il peut également être utilisé pour placer des objets inégalement espacés, tels que des arbres et des pierres.  Pour la hauteur, nous utilisons des amplitudes élevées avec des fréquences basses («bruit rouge»).  Pour placer des objets, vous devez utiliser des amplitudes élevées avec des fréquences élevées ("bruit bleu").  À gauche, un motif de bruit bleu;  à droite, les endroits où le bruit est supérieur aux valeurs adjacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  En choisissant différents R pour chaque biome, nous pouvons obtenir une densité d'arbres variable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  C'est génial qu'un tel bruit puisse être utilisé pour placer des arbres, mais d'autres algorithmes sont souvent plus efficaces et créent une distribution plus uniforme: taches de Poisson, carreaux de Van ou tramage graphique. <br><br><h2>  À l'infini et au-delà </h2><br>  Les calculs du biome à la position (x, y) sont indépendants des calculs de toutes les autres positions.  Ce <strong>calcul local</strong> a deux propriétés pratiques: il peut être calculé en parallèle et il peut être utilisé pour un terrain sans fin.  <strong>Placez le curseur de la souris sur la mini-carte</strong> (dans l'article d'origine) à gauche pour générer la carte à droite.  Vous pouvez générer n'importe quelle partie de la carte sans générer (et même sans stocker) la carte entière. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implémentation </h2><br>  L'utilisation du bruit pour générer du terrain est une solution populaire, et sur Internet, vous pouvez trouver des didacticiels pour de nombreuses langues et plates-formes différentes.  Le code pour générer des cartes dans différentes langues est approximativement le même.  Voici la boucle la plus simple en trois langues différentes: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Toutes les bibliothèques de bruit se ressemblent à peu près.  Essayez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opensimplex pour Python</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libnoise pour C ++</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simplex-noise</a> pour Javascript.  Pour la plupart des langues populaires, il existe de nombreuses bibliothèques de bruit.  Ou vous pouvez apprendre comment fonctionne le bruit Perlin ou réaliser le bruit vous-même.  <em>Je ne l'ai pas fait.</em> <br><br>  Dans différentes bibliothèques de bruit pour votre langue, les détails de l'application peuvent varier légèrement (certains nombres de retour dans la plage de 0,0 à 1,0, d'autres dans la plage de -1,0 à +1,0), mais l'idée de base est la même.  Pour un vrai projet, vous devrez peut-être envelopper la fonction de <code>noise</code> et l'objet <code>gen</code> dans une classe, mais ces détails ne sont pas pertinents, donc je les ai rendus globaux. <br><br>  Pour un projet aussi simple, peu importe le bruit que vous utilisez: bruit Perlin, bruit simplex, bruit OpenSimplex, bruit de valeur, décalage médian, algorithme diamant ou transformée de Fourier inverse.  Chacun d'eux a ses avantages et ses inconvénients, mais pour un générateur de cartes similaire, ils créent tous plus ou moins les mêmes valeurs de sortie. <br><br>  <em>Le rendu de la</em> carte dépend de la plateforme et du jeu, donc je ne l'ai pas implémenté;  ce code n'est nécessaire que pour générer des hauteurs et des biomes, dont le rendu dépend du style utilisé dans le jeu.  Vous pouvez le copier, le porter et l'utiliser dans vos projets. <br><br><h2>  Les expériences </h2><br>  J'ai regardé le mélange d'octaves, l'augmentation des degrés à une puissance et la combinaison des hauteurs avec l'humidité pour créer un biome.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez étudier un graphique interactif qui vous permet d'expérimenter avec tous ces paramètres, qui montre en quoi consiste le code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Voici un exemple de code: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Il y a une difficulté: pour le bruit des hauteurs et de l'humidité, il est nécessaire d'utiliser une graine différente, sinon ils se révéleront identiques et les cartes n'auront pas l'air si intéressantes.  En Javascript, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque prng-parkmiller</a> ;  en C ++, vous pouvez utiliser deux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets linear_congruential_engine</a> distincts;  en Python, vous pouvez créer deux instances distinctes d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe random.Random</a> . <br><br><h2>  Réflexions </h2><br>  J'aime cette approche de la génération de cartes pour sa <b>simplicité</b> .  Il est rapide et nécessite très peu de code pour produire des résultats décents. <br><br>  Je n'aime pas ses limites dans cette approche.  Les calculs locaux signifient que chaque point est indépendant de tous les autres.  Différentes zones de la carte <em>ne</em> sont <em>pas connectées les unes aux autres</em> .  Chaque endroit sur la carte «semble» le même.  Il n'y a pas de restrictions mondiales, par exemple, «il devrait y avoir de 3 à 5 lacs sur la carte» ou des caractéristiques mondiales, comme une rivière qui coule du haut du plus haut sommet vers l'océan.  De plus, je n'aime pas le fait que pour obtenir une bonne image, vous devez configurer les paramètres pendant longtemps. <br><br>  Pourquoi est-ce que je le recommande?  Je pense que c'est un bon point de départ, en particulier pour les jeux indépendants et les jams de jeu.  Deux de mes amis ont écrit la version initiale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Realm of the Mad God en</a> seulement 30 jours pour un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concours de jeux</a> .  Ils m'ont demandé d'aider à créer des cartes.  J'ai utilisé cette technique (plus quelques fonctionnalités supplémentaires qui se sont avérées peu utiles) et j'ai fait une carte pour elles.  Quelques mois plus tard, après avoir reçu les retours des joueurs et étudié attentivement la conception du jeu, nous avons créé un générateur de carte plus avancé basé sur les polygones de Voronoï, décrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habré).  Ce générateur de cartes n'utilise pas les techniques décrites dans cet article.  Il utilise le bruit pour créer des cartes d'une manière complètement différente. <br><br><h2>  Information additionnelle </h2><br>  Il y a <em>beaucoup de</em> choses intéressantes que vous pouvez faire avec les fonctions de bruit.  Si vous effectuez une recherche sur Internet, vous pouvez trouver des options telles que la turbulence, la houle, le multifractal strié, l'amortissement d'amplitude, les terrasses, le bruit de voronoi, les dérivés analytiques, la déformation de domaine et autres.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette page</a> comme source d'inspiration.  Je ne les considère pas ici, mon article se concentre sur la simplicité. <br><br>  Ce projet a été influencé par mes précédents projets de génération de cartes: <br><br><ul><li>  J'ai utilisé le bruit global de Perlin pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon premier générateur de cartes Realm of the Mad God</a> .  Nous l'avons utilisé pendant les six premiers mois du test alpha, puis l'avons remplacé par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un générateur de carte sur les polygones Voronoi</a> , spécialement créé pour les exigences de gameplay que nous avons déterminées lors du test alpha.  Les biomes et leurs couleurs pour l'article sont issus de ces projets. </li><li>  Lors de l'étude du traitement des signaux audio, j'ai écrit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel sur le bruit</a> qui explique des concepts tels que la fréquence, l'amplitude, les octaves et la «couleur» du bruit.  Les mêmes concepts qui fonctionnent pour le son s'appliquent également à la génération de cartes basée sur le bruit.  À ce moment-là, j'ai créé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">génération de secours de démonstration</a> brute, mais je ne les ai pas terminées. </li><li>  Parfois, j'expérimente pour trouver des limites.  Je voulais savoir combien de code est minimalement nécessaire pour créer des cartes convaincantes.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce mini-projet,</a> j'ai atteint <b>zéro</b> ligne de code - tout se fait avec des filtres d'image (turbulence, seuils, dégradés de couleurs).  Cela m'a rendu heureux et triste.  Dans quelle mesure la génération de cartes peut-elle être effectuée par des filtres d'image?  En assez gros.  Tout ce qui est décrit ci-dessus sur le "schéma de dégradés de couleurs lisses" est tiré de cette expérience.  La couche de bruit est un filtre d'image à turbulence;  les octaves sont des images superposées les unes aux autres;  L'outil de degré est appelé «correction de courbe» dans Photoshop. </li></ul><br>  Ce qui me dérange un peu, c'est que la plupart du code que les développeurs de jeux écrivent pour la génération de terrain basée sur le bruit (y compris le déplacement au milieu) se révèle être le même que dans les filtres de son et d'image.  D'un autre côté, cela crée des résultats assez décents en quelques lignes de code, c'est pourquoi j'ai écrit cet article.  Il s'agit d'un <em>point de référence rapide et facile</em> .  Habituellement, je n'utilise pas de telles cartes depuis longtemps, mais remplacez-les par un générateur de cartes plus complexe dès que je découvre quels types de cartes conviennent mieux à la conception du jeu.  Pour moi, c'est un modèle standard: commencer par quelque chose d'extrêmement simple, puis le remplacer uniquement après avoir mieux compris le système avec lequel je travaille. <br><br>  Il y a <em>beaucoup</em> plus de choses qui peuvent être faites avec du bruit, dans l'article, je n'en ai mentionné que quelques-unes.  Essayez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Noise Studio</a> pour tester de manière interactive diverses fonctionnalités. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430384/">https://habr.com/ru/post/fr430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430374/index.html">Ingénierie des données et plus encore: bandes vidéo Wrike et diapositives de la réunion</a></li>
<li><a href="../fr430376/index.html">Guide JavaScript, partie 6: exceptions, points-virgules, littéraux de modèle</a></li>
<li><a href="../fr430378/index.html">J2CL - Mieux vaut tard que jamais</a></li>
<li><a href="../fr430380/index.html">Guide JavaScript Partie 5: Tableaux et boucles</a></li>
<li><a href="../fr430382/index.html">Guide JavaScript Partie 4: Fonctionnalités</a></li>
<li><a href="../fr430386/index.html">Construction d'une centrale de stockage à semi-conducteurs en Inde</a></li>
<li><a href="../fr430388/index.html">Conférence Web Summit</a></li>
<li><a href="../fr430392/index.html">Comment développer et tester des API avec mon «vélo» PieceofScript</a></li>
<li><a href="../fr430394/index.html">Implémentation de la recherche instantanée dans Android à l'aide de RxJava</a></li>
<li><a href="../fr430396/index.html">Réplication de chaîne: création d'un référentiel KV efficace (partie 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>