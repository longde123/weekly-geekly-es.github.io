<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® üí© üòÖ Cr√©ation de cartes √† partir d'entit√©s de bruit ü§≤üèø üëêüèΩ üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'un des articles les plus populaires de mon site est consacr√© √† la g√©n√©ration de cartes polygonales ( traduction en Habr√©). La cr√©ation de telles car...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation de cartes √† partir d'entit√©s de bruit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  L'un des articles les plus populaires de mon site est consacr√© √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©ration de cartes polygonales</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©).  La cr√©ation de telles cartes n√©cessite beaucoup d'efforts.  Mais je n'ai pas commenc√© par cela, mais par une t√¢che <em>beaucoup</em> plus simple, que je d√©crirai ici.  Cette technique simple vous permet de cr√©er de telles cartes en moins de 50 lignes de code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Je ne vais pas expliquer comment <em>dessiner de</em> telles cartes: cela d√©pend de la langue, de la biblioth√®que graphique, de la plateforme, etc.  Je vais simplement expliquer comment <em>remplir le tableau</em> avec des donn√©es cartographiques. <br><br><h2>  Le bruit </h2><br>  La m√©thode standard pour g√©n√©rer des cartes 2D consiste √† utiliser le bruit avec une bande de fr√©quence limit√©e comme bloc de construction, comme le bruit Perlin ou le bruit simplex.  Voici √† quoi ressemble la fonction de bruit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="image"></div><br>  Nous attribuons un nombre de 0,0 √† 1,0 √† chaque point de la carte.  Dans cette image, 0,0 est noir et 1,0 est blanc. <a name="habracut"></a>  Voici comment d√©finir la couleur de chaque point de grille dans la syntaxe d'un langage de type C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  La boucle fonctionnera de la m√™me mani√®re en Javascript, Python, Haxe, C ++, C #, Java et la plupart des autres langages populaires, je vais donc l'afficher dans une syntaxe de type C afin que vous puissiez la convertir dans la langue dont vous avez besoin.  Dans la suite du tutoriel, je montrerai comment le corps du cycle change ( <code>value[y][x]=‚Ä¶</code> ligne <code>value[y][x]=‚Ä¶</code> ) lors de l'ajout de nouvelles fonctions.  La d√©mo montrera un exemple complet. <br><br>  Dans certaines biblioth√®ques, il sera n√©cessaire de d√©caler ou de multiplier les valeurs r√©sultantes afin de les renvoyer dans la plage de 0,0 √† 1,0. <br><br><h2>  La hauteur </h2><br>  Le bruit en lui-m√™me n'est qu'une collection de chiffres.  Nous devons lui donner un <em>sens</em> .  La premi√®re chose √† laquelle vous pouvez penser est de lier la valeur du bruit √† la hauteur (c'est ce qu'on appelle une ¬´carte de hauteur¬ª).  Prenons le bruit montr√© ci-dessus et dessinons-le en hauteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  Le code est rest√© presque le m√™me, √† l'exception de la boucle int√©rieure.  Maintenant, cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Oui, et c'est tout.  Les donn√©es cartographiques sont rest√©es les m√™mes, mais maintenant je vais les appeler <code>elevation</code> (hauteur), pas <code>value</code> . <br><br>  Nous avons eu beaucoup de collines, mais rien de plus.  Qu'est-ce qui ne va pas? <br><br><h3>  La fr√©quence </h3><br>  Le bruit peut √™tre g√©n√©r√© √† n'importe quelle <em>fr√©quence</em> .  Jusqu'√† pr√©sent, je n'ai choisi qu'une seule fr√©quence.  Voyons comment cela affecte. <br><br>  <strong>Essayez de changer la valeur avec le curseur</strong> (dans l'article d'origine) et voyez ce qui se passe √† diff√©rentes fr√©quences: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Cela change simplement l'√©chelle.  Au d√©but, cela ne semble pas tr√®s utile, mais ce n'est pas le cas.  J'ai un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©), qui explique la <em>th√©orie</em> : des concepts tels que la fr√©quence, l'amplitude, les octaves, le bruit rose et bleu, etc. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Il est √©galement parfois utile de rappeler la <em>longueur d'onde</em> , qui est l'inverse de la grandeur.  Lorsque la fr√©quence est doubl√©e, la taille n'est que de moiti√©.  Le doublement de la longueur d'onde double.  La longueur d'onde est la distance mesur√©e en pixels / tuiles / m√®tres ou toute autre unit√© que vous avez s√©lectionn√©e pour les cartes.  Elle est li√©e √† la fr√©quence: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Octaves </h3><br>  Pour rendre la carte des hauteurs plus int√©ressante, nous <em>ajouterons du bruit avec diff√©rentes fr√©quences</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  M√©langeons de grandes collines √† basse fr√©quence avec de petites collines √† haute fr√©quence sur une seule carte.  <strong>D√©placez le curseur</strong> (dans l'article d'origine) pour ajouter de petites collines au m√©lange: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Maintenant, cela ressemble beaucoup plus au soulagement fractal dont nous avons besoin!  Nous pouvons obtenir des collines et des montagnes accident√©es, mais nous n'avons toujours pas de plaines plates.  Pour ce faire, vous avez besoin d'autre chose. <br><br><h3>  Redistribution </h3><br>  La fonction de bruit nous donne des valeurs comprises entre 0 et 1 (ou de -1 √† +1, selon la biblioth√®que).  Pour cr√©er des plaines plates, nous pouvons <em>augmenter la hauteur √† une puissance</em> .  <strong>D√©placez le curseur</strong> (dans l'article d'origine) pour obtenir diff√©rents degr√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Des valeurs √©lev√©es <em>abaissent les hauteurs moyennes des plaines</em> et des valeurs faibles √©l√®vent les hauteurs moyennes vers les sommets des montagnes.  Nous devons les omettre.  J'utilise les fonctions de puissance car elles sont plus simples, mais vous pouvez utiliser n'importe quelle courbe;  J'ai une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©mo</a> plus compliqu√©e. <br><br>  Maintenant que nous avons une carte d'√©l√©vation r√©aliste, ajoutons des biomes! <br><br><h2>  Biomes </h2><br>  Le bruit donne des chiffres, mais nous avons besoin d'une carte des for√™ts, des d√©serts et des oc√©ans.  La premi√®re chose que vous pouvez faire est de transformer de petites hauteurs en eau: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, cela devient d√©j√† comme un monde g√©n√©r√© par la proc√©dure!  Nous avons de l'eau, de l'herbe et de la neige.  Et si nous en avons besoin de plus?  Faisons une s√©quence d'eau, de sable, d'herbe, de for√™t, de savane, de d√©sert et de neige: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Relief bas√© sur la hauteur</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, √ßa a l'air super!  Pour votre jeu, vous pouvez modifier les valeurs et les biomes.  Crysis aura beaucoup plus de jungle;  Skyrim a beaucoup plus de glace et de neige.  Mais peu importe comment vous changez les chiffres, cette approche est assez limit√©e.  Les types de relief correspondent aux hauteurs, forment donc des bandes.  Pour les rendre plus int√©ressants, nous devons choisir des biomes bas√©s sur autre chose.  Cr√©ons une <em>deuxi√®me</em> carte de bruit pour l'humidit√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Au-dessus, le bruit des hauteurs;</i>  <i>fond - bruit d'humidit√©</i> <br><br>  Utilisons maintenant la hauteur et l'humidit√© <em>ensemble</em> .  Dans la premi√®re image illustr√©e ci-dessous, l'axe y est la hauteur (tir√©e de l'image ci-dessus) et l'axe x est l'humidit√© (la deuxi√®me image est plus √©lev√©e).  Cela nous donne une carte convaincante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Soulagement bas√© sur deux valeurs de bruit</i> <br><br>  Les petites hauteurs sont les oc√©ans et les c√¥tes.  Les grandes hauteurs sont rocheuses et neigeuses.  Entre les deux, nous obtenons une large gamme de biomes.  Le code ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Si n√©cessaire, vous pouvez modifier toutes ces valeurs en fonction des exigences de votre jeu. <br><br>  Si nous n'avons pas besoin de biomes, des d√©grad√©s lisses (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> ) peuvent cr√©er des couleurs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Pour les biomes et les gradients, une seule valeur de bruit n'offre pas une variabilit√© suffisante, mais deux suffisent. <br><br><h2>  Le climat </h2><br>  Dans la section pr√©c√©dente, j'ai utilis√© l' <em>altitude</em> comme substitut de la <em>temp√©rature</em> .  Plus la hauteur est √©lev√©e, plus la temp√©rature est basse.  Cependant, la latitude g√©ographique affecte √©galement les temp√©ratures.  Utilisons √† la fois la hauteur et la latitude pour contr√¥ler la temp√©rature: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Pr√®s des p√¥les (grandes latitudes), le climat est plus froid et sur les sommets des montagnes (grandes hauteurs), le climat est √©galement plus froid.  Jusqu'√† pr√©sent, je l'ai travaill√© pas tr√®s dur: pour la bonne approche de ces param√®tres, vous avez besoin de beaucoup de r√©glages subtils. <br><br>  Il y a aussi le changement climatique <em>saisonnier</em> .  En √©t√© et en hiver, les h√©misph√®res nord et sud deviennent plus chauds et plus froids, mais √† l'√©quateur la situation ne change pas beaucoup.  Beaucoup peut √©galement √™tre fait ici, par exemple, on peut simuler les vents dominants et les courants oc√©aniques, l'effet des biomes sur le climat et l'effet moyen des oc√©ans sur les temp√©ratures. <br><br><h2>  Les √Æles </h2><br>  Dans certains projets, j'avais besoin que les bordures de la carte soient de l'eau.  Cela transforme le monde en une ou plusieurs √Æles.  Il y a plusieurs fa√ßons de le faire, mais j'ai utilis√© une solution assez simple dans mon g√©n√©rateur de carte polygonale: j'ai chang√© la hauteur en <code>e = e + a - b*d^c</code> , o√π <code>d</code> est la distance du centre (sur une √©chelle de 0-1).  Une autre option consiste √† modifier <code>e = (e + a) * (1 - b*d^c)</code> .  La constante <code>a</code> √©l√®ve tout, <code>b</code> abaisse les bords et <code>c</code> contr√¥le le taux de d√©clin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Je ne suis pas enti√®rement satisfait de cela</em> et beaucoup reste √† explorer.  Faut-il que ce soit Manhattan ou la distance euclidienne?  Doit-elle d√©pendre de la distance au centre ou de la distance au bord?  La distance doit-elle √™tre carr√©e, lin√©aire, ou avoir un autre degr√©?  Doit-il s'agir d'une addition / soustraction, ou d'une multiplication / division, ou autre chose?  Dans l'article d'origine, <b>essayez</b> Ajouter, a = 0,1, b = 0,3, c = 2,0, ou <b>essayez</b> Multiplier, a = 0,05, b = 1,00, c = 1,5.  Les options qui vous conviennent d√©pendent de votre projet. <br><br>  Pourquoi s'en tenir aux fonctions math√©matiques standard?  Comme je l'ai dit dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur les d√©g√¢ts en RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> sur Habr√©), tout le monde (y compris moi) utilise des fonctions math√©matiques, comme les polyn√¥mes, les distributions exponentielles, etc., mais sur l'ordinateur on ne peut pas se limiter √† elles.  Nous pouvons prendre <em>n'importe quelle</em> fonction de formation et l'utiliser ici, en utilisant la table de recherche <code>e = e + height_adjust[d]</code> .  Jusqu'√† pr√©sent, je n'ai pas √©tudi√© cette question. <br><br><h2>  Bruit √©pineux </h2><br>  Au lieu d'augmenter la hauteur √† une puissance, nous pouvons utiliser la valeur absolue pour cr√©er des pics nets: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Pour ajouter des octaves, nous pouvons faire varier les amplitudes des hautes fr√©quences afin que seules les montagnes re√ßoivent le bruit suppl√©mentaire: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Je n'ai pas beaucoup d'exp√©rience avec cette technique, j'ai donc besoin d'exp√©rimenter pour apprendre √† bien l'utiliser.  Il peut √©galement √™tre int√©ressant de m√©langer du bruit de basse fr√©quence h√©riss√© avec du bruit de haute fr√©quence non h√©riss√©. <br><br><h2>  Terrasses </h2><br>  Si nous arrondissons la hauteur aux n niveaux suivants, nous obtenons des terrasses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Ceci est le r√©sultat de l'application de la fonction de redistribution de la hauteur sous la forme <code>e = f(e)</code> .  Ci-dessus, nous avons utilis√© <code>e = Math.pow(e, exponent)</code> pour aiguiser les sommets des montagnes;  ici, nous utilisons <code>e = Math.round(e * n) / n</code> pour cr√©er des terrasses.  Si vous utilisez une fonction sans marche, les terrasses peuvent √™tre arrondies ou se produire uniquement √† certaines hauteurs. <br><br><h2>  Placement des arbres </h2><br>  Habituellement, nous avons utilis√© le bruit fractal pour la hauteur et l'humidit√©, mais il peut √©galement √™tre utilis√© pour placer des objets in√©galement espac√©s, tels que des arbres et des pierres.  Pour la hauteur, nous utilisons des amplitudes √©lev√©es avec des fr√©quences basses (¬´bruit rouge¬ª).  Pour placer des objets, vous devez utiliser des amplitudes √©lev√©es avec des fr√©quences √©lev√©es ("bruit bleu").  √Ä gauche, un motif de bruit bleu;  √† droite, les endroits o√π le bruit est sup√©rieur aux valeurs adjacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  En choisissant diff√©rents R pour chaque biome, nous pouvons obtenir une densit√© d'arbres variable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  C'est g√©nial qu'un tel bruit puisse √™tre utilis√© pour placer des arbres, mais d'autres algorithmes sont souvent plus efficaces et cr√©ent une distribution plus uniforme: taches de Poisson, carreaux de Van ou tramage graphique. <br><br><h2>  √Ä l'infini et au-del√† </h2><br>  Les calculs du biome √† la position (x, y) sont ind√©pendants des calculs de toutes les autres positions.  Ce <strong>calcul local</strong> a deux propri√©t√©s pratiques: il peut √™tre calcul√© en parall√®le et il peut √™tre utilis√© pour un terrain sans fin.  <strong>Placez le curseur de la souris sur la mini-carte</strong> (dans l'article d'origine) √† gauche pour g√©n√©rer la carte √† droite.  Vous pouvez g√©n√©rer n'importe quelle partie de la carte sans g√©n√©rer (et m√™me sans stocker) la carte enti√®re. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Impl√©mentation </h2><br>  L'utilisation du bruit pour g√©n√©rer du terrain est une solution populaire, et sur Internet, vous pouvez trouver des didacticiels pour de nombreuses langues et plates-formes diff√©rentes.  Le code pour g√©n√©rer des cartes dans diff√©rentes langues est approximativement le m√™me.  Voici la boucle la plus simple en trois langues diff√©rentes: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Toutes les biblioth√®ques de bruit se ressemblent √† peu pr√®s.  Essayez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opensimplex pour Python</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libnoise pour C ++</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simplex-noise</a> pour Javascript.  Pour la plupart des langues populaires, il existe de nombreuses biblioth√®ques de bruit.  Ou vous pouvez apprendre comment fonctionne le bruit Perlin ou r√©aliser le bruit vous-m√™me.  <em>Je ne l'ai pas fait.</em> <br><br>  Dans diff√©rentes biblioth√®ques de bruit pour votre langue, les d√©tails de l'application peuvent varier l√©g√®rement (certains nombres de retour dans la plage de 0,0 √† 1,0, d'autres dans la plage de -1,0 √† +1,0), mais l'id√©e de base est la m√™me.  Pour un vrai projet, vous devrez peut-√™tre envelopper la fonction de <code>noise</code> et l'objet <code>gen</code> dans une classe, mais ces d√©tails ne sont pas pertinents, donc je les ai rendus globaux. <br><br>  Pour un projet aussi simple, peu importe le bruit que vous utilisez: bruit Perlin, bruit simplex, bruit OpenSimplex, bruit de valeur, d√©calage m√©dian, algorithme diamant ou transform√©e de Fourier inverse.  Chacun d'eux a ses avantages et ses inconv√©nients, mais pour un g√©n√©rateur de cartes similaire, ils cr√©ent tous plus ou moins les m√™mes valeurs de sortie. <br><br>  <em>Le rendu de la</em> carte d√©pend de la plateforme et du jeu, donc je ne l'ai pas impl√©ment√©;  ce code n'est n√©cessaire que pour g√©n√©rer des hauteurs et des biomes, dont le rendu d√©pend du style utilis√© dans le jeu.  Vous pouvez le copier, le porter et l'utiliser dans vos projets. <br><br><h2>  Les exp√©riences </h2><br>  J'ai regard√© le m√©lange d'octaves, l'augmentation des degr√©s √† une puissance et la combinaison des hauteurs avec l'humidit√© pour cr√©er un biome.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez √©tudier un graphique interactif qui vous permet d'exp√©rimenter avec tous ces param√®tres, qui montre en quoi consiste le code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Voici un exemple de code: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Il y a une difficult√©: pour le bruit des hauteurs et de l'humidit√©, il est n√©cessaire d'utiliser une graine diff√©rente, sinon ils se r√©v√©leront identiques et les cartes n'auront pas l'air si int√©ressantes.  En Javascript, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la biblioth√®que prng-parkmiller</a> ;  en C ++, vous pouvez utiliser deux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets linear_congruential_engine</a> distincts;  en Python, vous pouvez cr√©er deux instances distinctes d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe random.Random</a> . <br><br><h2>  R√©flexions </h2><br>  J'aime cette approche de la g√©n√©ration de cartes pour sa <b>simplicit√©</b> .  Il est rapide et n√©cessite tr√®s peu de code pour produire des r√©sultats d√©cents. <br><br>  Je n'aime pas ses limites dans cette approche.  Les calculs locaux signifient que chaque point est ind√©pendant de tous les autres.  Diff√©rentes zones de la carte <em>ne</em> sont <em>pas connect√©es les unes aux autres</em> .  Chaque endroit sur la carte ¬´semble¬ª le m√™me.  Il n'y a pas de restrictions mondiales, par exemple, ¬´il devrait y avoir de 3 √† 5 lacs sur la carte¬ª ou des caract√©ristiques mondiales, comme une rivi√®re qui coule du haut du plus haut sommet vers l'oc√©an.  De plus, je n'aime pas le fait que pour obtenir une bonne image, vous devez configurer les param√®tres pendant longtemps. <br><br>  Pourquoi est-ce que je le recommande?  Je pense que c'est un bon point de d√©part, en particulier pour les jeux ind√©pendants et les jams de jeu.  Deux de mes amis ont √©crit la version initiale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Realm of the Mad God en</a> seulement 30 jours pour un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concours de jeux</a> .  Ils m'ont demand√© d'aider √† cr√©er des cartes.  J'ai utilis√© cette technique (plus quelques fonctionnalit√©s suppl√©mentaires qui se sont av√©r√©es peu utiles) et j'ai fait une carte pour elles.  Quelques mois plus tard, apr√®s avoir re√ßu les retours des joueurs et √©tudi√© attentivement la conception du jeu, nous avons cr√©√© un g√©n√©rateur de carte plus avanc√© bas√© sur les polygones de Vorono√Ø, d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©).  Ce g√©n√©rateur de cartes n'utilise pas les techniques d√©crites dans cet article.  Il utilise le bruit pour cr√©er des cartes d'une mani√®re compl√®tement diff√©rente. <br><br><h2>  Information additionnelle </h2><br>  Il y a <em>beaucoup de</em> choses int√©ressantes que vous pouvez faire avec les fonctions de bruit.  Si vous effectuez une recherche sur Internet, vous pouvez trouver des options telles que la turbulence, la houle, le multifractal stri√©, l'amortissement d'amplitude, les terrasses, le bruit de voronoi, les d√©riv√©s analytiques, la d√©formation de domaine et autres.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette page</a> comme source d'inspiration.  Je ne les consid√®re pas ici, mon article se concentre sur la simplicit√©. <br><br>  Ce projet a √©t√© influenc√© par mes pr√©c√©dents projets de g√©n√©ration de cartes: <br><br><ul><li>  J'ai utilis√© le bruit global de Perlin pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon premier g√©n√©rateur de cartes Realm of the Mad God</a> .  Nous l'avons utilis√© pendant les six premiers mois du test alpha, puis l'avons remplac√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un g√©n√©rateur de carte sur les polygones Voronoi</a> , sp√©cialement cr√©√© pour les exigences de gameplay que nous avons d√©termin√©es lors du test alpha.  Les biomes et leurs couleurs pour l'article sont issus de ces projets. </li><li>  Lors de l'√©tude du traitement des signaux audio, j'ai √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel sur le bruit</a> qui explique des concepts tels que la fr√©quence, l'amplitude, les octaves et la ¬´couleur¬ª du bruit.  Les m√™mes concepts qui fonctionnent pour le son s'appliquent √©galement √† la g√©n√©ration de cartes bas√©e sur le bruit.  √Ä ce moment-l√†, j'ai cr√©√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©ration de secours de d√©monstration</a> brute, mais je ne les ai pas termin√©es. </li><li>  Parfois, j'exp√©rimente pour trouver des limites.  Je voulais savoir combien de code est minimalement n√©cessaire pour cr√©er des cartes convaincantes.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce mini-projet,</a> j'ai atteint <b>z√©ro</b> ligne de code - tout se fait avec des filtres d'image (turbulence, seuils, d√©grad√©s de couleurs).  Cela m'a rendu heureux et triste.  Dans quelle mesure la g√©n√©ration de cartes peut-elle √™tre effectu√©e par des filtres d'image?  En assez gros.  Tout ce qui est d√©crit ci-dessus sur le "sch√©ma de d√©grad√©s de couleurs lisses" est tir√© de cette exp√©rience.  La couche de bruit est un filtre d'image √† turbulence;  les octaves sont des images superpos√©es les unes aux autres;  L'outil de degr√© est appel√© ¬´correction de courbe¬ª dans Photoshop. </li></ul><br>  Ce qui me d√©range un peu, c'est que la plupart du code que les d√©veloppeurs de jeux √©crivent pour la g√©n√©ration de terrain bas√©e sur le bruit (y compris le d√©placement au milieu) se r√©v√®le √™tre le m√™me que dans les filtres de son et d'image.  D'un autre c√¥t√©, cela cr√©e des r√©sultats assez d√©cents en quelques lignes de code, c'est pourquoi j'ai √©crit cet article.  Il s'agit d'un <em>point de r√©f√©rence rapide et facile</em> .  Habituellement, je n'utilise pas de telles cartes depuis longtemps, mais remplacez-les par un g√©n√©rateur de cartes plus complexe d√®s que je d√©couvre quels types de cartes conviennent mieux √† la conception du jeu.  Pour moi, c'est un mod√®le standard: commencer par quelque chose d'extr√™mement simple, puis le remplacer uniquement apr√®s avoir mieux compris le syst√®me avec lequel je travaille. <br><br>  Il y a <em>beaucoup</em> plus de choses qui peuvent √™tre faites avec du bruit, dans l'article, je n'en ai mentionn√© que quelques-unes.  Essayez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Noise Studio</a> pour tester de mani√®re interactive diverses fonctionnalit√©s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430384/">https://habr.com/ru/post/fr430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430374/index.html">Ing√©nierie des donn√©es et plus encore: bandes vid√©o Wrike et diapositives de la r√©union</a></li>
<li><a href="../fr430376/index.html">Guide JavaScript, partie 6: exceptions, points-virgules, litt√©raux de mod√®le</a></li>
<li><a href="../fr430378/index.html">J2CL - Mieux vaut tard que jamais</a></li>
<li><a href="../fr430380/index.html">Guide JavaScript Partie 5: Tableaux et boucles</a></li>
<li><a href="../fr430382/index.html">Guide JavaScript Partie 4: Fonctionnalit√©s</a></li>
<li><a href="../fr430386/index.html">Construction d'une centrale de stockage √† semi-conducteurs en Inde</a></li>
<li><a href="../fr430388/index.html">Conf√©rence Web Summit</a></li>
<li><a href="../fr430392/index.html">Comment d√©velopper et tester des API avec mon ¬´v√©lo¬ª PieceofScript</a></li>
<li><a href="../fr430394/index.html">Impl√©mentation de la recherche instantan√©e dans Android √† l'aide de RxJava</a></li>
<li><a href="../fr430396/index.html">R√©plication de cha√Æne: cr√©ation d'un r√©f√©rentiel KV efficace (partie 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>