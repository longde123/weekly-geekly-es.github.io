<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 🦋 😮 使用ESP8266上的加热地板控制器示例开发智能设备 👩🏻‍🎓 ✏️ 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想分享我在开发智能设备方面的经验。 在本出版物中，我将简要介绍硬件和软件（更详细地介绍）软件。 

 该控制器旨在分析传感器的读数（有线和无线）并通过打开/关闭锅炉并使用集热器上的热敏头控制水底加热回路来维持每个单独区域中的设定温度（包括时间表，包括一周中的几天）。 

 硬体 
 作为控制器，选...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用ESP8266上的加热地板控制器示例开发智能设备</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412889/"> 我想分享我在开发智能设备方面的经验。 在本出版物中，我将简要介绍硬件和软件（更详细地介绍）软件。 <br><br> 该控制器旨在分析传感器的读数（有线和无线）并通过打开/关闭锅炉并使用集热器上的热敏头控制水底加热回路来维持每个单独区域中的设定温度（包括时间表，包括一周中的几天）。 <br><a name="habracut"></a><br><h2> 硬体 </h2><br> 作为控制器，选择了ESP8266（WeMos D1 mini），作为 船上有wifi。 除了ESP8266外，其他任何控制器或微型计算机都可以使用-总体思路不变，主要的事情是可以在所选系统上部署支持WEB套接字的WEB服务器。 项目中还使用了以下内容： <br><br><ul><li>  RTC：DS3231-必须确定星期几和当前时间。 该项目被认为是可以在没有Internet的情况下工作的独立设备，因此NTP不适合。 </li><li> 无线温度传感器：NoName，433MHz，来自中国气象站-一种交钥匙解决方案，它们使用电池供电。 您还需要什么？ 但是有必要数据传输周期不固定。 问题在于传输周期为35秒，并且游泳不多。 并且在某些情况下，两个传感器的信号会重叠。 在这种情况下，一两个传感器会暂时退出系统。 使用类似的传感器可以解决该问题，其中通道切换也会改变数据传输周期。 </li><li>  433MHz接收器：Rxb6-互联网评论和个人经验都不错。 </li><li> 有线温度传感器：DS18B20-非常方便，因为您无需事先知道传感器的数量。 </li><li>  1Wire总线主机：DS2482-100-1Wire协议对时序非常敏感，因此程序总线主机的所有实现都使用延迟，这对于多任务处理不是很好。 使用该芯片，您可以利用1Wire总线，并通过广播1Wire &lt;-&gt; i2c消除其缺点。  i2c协议具有一条同步线，因此它对时序并不重要，通常在控制器的硬件中实现。 </li><li> 看门狗定时器：TPL5000DGST-对于该项目，连续的正常运行时间并不重要，但是可访问性非常重要。  ESP8266内置了看门狗定时器。 但是，正如实践所表明的那样，有时仍然存在无法应对且系统死机的情况。 外部硬件看门狗定时器旨在处理紧急情况。 配置为64秒的延迟。 连接到支腿TX-在操作期间，系统不断将调试信息写入Serial，并且如果超过一分钟没有活动，则表明系统已挂起。 </li><li> 端口扩展器：74HC595-使用此扩展器需要控制器的4条支线-3条支线传输状态，1条支线以便在通电时继电器不会发出喀哒声。 下次我将使用PCF8574-i2c总线仍在使用，即 无需额外的MCU支路，并且在通电时将设置输出1。 </li><li> 继电器模块：NoName，8通道，5V-没什么好说的，除了继电器在模块输入端以低电平打开时。 该项目中不允许使用固态继电器，因为 锅炉触点必须通过干触点进行切换-通常，我不知道触点上的电压以及直流或交流电。 </li></ul><br><h2> 作业系统 </h2><br> 操作系统是确保应用程序可操作性的所有软件。 操作系统也是硬件和应用程序之间的一层，提供用于访问硬件资源的高级接口。 对于ESP，操作系统的组件为： <br><br><h3> 文件系统 </h3><br> 该项目使用SPIFFS，在这里一切似乎都很清楚，这是最简单的方法。 为了从外部轻松访问设备上的文件，我使用nailbuster / esp8266FTPServer库。 <br><br><h3>  CPU时间分配系统 </h3><br> 这是操作系统的主要功能之一，ESP也不例外。 对于并行执行算法的各种流程，全局对象（单例）计时器负责。 该类非常简单，并提供以下功能： <br><br><ul><li> 以指定的时间间隔定期执行功能。 计时器初始化示例： <br><br><pre><code class="cpp hljs">Timers.add(doLoop, <span class="hljs-number"><span class="hljs-number">6000</span></span>, F(<span class="hljs-string"><span class="hljs-string">"OneWireSensorsClass::doLoop"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   –  </span></span></code> </pre> </li><li> 在指定的时间段后一次执行功能。 例如，以这种方式执行WiFi网络的延迟扫描： <br><br><pre> <code class="cpp hljs">Timers.once([]() { WiFi.scanNetworks(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);}, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> </li></ul><br> 因此，循环函数如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ESP.wdtFeed(); Timers.doLoop(); CPULoadInfo.doLoop(); }</code> </pre><br> 实际上，循环功能包含更多行，下面将对其进行描述。 <br> 附带了Timers类的清单。 <br><br><h3>  CPU时间核算 </h3><br> 没有实际应用的服务功能。 不过，她是。 由单例CPULoadInfo实现。 初始化对象后，将在很短的时间内测量空循环的迭代次数： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CPULoadInfoClass::init() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currTime = millis(); <span class="hljs-comment"><span class="hljs-comment">//      1 while ((millis() - currTime) &lt; 10) { delay(0); MaxLoopsInSecond++; } MaxLoopsInSecond *= 100; }</span></span></code> </pre> <br> 然后，我们计算每秒循环过程调用的次数，我们以百分比计算处理器负载，并将数据保存到缓冲区： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CPULoadInfoClass::doLoop() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prevTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currTime = millis(); LoopsInSecond++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currTime - prevTime) &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) { memmove(CPULoadPercentHistory, &amp;CPULoadPercentHistory[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CPULoadPercentHistory) - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> load = ((MaxLoopsInSecond - LoopsInSecond) * <span class="hljs-number"><span class="hljs-number">100</span></span>) / MaxLoopsInSecond; CPULoadPercentHistory[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CPULoadPercentHistory) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = load; prevTime = currTime; LoopsInSecond = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br> 使用这种方法可以使每个线程获得相同的处理器使用率（如果将此子系统与Timers类连接在一起），但是正如我所说-我没有看到任何实际的应用程序。 <br><br><h3> 输入输出系统 </h3><br> 为了与用户通信，使用了UART-USB和WEB接口。 我认为关于UART，我不需要详细讨论。 唯一需要注意的是，为了方便和与非ESP兼容，实现了serialEvent（）函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// … if (Serial.available()) serialEvent(); // … }</span></span></code> </pre><br> 使用WEB界面，一切都变得更加有趣。 我们在其中专门介绍了一个部分。 <br><br><h3>  WEB界面 </h3><br> 在我看来，对于智能设备，WEB界面是最人性化的解决方案。 <br><br> 我认为使用连接到设备的屏幕是过时的做法-当使用小屏幕和有限的按钮集时，不可能创建简单，方便，美观的界面。 <br><br> 使用特定程序来控制设备会给用户带来限制，增加了开发和支持这些程序的需要，并且还要求开发人员注意将这些程序交付给用户的终端设备。 以良好的方式，该应用程序应该以deb和rpm软件包的形式在Google，Apple，Windows应用程序商店中发布，并在Linux系统信息库中可用-否则，某些受众可能难以访问设备的界面。 <br><br> 只需安装浏览器，即可从任何操作系统（Linux，Windows，Android，MacOS，台式机，笔记本电脑，平板电脑，智能手机上）访问设备的WEB界面。 当然，WEB界面的开发人员必须考虑各种设备的功能，但这主要涉及尺寸和分辨率。 可以很容易地通过互联网从外部访问房屋/公寓/平房中智能设备的WEB界面-现在很难想象房屋/公寓中没有智能设备并且没有路由器和Internet，并且在路由器中单击几次即可配置此访问权限（对于那些完全不在主题范围内的关键字将对您有所帮助-“端口转发”和“动态DNS”）。 如果是夏季住宅，则可以使用3G路由器进行访问。 <br><br> 要实现WEB界面，需要一个WEB服务器。 我正在使用me-no-dev / ESPAsyncWebServer库。 该库提供以下功能： <br><br><ul><li> 返回静态内容，包括 带有gzip压缩支持。 支持虚拟目录，并能够为每个目录指定主文件（通常为index.htm）。 </li><li> 根据请求的类型（GET，POST等）将回调函数分配给不同的URL </li><li> 支持同一端口上的WEB套接字（在端口转发时很重要）。 </li><li> 基本授权。 此外，为每个URL分别设置授权。 这很重要，因为 例如，谷歌浏览器在主屏幕上创建页面快捷方式时，会请求图标和清单文件，并且不会传输授权数据。 因此，某些文件被放置在虚拟目录中，并且对该目录禁用了授权。 </li></ul><br><h3>  HTTP服务操作系统 </h3><br> 在当前项目中，所有操作系统设置都是使用HTTP服务执行的。  HTTP服务是可通过HTTP使用的小型独立数据检索/修改功能。 接下来，考虑这些服务的列表。 <br><br><h4> 帮忙 </h4><br> 执行任何命令列表，我认为从实施HELP团队开始是正确的。 以下是WEB服务器初始化块： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HTTPserverClass::init() { <span class="hljs-comment"><span class="hljs-comment">//SERVER INIT help_info.concat(F("/'doc_hame.ext': load file from server. Allow methods: HTTP_GET\n")); AsyncStaticWebHandler&amp; handler = server.serveStatic("na/", SPIFFS, "na/"); serveStaticHandlerNA = &amp;handler; //       server.serveStatic("/", SPIFFS, "/"); //    //info //       help_info.concat(F("/info: get system info. Allow methods: HTTP_GET\n")); server.on("/info", HTTP_GET, handleInfo); … server.on("/help", HTTP_GET, [](AsyncWebServerRequest *request) { request-&gt;send(200, ContentTypesStrings[ContentTypes::text_plain], help_info.c_str()); }); //    setAuthentication(ConfigStore.getAdminName(), ConfigStore.getAdminPassword()); DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*"); //  -  //   server.begin(); //       DEBUG_PRINT(F("HTTP server started")); }</span></span></code> </pre><br> 为什么我需要一个帮助系统，我认为这不值一提。 一些开发人员将帮助系统的实施推迟到以后，但是这种“后期”通常不会发生。 在项目开始时实施它并在项目开发过程中对其进行补充要容易得多。 <br> 在我的项目中，还会显示可能的服务列表，并显示404错误-未找到该页面。 当前实施了以下服务： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://tc-demo.vehs.ru/help</a> <br><br><pre> <code class="hljs sql">/'doc_hame.ext': <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> server. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /info: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> info. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> (eg: <span class="hljs-number"><span class="hljs-number">20140527</span></span>T123456). <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /uptime: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> uptime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> (eg: <span class="hljs-number"><span class="hljs-number">123</span></span>D123456). <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /rtc: <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> RTC time. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> ? [dir=...] &amp; [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> json. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /edit: edit files. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_PUT, HTTP_DELETE, HTTP_POST /wifi: edit wifi settings. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /wifi-<span class="hljs-keyword"><span class="hljs-keyword">scan</span></span> ? [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> wifi <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> json. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /wifi-info ? [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> wifi info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> json. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /ap: edit soft ap settings. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: edit <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> settings. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-info ? [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> json. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> flash. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /restart: restart system. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET, HTTP_POST /ws: web socket url. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET /<span class="hljs-keyword"><span class="hljs-keyword">help</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">allow</span></span> URLs. <span class="hljs-keyword"><span class="hljs-keyword">Allow</span></span> methods: HTTP_GET</code> </pre><br> 如您所见，服务列表中没有应用程序服务。 所有HTTP服务都与操作系统有关。 每个服务执行一个小任务。 此外，如果服务需要输入任何数据，则应要求，GET返回一个简约的输入形式： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> USE_RTC_CLOCK help_info.concat(F(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rtc: set RTC time. Allow methods: HTTP_GET, HTTP_POST\n"</span></span></span><span class="hljs-meta">)); const char* urlNTP = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rtc"</span></span></span><span class="hljs-meta">; server.on(urlNTP, HTTP_GET, [](AsyncWebServerRequest *request) { DEBUG_PRINT(F(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rtc"</span></span></span><span class="hljs-meta">)); request-&gt;send(200, ContentTypesStrings[ContentTypes::text_html], String(F(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;head&gt;&lt;title&gt;RTC time&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" action=\"rtc\"&gt;&lt;input name=\"newtime\" length=\"15\" placeholder=\"yyyyMMddThhmmss\"&gt;&lt;button type=\"submit\"&gt;set&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;"</span></span></span><span class="hljs-meta">))); }); server.on(urlNTP, HTTP_POST, handleSetRTC_time); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// USE_RTC_CLOCK</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/cr/-6/na/cr-6napgtebfgiquecvuezhxqia.png"><br><br> 后来，该服务在更漂亮的界面中使用： <br><br><img src="https://habrastorage.org/webt/tt/mn/-o/ttmn-oyhy9v3lygwrk0jk2wzp2o.png"><br><br><h2> 应用软件 </h2><br> 最后，我们来到创建系统的地步。 即-到应用任务的执行。 <br><br> 任何应用程序都必须接收源数据，对其进行处理并产生结果。 系统也应该报告当前状态。 <br><br> 地板采暖控制器的源数据为： <br><br><ul><li> 传感器数据-系统未绑定到特定传感器。 为每个传感器生成一个唯一的标识符。 对于无线传感器，其标识符用0到16位填充；对于1Wire传感器，根据其内部标识符计算CRC16，并将其用作传感器标识符。 因此，所有传感器都具有长度为2个字节的标识符。 </li><li> 加热区的数据-加热区的数量不固定，最大数量受所用继电器模块的限制。 鉴于此限制，还开发了WEB界面。 </li><li> 目标温度和时间表-我尝试进行最灵活的设置，可以创建多个加热方案，甚至可以为每个区域分配自己的设置方案。 </li></ul><br> 因此，有许多设置需要以某种方式进行设置，并且有许多参数需要系统报告为当前状态。 <br> 为了实现控制器与外界之间的通信，我实现了命令解释器，该命令解释器使我既可以实现对控制器的控制又可以接收状态数据。 命令以人类可读的形式传输到控制器，并且可以通过UART或WEB套接字传输（如果需要，您可以实现对其他协议的支持，例如telnet）。 <br> 命令行以“＃”字符开头，以空字符或换行符结尾。 所有命令均由命令名称和操作数组成，并用冒号分隔。 对于某些命令，操作数是可选的；在这种情况下，未指定冒号和操作数。 一行中的命令用逗号分隔。 例如： <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ZonesInfo</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">SensorsInfo</span></span></code> </pre> <br> 当然，命令列表以“帮助”命令开头，该命令显示所有有效命令的列表（为方便起见，传输的命令以“&gt;”而不是“＃”开头）： <br><br><pre> <code class="hljs dos">&gt;<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Help</span></span> SetZonesCount Zone SetName SetSensor ... LoadCfg SaveCfg #<span class="hljs-built_in"><span class="hljs-built_in">Cmd</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Help</span></span>,CmdRes:Ok</code> </pre> <br> 命令解释器的实现的一个特征是，有关命令执行结果的信息也以命令或命令集的形式发布： <br><br><pre> <code class="hljs css">&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">help</span></span> … <span class="hljs-selector-id"><span class="hljs-selector-id">#Cmd</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Help</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">CmdRes</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Ok</span></span> &gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">zone</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:123</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Cmd</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Zone</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Value</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:123</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">CmdRes</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Error</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Error</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Zone</span></span> 123 <span class="hljs-selector-tag"><span class="hljs-selector-tag">not</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">range</span></span> 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">-5</span></span> &gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">SchemasInfo</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#SchemasCount</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:2</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Schema</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Name</span></span>:,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DOWs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0b0000000</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Schema</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:2</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Name</span></span>:,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DOWs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0b0000000</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Cmd</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:SchemasInfo</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">CmdRes</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Ok</span></span></code> </pre><br> 在WEB客户端，还实现了一个外壳程序，该外壳程序接受这些命令并将其转换为图形视图。 例如： <br><br><pre> <code class="hljs css">&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">zonesInfo</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Zone</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Name</span></span>:,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Sensor</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0x5680</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schema</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DeltaT</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-20</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#Cmd</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ZonesInfo</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">CmdRes</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Ok</span></span></code> </pre> <br>  WEB接口向控制器发送了有关区域编号3的请求，并作为响应接收了区域名称，与该区域关联的传感器的标识符，分配给该区域的电路的标识符以及该区域的温度校正。 壳不了解分数，因此温度以十分之一度（即1摄氏度）传递。  12.3度是123的十分之一。 <br><br> 关键功能是，无论输入命令的方法如何，控制器都会对所有命令立即响应所有客户端。 这使您可以立即在WEB界面的所有会话中显示状态更改。 因为 控制器和WEB接口之间的主要交换传输是WEB套接字，然后控制器可以在没有请求的情况下传输数据，例如，当新数据来自传感器时： <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#sensor</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0x5A20</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">type</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:w433th</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">battery</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">button_tx</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">channel</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:0</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">temperature</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:228</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">humidity</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:34</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">uptime_label</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:130308243</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">time_label</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:20180521T235126</span></span></code> </pre> <br> 或者，例如，这些区域需要更新： <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#Zone</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:2</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">TargetTemp</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:220</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">CurrentTemp</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:228</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">Error</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Ok</span></span></code> </pre><br> 控制器的WEB界面基于文本命令的使用。 在界面的一个选项卡上，有一个终端，您可以使用该终端以文本形式输入命令。 另外，此选项卡（用于调试）可让您找出WEB界面通过各种用户操作发送和接收的命令。 <br><br> 通过更改现有命令并添加新命令，命令解释器使更改和增加设备功能变得容易。 同时，这样的系统的调试大大简化了，因为 与控制器的通信仅以人类可读的语言进行。 <br><br><h2> 结论 </h2><br> 使用类似的方法，即： <br><br><ul><li> 将软件分为操作系统和应用程序 </li><li> 以简约的HTTP服务形式实现操作系统设置 </li><li> 将系统逻辑与数据表示分离 </li><li> 使用人类可读的通信协议 </li></ul><br> 使您可以创建用户和开发人员都可以理解的解决方案。 这样的解决方案很容易修改。 基于这样的解决方案，很容易用完全不同的逻辑来构建新设备，但是它们将以相同的原理工作。 您可以创建一系列具有相同接口类型的设备： <br><br><img src="https://habrastorage.org/webt/5b/mg/mh/5bmgmh1jpuzsrdjpreb6jw_yopy.png"><br><br> 如您所见，在该项目中，仅界面的前三页与应用程序直接相关，其余几乎都是通用的。 <br><br> 在本出版物中，我仅描述我对智能设备的构造的看法，在任何情况下我都不会声称这是最终的真理。 <br><br> 这个主题对谁有意思-写，也许我在某件事上是错的，但也许有一些细节可以更详细地描述。 <br><br> 最终发生了什么： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">惨败。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一种自制物联网的故事</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412889/">https://habr.com/ru/post/zh-CN412889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412877/index.html">钌（Ru）-在室温下具有铁磁性的第四种元素</a></li>
<li><a href="../zh-CN412879/index.html">第24期：IT培训-领先公司的当前问题和挑战</a></li>
<li><a href="../zh-CN412881/index.html">BjörnStraustrup：编程问题</a></li>
<li><a href="../zh-CN412885/index.html">病理科学</a></li>
<li><a href="../zh-CN412887/index.html">6月IT活动摘要</a></li>
<li><a href="../zh-CN412891/index.html">Citrix XenServer 7.0 I / O未优化管理代理未安装</a></li>
<li><a href="../zh-CN412893/index.html">在四年内达到高级程序员的水平：“ School 21”方法</a></li>
<li><a href="../zh-CN412895/index.html">Vesta Matveeva：打击网络犯罪是一种道德选择</a></li>
<li><a href="../zh-CN412897/index.html">使用Prometheus监控Atlassian产品</a></li>
<li><a href="../zh-CN412899/index.html">周末读物：30种有关声音的材料，音频品牌的历史和电影业</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>