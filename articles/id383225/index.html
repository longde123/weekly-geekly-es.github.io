<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚪️ 🥊 📶 Beberapa ide konyol untuk produsen hard drive ☯️ 🙏🏽 🏞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hard drive baru-baru ini kehilangan posisi dalam pertarungan melawan SSD, di sisi yang ada kecepatan dan kurangnya ketakutan panik terhadap getaran, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beberapa ide konyol untuk produsen hard drive</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383225/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard drive baru-baru ini kehilangan posisi dalam pertarungan melawan SSD, di sisi yang ada kecepatan dan kurangnya ketakutan panik terhadap getaran, menghemat sendiri hanya karena biaya yang murah untuk menempatkan gigabyte data dan siklus penulisan ulang yang lebih banyak. </font><font style="vertical-align: inherit;">Mari kita pikirkan apakah beberapa ide berikut akan membantu memberikan permulaan untuk HDD.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hard disk terdiri dari satu atau beberapa disk tipis dengan permukaan feromagnetik yang dipasang pada spindle, dipintal oleh mesin hingga kecepatan beberapa ribu putaran per menit. Bagian terpisah adalah blok kepala yang bergerak di sepanjang jari-jari disk. Jika sistem sebelumnya digunakan yang memindahkan blok kepala dalam garis lurus (seperti sistem yang digunakan dalam CD / DVD), sekarang rocker biasanya digunakan. Kepala dipasang di salah satu ujung balok, dan sistem bergerak terletak di sisi lain. Pada awalnya, servos bertanggung jawab atas semua gerakan, tetapi setelah mereka belajar bagaimana membuat magnet yang kuat "banyak dan murah", mekanisme interaksi medan magnet magnet dan medan elektromagnetik dari kumparan kawat yang memasok arus listrik mulai digunakan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai penyimpanan, hard drive menyediakan tiga dimensi:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ilinder - adalah jarak tertentu dari pusat disk, di mana operasi baca, tulis berlangsung, dan sebelum Anda memulainya, Anda perlu memindahkan blok kepala ke satu atau silinder lain;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">head - masing-masing sisi disk pada permukaan data yang dapat ditempatkan, dan di mana head masing-masing ditempatkan, ada juga konsep "trek" yang mendefinisikan data yang ditempatkan pada permukaan tertentu pada silinder yang diberikan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmen - sepotong lingkar trek yang terletak di salah satu permukaan kerja di mana sepotong data sebenarnya berada.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membaca segmen data, hard disk harus memindahkan blok kepala ke silinder yang diinginkan, pilih aliran data dari kepala yang diinginkan dan tunggu sampai disk berubah menjadi segmen yang diinginkan di bawah blok kepala dan hanya dengan demikian data dapat dibaca atau ditulis. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Waktu akses untuk data bervariasi tergantung pada seberapa beruntungnya Anda, dan ada beberapa situasi. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus 1:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda beruntung, dan setelah menerima perintah untuk membaca, hard disk melihat bahwa blok kepala terletak pada silinder yang diinginkan, mulai membaca data dan membaca segmen pertama adalah yang Anda butuhkan. </font><font style="vertical-align: inherit;">Untuk menghitung seberapa beruntungnya Anda, mari kita coba menghitung berapa lama operasi ini akan berlangsung: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentukan variabelnya:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t1 adalah waktu perintah dikirim ke hard drive;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t2-waktu pemrosesan perintah oleh hard disk;</font></font></li>
<li>t3-  ;</li>
<li>t4-     ;</li>
<li>t5-   ;</li>
<li>t6-       </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t3 dan t4 untuk kasus yang dijelaskan cenderung nol dan kami akan mengabaikannya, serta waktu transmisi dari perintah t1 (untuk 10-12 byte dari perintah ini akan menjadi 1/100 bagian dari data) dan waktu pemrosesan dari perintah t2 (tergantung pada kompleksitas perhitungan dan kecepatan prosesor, tetapi kami menganggap bahwa cukup cepat untuk mengabaikan periode ini). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetap ada t5 dan t6 untuk menghitung nilai-nilai ini, kami mengambil karakteristik antarmuka dan pembacaan aliran dari disk (kecepatan membaca sejumlah segmen dalam satu baris dari satu trek). Untuk kesederhanaan perhitungan, kami mendefinisikan bahwa segmen 1000 byte (pada kenyataannya itu adalah 512 atau 4.096 byte data ditambah sejumlah data layanan tertentu), dan streaming membaca sebagai 50 Mb / s (ada lebih banyak, ada lebih sedikit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t5 - 1000 byte * (1 / 50.000.000 byte / s) = 20 μs per baca / tulis dari satu segmen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t6 - tergantung pada kecepatan transfer data, mari kita hitung untuk antarmuka yang berbeda: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDE</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA33 - 33 Mb / s = 1000 * (1/33 000 000) = 30 μs (lebih dari waktu yang dihabiskan untuk membaca)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA66 - 66 Mb / s = 1000 * (1/66 000 000) = 15 μs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA100 - 100 Mb / s = 1000 * (1/100 000 000) = 10 μs</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SATA</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA I -1500 Gbit / s = 150 Mb / s = 1000 * (1/150 000 000) = 6,6 μs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA II / SAS -3000 Gbit / s = 300 Mb / s = 1000 * (1/300 000 000) = 3,3 μs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA III / SAS 2-6000 Gb / s = 600 Mb / s = 1000 * (1/600 000 000) = 1,6 μs</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa saya membagi kecepatan SATA dengan 10 meskipun byte adalah 8 bit? Faktanya adalah bahwa transmisi terjadi dalam mode serial dan untuk mentransfer data dengan andal, baik sinyal sinkronisasi (start dan stop bit, halo </font></font><abbr title="Apakah kau serius?  Port komunikasi - port komunikasi, kadang-kadang diterjemahkan sebagai: Connect Over Modem - koneksi via modem"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port COM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) digunakan atau data dikodekan agar tidak mendapatkan </font></font><abbr title="ketika dengan latar belakang bit yang identik, satu bit dari nilai yang berbeda hilang"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saluran jenuh</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada output </font><font style="vertical-align: inherit;">, pengkodean digunakan sedemikian rupa sehingga meskipun oleh nilai stream byte asli (semua 0 atau 255), sebagai hasilnya kita mendapatkan kombinasi dengan jumlah nol dan yang sama, frekuensi sinyal juga berkurang karena transcoding sinyal (ya, frekuensi lebih rendah dan kecepatan lebih tinggi).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, kami mendapatkan bahwa jika Anda beruntung, Anda akan menerima data Anda dalam 21,6 - 50 μs, dan dari perhitungan dalam kasus ini Anda memahami mengapa pabrikan membuat antarmuka berkecepatan tinggi baru, meskipun fakta bahwa kecepatan membaca dari disk jauh lebih lambat (semakin cepat antarmuka komunikasi, lebih cepat, data Anda dapat ditransfer dari saat siap antara pengirim dan penerima). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus 2:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda tidak seberuntung itu, dan Anda perlu memindahkan kepala blok ke silinder lain, dan setelah silinder yang diinginkan ditemukan, Anda harus menunggu sampai disk berputar 180 derajat untuk mengakses segmen yang diinginkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, saya tidak tahu tentang waktu pemindahan dan pemosisian head, tetapi Anda dapat menghitung berapa banyak waktu yang dibutuhkan untuk memindahkan segmen dalam lingkaran, dan mengambil waktu pemosisian yang sama dengan setengah waktu rotasi disk, dan nilai ini diketahui, jadi kami mempertimbangkan waktu rotasi disk (setengah untuk pemosisian , setengah putaran disk baca). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghitung, Anda perlu mengetahui berapa banyak putaran terjadi per detik, dan kemudian mencari periode dengan membagi 1 dengan jumlah putaran: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5400 rpm - 1 (5400/60) = 11ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5900 rpm - T = 10 ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7200 rpm - T = 8 ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.000 rpm - T = 6 ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15.000 rpm - T = 4 ms</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah Anda menemukan makna yang dikenal? Baik! Waktu akses data rata-rata untuk disk kira-kira sama atau sama dengan periode rotasi disk, mengapa rata-rata? Karena ada: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus 3:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda kurang beruntung, blok kepala berada pada silinder pertama, dan segmen pada bagian terakhir, waktu pergerakan blok kepala hampir atau sebanyak periode rotasi disk setelah blok kepala diposisikan pada silinder yang diinginkan, dan membaca data dimulai, ternyata kami mendapat segmen berikutnya setelah yang diinginkan, dan untuk membacanya, Anda perlu menunggu sampai disk membuat revolusi lain, sementara saya tidak mengatakan apa-apa tentang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kasus 4:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika data bukan dari waktu pertama (dan mungkin berikutnya) pr baca (hitung berapa lama, Minium * T 2 vol.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulan apa yang bisa dibuat pada tahap ini? "Eureka: kamu perlu memutar gelendong hingga 100500 revolusi!". Tapi tidak semuanya begitu sederhana, jika Anda berputar di atas korsel, Anda harus tahu bahwa jika korsel tidak berputar terlalu cepat, maka mudah untuk tetap di sana di bagian mana pun, jika korsel dipelintir terlalu cepat, satu-satunya cara untuk tetap adalah lebih dekat dengan pusat dan pegang erat-erat. Apa yang akan terjadi pada disk jika disk dilepas dengan kuat: pertama, tepi disk akan mulai menyebar ke arah yang berbeda karena gaya sentrifugal, dan disk akan mulai mengembang pada awalnya, bertambah dalam arah yang berbeda, dan karena kecepatan rotasi tidak berkurang, dan karena ukuran disk meningkat, ukuran disk meningkat, sentrifugal juga meningkat kekuatan, yang mengarah pada penghancuran ikatan molekul dan kita mendapatkan "bigbadabum", dan beberapa potong dari disk.Itu karena aksi gaya sentrifugal, cakram berkecepatan tinggi membuat diameter lebih kecil sehingga mereka tidak sobek.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini muncul </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ide konyol pertama</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : mengapa tidak mungkin untuk membuat dua blok kepala saling berhadapan satu sama lain (dan jika berhasil dengan dua, maka coba 3, 4 bahkan bisa 5, 6). Apa ini memberi kita: </font></font><br>
<img src="https://habrastorage.org/files/ea7/0b7/1f6/ea70b71f66814d99ac0e55c794277291.JPG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) dengan peningkatan jumlah bagian, keandalan sistem "menurun", tetapi karena kita mendapatkan sistem cadangan, kita "meningkatkan keandalan". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) blok kepala bergerak secara sinkron (pulsa yang disebabkan oleh gerakan kepala tidak bekerja selama pembacaan / penulisan data), dan jika segmen baru saja lolos, blok kepala kedua akan mendapatkan kesempatan untuk membacanya melalui T rev / 2 (untuk ini, dalam kasus klasik, kita perlu itu akan memutar gelendong dua kali lebih cepat).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) blok kepala bekerja pada tugas yang terpisah (pengaruh impuls pergerakan blok kepala tidak penting untuk operasi baca / tulis), pengontrol, mengetahui di mana segmen ini atau itu berada, dapat memindahkan blok kepala yang paling menguntungkan dalam posisi, untuk mengurangi waktu yang hilang pada rotasi poros dan jumlah operasi input / output akan berlipat ganda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4) Ada dua situasi ketika kita perlu memproses sejumlah besar data sekaligus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-kopi / pindahkan file besar (Hai Blu-ray); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-baca-ubah-tulis satu file (halo ke database).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi klasik hard disk, saat menyalin, kita membaca blok data ke buffer, memindahkan blok kepala ke bagian lain, menulis data, mengembalikan sepotong data baru, dengan sejumlah kecil buffer, kita kehilangan banyak waktu untuk memindahkan blok kepala dengan sejumlah besar data . Dalam hal modifikasi satu file, kita mengisi buffer, memodifikasinya (ini dapat dilakukan bersamaan dengan membaca, segera setelah data pertama dalam konfigurasi yang diinginkan diterima), dan setelah modifikasi kita menulis. Dalam skema yang dimodifikasi, kita dapat menyalin file dengan kecepatan maksimum, membaca data dengan satu blok kepala, dan menulis blok kedua dengan kecepatan tertinggi, yang akan bergantung terutama pada fragmentasi file, sekarang untuk hard drive ini dimungkinkan jika dua drive digunakan , satu baca,menulis ke yang lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aspek kedua dari operasi hard disk adalah keandalannya, dan khususnya kerusakan khusus, kami menghilangkan kerusakan logika program, ini perlu diperbaiki di tempat lain, saya hanya akan mengumumkan kegagalan fungsi yang tergantung pada fitur desain hard disk:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macet spindle selama start-up (well, ada kemungkinan untuk menggulir spindle dengan tindakan eksternal, memulai disk, membaca data dan mengirimkannya ke tempat lain);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemacetan gelendong selama operasi (di sini konsekuensinya sudah tergantung pada keberuntungan Anda);</font></font></li>
<li>      ,    ,         ,           ()       (           ,        );</li>
<li>           ,        ,         ,   ,            ,                ;</li>
<li>     ,        ,            ,    ,                  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua orang tahu bahwa nilai terbesar bukanlah biaya hard drive (hi $ -y), tetapi gigabytes "informasi bermanfaat" yang dikumpulkan dengan cermat. Untuk menyimpan data, sistem RAID dari berbagai tingkatan digunakan, untuk itu diperlukan beberapa hard drive. Di sinilah </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ide konyol kedua</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muncul </font><font style="vertical-align: inherit;">: menggunakan teknologi RAID dalam satu drive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal kegagalan disk lengkap, itu pasti tidak akan menghemat, tetapi dalam kasus kehilangan data dari 1-2 segmen, itu akan sepenuhnya membantu untuk memperbaiki situasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan pertama, yang mudah diimplementasikan oleh perangkat lunak, adalah menempatkan seluruh permukaan, atau hanya data penting atau penting (0 segmen, tabel partisi, file konfigurasi sistem) menggunakan teknologi RAID 5: A + B = Jumlah, mendapatkan dua bagian dari tiga kita dapat dengan mudah mengembalikan yang ketiga, mirror atau duplikasi cukup banyak digunakan, misalnya, beberapa entri Master File Table digandakan dalam NTFS, tetapi ini tidak menghemat banyak jika terjadi kegagalan serius, di samping itu, "mirror" kehilangan setengah dari volume dalam double, sementara dalam kasus pengumpulan statistik segmen yang tidak dapat dibaca, adalah mungkin untuk mewujudkan kemungkinan penempatan data pada "A + B + C + D + E + E + F + G = I" kita akan kehilangan 1/9 volume, tetapi akan meningkatkan peluang pemulihan data jika kehilangan satu segmen data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan kedua, terkait dengan modifikasi logika operasi pengontrol, adalah menggunakan data dengan checksum untuk menempatkan data tidak pada satu trek, tetapi pada permukaan disk yang berbeda, implementasi ini akan menyelamatkan situasi ketika salah satu kepala kerja berhenti merespons sepenuhnya, kami selalu membaca nilai dari permukaan lain akan menerima data awal, tetapi dengan menyimpan data kita dapat dengan tenang menenangkan penderitanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, </font></font><i><s><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ide konyol ketiga</font></font></b></s></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (meskipun menyangkut drive eksternal sebagai kelas) adalah sebagai berikut: delegasikan dukungan untuk alokasi file dan dukungan sistem file ke pengontrol disk.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terima kasih: owniumo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sudah memiliki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard drive kinetik untuk penyimpanan objek yang skalabel</font></font></a><br>
</blockquote> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana ini akan membantu: prosesor pusat hanya akan mentransfer deskriptor file, dan bagian apa yang dibutuhkannya, berhenti terganggu oleh gangguan yang terkait dengan pembangunan rantai FAT, misalnya, dan pengontrol akan menghitung di mana potongan yang ditentukan disimpan dan memberikan pengontrol hanya potongan file yang diinginkan dari file tersebut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menerapkan ini:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengembangan dan penggantian firmware pabrik (mungkin pada perangkat keras saat ini, tetapi mahal dalam hal modifikasi berikutnya, dan jumlah opsi disk, halo untuk pengembang aplikasi seluler);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengembangan sistem file yang akan mendukung firmware dari produsen disk;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengembangan dan implementasi bahasa pemrograman ke dalam firmware dengan bantuan yang Anda dapat menggambarkan pekerjaan dengan sistem file</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah sebenarnya tiga ide konyol yang sulit untuk diuji sendiri, tetapi mereka tidak memberikan Anda tidur yang tenang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS Penggunaan acak atas merek dagang atau paten terdaftar adalah acak. </font><font style="vertical-align: inherit;">Semua ide asli tersedia untuk digunakan di bawah </font></font><abbr title="dan ini adalah masalah terpisah untuk diskusi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perjanjian lisensi bukit semut</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id383225/">https://habr.com/ru/post/id383225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id383213/index.html">Konsekuensi dari Satu Sengketa Privasi Forum</a></li>
<li><a href="../id383215/index.html">Pencitra termal untuk smartphone akan membantu mencuri kode pin kartu bank</a></li>
<li><a href="../id383219/index.html">Proyeksikan "Eye" bagian 10</a></li>
<li><a href="../id383221/index.html">Apakah kita takut akan hal itu? Mana yang lebih berbahaya sekarang - AI atau IOT?</a></li>
<li><a href="../id383223/index.html">Life Sciences adalah perusahaan pertama yang dibuat sebagai bagian dari holding Alphabet</a></li>
<li><a href="../id383227/index.html">Учёные сделали из графена катализатор, добавив наночастицы металлов</a></li>
<li><a href="../id383229/index.html">Obati Sindrom Klik Ganda</a></li>
<li><a href="../id383231/index.html">TS-7063: Ingat tahun 80-an</a></li>
<li><a href="../id383233/index.html">Tentang tes genetik Atlas: bagaimana, mengapa tidak mahal sama sekali, dan mengapa kita lebih baik dan lebih baik</a></li>
<li><a href="../id383235/index.html">Stasiun Cassini mentransmisikan gambar satelit berkualitas tinggi Saturnus Dione</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>