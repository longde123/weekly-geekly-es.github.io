<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎈 ⛏️ 🌜 Erste Schritte für Rust 👩🏽‍🤝‍👨🏼 🙋🏻 👩🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Kürzlich habe ich eine neue Programmiersprache Rust kennengelernt. Ich bemerkte, dass er anders war als andere, denen ich zuvor begegne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erste Schritte für Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433302/"><p><img src="https://habrastorage.org/webt/ra/od/jn/raodjnsmyuf5nphvpqwkhcwliyi.jpeg" alt="Bild"></p><br><p>  Hallo an alle.  Kürzlich habe ich eine neue Programmiersprache Rust kennengelernt.  Ich bemerkte, dass er anders war als andere, denen ich zuvor begegnet war.  Deshalb habe ich mich entschlossen, tiefer zu graben.  Ich möchte die Ergebnisse und meine Eindrücke teilen: </p><br><ul><li>  Ich werde meiner Meinung nach mit den Hauptmerkmalen von Rust beginnen </li><li>  Ich werde interessante Syntaxdetails beschreiben </li><li>  Ich werde erklären, warum Rust wahrscheinlich nicht die Welt übernehmen wird </li></ul><br><p>  Ich werde sofort erklären, dass ich seit ungefähr zehn Jahren in Java schreibe, also werde ich von meinem Glockenturm aus streiten. </p><a name="habracut"></a><br><h1 id="killer-feature">  Killer-Feature </h1><br><p> Rust versucht, eine Zwischenposition zwischen Low-Level-Sprachen wie C / C ++ und High-Level-Java / C # / Python / Ruby einzunehmen. Je näher die Sprache an der Hardware liegt, desto besser ist die Kontrolle über die Ausführung des Codes.  Der vollständige Zugriff auf das Gedächtnis ist jedoch viel einfacher, um Ihr Bein zu schießen.  Im Gegensatz zu C / C ++ erschienen Python / Java und alle anderen.  Sie müssen nicht daran denken, das Gedächtnis zu löschen.  Das Schlimmste ist NPE, Leckagen sind nicht so häufig.  Damit dies funktioniert, benötigen Sie mindestens einen Garbage Collector, der seinerseits parallel zum Benutzercode sein eigenes Leben führt und dessen Vorhersehbarkeit verringert.  Die virtuelle Maschine bietet weiterhin Plattformunabhängigkeit, aber wie viel benötigt wird, ist ein strittiger Punkt. Ich werde ihn jetzt nicht ansprechen. </p><br><p>  Rust ist eine einfache Sprache. Der Compiler gibt eine Binärdatei aus, für deren Arbeit keine zusätzlichen Tricks erforderlich sind.  Die gesamte Logik zum Entfernen unnötiger Objekte ist zum Zeitpunkt der Kompilierung in den Code integriert, d. H.  Zur Laufzeit gibt es auch keinen Garbage Collector.  Rust hat auch keine Nullreferenzen und Typen sind sicher, was es noch zuverlässiger als Java macht. </p><br><p>  Im Zentrum der Speicherverwaltung steht die Idee, eine Objektreferenz zu besitzen und auszuleihen.  Wenn jedes Objekt nur einer Variablen gehört, kann alles, auf das es zeigt, rekursiv gelöscht werden, sobald es am Ende des Blocks abläuft.  Links können auch zum Lesen oder Schreiben ausgeliehen werden.  Hier funktioniert das Prinzip eines Schriftstellers und vieler Leser. </p><br><p>  Dieses Konzept kann im folgenden Code demonstriert werden.  <em>Test</em> <em>()</em> wird von der <em>main ()</em> -Methode aufgerufen, die eine rekursive Datenstruktur <em>MyStruct erstellt</em> , die die Destruktorschnittstelle implementiert.  <em>Mit Drop</em> können Sie die Logik festlegen, die ausgeführt werden soll, bevor das Objekt zerstört wird.  Ähnlich wie beim Finalizer in Java ist der Zeitpunkt des Aufrufs der <em>drop ()</em> -Methode im Gegensatz zu Java ziemlich sicher. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { test(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of main"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = MyStruct { v: <span class="hljs-number"><span class="hljs-number">1</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new( <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(MyStruct { v: <span class="hljs-number"><span class="hljs-number">2</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), }) ), }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of test"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span></span> { v: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;MyStruct&gt;&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyStruct { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cleaning {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.v) } }</code> </pre> <br><p>  Die Schlussfolgerung lautet wie folgt: </p><br><pre> <code class="plaintext hljs">End of test Cleaning 1 Cleaning 2 End of main</code> </pre> <br><p>  Das heißt,  Vor dem Beenden von <em>test () wurde der</em> Speicher rekursiv gelöscht.  Der Compiler hat sich darum gekümmert, indem er den erforderlichen Code eingefügt hat.  Was <em>Box</em> und <em>Option ist,</em> wird etwas später beschrieben. </p><br><p>  Auf diese Weise übernimmt Rust die Sicherheit von Hochsprachen und die Vorhersagbarkeit von Programmiersprachen auf niedriger Ebene. </p><br><h1 id="chto-esche-interesnogo">  Was sonst noch interessant </h1><br><p>  Als nächstes werde ich die Merkmale der Sprache meiner Meinung nach in absteigender Reihenfolge ihrer Wichtigkeit auflisten. </p><br><h2 id="oop">  Oop </h2><br><p>  Hier ist Rust in der Regel den anderen voraus.  Wenn die meisten Sprachen zu dem Schluss gekommen sind, dass die Mehrfachvererbung aufgegeben werden muss, gibt es in Rust überhaupt keine Vererbung.  Das heißt,  Eine Klasse kann nur Schnittstellen in beliebiger Anzahl implementieren, aber nicht von anderen Klassen erben.  In Bezug auf Java würde dies bedeuten, dass alle Klassen endgültig sind.  Im Allgemeinen ist die syntaktische Vielfalt für die Aufrechterhaltung der OOP nicht so groß.  Vielleicht ist das das Beste. </p><br><p>  Zum Kombinieren von Daten gibt es Strukturen, die eine Implementierung enthalten können.  Schnittstellen werden als Merkmal bezeichnet und können auch Standardimplementierungen enthalten.  Sie erreichen keine abstrakten Klassen, weil  kann keine Felder enthalten, viele beschweren sich über diese Einschränkung.  Die Syntax ist wie folgt, ich denke, die Kommentare werden hier nicht benötigt: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { MyPrinter { value: <span class="hljs-number"><span class="hljs-number">10</span></span> }.print(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPrinter</span></span></span></span> { value: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyPrinter { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value) } }</code> </pre> <br><p>  Von den Merkmalen, die mir aufgefallen sind, ist Folgendes zu beachten: </p><br><ul><li>  Klassen haben keine Konstruktoren.  Es gibt nur Initialisierer, die Werte für Felder in geschweiften Klammern angeben.  Wenn Sie einen Konstruktor benötigen, erfolgt dies über statische Methoden. </li><li>  Die Instanzmethode unterscheidet sich von der statischen durch die <em>&amp; self-</em> Referenz als erstes Argument. </li><li>  Klassen, Schnittstellen und Methoden können ebenfalls verallgemeinert werden.  Im Gegensatz zu Java gehen diese Informationen zum Zeitpunkt der Kompilierung jedoch nicht verloren. </li></ul><br><h2 id="esche-nemnogo-bezopasnosti">  Etwas mehr Sicherheit </h2><br><p>  Wie gesagt, Rust achtet sehr auf die Zuverlässigkeit des Codes und versucht, die meisten Fehler bei der Kompilierung zu vermeiden.  Aus diesem Grund wurde die Möglichkeit, Links leer zu machen, ausgeschlossen.  Es erinnerte mich an die nullbaren Typen von Kotlin.  <em>Option wird</em> verwendet, um leere Links zu erstellen.  Genau wie in Kotlin schlägt der Compiler beim Versuch, auf eine solche Variable zuzugreifen, die Hände und zwingt zum Einfügen von Schecks.  Der Versuch, den Wert ohne Überprüfung herauszuziehen, kann zu einem Fehler führen.  Dies kann aber sicherlich nicht zufällig geschehen, wie zum Beispiel in Java. </p><br><p>  Mir hat auch gefallen, dass alle Variablen und Klassenfelder standardmäßig unveränderlich sind.  Hallo nochmal Kotlin.  Wenn sich der Wert ändern kann, sollte dies explizit mit dem Schlüsselwort <em>mut angegeben werden</em> .  Ich denke, der Wunsch nach Unveränderlichkeit verbessert die Lesbarkeit und Vorhersagbarkeit des Codes erheblich.  Obwohl <em>Option</em> aus irgendeinem Grund veränderlich ist, habe ich dies nicht verstanden. Hier ist der Code aus der Dokumentation: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x.take(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(x, <span class="hljs-literal"><span class="hljs-literal">None</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(y, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre> <br><h2 id="perechisleniya">  Transfers </h2><br><p>  Rost heißt <em>Enum</em> .  Nur zusätzlich zu einer begrenzten Anzahl von Werten können sie noch beliebige Daten und Methoden enthalten.  Es ist also etwas zwischen Aufzählungen und Klassen in Java.  Die Standard- <em>Enum-Option</em> in meinem ersten Beispiel gehört einfach zu diesem Typ: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Für die Verarbeitung solcher Werte gibt es eine spezielle Konstruktion: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"empty"</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(v) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, v) } }</code> </pre> <br><h2 id="a-takzhe">  Und auch </h2><br><p>  Ich habe nicht vor, ein Lehrbuch über Rust zu schreiben, sondern möchte nur dessen Merkmale hervorheben.  In diesem Abschnitt werde ich beschreiben, was sonst noch nützlich ist, aber meiner Meinung nach nicht so einzigartig: </p><br><ul><li>  Fans der funktionalen Programmierung werden nicht enttäuscht sein, es gibt Lambdas für sie.  Der Iterator verfügt über Methoden zum Verarbeiten der Sammlung, z. B. <em>filter</em> und <em>for_each</em> .  So etwas wie Java-Streams. </li><li>  Das <em>Übereinstimmungskonstrukt</em> kann auch für komplexere Dinge als die normale <em>Aufzählung verwendet werden</em> , beispielsweise zum Verarbeiten von Mustern. </li><li>  Es gibt eine große Anzahl integrierter Klassen, z. B. Sammlungen: <em>Vec, LinkedList, HashMap</em> usw. </li><li>  Sie können Makros erstellen </li><li>  Es ist möglich, Methoden zu vorhandenen Klassen hinzuzufügen </li><li>  Automatische Typinferenz unterstützt </li><li>  Zusammen mit der Sprache kommt ein Standard-Test-Framework </li><li>  Das integrierte <em>Frachtdienstprogramm</em> wird zum Erstellen und Verwalten von Abhängigkeiten verwendet </li></ul><br><h1 id="lozhki-degtya">  Fliege in die Salbe </h1><br><p>  Dieser Abschnitt ist erforderlich, um das Bild zu vervollständigen. </p><br><h2 id="killer-problem">  Killerproblem </h2><br><p>  Der Hauptnachteil liegt in der Hauptfunktion.  Sie müssen für alles bezahlen.  In Rust ist es sehr unpraktisch, mit veränderlichen Graphdatenstrukturen zu arbeiten, weil  Jedes Objekt sollte nicht mehr als einen Link haben.  Um diese Einschränkung zu umgehen, gibt es eine Reihe integrierter Klassen: </p><br><ul><li>  <em>Box</em> - ein unveränderlicher Wert auf dem Heap, ein Analogon von Wrappern für Grundelemente in Java </li><li>  <em>Zelle</em> - variabler Wert </li><li>  <em>RefCell</em> - variabler Wert, auf den als Referenz <em>zugegriffen</em> werden kann </li><li>  <em>Rc</em> - Referenzzähler für mehrere Verweise auf ein Objekt </li></ul><br><p>  Und das ist eine unvollständige Liste.  Für das erste Rust-Beispiel habe ich mich rücksichtslos entschlossen, eine einfach verknüpfte Liste mit grundlegenden Methoden zu schreiben.  Letztendlich führte die Verknüpfung mit dem Knoten <em>zu der</em> folgenden <em>Option &lt;Rc &lt;RefCell &lt;ListNode&gt; &gt;&gt;</em> : </p><br><ul><li>  <em>Option</em> - um einen leeren Link zu verarbeiten </li><li>  <em>Rc</em> - für mehrere Links, as  Der letzte Knoten wird vom vorherigen Knoten und dem Blatt selbst referenziert </li><li>  <em>RefCell</em> - für veränderlichen Link </li><li>  <em>ListNode</em> - das nächste Element selbst </li></ul><br><p>  Es sieht so lala aus, insgesamt drei Wrapper um ein Objekt.  Der Code zum einfachen Hinzufügen eines Elements am Ende der Liste ist sehr umständlich, und es enthält nicht offensichtliche Dinge wie Klonen und Ausleihen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span></span> { val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, next: Node, } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinkedList</span></span></span></span> { root: Node, last: Node, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = Rc::new(RefCell::new(ListNode { val: val, next: <span class="hljs-literal"><span class="hljs-literal">None</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root.is_none()){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last.map(|v| { v.borrow_mut().next = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()) }); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } ...</code> </pre> <br><p>  Auf Kotlin sieht das viel einfacher aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newNode = ListNode(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value); root = root ?: newNode; last?.next = newNode last = newNode; }</code> </pre> <br><p>  Wie ich später herausfand, sind solche Strukturen nicht typisch für Rust, und mein Code ist völlig nicht idiomatisch.  Die Leute schreiben sogar ganze Artikel: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10 Möglichkeiten, eine Liste in Rust zu erstellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein anderer Weg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qual ähnlich wie meine</a> </li></ul><br><p>  Hier opfert Rust die Lesbarkeit für die Sicherheit.  Darüber hinaus können solche Übungen immer noch zu geloopten Links führen, die im Speicher hängen, weil  Kein Müllsammler wird sie wegnehmen.  Ich habe in Rust keinen Arbeitscode geschrieben, daher fällt es mir schwer zu sagen, wie sehr solche Schwierigkeiten das Leben erschweren.  Es wäre interessant, Kommentare von praktizierenden Ingenieuren zu erhalten. </p><br><h2 id="slozhnost-izucheniya">  Schwierigkeiten beim Lernen </h2><br><p>  Der lange Prozess des Lernens von Rust folgt weitgehend aus dem vorherigen Abschnitt.  Bevor Sie überhaupt etwas schreiben, müssen Sie Zeit damit verbringen, das Schlüsselkonzept des Speicherbesitzes zu beherrschen  es durchdringt jede Linie.  Zum Beispiel hat mich die einfachste Liste ein paar Abende gekostet, während auf Kotlin dasselbe in 10 Minuten geschrieben ist, obwohl dies nicht meine Arbeitssprache ist.  Darüber hinaus sehen viele bekannte Ansätze zum Schreiben von Algorithmen oder Datenstrukturen in Rust anders aus oder funktionieren überhaupt nicht.  Das heißt,  Wenn Sie darauf umsteigen, ist eine tiefere Umstrukturierung des Denkens erforderlich. Es reicht nicht aus, nur die Syntax zu beherrschen.  Dies ist weit entfernt von JavaScript, das alles verschluckt und aushält.  Ich denke, Rust wird niemals die Sprache sein, in der Kinder in einer Programmierschule unterrichtet werden.  Auch C / C ++ hat in diesem Sinne mehr Chancen. </p><br><h1 id="v-itoge">  Zusammenfassend </h1><br><p>  Ich fand die Idee, den Speicher in der Kompilierungsphase zu verwalten, sehr interessant.  In C / C ++ habe ich keine Erfahrung, daher werde ich nicht mit Smart Pointer vergleichen.  Die Syntax ist im Allgemeinen angenehm und es gibt nichts Überflüssiges.  Ich habe Rust für die Komplexität der Implementierung von Graphendatenstrukturen kritisiert, aber ich vermute, dass dies ein Merkmal aller Nicht-GC-Programmiersprachen ist.  Vielleicht war der Vergleich mit Kotlin nicht ganz ehrlich. </p><br><h1 id="todo">  Todo </h1><br><p>  In diesem Artikel habe ich Multithreading überhaupt nicht angesprochen, ich denke, dies ist ein separates großes Thema.  Es gibt jedoch Pläne, eine Datenstruktur oder einen Algorithmus zu schreiben, der komplizierter als die Liste ist. Wenn Sie Ideen haben, teilen Sie diese bitte in den Kommentaren mit.  Es wäre interessant zu wissen, welche Arten von Anwendungen im Allgemeinen in Rust geschrieben sind. </p><br><h1 id="pochitat">  Lesen Sie </h1><br><p>  Wenn Sie an Rust interessiert sind, hier ein paar Links: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmierrost: Schnelle, sichere Systementwicklung</a> - ein gutes Buch, es gibt auch eine elektronische Version </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rostdokumentation</a> - offizielle Dokumentation, es gibt Beispiele </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idiomatischer Rostcode</a> - Liste der Artikel </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ruRust / easy</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ruRust / general</a> - Kanäle in Gitter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">r / rust /</a> - Reddit </li></ul><br><p>  <strong>UPD: Vielen Dank für Ihre Kommentare.</strong>  <strong>Ich habe viele nützliche Dinge für mich gelernt.</strong>  <strong>Korrigierte Ungenauigkeiten und Tippfehler, fügte Links hinzu.</strong>  <strong>Ich denke, solche Diskussionen tragen wesentlich zum Studium neuer Technologien bei.</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433302/">https://habr.com/ru/post/de433302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433292/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 279 (vom 10. bis 16. Dezember)</a></li>
<li><a href="../de433294/index.html">Ein paar einfache Empfehlungen für die Teamarbeit</a></li>
<li><a href="../de433296/index.html">Finanzmanagement in einem IT-Unternehmen</a></li>
<li><a href="../de433298/index.html">Network Digest: 17 Expertenmaterialien zu Wi-Fi und 5G</a></li>
<li><a href="../de433300/index.html">Erstellen eines Home Media Centers. Prolog</a></li>
<li><a href="../de433304/index.html">Lastprüfung mit Heuschrecke. Teil 3</a></li>
<li><a href="../de433306/index.html">Visual Studio 2019</a></li>
<li><a href="../de433308/index.html">Übertragen der PBX-Konfiguration an den 3CX PBX Express-Dienst</a></li>
<li><a href="../de433316/index.html">Design Digest: Onboarding, Feedback, Suche nach Ideen und Entscheidungsfindung</a></li>
<li><a href="../de433318/index.html">garbage.collect ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>