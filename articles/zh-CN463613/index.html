<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎼 🖖🏼 😐 Docker镜像也可以使用常规Dockerfile在werf中构建 👩🏽‍⚖️ 👐🏻 😔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="迟到总比没有好。 或者我们几乎犯了一个严重的错误，没有普通的Dockerfiles支持来构建应用程序映像。 



 我们将讨论werf ，它是一个与任何CI / CD系统集成并提供对整个应用程序生命周期的控制的GitOps实用程序，使您能够： 



- 收集并发布图像 
- 在Kubernete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker镜像也可以使用常规Dockerfile在werf中构建</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/463613/">  <i>迟到总比没有好。</i>  <i>或者我们几乎犯了一个严重的错误，没有普通的Dockerfiles支持来构建应用程序映像。</i> <br><br><img src="https://habrastorage.org/webt/on/ut/ju/onutju4gqnldsccyq0bbeywfnng.png"><br><br> 我们将讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">werf</a> ，它是一个与任何CI / CD系统集成并提供对整个应用程序生命周期的控制的GitOps实用程序，使您能够： <br><br><ul><li> 收集并发布图像 </li><li> 在Kubernetes中部署应用程序 </li><li> 使用特殊策略删除未使用的图像。 </li></ul><a name="habracut"></a><br> 该项目的理念是将低级工具组装到一个统一的系统中，从而使DevOps工程师可以控制应用程序。 在可能的情况下，应使用现有的实用程序（例如Helm和Docker）。 如果无法解决问题，我们可以创建并维护为此所需的一切。 <br><br><h2> 背景：您的图像收集器 </h2><br> 这是werf中的图像收集器发生的情况：我们没有通常的Dockerfile。 如果您快速投入到项目的历史中，那么这个问题就会在werf的第一个版本（当时仍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">称为dapp</a> ） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中显现出来</a> 。 <br><br> 通过创建用于在Docker映像中构建应用程序的工具，我们很快意识到Dockerfile不适合某些非常具体的任务： <br><br><ol><li> 需要根据以下标准方案构建典型的小型Web应用程序： <br><ul><li> 安装系统范围的应用程序依赖项 </li><li> 安装捆绑的应用程序依赖库， </li><li> 收集资产 </li><li> 最重要的是，快速有效地更新图像中的代码。 </li></ul></li><li> 对项目文件进行更改时，构建器必须通过将补丁应用到修改后的文件来快速创建新层。 </li><li> 如果某些文件已更改，则必须重建适当的依赖阶段。 </li></ol><br> 今天，在我们的收藏家中，还有许多其他可能性，但是最初的愿望和冲动就是这些。 <br><br> 通常，无需三思而后行，我们就能使用所使用的编程语言武装自己<i>（见下文），</i>并一路走上-实现<b>我们自己的DSL</b> ！ 与任务相对应，它旨在按阶段描述组装过程，并确定这些阶段对文件的依赖性。 在他<b>自己的收藏家的帮助下</b> ，他将DSL变成了最终目标-组合图像。 最初，DSL是在Ruby中进行的，当我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切换到Golang时</a> ，收集器的配置开始在YAML文件中进行描述。 <br><br><img src="https://habrastorage.org/webt/z5/ji/sr/z5jisrzzlmuxu5r3gct98dovmxq.png"><br>  <i>Ruby上dapp的旧配置</i> <br><br><img src="https://habrastorage.org/webt/wc/h1/jj/wch1jjegx2n6zxtxh3-ky9ouedu.png"><br>  <i>YAML上werf的当前配置</i> <br><br> 收集器的机制也随着时间而改变。 首先，我们只是通过运行中的配置简单地生成了一个临时的临时Dockerfile，然后开始在临时容器中运行汇编指令并进行提交。 <br><br>  <i><b>注意</b> ：目前，我们的收集器已经可以发展成为一个功能非常强大的工具，该收集器使用其配置（在YAML中），并且称为Stapel-collector。</i>  <i>其详细说明应另作文章，主要细节可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>找到。</i> <br><br>
<h2> 问题意识 </h2><br> 但是我们意识到并且没有立即意识到我们犯了一个错误：我们没有添加<b>通过标准Dockerfile收集映像</b>并将其集成到用于集成应用程序管理的相同基础结构中的功能（即收集映像，部署和清理它们）。 您如何在Kubernetes中制作一个部署工具而不实现Dockerfile支持，即 一种描述大多数项目图像的标准方法？ <br><br> 我们没有回答这个问题，而是提供了解决方案。 如果您已经有一个Dockerfile（或一组Dockerfile）并想使用werf怎么办？ <br><br>  <i><b>NB</b> ：顺便说一句，您为什么还要使用werf？</i>  <i>主要功能如下：</i> <br><br><ul><li>  <i>完整的应用程序管理周期，包括图像清理；</i> </li><li>  <i>从单个配置控制多个图像的组合的能力；</i> </li><li>  <i>改进了与Helm兼容的图表部署过程。</i> </li></ul><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在项目页面</a>上可以找到它们的更完整列表。</i> <br><br> 因此，如果早些时候我们建议将Dockerfile重写为我们的配置，现在现在我们将很高兴地说：“让我们来构建您的Dockerfile！” <br><br><h2> 使用方法 </h2><br> 此功能的完整实现出现在<a href="">werf v1.0.3-beta.1版本中</a> 。 一般原则很简单：用户在werf配置中指定现有Dockerfile的路径，然后运行<code>werf build</code> ...命令，就是这样-werf将收集映像。 考虑一个抽象的例子。 <br><br> 在项目的根目录中<code>Dockerfile</code>以下<code>Dockerfile</code> ： <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN echo Building ...</code> </pre> <br> 并声明使用此<code>Dockerfile</code> ： <br><br><pre> <code class="plaintext hljs">configVersion: 1 project: dockerfile-example --- image: ~ dockerfile: ./Dockerfile</code> </pre> <br> 仅此而已！ 仍然<b>需要运行<code>werf build</code></b> ： <br><br><img src="https://habrastorage.org/webt/uk/jm/7j/ukjm7j_4aryw5zgbugqusuxvdue.png"><br><br> 此外，您可以声明以下<code>werf.yaml</code>以便一次从不同的Dockerfile构建多个映像： <br><br><pre> <code class="plaintext hljs">configVersion: 1 project: dockerfile-example --- image: backend dockerfile: ./dockerfiles/Dockerfile-backend --- image: frontend dockerfile: ./dockerfiles/Dockerfile-frontend</code> </pre> <br> 最后，它还支持通过werf配置传输其他构建参数，例如<code>--build-arg</code>和<code>--add-host</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档页面</a>上提供了Dockerfile映像配置的完整说明。 <br><br><h2> 如何运作？ </h2><br> 在构建过程中，Docker中的标准本地层缓存起作用。 但是，重要的是，werf还将<b>Dockerfile配置集成到其基础架构中</b> 。 这是什么意思？ <br><br><ol><li> 从Dockerfile收集的每个映像都包含一个称为<code>dockerfile</code>阶段（有关werf中的各个阶段的更多信息，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读）。 </li><li> 对于阶段， <code>dockerfile</code> werf计算签名，具体取决于Dockerfile配置的内容。 更改Dockerfile配置后， <code>dockerfile</code>阶段签名<code>dockerfile</code>并且werf使用新的Dockerfile配置启动此阶段的重建。 如果签名不变，则werf从缓存中获取图像<i>（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此报告</a>中介绍了有关在werf中使用签名的更多信息）</i> 。 </li><li> 此外，可以<code>werf publish</code>命令<code>werf publish</code>收集的图像（或<code>werf build-and-publish</code> ），并将其用于Kubernetes中的部署。  Docker Registry中发布的映像将使用标准的werf清理器清理，即 它将自动清除旧映像（早于N天），与不存在的Git分支关联的映像以及其他策略。 </li></ol><br> 您可以从文档中了解有关此处描述的要点的更多信息： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布过程</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与Kubernetes中的部署过程集成</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">清洁过程</a> 。 </li></ul><br><h2> 注意事项及注意事项 </h2><br><h3>  1.不支持ADD中的外部URL </h3><br> 当前不支持在<code>ADD</code>指令中使用外部URL。 当资源更改为指定的URL时，Werf将不会启动重建。 计划很快添加此功能。 <br><br><h3>  2.您不能将.git添加到图像 </h3><br> 一般来说，在映像中添加<code>.git</code>目录是一种<s>恶性的</s>坏习惯，原因如下： <br><br><ol><li> 如果<code>.git</code>保留在最终映像中，则违反了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">12因子应用程序</a>的原理：由于最终映像必须与一个提交相关联，因此不可能对任意提交进行<code>git checkout</code> 。 </li><li>  <code>.git</code>增加了图像的大小（由于曾经向其中添加大文件然后删除了大文件，因此存储库可能很大）。 仅与特定提交相关联的工作树的大小将不依赖于Git中的操作历史。 同时，从最终映像中添加然后删除<code>.git</code>将不起作用：该映像仍将获得额外的一层-这就是Docker的工作方式。 </li><li>  Docker可以启动不必要的重建，即使正在构建相同的提交，但使用不同的工作树也是如此。 例如，启用并行汇编后，GitLab在<code>/home/gitlab-runner/builds/HASH/[0-N]/yourproject</code>创建单独的克隆目录。 额外的重建将归因于以下事实：即使收集了相同的提交，同一存储库的不同克隆版本中的<code>.git</code>目录也不同。 </li></ol><br> 最后一点在使用werf时会产生后果。  Werf要求在运行某些命令时（例如<code>werf deploy</code> ）必须存在收集的缓存。 在执行此类命令期间，werf将为werf.yaml中指定的映像计算阶段签名，并且这些签名必须位于程序集缓存中-否则团队将无法继续工作。 如果阶段签名将取决于<code>.git</code>的内容，那么我们将获得一个对无关文件的更改不稳定的缓存，并且werf将无法原谅这种疏忽（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>以获取更多详细信息）。 <br><br> 通常，在任何情况下，通过<code>ADD</code>指令<b>仅添加某些必需的文件都</b>可以提高写入的<code>Dockerfile</code>的效率和可靠性，并且还可以提高此<code>Dockerfile</code>生成的缓存的稳定性，以防止Git的无关更改。 <br><br><h2> 总结 </h2><br> 我们为满足特定需求而编写自己的编译器的最初方法是困难，诚实和直接的：我们不是在标准Dockerfile之上使用拐杖，而是使用自定义语法编写了自己的解决方案。 这样做有其优点：Stapel-builder可以完美地完成其任务。 <br><br> 但是，在编写自己的收集器的过程中，我们忽略了现有Dockerfiles的支持。 现在，此缺陷已得到修复，并且将来我们计划与自定义Stapel收集器一起开发Dockerfile支持，以进行分布式装配和使用Kubernetes的装配（即在Kanbernetes内的转轮上进行装配，就像在kaniko中一样）。 <br><br> 因此，如果您突然在附近有几个Dockerfile，请<b>尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">werf</a></b> ！ <br><br><h2>  PS相关文件清单 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速入门指南</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dockerfile构建器配置</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">舞台设备在werf</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布图像的过程</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与Kubernetes中的部署过程集成</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">清洗工艺</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stapel-builder作为Dockerfile的替代方案</a> 。 </li></ul><br> 还要在我们的博客上阅读：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">werf是Kubernetes中的CI / CD工具（审阅和视频报告）</a> 。” </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463613/">https://habr.com/ru/post/zh-CN463613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463601/index.html">Java / logback中的单独方法记录</a></li>
<li><a href="../zh-CN463605/index.html">技术知识分子-来自深空</a></li>
<li><a href="../zh-CN463607/index.html">带有React Context和hook的Redux内置替代方案</a></li>
<li><a href="../zh-CN463609/index.html">Directum Club的推荐系统。 第一部分，协作</a></li>
<li><a href="../zh-CN463611/index.html">神奇的插件，卷。 2.练习</a></li>
<li><a href="../zh-CN463617/index.html">测试移动MMO的功能</a></li>
<li><a href="../zh-CN463619/index.html">远程工作：我们的经验</a></li>
<li><a href="../zh-CN463623/index.html">我们是从测试的丛林中选拔出来的：从夹具到测试，我们正在建立一条捷径</a></li>
<li><a href="../zh-CN463625/index.html">使用Flowmon Networks解决方案进行网络监视和异常网络活动的检测</a></li>
<li><a href="../zh-CN463627/index.html">AVR微控制器的汇编代码生成器库。 第4部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>