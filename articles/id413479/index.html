<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎓 💅🏼 🙆🏿 Kami menulis protokol kami di atas UDP 👩🏿‍🤝‍👨🏾 🧑🏿 😚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siaran langsung pertama dari tempat itu muncul di Rusia hampir 70 tahun yang lalu dan disiarkan dari stasiun televisi bergerak (PTS), yang tampak sepe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis protokol kami di atas UDP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/413479/">  Siaran langsung pertama dari tempat itu muncul di Rusia hampir 70 tahun yang lalu dan disiarkan dari stasiun televisi bergerak (PTS), yang tampak seperti troli dan diizinkan untuk disiarkan dari luar studio.  Dan hanya tiga tahun yang lalu Periscope diizinkan untuk menggunakan telepon seluler alih-alih “bis listrik”. <br><br>  Tetapi aplikasi ini memiliki sejumlah masalah terkait, misalnya, keterlambatan penyiaran, ketidakmampuan menonton siaran dengan kualitas tinggi, dll. <br><br><img src="https://habrastorage.org/webt/ah/bx/dh/ahbxdhk3rew0amnby0xhqmwct98.jpeg"><br>  Enam bulan kemudian, pada musim panas 2016, Odnoklassniki meluncurkan aplikasi mobile OK Live streaming mereka, di mana mereka mencoba menyelesaikan masalah ini. <br><br>  Alexander Tobol bertanggung jawab atas bagian teknis video di Odnoklassniki dan di Highload ++ 2017 ia berbicara tentang cara menulis protokol UDP Anda, dan mengapa ini mungkin diperlukan. <br><br>  Dari transkrip laporannya, Anda akan mempelajari semua tentang protokol streaming video lainnya, apa nuansanya, dan trik apa yang kadang-kadang diperlukan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Ih0bL2Zp1c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mereka mengatakan bahwa kita harus selalu mulai dengan arsitektur dan TK - seharusnya tidak mungkin tanpa ini!  Jadi mari kita lakukan. <br><a name="habracut"></a><br><h2>  Arsitektur dan TK </h2><br>  Pada slide di bawah ini adalah diagram arsitektur dari setiap layanan streaming: <strong>video diumpankan ke input, dikonversi dan dikirim ke output</strong> .  Kami menambahkan lebih banyak persyaratan untuk arsitektur ini: video harus dipasok dari desktop dan ponsel, dan output harus pergi ke desktop yang sama, ponsel, smartTV, Chromcast, AppleTV dan perangkat lain - semua video dapat diputar. <br><br><img src="https://habrastorage.org/webt/g2/ju/k_/g2juk_sfrmjcu1hv_4ieulhse44.jpeg"><br>  Selanjutnya, kita beralih ke kerangka acuan.  Jika Anda memiliki pelanggan, Anda memiliki TK.  Jika Anda adalah jejaring sosial, Anda tidak memiliki TK.  Bagaimana cara menebusnya? <br><br>  Tentu saja Anda dapat mewawancarai pengguna dan mengetahui semua yang mereka inginkan.  Tetapi itu akan menjadi sejumlah keinginan yang tidak berkorelasi dengan apa yang benar-benar dibutuhkan orang. <br><br>  Kami memutuskan untuk mengambil jalan sebaliknya dan melihat apa yang TIDAK ingin dilihat pengguna dari layanan siaran. <br><br><ul><li>  Hal pertama yang tidak diinginkan pengguna adalah melihat <strong>penundaan pada awal siaran</strong> . <br></li><li>  Pengguna tidak ingin melihat <strong>gambar streaming berkualitas rendah</strong> . <br></li><li>  Jika siaran itu interaktif ketika pengguna berkomunikasi dengan audiensnya (siaran langsung, panggilan, dll.), Maka ia tidak ingin melihat <strong>penundaan antara streamer dan penonton</strong> . <br></li></ul><br>  Seperti inilah layanan streaming normal.  Mari kita lihat apa yang dapat dilakukan untuk melakukan layanan streaming reguler, bukan yang biasa. <br><br><img src="https://habrastorage.org/webt/ik/68/zp/ik68zpbfkto_uh2ukzdpdinqoqi.jpeg"><br>  Anda bisa mulai dengan melihat semua protokol streaming, pilih yang paling menarik dan bandingkan.  Tetapi kami melakukannya secara berbeda. <br><br><h2>  Apa yang dimiliki pesaing? </h2><br>  Kami mulai dengan menjelajahi layanan pesaing.  <strong>Open Periscope - apa yang mereka miliki?</strong> <br><br>  Seperti biasa, yang utama adalah arsitektur. <br><br><img src="https://habrastorage.org/webt/ex/-e/xo/ex-exowlx_iyvaq5xvqmpsjnata.jpeg"><br>  Sara Hyder, insinyur utama Periscope, menulis bahwa mereka menggunakan Wowza untuk backend.  Jika kita membaca sedikit lebih banyak artikel, maka kita akan melihat apa yang mereka streaming menggunakan protokol <strong>RTMP</strong> , dan mendistribusikannya baik dalam RTMP atau dalam HLS.  Mari kita lihat apa protokol ini dan bagaimana cara kerjanya. <br><br>  Kami menguji Periscope pada tiga persyaratan utama kami. <br><img src="https://habrastorage.org/webt/i5/6n/y-/i56ny-rn2pymgbg_pujoroehycm.jpeg"><br>  Mereka memiliki <strong>kecepatan mulai yang</strong> dapat diterima (kurang dari satu detik di jaringan yang baik), <strong>kualitas</strong> konstan sekitar 600 px (bukan HD), dan pada saat yang sama <strong>penundaan bisa mencapai 12 detik</strong> . <br><br>  Ngomong-ngomong, bagaimana mengukur keterlambatan penyiaran? <br><img src="https://habrastorage.org/webt/ug/hs/pa/ughspadkdie3xrgpmxt1vjwrmdm.jpeg"><br>  Ini adalah foto pengukuran keterlambatan.  Ada ponsel dengan timer.  Kami menyalakan siaran dan melihat gambar ponsel ini di layar.  Selama 0,15 milidetik, gambar jatuh pada sensor kamera dan dihapus dari memori video ke layar ponsel.  Setelah itu, kita menyalakan browser dan menonton siaran. <br><br>  Aduh!  Dia sedikit ketinggalan - sekitar 12 detik. <br><br>  Untuk menemukan alasan penundaan, kami profil streaming video. <br><img src="https://habrastorage.org/webt/ce/3u/jg/ce3ujgyeow2snntsekcqqq6xcr4.jpeg"><br>  Jadi, ada ponsel, videonya masuk dari kamera dan masuk ke buffer video.  Di sini penundaannya minimal (≈0,15 ms).  Kemudian encoder mengkodekan sinyal, mengemasnya dalam suatu paket dan mengirimkannya ke buffer soket.  Semuanya terbang ke web.  Selanjutnya, hal yang sama terjadi pada perangkat penerima. <br><br>  Pada dasarnya, ada dua poin sulit utama untuk dipertimbangkan: <br><br><ul><li>  <strong>encoding / decoding video;</strong> <br></li><li>  <strong>protokol jaringan</strong> . <br></li></ul><br><h2>  Pengkodean / Penguraian Video </h2><br>  Saya akan menceritakan sedikit tentang coding.  Anda tetap akan menjumpainya jika Anda melakukan Streaming Langsung Latensi Rendah. <br><img src="https://habrastorage.org/webt/gr/op/o_/gropo_fxvnlubkxnrwdjrbhrj-w.jpeg"><br>  Apa itu video?  Ini adalah seperangkat bingkai, tetapi tidak cukup sederhana.  Frame terdiri dari tiga jenis: I, P dan B-frame: <br><br><ul><li>  <strong>I-frame</strong> hanya jpg.  Bahkan, ini adalah kerangka referensi, tidak bergantung pada siapa pun dan berisi gambar yang jelas. <br></li><li>  <strong>Bingkai-P</strong> semata-mata bergantung pada bingkai sebelumnya. <br></li><li>  <strong>Bingkai-B yang</strong> rumit mungkin bergantung pada masa depan.  Ini berarti bahwa untuk menghitung b-frame, perlu bahwa frame masa depan juga datang dari kamera.  Hanya dengan demikian b-frame dapat diterjemahkan dengan penundaan. <br></li></ul><br>  Ini menunjukkan bahwa <strong>frame</strong> <strong>B</strong> <strong>berbahaya</strong> .  Mari kita coba untuk menghapusnya. <br><br><ol><li>  Jika Anda streaming dari perangkat seluler, Anda dapat mencoba <strong>mengaktifkan profil dasar</strong> .  Ini akan menonaktifkan B-frame. <br></li><li>  Anda dapat mencoba mengkonfigurasi codec dan mengurangi penundaan untuk frame masa depan sehingga frame tiba lebih cepat. <br></li><li>  Hal penting lainnya dalam menyetel codec adalah <strong>dimasukkannya CBR</strong> (laju bit konstan). <br></li></ol><br><img src="https://habrastorage.org/webt/yu/xr/0t/yuxr0tpvsdyvqzkfxd_c7k4rop4.jpeg"><br>  Cara kerja codec diilustrasikan dalam slide di atas.  Dalam contoh ini, video adalah gambar statis, karena penyandiannya menghemat ruang disk, karena  hampir tidak ada perubahan di sana, dan bitrate video rendah.  Perubahan sedang terjadi - entropi bertambah, bitrate video bertambah - bagus untuk menyimpan ke disk. <br><br>  Tetapi pada saat perubahan aktif dimulai, dan bitrate meningkat, kemungkinan besar semua data tidak akan masuk ke jaringan.  Inilah yang terjadi ketika Anda melakukan panggilan video dan mulai berbelok, dan pelanggan Anda memperlambat gambar.  Ini disebabkan oleh fakta bahwa jaringan tidak punya waktu untuk beradaptasi dengan mengubah laju bit. <br><br>  <strong>Seseorang harus memasukkan CBR</strong> .  Tidak semua codec Android akan mendukungnya dengan benar, tetapi mereka akan mengusahakannya.  Artinya, Anda perlu memahami bahwa dengan CBR Anda tidak akan mendapatkan gambar dunia yang sempurna, seperti pada gambar bawah, tetapi masih layak untuk dinyalakan. <br><br>  4. Dan di backend, Anda perlu menambahkan codec <strong>zerolatency</strong> ke H264 - ini akan memungkinkan Anda untuk tidak membuat dependensi dalam bingkai untuk masa depan. <br><br><h2>  Protokol Transfer Video </h2><br>  Pertimbangkan protokol streaming apa yang ditawarkan industri.  Saya membaginya secara kondisional menjadi dua jenis: <br><br><ol><li>  protokol streaming; <br></li><li>  protokol segmen. <br></li></ol><br><img src="https://habrastorage.org/webt/hc/fr/qn/hcfrqnga93h7wofbe6j8ojk1h4g.jpeg"><br>  <strong>Protokol streaming</strong> adalah protokol dari dunia panggilan p2p: <strong>RTMP, webRTC, RTSP / RTP</strong> .  Mereka berbeda dalam hal pengguna menyetujui saluran mana yang mereka miliki, pilih bitrate codec sesuai dengan saluran.  Dan mereka juga memiliki tim tambahan semacam ini, seperti "beri saya referensi".  Jika Anda kehilangan bingkai, dalam protokol ini Anda dapat memintanya lagi. <br><br>  Perbedaan antara <strong>protokol segmen</strong> adalah tidak ada yang bernegosiasi dengan siapa pun.  Mereka memotong video menjadi segmen, menyimpan setiap segmen dalam berbagai kualitas, dan klien dapat memilih segmen mana yang akan ditonton.  Setiap segmen dimulai dengan kerangka referensi. <br><br>  Pertimbangkan protokol secara lebih rinci.  Mari kita mulai dengan protokol streaming dan mencari tahu masalah apa yang mungkin kita temui jika kita menggunakan protokol streaming untuk streaming siaran. <br><br><h3>  Protokol Streaming </h3><br>  Periscope menggunakan RTMP.  Protokol ini muncul pada tahun 2009, dan pada awalnya Adobe tidak sepenuhnya menentukannya.  Kemudian dia mengalami kesulitan tertentu dengan fakta bahwa Adobe ingin menjual servernya secara eksklusif.  Artinya, RTMP berkembang cukup sulit.  Masalah utamanya adalah <strong>ia menggunakan TCP</strong> , tetapi karena beberapa alasan Periscope memilihnya. <br><br><img src="https://habrastorage.org/webt/p3/qf/8x/p3qf8x_qmpcxxs1ydjzdrewzpv8.jpeg"><br><br>  Jika Anda membaca secara detail, ternyata Periscope menggunakan RTMP untuk menyiarkan dengan sejumlah kecil pemirsa.  Hanya siaran seperti itu, jika Anda memiliki saluran yang tidak mencukupi, kemungkinan besar Anda tidak akan bisa menonton. <br><br><img src="https://habrastorage.org/webt/42/cc/oy/42ccoy-bvsta9_1wi47vsetzrpy.jpeg"><br><br>  Pertimbangkan contoh spesifik.  Ada pengguna dengan saluran komunikasi sempit yang menonton siaran Anda.  Anda setuju dengannya pada RTMP tentang bitrate rendah dan mulai streaming untuknya secara pribadi. <br><br>  Seorang pengguna dengan internet keren datang kepada Anda, Anda juga memiliki internet keren, tetapi Anda telah menyetujui kualitas rendah dengan seseorang, dan ternyata yang ketiga ini dengan internet keren sedang menonton aliran dalam kualitas buruk, terlepas dari kenyataan bahwa itu bisa terlihat bagus. <br><br>  Kami memutuskan untuk memperbaiki masalah ini.  Kami memungkinkan RTMP terpotong secara individual untuk setiap klien, yaitu streamer bernegosiasi dengan server, streaming dengan kualitas setinggi mungkin, dan setiap klien menerima kualitas yang dimungkinkan oleh jaringan. <br><br>  Wow! <br><br>  Tapi tetap saja, kami memiliki RTMP lebih dari TCP, dan tidak ada yang menjamin kami dari memblokir awal antrian. <br><br><img src="https://habrastorage.org/webt/pr/ri/db/prridbql3upjieh2baseexcnkoa.jpeg"><br><br>  Ini diilustrasikan dalam gambar: kami menerima bingkai audio dan video, RTMP mengemasnya, mungkin mereka mencampurnya entah bagaimana, dan mereka terbang ke jaringan. <br><br>  Tapi misalkan kita kehilangan satu paket.  Ada kemungkinan bahwa paket kuning yang hilang sama - ini umumnya P-frame dari beberapa yang sebelumnya - bisa saja dijatuhkan.  Mungkin, minimal, seseorang dapat memutar audio.  Tetapi TCP tidak akan memberi kita sisa paket, karena <strong>menjamin pengiriman dan urutan paket</strong> .  Kita harus entah bagaimana berurusan dengan ini. <br><br><img src="https://habrastorage.org/webt/me/vz/at/mevzattuvqxtwrbnu61ubb40nm8.jpeg"><br>  Ada masalah lain dengan menggunakan protokol TCP dalam streaming. <br><br>  Katakanlah kita memiliki buffer dan bandwidth jaringan yang tinggi.  Kami menghasilkan paket resolusi tinggi dari codec kami di sana.  Lalu - op!  - jaringan mulai bekerja lebih buruk.  Di codec, kami telah mengindikasikan bahwa bitrate perlu diturunkan, tetapi paket yang sudah jadi sudah dalam antrian dan <strong>Anda tidak dapat menghapusnya dari sana</strong> dengan cara apa pun.  TCP sangat ingin mendorong paket HD melalui 3G kami. <br><br>  Kami tidak memiliki manajemen buffer, tidak ada prioritas, sehingga <strong>TCP sangat tidak cocok untuk streaming</strong> . <br><br><img src="https://habrastorage.org/webt/nh/ed/xr/nhedxrx0krpqjjtcq3txpq4a0_i.jpeg"><br><br>  Mari kita lihat jaringan seluler sekarang.  Mungkin mengejutkan bagi penduduk ibu kota, tetapi jaringan seluler rata-rata kami terlihat seperti ini: <br><br><ul><li>  Lalu lintas 1,1 Mbps; <br></li><li>  Kehilangan paket 0,1%; <br></li><li>  300 ms RTT rata-rata. <br></li></ul><br>  Dan jika Anda melihat beberapa wilayah dan operator tertentu, maka mereka memiliki <strong>persentase kehilangan paket harian rata</strong> - <strong>rata lebih dari 3%</strong> , dan RTT dari 600 ms adalah normal. <br><br>  TCP, di satu sisi, adalah protokol keren - sangat sulit untuk mengajarkan mobil untuk mengemudi di jalan TOL dan off-road.  Tetapi untuk mengajarinya maka juga untuk terbang di atas jaringan nirkabel sangat sulit. <br><br><img src="https://habrastorage.org/webt/7d/1u/la/7d1ula7h-j6sf-4mb4xyw-pqi_m.jpeg"><br><br><blockquote>  Kehilangan bahkan 0,001% dari paket menghasilkan pengurangan 30% dalam throughput.  Artinya, pengguna kami tidak memanfaatkan saluran sebesar 30% karena ketidakefisienan protokol TCP dalam jaringan dengan kehilangan paket acak. <br></blockquote><br>  Di wilayah tertentu, packet loss mencapai 1%, maka pengguna memiliki sekitar 10% persen dari bandwidth. <br><br>  Karena itu, <strong>kami tidak akan melakukan TCP</strong> . <br><br>  Mari kita lihat apa lagi yang ada di dunia streaming dari UDP. <br><br>  <strong>Protokol WebRTC</strong> telah bekerja dengan sangat baik untuk panggilan P2P.  Di situs yang sangat populer mereka menulis bahwa menggunakannya untuk panggilan sangat keren, tetapi untuk mengirimkan video dan musik itu tidak baik. <br><br>  Masalah utamanya adalah ia <strong>mengabaikan kerugian</strong> .  Dengan semua situasi aneh, dia hanya jatuh. <br><br>  Masih ada beberapa masalah dalam keterikatannya dengan panggilan, faktanya dia mengenkripsi semuanya.  Karena itu, jika Anda menyiarkan siaran, dan tidak perlu mengenkripsi seluruh aliran audio / video dengan memulai WebRTC, Anda tetap akan menyaring prosesor Anda.  Anda mungkin tidak membutuhkan ini. <br><br><img src="https://habrastorage.org/webt/h4/qq/1o/h4qq1o8awojsly2-fo-mggjb30y.jpeg"><br><br>  <strong>Streaming RTP</strong> adalah protokol dasar untuk mengirimkan data melalui UDP.  Di bawah ini pada slide ke kanan adalah serangkaian ekstensi dan RFC yang harus diterapkan di WebRTC untuk menyesuaikan protokol ini untuk panggilan.  Pada prinsipnya, Anda dapat mencoba melakukan sesuatu seperti ini - memanggil satu set ekstensi ke RTP dan mendapatkan streaming UDP.  <strong>Tetapi ini sangat sulit</strong> . <br><br>  Masalah kedua adalah bahwa jika salah satu klien Anda tidak mendukung ekstensi apa pun, maka protokol tidak akan berfungsi. <br><br><img src="https://habrastorage.org/webt/vi/ny/wl/vinywlwh6wfdwrrfznzoiccjjzc.jpeg"><br><br><h3>  Protokol Segmen </h3><br>  Contoh yang bagus dari protokol video tersegmentasi adalah <strong>MPEG-Dash</strong> .  Ini terdiri dari file manifes yang Anda poskan di portal Anda.  Ini berisi tautan ke file dalam kualitas yang berbeda, di awal file ada beberapa indeks yang mengatakan di mana file mana segmen dimulai. <br><br><img src="https://habrastorage.org/webt/9x/kd/py/9xkdpywmis1cfrdrmx6peob2gag.jpeg"><br><br>  Seluruh video dibagi menjadi beberapa segmen, misalnya, selama 3 detik, setiap segmen dimulai dengan kerangka referensi.  Jika Anda menonton video dan perubahan bitrate Anda, maka Anda hanya di sisi klien mulai mengambil segmen kualitas yang Anda butuhkan. <br><br>  Contoh lain dari streaming tersegmentasi adalah <strong>HLS</strong> . <br><br>  MPEG-Dash adalah solusi dari Google, ini bekerja dengan baik di Android, dan solusi Apple lebih tua, ia memiliki sejumlah kelemahan tertentu. <br><br><img src="https://habrastorage.org/webt/ed/jv/wv/edjvwvr9g_-n_tihydmscth_rym.jpeg"><br><br>  Yang pertama adalah manifes utama berisi tautan ke manifes sekunder, manifes sekunder untuk setiap kualitas spesifik berisi tautan ke setiap segmen individu, dan setiap segmen individu diwakili oleh file terpisah. <br><br>  Jika Anda melihat lebih detail, maka di dalam setiap segmen adalah MPEG2-TS.  Protokol ini juga dibuat untuk satelit, ukuran paketnya adalah <strong>188 byte</strong> .  Sangat tidak nyaman untuk mengemas video dalam ukuran ini, terutama karena Anda selalu menyediakannya dengan header kecil. <br><br>  Bahkan, ini sulit tidak hanya untuk server, yang untuk memproses 40 GB lalu lintas harus mengumpulkan <strong>26 juta paket</strong> , tetapi juga sulit bagi klien.  Karena itu, ketika kami menulis ulang pemutar iOS di MPEG-Dash, kami bahkan melihat beberapa peningkatan kinerja. <br><br><img src="https://habrastorage.org/webt/li/iy/-b/liiy-bk2b4hbreygtlsrypgykb4.jpeg"><br><br>  Namun Apple tidak tinggal diam.  Pada 2016, mereka akhirnya mengumumkan bahwa mereka memiliki kesempatan untuk mendorong sebuah fragmen dari MPEG4 di HLS.  Kemudian mereka berjanji untuk menambahkan ini hanya untuk pengembang, tetapi tampaknya sekarang dukungan untuk macOS dan iOS akan muncul. <br><br>  Artinya, akan tampak bahwa streaming fragmen nyaman - datang, ambil fragmen yang diinginkan, mulai dari kerangka referensi - itu berfungsi. <br><br>  Minus: sudah jelas bahwa kerangka referensi dari mana Anda memulai bukanlah bingkai yang dimiliki orang yang melakukan streaming sekarang.  Karena itu, <strong>selalu ada penundaan</strong> . <br><br>  Secara umum, dimungkinkan untuk menyelesaikan HLS hingga keterlambatan urutan 5 detik, seseorang mengatakan bahwa ia berhasil mendapatkan 4, tetapi pada prinsipnya, <strong>keputusan untuk menggunakan streaming fragmen untuk terjemahan tidak terlalu baik</strong> . <br><br><img src="https://habrastorage.org/webt/ot/5d/fx/ot5dfxmgkfjri9h6uqxttl7dwoo.jpeg"><br><br><h3>  Kesulitan vs Penundaan </h3><br>  Mari kita lihat semua protokol yang tersedia dan urutkan berdasarkan dua parameter: <br><br><ul><li>  latensi yang mereka berikan antara siaran dan penonton; </li><li>  kompleksitas </li></ul><br>  Semakin pendek penundaan jaminan protokol, semakin kompleks itu. <br><br><img src="https://habrastorage.org/webt/va/or/jm/vaorjm1gkqcpwvxf1eos4uds90a.jpeg"><br><br><h3>  Apa yang kita inginkan? </h3><br>  Kami ingin membuat protokol UDP untuk streaming dari 1 ke N dengan penundaan yang sebanding dengan komunikasi p2p, dengan opsi enkripsi paket opsional tergantung pada apakah penyiaran publik atau swasta. <br><br>  <strong>Opsi apa lagi yang ada?</strong>  Anda bisa menunggu, misalnya, ketika Google merilis QUIC-nya. <br><br>  Saya akan memberi tahu Anda sedikit apa itu.  Google memposisikan Google QUIC sebagai pengganti TCP - semacam TCP 2.0.  Ini telah dikembangkan sejak 2013, sekarang tidak memiliki spesifikasi, tetapi sepenuhnya tersedia di Google Chrome, dan menurut saya kadang-kadang mereka menyalakannya untuk beberapa pengguna untuk melihat cara kerjanya.  Pada prinsipnya, Anda dapat masuk ke pengaturan, nyalakan QUIC, pergi ke situs Google mana saja dan dapatkan sumber daya ini melalui UDP. <br><br>  Kami memutuskan untuk tidak menunggu sampai mereka semua menentukan, dan untuk mengajukan keputusan kami. <br><br>  Persyaratan Protokol: <br><br><ol><li>  <strong>Multithreading</strong> , yaitu, kami memiliki beberapa aliran - kontrol, video, audio. <br></li><li>  <strong>Jaminan pengiriman opsional</strong> - aliran kontrol memiliki jaminan 100%, video yang paling kami butuhkan - kami dapat meletakkan bingkai di sana, kami masih menginginkan audio. <br></li><li>  <strong>Prioritas aliran</strong> - sehingga audio maju, dan manajer umumnya terbang. <br></li><li>  <strong>Enkripsi opsional</strong> : semua data, atau hanya header dan data penting. <br></li></ol><br><img src="https://habrastorage.org/webt/k6/un/6t/k6un6tc2qxdngdgbjgvycugso80.jpeg"><br><br>  Ini adalah segitiga standar: jika jaringan yang baik, maka kualitas tinggi dan latensi rendah.  Segera setelah jaringan yang tidak stabil muncul, paket-paket mulai menghilang, kami menyeimbangkan antara kualitas dan penundaan.  Kami punya pilihan: menunggu sampai jaringan menjadi lebih baik dan mengirim semua yang telah menumpuk, atau turun dan entah bagaimana hidup dengannya. <br><br>  Jika Anda mengurutkan protokol berdasarkan prinsip ini, maka dapat dilihat bahwa <strong>semakin pendek waktu tunggu, semakin buruk kualitasnya</strong> - kesimpulan yang cukup sederhana. <br><br>  Kami ingin memasukkan protokol kami ke zona di mana penundaan dekat dengan WebRTC, tetapi pada saat yang sama dapat mendorongnya sedikit, karena bagaimanapun kita tidak memiliki panggilan, tetapi siaran.  Pengguna akhirnya ingin menerima aliran kualitas. <br><br><h2>  Pengembangan </h2><br>  Mari kita mulai menulis protokol UDP, tetapi pertama-tama lihat statistiknya. <br><br><img src="https://habrastorage.org/webt/7f/pa/g2/7fpag2oc-8grjh0sprl-xjok9hg.jpeg"><br><br>  Ini adalah statistik kami di jaringan seluler.  Dapat dilihat bahwa rata-rata Internet sedikit lebih dari megabit, paket loss sekitar 1% adalah normal, dan RTT di wilayah 600 ms - pada 3G, ini hanya nilai rata-rata. <br><br>  Kami akan fokus pada ini ketika menulis protokol - ayo! <br><br><h2>  Protokol UDP </h2><br>  Kami membuka soket UDP, kami mengambil data, kami kemas, kami kirim.  Kami mengambil paket kedua dari codec, kami masih mengirim.  Segalanya tampak hebat! <br><br><img src="https://habrastorage.org/webt/_z/mn/pb/_zmnpbiqjqaylvgxteujqyehvi4.jpeg"><br><br>  Tapi kita mendapatkan gambar berikut: jika kita mulai mengirim paket UDP secara acak ke soket, maka menurut statistik, pada paket ke-21 probabilitas yang akan dicapai hanya 85%.  Artinya, packet loss akan menjadi 15%, yang tidak baik.  Ini perlu diperbaiki. <br><br><img src="https://habrastorage.org/webt/-k/9x/yf/-k9xyfgw5atqxwbfgsoz4hwdzpo.jpeg"><br><br>  Ini ditetapkan sebagai standar.  Ilustrasi menggambarkan kehidupan tanpa Pacer dan hidup dengan <strong>Pacer</strong> . <br><br>  Pacer adalah hal yang menyebar paket dalam waktu dan mengendalikan kehilangan mereka;  Itu terlihat pada kehilangan paket apa sekarang, tergantung pada ini menyesuaikan dengan kecepatan saluran. <br><br>  Seperti yang kita ingat, untuk jaringan seluler, paket loss 1-3% adalah norma.  Oleh karena itu, entah bagaimana kita harus bekerja dengan ini.  Bagaimana jika kita kehilangan paket? <br><br><h3>  Kirim ulang </h3><br><img src="https://habrastorage.org/webt/rm/6c/sn/rm6csnnevyp8uer3y_88usgnxvi.jpeg"><br><br>  Dalam TCP, seperti yang Anda ketahui, ada algoritma pengiriman ulang cepat: kami mengirim satu paket, yang kedua, jika paket tersebut hilang, maka setelah beberapa saat (periode pengiriman ulang) kami mengirim paket yang sama. <br><br>  Apa kelebihannya?  Tidak ada masalah, tidak ada redundansi, tetapi ada minus - beberapa <strong>periode pengiriman ulang</strong> . <br><br><img src="https://habrastorage.org/webt/wa/91/8x/wa918xscu2p_r9dym0hxtexa-te.jpeg"><br><br>  Tampaknya sangat sederhana: setelah beberapa waktu Anda perlu mengulangi paket jika Anda belum menerima konfirmasi tentang itu.  Logikanya, ini mungkin waktu yang sama dengan waktu ping.  ping —    ,      RTT time ,   ,   . <br><br>  ,    , ,   ,  jitter:       ping-. ,   ,    46 .     jitter — 50. <br><br><img src="https://habrastorage.org/webt/tc/ut/qp/tcutqprunmcey5nsfas7jobk1ju.jpeg"><br><br>        .   RTT   ,      ,  acknowledge      .  ,  RFC6298,   TCP ,     . <br><br>     jitter.     jitter  ping  15%. ,  retransmit period  ,  ,  20% ,  RTT. <br><br><img src="https://habrastorage.org/webt/ro/0f/ut/ro0futlozzfwqp7frtgd4-26ufg.jpeg"><br><br>     retransmit.       acknowledge   .    ,  ,    .    retransmit period,       .    ,      . <br><br>       ,   retransmit   .   , , packet loss 5%,    400 ,   400    1      packet-drop,  ,    retransmit period  ,      . <br><br>    ,   .    , ,    acknowledge   . ,   —   ,       ,  speculative retransmit   . <br><br>      retransmit,     . <br><br>      .  ,   <strong>Forward Error Correction</strong> ?      , , XOR.    ,       ,       . <br><br><img src="https://habrastorage.org/webt/zd/b1/pe/zdb1pedfxegynl5dx-m7qopdgqw.jpeg"><br><br> !     round trip,      . <br><br>  ,     ,   ?   XOR    — ,   Reed-Solomon, Fountain codes  ..  :   K ,     N  ,   N   . <br><br>   ! <br><br> ,      ,     ,    Forward Error Correction    negative acknowledgement. <br><br><h3> NACK </h3><br><img src="https://habrastorage.org/webt/yy/6d/uv/yy6duvocxiqc43veskkksrfj7s0.jpeg"><br><br>     ,   parity protection (  )    ,    . <br><br>  NACK: <br><br><ul><li>   ,      negative acknowledgement,    . <br></li><li>    FEC. <br></li></ul><br> ,    : <br><br><ol><li>   , FEC + NACK; <br></li><li>   , Fast retransmit. <br></li></ol><br> ,    . <br><br><img src="https://habrastorage.org/webt/zs/tg/dr/zstgdrqijyhnsnbfx4xfpgfixa8.jpeg"><br><br> ,        ,   (  ).    , ,  11 ,     60-80 .  ,   ,   . <br><br>        6 . <br><br><img src="https://habrastorage.org/webt/7p/bm/1e/7pbm1elkbfopc4zogdohequo4zo.jpeg"><br><br>     ,    ,    .    ,    . , Wi-Fi  22    5 , 3G   34   8 . <br><br><img src="https://habrastorage.org/webt/-1/7_/sg/-17_sgwf_vd6x88lryeyqarozfq.jpeg"><br><br> :   ,    90% packet loss     10 ,     gap  25 ,     — FEC + NACK  Fast retransmit? <br><br> , ,  ,  Google,     QUIC  2013 ,  Forward Error Correction  , ,     .   2015   . <br><br>           FEC + NACK,       . <br><br> ,   . <br><br><img src="https://habrastorage.org/webt/vo/vx/en/vovxendpcptrbqle5r-_dsphz7o.jpeg"><br><br>  ,    , c    : <br><br><ul><li> 1 / ; <br></li><li> 1% packet loss; <br></li><li> 300  RTT; <br></li><li> 1 000  —   ; <br></li><li> 1 000    . <br></li></ul><br>        10 .   packet loss  1%    1 000   10.  —    100   1 —  ,        2 ,   . <br><br>     ,     .    500- ,      10 . <br><br>    : <br><br><ul><li>   500      Forward Error Correction.        ,     . <br></li><li>   NACK,   ,    . <br></li><li>      Fast Retransmit,           . <br></li></ul><br>  Forward Error Correction  ,       —  gap      200-300     . <br><br><h3> Fast Retransmit </h3><br>   :  ,      10 ,    , ,    retransmit period ,     . <br><br><img src="https://habrastorage.org/webt/uf/8l/vu/uf8lvu8cm-golfpmgpng1rln25y.jpeg"><br><br>    ,  retransmit period     350 ,     packet gap — 25-30 ,   100.  ,   ,  retransmit   ,         . <br><br>   ,       . <br><br><h3>   </h3><br>       UDP       ,    . <br><br><img src="https://habrastorage.org/webt/rh/lr/nf/rhlrnfukoaeiiy8vxnrku7qbopg.jpeg"><br><br>   ,     ,   p/b-.     .      ,      . <br><br>  ,      ,    ,     ,   , ,  0,5          . <br><br>  ,    ,       ,     ,    p/b,   ,       ,     . <br><br><h3> MTU </h3><br>  Karena kita menulis protokol sendiri, kita harus berurusan dengan fragmentasi IP.  Saya pikir banyak orang tahu tentang ini, tetapi untuk berjaga-jaga, saya akan memberitahu Anda secara singkat. <br><br><img src="https://habrastorage.org/webt/wy/wy/lt/wywyltg-bw2a3ypzpvmkpz1zcsw.jpeg"><br><br>  Kami memiliki server, mengirimkan beberapa paket ke jaringan, mereka datang ke router dan pada levelnya MTU (unit transmisi maksimum) menjadi lebih rendah dari ukuran paket yang tiba.  Ini membagi paket menjadi besar dan kecil (di sini 1100 dan 400 byte) dan mengirimkan. <br><br>  Pada prinsipnya, tidak ada masalah, semuanya akan berkumpul pada klien dan akan bekerja.  Tetapi jika kita kehilangan 1 paket, kita menjatuhkan semua paket, ditambah kita mendapatkan biaya tambahan untuk header paket.  Karena itu, jika Anda menulis protokol Anda, sangat ideal untuk bekerja dalam jumlah MTU. <br><br>  <strong>Bagaimana cara menghitungnya?</strong> <br><br>  Bahkan, Google tidak repot-repot, menempatkan sekitar 1200 byte dalam QUIC dan tidak memilihnya, karena dengan demikian IP fragmentasi akan mengumpulkan semua paket. <br><br><img src="https://habrastorage.org/webt/lj/q0/eu/ljq0eutloqqgituniq6jhfodjwo.jpeg"><br><br>  Kami melakukan hal yang persis sama - pertama-tama kami menetapkan ukuran default dan mulai mengirim paket - biarkan memecahnya. <br><br>  Secara paralel, jalankan utas terpisah dan buat soket dengan bendera larangan fragmentasi untuk semua paket.  Jika router menemukan paket seperti itu dan tidak dapat memecah-mecah data ini, maka itu akan menjatuhkan paket dan mungkin mengirim Anda melalui ICMP bahwa ada masalah, tetapi kemungkinan besar, ICMP akan ditutup dan ini tidak akan terjadi.  Karena itu, kami hanya, misalnya, mencoba tiga kali untuk mengirim paket dengan ukuran tertentu pada interval tertentu.  Jika tidak mencapai, kami percaya bahwa MTU terlampaui dan selanjutnya menguranginya. <br><br>  Dengan demikian, memiliki MTU dari antarmuka internet yang ada di perangkat, dan beberapa MTU minimum, kami cukup memilih MTU yang benar dengan pencarian satu dimensi.  Setelah itu, kami menyesuaikan ukuran paket dalam protokol. <br><br>  Bahkan terkadang berubah.  Kami terkejut, tetapi dalam proses beralih Wi-Fi, dll. MTU berubah.  Lebih baik tidak menghentikan proses paralel ini dan memperbaiki MTU dari waktu ke waktu. <br><br><img src="https://habrastorage.org/webt/x5/db/hy/x5dbhy0sbgn990swfjmqp2s9z8w.jpeg"><br><br>  Distribusi MTU lebih tinggi di dunia.  Kami mendapat sekitar 1100 byte di portal. <br><br><h3>  Enkripsi </h3><br>  Kami mengatakan bahwa kami ingin mengelola enkripsi secara opsional.  Kami membuat pilihan paling sederhana - Diffie-Hellman pada kurva elips.  Kami melakukannya secara opsional - kami mengenkripsi hanya paket kontrol dan header sehingga man-in-the-middle tidak dapat menerima kunci siaran, menyadapnya, dan sebagainya. <br><br><img src="https://habrastorage.org/webt/nn/sv/h3/nnsvh3c3wxoulkrg31ggc8kkvyg.jpeg"><br><br>  Jika siaran bersifat pribadi, maka kami juga dapat menambahkan enkripsi semua data. <br><br>  Paket dienkripsi dengan AES-256 secara independen, sehingga paket drop tidak mempengaruhi enkripsi paket lebih lanjut. <br><br><h3>  Prioritas </h3><br>  Ingat, kami menginginkan lebih banyak prioritas dari protokol. <br><br><img src="https://habrastorage.org/webt/cc/ob/hd/ccobhdbwn5xelxwurrvsz7rxttg.jpeg"><br><br>  Kami memiliki metadata, bingkai audio dan video, kami berhasil mengirimkannya ke jaringan.  Kemudian jaringan kami terbakar di neraka dan untuk waktu yang lama tidak berfungsi - kami memahami bahwa kami perlu menjatuhkan paket. <br><br>  Kami terutama menjatuhkan paket video, kemudian mencoba untuk menjatuhkan audio dan tidak pernah menyentuh paket kontrol, karena data seperti perubahan resolusi dan masalah penting lainnya dapat melewatinya. <br><br><h3>  Roti tambahan tentang UDP </h3><br>  Jika Anda akan menulis protokol UDP Anda, misalnya, dengan komunikasi dua arah, maka Anda perlu memahami bahwa ada NAT Unbinding dan kemungkinan Anda tidak dapat menemukan klien kembali dari server. <br><br><img src="https://habrastorage.org/webt/zs/my/ii/zsmyiips__dpgzghjbdeovvz_6g.jpeg"><br><br>  Pada slide, ada saat-saat ketika itu tidak mungkin untuk menjangkau klien dari server melalui UDP. <br><br>  Banyak skeptis mengatakan bahwa router dirancang sedemikian rupa sehingga NAT Unbinding terutama memadati rute UDP.  Tetapi hal di atas menunjukkan bahwa jika Keep-Alive atau ping kurang dari 30 detik, maka dengan probabilitas 99% akan memungkinkan untuk mencapai klien. <br><br><h3>  Ketersediaan UDP pada perangkat seluler di dunia </h3><br><img src="https://habrastorage.org/webt/nt/mv/5u/ntmv5u_uv_pl1jdgabyewmmhk80.jpeg"><br><br>  Google mengatakan 6%, tetapi ternyata <strong>7% pengguna ponsel tidak dapat menggunakan UDP</strong> .  Dalam hal ini, kami meninggalkan protokol kami yang indah dengan memprioritaskan, enkripsi, dan semuanya, hanya pada TCP. <br><br>  Di UDP, VOIP sekarang berfungsi di WebRTC, Google QUIC, dan banyak gim bekerja di UDP.  Karena itu, saya tidak akan percaya bahwa UDP akan ditutup pada perangkat seluler. <br><br>  Sebagai hasilnya, kami: <br><br><ul><li>  Mengurangi penundaan antara streamer dan watcher menjadi 1 s. <br></li><li>  Kami menyingkirkan efek kumulatif dalam buffer, yaitu siaran tidak ketinggalan. <br></li><li>  Jumlah <strong>kios</strong> di penonton telah <strong>berkurang</strong> . <br></li><li>  Mereka mampu mendukung streaming pada perangkat seluler FullHD. <br></li></ul><br><img src="https://habrastorage.org/webt/im/ql/le/imqlle87zr_gdvhaflkcxe-25_q.jpeg"><br><ul><li>  Penundaan dalam aplikasi seluler OK Live kami adalah 25 ms - 10 ms lebih lama dari pemindai kamera berfungsi, tetapi tidak begitu menakutkan. <br></li><li>  Webcasting menunjukkan penundaan hanya 690 ms - ruang! <br></li></ul><br><h2>  Apa lagi yang bisa streaming di Odnoklassniki </h2><img src="https://habrastorage.org/webt/le/zu/zc/lezuzc64qct36iohbnoyukuab8o.jpeg"><br><br><ul><li>  Terima protokol OKMP kami dari perangkat seluler; <br></li><li>  dapat menerima RTMP dan WebRTC; <br></li><li>  membagikan HLS, MPEG-Dash, dll. <br></li></ul><br>  Jika Anda berhati-hati, Anda perhatikan bahwa saya mengatakan bahwa kami dapat mengambil, misalnya, WebRTC dari pengguna dan mengubahnya menjadi RTMP. <br><br><img src="https://habrastorage.org/webt/me/hc/3c/mehc3cteyxhn2hcsrjd1vmx9z_y.jpeg"><br><br>  Ada nuansa.  Faktanya, WebRTC adalah protokol berorientasi paket dan menggunakan codec audio OPUS.  Anda tidak dapat menggunakan OPUS dalam RTMP. <br><br>  Di server backend, kami menggunakan RTMP di mana-mana.  Oleh karena itu, kami harus membuat beberapa perbaikan di FF MPEG, yang memungkinkan kami untuk mendorong OPUS ke RTMP, mengubahnya menjadi AAC dan memberikannya kepada pengguna yang sudah ada di HLS atau yang lainnya. <br><br><h2>  Seperti apa rupanya di dalam diri kita? </h2><img src="https://habrastorage.org/webt/v_/s2/z4/v_s2z4ja4xlfcuacadyelfpcdj0.jpeg"><br><br><ul><li>  Pengguna yang menggunakan salah satu protokol mengunggah video asli ke server unggah kami. <br></li><li>  Di sana kami menyebarkan protokol. <br></li><li>  Kami mengirim RTMP ke salah satu server transformasi video. <br></li><li>  Dokumen asli selalu disimpan dalam penyimpanan terdistribusi sehingga tidak ada yang hilang. <br></li><li>  Setelah itu, semua video masuk ke server distribusi. <br></li></ul><br>  Untuk zat besi, kami memiliki yang berikut: <br><br><img src="https://habrastorage.org/webt/hb/zc/nl/hbzcnl6smz5tevhx5ud_phg0m0q.jpeg"><br>  Saya akan menceritakan sedikit tentang toleransi kesalahan: <br><br><ul><li>  Upload-server didistribusikan di pusat data yang berbeda, berdiri di belakang IP yang berbeda. <br></li><li>  Pengguna datang, menerima IP pada DNS. <br></li><li>  Upload-server mengirimkan video ke server slicing, mereka memotong dan memberikannya ke server distribusi. <br></li><li>  Untuk siaran yang lebih populer, kami mulai menambahkan lebih banyak server distribusi. <br></li><li>  Kami menyimpan semua yang datang dari pengguna di repositori, sehingga nanti kami dapat membuat arsip siaran dan tidak kehilangan apa pun. <br></li><li>  Penyimpanan yang toleran terhadap kesalahan didistribusikan di tiga pusat data. <br></li></ul><br>  Untuk menentukan server mana yang saat ini bertanggung jawab atas terjemahan, kami menggunakan <strong>ZooKeeper</strong> .  Untuk setiap terjemahan, kami menyimpan node dan membuat node sementara untuk setiap server.  Sebenarnya, ini adalah hal yang memungkinkan aliran membuat antrian server yang akan diproses.  Selalu pemimpin saat ini di baris ini terlibat dalam pemrosesan aliran. <br><br>  Kami akan menguji toleransi kesalahan dengan cepat.  Kami segera mulai dengan hilangnya seluruh pusat data. <br><br>  <strong>Apa yang akan terjadi</strong> <br><br><ul><li>  Pengguna DNS akan mengambil IP berikutnya dari server unggah lain. <br></li><li>  Pada saat ini, ZooKeeper akan mengerti bahwa server di pusat data tersebut telah mati, dan akan memilih slicing server untuk server yang lain. <br></li><li>  Server unduhan akan mencari tahu siapa yang sekarang bertanggung jawab atas transformasi aliran ini dan akan mendistribusikannya. <br></li></ul><br>  Pada prinsipnya, semua ini akan terjadi dengan penundaan minimal. <br><br><h2>  Menggunakan protokol dalam produk </h2>  Kami membuat aplikasi seluler OK Live streaming.  Ini sepenuhnya terintegrasi dengan portal.  Pengguna di sana dapat berkomunikasi, melakukan siaran langsung, ada peta siaran, daftar siaran populer - secara umum, semua yang Anda inginkan. <br><br><img src="https://habrastorage.org/webt/kz/4n/on/kz4nonh4fuveoh5iilwwhipapl8.jpeg"><br><br>  Kami juga menambahkan kemampuan untuk menyiarkan dalam FullHD.  Anda dapat menghubungkan kamera aksi di Android ke perangkat Android. <br><br><img src="https://habrastorage.org/webt/pi/ut/ga/piutgamml44x_nzqt41dlg3t9za.jpeg"><br><br>  Sekarang kami memiliki mekanisme yang memungkinkan siaran langsung.  Misalnya, kami membuat hubungan langsung dengan Presiden melalui OK Live dan menyiarkannya di <strong>seluruh negeri</strong> .  Pengguna menyaksikan dan melalui aliran yang datang dapat mengudara dan mengajukan pertanyaan mereka. <br><br>  Faktanya, dua aliran yang datang dengan penundaan minimum menyediakan format konferensi publik tertentu. <br><br>  Bahkan, kami bertemu di suatu tempat dalam 2 detik - satu detik di sana dan kedua di belakang.  Ingat "troli" yang saya bicarakan di awal artikel - sekarang terlihat seperti 2 truk besar.  Untuk siaran TV, menghapus dari kamera dan hanya mencampur semuanya dengan penundaan sekitar 1-2 detik adalah hal yang normal. <br><br>  Faktanya, kami berhasil mereproduksi sesuatu yang sebanding dengan TCP modern saat ini. <br><br><img src="https://habrastorage.org/webt/si/io/dg/siiodgw1g17mn3b1jt8270ezuo8.jpeg"><br><br>  Siaran langsung adalah tren saat ini.  Selama satu setengah tahun terakhir di portal OK, mereka telah berlipat tiga (bukan tanpa bantuan aplikasi OK Live). <br><br><img src="https://habrastorage.org/webt/lx/sa/4w/lxsa4wk6ltmz8xefbsunlfbqjrq.jpeg"><br><br>  Semua siaran direkam secara default.  Kami memiliki sekitar 50 ribu aliran per hari, ini menghasilkan sekitar 17 terabyte lalu lintas per hari, tetapi secara umum semua video di portal menghasilkan sekitar satu petabyte data per bulan. <br><br><img src="https://habrastorage.org/webt/zg/n3/h6/zgn3h616zrtpcyw7dkgpuwconp4.jpeg"><br><br>  Apa yang kami dapatkan: <br><br><ul><li>  Bisa menjamin durasi penundaan antara streamer dan audiens. <br></li><li>  Kami membuat aplikasi FullHD seluler pertama untuk streaming pada saluran Internet seluler yang berubah secara dinamis. <br></li><li>  Kami mendapat kesempatan untuk kehilangan pusat data dan pada saat yang sama tidak mengganggu siaran <br></li></ul><br>  Apa yang kamu pelajari: <br><br><ul><li>  Apa itu video dan bagaimana cara streaming itu. <br></li><li>  Anda dapat menulis protokol UDP Anda jika Anda tahu pasti bahwa Anda memiliki tugas yang sangat spesifik dan pengguna tertentu. <br></li><li>  Tentang arsitektur layanan streaming apa pun - video memasukkan input, mengonversi, dan keluar. <br></li></ul><br><blockquote>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Highload ++ Siberia,</a> Alexander Tobol berjanji untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang layanan panggilan OK, akan menarik untuk mengetahui apa yang berhasil diterapkan dari apa yang dibahas dalam artikel ini, dan apa yang harus diimplementasikan sepenuhnya lagi. <br><br>  Di bagian yang sama, laporan direncanakan pada topik yang sangat terspesialisasi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eugene Rossinsky</a> (ivi) pada sistem untuk mengumpulkan statistik terperinci tentang pengoperasian node CDN. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anton Rusakova</a> (Badoo) tentang integrasi sistem pembayaran tanpa menggunakan penagihan mereka sendiri. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413479/">https://habr.com/ru/post/id413479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413465/index.html">AMD mengumumkan Threadripper 2 32-core</a></li>
<li><a href="../id413467/index.html">Backup data yang cepat dan andal ke cloud</a></li>
<li><a href="../id413469/index.html">Tes memori membunuh laptop hampir merupakan cerita detektif</a></li>
<li><a href="../id413471/index.html">Friday Mini Tomy Fancy Toy Retrospective</a></li>
<li><a href="../id413473/index.html">Pengembangan saklar sentuh Z-Wave pada baterai dengan tombol bercahaya</a></li>
<li><a href="../id413481/index.html">Ekspor pohon uji dari JMeter ke teks</a></li>
<li><a href="../id413485/index.html">GitLab 10.8 dirilis: mirroring open-source push dan penyebaran tambahan</a></li>
<li><a href="../id413487/index.html">Apa yang seharusnya seorang pengembang harapkan dalam bidang keuangan: kondisi kerja, proyek, dan keterampilan yang diperlukan</a></li>
<li><a href="../id413489/index.html">Bagaimana memilih messenger yang benar-benar aman dan apa hubungannya dengan blockchain</a></li>
<li><a href="../id413491/index.html">Intisari Desain Makanan, Mei 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>