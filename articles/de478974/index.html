<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõê üóΩ ü§ñ Modul Autoload mit dynamischem Import üïå ‚òÑÔ∏è üëª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich wurde in Node.js die Unterst√ºtzung f√ºr ECMAScript-Module angek√ºndigt , und in ES2020 wurde die Unterst√ºtzung f√ºr dynamische Importe eingef√ºhr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modul Autoload mit dynamischem Import</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478974/"><p>  K√ºrzlich wurde in Node.js die Unterst√ºtzung f√ºr ECMAScript-Module <a href="https://medium.com/%40nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="nofollow">angek√ºndigt</a> , und in ES2020 wurde die Unterst√ºtzung f√ºr <a href="https://v8.dev/features/dynamic-import" rel="nofollow">dynamische Importe</a> eingef√ºhrt.  In diesem Artikel werde ich √ºber die Implementierung des offensichtlichen Falls der Verwendung dynamischer Importe sprechen - mit unbekannten Verzeichnisnamen im Voraus. </p><br><p><img src="https://habrastorage.org/webt/xf/tq/5x/xftq5xiu8t_um1cnsinetckoqee.png" alt="bedecken"></p><a name="habracut"></a><br><h1 id="problematika">  Ausgabe </h1><br><p>  Oft beobachte ich in Projekten ungef√§hr folgende Verzeichnisstruktur: </p><br><pre><code class="plaintext hljs">$ tree . ‚îú‚îÄ‚îÄ modules ‚îÇ ‚îú‚îÄ‚îÄ a ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ index.ts ‚îÇ ‚îú‚îÄ‚îÄ b ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ index.ts ‚îÇ ‚îî‚îÄ‚îÄ c ‚îÇ ‚îî‚îÄ‚îÄ bobule.ts ‚îú‚îÄ‚îÄ index.ts ‚îî‚îÄ‚îÄ package.json</code> </pre> <br><p>  und den Inhalt von <code>index.ts</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/c/bobule.ts'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">module</span></span>: a, <span class="hljs-attr"><span class="hljs-attr">dopule</span></span>: b, <span class="hljs-attr"><span class="hljs-attr">bobule</span></span>: c };</code> </pre> <br><p>  Und dann irgendwo auf der obersten Ebene gibt es einen anderen index.ts, der diesen index.ts importiert, der importiert ... </p><br><p>  Ich w√ºrde gerne so etwas wie top-level <code>index.ts</code> </p><br><pre> <code class="plaintext hljs">import modules from './modules/*/*'</code> </pre> <br><p>  aber aus der Box heraus wird dies nicht unterst√ºtzt, was in mir einen unb√§ndigen Wunsch weckte, meine zu verarschen <del>  Kr√ºcke, Fahrrad, Rahmen </del>  Zweifellos eine n√ºtzliche, originelle und sehr notwendige L√∂sung f√ºr dieses Problem. </p><br><h1 id="dinamicheskie-importy">  Dynamische Importe </h1><br><p>  Der Hauptvorteil des Importierens von Dynamik gegen√ºber Statik ist die funktionale Form, die das Laden von Modulen nach Bedingung erm√∂glicht.  Es funktioniert so: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// module.ts export const a = 'i love hexlet' const b = { referral: 'hexlet.io/?ref=162475' } export default b // index.ts const module = await import('./module.ts') module.default // { referral: 'hexlet.io/?ref=162475' } module.a // 'i love hexlet'</span></span></code> </pre> <br><p>  <code>fs</code> diesem Design ein wenig <code>fs</code> hinzuf√ºgen, k√∂nnen Sie mit dynamischen Importen alle Dateien aus Unterverzeichnissen auf jeder Ebene abrufen. </p><br><h1 id="vdohnovlyonnyy-php">  PHP inspiriert </h1><br><p>  Die Idee des Autoloads ist nicht neu und wird in PHP aus architektonischen und historischen Gr√ºnden aktiv verwendet, aber nichts hindert mich daran, meine eigenen Schwierigkeiten zu schaffen und sie heldenhaft zu √ºberwinden.  Daher habe ich versucht, einen Autoload-Abschnitt in package.json zu erstellen und ein Tool zu erstellen, das den Modulnamen anhand des Schl√ºssels und den Dateipfad anhand des folgenden Werts liest: </p><br><pre> <code class="json hljs">//  package.json { <span class="hljs-attr"><span class="hljs-attr">"autoload"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"index.ts"</span></span>] <span class="hljs-string"><span class="hljs-string">"bobules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"bobule.ts"</span></span>], } }</code> </pre> <br><p>  Bei der Verwendung von typescipt ist es √§rgerlich, dass sich die Erweiterungen nach dem Erstellen der Anwendung √§ndern und es mehr als zwei davon gibt: <code>ts|js|mjs|tsx</code> Sie k√∂nnen dies also sofort ber√ºcksichtigen, indem Sie alle verf√ºgbaren Optionen auflisten und nur die ben√∂tigten herunterladen: </p><br><pre> <code class="json hljs">//  package.json { <span class="hljs-attr"><span class="hljs-attr">"autoload"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"index.ts|js"</span></span>] <span class="hljs-string"><span class="hljs-string">"bobules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"bobule.ts|js"</span></span>], } }</code> </pre> <br><h1 id="realizaciya">  Implementierung </h1><br><p>  Die folgenden F√§lle werden erhalten: </p><br><ol><li>  <code>f(projectRoot, ['modules', '*', 'index.js|ts'], moduleName = 'default')</code> // <code>f(projectRoot, ['modules', '*', 'index.js|ts'], moduleName = 'default')</code> die Module auf den vom Benutzer angegebenen Pfad </li><li>  <code>f(projectRoot)</code> // Laden von Modulen aus package.json, Modulnamen (Schl√ºssel im Autoload-Bereich) werden in diesem Fall vom dritten Argument bereits "under the hood" √ºbergeben. </li></ol><br><p>  Das Erstellen von Pfaden ist eine triviale Aufgabe. Wir gehen einfach das Array durch und w√§hlen alle Unterverzeichnisse f√ºr die Sterne aus. Wenn das Array endet, geben Sie es zur√ºck und laden die Module in das Array.  Infolgedessen habe ich einige Abende lang diese L√∂sung f√ºr mich entworfen: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   package.json /   const modulesRawPathsParts = await getModulesRawPaths( projectRoot, modulePath, moduleGroupName ); //         const modulesFilesPathsParts = entries(modulesRawPathsParts).reduce( (acc, [moduleName, moduleRawPath]) =&gt; { const rawFilename = moduleRawPath.pop(); const processedFilenames = processFileExtensions(rawFilename); const pathsWithFilenames = processedFilenames.map( filename =&gt; moduleRawPath.concat(filename) ); return { ...acc, [moduleName]: pathsWithFilenames }; }, {} ); //       const modulesFilesPaths = await Promise.all( entries(modulesFilesPathsParts).map(([moduleName, modulePathParts]) =&gt; Promise.all( modulePathParts.map(modulePathPart =&gt; buildPaths(projectRoot, modulePathPart)) ) .then(paths =&gt; paths.flat().filter(processedPath =&gt; processedPath)) .then(existingPaths =&gt; ({ [moduleName]: existingPaths })), ), ); const processedModulesFilesPaths = arrayToObject(modulesFilesPaths); //    ,       const availableModules = entries(processedModulesFilesPaths).reduce( (acc, [moduleName, modulePaths]) =&gt; (modulePaths.length === 0 ? acc : { ...acc, [moduleName]: modulePaths }), {}, ); //   return Promise.all( entries(availableModules).map(([moduleName, modulePaths]) =&gt; Promise.all(modulePaths.map(moduleLoadPath =&gt; //     : import(moduleLoadPath) )).then(loadedModule =&gt; ({ [moduleName]: loadedModule, })), ), ).then(arrayToObject);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/u9/9o/or/u99ooru0jkdcq9bclelznor0n9s.png" alt="nur noch Typoskript zum Schummeln"></p><br><h1 id="zachem-eto-vsyo">  Warum ist das alles? </h1><br><p>  Es schien mir, dass das Thema dynamischer Importe zu Unrecht sehr schlecht behandelt wurde und alle diese Bibliotheken in npm nicht leicht aktualisiert wurden (oder sah ich schlecht aus?). Und die Technologie erm√∂glicht es Ihnen, ohne Registrierung und SMS auszukommen.  Ich hoffe, dass der Quellcode des Projekts und meine Verwendungsf√§lle Sie f√ºr die Verwendung in Ihren Projekten interessieren und die Codevervielf√§ltigung durch Verschrauben leicht reduzieren <del>  Kr√ºcke, Fahrrad, Rahmen </del>  zweifellos ein n√ºtzlicher Helfer. </p><br><hr><br><p>  Links, Beweise, √úbersetzungen: </p><br><ul><li>  ECMAScript-Module <br><ul><li>  original: <a href="https://medium.com/%40nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="nofollow">https://medium.com/@nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663</a> </li><li>  √úbersetzung: <a href="https://habr.com/ru/post/477168/">https://habr.com/de/post/477168/</a> </li></ul></li><li>  Dynamische Importe: <br><ul><li>  original: <a href="https://v8.dev/features/dynamic-import" rel="nofollow">https://v8.dev/features/dynamic-import</a> </li><li>  kostenlose √úbersetzung: <a href="https://habr.com/ru/post/455200/">https://habr.com/de/post/455200/</a> </li></ul></li></ul><br><p>  Der Quellcode f√ºr diesen fehlerlosen Code ist hier: <br>  <a href="" rel="nofollow">https://github.com/Melodyn/npm-dynamicimport/blob/master/lib/index.js#L93-L120</a> <br>  Erhalten Sie hier eine unsch√§tzbare Benutzererfahrung: <br>  <a href="https://www.npmjs.com/package/%40melodyn/dynamicimport" rel="nofollow">https://www.npmjs.com/package/@melodyn/dynamicimport</a> <br>  Die Katze ist hier: <br>  (^ ‚âóœâ‚âó ^) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478974/">https://habr.com/ru/post/de478974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478962/index.html">Ilya Yakyamsev: Effizienz funktioniert nicht</a></li>
<li><a href="../de478966/index.html">Wie kann man in der modernen Welt √ºberleben und Frontend-Entwickler werden?</a></li>
<li><a href="../de478968/index.html">SpaceX bringt Nanoracks auf den Markt, um Weltraumm√ºll-Orbitalstationen zu bauen</a></li>
<li><a href="../de478970/index.html">DIY Ruftaste Teil 2. Bildtelefon von Raspberry Pi</a></li>
<li><a href="../de478972/index.html">Gewinner des Miro-Plattformwettbewerbs</a></li>
<li><a href="../de478978/index.html">Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche</a></li>
<li><a href="../de478980/index.html">Azure SDK f√ºr .NET: Die Geschichte eines schwierigen Fehlersuchers</a></li>
<li><a href="../de478986/index.html">Yandex hat eine popul√§re Abstimmung f√ºr Retro-Spiele gestartet. Finalisten der Retro Games Battle 2019</a></li>
<li><a href="../de478988/index.html">Venedig: wilder Gewinn auf ein paar nackten Steinen</a></li>
<li><a href="../de478990/index.html">Installation eines verteilten ausfallsicheren LeoFS-Speichers, der mit Clients kompatibel ist, die S3, NFS verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>