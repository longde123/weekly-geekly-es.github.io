<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥¡ ğŸ‘©ğŸ¿â€âš•ï¸ ğŸ’ƒğŸ¿ Aplikasi TDD pada Spring Boot: bekerja dengan database ğŸ“³ ğŸ· âœ‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel kedua dari seri "Test-Driven Development of application on Spring Boot" dan kali ini saya akan berbicara tentang pengujian akses ke database, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi TDD pada Spring Boot: bekerja dengan database</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433958/"><p>  Artikel kedua dari seri "Test-Driven Development of application on Spring Boot" dan kali ini saya akan berbicara tentang pengujian akses ke database, aspek penting dari pengujian integrasi.  Saya akan memberi tahu Anda cara menentukan antarmuka layanan di masa mendatang untuk akses data melalui pengujian, cara menggunakan basis data di dalam memori untuk pengujian, bekerja dengan transaksi, dan mengunggah data pengujian ke basis data. </p><a name="habracut"></a><br><p>  Saya tidak akan banyak bicara tentang TDD dan pengujian secara umum, saya mengundang semua orang untuk membaca artikel pertama - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana membangun piramida di bagasi atau Test-Driven Development aplikasi pada Spring Boot / majalah geek</a> </p><br><p>  Saya akan mulai, seperti terakhir kali, dengan bagian teoretis kecil, dan beralih ke tes ujung ke ujung. </p><br><h1 id="piramida-testirovaniya">  Menguji Piramida </h1><br><p>  Untuk mulai dengan, deskripsi kecil tetapi perlu dari entitas yang penting dalam pengujian sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piramida Uji</a> atau <em>piramida pengujian</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="gambar"></p><br><p>  (diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piramida Tes Praktis</a> ) </p><br><p>  Piramida pengujian adalah pendekatan ketika tes diselenggarakan pada beberapa tingkatan. </p><br><ul><li>  Tes <strong>UI</strong> (atau end-to-end, <strong>E2E</strong> ) sedikit dan mereka lambat, tetapi mereka menguji aplikasi yang sebenarnya - tidak ada tiruan dan rekan tes.  Bisnis sering berpikir pada tingkat ini dan semua kerangka kerja BDD tinggal di sini (lihat Mentimun di artikel sebelumnya). </li><li>  Mereka diikuti oleh <strong>tes integrasi</strong> (layanan, komponen - masing-masing memiliki terminologi sendiri), yang sudah fokus pada komponen tertentu (layanan) sistem, mengisolasinya dari komponen lain melalui moki / ganda, tetapi masih memeriksa integrasi dengan sistem eksternal nyata - tes ini terhubung ke database, kirim permintaan REST, saya bekerja dengan antrian pesan.  Bahkan, ini adalah tes yang memverifikasi integrasi logika bisnis dengan dunia luar. </li><li>  Di bagian paling bawah adalah <strong>tes unit</strong> cepat yang menguji blok kode minimum (kelas, metode) dalam isolasi lengkap. </li></ul><br><p>  Spring membantu dengan menulis tes untuk setiap level - <em>bahkan untuk tes unit</em> , meskipun ini mungkin terdengar aneh, karena di dunia unit test tidak ada pengetahuan tentang kerangka kerja yang harus ada sama sekali.  Setelah menulis tes E2E, saya hanya akan menunjukkan bagaimana Spring memungkinkan bahkan hal-hal "integrasi" murni seperti pengendali untuk menguji secara terpisah. </p><br><p>  Tapi saya akan mulai dari bagian paling atas piramida - tes UI lambat, yang dimulai dan menguji aplikasi lengkap. </p><br><h1 id="end-to-end-test">  Tes ujung ke ujung </h1><br><p>  Jadi, fitur baru: </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price Â£3.95 And she sees that "Victoria Sponge" is available with price Â£5.50</code> </pre> <br><blockquote>  Dan di sini ada aspek yang langsung menarik - apa yang harus dilakukan dengan tes sebelumnya, tentang salam di halaman utama?  Sepertinya sudah tidak relevan lagi, setelah meluncurkan situs di halaman utama sudah akan ada direktori, bukan salam.  Tidak ada jawaban tunggal, saya akan mengatakan - itu tergantung pada situasinya.  Tapi saran utama - jangan melekat pada tes!  Hapus ketika mereka kehilangan relevansi, tulis ulang untuk membuatnya lebih mudah dibaca.  Terutama tes E2E - ini seharusnya, pada kenyataannya, <strong>spesifikasi yang hidup dan saat ini</strong> .  Dalam kasus saya, saya baru saja menghapus tes lama, dan menggantinya dengan yang baru, menggunakan beberapa langkah sebelumnya dan menambahkan yang tidak ada. </blockquote><p>  Sekarang saya sampai pada poin penting - pilihan teknologi untuk menyimpan data.  Sesuai dengan pendekatan <em>lean</em> , saya ingin menunda pilihan sampai saat terakhir - ketika saya akan tahu pasti apakah model relasional atau tidak, apa persyaratan untuk konsistensi, transaksionalitas.  Secara umum, ada solusi untuk ini - misalnya, penciptaan <strong>kembar uji</strong> dan berbagai penyimpanan <strong>dalam memori</strong> , tetapi sejauh ini saya tidak ingin menyulitkan artikel dan segera memilih teknologi - basis data relasional.  Tetapi untuk menjaga setidaknya beberapa kemungkinan memilih database, saya akan menambahkan abstraksi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Data JPA</a> .  JPA sendiri adalah spesifikasi yang cukup abstrak untuk mengakses basis data relasional, dan Spring Data membuatnya lebih mudah digunakan. </p><br><blockquote>  Spring Data JPA menggunakan Hibernate sebagai penyedia secara default, tetapi juga mendukung teknologi lain, seperti EclipseLink dan MyBatis.  Untuk orang-orang yang tidak terlalu terbiasa dengan Java Persistence API - JPA seperti antarmuka, dan Hibernate adalah kelas yang mengimplementasikannya. </blockquote><p>  Jadi, untuk menambahkan dukungan JPA, saya menambahkan beberapa dependensi: </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p>  Sebagai basis data saya akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">H2</a> - basis data tertanam yang ditulis dalam Java, dengan kemampuan untuk bekerja dalam mode dalam memori. </p><br><p>  Menggunakan Spring Data JPA, saya segera mendefinisikan antarmuka untuk mengakses data: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  Dan intinya: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p>  Ada beberapa hal yang kurang jelas dalam deskripsi entitas. </p><br><ul><li>  <code>@NaturalId</code> untuk bidang <code>sku</code> .  Bidang ini digunakan sebagai "pengidentifikasi alami" untuk memeriksa kesetaraan entitas - menggunakan semua bidang atau bidang <code>@Id</code> dalam metode <code>equals</code> / <code>hashCode</code> lebih merupakan anti-pola.  Ditulis dengan baik tentang cara memverifikasi dengan benar kesetaraan entitas, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li><li>  Untuk sedikit mengurangi kode boilerplate, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Project Lombok</a> - prosesor anotasi untuk Java.  Ini memungkinkan Anda untuk menambahkan berbagai hal berguna, seperti <code>@Builder</code> - untuk secara otomatis menghasilkan pembangun untuk kelas dan <code>@AllArgsConstructor</code> untuk membuat konstruktor untuk semua bidang. </li></ul><br><p>  Implementasi antarmuka akan disediakan secara otomatis oleh Spring Data. </p><br><h1 id="vniz-po-piramide">  Menuruni piramida </h1><br><p>  Sekarang adalah waktunya untuk turun ke tingkat piramida berikutnya.  Sebagai aturan praktis, saya akan menyarankan Anda <strong>selalu mulai dengan tes e2e</strong> , karena ini akan memungkinkan Anda untuk menentukan "tujuan akhir" dan batas-batas fitur baru, tetapi tidak ada aturan ketat lebih lanjut.  Tidak perlu menulis tes integrasi terlebih dahulu, sebelum pindah ke tingkat unit.  Paling sering lebih nyaman dan lebih sederhana - dan itu wajar untuk turun. </p><br><p>  Tetapi khusus sekarang, saya ingin segera melanggar aturan ini dan menulis unit test yang akan membantu menentukan antarmuka dan kontrak komponen baru yang belum ada.  Pengontrol harus mengembalikan model yang akan diisi dari komponen X tertentu, dan saya menulis tes ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"Â£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"Â£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p>  Ini adalah unit test murni - tidak ada konteks, tidak ada database di sini, hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mockito</a> untuk mok.  Dan tes ini hanyalah demonstrasi yang bagus tentang bagaimana Spring membantu pengujian unit - <em>controller di Spring MVC hanyalah kelas yang metodenya menerima parameter tipe biasa dan mengembalikan objek POJO - Lihat Model</em> .  Tidak ada permintaan HTTP, tidak ada respons, header, JSON, XML - semua ini akan secara otomatis diterapkan di tumpukan dalam bentuk konverter dan serializer.  Ya, ada "petunjuk" kecil untuk Spring dalam bentuk <code>ModelAndView</code> , tetapi ini adalah POJO biasa dan Anda bahkan dapat menyingkirkannya jika diinginkan, diperlukan khusus untuk pengontrol UI. </p><br><blockquote>  Saya tidak akan berbicara banyak tentang Mockito, Anda dapat membaca semuanya di dokumentasi resmi.  Secara khusus, hanya ada poin menarik dalam tes ini - saya menggunakan <code>MockitoExtension.class</code> sebagai <code>MockitoExtension.class</code> uji, dan itu akan secara otomatis menghasilkan mokas untuk bidang yang dijelaskan oleh <code>@Mock</code> dan kemudian menyuntikkan mokas ini sebagai dependensi dalam konstruktor untuk objek di bidang yang ditandai <code>@InjectMocks</code> .  Anda dapat melakukan semua ini secara manual menggunakan metode <code>Mockito.mock()</code> dan kemudian membuat kelas. </blockquote><p>  Dan tes ini membantu menentukan metode komponen baru - <code>findPromotedCakes</code> , daftar kue yang ingin kami tampilkan di halaman utama.  Dia tidak menentukan apa itu, atau bagaimana seharusnya bekerja dengan database.  Tanggung jawab pengontrol adalah untuk mengambil apa yang ditransfer ke sana dan mengembalikan model ("kue") di bidang tertentu.  Namun demikian, <code>CakeFinder</code> sudah memiliki metode pertama di antarmuka saya, yang berarti Anda dapat menulis tes integrasi untuknya. </p><br><blockquote>  Saya sengaja membuat semua kelas di dalam <strong>paket</strong> <code>cakes</code> <strong>pribadi</strong> sehingga tidak ada orang di luar paket yang bisa menggunakannya.  Satu-satunya cara untuk mendapatkan data dari database adalah dengan antarmuka CakeFinder, yang merupakan "komponen X" saya untuk mengakses database.  Ini menjadi "konektor" alami, yang dapat dengan mudah saya kunci jika saya perlu menguji sesuatu secara terpisah dan tidak menyentuh alasnya.  Dan satu-satunya implementasinya adalah JpaCakeFinder.  Dan jika, misalnya, tipe basis data atau sumber data berubah di masa mendatang, maka Anda perlu menambahkan implementasi antarmuka <code>CakeFinder</code> tanpa mengubah kode yang menggunakannya. </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest">  Tes integrasi untuk JPA menggunakan @ DataJpaTest </h1><br><p>  Tes integrasi adalah roti dan mentega Spring.  Di dalamnya, pada kenyataannya, semuanya dilakukan dengan sangat baik untuk pengujian integrasi sehingga pengembang terkadang tidak ingin pergi ke tingkat unit atau mengabaikan tingkat UI.  Ini tidak buruk atau baik - saya ulangi bahwa tujuan utama dari tes ini adalah kepercayaan diri.  Dan satu set tes integrasi yang cepat dan efektif mungkin cukup untuk memberikan kepercayaan ini.  Namun, ada bahaya bahwa seiring waktu, tes ini akan menjadi lebih lambat atau lebih lambat, atau mulai menguji komponen secara terpisah, bukan integrasi. </p><br><p>  Tes integrasi dapat menjalankan aplikasi apa adanya ( <code>@SpringBootTest</code> ), atau komponennya yang terpisah (JPA, Web).  Dalam kasus saya, saya ingin menulis tes terfokus untuk JPA - jadi saya tidak perlu mengonfigurasi pengontrol atau komponen lainnya.  Anotasi <code>@DataJpaTest</code> bertanggung jawab atas hal ini di Uji Booting Musim Semi.  Ini adalah <em>meta</em> anotasi, mis.  Ini menggabungkan beberapa anotasi berbeda yang mengkonfigurasi berbagai aspek pengujian. </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @Transaksional </li></ul><br><p>  Pertama saya akan memberitahu Anda tentang masing-masing secara individual, dan kemudian saya akan menunjukkan kepada Anda tes selesai. </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br>  Itu memuat seluruh rangkaian konfigurasi dan mengatur repositori (pembuatan otomatis implementasi untuk <code>CrudRepositories</code> ), alat migrasi untuk database FlyWay dan Liquibase, menghubungkan ke database menggunakan DataSource, manajer transaksi, dan akhirnya Hibernate.  Pada kenyataannya, ini hanya satu set konfigurasi yang relevan untuk mengakses data - baik <code>DispatcherServlet</code> dari Web MVC, maupun komponen lainnya termasuk di sini. </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br>  Ini adalah salah satu aspek paling menarik dari tes JPA.  Konfigurasi ini <em>mencari classpath untuk salah satu database tertanam yang didukung dan mengkonfigurasi ulang konteksnya sehingga DataSource menunjuk ke database dalam-memori yang dibuat secara acak</em> .  Karena saya menambahkan ketergantungan pada basis H2, saya tidak perlu melakukan hal lain, hanya memiliki anotasi ini secara otomatis untuk setiap uji coba akan memberikan basis kosong, dan ini hanya sangat nyaman. </p><br><p>  Perlu diingat bahwa pangkalan ini akan benar-benar kosong, tanpa skema.  Untuk menghasilkan rangkaian, ada beberapa opsi. </p><br><ol><li>  Gunakan fitur <strong>Auto DDL</strong> dari Hibernate.  Spring Boot Test akan secara otomatis mengatur nilai ini menjadi <code>create-drop</code> sehingga Hibernate akan menghasilkan skema dari deskripsi entitas dan menghapusnya di akhir sesi.  Ini adalah fitur Hibernate yang sangat kuat, yang sangat berguna untuk pengujian. </li><li>  Gunakan migrasi yang dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flyway</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liquibase</a> . </li></ol><br><p>  Anda dapat membaca lebih lanjut tentang berbagai pendekatan untuk menginisialisasi database dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><p>  <strong>@AutoConfigureCache</strong> <br>  Itu hanya mengkonfigurasi cache untuk menggunakan NoOpCacheManager - yaitu  jangan tembolok apa pun.  Ini berguna untuk menghindari kejutan dalam tes. </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br>  Menambahkan objek <code>TestEntityManager</code> khusus ke <code>TestEntityManager</code> , yang dengan sendirinya merupakan binatang yang menarik.  <code>EntityManager</code> adalah kelas utama JPA, yang bertanggung jawab untuk menambahkan entitas ke sesi, menghapus, dan hal-hal serupa.  Hanya ketika, misalnya, Hibernate mulai beroperasi - menambahkan entitas ke sesi tidak berarti bahwa permintaan ke database akan dieksekusi, dan memuat dari sesi tidak berarti bahwa permintaan pilih akan dieksekusi.  Karena mekanisme internal Hibernate, operasi nyata dengan database akan dilakukan pada waktu yang tepat, yang akan ditentukan oleh kerangka itu sendiri.  Tetapi dalam pengujian, mungkin perlu untuk mengirim sesuatu ke database dengan paksa, karena tujuan dari tes ini adalah untuk menguji integrasi.  Dan <code>TestEntityManager</code> hanyalah pembantu yang akan membantu beberapa operasi dengan database dilakukan secara paksa - misalnya, <code>persistAndFlush()</code> akan memaksa Hibernate untuk menjalankan semua permintaan. </p><br><p>  <strong>@Transaksional</strong> <br>  Anotasi ini membuat semua tes dalam transaksional kelas, dengan rollback otomatis dari transaksi setelah menyelesaikan tes.  Ini hanya mekanisme untuk "membersihkan" database sebelum setiap tes, karena jika tidak, Anda harus menghapus data secara manual dari setiap tabel. </p><br><blockquote>  Apakah tes harus mengelola transaksi bukanlah pertanyaan yang sederhana dan jelas seperti kelihatannya.  Terlepas dari kenyamanan basis data "bersih", kehadiran <code>@Transactional</code> dalam pengujian dapat menjadi kejutan yang tidak menyenangkan jika kode "pertempuran" tidak memulai transaksi itu sendiri, tetapi membutuhkan yang sudah ada.  Ini dapat mengarah pada fakta bahwa tes integrasi lulus, tetapi ketika kode nyata dieksekusi dari controller, dan bukan dari tes, layanan tidak akan memiliki transaksi aktif dan metode akan mengeluarkan pengecualian.  Meskipun ini terlihat berbahaya, dengan tes tingkat tinggi tes UI, tes transaksional tidak begitu buruk.  Dalam pengalaman saya, saya hanya melihat sekali, ketika tes integrasi yang lulus crash kode produksi, yang jelas membutuhkan keberadaan transaksi yang ada.  Tetapi jika Anda masih perlu memverifikasi bahwa layanan dan komponen itu sendiri mengelola transaksi dengan benar, Anda dapat "memblokir" anotasi <code>@Transactional</code> pada pengujian dengan mode yang diinginkan (misalnya, jangan memulai transaksi). </blockquote><br><h1 id="integracionnyy-test-so-springboottest">  Uji Integrasi dengan @SpringBootTest </h1><br><p>  Saya juga ingin mencatat bahwa <code>@DataJpaTest</code> bukan contoh unik dari tes integrasi fokal, ada <code>@WebMvcTest</code> , <code>@DataMongoTest</code> dan banyak lainnya.  Tetapi salah satu anotasi pengujian paling penting tetap <code>@SpringBootTest</code> , yang meluncurkan aplikasi <em>"sebagaimana adanya"</em> untuk pengujian - dengan semua komponen dan integrasi yang dikonfigurasi.  Sebuah pertanyaan logis muncul - jika Anda dapat menjalankan seluruh aplikasi, mengapa melakukan tes DataJpa fokus, misalnya?  Saya akan mengatakan bahwa tidak ada aturan ketat di sini lagi. </p><br><p>  Jika <em>memungkinkan</em> untuk menjalankan aplikasi setiap saat, mengisolasi crash dalam pengujian, jangan overload dan jangan mempersulit pengaturan Setup tes, maka tentu saja Anda dapat dan harus menggunakan @SpringBootTest. </p><br><p>  Namun, dalam kehidupan nyata, aplikasi dapat memerlukan banyak pengaturan yang berbeda, terhubung ke sistem yang berbeda, dan saya tidak ingin tes akses database saya jatuh, karena  koneksi ke antrian pesan tidak dikonfigurasi.  Oleh karena itu, penting untuk menggunakan akal sehat, dan jika untuk mendapatkan tes dengan penjelasan @SpringBootTest agar berfungsi, Anda perlu mengunci setengah sistem - apakah masuk akal sama sekali di @SpringBootTest? </p><br><h1 id="podgotovka-dannyh-dlya-testa">  Persiapan data untuk tes </h1><br><p>  Salah satu poin utama untuk pengujian adalah persiapan data.  Setiap tes harus dilakukan dalam isolasi, dan mempersiapkan lingkungan sebelum memulai, membawa sistem ke keadaan semula yang diinginkan.  Opsi termudah untuk melakukan ini adalah dengan menggunakan <code>@BeforeEach</code> / <code>@BeforeAll</code> anotasi dan menambahkan entri ke database di sana menggunakan repositori, <code>EntityManager</code> atau <code>TestEntityManager</code> .  Tetapi ada opsi lain yang memungkinkan Anda untuk menjalankan skrip yang sudah disiapkan atau menjalankan query SQL yang diinginkan, ini adalah penjelasan <code>@Sql</code> .  Sebelum menjalankan tes, Uji Booting Musim Semi akan secara otomatis menjalankan skrip yang ditentukan, menghilangkan keharusan untuk menambahkan blok <code>@BeforeAll</code> , dan <code>@Transactional</code> akan menangani <code>@Transactional</code> data. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl">  Siklus refactor merah-hijau </h1><br><p>  Terlepas dari jumlah teks ini, untuk pengembang, tes masih terlihat seperti kelas sederhana dengan anotasi @DataJpaTest, tapi saya harap saya dapat menunjukkan seberapa banyak hal berguna yang terjadi di bawah tenda, yang tidak dapat dipikirkan oleh pengembang.  Sekarang kita dapat beralih ke siklus TDD dan kali ini saya akan menunjukkan beberapa iterasi TDD, dengan contoh-contoh refactoring dan kode minimal.  Untuk membuatnya lebih jelas, saya sangat menyarankan agar Anda melihat sejarah di Git, di mana setiap komit adalah langkah yang terpisah dan signifikan dengan deskripsi tentang apa dan bagaimana fungsinya. </p><br><h2 id="podgotovka-dannyh">  Persiapan data </h2><br><p>  Saya menggunakan pendekatan dengan <code>@BeforeAll</code> / <code>@BeforeEach</code> dan secara manual membuat semua catatan dalam database.  Contoh dengan penjelasan <code>@Sql</code> dipindahkan ke kelas yang terpisah <code>JpaCakeFinderTestWithScriptSetup</code> , itu menggandakan tes, yang, tentu saja, tidak boleh, dan ada untuk tujuan tunggal menunjukkan pendekatan. </p><br><p>  Keadaan awal sistem - ada dua entri dalam sistem, satu kue berpartisipasi dalam promosi dan harus dimasukkan dalam hasil yang dikembalikan oleh metode, yang kedua - tidak. </p><br><h2 id="pervyy-test-integracionnyy-test">  Tes integrasi pertama </h2><br><p>  Tes pertama adalah yang paling sederhana - <code>findPromotedCakes</code> harus menyertakan deskripsi dan harga kue yang berpartisipasi dalam promosi. </p><br><h3 id="red">  Merah </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"Â£10.00"</span></span>); }</code> </pre> <br><p>  Tes, tentu saja, lumpuh - implementasi standar mengembalikan Set kosong. </p><br><h3 id="green">  Hijau </h3><br><p>  Secara alami, kami ingin segera menulis pemfilteran, membuat permintaan ke database dengan <code>where</code> dan seterusnya.  Tetapi setelah latihan TDD, saya harus menulis <em>kode minimum agar lulus</em> .  Dan kode minimal ini adalah untuk mengembalikan semua catatan dalam database.  Ya, sangat sederhana dan klise. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Â£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote>  Mungkin beberapa orang akan berpendapat bahwa di sini Anda dapat membuat tes hijau bahkan tanpa basis - hanya hardcode hasil yang diharapkan oleh tes.  Saya sesekali mendengar argumen seperti itu, tetapi saya pikir semua orang mengerti bahwa TDD bukan dogma atau agama, tidak masuk akal untuk membawa ini ke titik absurditas.  Tetapi jika Anda benar-benar ingin, maka Anda dapat, misalnya, mengacak data pada instalasi sehingga tidak hardcode. </blockquote><br><h3 id="refactor">  Refactor </h3><br><p>  Saya tidak melihat banyak refactoring di sini, sehingga fase ini dapat dilewati untuk tes khusus ini.  Tetapi saya masih tidak akan merekomendasikan mengabaikan fase ini, lebih baik untuk berhenti dan berpikir setiap kali dalam keadaan "hijau" dari sistem - apakah mungkin untuk refactor sesuatu untuk membuatnya lebih baik dan lebih mudah? </p><br><h2 id="vtoroy-test">  Tes kedua </h2><br><p>  Tetapi pengujian kedua sudah akan memverifikasi bahwa tidak ada kue yang dipromosikan akan jatuh ke dalam hasil yang dikembalikan oleh <code>findPromotedCakes</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1">  Merah </h3><br><p>  Tes, seperti yang diharapkan, crash - ada dua catatan dalam database dan kode hanya mengembalikan semuanya. </p><br><h3 id="green-1">  Hijau </h3><br><p>  Dan lagi Anda dapat berpikir - dan apa kode minimum yang dapat Anda tulis untuk lulus ujian?  Karena sudah ada aliran dan rakitannya, Anda cukup menambahkan blok <code>filter</code> sana. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Kami memulai kembali tes - tes integrasi sekarang berwarna hijau.  Momen penting telah datang - karena kombinasi uji unit controller dan uji integrasi untuk bekerja dengan database, fitur saya sudah siap - dan tes UI sekarang berlalu! </p><br><h3 id="refactor-1">  Refactor </h3><br><p>  Dan karena semua tes berwarna hijau - saatnya untuk refactor.  Saya pikir tidak perlu mengklarifikasi bahwa pemfilteran dalam memori bukan ide yang baik, lebih baik melakukan ini dalam database.  Untuk melakukan ini, saya menambahkan metode baru di <code>CakesRepository</code> - <code>findByPromotedIsTrue</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Untuk metode ini, Spring Data secara otomatis menghasilkan metode yang akan mengeksekusi kueri pemilihan formulir <code>select from cakes where promoted = true</code> .  Baca selengkapnya tentang pembuatan kueri dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Data Musim Semi. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Ini adalah contoh yang baik tentang fleksibilitas yang diberikan pengujian integrasi dan pendekatan kotak hitam.  Jika repositori dikunci, maka menambahkan metode baru tanpa mengubah tes bukan tidak mungkin. </p><br><h1 id="podklyuchenie-k-production-baze">  Koneksi ke basis produksi </h1><br><p>  Untuk menambahkan sedikit "realisme" dan menunjukkan bagaimana Anda dapat memisahkan konfigurasi untuk pengujian dan aplikasi utama, saya akan menambahkan konfigurasi akses data untuk aplikasi "produksi". </p><br><p>  Semuanya ditambahkan secara tradisional oleh bagian di <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p>  Ini secara otomatis akan menyimpan data dalam sistem file ke folder <code>./data</code> .  Saya perhatikan bahwa folder ini tidak akan dibuat dalam pengujian - <code>@DataJpaTest</code> akan secara otomatis mengganti koneksi ke file database dengan database acak dalam memori karena adanya penjelasan <code>@AutoConfigureTestDatabase</code> . </p><br><blockquote>   ,    â€”   <code>data.sql</code>  <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security â€”                Spring,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433958/">https://habr.com/ru/post/id433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433946/index.html">Cheat sheet untuk kecerdasan buatan - buang kelebihannya, ajarkan hal utama. Pelatihan teknik pemrosesan urutan</a></li>
<li><a href="../id433948/index.html">Cara membuat pembayaran lebih nyaman: pengalaman penyedia IaaS</a></li>
<li><a href="../id433952/index.html">10 alasan untuk memilih solusi untuk SAP HANA dari HPE. Bagian 2</a></li>
<li><a href="../id433954/index.html">Delapan teknologi audio dan gadget audio yang akan memasuki TECnology Hall of Fame pada tahun 2019</a></li>
<li><a href="../id433956/index.html">Modder telah menggunakan AI untuk meningkatkan tekstur dalam game</a></li>
<li><a href="../id433964/index.html">Modul ECMAScript di Node.js: Paket Baru</a></li>
<li><a href="../id433966/index.html">Kartu Natal dari Mars. ESA menunjukkan akumulasi besar es di permukaan planet merah</a></li>
<li><a href="../id433968/index.html">Game komunikasi yang paling buruk</a></li>
<li><a href="../id433972/index.html">HolyJS 2018 Moskow melalui mata peserta</a></li>
<li><a href="../id433974/index.html">Chatbot Mendapat Pendengaran, atau Penderitaan Amatir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>