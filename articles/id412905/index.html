<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏾 ⛺️ ♏️ Tentang LL Parsing: Suatu Pendekatan untuk Parsing Melalui Konsep Pemotongan Tali 📓 👋🏻 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salam untuk komunitas terhormat! 

 Pengulangan adalah ibu dari pembelajaran, dan memahami parsing adalah keterampilan yang sangat berguna bagi progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang LL Parsing: Suatu Pendekatan untuk Parsing Melalui Konsep Pemotongan Tali</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Salam untuk komunitas terhormat! <br><br>  Pengulangan adalah ibu dari pembelajaran, dan memahami parsing adalah keterampilan yang sangat berguna bagi programmer mana pun, jadi saya ingin mengangkat topik ini lagi dan berbicara kali ini tentang analisis recursive descent (LL) tanpa melakukan terlalu banyak formalisme (Anda selalu dapat menggunakannya nanti) kembali). <br><br>  Seperti yang ditulis oleh D. Strogov, "memahami berarti menyederhanakan."  Oleh karena itu, untuk memahami konsep parsing menggunakan metode turunan rekursif (alias LL-parsing), kami menyederhanakan tugas sebanyak mungkin dan secara manual menulis parser dari format yang mirip dengan JSON, tetapi lebih sederhana (jika Anda mau, Anda kemudian dapat memperluasnya ke parser JSON lengkap jika ingin berolahraga).  Mari kita menulisnya, mengambil sebagai dasar gagasan <b>memotong tali</b> . <br><a name="habracut"></a><br>  Dalam buku-buku klasik dan kursus desain kompiler, mereka biasanya mulai menjelaskan topik parsing dan interpretasi, menyoroti beberapa fase: <br><br><ul><li>  Analisis leksikal: membelah teks sumber menjadi array substring (token, atau token) </li><li>  Parsing: membangun pohon parsing dari berbagai token </li><li>  Interpretasi (atau kompilasi): melintasi pohon yang dihasilkan dalam urutan yang diinginkan (langsung atau terbalik) dan melakukan beberapa interpretasi atau tindakan pembuatan kode pada beberapa langkah traversal ini </li></ul><br><div class="spoiler">  <b class="spoiler_title">tidak juga</b> <div class="spoiler_text">  karena dalam proses penguraian kita sudah mendapatkan urutan langkah-langkah, yang merupakan urutan kunjungan ke simpul pohon, pohon itu sendiri dalam bentuk eksplisit mungkin tidak ada sama sekali, tetapi kita belum akan pergi jauh.  Bagi yang ingin masuk lebih dalam, ada tautan di bagian akhir. <br></div></div><br>  Sekarang saya ingin menggunakan pendekatan yang sedikit berbeda dengan konsep yang sama ini (penguraian LL) dan menunjukkan bagaimana Anda dapat membangun penganalisis LL berdasarkan ide memotong string: fragmen dipotong dari string asli selama penguraian, itu menjadi lebih kecil, dan kemudian diurai mengekspos sisa garis.  Sebagai hasilnya, kita sampai pada konsep yang sama tentang turunan rekursif, tetapi dengan cara yang sedikit berbeda dari yang biasanya dilakukan.  Mungkin jalan ini akan lebih nyaman untuk memahami esensi gagasan.  Dan jika tidak, maka masih ada kesempatan untuk melihat keturunan rekursif dari sudut yang berbeda. <br><br>  Mari kita mulai dengan tugas yang lebih sederhana: ada garis dengan pembatas, dan saya ingin menulis iterasi atas nilainya.  Sesuatu seperti: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Bagaimana ini bisa dilakukan?  Cara standar adalah untuk mengubah string yang dibatasi ke array atau daftar menggunakan String.split (di Jawa), atau names.split (",") (dalam javascript), dan iterate melalui array yang sudah ada.  Tetapi mari kita bayangkan bahwa kita tidak ingin atau tidak dapat menggunakan konversi ke sebuah array (misalnya, yah, tiba-tiba jika kita memprogram dalam bahasa pemrograman AVAJ ++, di mana tidak ada struktur data "array").  Anda masih dapat memindai string dan melacak pembatas, tetapi saya tidak akan menggunakan metode ini juga, karena itu membuat kode loop iterasi rumit dan, yang paling penting, itu bertentangan dengan konsep yang ingin saya tampilkan.  Oleh karena itu, kami akan berhubungan dengan string yang dibatasi dengan cara yang sama seperti yang berhubungan dengan daftar dalam pemrograman fungsional.  Dan di sana mereka selalu mendefinisikan fungsi head (mendapatkan elemen pertama dari daftar) dan tail (mendapatkan sisa daftar).  Mulai dari dialek pertama Lisp, di mana fungsi-fungsi ini disebut benar-benar mengerikan dan tidak intuitif: mobil dan cdr (mobil = isi register alamat, cdr = isi register penurunan. Legenda lama dalam, ya, eheheh.). <br><br>  Baris kami adalah garis yang dibatasi.  Sorot pembagi berwarna ungu: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Dan sorot daftar item dengan warna kuning: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Kami berasumsi bahwa baris kami bisa berubah (dapat diubah) dan menulis fungsi: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Tanda tangannya, misalnya, mungkin: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  Pada input fungsi, kami memberikan daftar (dalam bentuk string dengan pembatas) dan, pada kenyataannya, nilai pembatas.  Pada output, fungsi mengembalikan elemen pertama dari daftar (segmen garis ke pemisah pertama), sisa daftar dan tanda apakah elemen pertama dikembalikan.  Dalam hal ini, sisa daftar ditempatkan dalam variabel yang sama di mana daftar asli berada. <br><br>  Akibatnya, kami mendapat kesempatan untuk menulis seperti ini: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Output seperti yang diharapkan: <br><br>  ivanov <br>  petrov <br>  sidorov <br><br>  Kami melakukannya tanpa konversi ke ArrayList, tetapi merusak variabel nama, dan sekarang memiliki string kosong.  Ini belum terlihat sangat berguna, seolah-olah mereka mengubah penusuk untuk sabun.  Tapi mari kita melangkah lebih jauh.  Di sana kita akan melihat mengapa itu perlu dan ke mana itu akan menuntun kita. <br><br>  Sekarang mari kita parsing sesuatu yang lebih menarik: daftar pasangan kunci-nilai.  Ini juga merupakan tugas yang sangat umum. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Juga diharapkan.  Dan hal yang sama dapat dicapai dengan String.split, tanpa memotong garis. <br>  Tetapi katakanlah sekarang kita ingin menyulitkan format kita dan beralih dari nilai kunci datar ke format nestable yang mengingatkan kita pada JSON.  Sekarang kami ingin membaca sesuatu seperti ini: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Pemisah apa yang dipisah?  Jika itu koma, maka di salah satu token kami akan memiliki garis <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Jelas bukan yang kita butuhkan.  Karena itu, kita harus memperhatikan struktur garis yang ingin kita uraikan. <br><br>  Dimulai dengan penjepit keriting dan berakhir dengan penjepit keriting (dipasangkan dengan itu, yang penting).  Di dalam tanda kurung ini adalah daftar 'kunci' pasangan: 'nilai', setiap pasangan dipisahkan dari pasangan berikutnya dengan koma.  Kunci dan nilai dipisahkan oleh titik dua.  Kunci adalah serangkaian huruf yang dilampirkan dalam apostrof.  Nilai dapat berupa string karakter yang dilampirkan dalam apostrof, atau bisa juga struktur yang sama, dimulai dan diakhiri dengan kurung kurawal berpasangan.  Kami menyebut struktur seperti itu dengan kata "objek", seperti kebiasaan untuk menyebutnya dalam JSON. <br><br>  Kami hanya secara informal menggambarkan tata bahasa format JSON kami.  Biasanya, tata bahasa dijelaskan secara terbalik, dalam bentuk formal, dan notasi BNF atau variasinya digunakan untuk menulisnya.  Tapi sekarang saya bisa melakukannya tanpa itu, dan kita akan lihat bagaimana Anda dapat "memotong" baris ini sehingga dapat diurai sesuai dengan aturan tata bahasa ini. <br><br>  Sebenarnya, "objek" kita dimulai dengan penjepit keriting pembuka dan berakhir dengan sepasang yang menutupnya.  Apa yang bisa dilakukan fungsi parsing format seperti itu?  Kemungkinan besar, berikut ini: <br><br><ul><li>  pastikan string yang diteruskan dimulai dengan penjepit pembuka </li><li>  pastikan bahwa string yang diteruskan berakhir dengan sepasang kawat gigi penutup </li><li>  jika kedua kondisi benar, potong tanda kurung buka dan tutup, dan yang tersisa, berikan fungsi yang mem-parsing daftar pasangan 'kunci': 'nilai' </li></ul><br>  Harap dicatat: kata-kata "fungsi parsing format ini" dan "fungsi parsing daftar pasangan 'kunci': 'nilai'" muncul.  Kami memiliki dua fitur!  Ini adalah fungsi yang dalam deskripsi klasik dari algoritma turunan rekursif disebut "fungsi parsing simbol nonterminal", dan yang mengatakan bahwa "untuk setiap simbol nonterminal, fungsi parsing sendiri dibuat".  Yang sebenarnya, mem-parsingnya.  Kita bisa memberi nama mereka, katakanlah, parseJsonObject dan parseJsonPairList. <br><br>  Juga sekarang kita perlu memperhatikan bahwa kita sudah mendapat konsep "pasang braket" selain konsep "pemisah".  Jika untuk memotong garis ke pemisah berikutnya (titik dua antara kunci dan nilai, koma antara pasangan "kunci: nilai") fungsi cutNextToken sudah cukup bagi kita, sekarang kita dapat menggunakan tidak hanya string, tetapi juga objek, kita perlu berfungsi "potong ke pasangan kurung berikutnya".  Sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Fungsi ini memotong sebuah fragmen dari garis dari braket pembuka ke pasangan yang menutupnya, diberi tanda kurung, jika ada.  Tentu saja, Anda tidak dapat terbatas pada tanda kurung, tetapi menggunakan fungsi yang sama untuk memotong berbagai struktur blok yang dapat disarangkan: blok operator mulai..mengakhiri, jika..menerima, untuk..makhor dan yang sejenis. <br><br>  Mari kita menggambar secara grafis apa yang akan terjadi pada string.  Warna pirus - ini berarti kita memindai garis ke depan ke simbol yang disorot dalam pirus untuk menentukan apa yang harus kita lakukan selanjutnya.  Violet adalah "apa yang harus dipotong, ini adalah saat kita memotong fragmen yang disorot dalam warna violet dari garis, dan terus mengurai apa yang tersisa dari itu lebih jauh. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  Sebagai perbandingan, output dari program (teks program diberikan dalam lampiran) yang mem-parsing baris ini: <br><br>  Demonstrasi penguraian struktur seperti JSON <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  Kapan saja, kami tahu apa yang kami harapkan akan ditemukan di jalur input kami.  Jika kita memasuki fungsi parseJsonObject, maka kita berharap bahwa objek itu diberikan kepada kita di sana, dan kita dapat memeriksa ini dengan kehadiran tanda kurung buka dan tutup di awal dan di akhir.  Jika kita memasuki fungsi parseJsonPairList, maka kita mengharapkan daftar pasangan "key: value" di sana, dan setelah kita "menggigit" kunci (sebelum pemisah ":"), kami berharap bahwa hal berikutnya yang kami "gigit" adalah nilai.  Kita dapat melihat karakter pertama dari nilai, dan menarik kesimpulan tentang jenisnya (jika tanda kutip, maka nilainya dari jenis "string", jika braket keriting pembukaan adalah nilainya dari jenis "objek"). <br><br>  Dengan demikian, memotong fragmen dari string, kita dapat menguraikannya dengan metode analisis top-down (keturunan rekursif).  Dan ketika kita dapat menguraikan, kita dapat mem-parsing format yang kita butuhkan.  Atau buat format Anda sendiri yang nyaman bagi kami dan bongkar.  Atau muncul dengan Bahasa Spesifik Domain (DSL) untuk area spesifik kami dan rancang juru bahasa untuk itu.  Dan untuk mengkonstruksinya dengan benar, tanpa solusi tersiksa pada regexp atau mesin negara buatan sendiri yang muncul untuk programmer yang mencoba untuk memecahkan beberapa masalah yang membutuhkan penguraian, tetapi tidak cukup memiliki materi. <br><br>  Di sini  Selamat untuk semua pada musim panas mendatang dan berharap Anda baik, cinta dan parser fungsional :) <br><br>  Untuk bacaan lebih lanjut: <br><br>  Ideologis: beberapa artikel yang panjang tapi layak dibaca oleh Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Makanan programmer kaya</a> <br><br>  Beberapa kutipan dari sana: <br><blockquote>  Anda bisa belajar kompiler dan mulai menulis DSL Anda sendiri, atau membuat bahasa Anda lebih baik </blockquote><blockquote>  Fase besar pertama dari pipa kompilasi adalah parsing </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah pinocchiom</a> <br><br>  Kutipan dari sana: <br><blockquote>  Ketik gips, penyempitan dan pelebaran konversi, fungsi teman untuk mem-bypass perlindungan kelas standar, <b>memasukkan bahasa minilang ke dalam string dan menguraikannya dengan tangan</b> , ada lusinan cara untuk mem-bypass sistem tipe di Java dan C ++, dan programmer menggunakannya sepanjang waktu , karena (sedikit yang mereka tahu) mereka sebenarnya mencoba membangun perangkat lunak, bukan perangkat keras. </blockquote>  Teknis: dua artikel tentang parsing tentang perbedaan antara pendekatan LL dan LR: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LL dan LR Parsing Demystified</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LL dan LR dalam Konteks: Mengapa Parsing Tools Sulit</a> <br><br>  Dan bahkan lebih dalam ke topik: bagaimana menulis interpreter Lisp di C ++ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lisp interpreter dalam 90 baris C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Aplikasi.</b>  <b class="spoiler_title">Kode contoh (java) yang mengimplementasikan analisa yang dijelaskan dalam artikel:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412905/">https://habr.com/ru/post/id412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412895/index.html">Vesta Matveeva: perang melawan kejahatan dunia maya adalah pilihan moral</a></li>
<li><a href="../id412897/index.html">Memantau Produk Atlassian dengan Prometheus</a></li>
<li><a href="../id412899/index.html">Weekend Reading: 30 materi tentang suara, sejarah merek audio dan industri film</a></li>
<li><a href="../id412901/index.html">Monitoring dan Kubernetes (review dan laporan video)</a></li>
<li><a href="../id412903/index.html">Bagaimana kami melukis Habr</a></li>
<li><a href="../id412911/index.html">Pengembang berbicara tentang fitur yang terpotong dari game</a></li>
<li><a href="../id412913/index.html">"Baikal-T1" mulai dijual seharga 3990 rubel</a></li>
<li><a href="../id412915/index.html">Penentuan kerapatan gas dari hasil pengukuran tekanan dan suhu dengan sensor Arduino</a></li>
<li><a href="../id412917/index.html">Russian Post akan mulai menggunakan penyortir robot. Bagaimana cara kerjanya?</a></li>
<li><a href="../id412921/index.html">Tanda Tangan Jaringan Monero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>