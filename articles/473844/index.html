<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ç ‚ÜòÔ∏è üêë ¬øPor qu√© necesitamos rangos de C ++ 20 en una trituradora simple? üå•Ô∏è üõåüèª üçû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, los rangos que deber√≠an incluirse en el est√°ndar C ++ 20 se han discutido bastante, incluso en Habr√© ( un ejemplo donde hay muchos ejem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© necesitamos rangos de C ++ 20 en una trituradora simple?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473844/"><p>  Recientemente, <em>los</em> rangos que deber√≠an incluirse en el est√°ndar C ++ 20 se han discutido bastante, incluso en Habr√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo donde hay muchos ejemplos</a> ).  Hay suficientes cr√≠ticos de intervalos, dicen que </p><br><ul><li>  son demasiado abstractos y solo se necesitan para un c√≥digo muy abstracto </li><li>  la legibilidad del c√≥digo con ellos solo empeora </li><li>  intervalos ralentizan el c√≥digo </li></ul><br><p>  Vamos a ver por completo <del>  trabajador-campesino </del>  tarea pr√°ctica, para comprender si esta cr√≠tica es v√°lida <del>  y es cierto que Eric Nibler fue mordido por Bartosz Milewski y escribe range-v3 solo con la luna llena </del>  . </p><br><p><img src="https://habrastorage.org/webt/pb/dt/ih/pbdtihbl4gn8qiqwr5uk_j8qi0a.png" alt="kdpv"></p><br><p>  Integraremos la siguiente funci√≥n utilizando el m√©todo trapezoidal: <math> </math> $ en l√≠nea $ f (t) = 3 t ^ 2 \ sin t ^ 3 $ en l√≠nea $   que van desde cero a <math> </math> $ en l√≠nea $ \ tau $ en l√≠nea $   .  Si <math> </math> $ en l√≠nea $ \ tau ^ 3 / \ pi $ en l√≠nea $   es igual a un n√∫mero impar, entonces la integral es 2. </p><a name="habracut"></a><br><p> Entonces, el problema: escribimos un prototipo de una funci√≥n que calcula la integral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por el m√©todo trapezoidal</a> .  Parece, a primera vista, que no se necesitan abstracciones aqu√≠, pero la velocidad es importante.  De hecho, esto no es del todo cierto.  Para el trabajo, a menudo tengo que escribir "trituradoras de n√∫meros", cuyo usuario principal soy yo.  As√≠ que tambi√©n tengo que apoyar y lidiar con sus errores (desafortunadamente mis colegas, no siempre solo yo).  Y tambi√©n sucede que parte del c√≥digo no se usa, por ejemplo, un a√±o, y luego ... En general, tambi√©n es necesario escribir documentaci√≥n y pruebas. </p><br><p>  ¬øQu√© argumentos debe tener una funci√≥n integradora?  Funci√≥n y cuadr√≠cula integrables (conjunto de puntos <math> </math> $ en l√≠nea $ t_1, t_2, t_3 ... $ en l√≠nea $  usado para calcular la integral).  Y si todo est√° claro con la funci√≥n integrada ( <code>std::function</code> estar√° justo aqu√≠), entonces ¬øen qu√© forma se debe transmitir la grilla?  A ver </p><br><h2 id="varianty">  Opciones </h2><br><p>  Para empezar, para que haya algo con lo que comparar el rendimiento, escribiremos un bucle simple con un paso de tiempo constante: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step; // dt_fixed is the timestep; n_fixed is the number of steps double integrate() { double acc = 0; for(long long i = 1; i &lt; n_fixed - 1; ++i) { double t = dt_fixed * static_cast&lt;double&gt;(i); acc += dt_fixed * f(t); } acc += 0.5 * dt_fixed * f(0); acc += 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Al usar este ciclo, puede pasar como argumentos a la funci√≥n el principio y el final del intervalo de integraci√≥n, as√≠ como el n√∫mero de puntos para esta integraci√≥n en s√≠.  Detener: ¬°el m√©todo trapezoidal tambi√©n ocurre con un paso variable, y nuestra funci√≥n integrable simplemente pide usar un paso variable!  Que as√≠ sea, tengamos un par√°metro m√°s ( <math> </math> $ en l√≠nea $ b $ en l√≠nea $   ) para controlar la "no linealidad" y dejar que nuestros pasos sean, por ejemplo, los siguientes: <math> </math> $ en l√≠nea $ \ Delta t (t) = \ Delta t_0 + bt $ en l√≠nea $   .  Este enfoque (introducir un par√°metro num√©rico adicional) probablemente se usa en un mill√≥n de lugares, aunque, al parecer, su defecto deber√≠a ser obvio para todos.  ¬øY si tenemos una funci√≥n diferente?  ¬øY si necesitamos un peque√±o paso en alg√∫n lugar en el medio de nuestro intervalo num√©rico?  Pero, ¬øqu√© pasa si una funci√≥n integrable tiene un par de caracter√≠sticas?  En general, debemos poder transmitir <em>cualquier</em> grilla.  (Sin embargo, en los ejemplos, hasta el final, nos "olvidaremos" del m√©todo trapezoidal real y, por simplicidad, consideraremos su versi√≥n con un paso constante, teniendo en cuenta que la cuadr√≠cula puede ser arbitraria). </p><br><p>  Dado que la cuadr√≠cula puede ser cualquiera, pasemos sus valores <math> </math> $ en l√≠nea $ t_1, t_2, ... $ en l√≠nea $   envuelto en <code>std::vector</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step double integrate(vector&lt;double&gt; t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Hay m√°s que suficientes comunidades en este enfoque, pero ¬øqu√© pasa con el rendimiento?  Con consumo de memoria?  Si antes todo se resum√≠a en el procesador, ahora primero tenemos que completar el √°rea de memoria y luego leerlo.  Y la comunicaci√≥n con la memoria es algo bastante lento.  Y el recuerdo a√∫n no es de goma ( <del>  y silicona </del>  ) </p><br><p>  Veamos la ra√≠z del problema.  ¬øQu√© necesita una persona para ser feliz?  M√°s precisamente, ¬øqu√© necesita nuestro ciclo (basado en rango para bucle)?  Cualquier contenedor con iteradores <code>begin()</code> y <code>end()</code> , y <code>++</code> , <code>*</code> y <code>!=</code> Operadores para iteradores.  Entonces escribiremos. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ,      template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; } // ... //      class lazy_container { public: long long int n_nodes; lazy_container() { n_nodes = n_fixed; } ~lazy_container() {} class iterator { public: long long int i; // index of the current node iterator() { i = 0; } ~iterator() {} iterator&amp; operator++() { i+= 1; return *this; } // ! bool operator!=(const iterator&amp; rhs) const { return i != rhs.i; } double operator* () const { return dt_fixed * static_cast&lt;double&gt;(i); } }; iterator begin() { return iterator(); } iterator end() { iterator it; it.i = n_nodes; return it; } }; // ... //      lazy_container t_nodes; double res = integrate(t_nodes);</span></span></code> </pre> <br><p>  Estamos calculando un nuevo valor aqu√≠. <math> </math> $ en l√≠nea $ t_i $ en l√≠nea $   a pedido, tal como lo hicimos en un bucle simple.  No hay accesos a la memoria, y se espera que los compiladores modernos simplifiquen el c√≥digo de manera muy eficiente.  Al mismo tiempo, el c√≥digo de la funci√≥n integradora no ha cambiado mucho y a√∫n puede digerir <code>std::vector</code> . </p><br><p>  ¬øD√≥nde est√° la flexibilidad?  De hecho, ahora podemos escribir cualquier funci√≥n en el operador <code>++</code> .  Es decir, este enfoque permite, de hecho, transferir una funci√≥n en lugar de un √∫nico par√°metro num√©rico.  La cuadr√≠cula generada sobre la marcha puede ser cualquiera, y tambi√©n (probablemente) no perdemos rendimiento.  Sin embargo, escribir un nuevo <code>lazy_container</code> cada vez para distorsionar de alguna manera la cuadr√≠cula de una manera nueva no se siente en absoluto (¬°son las mismas 27 l√≠neas!).  Por supuesto, puede hacer que la funci√≥n responsable de generar la cuadr√≠cula sea un par√°metro de nuestra funci√≥n integradora, y <code>lazy_container</code> tambi√©n, es decir, disc√∫lpeme, encaps√∫lelo. </p><br><p>  Usted pregunta, ¬øentonces algo volver√° a estar mal?  Si!  En primer lugar, ser√° necesario transmitir por separado el n√∫mero de puntos para la integraci√≥n, lo que puede causar un error.  En segundo lugar, la bicicleta no est√°ndar creada tendr√° que ser apoyada y posiblemente desarrollada por alguien.  Por ejemplo, ¬øpuede imaginar de inmediato c√≥mo, con este enfoque, componer un combinador para funciones en el operador <code>++</code> ? </p><br><p>  C ++ por m√°s de 30 a√±os.  Muchos a esta edad ya tienen hijos, y C ++ ni siquiera tiene contenedores / iteradores perezosos est√°ndar.  Una pesadilla!  Pero todo (en el sentido de los iteradores, no los ni√±os) cambiar√° tan pronto como el pr√≥ximo a√±o: el est√°ndar (posiblemente parcialmente) incluir√° la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">range-v3</a> , que ha sido desarrollada por Eric Nibler durante varios a√±os.  Utilizaremos las obras de sus frutos.  El c√≥digo lo dice todo por s√≠ mismo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... auto t_nodes = ranges::v3::iota_view(0, n_fixed) | ranges::v3::views::transform( [](long long i){ return dt_fixed * static_cast&lt;double&gt;(i); } ); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  La funci√≥n integradora sigue siendo la misma.  Es decir, ¬°solo 3 l√≠neas para resolver nuestro problema!  Aqu√≠ <code>iota_view(0, n)</code> genera un <em>intervalo</em> <code>iota_view(0, n)</code> rango, un objeto que encapsula el inicio y el final generalizados; un intervalo diferido es una vista), que, al iterar en cada paso, calcula el siguiente n√∫mero en el intervalo [0, n).  Es curioso que el nombre Œπ (la letra griega iota) se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">refiera hace</a> 50 a√±os al lenguaje APL.  Palo <code>|</code>  le permite escribir tuber√≠as de modificadores de intervalo y <code>transform</code> , de hecho, es un modificador que, utilizando una funci√≥n lambda simple, convierte una secuencia de enteros en una serie <math> </math> $ en l√≠nea $ t_1, t_2, ... $ en l√≠nea $   .  Todo es simple, como en <del>  un cuento de hadas </del>  Haskell </p><br><p>  ¬øPero c√≥mo hacer un paso variable?  Todo es igual de simple: </p><br><div class="spoiler">  <b class="spoiler_title">Un poco de matem√°tica</b> <div class="spoiler_text"><p>  Como paso fijo, tomamos una d√©cima parte del per√≠odo de nuestra funci√≥n cerca del l√≠mite superior de integraci√≥n <math> </math> $ en l√≠nea $ \ Delta t_ {fijo} = 0.1 \ veces 2 \ pi / 3 \ tau ^ 2 $ en l√≠nea $   .  Ahora el paso ser√° variable: notar√°s que si tomas <math> </math> $ en l√≠nea $ t_i = \ tau (i / n) ^ {1/3} $ en l√≠nea $   , (donde <math> </math> $ en l√≠nea $ n $ en l√≠nea $   Es el n√∫mero total de puntos), entonces el paso ser√° <math> </math> $ en l√≠nea $ \ Delta t (t) \ aprox dt_i / di = \ tau ^ 3 / (3 nt ^ 2) $ en l√≠nea $   , que es una d√©cima parte del per√≠odo de una funci√≥n integrable para un determinado <math> </math> $ en l√≠nea $ t $ en l√≠nea $   si <math> </math> $ en l√≠nea $ n = \ tau ^ 3 / (0.1 \ por 2 \ pi) $ en l√≠nea $   .  Queda por "ce√±ir" esto a una partici√≥n razonable para valores peque√±os <math> </math> $ en l√≠nea $ i $ en l√≠nea $   . </p></div></div><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/drop.hpp&gt; #include &lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... // trapezoidal rule of integration; step size is not fixed template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; double t_prev = *(t_nodes.begin()); double f_prev = f(t_prev); for (auto t: t_nodes | ranges::v3::views::drop(1)) { double f_curr = f(t); acc += 0.5 * (t - t_prev) * (f_curr + f_prev); t_prev = t; f_prev = f_curr; } return acc; } //... auto step_f = [](long long i) { if (static_cast&lt;double&gt;(i) &lt;= 1 / a) { return pow(2 * M_PI, 1/3.0) * a * static_cast&lt;double&gt;(i); } else { return tau * pow(static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(n), 1/3.0); } }; auto t_nodes = ranges::v3::iota_view(0, n) | ranges::v3::views::transform(step_f); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Un lector atento not√≥ que en nuestro ejemplo, el paso variable nos permiti√≥ reducir el n√∫mero de puntos de la cuadr√≠cula en un factor de tres, mientras que adicionalmente, hay gastos notables para calcular <math> </math> $ en l√≠nea $ t_i $ en l√≠nea $   .  Pero si tomamos otro <math> </math> $ en l√≠nea $ f (t) $ en l√≠nea $   , el n√∫mero de puntos puede cambiar mucho m√°s ... (pero aqu√≠ el autor ya se est√° volviendo vago). </p><br><h2 id="itak-taymingi">  Entonces los tiempos </h2><br><p>  Tenemos las siguientes opciones: </p><br><ul><li>  v1 - bucle simple </li><li>  v2 - <math> </math> $ en l√≠nea $ t_i $ en l√≠nea $   mentir en <code>std::vector</code> </li><li>  v3 - improvisado <code>lazy_container</code> con iterador improvisado </li><li>  v4 - intervalos de C ++ 20 (rangos) </li><li>  v5: rangos de nuevo, pero solo aqu√≠ el m√©todo trapezoidal se escribe usando un tono variable </li></ul><br><p>  Esto es lo que resulta (en segundos) para <math> </math> $ inline $ \ tau = (10 \, 000 \, 001 \ times \ pi) ^ {1/3} $ inline $   , para g ++ 8.3.0 y clang ++ 8.0.0 en Intel¬Æ Xeon¬Æ CPU¬Æ X5550 (n√∫mero de pasos sobre <math> </math> $ en l√≠nea $ 1.5 \ veces 10 ^ 8 $ en l√≠nea $   , excepto para v5, donde los pasos son tres veces menos (el resultado de los c√°lculos de todos los m√©todos difiere de los dos en no m√°s de 0.07): </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  4.7 </td><td>  6.7 </td><td>  4.6 </td><td>  3.7 </td><td>  4.3 4.3 </td></tr><tr><td>  clang ++ </td><td>  5.0 </td><td>  7.2 </td><td>  4.6 </td><td>  4.8 </td><td>  4.1 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">Banderas ~~ de papel de colores ~~</b> <div class="spoiler_text"><p>  g ++ -O3 -ffast-math -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include <br>  clang ++ -Ofast -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include </p></div></div><br><p>  En general, la mosca cruz√≥ el campo, ¬°la mosca encontr√≥ una moneda! </p><br><div class="spoiler">  <b class="spoiler_title">g ++ en modo de depuraci√≥n</b> <div class="spoiler_text"><p>  Puede ser importante para alguien. </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  5.9 </td><td>  17,8 </td><td>  7.2 </td><td>  33,6 </td><td>  14,3 </td></tr></tbody></table></div></div></div><br><h2 id="itog">  Resumen </h2><br><p>  Incluso en una tarea muy simple, los rangos resultaron ser muy √∫tiles: en lugar de c√≥digo con iteradores hechos a s√≠ mismos en m√°s de 20 l√≠neas, escribimos 3 l√≠neas, sin tener problemas con la legibilidad del c√≥digo o su rendimiento. </p><br><p>  Por supuesto, si necesit√°ramos (para) el m√°ximo rendimiento en estas pruebas, tendr√≠amos que aprovechar al m√°ximo el procesador y la memoria escribiendo c√≥digo paralelo (o escribiendo una versi√≥n en OpenCL) ... Adem√°s, no tengo idea de lo que suceder√° si escribo cadenas muy largas de modificadores.  ¬øEs f√°cil depurar y leer los mensajes del compilador cuando se usan rangos en proyectos complejos?  Aumentar√° el tiempo de compilaci√≥n.  Espero que alguien escriba sobre este art√≠culo. </p><br><p>  Cuando escrib√≠ estas pruebas, yo mismo no sab√≠a qu√© pasar√≠a.  Ahora lo s√©: los rangos definitivamente merecen ser probados en un proyecto real, en las condiciones en las que tiene la intenci√≥n de usarlos. </p><br><p><del>  Fui al bazar a comprar un samovar. </del></p><br><h3 id="poleznye-ssylki">  Enlaces utiles </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rango-v3 inicio</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n y estudios de caso v3</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo de este art√≠culo en github</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">listas en Haskell, para comparar</a> </p><br><h3 id="blagodarnosti">  Agradecimientos </h3><br><p>  ¬°Gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Fadey</a> por ayudar a escribir todo esto! </p><br><h3 id="ps">  PS </h3><br><p>  Espero que alguien comente sobre tales rarezas: i) Si toma el intervalo de integraci√≥n 10 veces m√°s peque√±o, en mi Xeon el ejemplo v2 es 10% m√°s r√°pido que v1, y v4 es tres veces m√°s r√°pido que v1.  ii) El compilador Intel (icc 2019) a veces en estos ejemplos crea un c√≥digo que es dos veces m√°s r√°pido que el compilado g ++.  ¬øEs la vectorizaci√≥n la culpable?  ¬øSe puede obligar a g ++ a hacer lo mismo? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473844/">https://habr.com/ru/post/473844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473832/index.html">ShIoTiny: actualizaciones y notificaciones</a></li>
<li><a href="../473834/index.html">Monitoreo de Blackbox en redes Clos. Informe Yandex</a></li>
<li><a href="../473838/index.html">DJI Mavic Mini: el quadrocopter plegable m√°s ligero</a></li>
<li><a href="../473840/index.html">Transmita video desde un dispositivo Android a trav√©s de UDP a la aplicaci√≥n JAVA</a></li>
<li><a href="../473842/index.html">Resumen de noticias de octubre sobre aprendizaje autom√°tico e inteligencia artificial</a></li>
<li><a href="../473846/index.html">C√≥mo medir el rendimiento de las redes blockchain. M√©tricas clave</a></li>
<li><a href="../473848/index.html">c.tech en HighLoad ++ 2019</a></li>
<li><a href="../473852/index.html">Pros y contras de trabajar de noche</a></li>
<li><a href="../473854/index.html">¬øC√≥mo recordamos el √∫ltimo JokerConf?</a></li>
<li><a href="../473856/index.html">Peligrosa facilidad con la que puedes enga√±ar a la inteligencia artificial militar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>