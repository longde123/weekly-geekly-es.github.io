<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÄ üë∞ üèüÔ∏è In jeder unverst√§ndlichen Situation - schreiben Sie Skripte üëë ü§ì ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Skripte sind eine der h√§ufigsten Methoden, um eine Anwendung flexibler zu gestalten und unterwegs etwas zu reparieren. Nat√ºrlich hat dieser Ansatz auc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In jeder unverst√§ndlichen Situation - schreiben Sie Skripte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/431084/"><img src="https://habrastorage.org/webt/a5/ng/5b/a5ng5b6thpfbxpcasm51swkuzgk.jpeg" alt="Bild"><br><br>  Skripte sind eine der h√§ufigsten Methoden, um eine Anwendung flexibler zu gestalten und unterwegs etwas zu reparieren.  Nat√ºrlich hat dieser Ansatz auch Nachteile: Sie m√ºssen sich immer an das Gleichgewicht zwischen Flexibilit√§t und Verwaltbarkeit erinnern.  In diesem Artikel werden wir jedoch nicht ‚Äûallgemein‚Äú √ºber die Vor- und Nachteile der Verwendung von Skripten sprechen, sondern praktische M√∂glichkeiten zur Implementierung dieses Ansatzes in Betracht ziehen und eine Bibliothek einf√ºhren, die eine bequeme Infrastruktur zum Hinzuf√ºgen von Skripten zu Anwendungen bietet, die im Spring Framework geschrieben wurden. <br><a name="habracut"></a><br><h2>  Ein paar einleitende Worte </h2><br>  Wenn Sie die M√∂glichkeit hinzuf√ºgen m√∂chten, die Gesch√§ftslogik in einer Anwendung ohne Neukompilierung und anschlie√üende Bereitstellung zu √§ndern, sind Skripte eine der M√∂glichkeiten, die Ihnen in den Sinn kommen.  Oft erscheinen Skripte nicht, weil es beabsichtigt war, sondern weil es passiert ist.  In der Spezifikation gibt es beispielsweise einen Teil der Logik, der derzeit nicht vollst√§ndig klar ist. Um jedoch nicht einige Tage (und manchmal auch l√§nger) f√ºr die Analyse aufzuwenden, k√∂nnen Sie einen Erweiterungspunkt festlegen und ein Skript aufrufen - einen Stub.  Und dann wird dieses Skript nat√ºrlich neu geschrieben, wenn die Anforderungen klar werden. <br><br>  Die Methode ist nicht neu und ihre Vor- und Nachteile sind bekannt: Flexibilit√§t - Sie k√∂nnen die Logik einer laufenden Anwendung √§ndern und bei einer Neuinstallation Zeit sparen. Andererseits sind Skripte schwieriger zu testen, daher m√∂gliche Probleme mit Sicherheit, Leistung usw. <br><br>  Diese Techniken, die sp√§ter erl√§utert werden, k√∂nnen sowohl f√ºr Entwickler n√ºtzlich sein, die bereits Skripte in ihrer Anwendung verwenden, als auch f√ºr diejenigen, die nur dar√ºber nachdenken. <br><br><h2>  Nichts Pers√∂nliches, nur Skripte </h2><br>  Mit JSR-233 ist das Scripting in Java sehr einfach geworden.  Es gibt gen√ºgend Skript-Engines, die auf dieser API basieren (Nashorn, JRuby, Jython und einige mehr), sodass es kein Problem ist, Ihrem Code ein bisschen Skript-Magie hinzuzuf√ºgen: <br><br><pre><code class="java hljs">Map&lt;String, Object&gt; parameters = createParametersMap(); ScriptEngineManager manager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptEngineManager(); ScriptEngine scriptEngine = manager.getEngineByName(<span class="hljs-string"><span class="hljs-string">"groovy"</span></span>); Object result = scriptEngine.eval(script.getScriptAsString(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBindings(parameters));</code> </pre> <br>  Wenn ein solcher Code in der gesamten Anwendung verteilt ist, wird er offensichtlich zu etwas Unverst√§ndlichem.  Wenn Ihre Anwendung mehr als einen Skriptaufruf enth√§lt, m√ºssen Sie nat√ºrlich eine separate Klasse erstellen, um mit ihnen arbeiten zu k√∂nnen.  Manchmal k√∂nnen Sie sogar noch weiter gehen und spezielle Klassen erstellen, die <code>evaluateGroovy()</code> -Aufrufe in regul√§re typisierte Java-Methoden einschlie√üen.  Diese Methoden haben einen ziemlich einheitlichen Dienstprogrammcode, wie im Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"cust"</span></span>, customer); params.put(<span class="hljs-string"><span class="hljs-string">"amount"</span></span>, orderAmount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (BigDecimal)scripting.evalGroovy(getScriptSrc(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), params); }</code> </pre><br>  Dieser Ansatz erh√∂ht die Transparenz beim Aufrufen von Skripten aus Anwendungscode erheblich. Sie k√∂nnen sofort sehen, welche Parameter das Skript akzeptiert, welchen Typ sie haben und was zur√ºckgegeben wird.  Die Hauptsache ist, nicht zu vergessen, den Code-Schreibstandards ein Verbot hinzuzuf√ºgen, Skripte nicht mit typisierten Methoden aufzurufen! <br><br><h2>  Wir pumpen Skripte auf </h2><br>  Trotz der Tatsache, dass Skripte einfach sind, gibt es eine echte Chance, auf Leistungsprobleme zu sto√üen, wenn Sie viele davon haben und sie intensiv nutzen.  Wenn Sie beispielsweise eine Reihe umfangreicher Vorlagen zum Generieren von Berichten verwenden und diese gleichzeitig ausf√ºhren, wird dies fr√ºher oder sp√§ter zu einem der Engp√§sse bei der Anwendungsleistung. <br>  Daher stellen viele Frameworks verschiedene Add-Ons √ºber die Standard-API her, um die Arbeitsgeschwindigkeit, das Caching, die √úberwachung der Ausf√ºhrung, die Verwendung verschiedener Skriptsprachen in einer Anwendung usw. zu verbessern. <br><br>  Beispielsweise wurde in CUBA eine ziemlich ausgekl√ºgelte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skript-</a> Engine erstellt, die zus√§tzliche Funktionen unterst√ºtzt, wie z. <br><br><ol><li>  F√§higkeit, Skripte in Java und Groovy zu schreiben </li><li>  Klassencache, um Skripte nicht neu zu kompilieren </li><li>  JMX-Beh√§lter zur Steuerung des Motors </li></ol><br>  All dies verbessert nat√ºrlich die Leistung und Benutzerfreundlichkeit, aber die Low-Level-Engine bleibt weiterhin Low-Level, und Sie m√ºssen den Skripttext lesen, Parameter √ºbergeben und die API aufrufen, um das Skript auszuf√ºhren.  Sie m√ºssen also in jedem Projekt eine Art Wrapper erstellen, um die Entwicklung noch effizienter zu gestalten. <br><br>  Und es w√§re unfair, GraalVM nicht zu erw√§hnen - eine experimentelle Engine, die Programme in verschiedenen Sprachen (JVM und Nicht-JVM) ausf√ºhren kann und es Ihnen erm√∂glicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Module in diesen Sprachen</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java-Anwendungen</a> einzuf√ºgen.  Ich hoffe, dass Nashorn fr√ºher oder sp√§ter in die Geschichte eingehen wird und wir die M√∂glichkeit haben werden, Teile des Codes in verschiedenen Sprachen in einer Quelle zu schreiben.  Das ist aber nur ein Traum. <br><br><h2>  Spring Framework: Ein Angebot, das schwer abzulehnen ist? </h2><br>  Spring verf√ºgt √ºber eine integrierte Unterst√ºtzung f√ºr die Skriptausf√ºhrung, die auf der JDK-API aufbaut.  Im Paket <code>org.springframework.scripting.*</code> Finden Sie viele n√ºtzliche Klassen - alles, damit Sie die Low-Level-API bequem f√ºr die Skripterstellung in Ihrer Anwendung verwenden k√∂nnen. <br><br>  Dar√ºber hinaus gibt es ein h√∂heres Ma√ü an Unterst√ºtzung, das in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausf√ºhrlich beschrieben wird.  Kurz gesagt: Sie m√ºssen eine Klasse in einer Skriptsprache (z. B. Groovy) erstellen und √ºber eine XML-Beschreibung als Bean ver√∂ffentlichen: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messenger"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script-source</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"classpath:Messenger.groovy"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"I Can Do The Frug"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Sobald eine Bean ver√∂ffentlicht wurde, kann sie mithilfe von IoC zu ihren Klassen hinzugef√ºgt werden.  Spring bietet eine automatische Aktualisierung des Skripts, wenn Text in der Datei ge√§ndert wird. Sie k√∂nnen Aspekte an Methoden usw. h√§ngen. <br><br>  Es sieht gut aus, aber Sie m√ºssen "echte" Klassen erstellen, um sie zu ver√∂ffentlichen. Sie k√∂nnen keine regul√§re Funktion in ein Skript schreiben.  Au√üerdem k√∂nnen Skripte nur im Dateisystem gespeichert werden, um die Datenbank zu verwenden, die Sie in Spring erklimmen m√ºssen.  Ja, und viele halten die XML-Konfiguration f√ºr veraltet, insbesondere wenn die Anwendung bereits alle Anmerkungen enth√§lt.  Das ist nat√ºrlich Aroma, aber man muss oft damit rechnen. <br><br><h2>  Skripte: Schwierigkeiten und Ideen </h2><br>  Jede L√∂sung hat ihren eigenen Preis. Wenn wir √ºber Skripte in Java-Anwendungen sprechen, kann es bei der Einf√ºhrung dieser Technologie zu einigen Schwierigkeiten kommen: <br><br><ol><li>  Verwaltbarkeit.  Oft sind Skriptaufrufe √ºber die gesamte Anwendung verteilt, und bei √Ñnderungen im Code ist es ziemlich schwierig, die Aufrufe der erforderlichen Skripte zu verfolgen. </li><li>  F√§higkeit, Anrufpunkte zu finden.  Wenn in einem bestimmten Skript etwas schief geht, ist das Auffinden aller Dial <code>evaluateGroovy()</code> ein Problem, es sei denn, Sie wenden eine Suche nach Dateinamen oder Methodenaufrufen wie <code>evaluateGroovy()</code> </li><li>  Transparenz  Das Schreiben eines Skripts ist an sich keine leichte Aufgabe, und noch schwieriger ist es f√ºr diejenigen, die dieses Skript aufrufen.  Sie m√ºssen sich merken, wie die Eingabeparameter aufgerufen werden, welche Art von Daten sie haben und was das Ergebnis der Ausf√ºhrung ist.  Oder schauen Sie sich jedes Mal den Skript-Quellcode an. </li><li>  Testen und Aktualisieren - Es ist nicht immer m√∂glich, das Skript in der Umgebung des Anwendungscodes zu testen. Nach dem Hochladen auf den "Battle" -Server m√ºssen Sie in der Lage sein, alles schnell zur√ºckzusetzen, wenn etwas schief geht. </li></ol><br>  Es scheint, dass das Umschlie√üen von Skriptaufrufen in Java-Methoden zur L√∂sung der meisten der oben genannten Probleme beitr√§gt.  Es ist sehr gut, wenn solche Klassen im IoC-Container ver√∂ffentlicht werden k√∂nnen und Methoden mit normalen, aussagekr√§ftigen Namen in ihren Diensten aufrufen k√∂nnen, anstatt <code>eval(‚Äúdisc_10_cl.groovy‚Äù)</code> von einer Dienstprogrammklasse <code>eval(‚Äúdisc_10_cl.groovy‚Äù)</code> .  Ein weiteres Plus ist, dass der Code selbstdokumentierend wird und der Entwickler nicht dar√ºber nachdenken muss, welche Art von Algorithmus hinter dem Dateinamen verborgen ist. <br><br>  Wenn au√üerdem jedes Skript nur einer Methode zugeordnet ist, k√∂nnen Sie √ºber das Men√º ‚ÄûVerwendungen suchen‚Äú in der IDE schnell alle Dial Peers in der Anwendung finden und die Position des Skripts in den einzelnen Gesch√§ftslogikalgorithmen verstehen. <br><br>  Das Testen wird vereinfacht - es wird zu einem ‚Äûnormalen‚Äú Klassentest unter Verwendung vertrauter Frameworks, Mocks und mehr. <br><br>  All dies steht im Einklang mit der am Anfang des Artikels erw√§hnten Idee - ‚Äûspezielle‚Äú Klassen f√ºr Methoden, die von Skripten implementiert werden.  Aber was ist, wenn Sie noch einen Schritt machen und den gesamten Service-Code des gleichen Typs zum Aufrufen von Skript-Engines vor dem Entwickler verbergen, damit er nicht einmal dar√ºber nachdenkt (na ja, fast)? <br><br><h2>  Skript-Repositorys - Konzept </h2><br>  Die Idee ist recht einfach und sollte denen bekannt sein, die mindestens einmal mit Spring gearbeitet haben, insbesondere mit Spring JPA.  Sie m√ºssen lediglich eine Java-Schnittstelle erstellen und das Skript aufrufen, wenn Sie seine Methoden aufrufen.  In JPA wird √ºbrigens ein identischer Ansatz verwendet - der Aufruf von CrudRepository wird abgefangen, basierend auf dem Methodennamen und den Parametern wird eine Anforderung erstellt, die dann vom Datenbankmodul ausgef√ºhrt wird. <br><br>  Was wird zur Umsetzung des Konzepts ben√∂tigt? <br><br>  Zuerst eine Annotation auf Klassenebene, damit Sie die Schnittstelle - das Repository - finden und darauf basierend einen Bin erstellen k√∂nnen. <br><br>  Au√üerdem sind Anmerkungen zu den Methoden dieser Schnittstelle wahrscheinlich n√ºtzlich, um die zum Aufrufen der Methode erforderlichen Metadaten zu speichern.  Zum Beispiel - wo man den Skripttext erh√§lt und welche Engine verwendet werden soll. <br><br>  Eine n√ºtzliche Erg√§nzung ist die M√∂glichkeit, Methoden mit Implementierung in der Benutzeroberfl√§che zu verwenden (auch bekannt als Standard). Dieser Code funktioniert so lange, bis der Business Analyst eine vollst√§ndigere Version des Algorithmus anzeigt und der Entwickler ein Skript basierend auf erstellt <br>  diese Informationen.  Oder lassen Sie den Analysten das Skript schreiben und der Entwickler kopiert es dann einfach auf den Server.  Es gibt viele M√∂glichkeiten :-) <br><br>  Angenommen, Sie m√ºssen f√ºr einen Online-Shop einen Dienst einrichten, um Rabatte basierend auf dem Benutzerprofil zu berechnen.  Derzeit ist nicht klar, wie dies zu tun ist, aber der Gesch√§ftsanalyst schw√∂rt, dass alle registrierten Benutzer Anspruch auf einen Rabatt von 10% haben. Den Rest wird er innerhalb einer Woche vom Kunden erfahren.  Service ist gleich morgen n√∂tig - schlie√ülich Saison.  Wie k√∂nnte der Code f√ºr diesen Fall aussehen? <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  Und dann wird der Algorithmus selbst, der zum Beispiel in groovig geschrieben ist, rechtzeitig eintreffen, dort werden die Rabatte etwas anders sein: <br><br><pre> <code class="plaintext hljs">def age = 50 if ((Calendar.YEAR - customer.birthday.year) &gt;= age) { return orderAmount.multiply(0.75) } else { return orderAmount.multiply(0.9) }</code> </pre><br>  Der Zweck all dessen ist es, dem Entwickler die M√∂glichkeit zu geben, nur den Schnittstellencode und den <code>getEngine</code> zu schreiben und nicht mit all diesen Aufrufen von <code>getEngine</code> , <code>eval</code> und anderen <code>getEngine</code> .  Die Bibliothek f√ºr die Arbeit mit Skripten sollte die ganze Magie ausf√ºhren - den Aufruf der Schnittstellenmethode abfangen, den Skripttext abrufen, die Parameterwerte ersetzen, die gew√ºnschte Skript-Engine abrufen, das Skript ausf√ºhren (oder die Standardmethode aufrufen, wenn kein Skripttext vorhanden ist) und den Wert zur√ºckgeben.  Im Idealfall sollte das Programm zus√§tzlich zu dem bereits geschriebenen Code Folgendes haben: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerServiceBean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PricingRepository pricingRepository; <span class="hljs-comment"><span class="hljs-comment">//Other injected beans here @Override public BigDecimal applyCustomerDiscount(Customer cust, BigDecimal orderAmnt) { if (customer.isRegistered()) { return pricingRepository.applyCustomerDiscount(cust, orderAmnt); } else { return orderAmnt; } //Other service methods here }</span></span></code> </pre><br>  Die Herausforderung ist lesbar, verst√§ndlich und um sie zu meistern, braucht man keine besonderen F√§higkeiten. <br><br>  Dies waren die Ideen, auf deren Grundlage eine kleine Bibliothek f√ºr die Arbeit mit Skripten erstellt wurde.  Es ist f√ºr Spring-Anwendungen vorgesehen. Dieses Framework wurde zum Erstellen der Bibliothek verwendet.  Es bietet eine erweiterbare API zum Laden und Ausf√ºhren von Skripten aus verschiedenen Quellen, die die Routinearbeit mit Skript-Engines verbirgt. <br><br><h2>  Wie funktioniert es? </h2><br>  F√ºr alle mit <code>@ScriptRepository</code> gekennzeichneten <code>@ScriptRepository</code> werden Proxy-Objekte w√§hrend der Initialisierung des Spring-Kontexts mit der <code>newProxyInstance</code> Methode der <code>Proxy</code> Klasse erstellt.  Diese Proxys werden im Spring-Kontext als Singleton-Beans ver√∂ffentlicht, sodass Sie ein Klassenfeld mit einem Schnittstellentyp deklarieren und die Annotation <code>@Autowired</code> oder <code>@Inject</code> darauf setzen k√∂nnen.  Genau wie geplant. <br><br>  Das Scannen und Verarbeiten von <code>@EnableSriptRepositories</code> wird mithilfe der Annotation <code>@EnableSriptRepositories</code> aktiviert, genauso wie Spring JPA oder Repositorys f√ºr MongoDB aktiviert ( <code>@EnableJpaRepositories</code> bzw. <code>@EnableMongoRepositories</code> ).  Als Anmerkungsparameter m√ºssen Sie ein Array mit den Namen der zu scannenden Pakete angeben. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableScriptRepositories</span></span>(basePackages = {<span class="hljs-string"><span class="hljs-string">"com.example"</span></span>, <span class="hljs-string"><span class="hljs-string">"com.sample"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//More configuration here. }</span></span></code> </pre><br>  Methoden m√ºssen mit <code>@ScriptMethod</code> kommentiert <code>@ScriptMethod</code> (es gibt auch <code>@GroovyScript</code> und <code>@JavaScript</code> mit der entsprechenden Spezialisierung), um Metadaten zum Aufrufen des Skripts hinzuzuf√ºgen.  Nat√ºrlich werden Standardmethoden in Schnittstellen unterst√ºtzt. <br><br>  Die allgemeine Struktur der Bibliothek ist im Diagramm dargestellt.  Blau hervorgehobene Komponenten, die entwickelt werden m√ºssen, wei√ü - die sich bereits in der Bibliothek befinden.  Das Spring-Symbol markiert Komponenten, die im Spring-Kontext verf√ºgbar sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/h0/xc/rzh0xc48cr_kw1d97y2i3wrbdvu.png"></div><br>  Wenn die Schnittstellenmethode aufgerufen wird (tats√§chlich das Proxy-Objekt), wird der Aufruf-Handler gestartet, der im Anwendungskontext nach zwei Beans sucht: dem Provider, der nach dem Skripttext sucht, und dem Executor, der tats√§chlich den gefundenen Text ausf√ºhrt.  Anschlie√üend gibt der Handler das Ergebnis an die aufrufende Methode zur√ºck. <br><br>  Die Provider- und Executor- <code>@ScriptMethod</code> Namen werden in der Annotation <code>@ScriptMethod</code> angegeben, in der Sie auch die Ausf√ºhrungszeit der Methode begrenzen k√∂nnen.  Unten finden Sie einen Beispielcode f√ºr die Verwendung der Bibliothek: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> (providerBeanName = <span class="hljs-string"><span class="hljs-string">"resourceProvider"</span></span>, evaluatorBeanName = <span class="hljs-string"><span class="hljs-string">"groovyEvaluator"</span></span>, timeout = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @ScriptParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cust"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Customer customer, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScriptParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"amount"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> BigDecimal orderAmount) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  Sie k√∂nnen <code>@ScriptParam</code> Anmerkungen bemerken - sie werden ben√∂tigt, um die Parameternamen anzugeben, wenn sie an das Skript √ºbergeben werden, da der Java-Compiler die urspr√ºnglichen Namen aus den Quellen l√∂scht (es gibt M√∂glichkeiten, dies nicht zu tun, aber es ist besser, sich nicht darauf zu verlassen).  Sie k√∂nnen die Parameternamen weglassen, aber in diesem Fall m√ºssen Sie "arg0", "arg1" im Skript verwenden, was die Lesbarkeit nicht wesentlich verbessert. <br><br>  Standardm√§√üig verf√ºgt die Bibliothek √ºber Anbieter zum Lesen von .groovy- und .js-Dateien von der Festplatte und entsprechenden Executoren, die Wrapper √ºber die Standard-JSR-233-API sind.  Sie k√∂nnen Ihre eigenen Beans f√ºr verschiedene <code>ScriptProvider</code> und f√ºr verschiedene Engines <code>SpringEvaluator</code> . Dazu m√ºssen Sie die entsprechenden Schnittstellen implementieren: <code>ScriptProvider</code> und <code>SpringEvaluator</code> .  Die erste Schnittstelle verwendet <code>org.springframework.scripting.ScriptSource</code> und die zweite ist <code>org.springframework.scripting.ScriptEvaluator</code> .  Die Spring-API wurde verwendet, damit vorgefertigte Klassen verwendet werden k√∂nnen, wenn sie bereits in der Anwendung enthalten sind. <br>  Der Anbieter und der K√ºnstler werden nach Namen durchsucht, um eine gr√∂√üere Flexibilit√§t zu gew√§hrleisten. Sie k√∂nnen die Standard-Beans aus der Bibliothek in Ihrer Anwendung ersetzen, indem Sie Ihre Komponenten mit denselben Namen benennen. <br><br><h2>  Testen und Versionieren </h2><br>  Da sich Skripte h√§ufig und einfach √§ndern, m√ºssen Sie sicherstellen k√∂nnen, dass die √Ñnderungen nichts besch√§digen.  Die Bibliothek ist mit JUnit kompatibel. Das Repository kann einfach als regul√§re Klasse im Rahmen eines Einheits- oder Integrationstests getestet werden.  Scheinbibliotheken werden ebenfalls unterst√ºtzt. In Tests f√ºr die Bibliothek finden Sie ein Beispiel daf√ºr, wie Sie die Skript-Repository-Methode verspotten. <br><br>  Wenn eine Versionierung erforderlich ist, k√∂nnen Sie einen Anbieter erstellen, der beispielsweise verschiedene Versionen von Skripten aus dem Dateisystem, aus der Datenbank oder aus Git liest.  Bei Problemen auf dem Hauptserver ist es daher einfach, ein Rollback auf die vorherige Version des Skripts zu organisieren. <br><br><h2>  Insgesamt </h2><br>  Die vorgestellte Bibliothek hilft beim Organisieren von Skripten in der Spring-Anwendung: <br><br><ol><li>  Der Entwickler hat immer Informationen dar√ºber, welche Parameter die Skripte ben√∂tigen und was zur√ºckgegeben wird.  Und wenn die Schnittstellenmethoden sinnvoll benannt sind, was das Skript dann tut. </li><li>  Anbieter und Ausf√ºhrende helfen dabei, den Code f√ºr den Empfang von Skripten und die Interaktion mit der Skript-Engine an einem Ort zu halten, und diese Aufrufe werden nicht √ºber den gesamten Anwendungscode verteilt. </li><li>  Alle Skriptaufrufe k√∂nnen mithilfe von Verwendungen suchen leicht gefunden werden. </li></ol><br>  Spring Boot Autokonfiguration, Unit Testing, Mock werden unterst√ºtzt.  √úber die API k√∂nnen Sie Daten zu den Skriptmethoden und ihren Parametern abrufen.  Sie k√∂nnen das Ausf√ºhrungsergebnis auch mit einem speziellen ScriptResult-Objekt umschlie√üen, in dem ein Ergebnis oder eine Ausnahmeinstanz angezeigt wird, wenn Sie sich beim Aufrufen von Skripten nicht mit try ... catch besch√§ftigen m√∂chten.  Die XML-Konfiguration wird unterst√ºtzt, wenn sie aus dem einen oder anderen Grund erforderlich ist.  Und schlie√ülich k√∂nnen Sie bei Bedarf ein Zeitlimit f√ºr die Skriptmethode angeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Bibliotheksquellen sind hier.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431084/">https://habr.com/ru/post/de431084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431074/index.html">JavaScript-Handbuch Teil 8: √úbersicht √ºber die ES6-Funktionen</a></li>
<li><a href="../de431076/index.html">Die beliebtesten Node.js-Frameworks von 2018</a></li>
<li><a href="../de431078/index.html">JavaScript-Anleitung zur Fehlerbehandlung</a></li>
<li><a href="../de431080/index.html">So organisieren Sie Remote-B√ºros und verlieren kein Team im Weltraum</a></li>
<li><a href="../de431082/index.html">Kotlin: auf der Suche nach Marketingleiter</a></li>
<li><a href="../de431086/index.html">Alles, was Sie √ºber PVS-Studio wissen wollten und ohne zu z√∂gern zu fragen</a></li>
<li><a href="../de431088/index.html">Dateiverwaltung falsch gemacht - Teil 1: Urspr√ºnglich aus den 90ern</a></li>
<li><a href="../de431090/index.html">Ein VK-Bot, ein C # und eine Orange</a></li>
<li><a href="../de431092/index.html">ROS: Tiefenkarte auf dem Raspberry Pi "low blood"</a></li>
<li><a href="../de431094/index.html">Solitaire Sort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>