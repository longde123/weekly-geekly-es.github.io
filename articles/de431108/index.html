<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 🕐 👩🏾‍🎓 So verwandeln Sie Satellitenbilder in Karten. Computer Vision in Yandex 👲🏼 👨🏿‍💼 🍏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der Hauptdatenquellen für den Yandex.Maps-Dienst sind Satellitenbilder. Um die Arbeit mit der Karte zu vereinfachen, sind Objekte: Wälder, Teiche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verwandeln Sie Satellitenbilder in Karten. Computer Vision in Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  Eine der Hauptdatenquellen für den Yandex.Maps-Dienst sind Satellitenbilder.  Um die Arbeit mit der Karte zu vereinfachen, sind Objekte: Wälder, Teiche, Straßen, Häuser usw. auf den Fotos mit Polygonen gekennzeichnet. In der Regel sind Kartografen mit der Kennzeichnung beschäftigt.  Wir beschlossen, ihnen zu helfen und dem Computer beizubringen, Polygone von Häusern ohne die Beteiligung von Menschen hinzuzufügen. <br><br>  Für Operationen mit Bildern trifft der Bereich der IT, der als Computer Vision bezeichnet wird.  In den letzten Jahren wurden die meisten Aufgaben in diesem Bereich mithilfe neuronaler Netze sehr erfolgreich gelöst.  Heute werden wir den Lesern von Habr über unsere Erfahrungen mit der Verwendung neuronaler Netze beim Mapping berichten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  Zunächst werden wir ein neuronales Gitter trainieren, das sich mit der semantischen Segmentierung befasst, d. H. Bestimmt, ob jeder Punkt im Satellitenbild mit dem Haus zusammenhängt.  Warum ist semantische Segmentierung und nicht nur Objekterkennung?  Wenn das Erkennungsproblem gelöst ist, erhalten wir am Ausgang eine Reihe von Rechtecken, die außerdem spezifisch sind: Zwei Seiten sind vertikal, zwei sind horizontal.  Und Häuser werden normalerweise relativ zu den Bildachsen gedreht, und einige Gebäude haben auch eine komplexe Form. <br><br>  Die Aufgabe der semantischen Segmentierung wird nun von verschiedenen Netzwerken ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNet</a> usw.) gelöst.  Sie müssen nur auswählen, welches für uns am besten geeignet ist. <br><br>  Nachdem wir die Maske vom Satellitenbild erhalten haben, wählen wir ausreichend große Gruppen von Punkten aus, die zu den Häusern gehören, sammeln sie in verbundenen Bereichen und präsentieren die Grenzen der Bereiche in Vektorform in Form von Polygonen. <br><br>  Es ist klar, dass die Maske nicht absolut genau ist, was bedeutet, dass Häuser in der Nähe in einem verbundenen Bereich zusammenkleben können.  Um dieses Problem zu lösen, haben wir beschlossen, das Netzwerk weiter auszubilden.  Sie findet im Bild die Rippen (die Grenzen der Häuser) und trennt die zusammengeklebten Gebäude. <br><br>  Ein solches Schema zeichnete sich ab: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  Wir haben die Erkennungsnetzwerke nicht vollständig verworfen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mask R-CNN</a> ausprobiert.  Das Plus im Vergleich zur üblichen Segmentierung besteht darin, dass die Maske R-CNN Objekte erkennt und eine Maske generiert, sodass die gemeinsame Maske nicht in verbundene Bereiche unterteilt werden muss.  Nun, minus (wie ohne) in der festen Auflösung der Maske jedes Objekts, d. H. Für große Häuser mit einer komplexen Grenze, wird sich diese Grenze offensichtlich als vereinfacht herausstellen. <br><br><h2>  Die Werkzeuge </h2><br>  Dann musste man sich für die Werkzeuge entscheiden.  Hier war alles ziemlich offensichtlich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV</a> eignet sich am besten für Computer Vision-Aufgaben.  Die Auswahl an neuronalen Netzen ist etwas größer.  Wir haben uns für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tensorflow entschieden</a> .  Seine Vorteile: <br><br><ul><li>  ein ziemlich entwickelter Satz vorgefertigter „Würfel“, aus denen Sie Ihre Netzwerke zusammenstellen können; </li><li>  Python-API, praktisch zum schnellen Erstellen einer Netzwerkstruktur und zum Trainieren; </li><li>  Ein trainiertes Netzwerk kann in Ihrem Programm über eine C ++ - Schnittstelle verwendet werden (im Vergleich zum Python-Teil sehr schlecht, aber ausreichend, um vorgefertigte Netzwerke auszuführen). </li></ul><br>  Für Schulungen und andere schwere Computer wollten wir Nirvana verwenden - die wunderbare Yandex-Plattform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, über die wir bereits gesprochen haben</a> . <br><br><h2>  Datacet </h2><br>  Achtzig Prozent Erfolg bei der Arbeit mit einem neuronalen Netzwerk bestehen aus einem guten Datensatz.  Für den Anfang hätten wir also einen solchen Datensatz zusammenstellen sollen.  Yandex hat eine große Anzahl von Satellitenbildern mit bereits markierten Objekten.  Alles scheint einfach zu sein: Laden Sie diese Daten einfach hoch und sammeln Sie sie in einem Datensatz.  Es gibt jedoch eine Einschränkung. <br><br><h3>  Datensatz verfeinern </h3><br>  Wenn eine Person in einem Satellitenbild nach einem Haus sucht, sieht sie als erstes das Dach.  Die Höhe der Häuser variiert jedoch, der Satellit kann dasselbe Gelände aus verschiedenen Winkeln aufnehmen - und wenn wir ein dem Dach entsprechendes Polygon auf einer Vektorkarte platzieren, gibt es keine Garantie dafür, dass das Dach beim Aktualisieren des Bildes nicht verlässt.  Aber das Fundament wird in den Boden gegraben und bleibt aus jedem Winkel, den Sie abnehmen, die ganze Zeit an einem Ort.  Deshalb sind die Häuser auf dem Vektor Yandex.Map "auf den Fundamenten" markiert.  Dies ist richtig, aber für die Segmentierung von Bildern ist es besser, dem Netzwerk das Suchen nach Dächern beizubringen: Die Hoffnung, dass das Netzwerk darauf trainiert ist, die Fundamente zu erkennen, ist sehr gering.  Daher sollte im Datensatz alles auf den Dächern markiert sein.  Um einen guten Datensatz zu erstellen, müssen wir lernen, wie das Vektorlayout von Häusern von Fundamenten auf Dächer verschoben wird. <br><br>  <i>Wir haben versucht, uns nicht zu verschieben, aber die Qualität war nicht sehr gut, und das ist verständlich: Die Aufnahmewinkel des Satelliten sind unterschiedlich, die Höhen der Häuser sind unterschiedlich, daher wurde das Fundament auf den Fotos in verschiedene Richtungen und in unterschiedlichen Abständen vom Dach verschoben.</i>  <i>Das Netzwerk geht durch eine solche Vielfalt verloren und trainiert bestenfalls für etwas dazwischen, im schlimmsten Fall für etwas Unverständliches.</i>  <i>Darüber hinaus liefert das Netzwerk für die semantische Segmentierung ein Ergebnis, das einem akzeptablen ähnelt, aber bei der Suche nach Kanten sinkt die Qualität dramatisch.</i> <br><br><h4>  Raster-Ansatz </h4><br>  Seit wir auf dem Gebiet der Computer Vision tätig sind, haben wir als erstes einen Ansatz ausprobiert, der für diese Computer Vision relevant ist.  Zuerst wird die Vektorkarte gerastert (die Polygone der Häuser werden mit weißen Linien auf schwarzem Hintergrund gezeichnet), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Sobel-Filter</a> wählt die Kanten im Satellitenbild aus.  Und dann gibt es einen Versatz von zwei Bildern relativ zueinander, wodurch die Korrelation zwischen ihnen maximiert wird.  Die Kanten nach dem Sobel-Filter sind ziemlich verrauscht. Wenn dieser Ansatz auf ein Gebäude angewendet wird, wird daher nicht immer ein akzeptables Ergebnis erzielt.  Die Methode funktioniert jedoch gut in Gebieten mit Gebäuden gleicher Höhe: Wenn Sie sofort nach einem Versatz über einen großen Bereich des Bildes suchen, ist das Ergebnis stabiler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  "Geometrischer" Ansatz </h4><br>  Wenn das Gebiet nicht mit demselben Typ, sondern mit verschiedenen Häusern aufgebaut ist, funktioniert die vorherige Methode nicht.  Glücklicherweise kennen wir manchmal die Höhe von Gebäuden auf der Yandex-Vektorkarte und die Position des Satelliten während der Aufnahme.  Auf diese Weise können wir schulische Kenntnisse der Geometrie nutzen und berechnen, wo und in welcher Entfernung sich das Dach relativ zum Fundament bewegt.  Diese Methode hat den Datensatz in Gebieten mit Hochhäusern verbessert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  "Manueller" Ansatz </h4><br>  Der zeitaufwändigste Weg: Krempeln Sie die Ärmel hoch, decken Sie die Maus auf, starren Sie auf den Monitor und verschieben Sie das Vektorlayout der Häuser manuell von den Fundamenten auf die Dächer.  Die Technik führt zu einem Ergebnis, das von erstaunlicher Qualität ist, aber es wird nicht empfohlen, es in großen Mengen zu verwenden: Entwickler, die mit solchen Aufgaben beschäftigt sind, geraten schnell in Apathie und verlieren das Interesse am Leben. <br><br><h4>  Neuronales Netz </h4><br>  Am Ende haben wir genug Satellitenbilder, die auf den Dächern gut markiert sind.  Es bestand also die Möglichkeit, das neuronale Netzwerk zu trainieren (vorerst jedoch nicht zur Segmentierung, sondern zur Verbesserung des Layouts anderer Satellitenbilder).  Und wir haben es geschafft. <br><br>  Die Eingabedaten des Faltungsnetzwerks waren ein Satellitenbild und eine verschobene rasterisierte Markierung.  Am Ausgang erhielten wir einen zweidimensionalen Vektor: vertikale und horizontale Verschiebungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  Mit Hilfe eines neuronalen Netzwerks fanden wir die notwendige Verschiebung, die es uns ermöglichte, gute Ergebnisse bei Gebäuden zu erzielen, für die die Höhe nicht angegeben ist.  Infolgedessen haben wir die manuelle Markup-Korrektur erheblich reduziert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Unterschiedliche Gebiete - unterschiedliche Häuser </h3><br>  Es gibt viele interessante Gebiete und Staaten auf Yandex.Maps.  Aber auch in Russland sind die Häuser äußerst unterschiedlich, was sich auf das Aussehen in Satellitenbildern auswirkt.  Sie müssen also die Vielfalt im Datensatz widerspiegeln.  Und anfangs haben wir nicht wirklich verstanden, wie wir mit all dieser Pracht umgehen sollen.  Einen riesigen Datensatz sammeln und dann ein Netzwerk darauf trainieren?  Erstellen Sie Ihren eigenen Datensatz für jede (bedingte) Art der Entwicklung und trainieren Sie ein separates Netzwerk?  Ein bestimmtes Kernnetzwerk trainieren und es dann für eine bestimmte Art von Entwicklung trainieren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Empirisch fanden wir Folgendes: <br><br><ol><li>  Zweifellos ist es notwendig, den Datensatz für verschiedene Gebäudetypen zu erweitern, für die das Tool verwendet werden soll.  Ein auf einen Typ geschultes Netzwerk kann Gebäude eines anderen Typs unterscheiden, wenn auch sehr schlecht. </li><li>  Es ist besser, ein großes Netzwerk für den gesamten Datensatz zu trainieren.  Es verallgemeinert sich recht gut auf verschiedene Gebiete.  Wenn Sie für jede Art von Entwicklung separate Netzwerke trainieren, bleibt die Qualität entweder gleich oder verbessert sich kaum.  Es ist daher sinnlos, unterschiedliche Netzwerke für unterschiedliche Gebiete zu implementieren.  Darüber hinaus erfordert dies mehr Daten und einen zusätzlichen Klassifikator für die Art der Entwicklung. </li><li>  Wenn Sie beim Hinzufügen neuer Gebiete zu den Daten alte Netzwerke verwenden, lernen die Netzwerke viel schneller.  Die Umschulung alter Netzwerke in erweiterte Daten führt zu ungefähr dem gleichen Ergebnis wie das Training eines Netzwerks von Grund auf neu, erfordert jedoch viel weniger Zeit. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Lösungsoptionen </h2><br><h3>  Semantische Segmentierung </h3><br>  Die semantische Segmentierung ist eine ziemlich gut erforschte Aufgabe.  Nach dem Erscheinen des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fully Convolutional Networks</a> wird dieser meist mithilfe neuronaler Netze gelöst.  Es bleibt nur die Auswahl eines Netzwerks (wir haben <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SegNet</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNet in</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betracht</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezogen</a> ), die Überlegung, ob wir zusätzliche Tricks wie CRF am Ausgang benötigen, und die Bestimmung, wie und mit welcher Fehlerfunktion das Training trainiert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  Infolgedessen haben wir uns für eine U-Net-ähnliche Architektur mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verallgemeinerten Intersection Over Union-</a> Funktion als Fehlerfunktion entschieden.  Für das Training schneiden wir Satellitenbilder und ihre entsprechenden Markierungen (natürlich gerastert) in Quadrate und setzen sie zu Datensätzen zusammen.  Es stellte sich als ziemlich schön heraus und manchmal ganz gut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  In Gebieten mit einzelnen Gebäuden reichte die semantische Segmentierung aus, um zur nächsten Stufe überzugehen - der Vektorisierung.  Wo das Gebäude dicht ist, kleben Häuser manchmal in einem zusammenhängenden Bereich zusammen.  Es dauerte, um sie zu trennen. <br><br><h3>  Kantenerkennung </h3><br>  Um diese Aufgabe zu bewältigen, finden Sie die Kanten im Bild.  Um Kanten zu erkennen, haben wir uns auch entschlossen, das Netzwerk zu trainieren (Kanten-Suchalgorithmen, die keine neuronalen Netzwerke verwenden, gehören eindeutig der Vergangenheit an).  Schulung eines Netzwerks vom Typ HED, das unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ganzheitlich verschachtelte Kantenerkennung beschrieben wird</a> .  Im Originalartikel wurde das Netzwerk auf den BSDS-500-Datensatz trainiert, in dem alle Kanten auf den Bildern markiert sind.  Ein geschultes Netzwerk findet alle ausgeprägten Kanten: die Grenzen von Häusern, Straßen, Seen usw. Dies reicht bereits aus, um die nahe gelegenen Gebäude zu trennen.  Wir haben uns jedoch entschlossen, weiter zu gehen und denselben Datensatz für das Training wie für die semantische Segmentierung zu verwenden. Malen Sie jedoch beim Rastern nicht die gesamten Polygone von Gebäuden, sondern zeichnen Sie nur deren Grenzen. <br><br>  Das Ergebnis war so überwältigend schön, dass wir beschlossen, die Gebäude direkt an den vom Netzwerk empfangenen Kanten zu vektorisieren.  Und es ist ganz passiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Scheitelpunkterkennung </h3><br>  Da ein Netzwerk wie HED an Kanten ein hervorragendes Ergebnis liefert, haben wir beschlossen, es so zu trainieren, dass es Scheitelpunkte erkennt.  Tatsächlich haben wir ein Netzwerk mit allgemeinen Gewichten für Faltungsschichten.  Sie hatte zwei Ausgänge gleichzeitig: für Kanten und für Spitzen.  Infolgedessen haben wir eine andere Version der Gebäudevektorisierung erstellt, und in einigen Fällen wurden recht vernünftige Ergebnisse erzielt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  Maske r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mask R-CNN</a> ist eine relativ neue Erweiterung von Netzwerken wie Faster R-CNN.  Maske R-CNN sucht nach Objekten und wählt für jedes eine Maske aus.  Als Ergebnis erhalten wir für Häuser nicht nur Begrenzungsrechtecke, sondern auch eine raffinierte Struktur.  Dieser Ansatz ist im Vergleich zu einer einfachen Erkennung (wir wissen nicht, wie sich das Gebäude innerhalb des Rechtecks ​​befindet) und einer normalen Segmentierung (mehrere Häuser können zu einem zusammenkleben, und es ist nicht klar, wie sie getrennt werden sollen) günstig.  Mit Mask R-CNN müssen Sie nicht mehr über zusätzliche Tricks nachdenken: Es reicht aus, den Maskenrand für jedes Objekt zu vektorisieren und sofort das Ergebnis zu erhalten.  Es gibt auch ein Minus: Die Größe der Maske für das Objekt ist immer festgelegt, d. H. Bei großen Gebäuden ist die Genauigkeit des Pixellayouts gering.  Das Ergebnis von Mask R-CNN sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Wir haben zuletzt Mask R-CNN ausprobiert und sichergestellt, dass dieser Ansatz bei einigen Gebäudetypen andere übertrifft. <br><br><h2>  Vektorisierung </h2><br><h3>  Rechteckvektorisierung </h3><br>  Bei aller modernen architektonischen Vielfalt sehen Häuser auf Satellitenbildern immer noch meistens wie Rechtecke aus.  Darüber hinaus ist für die Masse der Gebiete eine Kennzeichnung mit komplexen Polygonen nicht erforderlich.  Trotzdem möchte ich, dass Häuser auf der Karte markiert werden.  (Nun, zum Beispiel eine Gartenbaupartnerschaft: Es gibt dort normalerweise viele Häuser, manuelles Markieren ist nicht so wichtig, aber das Markieren mit Rechtecken auf der Karte ist sehr gut.) Daher war der erste Ansatz zur Vektorisierung äußerst einfach. <br><br><ol><li>  Nehmen Sie die Rasterregion, die dem "Haus" entspricht. </li><li>  Suchen Sie das Rechteck des Mindestbereichs, der diesen Bereich enthält (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV :: minAreaRect</a> ).  Das Problem ist gelöst. </li></ol><br>  Es ist klar, dass die Qualität dieses Ansatzes alles andere als ideal ist.  Der Algorithmus ist jedoch recht einfach und funktioniert in vielen Fällen. <br><br><h3>  Polygonvektorisierung </h3><br>  Wenn die Qualität der Segmentierung gut genug ist, können Sie die Kontur des Hauses genauer nachbilden.  In den meisten Gebäuden mit komplexer Form sind die Winkel größtenteils richtig, daher haben wir beschlossen, das Problem auf die Aufgabe zu reduzieren, ein Polygon mit orthogonalen Seiten zu konstruieren.  Um dies zu lösen, möchten wir zwei Ziele gleichzeitig erreichen: das einfachste Polygon finden und die Form von Gebäuden so genau wie möglich wiederholen.  Diese Ziele stehen in Konflikt miteinander, daher müssen Sie zusätzliche Bedingungen einführen: um die minimale Länge der Wände, die maximale Abweichung von der Rasterregion usw. zu begrenzen. <br><br>  Der Algorithmus, der uns zuerst einfiel, basierte auf der Konstruktion der Projektion von Punkten auf geraden Linien: <br><br><ol><li>  Finden Sie den Umriss der Rasterregion, die einem Haus entspricht. </li><li>  Reduzieren Sie die Anzahl der Punkte in der Schaltung, indem Sie sie beispielsweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Douglas-Pecker-Algorithmus</a> vereinfachen. </li><li>  Finden Sie die längste Seite in der Gliederung.  Es ist sein Neigungswinkel, der den Winkel des gesamten zukünftigen orthogonalen Polygons bestimmt. </li><li>  Konstruieren Sie eine Projektion vom nächsten Konturpunkt zur vorherigen Seite. </li><li>  Seite zum Projektionspunkt ausfahren.  Wenn der Abstand vom Punkt zu seiner Projektion größer als die kürzeste Wand des Gebäudes ist, fügen Sie das resultierende Segment zur Kontur des Gebäudes hinzu. </li><li>  Wiederholen Sie die Schritte 4 und 5, bis der Stromkreis schließt. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Dieser Algorithmus ist extrem einfach und bringt schnell Ergebnisse, aber die Kontur des Gebäudes ist manchmal ziemlich verrauscht.  Bei dem Versuch, dieses Problem zu lösen, haben wir eine ziemlich interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lösung für das</a> Problem gefunden, bei der ein quadratisches Gitter im Raum verwendet wird, um das Polygon zu approximieren.  Kurz beschrieben besteht der Algorithmus aus drei Aktionen: <br><br><ol><li>  Erstellen Sie ein quadratisches Gitter im Raum, der auf Null zentriert ist. </li><li>  Konstruieren Sie an Gitterpunkten, die nicht weiter als einen bestimmten Abstand von der ursprünglichen Kontur entfernt sind, verschiedene Polygone. </li><li>  Wählen Sie ein Polygon mit einer Mindestanzahl von Scheitelpunkten aus. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Da der erforderliche Drehwinkel des Gitters nicht im Voraus bekannt ist, müssen mehrere Werte aussortiert werden, was sich negativ auf die Leistung auswirkt.  Mit dem Algorithmus können Sie jedoch visuell schönere Ergebnisse erzielen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Verbesserung der Vektorisierung </h2><br>  Während wir tatsächlich mit jedem Haus separat gearbeitet haben.  Wenn die erste Phase abgeschlossen ist, können Sie bereits mit dem gesamten Bild arbeiten und das Ergebnis verbessern.  Hierzu wurde ein Algorithmus zur Nachbearbeitung eines Satzes von Polygonen hinzugefügt.  Wir haben folgende Heuristiken verwendet: <br><br><ul><li>  Normalerweise sind die Wände benachbarter Häuser parallel.  Außerdem: Meistens können Häuser zu Sets zusammengefasst werden, in denen alle Elemente ausgerichtet sind. </li><li>  Wenn auf dem Bild bereits Straßen markiert sind, ist es sehr wahrscheinlich, dass die Seiten der Polygone parallel zu den Straßen verlaufen. </li><li>  Wenn sich die Polygone schneiden, ist es höchstwahrscheinlich sinnvoll, die Wände so zu verschieben, dass der Schnitt verschwindet. </li></ul><br>  Als Ergebnis erschien der folgende Algorithmus: <br><br><ol><li>  Wir gruppieren die Häuser, die sich aus dem Abstand zwischen ihnen und dem Drehwinkel ergeben.  Wir mitteln die Umdrehungen von Gebäuden in jedem Cluster.  Wir wiederholen, bis sich die Position der Gebäude nicht mehr ändert oder bis die Häuser zu stark von der ursprünglichen Position abweichen. </li><li>  Wir wählen Häuser in der Nähe der Straßen, wir finden die längsten und am nächsten an der Straßenseite.  Wir drehen das Haus bis zur Parallelität der ausgewählten Seite und der Straße. </li><li>  Wir entfernen die Schnittpunkte zwischen den Polygonen und verschieben die Seiten zweier sich kreuzender Gebäude proportional zur Größe der Seiten. </li></ol><br><h2>  Ergebnis </h2><br>  Als Ergebnis haben wir ein Tool erhalten, das Gebäude verschiedener Gebäudetypen erkennen kann.  Es hilft Kartographen bei ihrer harten Arbeit: Es beschleunigt die Suche nach vermissten Häusern erheblich und füllt neue, noch nicht bebaute Gebiete aus.  Derzeit wurden mit diesem Tool mehr als 800.000 neue Objekte zur Personenkarte hinzugefügt. <br><br>  Nachfolgend sehen Sie einige Beispiele für die Erkennung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431108/">https://habr.com/ru/post/de431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431096/index.html">So erstellen Sie ein Chat-Bot-Produkt</a></li>
<li><a href="../de431098/index.html">Selbst ein Feuer ist kein Hindernis oder eine Wiederherstellung der Zimbra-Geschwindigkeit nach einer Katastrophe</a></li>
<li><a href="../de431102/index.html">Wie die physikalische Adresse in DRAM-Strings und -Banken angezeigt wird</a></li>
<li><a href="../de431104/index.html">Wie wir bei Neoflex DevOps-Know-how entwickeln</a></li>
<li><a href="../de431106/index.html">Wie viel Geld haben die Amerikaner an diesem schwarzen Freitag ausgegeben und was haben Smartphones damit zu tun?</a></li>
<li><a href="../de431110/index.html">Hören Sie auf, Verlage zu füttern. Die EU entwickelt Regeln für den obligatorischen freien Zugang zu Forschung</a></li>
<li><a href="../de431112/index.html">Verwendung der Methode der kleinsten Quadrate zum Bewerten von Ressourcen und Überwachen von Oracle-Datenbanken</a></li>
<li><a href="../de431116/index.html">Willst du seltsam: Rückblick auf die bevorstehende DartUP-Konferenz in St. Petersburg</a></li>
<li><a href="../de431118/index.html">Die ganze Wahrheit über RTOS. Artikel 22. Postfächer: Nebendienstleistungen und Datenstrukturen</a></li>
<li><a href="../de431120/index.html">Leiden bei der Arbeit ist nicht notwendig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>