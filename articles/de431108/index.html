<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üïê üë©üèæ‚Äçüéì So verwandeln Sie Satellitenbilder in Karten. Computer Vision in Yandex üë≤üèº üë®üèø‚Äçüíº üçè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der Hauptdatenquellen f√ºr den Yandex.Maps-Dienst sind Satellitenbilder. Um die Arbeit mit der Karte zu vereinfachen, sind Objekte: W√§lder, Teiche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verwandeln Sie Satellitenbilder in Karten. Computer Vision in Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  Eine der Hauptdatenquellen f√ºr den Yandex.Maps-Dienst sind Satellitenbilder.  Um die Arbeit mit der Karte zu vereinfachen, sind Objekte: W√§lder, Teiche, Stra√üen, H√§user usw. auf den Fotos mit Polygonen gekennzeichnet. In der Regel sind Kartografen mit der Kennzeichnung besch√§ftigt.  Wir beschlossen, ihnen zu helfen und dem Computer beizubringen, Polygone von H√§usern ohne die Beteiligung von Menschen hinzuzuf√ºgen. <br><br>  F√ºr Operationen mit Bildern trifft der Bereich der IT, der als Computer Vision bezeichnet wird.  In den letzten Jahren wurden die meisten Aufgaben in diesem Bereich mithilfe neuronaler Netze sehr erfolgreich gel√∂st.  Heute werden wir den Lesern von Habr √ºber unsere Erfahrungen mit der Verwendung neuronaler Netze beim Mapping berichten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  Zun√§chst werden wir ein neuronales Gitter trainieren, das sich mit der semantischen Segmentierung befasst, d. H. Bestimmt, ob jeder Punkt im Satellitenbild mit dem Haus zusammenh√§ngt.  Warum ist semantische Segmentierung und nicht nur Objekterkennung?  Wenn das Erkennungsproblem gel√∂st ist, erhalten wir am Ausgang eine Reihe von Rechtecken, die au√üerdem spezifisch sind: Zwei Seiten sind vertikal, zwei sind horizontal.  Und H√§user werden normalerweise relativ zu den Bildachsen gedreht, und einige Geb√§ude haben auch eine komplexe Form. <br><br>  Die Aufgabe der semantischen Segmentierung wird nun von verschiedenen Netzwerken ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNet</a> usw.) gel√∂st.  Sie m√ºssen nur ausw√§hlen, welches f√ºr uns am besten geeignet ist. <br><br>  Nachdem wir die Maske vom Satellitenbild erhalten haben, w√§hlen wir ausreichend gro√üe Gruppen von Punkten aus, die zu den H√§usern geh√∂ren, sammeln sie in verbundenen Bereichen und pr√§sentieren die Grenzen der Bereiche in Vektorform in Form von Polygonen. <br><br>  Es ist klar, dass die Maske nicht absolut genau ist, was bedeutet, dass H√§user in der N√§he in einem verbundenen Bereich zusammenkleben k√∂nnen.  Um dieses Problem zu l√∂sen, haben wir beschlossen, das Netzwerk weiter auszubilden.  Sie findet im Bild die Rippen (die Grenzen der H√§user) und trennt die zusammengeklebten Geb√§ude. <br><br>  Ein solches Schema zeichnete sich ab: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  Wir haben die Erkennungsnetzwerke nicht vollst√§ndig verworfen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mask R-CNN</a> ausprobiert.  Das Plus im Vergleich zur √ºblichen Segmentierung besteht darin, dass die Maske R-CNN Objekte erkennt und eine Maske generiert, sodass die gemeinsame Maske nicht in verbundene Bereiche unterteilt werden muss.  Nun, minus (wie ohne) in der festen Aufl√∂sung der Maske jedes Objekts, d. H. F√ºr gro√üe H√§user mit einer komplexen Grenze, wird sich diese Grenze offensichtlich als vereinfacht herausstellen. <br><br><h2>  Die Werkzeuge </h2><br>  Dann musste man sich f√ºr die Werkzeuge entscheiden.  Hier war alles ziemlich offensichtlich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV</a> eignet sich am besten f√ºr Computer Vision-Aufgaben.  Die Auswahl an neuronalen Netzen ist etwas gr√∂√üer.  Wir haben uns f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tensorflow entschieden</a> .  Seine Vorteile: <br><br><ul><li>  ein ziemlich entwickelter Satz vorgefertigter ‚ÄûW√ºrfel‚Äú, aus denen Sie Ihre Netzwerke zusammenstellen k√∂nnen; </li><li>  Python-API, praktisch zum schnellen Erstellen einer Netzwerkstruktur und zum Trainieren; </li><li>  Ein trainiertes Netzwerk kann in Ihrem Programm √ºber eine C ++ - Schnittstelle verwendet werden (im Vergleich zum Python-Teil sehr schlecht, aber ausreichend, um vorgefertigte Netzwerke auszuf√ºhren). </li></ul><br>  F√ºr Schulungen und andere schwere Computer wollten wir Nirvana verwenden - die wunderbare Yandex-Plattform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, √ºber die wir bereits gesprochen haben</a> . <br><br><h2>  Datacet </h2><br>  Achtzig Prozent Erfolg bei der Arbeit mit einem neuronalen Netzwerk bestehen aus einem guten Datensatz.  F√ºr den Anfang h√§tten wir also einen solchen Datensatz zusammenstellen sollen.  Yandex hat eine gro√üe Anzahl von Satellitenbildern mit bereits markierten Objekten.  Alles scheint einfach zu sein: Laden Sie diese Daten einfach hoch und sammeln Sie sie in einem Datensatz.  Es gibt jedoch eine Einschr√§nkung. <br><br><h3>  Datensatz verfeinern </h3><br>  Wenn eine Person in einem Satellitenbild nach einem Haus sucht, sieht sie als erstes das Dach.  Die H√∂he der H√§user variiert jedoch, der Satellit kann dasselbe Gel√§nde aus verschiedenen Winkeln aufnehmen - und wenn wir ein dem Dach entsprechendes Polygon auf einer Vektorkarte platzieren, gibt es keine Garantie daf√ºr, dass das Dach beim Aktualisieren des Bildes nicht verl√§sst.  Aber das Fundament wird in den Boden gegraben und bleibt aus jedem Winkel, den Sie abnehmen, die ganze Zeit an einem Ort.  Deshalb sind die H√§user auf dem Vektor Yandex.Map "auf den Fundamenten" markiert.  Dies ist richtig, aber f√ºr die Segmentierung von Bildern ist es besser, dem Netzwerk das Suchen nach D√§chern beizubringen: Die Hoffnung, dass das Netzwerk darauf trainiert ist, die Fundamente zu erkennen, ist sehr gering.  Daher sollte im Datensatz alles auf den D√§chern markiert sein.  Um einen guten Datensatz zu erstellen, m√ºssen wir lernen, wie das Vektorlayout von H√§usern von Fundamenten auf D√§cher verschoben wird. <br><br>  <i>Wir haben versucht, uns nicht zu verschieben, aber die Qualit√§t war nicht sehr gut, und das ist verst√§ndlich: Die Aufnahmewinkel des Satelliten sind unterschiedlich, die H√∂hen der H√§user sind unterschiedlich, daher wurde das Fundament auf den Fotos in verschiedene Richtungen und in unterschiedlichen Abst√§nden vom Dach verschoben.</i>  <i>Das Netzwerk geht durch eine solche Vielfalt verloren und trainiert bestenfalls f√ºr etwas dazwischen, im schlimmsten Fall f√ºr etwas Unverst√§ndliches.</i>  <i>Dar√ºber hinaus liefert das Netzwerk f√ºr die semantische Segmentierung ein Ergebnis, das einem akzeptablen √§hnelt, aber bei der Suche nach Kanten sinkt die Qualit√§t dramatisch.</i> <br><br><h4>  Raster-Ansatz </h4><br>  Seit wir auf dem Gebiet der Computer Vision t√§tig sind, haben wir als erstes einen Ansatz ausprobiert, der f√ºr diese Computer Vision relevant ist.  Zuerst wird die Vektorkarte gerastert (die Polygone der H√§user werden mit wei√üen Linien auf schwarzem Hintergrund gezeichnet), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Sobel-Filter</a> w√§hlt die Kanten im Satellitenbild aus.  Und dann gibt es einen Versatz von zwei Bildern relativ zueinander, wodurch die Korrelation zwischen ihnen maximiert wird.  Die Kanten nach dem Sobel-Filter sind ziemlich verrauscht. Wenn dieser Ansatz auf ein Geb√§ude angewendet wird, wird daher nicht immer ein akzeptables Ergebnis erzielt.  Die Methode funktioniert jedoch gut in Gebieten mit Geb√§uden gleicher H√∂he: Wenn Sie sofort nach einem Versatz √ºber einen gro√üen Bereich des Bildes suchen, ist das Ergebnis stabiler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  "Geometrischer" Ansatz </h4><br>  Wenn das Gebiet nicht mit demselben Typ, sondern mit verschiedenen H√§usern aufgebaut ist, funktioniert die vorherige Methode nicht.  Gl√ºcklicherweise kennen wir manchmal die H√∂he von Geb√§uden auf der Yandex-Vektorkarte und die Position des Satelliten w√§hrend der Aufnahme.  Auf diese Weise k√∂nnen wir schulische Kenntnisse der Geometrie nutzen und berechnen, wo und in welcher Entfernung sich das Dach relativ zum Fundament bewegt.  Diese Methode hat den Datensatz in Gebieten mit Hochh√§usern verbessert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  "Manueller" Ansatz </h4><br>  Der zeitaufw√§ndigste Weg: Krempeln Sie die √Ñrmel hoch, decken Sie die Maus auf, starren Sie auf den Monitor und verschieben Sie das Vektorlayout der H√§user manuell von den Fundamenten auf die D√§cher.  Die Technik f√ºhrt zu einem Ergebnis, das von erstaunlicher Qualit√§t ist, aber es wird nicht empfohlen, es in gro√üen Mengen zu verwenden: Entwickler, die mit solchen Aufgaben besch√§ftigt sind, geraten schnell in Apathie und verlieren das Interesse am Leben. <br><br><h4>  Neuronales Netz </h4><br>  Am Ende haben wir genug Satellitenbilder, die auf den D√§chern gut markiert sind.  Es bestand also die M√∂glichkeit, das neuronale Netzwerk zu trainieren (vorerst jedoch nicht zur Segmentierung, sondern zur Verbesserung des Layouts anderer Satellitenbilder).  Und wir haben es geschafft. <br><br>  Die Eingabedaten des Faltungsnetzwerks waren ein Satellitenbild und eine verschobene rasterisierte Markierung.  Am Ausgang erhielten wir einen zweidimensionalen Vektor: vertikale und horizontale Verschiebungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  Mit Hilfe eines neuronalen Netzwerks fanden wir die notwendige Verschiebung, die es uns erm√∂glichte, gute Ergebnisse bei Geb√§uden zu erzielen, f√ºr die die H√∂he nicht angegeben ist.  Infolgedessen haben wir die manuelle Markup-Korrektur erheblich reduziert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Unterschiedliche Gebiete - unterschiedliche H√§user </h3><br>  Es gibt viele interessante Gebiete und Staaten auf Yandex.Maps.  Aber auch in Russland sind die H√§user √§u√üerst unterschiedlich, was sich auf das Aussehen in Satellitenbildern auswirkt.  Sie m√ºssen also die Vielfalt im Datensatz widerspiegeln.  Und anfangs haben wir nicht wirklich verstanden, wie wir mit all dieser Pracht umgehen sollen.  Einen riesigen Datensatz sammeln und dann ein Netzwerk darauf trainieren?  Erstellen Sie Ihren eigenen Datensatz f√ºr jede (bedingte) Art der Entwicklung und trainieren Sie ein separates Netzwerk?  Ein bestimmtes Kernnetzwerk trainieren und es dann f√ºr eine bestimmte Art von Entwicklung trainieren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Empirisch fanden wir Folgendes: <br><br><ol><li>  Zweifellos ist es notwendig, den Datensatz f√ºr verschiedene Geb√§udetypen zu erweitern, f√ºr die das Tool verwendet werden soll.  Ein auf einen Typ geschultes Netzwerk kann Geb√§ude eines anderen Typs unterscheiden, wenn auch sehr schlecht. </li><li>  Es ist besser, ein gro√ües Netzwerk f√ºr den gesamten Datensatz zu trainieren.  Es verallgemeinert sich recht gut auf verschiedene Gebiete.  Wenn Sie f√ºr jede Art von Entwicklung separate Netzwerke trainieren, bleibt die Qualit√§t entweder gleich oder verbessert sich kaum.  Es ist daher sinnlos, unterschiedliche Netzwerke f√ºr unterschiedliche Gebiete zu implementieren.  Dar√ºber hinaus erfordert dies mehr Daten und einen zus√§tzlichen Klassifikator f√ºr die Art der Entwicklung. </li><li>  Wenn Sie beim Hinzuf√ºgen neuer Gebiete zu den Daten alte Netzwerke verwenden, lernen die Netzwerke viel schneller.  Die Umschulung alter Netzwerke in erweiterte Daten f√ºhrt zu ungef√§hr dem gleichen Ergebnis wie das Training eines Netzwerks von Grund auf neu, erfordert jedoch viel weniger Zeit. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  L√∂sungsoptionen </h2><br><h3>  Semantische Segmentierung </h3><br>  Die semantische Segmentierung ist eine ziemlich gut erforschte Aufgabe.  Nach dem Erscheinen des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fully Convolutional Networks</a> wird dieser meist mithilfe neuronaler Netze gel√∂st.  Es bleibt nur die Auswahl eines Netzwerks (wir haben <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SegNet</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNet in</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betracht</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezogen</a> ), die √úberlegung, ob wir zus√§tzliche Tricks wie CRF am Ausgang ben√∂tigen, und die Bestimmung, wie und mit welcher Fehlerfunktion das Training trainiert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  Infolgedessen haben wir uns f√ºr eine U-Net-√§hnliche Architektur mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verallgemeinerten Intersection Over Union-</a> Funktion als Fehlerfunktion entschieden.  F√ºr das Training schneiden wir Satellitenbilder und ihre entsprechenden Markierungen (nat√ºrlich gerastert) in Quadrate und setzen sie zu Datens√§tzen zusammen.  Es stellte sich als ziemlich sch√∂n heraus und manchmal ganz gut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  In Gebieten mit einzelnen Geb√§uden reichte die semantische Segmentierung aus, um zur n√§chsten Stufe √ºberzugehen - der Vektorisierung.  Wo das Geb√§ude dicht ist, kleben H√§user manchmal in einem zusammenh√§ngenden Bereich zusammen.  Es dauerte, um sie zu trennen. <br><br><h3>  Kantenerkennung </h3><br>  Um diese Aufgabe zu bew√§ltigen, finden Sie die Kanten im Bild.  Um Kanten zu erkennen, haben wir uns auch entschlossen, das Netzwerk zu trainieren (Kanten-Suchalgorithmen, die keine neuronalen Netzwerke verwenden, geh√∂ren eindeutig der Vergangenheit an).  Schulung eines Netzwerks vom Typ HED, das unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ganzheitlich verschachtelte Kantenerkennung beschrieben wird</a> .  Im Originalartikel wurde das Netzwerk auf den BSDS-500-Datensatz trainiert, in dem alle Kanten auf den Bildern markiert sind.  Ein geschultes Netzwerk findet alle ausgepr√§gten Kanten: die Grenzen von H√§usern, Stra√üen, Seen usw. Dies reicht bereits aus, um die nahe gelegenen Geb√§ude zu trennen.  Wir haben uns jedoch entschlossen, weiter zu gehen und denselben Datensatz f√ºr das Training wie f√ºr die semantische Segmentierung zu verwenden. Malen Sie jedoch beim Rastern nicht die gesamten Polygone von Geb√§uden, sondern zeichnen Sie nur deren Grenzen. <br><br>  Das Ergebnis war so √ºberw√§ltigend sch√∂n, dass wir beschlossen, die Geb√§ude direkt an den vom Netzwerk empfangenen Kanten zu vektorisieren.  Und es ist ganz passiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Scheitelpunkterkennung </h3><br>  Da ein Netzwerk wie HED an Kanten ein hervorragendes Ergebnis liefert, haben wir beschlossen, es so zu trainieren, dass es Scheitelpunkte erkennt.  Tats√§chlich haben wir ein Netzwerk mit allgemeinen Gewichten f√ºr Faltungsschichten.  Sie hatte zwei Ausg√§nge gleichzeitig: f√ºr Kanten und f√ºr Spitzen.  Infolgedessen haben wir eine andere Version der Geb√§udevektorisierung erstellt, und in einigen F√§llen wurden recht vern√ºnftige Ergebnisse erzielt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  Maske r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mask R-CNN</a> ist eine relativ neue Erweiterung von Netzwerken wie Faster R-CNN.  Maske R-CNN sucht nach Objekten und w√§hlt f√ºr jedes eine Maske aus.  Als Ergebnis erhalten wir f√ºr H√§user nicht nur Begrenzungsrechtecke, sondern auch eine raffinierte Struktur.  Dieser Ansatz ist im Vergleich zu einer einfachen Erkennung (wir wissen nicht, wie sich das Geb√§ude innerhalb des Rechtecks ‚Äã‚Äãbefindet) und einer normalen Segmentierung (mehrere H√§user k√∂nnen zu einem zusammenkleben, und es ist nicht klar, wie sie getrennt werden sollen) g√ºnstig.  Mit Mask R-CNN m√ºssen Sie nicht mehr √ºber zus√§tzliche Tricks nachdenken: Es reicht aus, den Maskenrand f√ºr jedes Objekt zu vektorisieren und sofort das Ergebnis zu erhalten.  Es gibt auch ein Minus: Die Gr√∂√üe der Maske f√ºr das Objekt ist immer festgelegt, d. H. Bei gro√üen Geb√§uden ist die Genauigkeit des Pixellayouts gering.  Das Ergebnis von Mask R-CNN sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Wir haben zuletzt Mask R-CNN ausprobiert und sichergestellt, dass dieser Ansatz bei einigen Geb√§udetypen andere √ºbertrifft. <br><br><h2>  Vektorisierung </h2><br><h3>  Rechteckvektorisierung </h3><br>  Bei aller modernen architektonischen Vielfalt sehen H√§user auf Satellitenbildern immer noch meistens wie Rechtecke aus.  Dar√ºber hinaus ist f√ºr die Masse der Gebiete eine Kennzeichnung mit komplexen Polygonen nicht erforderlich.  Trotzdem m√∂chte ich, dass H√§user auf der Karte markiert werden.  (Nun, zum Beispiel eine Gartenbaupartnerschaft: Es gibt dort normalerweise viele H√§user, manuelles Markieren ist nicht so wichtig, aber das Markieren mit Rechtecken auf der Karte ist sehr gut.) Daher war der erste Ansatz zur Vektorisierung √§u√üerst einfach. <br><br><ol><li>  Nehmen Sie die Rasterregion, die dem "Haus" entspricht. </li><li>  Suchen Sie das Rechteck des Mindestbereichs, der diesen Bereich enth√§lt (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV :: minAreaRect</a> ).  Das Problem ist gel√∂st. </li></ol><br>  Es ist klar, dass die Qualit√§t dieses Ansatzes alles andere als ideal ist.  Der Algorithmus ist jedoch recht einfach und funktioniert in vielen F√§llen. <br><br><h3>  Polygonvektorisierung </h3><br>  Wenn die Qualit√§t der Segmentierung gut genug ist, k√∂nnen Sie die Kontur des Hauses genauer nachbilden.  In den meisten Geb√§uden mit komplexer Form sind die Winkel gr√∂√ütenteils richtig, daher haben wir beschlossen, das Problem auf die Aufgabe zu reduzieren, ein Polygon mit orthogonalen Seiten zu konstruieren.  Um dies zu l√∂sen, m√∂chten wir zwei Ziele gleichzeitig erreichen: das einfachste Polygon finden und die Form von Geb√§uden so genau wie m√∂glich wiederholen.  Diese Ziele stehen in Konflikt miteinander, daher m√ºssen Sie zus√§tzliche Bedingungen einf√ºhren: um die minimale L√§nge der W√§nde, die maximale Abweichung von der Rasterregion usw. zu begrenzen. <br><br>  Der Algorithmus, der uns zuerst einfiel, basierte auf der Konstruktion der Projektion von Punkten auf geraden Linien: <br><br><ol><li>  Finden Sie den Umriss der Rasterregion, die einem Haus entspricht. </li><li>  Reduzieren Sie die Anzahl der Punkte in der Schaltung, indem Sie sie beispielsweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Douglas-Pecker-Algorithmus</a> vereinfachen. </li><li>  Finden Sie die l√§ngste Seite in der Gliederung.  Es ist sein Neigungswinkel, der den Winkel des gesamten zuk√ºnftigen orthogonalen Polygons bestimmt. </li><li>  Konstruieren Sie eine Projektion vom n√§chsten Konturpunkt zur vorherigen Seite. </li><li>  Seite zum Projektionspunkt ausfahren.  Wenn der Abstand vom Punkt zu seiner Projektion gr√∂√üer als die k√ºrzeste Wand des Geb√§udes ist, f√ºgen Sie das resultierende Segment zur Kontur des Geb√§udes hinzu. </li><li>  Wiederholen Sie die Schritte 4 und 5, bis der Stromkreis schlie√üt. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Dieser Algorithmus ist extrem einfach und bringt schnell Ergebnisse, aber die Kontur des Geb√§udes ist manchmal ziemlich verrauscht.  Bei dem Versuch, dieses Problem zu l√∂sen, haben wir eine ziemlich interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂sung f√ºr das</a> Problem gefunden, bei der ein quadratisches Gitter im Raum verwendet wird, um das Polygon zu approximieren.  Kurz beschrieben besteht der Algorithmus aus drei Aktionen: <br><br><ol><li>  Erstellen Sie ein quadratisches Gitter im Raum, der auf Null zentriert ist. </li><li>  Konstruieren Sie an Gitterpunkten, die nicht weiter als einen bestimmten Abstand von der urspr√ºnglichen Kontur entfernt sind, verschiedene Polygone. </li><li>  W√§hlen Sie ein Polygon mit einer Mindestanzahl von Scheitelpunkten aus. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Da der erforderliche Drehwinkel des Gitters nicht im Voraus bekannt ist, m√ºssen mehrere Werte aussortiert werden, was sich negativ auf die Leistung auswirkt.  Mit dem Algorithmus k√∂nnen Sie jedoch visuell sch√∂nere Ergebnisse erzielen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Verbesserung der Vektorisierung </h2><br>  W√§hrend wir tats√§chlich mit jedem Haus separat gearbeitet haben.  Wenn die erste Phase abgeschlossen ist, k√∂nnen Sie bereits mit dem gesamten Bild arbeiten und das Ergebnis verbessern.  Hierzu wurde ein Algorithmus zur Nachbearbeitung eines Satzes von Polygonen hinzugef√ºgt.  Wir haben folgende Heuristiken verwendet: <br><br><ul><li>  Normalerweise sind die W√§nde benachbarter H√§user parallel.  Au√üerdem: Meistens k√∂nnen H√§user zu Sets zusammengefasst werden, in denen alle Elemente ausgerichtet sind. </li><li>  Wenn auf dem Bild bereits Stra√üen markiert sind, ist es sehr wahrscheinlich, dass die Seiten der Polygone parallel zu den Stra√üen verlaufen. </li><li>  Wenn sich die Polygone schneiden, ist es h√∂chstwahrscheinlich sinnvoll, die W√§nde so zu verschieben, dass der Schnitt verschwindet. </li></ul><br>  Als Ergebnis erschien der folgende Algorithmus: <br><br><ol><li>  Wir gruppieren die H√§user, die sich aus dem Abstand zwischen ihnen und dem Drehwinkel ergeben.  Wir mitteln die Umdrehungen von Geb√§uden in jedem Cluster.  Wir wiederholen, bis sich die Position der Geb√§ude nicht mehr √§ndert oder bis die H√§user zu stark von der urspr√ºnglichen Position abweichen. </li><li>  Wir w√§hlen H√§user in der N√§he der Stra√üen, wir finden die l√§ngsten und am n√§chsten an der Stra√üenseite.  Wir drehen das Haus bis zur Parallelit√§t der ausgew√§hlten Seite und der Stra√üe. </li><li>  Wir entfernen die Schnittpunkte zwischen den Polygonen und verschieben die Seiten zweier sich kreuzender Geb√§ude proportional zur Gr√∂√üe der Seiten. </li></ol><br><h2>  Ergebnis </h2><br>  Als Ergebnis haben wir ein Tool erhalten, das Geb√§ude verschiedener Geb√§udetypen erkennen kann.  Es hilft Kartographen bei ihrer harten Arbeit: Es beschleunigt die Suche nach vermissten H√§usern erheblich und f√ºllt neue, noch nicht bebaute Gebiete aus.  Derzeit wurden mit diesem Tool mehr als 800.000 neue Objekte zur Personenkarte hinzugef√ºgt. <br><br>  Nachfolgend sehen Sie einige Beispiele f√ºr die Erkennung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431108/">https://habr.com/ru/post/de431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431096/index.html">So erstellen Sie ein Chat-Bot-Produkt</a></li>
<li><a href="../de431098/index.html">Selbst ein Feuer ist kein Hindernis oder eine Wiederherstellung der Zimbra-Geschwindigkeit nach einer Katastrophe</a></li>
<li><a href="../de431102/index.html">Wie die physikalische Adresse in DRAM-Strings und -Banken angezeigt wird</a></li>
<li><a href="../de431104/index.html">Wie wir bei Neoflex DevOps-Know-how entwickeln</a></li>
<li><a href="../de431106/index.html">Wie viel Geld haben die Amerikaner an diesem schwarzen Freitag ausgegeben und was haben Smartphones damit zu tun?</a></li>
<li><a href="../de431110/index.html">H√∂ren Sie auf, Verlage zu f√ºttern. Die EU entwickelt Regeln f√ºr den obligatorischen freien Zugang zu Forschung</a></li>
<li><a href="../de431112/index.html">Verwendung der Methode der kleinsten Quadrate zum Bewerten von Ressourcen und √úberwachen von Oracle-Datenbanken</a></li>
<li><a href="../de431116/index.html">Willst du seltsam: R√ºckblick auf die bevorstehende DartUP-Konferenz in St. Petersburg</a></li>
<li><a href="../de431118/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 22. Postf√§cher: Nebendienstleistungen und Datenstrukturen</a></li>
<li><a href="../de431120/index.html">Leiden bei der Arbeit ist nicht notwendig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>