<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”  ğŸ˜’ ğŸš¶ Membuat bot untuk berpartisipasi dalam cangkir mini AI. Pengalaman GPU ğŸ“ ğŸ¦‹ âœğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kelanjutan Pasal 1 dan Pasal 2 . 


 Di bawah potongan ini, saya akan berbicara tentang pengalaman penulis dalam menggunakan GPU untuk perhitungan, te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat bot untuk berpartisipasi dalam cangkir mini AI. Pengalaman GPU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417757/"><p><img src="https://habrastorage.org/webt/0y/a5/cb/0ya5cbi1psai9jbzlfxhlhnzx4w.jpeg"></p><br><p>  Kelanjutan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pasal 1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pasal 2</a> . </p><br><p>  Di bawah potongan ini, saya akan berbicara tentang pengalaman penulis dalam menggunakan GPU untuk perhitungan, termasuk sebagai bagian dari pembuatan bot untuk berpartisipasi dalam piala mini AI.  Melainkan, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">esai</a> tentang masalah GPU. </p><br><p>  - Namamu ajaib ... <br>  -Apakah kamu tahu, Joel? .. Keajaiban itu pergi ... </p><a name="habracut"></a><br><p> Di masa kanak-kanak, kita berbicara tentang usia ketika kimia belum berjalan di sekolah atau baru mulai terjadi, penulis terpesona oleh reaksi pembakaran, kebetulan orang tuanya tidak mengganggu dia dan gurun Moskow dekat rumah kadang-kadang diterangi oleh berbagai aktivitas anak-anak, roket buatan sendiri berwarna hitam bubuk mesiu, pada karamel gula-nitrat, dll.  Dua keadaan membatasi fantasi anak-anak: dekomposisi nitrogliserin di laboratorium rumah dengan langit-langit berdesis dari asam dan dorongan ke ruang polisi dalam upaya untuk mendapatkan bahan kimia di salah satu perusahaan pertahanan yang tersebar di sekitar wilayah metro Aviamotornaya. </p><br><p>  Dan kemudian sebuah sekolah fisika dengan komputer yamaha msx muncul, kalkulator MK yang dapat diprogram di rumah, dan tidak ada waktu untuk kimia.  Kepentingan anak telah bergeser ke komputer.  Dan apa yang kurang dari penulis dari kenalan pertama dengan komputer adalah reaksi terbakar, program-programnya membara, tidak ada sensasi kekuatan alami ini.  Anda bisa melihat proses mengoptimalkan perhitungan dalam permainan, tetapi pada saat itu penulis tidak tahu bagaimana cara mengganti perhitungan dosa () dengan tabel nilai fungsi ini, tidak ada Internet ... </p><br><p>  Jadi, penulis bisa mendapatkan perasaan senang dari daya komputasi, pembakaran bersih, saya menggunakan GPU dalam perhitungan. </p><br><p>  Pada habr ada beberapa artikel bagus tentang perhitungan pada GPU.  Ada juga banyak contoh di Internet, jadi diputuskan untuk hanya menulis pada hari Sabtu pagi tentang perasaan pribadi dan dimungkinkan untuk mendorong orang lain menuju paralelisme massa. </p><br><p>  Mari kita mulai dengan formulir sederhana.  Komputasi GPU mendukung beberapa kerangka kerja, tetapi yang paling terkenal adalah NVIDIA CUDA dan OpenCL.  Kami akan mengambil CUDA dan segera kami harus mempersempit set bahasa pemrograman kami ke C ++.  Ada perpustakaan untuk menghubungkan ke CUDA dalam bahasa pemrograman lain, misalnya, ALEA GPU dalam C #, tetapi ini lebih merupakan topik dari artikel ulasan terpisah. </p><br><p>  Karena mereka tidak dapat membuat mobil massal dengan mesin jet pada satu waktu, meskipun beberapa indikatornya lebih tinggi daripada mesin pembakaran internal, perhitungan paralel tidak selalu mungkin untuk diterapkan dalam masalah nyata.  Aplikasi utama untuk komputasi paralel: Anda memerlukan tugas yang mengandung beberapa elemen karakter massal, multiplisitas.  Dalam kasus kami membuat bot, jaringan saraf (banyak neuron, koneksi saraf) jatuh di bawah massa dan populasi bot (menghitung dinamika pergerakan, tabrakan untuk setiap bot membutuhkan waktu, jika bot dari 300-1000 maka prosesor pusat menyerah dan Anda akan mengamati hanya lambat) membara program Anda, seperti jeda panjang antara frame visualisasi). </p><br><p>  Pilihan massa terbaik adalah ketika setiap elemen perhitungan tidak bergantung pada hasil perhitungan pada elemen lain dari daftar, misalnya, tugas sederhana menyortir array sudah ditumbuhi semua jenis trik, karena posisi angka dalam array tergantung pada angka lain dan tidak dapat dimasukkan ke dahi pada <strong>siklus paralel</strong> .  Untuk menyederhanakan kata-kata: tanda pertama dari karakter massa yang sukses adalah bahwa jika Anda tidak perlu mengubah posisi elemen dalam array, Anda dapat dengan bebas melakukan perhitungan di atasnya, mengambil nilai-nilai elemen lain untuk ini, tetapi jangan memindahkannya dari tempatnya.  Sesuatu seperti dongeng: jangan mengubah urutan elemen, jika tidak GPU akan berubah menjadi labu. </p><br><p>  Dalam bahasa pemrograman modern, ada konstruksi yang dapat dieksekusi secara paralel pada beberapa inti prosesor pusat atau utas logis dan mereka banyak digunakan, tetapi penulis memfokuskan pembaca pada paralelisme massa, ketika jumlah modul yang dieksekusi melebihi ratusan atau ribuan unit. </p><br><p>  Elemen pertama dari struktur paralel muncul: <strong>siklus paralel</strong> .  Untuk sebagian besar tugas, itu sudah cukup.  Dalam arti luas, inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intisari</a> <br>  komputasi paralel. </p><br><p>  Contoh penulisan loop utama di CUDA (kernel): </p><br><pre><code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tid = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadN = gridDim.x * blockDim.x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> = tid; <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> &lt; numElements; <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> += threadN) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>,     ,       thread     pos.  :    thread    ,  thread   <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>=<span class="hljs-number"><span class="hljs-number">1146</span></span>     thread c  <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>=<span class="hljs-number"><span class="hljs-number">956</span></span>.        .           . }</code> </pre> <br><p>  Banyak yang telah ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi dan ulasan untuk CUDA</a> , tentang blok GPU, tentang Thread yang diproduksi di blok ini, bagaimana cara memparalelkan tugas pada mereka.  Tetapi jika Anda memiliki array data dan itu jelas terdiri dari elemen massa, gunakan bentuk loop di atas, karena secara visual mirip dengan loop biasa dalam bentuk, yang menyenangkan, tetapi sayangnya tidak dalam konten. </p><br><p>  Saya pikir pembaca sudah mengerti bahwa kelas tugas dengan cepat menyempit dalam kaitannya dengan pemrograman paralel massa.  Jika kita berbicara tentang membuat game, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin rendering</a> 3d, jaringan saraf, pengeditan video, dan tugas serupa lainnya, maka pembersihan untuk tindakan pembaca independen sangat usang, ada program besar, program kecil, kerangka kerja, pustaka yang dikenal dan tidak dikenal untuk tugas-tugas ini.  Artinya, area tersebut tetap hanya dari topik, untuk membuat roket komputasi kecil Anda sendiri, bukan SpaceX dan Roscosmos, tetapi sesuatu yang sederhana, tetapi benar-benar jahat dalam perhitungan. </p><br><p><img src="https://habrastorage.org/webt/p6/f-/yt/p6f-ytvdsye66m74evqa0xisslc.png"></p><br><p>  Berikut adalah gambar roket yang benar-benar menyala yang digambarkan. </p><br><p>  Berbicara tentang tugas-tugas yang tidak dapat dipecahkan oleh siklus paralel di tangan Anda.  Dan pencipta CUDA dalam pribadi pengembang NVIDIA telah memikirkan hal ini. </p><br><p>  Ada perpustakaan Thrust di beberapa tempat yang berguna sampai "tidak ada opsi" dilakukan secara berbeda.  Omong-omong, tidak menemukan ulasan lengkap tentang HabrÃ©. </p><br><p>  Untuk memahami cara kerjanya, pertama-tama Anda perlu mengatakan tiga kalimat tentang prinsip-prinsip CUDA.  Jika Anda membutuhkan lebih banyak kata, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> tautannya. </p><br><p>  Prinsip-prinsip CUDA: </p><br><p>  Perhitungan dilakukan pada GPU, program yang merupakan kernel, dan Anda harus menuliskannya dalam C. Kernel, pada gilirannya, hanya berkomunikasi dengan memori GPU dan Anda harus memuat data ke dalam memori prosesor video dari program utama dan mengunggahnya kembali ke program.  Algoritma canggih pada CUDA membutuhkan fleksibilitas pikiran. </p><br><p>  Jadi, perpustakaan Thrust menghapus rutin dan mengambil beberapa tugas "kompleks" untuk CUDA, seperti menjumlahkan array atau mengurutkannya.  Anda tidak perlu lagi menulis kernel terpisah, memuat pointer ke memori, dan menyalin data dari pointer ini ke memori GPU.  Semua misteri akan terjadi di depan mata Anda di program utama dan dengan kecepatan sedikit lebih rendah daripada CUDA.  Perpustakaan Thrust ditulis dalam CUDA, jadi ini adalah bidang beri tunggal dalam hal kinerja. </p><br><p>  Yang perlu Anda lakukan di Thrust adalah membuat array (thrust :: vector) di dalam library-nya, yang kompatibel dengan array reguler (std :: vector).  Itu, tentu saja, tidak semuanya begitu sederhana, tetapi makna dari apa yang penulis katakan mirip dengan kebenaran.  Sebenarnya ada dua array, satu di GPU (perangkat), yang lain di program utama (host). </p><br><p>  Contoh akan menunjukkan kesederhanaan dari sintaks (X, Y, Z array): </p><br><pre> <code class="hljs vhdl">// initialize X <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, .... thrust::<span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>(X.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), X.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()); // compute Y = -X thrust::transform(X.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), X.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), Y.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), thrust::negate&lt;int&gt;()); // fill Z <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> twos thrust::fill(Z.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), Z.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), <span class="hljs-number"><span class="hljs-number">2</span></span>); // compute Y = X <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> thrust::transform(X.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), X.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), Z.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), Y.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), thrust::modulus&lt;int&gt;()); // replace <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> the ones <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Y <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> tens thrust::replace(Y.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), Y.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Anda dapat melihat betapa tidak berbahaya tampilannya dengan latar belakang membuat kernel CUDA, dan serangkaian fungsi di Thrust <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> .  Mulai dari bekerja dengan variabel acak, yang dalam CUDA dilakukan oleh pustaka cuRAND yang terpisah (lebih disukai dijalankan oleh kernel terpisah), untuk menyortir, menjumlahkan, dan menulis fungsi Anda sesuai dengan fungsionalitas yang dekat dengan fungsi kernel. </p><br><p>  Penulis memiliki sedikit pengalaman menggunakan CUDA dan C ++, dua bulan.  Tentang tahun ini tentang C #.  Ini, tentu saja, sedikit bertentangan dengan permulaan artikel tentang kenalan awalnya dengan komputer, fisika sekolah, dan matematika terapan sebagai pendidikan.  Saya akan bilang begitu.  Tetapi mengapa saya menulis artikel ini, bukan karena saya menguasai semuanya seperti itu, tetapi bahwa C ++ ternyata menjadi bahasa yang nyaman (saya dulu agak takut akan hal itu, dengan latar belakang artikel dalam jenis Haber â€œfungsi lambda â†’ kelebihan beban operator internal, seperti mendefinisikan ulang segalanya "), jelas bahwa tahun-tahun perkembangannya telah menyebabkan lingkungan pengembangan yang cukup ramah (IDE).  Bahasa itu sendiri dalam versi terbarunya, sepertinya mengumpulkan sampah dari memori, saya tidak tahu bagaimana itu sebelumnya.  Setidaknya, program yang ditulis oleh penulis tentang konstruksi algoritmik paling sederhana mendorong algoritma komputasi untuk bot selama berhari-hari dan tidak ada kebocoran memori dan kegagalan lainnya pada beban tinggi.  Ini juga berlaku untuk CUDA, pada awalnya tampaknya rumit, tetapi didasarkan pada prinsip-prinsip sederhana dan tentu saja sulit untuk menginisialisasi tempat pada GPU di tempat-tempat jika ada banyak, tetapi kemudian Anda akan memiliki roket kecil Anda sendiri, dengan asap dari kartu video. </p><br><p>  Dari kelas objek untuk pelatihan dengan GPU, penulis merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">automata seluler</a> .  Pada suatu waktu ada peningkatan popularitas dan mode untuk mereka, tetapi kemudian jaringan saraf menangkap pikiran para pengembang. <br>  Hingga: </p><br><p>  "Setiap kuantitas dalam fisika, termasuk waktu dan ruang, adalah terbatas dan terpisah." <br>  daripada bukan otomat seluler. </p><br><p>  Tapi itu indah ketika tiga formula sederhana dapat membuat ini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wNiBFQgrNp8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Jika akan menarik untuk membaca tentang automata seluler di CUDA, tulis di komentar, akan ada bahan yang diketik untuk artikel kecil. <br>  Dan ini adalah sumber automata seluler (di bawah video ada tautan ke sumbernya): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/KJe9H6qS82I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Gagasan untuk menulis artikel setelah sarapan, dalam satu napas tampaknya bagi saya berhasil.  Waktu kopi kedua.  Memiliki pembaca akhir pekan yang menyenangkan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417757/">https://habr.com/ru/post/id417757/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417745/index.html">Pengalaman Pribadi: Rekayasa Data di Upwork</a></li>
<li><a href="../id417747/index.html">Re: "Perbandingan kerangka JS: Bereaksi, Vue, dan Hyperapp"</a></li>
<li><a href="../id417749/index.html">Project Loon sebagai proyek komersial: kontrak pertama ditandatangani</a></li>
<li><a href="../id417753/index.html">Kompresi array bilangan prima yang besar</a></li>
<li><a href="../id417755/index.html">Studi: 80% dari 2017 ICO dianggap curang</a></li>
<li><a href="../id417759/index.html">Jadilah bebek karet saya</a></li>
<li><a href="../id417761/index.html">GitLab bergerak dari Azure ke Google Cloud Platform. Berita Relokasi dan Tanggal Pemeliharaan</a></li>
<li><a href="../id417763/index.html">MVIDroid: tinjauan perpustakaan MVI baru (Model-View-Intent)</a></li>
<li><a href="../id417767/index.html">Analisis sentimen teks menggunakan jaringan saraf convolutional</a></li>
<li><a href="../id417769/index.html">Desain Memori Pengguna: Cara Desain Untuk Usia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>