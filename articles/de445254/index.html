<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ€„ï¸ ğŸŒ ğŸš› Testen von Ethereum Smart Contracts on Go: Auf Wiedersehen, JavaScript ğŸ‘©â€ğŸ”¬ ğŸ™†ğŸ½ ğŸ“²</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mÃ¶chte meinen Kollegen Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich und Igor Titarenko fÃ¼r Konsultationen, Feedback und Tests danken. Ich mÃ¶chte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von Ethereum Smart Contracts on Go: Auf Wiedersehen, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="Bild"><br>  <em>Ich mÃ¶chte meinen Kollegen Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich und Igor Titarenko fÃ¼r Konsultationen, Feedback und Tests danken.</em>  <em>Ich mÃ¶chte mich auch beim PolySwarm-Team fÃ¼r die Entwicklung der Originalversion von Perigord bedanken.</em> <em><br></em> <br>  <em>Dies ist eine Ãœbersetzung meines ersten verÃ¶ffentlichten mittelenglischen Artikels</em> </p><br><p>  Das Testen war schon immer ein wesentlicher Bestandteil der Softwareentwicklung, wenn auch nicht der unterhaltsamste.  Wenn es um intelligente VertrÃ¤ge geht, sind strenge Tests mit auÃŸergewÃ¶hnlicher Liebe zum Detail erforderlich  Fehler kÃ¶nnen nach der Bereitstellung im Blockchain-Netzwerk nicht mehr behoben werden.  In den letzten Jahren hat die Ethereum-Community viele Tools fÃ¼r die Entwicklung intelligenter VertrÃ¤ge entwickelt.  Einige von ihnen wurden nicht populÃ¤r, zum Beispiel Vyper - ein Python-Dialekt zum Schreiben intelligenter VertrÃ¤ge.  Andere, wie z. B. Solidity, sind zu einem anerkannten Standard geworden.  Die bislang umfangreichste Dokumentation zum Testen intelligenter VertrÃ¤ge enthÃ¤lt eine Reihe von TrÃ¼ffeln und Ganache.  Beide Tools verfÃ¼gen Ã¼ber eine gute Dokumentation. In vielen FÃ¤llen wurde bereits Ã¼ber StapelÃ¼berlauf und Ã¤hnliche Ressourcen entschieden.  Dieser Ansatz hat jedoch einen wichtigen Nachteil: Um Tests zu schreiben, mÃ¼ssen Sie Node.js verwenden. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  JavaScript-Fallen </h4><br><p>  Auch wenn Sie kein Fan von statisch typisierten Programmiersprachen sind und JavaScript lieben, sollten Sie einen Tippfehler machen und das Ergebnis einer Funktion vergleichen, die eine Zeichenfolge mit einem booleschen Wert zurÃ¼ckgibt, indem Sie die veraltete Equal-Methode anstelle von strictEqual verwenden. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Wenn checkProposal die Zeichenfolge "yes" oder "no" zurÃ¼ckgibt, konvertieren Sie sie immer in "true".  Durch dynamisches Tippen werden viele dieser Fallen ausgeblendet, und selbst erfahrene Programmierer kÃ¶nnen solche Fehler machen, wenn sie an einem groÃŸen Projekt oder in einem Team mit anderen Entwicklern arbeiten, die Ã„nderungen am Code vornehmen und ihn nicht melden kÃ¶nnen. </p><br><p>  Die statische Eingabe von Go hilft, solche Fehler zu vermeiden.  DarÃ¼ber hinaus ist die Verwendung der Go-Sprache anstelle von Node.js zum Testen der Traum eines jeden Go-Entwicklers, der mit intelligenten VertrÃ¤gen arbeitet. </p><br><p>  Mein Team entwickelte ein Investitionssystem, das auf intelligenten VertrÃ¤gen mit einer sehr komplexen Architektur basiert.  Das intelligente Vertragssystem enthielt mehr als 2.000 Codezeilen.  Da der GroÃŸteil des Teams aus Go-Entwicklern bestand, war das Testen auf Go Node.js vorzuziehen. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  Die erste Umgebung zum Testen intelligenter VertrÃ¤ge auf Go </h4><br><p>  Im Jahr 2017 entwickelte PolySwarm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perigord</a> , ein Truffle-Ã¤hnliches Tool, das Go anstelle von JavaScript verwendet.  Leider wird dieses Projekt nicht mehr unterstÃ¼tzt, es gibt nur ein Tutorial mit sehr einfachen Beispielen.  DarÃ¼ber hinaus wird die Integration mit Ganache (einer privaten Blockchain zur Entwicklung von Ethereum mit einer sehr praktischen BenutzeroberflÃ¤che) nicht unterstÃ¼tzt.  Wir haben Perigord verbessert, indem wir Fehler beseitigt und zwei neue Funktionen eingefÃ¼hrt haben: Generieren von Brieftaschen aus dem Mnemonik-Code und Verwenden dieser zum Testen und Herstellen einer Verbindung mit der Ganache-Blockchain.  Den Quellcode kÃ¶nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. </p><br><p>  Das ursprÃ¼ngliche Perigord-Tutorial enthÃ¤lt nur das einfachste Beispiel fÃ¼r das Aufrufen eines Vertrags zum Ã„ndern eines einzelnen Werts.  In der realen Welt mÃ¼ssen Sie jedoch auch einen Vertrag aus verschiedenen GeldbÃ¶rsen anrufen, Ether senden und empfangen usw.  Jetzt kÃ¶nnen Sie all dies mit dem fortgeschrittenen Perigord und dem guten alten Ganache tun.  Im Folgenden finden Sie detaillierte Anleitungen zum Entwickeln und Testen intelligenter VertrÃ¤ge mit Perigord &amp; Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Verwenden von Advanced Perigord: Eine vollstÃ¤ndige Anleitung </h4><br><p>  Um Perigord verwenden zu kÃ¶nnen, mÃ¼ssen Sie Go 1.7+, solc, abigen und Ganache installieren.  Weitere Informationen finden Sie in der Dokumentation zu Ihrem Betriebssystem. </p><br><p>  Installieren Sie Perigord wie folgt: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Danach kÃ¶nnen Sie den Befehl perigord verwenden: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Wir werden jetzt einen einfachen Market Smart-Vertrag erstellen, um die verfÃ¼gbaren Testoptionen zu demonstrieren. </p><br><p>  Geben Sie Folgendes in das Terminal ein, um ein Projekt zu starten: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  Das Projekt wird im Ordner src / in GOPATH angezeigt.  Verschieben Sie das Projekt in einen anderen Ordner und aktualisieren Sie die Importpfade, wenn Sie den Speicherort Ã¤ndern mÃ¶chten.  Mal sehen, was sich im Markt / Ordner befindet. </p><br><pre> <code class="plaintext hljs">$ tree . â”œâ”€â”€ contracts â”‚ â””â”€â”€ Foo.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  Sehr Ã¤hnlich dem in Truffle erstellten Projekt, nicht wahr?  Aber es geht alles los!  Mal sehen, was in der Konfigurationsdatei perigord.yaml enthalten ist. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Zum Testen kÃ¶nnen Sie sowohl das private Geth-Netzwerk als auch Brieftaschendateien verwenden und eine Verbindung zu Ganache herstellen.  Diese Optionen schlieÃŸen sich gegenseitig aus.  Wir verwenden die Standard-Mnemonik, generieren 10 Konten und stellen eine Verbindung zu Ganache her.  Ersetzen Sie den Code in perigord.yaml durch: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP http://127.0.0.1:7545</a> - die Standardadresse des Ganache RPC-Servers.  Bitte beachten Sie, dass Sie eine beliebige Anzahl von Konten zum Testen erstellen kÃ¶nnen, aber nur in der Ganache (GUI) generierte Konten Gelder enthalten. </p><br><p>  Wir werden einen Vertrag namens Market.sol erstellen.  Er kann Aufzeichnungen Ã¼ber Adresspaare fÃ¼hren, von denen einer Geld auf das Vertragskonto sendet und der andere das Recht hat, Geld zu erhalten, wenn der VertragseigentÃ¼mer die Erlaubnis fÃ¼r eine solche Transaktion erteilt.  Beispielsweise vertrauen sich zwei Teilnehmer nicht, sondern dem Vertragsinhaber, der entscheidet, ob eine bestimmte Bedingung erfÃ¼llt ist.  Das Beispiel implementiert mehrere Grundfunktionen zu Demonstrationszwecken. </p><br><p>  FÃ¼gen Sie dem Projekt einen Kontakt hinzu: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  Das Postfix .sol wird automatisch hinzugefÃ¼gt.  Sie kÃ¶nnen auch andere VertrÃ¤ge hinzufÃ¼gen oder den Beispielvertrag Foo.sol lÃ¶schen.  WÃ¤hrend Sie bei GOPATH arbeiten, kÃ¶nnen Sie ImportvertrÃ¤ge verwenden, um komplexe Strukturen zu erstellen.  Wir werden drei Solidity-Dateien haben: den Hauptmarktvertrag, die Ownable- und Migrations-ZusatzvertrÃ¤ge und die SafeMath-Bibliothek.  Den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Jetzt hat das Projekt folgende Struktur: </p><br><pre> <code class="plaintext hljs">. â”œâ”€â”€ contracts â”‚ â”œâ”€â”€ Market.sol â”‚ â”œâ”€â”€ Ownable.sol â”‚ â””â”€â”€ SafeMath.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  Generieren Sie EVM-Bytecode-, ABI- und Go-Bindungen: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  FÃ¼gen Sie die Migrationen aller VertrÃ¤ge hinzu, die Sie bereitstellen mÃ¶chten.  Weil  Wir stellen nur Market.sol bereit. Wir benÃ¶tigen nur eine neue Migration: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Unser Vertrag enthÃ¤lt keinen Konstruktor, der Parameter akzeptiert.  Wenn Sie Parameter an den Konstruktor Ã¼bergeben mÃ¼ssen, fÃ¼gen Sie sie der Funktion Deploy {NewContract} in der Migrationsdatei hinzu: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), â€œFOOâ€, â€œBARâ€)</code> </pre> <br><p>  LÃ¶schen Sie die Beispieldatei Foo.go und fÃ¼gen Sie eine Testdatei fÃ¼r unseren Vertrag hinzu: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Um deterministische GeldbÃ¶rsen zu verwenden, mÃ¼ssen wir die Mnemonik aus der Konfigurationsdatei lesen: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  Die folgende Hilfsfunktion wird verwendet, um die Netzwerkadresse abzurufen: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Eine weitere Hilfsfunktion, die wir benÃ¶tigen, ist sendETH. Wir werden sie verwenden, um Ether von einer der generierten GeldbÃ¶rsen (angezeigt durch den Index) an eine beliebige Ethereum-Adresse zu Ã¼bertragen: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Die folgenden zwei Funktionen werden zum Ã„ndern eines Vertragsaufrufs verwendet: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Testverfahren </h4><br><p>  FÃ¼r einen Anruf erstellen wir einen contractSessionActual fÃ¼r einen bestimmten Vertrag.  Weil  Der Vertrag hat einen EigentÃ¼mer. Wir kÃ¶nnen seine Adresse abrufen und prÃ¼fen, ob er mit dem Standard-Null-Ganache-Konto Ã¼bereinstimmt.  Wir werden dies wie folgt tun (wir werden die Fehlerbehandlung weglassen, um Platz zu sparen): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  Die nÃ¤chste nÃ¼tzliche Funktion ist das Ã„ndern der Brieftasche, die den Vertrag verursacht: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Weil  Eine der Hauptfunktionen beim Testen ist das Ã„ndern des Anrufvertrags. Lassen Sie uns eine Zahlung im Namen des Absenders leisten: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  Der vollstÃ¤ndige Testcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Ã–ffnen Sie nun stub_test.go und stellen Sie sicher, dass alle Importe auf Ihr aktuelles Projekt verweisen.  In unserem Fall ist es: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  FÃ¼hren Sie die Tests aus: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Wenn alles richtig gemacht wurde, gibt es nach dem Ende des Tests ein Ã¤hnliches Ergebnis: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Wenn Sie Probleme haben, laden Sie die Quelldateien herunter und wiederholen Sie die in diesem Handbuch beschriebenen Schritte. </p><br><h4 id="v-zaklyuchenie">  AbschlieÃŸend </h4><br><p>  Perigord ist ein zuverlÃ¤ssiges Testwerkzeug, das in Ihrer Lieblingssprache geschrieben ist.  Er erstellt dieselbe Projektstruktur wie Truffle und hat dieselben Teams, sodass Sie nicht neu lernen mÃ¼ssen.  Durch statische Typisierung und eine eindeutige Funktionssignatur kÃ¶nnen Sie schnell Debugging entwickeln und durchfÃ¼hren sowie sich erheblich gegen Tippfehler in den Argumenten schÃ¼tzen.  In Perigord kÃ¶nnen Sie ein vorhandenes Projekt problemlos nach Truffle migrieren (Sie mÃ¼ssen lediglich die Vertragsdateien kopieren und in den entsprechenden Ordner einfÃ¼gen und Tests hinzufÃ¼gen) und ein vollstÃ¤ndig neues Projekt mit in Go geschriebenen Tests starten. </p><br><p>  Ich hoffe, dass die vom PolySwarm-Team begonnene und von Inn4Science fortgesetzte Arbeit fÃ¼r die Go-Community nÃ¼tzlich und frei von Test- und Debugging-Stunden mit weniger praktischen Tools ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445254/">https://habr.com/ru/post/de445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445242/index.html">Erfahrung mit Coroutinen und Retrofit2</a></li>
<li><a href="../de445244/index.html">"Geldspiele auÃŸerhalb der Blockchain mÃ¼ssen sterben"</a></li>
<li><a href="../de445246/index.html">Nicht-Blockchain-Spiele mit Geld mÃ¼ssen sterben</a></li>
<li><a href="../de445248/index.html">Willst du ein bisschen glÃ¼cklicher sein? Versuchen Sie, der Beste auf Ihrem Gebiet zu sein</a></li>
<li><a href="../de445252/index.html">Digitale Rechte gingen nach Russland</a></li>
<li><a href="../de445256/index.html">Cyberkriminelle kontrollierten ASUS Live Update fÃ¼nf Monate lang</a></li>
<li><a href="../de445258/index.html">So lÃ¶schen Sie Ihre Daten sicher von Ihrem Android-Smartphone, bevor Sie sie verkaufen</a></li>
<li><a href="../de445260/index.html">Werden sich Roboter jemals wirklich erkennen? Wissenschaftler bewegen sich in diese Richtung.</a></li>
<li><a href="../de445262/index.html">GeekUniversity erÃ¶ffnet Rekrutierung in der Big Data-Abteilung fÃ¼r Analytik</a></li>
<li><a href="../de445264/index.html">Preload, Prefetch und andere Tags</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>