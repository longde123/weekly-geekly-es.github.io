<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🀄️ 🌞 🚛 Testen von Ethereum Smart Contracts on Go: Auf Wiedersehen, JavaScript 👩‍🔬 🙆🏽 📲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte meinen Kollegen Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich und Igor Titarenko für Konsultationen, Feedback und Tests danken. Ich möchte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von Ethereum Smart Contracts on Go: Auf Wiedersehen, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="Bild"><br>  <em>Ich möchte meinen Kollegen Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich und Igor Titarenko für Konsultationen, Feedback und Tests danken.</em>  <em>Ich möchte mich auch beim PolySwarm-Team für die Entwicklung der Originalversion von Perigord bedanken.</em> <em><br></em> <br>  <em>Dies ist eine Übersetzung meines ersten veröffentlichten mittelenglischen Artikels</em> </p><br><p>  Das Testen war schon immer ein wesentlicher Bestandteil der Softwareentwicklung, wenn auch nicht der unterhaltsamste.  Wenn es um intelligente Verträge geht, sind strenge Tests mit außergewöhnlicher Liebe zum Detail erforderlich  Fehler können nach der Bereitstellung im Blockchain-Netzwerk nicht mehr behoben werden.  In den letzten Jahren hat die Ethereum-Community viele Tools für die Entwicklung intelligenter Verträge entwickelt.  Einige von ihnen wurden nicht populär, zum Beispiel Vyper - ein Python-Dialekt zum Schreiben intelligenter Verträge.  Andere, wie z. B. Solidity, sind zu einem anerkannten Standard geworden.  Die bislang umfangreichste Dokumentation zum Testen intelligenter Verträge enthält eine Reihe von Trüffeln und Ganache.  Beide Tools verfügen über eine gute Dokumentation. In vielen Fällen wurde bereits über Stapelüberlauf und ähnliche Ressourcen entschieden.  Dieser Ansatz hat jedoch einen wichtigen Nachteil: Um Tests zu schreiben, müssen Sie Node.js verwenden. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  JavaScript-Fallen </h4><br><p>  Auch wenn Sie kein Fan von statisch typisierten Programmiersprachen sind und JavaScript lieben, sollten Sie einen Tippfehler machen und das Ergebnis einer Funktion vergleichen, die eine Zeichenfolge mit einem booleschen Wert zurückgibt, indem Sie die veraltete Equal-Methode anstelle von strictEqual verwenden. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Wenn checkProposal die Zeichenfolge "yes" oder "no" zurückgibt, konvertieren Sie sie immer in "true".  Durch dynamisches Tippen werden viele dieser Fallen ausgeblendet, und selbst erfahrene Programmierer können solche Fehler machen, wenn sie an einem großen Projekt oder in einem Team mit anderen Entwicklern arbeiten, die Änderungen am Code vornehmen und ihn nicht melden können. </p><br><p>  Die statische Eingabe von Go hilft, solche Fehler zu vermeiden.  Darüber hinaus ist die Verwendung der Go-Sprache anstelle von Node.js zum Testen der Traum eines jeden Go-Entwicklers, der mit intelligenten Verträgen arbeitet. </p><br><p>  Mein Team entwickelte ein Investitionssystem, das auf intelligenten Verträgen mit einer sehr komplexen Architektur basiert.  Das intelligente Vertragssystem enthielt mehr als 2.000 Codezeilen.  Da der Großteil des Teams aus Go-Entwicklern bestand, war das Testen auf Go Node.js vorzuziehen. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  Die erste Umgebung zum Testen intelligenter Verträge auf Go </h4><br><p>  Im Jahr 2017 entwickelte PolySwarm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perigord</a> , ein Truffle-ähnliches Tool, das Go anstelle von JavaScript verwendet.  Leider wird dieses Projekt nicht mehr unterstützt, es gibt nur ein Tutorial mit sehr einfachen Beispielen.  Darüber hinaus wird die Integration mit Ganache (einer privaten Blockchain zur Entwicklung von Ethereum mit einer sehr praktischen Benutzeroberfläche) nicht unterstützt.  Wir haben Perigord verbessert, indem wir Fehler beseitigt und zwei neue Funktionen eingeführt haben: Generieren von Brieftaschen aus dem Mnemonik-Code und Verwenden dieser zum Testen und Herstellen einer Verbindung mit der Ganache-Blockchain.  Den Quellcode können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. </p><br><p>  Das ursprüngliche Perigord-Tutorial enthält nur das einfachste Beispiel für das Aufrufen eines Vertrags zum Ändern eines einzelnen Werts.  In der realen Welt müssen Sie jedoch auch einen Vertrag aus verschiedenen Geldbörsen anrufen, Ether senden und empfangen usw.  Jetzt können Sie all dies mit dem fortgeschrittenen Perigord und dem guten alten Ganache tun.  Im Folgenden finden Sie detaillierte Anleitungen zum Entwickeln und Testen intelligenter Verträge mit Perigord &amp; Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Verwenden von Advanced Perigord: Eine vollständige Anleitung </h4><br><p>  Um Perigord verwenden zu können, müssen Sie Go 1.7+, solc, abigen und Ganache installieren.  Weitere Informationen finden Sie in der Dokumentation zu Ihrem Betriebssystem. </p><br><p>  Installieren Sie Perigord wie folgt: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Danach können Sie den Befehl perigord verwenden: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Wir werden jetzt einen einfachen Market Smart-Vertrag erstellen, um die verfügbaren Testoptionen zu demonstrieren. </p><br><p>  Geben Sie Folgendes in das Terminal ein, um ein Projekt zu starten: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  Das Projekt wird im Ordner src / in GOPATH angezeigt.  Verschieben Sie das Projekt in einen anderen Ordner und aktualisieren Sie die Importpfade, wenn Sie den Speicherort ändern möchten.  Mal sehen, was sich im Markt / Ordner befindet. </p><br><pre> <code class="plaintext hljs">$ tree . ├── contracts │ └── Foo.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Sehr ähnlich dem in Truffle erstellten Projekt, nicht wahr?  Aber es geht alles los!  Mal sehen, was in der Konfigurationsdatei perigord.yaml enthalten ist. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Zum Testen können Sie sowohl das private Geth-Netzwerk als auch Brieftaschendateien verwenden und eine Verbindung zu Ganache herstellen.  Diese Optionen schließen sich gegenseitig aus.  Wir verwenden die Standard-Mnemonik, generieren 10 Konten und stellen eine Verbindung zu Ganache her.  Ersetzen Sie den Code in perigord.yaml durch: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP http://127.0.0.1:7545</a> - die Standardadresse des Ganache RPC-Servers.  Bitte beachten Sie, dass Sie eine beliebige Anzahl von Konten zum Testen erstellen können, aber nur in der Ganache (GUI) generierte Konten Gelder enthalten. </p><br><p>  Wir werden einen Vertrag namens Market.sol erstellen.  Er kann Aufzeichnungen über Adresspaare führen, von denen einer Geld auf das Vertragskonto sendet und der andere das Recht hat, Geld zu erhalten, wenn der Vertragseigentümer die Erlaubnis für eine solche Transaktion erteilt.  Beispielsweise vertrauen sich zwei Teilnehmer nicht, sondern dem Vertragsinhaber, der entscheidet, ob eine bestimmte Bedingung erfüllt ist.  Das Beispiel implementiert mehrere Grundfunktionen zu Demonstrationszwecken. </p><br><p>  Fügen Sie dem Projekt einen Kontakt hinzu: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  Das Postfix .sol wird automatisch hinzugefügt.  Sie können auch andere Verträge hinzufügen oder den Beispielvertrag Foo.sol löschen.  Während Sie bei GOPATH arbeiten, können Sie Importverträge verwenden, um komplexe Strukturen zu erstellen.  Wir werden drei Solidity-Dateien haben: den Hauptmarktvertrag, die Ownable- und Migrations-Zusatzverträge und die SafeMath-Bibliothek.  Den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Jetzt hat das Projekt folgende Struktur: </p><br><pre> <code class="plaintext hljs">. ├── contracts │ ├── Market.sol │ ├── Ownable.sol │ └── SafeMath.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Generieren Sie EVM-Bytecode-, ABI- und Go-Bindungen: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Fügen Sie die Migrationen aller Verträge hinzu, die Sie bereitstellen möchten.  Weil  Wir stellen nur Market.sol bereit. Wir benötigen nur eine neue Migration: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Unser Vertrag enthält keinen Konstruktor, der Parameter akzeptiert.  Wenn Sie Parameter an den Konstruktor übergeben müssen, fügen Sie sie der Funktion Deploy {NewContract} in der Migrationsdatei hinzu: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), “FOO”, “BAR”)</code> </pre> <br><p>  Löschen Sie die Beispieldatei Foo.go und fügen Sie eine Testdatei für unseren Vertrag hinzu: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Um deterministische Geldbörsen zu verwenden, müssen wir die Mnemonik aus der Konfigurationsdatei lesen: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  Die folgende Hilfsfunktion wird verwendet, um die Netzwerkadresse abzurufen: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Eine weitere Hilfsfunktion, die wir benötigen, ist sendETH. Wir werden sie verwenden, um Ether von einer der generierten Geldbörsen (angezeigt durch den Index) an eine beliebige Ethereum-Adresse zu übertragen: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Die folgenden zwei Funktionen werden zum Ändern eines Vertragsaufrufs verwendet: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Testverfahren </h4><br><p>  Für einen Anruf erstellen wir einen contractSessionActual für einen bestimmten Vertrag.  Weil  Der Vertrag hat einen Eigentümer. Wir können seine Adresse abrufen und prüfen, ob er mit dem Standard-Null-Ganache-Konto übereinstimmt.  Wir werden dies wie folgt tun (wir werden die Fehlerbehandlung weglassen, um Platz zu sparen): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  Die nächste nützliche Funktion ist das Ändern der Brieftasche, die den Vertrag verursacht: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Weil  Eine der Hauptfunktionen beim Testen ist das Ändern des Anrufvertrags. Lassen Sie uns eine Zahlung im Namen des Absenders leisten: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  Der vollständige Testcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Öffnen Sie nun stub_test.go und stellen Sie sicher, dass alle Importe auf Ihr aktuelles Projekt verweisen.  In unserem Fall ist es: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  Führen Sie die Tests aus: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Wenn alles richtig gemacht wurde, gibt es nach dem Ende des Tests ein ähnliches Ergebnis: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Wenn Sie Probleme haben, laden Sie die Quelldateien herunter und wiederholen Sie die in diesem Handbuch beschriebenen Schritte. </p><br><h4 id="v-zaklyuchenie">  Abschließend </h4><br><p>  Perigord ist ein zuverlässiges Testwerkzeug, das in Ihrer Lieblingssprache geschrieben ist.  Er erstellt dieselbe Projektstruktur wie Truffle und hat dieselben Teams, sodass Sie nicht neu lernen müssen.  Durch statische Typisierung und eine eindeutige Funktionssignatur können Sie schnell Debugging entwickeln und durchführen sowie sich erheblich gegen Tippfehler in den Argumenten schützen.  In Perigord können Sie ein vorhandenes Projekt problemlos nach Truffle migrieren (Sie müssen lediglich die Vertragsdateien kopieren und in den entsprechenden Ordner einfügen und Tests hinzufügen) und ein vollständig neues Projekt mit in Go geschriebenen Tests starten. </p><br><p>  Ich hoffe, dass die vom PolySwarm-Team begonnene und von Inn4Science fortgesetzte Arbeit für die Go-Community nützlich und frei von Test- und Debugging-Stunden mit weniger praktischen Tools ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445254/">https://habr.com/ru/post/de445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445242/index.html">Erfahrung mit Coroutinen und Retrofit2</a></li>
<li><a href="../de445244/index.html">"Geldspiele außerhalb der Blockchain müssen sterben"</a></li>
<li><a href="../de445246/index.html">Nicht-Blockchain-Spiele mit Geld müssen sterben</a></li>
<li><a href="../de445248/index.html">Willst du ein bisschen glücklicher sein? Versuchen Sie, der Beste auf Ihrem Gebiet zu sein</a></li>
<li><a href="../de445252/index.html">Digitale Rechte gingen nach Russland</a></li>
<li><a href="../de445256/index.html">Cyberkriminelle kontrollierten ASUS Live Update fünf Monate lang</a></li>
<li><a href="../de445258/index.html">So löschen Sie Ihre Daten sicher von Ihrem Android-Smartphone, bevor Sie sie verkaufen</a></li>
<li><a href="../de445260/index.html">Werden sich Roboter jemals wirklich erkennen? Wissenschaftler bewegen sich in diese Richtung.</a></li>
<li><a href="../de445262/index.html">GeekUniversity eröffnet Rekrutierung in der Big Data-Abteilung für Analytik</a></li>
<li><a href="../de445264/index.html">Preload, Prefetch und andere Tags</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>