<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>  さ La historia de un problema: el recordatorio de JavaScript m谩s corto   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fue por la tarde, en la v铆spera de la conferencia anual HolyJS en San Petersburgo. Nuestra empresa ha sido patrocinador durante varios a帽os: en consec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La historia de un problema: el recordatorio de JavaScript m谩s corto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="imagen"></p><br><p>  Fue por la tarde, en la v铆spera de la conferencia anual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS</a> en San Petersburgo.  Nuestra empresa ha sido patrocinador durante varios a帽os: en consecuencia, tambi茅n tiene su propio stand con interesantes intereses para la mente inquisitiva de los desarrolladores interesados.  Cuando el plato principal estuvo listo y todas las tareas fueron revisadas y completadas por abogados, decid铆 lanzar a mis colegas algo m谩s de comida intelectual por la noche: </p><br><blockquote>  Escriba un recordatorio: una funci贸n de decorador que guarda los resultados de ejecutar una funci贸n ajustada para evitar c谩lculos repetidos.  Tienes solo 50 caracteres. </blockquote><p>  El lenguaje es, por supuesto, <strong>JavaScript</strong> .  La tarea en s铆 es un cl谩sico, pero el l铆mite de 50 caracteres se convirti贸 en un verdadero desaf铆o. </p><br><p>  En los descansos del primer d铆a de la conferencia, discutimos opciones para lograr el objetivo, reduciendo gradualmente la respuesta.  Todo el bombo se coron贸 con la idea de compartir la tarea con todos los participantes de la conferencia, y en el segundo d铆a visualizamos la tarea (ver el ap茅ndice) y comenzamos a distribuir formularios a quienes quisieran.  Como resultado, obtuvimos alrededor de 40 soluciones y una vez m谩s nos convencimos de la extraordinaria comunidad de desarrolladores de js, pero <strong>el</strong> registro de <strong>Dmitry Kataev</strong> (SEMrush) de <strong>53</strong> caracteres permaneci贸.  隆Vamos a resolverlo! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Implementaci贸n habitual </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Resultado: ~ <strong>190</strong> caracteres </p><br><ul><li>  memorizar - nuestro recordatorio </li><li>  f - decorada, funci贸n envuelta </li><li>  ret - funci贸n resultante </li></ul><br><p>  Para obtener la respuesta, el tama帽o de la funci贸n, utilizamos: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Al evaluar el tama帽o de una funci贸n, prestamos atenci贸n a su cuerpo y a una lista de par谩metros.  Si la funci贸n es an贸nima, la declaraci贸n no se tiene en cuenta. </p><br><p>  Pruebas simples para evaluar la salud despu茅s del abuso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  No </th><th>  Llamada a la funci贸n </th><th>  El resultado de la ejecuci贸n en la consola. </th></tr></thead><tbody><tr><td>  1) </td><td> <code>log(false)</code> </td> <td>  &gt; falso </td></tr><tr><td>  2) </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3) </td><td> <code>log(false)</code> </td> <td>  Nada, ya que la funci贸n ya se ha ejecutado para estos valores. </td></tr><tr><td>  4) </td><td> <code>log('2', {x:1})</code> </td> <td>  Nada, ya que la funci贸n ya se ha ejecutado para estos valores. </td></tr><tr><td>  5) </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6) </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  A continuaci贸n, el resultado de cada implementaci贸n estar谩 marcado por el resultado de la prueba. </p><br><h3 id="chistaya-realizaciya">  Implementaci贸n neta </h3><br><p>  En primer lugar, quiero deshacerme de la <em>Declaraci贸n</em> de <em>funciones</em> a favor de la funci贸n de flecha, ya que no estamos interesados en <em>este</em> contexto, no apelamos a <em>argumentos,</em> y como constructores no tenemos la intenci贸n de llamar a <em>nuevos</em> .  Al mismo tiempo, reduciremos los nombres de las variables locales utilizadas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>154</strong> , pruebas aprobadas </p><br><p>  Entonces podemos llevar a cabo una operaci贸n similar con la funci贸n resultante, pero all铆 necesitamos <em>argumentos</em> .  Aqu铆 el <em>operador de propagaci贸n</em> viene al rescate, lo que nos permite reemplazar el objeto iterable pasado de los argumentos con la variable de matriz <em>a</em> .  Adem谩s, ya no pasaremos <em>este</em> contexto a la funci贸n que se est谩 decorando: si es necesario, <em>Function.prototype.bind</em> o nuestro polyfil ayudar谩n. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>127</strong> , pruebas aprobadas </p><br><p>  Ahora pasamos al cuerpo de la funci贸n resultante.  Obviamente, encontrar la clave en el cach茅 y devolver el valor es engorroso.  Intentemos reducir c贸mo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Resultado: <strong>101</strong> , cayeron las pruebas 3 y 4 </p><br><p>  Aqu铆 abandonamos el m茅todo <em>hasOwnProperty</em> .  Podemos permitirlo, porque el resultado de serializar la matriz de argumentos a trav茅s de <em>JSON.stringify</em> siempre ser谩 "[...]" y es poco probable que dicha propiedad <em>aparezca</em> en el cach茅 prototipo ( <em>Object</em> ). </p><br><p>  A continuaci贸n, usamos la funci贸n del operador OR "l贸gico" para devolver la primera expresi贸n si se puede convertir a <em>verdadero</em> , o de lo contrario, la segunda con el c谩lculo de la funci贸n anterior. </p><br><p>  Y aqu铆 caemos las pruebas 3 y 4. Esto sucedi贸 porque la funci贸n decorada <em>console.log</em> no devuelve un valor: el resultado ser谩 <em>indefinido</em> .  Ponemos esto en la memoria cach茅, y cuando intentamos verificar a trav茅s de la funci贸n disyuntor cuando llamamos de nuevo, obtenemos impl铆citamente <em>falso</em> en el primer operando y, en consecuencia, entramos en el segundo, lo que conduce a la llamada a la funci贸n.  Este efecto tendr谩 lugar para todos los resultados reducidos a <em>falso</em> : <em>0, "", nulo, NaN</em> , etc. </p><br><p>  En lugar de OR y <em>if,</em> podemos usar un operador ternario condicional: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>118</strong> , pruebas aprobadas </p><br><p>  Reducido muy ligeramente.  Pero, 驴qu茅 pasa si usa <em>Map</em> como almacenamiento en lugar de un objeto simple?  Tambi茅n hay un m茅todo corto <em>tiene</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Resultado: <strong>121</strong> , pruebas aprobadas </p><br><p>  Reducir completamente fallido.  Pero descartar <em>Map</em> inmediatamente no vale la pena.  Esta implementaci贸n del almacenamiento de valores clave le permite usar objetos como clave.  Y eso significa, 驴deber铆amos renunciar a <em>JSON.stringify</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Resultado: <strong>83</strong> , cayeron las pruebas 3 y 4 </p><br><p>  隆Se ve muy prometedor!  Sin embargo, las pruebas 3 y 4 comenzaron a caer nuevamente, debido a que la comparaci贸n de claves en el objeto <em>Map</em> se implementa utilizando el algoritmo <em>SameValueZero</em> .  Si omite los detalles con <em>NaN, -0</em> y <em>0</em> , entonces funciona de manera similar al <em>operador de comparaci贸n estricto</em> ( <em>===</em> ).  Y tenemos una nueva matriz de argumentos (y, por lo tanto, un objeto) para cada llamada de la funci贸n ajustada, incluso con los mismos valores.  La comparaci贸n se realiza de acuerdo con la referencia del objeto y, por lo tanto, el m茅todo <em>Map.prototype.has</em> nunca encontrar谩 nada. </p><br><p>  Por lo tanto, el uso de <em>Map</em> no nos <em>ha</em> reducido <em>hasOwnProperty</em> o <em>JSON.stringify</em> . </p><br><p>  En <em>operador</em> viene al rescate, que comprueba la presencia de una propiedad en un objeto o en la cadena de sus prototipos.  Por qu茅 no podemos tener miedo de la b煤squeda en prototipos se ha explicado anteriormente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>105</strong> , pruebas aprobadas </p><br><p>  El cuerpo del memorador y la funci贸n resultante consta de dos expresiones con la necesidad de declarar e inicializar una variable local antes de la l贸gica en la <em>declaraci贸n de retorno</em> .  驴Es posible reducir el cuerpo de la funci贸n de flecha a una expresi贸n aqu铆?  Por supuesto, usando el <em>patr贸n IIFE</em> ( <em>expresi贸n de funci贸n invocada inmediatamente</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Resultado: <strong>82</strong> , pruebas aprobadas </p><br><p>  Es hora de deshacerse de los espacios adicionales: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Resultado: <strong>68</strong> , pruebas aprobadas </p><br><p>  Obviamente, el cuello de botella ahora es el largo m茅todo <em>JSON.stringify</em> , que serializa recursivamente el objeto en una cadena JSON, que usamos como clave.  De hecho, no necesitamos una funci贸n de serializaci贸n, sino una funci贸n hash con la que podamos verificar la igualdad de los objetos, ya que funciona en otros idiomas.  Pero, desafortunadamente, no hay una soluci贸n nativa en JavaScript, y el <em>polifilo autoescrito hashCode</em> en el prototipo de <em>Object</em> est谩 claramente m谩s all谩 del alcance. </p><br><p>  Hmm, 驴por qu茅 tenemos que serializarnos?  Al agregar un elemento a un objeto por clave, se llamar谩 impl铆citamente a toString.  Dado que nos negamos a usar el objeto de <em>argumentos</em> iterables a favor de la matriz a trav茅s del <em>operador de propagaci贸n</em> , la llamada <em>aString</em> no ser谩 de <em>Object.prototype</em> , sino de <em>Array.prototype</em> , en el que se redefine y separa por coma sus elementos.  Por lo tanto, para un conjunto diferente de argumentos obtenemos una clave diferente. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Resultado: <strong>44</strong> , cay贸 la prueba 6 </p><br><p>  La prueba 6 est谩 empezando a caer, parece que el valor de retorno es el resultado de una llamada a una funci贸n anterior en la prueba 5. 驴Por qu茅 est谩 sucediendo esto?  S铆, pasamos por alto la llamada a <em>String</em> para el objeto de <em>argumentos</em> , pero no tomamos en cuenta que cualquier argumento tambi茅n puede ser un objeto complejo, llamando a <em>String</em> de donde obtenemos el <em>[objeto Object]</em> favorito de todos.  Esto significa que los argumentos {x: 1} y {x: 2} usar谩n la misma clave en el hash. </p><br><p>  El <em>btoa</em> utilizado para convertir a base64 parec铆a un buen competidor para la funci贸n de serializaci贸n.  Pero 茅l conduce primero a la cuerda, as铆 que no hay posibilidad.  Pensamos en la direcci贸n de generar un URI y formar un <em>ArrayBuffer</em> , cualquier funci贸n para obtener un valor hash o serializado.  Pero se quedaron en su lugar. </p><br><p>  Por cierto, <em>JSON.stringify</em> tiene sus propias peculiaridades: <em>Infinito, NaN, indefinido, S铆mbolo</em> se convertir谩 en <em>nulo</em> .  Lo mismo vale para las funciones.  Si es posible, se produce una llamada impl铆cita a <em>JSON</em> desde el objeto, y <em>Map</em> and <em>Set</em> se representar谩 mediante elementos simplemente enumerados.  Es comprensible, dado el formato final: JSON. </p><br><p>  Que sigue </p><br><h3 id="toksichnaya-dorabotka">  Modificaci贸n t贸xica </h3><br><p>  Ciertamente, todos amamos las funciones puras, pero ante el problema, tal requisito no vale la pena.  Y esto significa que es hora de agregar una pizca de efectos secundarios. </p><br><p>  Primero, 驴por qu茅 no iniciar el cach茅 de la siguiente manera? </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>66</strong> , pruebas aprobadas </p><br><p>  Aqu铆 usamos el <em>par谩metro predeterminado</em> en la funci贸n de flecha.  Por supuesto, le damos al cliente la oportunidad de configurar su cach茅, 驴y qu茅?  Pero redujimos 2 caracteres. </p><br><p>  驴De qu茅 otra forma puedo iniciar un cach茅 para que se decore una funci贸n?  La respuesta correcta: 驴por qu茅 necesitamos iniciarlo?  驴Por qu茅 no usar algo listo en el contexto de una funci贸n para envolver?  Pero, 驴y si la funci贸n en s铆?  Todos sabemos que las funciones en JavaScript tambi茅n son objetos: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>59</strong> , pruebas aprobadas </p><br><p>  Aqu铆 <em>JSON.stringify nos</em> proteger谩 de la intersecci贸n con otras propiedades y m茅todos del objeto (funci贸n), envolviendo los argumentos en "[...]". </p><br><p>  En este mismo momento, el patr贸n <em>IIFE</em> aplicado anteriormente <em>ya</em> no se justifica a s铆 mismo.  Pero es urgente mantener una sola expresi贸n para la funci贸n de flecha para evitar una <em>declaraci贸n de retorno</em> : </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Resultado: <strong>57</strong> , pruebas aprobadas </p><br><p>  Como no usamos la <em>instrucci贸n de bloque</em> en la funci贸n de flecha, no podemos declarar una variable ( <em>var</em> o <em>let</em> ), pero podemos usar el contexto global - 隆efecto secundario!  Aqu铆 el conflicto ya tiene algunas posibilidades de ser. </p><br><p>  Usando el <em>operador de coma,</em> concatenamos dos expresiones en una: los operandos se eval煤an de izquierda a derecha, y el resultado es el valor de este 煤ltimo. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Resultado: <strong>54</strong> , pruebas aprobadas </p><br><p>  Entonces, al reorganizar solo un par茅ntesis, eliminamos tres caracteres a la vez.  <em>El operador de agrupaci贸n</em> al calcular la clave nos permiti贸 combinar ambos operandos de la expresi贸n en una sola expresi贸n, y el corchete de cierre elimin贸 el espacio antes del <em>operador in</em> . </p><br><p>  Y finalmente: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Resultado: <strong>53</strong> , pruebas aprobadas </p><br><p>  驴Por qu茅 no calcular la clave al acceder al valor?  Y luego, el mismo operador ternario y la misma asignaci贸n.  Total: 53 caracteres! </p><br><p>  驴Es posible eliminar los 3 caracteres restantes? </p><br><h3 id="osmyslenie">  Comprensi贸n </h3><br><p>  驴Por qu茅 todo esto?  Esta tarea simple y la cadena posterior de conversiones de lo habitual a lo indecente demuestran un n煤mero considerable de caracter铆sticas del lenguaje JavaScript.  En nuestras discusiones, tocamos cosas como: </p><br><ul><li>  Expresi贸n de la funci贸n de flecha </li><li>  Alcance l茅xico y IIFE </li><li>  Objeto de argumentos tipo matriz </li><li>  Difusi贸n, coma u operadores </li><li>  Operador de comparaci贸n estricto </li><li>  JSON.stringify y toString </li><li>  En operador y hasOwnProperty </li><li>  Operador de agrupaci贸n y declaraci贸n de bloque </li><li>  Objeto del mapa </li><li>  y algo mas </li></ul><br><p>  Tales historias son una buena raz贸n para sumergirse en el estudio de los detalles de un idioma, ayudar a comprenderlo mejor (o viceversa).  Y, por supuesto, 隆solo por diversi贸n! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="imagen"></p><br><p>  <em>En sus aventuras, Rick a menudo tiene que calibrar su arma portal.</em>  <em>El procedimiento lleva tiempo, pero la entrada a menudo se repite.</em>  <em>El cient铆fico est谩 tratando de memorizar los resultados ya obtenidos una vez para no hacer c谩lculos repetidamente, pero el alcoholismo y la senilidad senil afectan fuertemente su memoria.</em>  <em>Le pidi贸 a Morty que mejorara el m贸dulo de configuraci贸n de armas, agregando una funci贸n de memoria.</em>  <em>Esta funci贸n debe guardar los resultados de la funci贸n que se est谩 decorando para evitar c谩lculos repetidos.</em>  <em>Solo Morty tiene p谩nico y teme a las funciones largas.</em>  <em>Ay煤delo a resolver el problema de la manera <strong>m谩s</strong> compacta <strong>posible</strong> .</em>  <em>La funci贸n que se est谩 decorando puede tomar enteros, cadenas, booleanos y objetos como argumentos.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413303/">https://habr.com/ru/post/es413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413287/index.html">DocumentFragment: qu茅 es y c贸mo (no) combatirlo</a></li>
<li><a href="../es413289/index.html">Automatizaci贸n de centros de datos o "rebeli贸n de m谩quinas"</a></li>
<li><a href="../es413291/index.html">El libro "Aprendizaje profundo en Python"</a></li>
<li><a href="../es413293/index.html">Gran 茅xodo de la industria de los videojuegos.</a></li>
<li><a href="../es413297/index.html">Fuentes web variables</a></li>
<li><a href="../es413305/index.html">Bater铆as, Gigafactory, Northvolt y Siemens. Forastero T</a></li>
<li><a href="../es413307/index.html">ESET descubri贸 BackSwap banker utilizando un nuevo m茅todo de manipulaci贸n del navegador</a></li>
<li><a href="../es413309/index.html">Lado oscuro 谩gil</a></li>
<li><a href="../es413311/index.html">Portar su aplicaci贸n web de JavaScript puro a Vue.js</a></li>
<li><a href="../es413315/index.html">Sistema de clima en el apartamento con sus propias manos - parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>