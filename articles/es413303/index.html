<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖤 🙌🏾 🤵🏻 La historia de un problema: el recordatorio de JavaScript más corto 🌇 👇🏼 👆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fue por la tarde, en la víspera de la conferencia anual HolyJS en San Petersburgo. Nuestra empresa ha sido patrocinador durante varios años: en consec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La historia de un problema: el recordatorio de JavaScript más corto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="imagen"></p><br><p>  Fue por la tarde, en la víspera de la conferencia anual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS</a> en San Petersburgo.  Nuestra empresa ha sido patrocinador durante varios años: en consecuencia, también tiene su propio stand con interesantes intereses para la mente inquisitiva de los desarrolladores interesados.  Cuando el plato principal estuvo listo y todas las tareas fueron revisadas y completadas por abogados, decidí lanzar a mis colegas algo más de comida intelectual por la noche: </p><br><blockquote>  Escriba un recordatorio: una función de decorador que guarda los resultados de ejecutar una función ajustada para evitar cálculos repetidos.  Tienes solo 50 caracteres. </blockquote><p>  El lenguaje es, por supuesto, <strong>JavaScript</strong> .  La tarea en sí es un clásico, pero el límite de 50 caracteres se convirtió en un verdadero desafío. </p><br><p>  En los descansos del primer día de la conferencia, discutimos opciones para lograr el objetivo, reduciendo gradualmente la respuesta.  Todo el bombo se coronó con la idea de compartir la tarea con todos los participantes de la conferencia, y en el segundo día visualizamos la tarea (ver el apéndice) y comenzamos a distribuir formularios a quienes quisieran.  Como resultado, obtuvimos alrededor de 40 soluciones y una vez más nos convencimos de la extraordinaria comunidad de desarrolladores de js, pero <strong>el</strong> registro de <strong>Dmitry Kataev</strong> (SEMrush) de <strong>53</strong> caracteres permaneció.  ¡Vamos a resolverlo! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Implementación habitual </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Resultado: ~ <strong>190</strong> caracteres </p><br><ul><li>  memorizar - nuestro recordatorio </li><li>  f - decorada, función envuelta </li><li>  ret - función resultante </li></ul><br><p>  Para obtener la respuesta, el tamaño de la función, utilizamos: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Al evaluar el tamaño de una función, prestamos atención a su cuerpo y a una lista de parámetros.  Si la función es anónima, la declaración no se tiene en cuenta. </p><br><p>  Pruebas simples para evaluar la salud después del abuso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  No </th><th>  Llamada a la función </th><th>  El resultado de la ejecución en la consola. </th></tr></thead><tbody><tr><td>  1) </td><td> <code>log(false)</code> </td> <td>  &gt; falso </td></tr><tr><td>  2) </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3) </td><td> <code>log(false)</code> </td> <td>  Nada, ya que la función ya se ha ejecutado para estos valores. </td></tr><tr><td>  4) </td><td> <code>log('2', {x:1})</code> </td> <td>  Nada, ya que la función ya se ha ejecutado para estos valores. </td></tr><tr><td>  5) </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6) </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  A continuación, el resultado de cada implementación estará marcado por el resultado de la prueba. </p><br><h3 id="chistaya-realizaciya">  Implementación neta </h3><br><p>  En primer lugar, quiero deshacerme de la <em>Declaración</em> de <em>funciones</em> a favor de la función de flecha, ya que no estamos interesados ​​en <em>este</em> contexto, no apelamos a <em>argumentos,</em> y como constructores no tenemos la intención de llamar a <em>nuevos</em> .  Al mismo tiempo, reduciremos los nombres de las variables locales utilizadas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>154</strong> , pruebas aprobadas </p><br><p>  Entonces podemos llevar a cabo una operación similar con la función resultante, pero allí necesitamos <em>argumentos</em> .  Aquí el <em>operador de propagación</em> viene al rescate, lo que nos permite reemplazar el objeto iterable pasado de los argumentos con la variable de matriz <em>a</em> .  Además, ya no pasaremos <em>este</em> contexto a la función que se está decorando: si es necesario, <em>Function.prototype.bind</em> o nuestro polyfil ayudarán. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>127</strong> , pruebas aprobadas </p><br><p>  Ahora pasamos al cuerpo de la función resultante.  Obviamente, encontrar la clave en el caché y devolver el valor es engorroso.  Intentemos reducir cómo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Resultado: <strong>101</strong> , cayeron las pruebas 3 y 4 </p><br><p>  Aquí abandonamos el método <em>hasOwnProperty</em> .  Podemos permitirlo, porque el resultado de serializar la matriz de argumentos a través de <em>JSON.stringify</em> siempre será "[...]" y es poco probable que dicha propiedad <em>aparezca</em> en el caché prototipo ( <em>Object</em> ). </p><br><p>  A continuación, usamos la función del operador OR "lógico" para devolver la primera expresión si se puede convertir a <em>verdadero</em> , o de lo contrario, la segunda con el cálculo de la función anterior. </p><br><p>  Y aquí caemos las pruebas 3 y 4. Esto sucedió porque la función decorada <em>console.log</em> no devuelve un valor: el resultado será <em>indefinido</em> .  Ponemos esto en la memoria caché, y cuando intentamos verificar a través de la función disyuntor cuando llamamos de nuevo, obtenemos implícitamente <em>falso</em> en el primer operando y, en consecuencia, entramos en el segundo, lo que conduce a la llamada a la función.  Este efecto tendrá lugar para todos los resultados reducidos a <em>falso</em> : <em>0, "", nulo, NaN</em> , etc. </p><br><p>  En lugar de OR y <em>if,</em> podemos usar un operador ternario condicional: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>118</strong> , pruebas aprobadas </p><br><p>  Reducido muy ligeramente.  Pero, ¿qué pasa si usa <em>Map</em> como almacenamiento en lugar de un objeto simple?  También hay un método corto <em>tiene</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Resultado: <strong>121</strong> , pruebas aprobadas </p><br><p>  Reducir completamente fallido.  Pero descartar <em>Map</em> inmediatamente no vale la pena.  Esta implementación del almacenamiento de valores clave le permite usar objetos como clave.  Y eso significa, ¿deberíamos renunciar a <em>JSON.stringify</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Resultado: <strong>83</strong> , cayeron las pruebas 3 y 4 </p><br><p>  ¡Se ve muy prometedor!  Sin embargo, las pruebas 3 y 4 comenzaron a caer nuevamente, debido a que la comparación de claves en el objeto <em>Map</em> se implementa utilizando el algoritmo <em>SameValueZero</em> .  Si omite los detalles con <em>NaN, -0</em> y <em>0</em> , entonces funciona de manera similar al <em>operador de comparación estricto</em> ( <em>===</em> ).  Y tenemos una nueva matriz de argumentos (y, por lo tanto, un objeto) para cada llamada de la función ajustada, incluso con los mismos valores.  La comparación se realiza de acuerdo con la referencia del objeto y, por lo tanto, el método <em>Map.prototype.has</em> nunca encontrará nada. </p><br><p>  Por lo tanto, el uso de <em>Map</em> no nos <em>ha</em> reducido <em>hasOwnProperty</em> o <em>JSON.stringify</em> . </p><br><p>  En <em>operador</em> viene al rescate, que comprueba la presencia de una propiedad en un objeto o en la cadena de sus prototipos.  Por qué no podemos tener miedo de la búsqueda en prototipos se ha explicado anteriormente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>105</strong> , pruebas aprobadas </p><br><p>  El cuerpo del memorador y la función resultante consta de dos expresiones con la necesidad de declarar e inicializar una variable local antes de la lógica en la <em>declaración de retorno</em> .  ¿Es posible reducir el cuerpo de la función de flecha a una expresión aquí?  Por supuesto, usando el <em>patrón IIFE</em> ( <em>expresión de función invocada inmediatamente</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Resultado: <strong>82</strong> , pruebas aprobadas </p><br><p>  Es hora de deshacerse de los espacios adicionales: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Resultado: <strong>68</strong> , pruebas aprobadas </p><br><p>  Obviamente, el cuello de botella ahora es el largo método <em>JSON.stringify</em> , que serializa recursivamente el objeto en una cadena JSON, que usamos como clave.  De hecho, no necesitamos una función de serialización, sino una función hash con la que podamos verificar la igualdad de los objetos, ya que funciona en otros idiomas.  Pero, desafortunadamente, no hay una solución nativa en JavaScript, y el <em>polifilo autoescrito hashCode</em> en el prototipo de <em>Object</em> está claramente más allá del alcance. </p><br><p>  Hmm, ¿por qué tenemos que serializarnos?  Al agregar un elemento a un objeto por clave, se llamará implícitamente a toString.  Dado que nos negamos a usar el objeto de <em>argumentos</em> iterables a favor de la matriz a través del <em>operador de propagación</em> , la llamada <em>aString</em> no será de <em>Object.prototype</em> , sino de <em>Array.prototype</em> , en el que se redefine y separa por coma sus elementos.  Por lo tanto, para un conjunto diferente de argumentos obtenemos una clave diferente. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Resultado: <strong>44</strong> , cayó la prueba 6 </p><br><p>  La prueba 6 está empezando a caer, parece que el valor de retorno es el resultado de una llamada a una función anterior en la prueba 5. ¿Por qué está sucediendo esto?  Sí, pasamos por alto la llamada a <em>String</em> para el objeto de <em>argumentos</em> , pero no tomamos en cuenta que cualquier argumento también puede ser un objeto complejo, llamando a <em>String</em> de donde obtenemos el <em>[objeto Object]</em> favorito de todos.  Esto significa que los argumentos {x: 1} y {x: 2} usarán la misma clave en el hash. </p><br><p>  El <em>btoa</em> utilizado para convertir a base64 parecía un buen competidor para la función de serialización.  Pero él conduce primero a la cuerda, así que no hay posibilidad.  Pensamos en la dirección de generar un URI y formar un <em>ArrayBuffer</em> , cualquier función para obtener un valor hash o serializado.  Pero se quedaron en su lugar. </p><br><p>  Por cierto, <em>JSON.stringify</em> tiene sus propias peculiaridades: <em>Infinito, NaN, indefinido, Símbolo</em> se convertirá en <em>nulo</em> .  Lo mismo vale para las funciones.  Si es posible, se produce una llamada implícita a <em>JSON</em> desde el objeto, y <em>Map</em> and <em>Set</em> se representará mediante elementos simplemente enumerados.  Es comprensible, dado el formato final: JSON. </p><br><p>  Que sigue </p><br><h3 id="toksichnaya-dorabotka">  Modificación tóxica </h3><br><p>  Ciertamente, todos amamos las funciones puras, pero ante el problema, tal requisito no vale la pena.  Y esto significa que es hora de agregar una pizca de efectos secundarios. </p><br><p>  Primero, ¿por qué no iniciar el caché de la siguiente manera? </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>66</strong> , pruebas aprobadas </p><br><p>  Aquí usamos el <em>parámetro predeterminado</em> en la función de flecha.  Por supuesto, le damos al cliente la oportunidad de configurar su caché, ¿y qué?  Pero redujimos 2 caracteres. </p><br><p>  ¿De qué otra forma puedo iniciar un caché para que se decore una función?  La respuesta correcta: ¿por qué necesitamos iniciarlo?  ¿Por qué no usar algo listo en el contexto de una función para envolver?  Pero, ¿y si la función en sí?  Todos sabemos que las funciones en JavaScript también son objetos: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>59</strong> , pruebas aprobadas </p><br><p>  Aquí <em>JSON.stringify nos</em> protegerá de la intersección con otras propiedades y métodos del objeto (función), envolviendo los argumentos en "[...]". </p><br><p>  En este mismo momento, el patrón <em>IIFE</em> aplicado anteriormente <em>ya</em> no se justifica a sí mismo.  Pero es urgente mantener una sola expresión para la función de flecha para evitar una <em>declaración de retorno</em> : </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Resultado: <strong>57</strong> , pruebas aprobadas </p><br><p>  Como no usamos la <em>instrucción de bloque</em> en la función de flecha, no podemos declarar una variable ( <em>var</em> o <em>let</em> ), pero podemos usar el contexto global - ¡efecto secundario!  Aquí el conflicto ya tiene algunas posibilidades de ser. </p><br><p>  Usando el <em>operador de coma,</em> concatenamos dos expresiones en una: los operandos se evalúan de izquierda a derecha, y el resultado es el valor de este último. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Resultado: <strong>54</strong> , pruebas aprobadas </p><br><p>  Entonces, al reorganizar solo un paréntesis, eliminamos tres caracteres a la vez.  <em>El operador de agrupación</em> al calcular la clave nos permitió combinar ambos operandos de la expresión en una sola expresión, y el corchete de cierre eliminó el espacio antes del <em>operador in</em> . </p><br><p>  Y finalmente: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Resultado: <strong>53</strong> , pruebas aprobadas </p><br><p>  ¿Por qué no calcular la clave al acceder al valor?  Y luego, el mismo operador ternario y la misma asignación.  Total: 53 caracteres! </p><br><p>  ¿Es posible eliminar los 3 caracteres restantes? </p><br><h3 id="osmyslenie">  Comprensión </h3><br><p>  ¿Por qué todo esto?  Esta tarea simple y la cadena posterior de conversiones de lo habitual a lo indecente demuestran un número considerable de características del lenguaje JavaScript.  En nuestras discusiones, tocamos cosas como: </p><br><ul><li>  Expresión de la función de flecha </li><li>  Alcance léxico y IIFE </li><li>  Objeto de argumentos tipo matriz </li><li>  Difusión, coma u operadores </li><li>  Operador de comparación estricto </li><li>  JSON.stringify y toString </li><li>  En operador y hasOwnProperty </li><li>  Operador de agrupación y declaración de bloque </li><li>  Objeto del mapa </li><li>  y algo mas </li></ul><br><p>  Tales historias son una buena razón para sumergirse en el estudio de los detalles de un idioma, ayudar a comprenderlo mejor (o viceversa).  Y, por supuesto, ¡solo por diversión! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="imagen"></p><br><p>  <em>En sus aventuras, Rick a menudo tiene que calibrar su arma portal.</em>  <em>El procedimiento lleva tiempo, pero la entrada a menudo se repite.</em>  <em>El científico está tratando de memorizar los resultados ya obtenidos una vez para no hacer cálculos repetidamente, pero el alcoholismo y la senilidad senil afectan fuertemente su memoria.</em>  <em>Le pidió a Morty que mejorara el módulo de configuración de armas, agregando una función de memoria.</em>  <em>Esta función debe guardar los resultados de la función que se está decorando para evitar cálculos repetidos.</em>  <em>Solo Morty tiene pánico y teme a las funciones largas.</em>  <em>Ayúdelo a resolver el problema de la manera <strong>más</strong> compacta <strong>posible</strong> .</em>  <em>La función que se está decorando puede tomar enteros, cadenas, booleanos y objetos como argumentos.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413303/">https://habr.com/ru/post/es413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413287/index.html">DocumentFragment: qué es y cómo (no) combatirlo</a></li>
<li><a href="../es413289/index.html">Automatización de centros de datos o "rebelión de máquinas"</a></li>
<li><a href="../es413291/index.html">El libro "Aprendizaje profundo en Python"</a></li>
<li><a href="../es413293/index.html">Gran éxodo de la industria de los videojuegos.</a></li>
<li><a href="../es413297/index.html">Fuentes web variables</a></li>
<li><a href="../es413305/index.html">Baterías, Gigafactory, Northvolt y Siemens. Forastero T</a></li>
<li><a href="../es413307/index.html">ESET descubrió BackSwap banker utilizando un nuevo método de manipulación del navegador</a></li>
<li><a href="../es413309/index.html">Lado oscuro ágil</a></li>
<li><a href="../es413311/index.html">Portar su aplicación web de JavaScript puro a Vue.js</a></li>
<li><a href="../es413315/index.html">Sistema de clima en el apartamento con sus propias manos - parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>