<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💑 🚽 🐨 Pemikiran fungsional. Bagian 9 💠 👂🏿 🥒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini sudah merupakan bagian 9 dari serangkaian artikel tentang pemrograman fungsional dalam F #! Saya yakin bahwa di Habré tidak banyak siklus yang pan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran fungsional. Bagian 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p>  Ini sudah merupakan bagian 9 dari serangkaian artikel tentang pemrograman fungsional dalam F #!  Saya yakin bahwa di Habré tidak banyak siklus yang panjang.  Tapi kita tidak akan berhenti.  Hari ini kita akan berbicara tentang fungsi bersarang, modul, ruang nama, dan pencampuran tipe dan fungsi dalam modul. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketiga</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keempat</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kelima</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keenam</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketujuh</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedelapan</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Sekarang Anda tahu cara mendefinisikan fungsi, tetapi bagaimana mengaturnya? </p><br><p>  F # memiliki tiga opsi: </p><br><ul><li>  fungsi dapat disarangkan di fungsi lainnya. </li><li>  pada level aplikasi, fungsi level atas dikelompokkan menjadi “modul”. </li><li>  atau Anda dapat mengikuti pendekatan berorientasi objek dan melampirkan fungsi ke tipe sebagai metode. </li></ul><br><p>  Dalam artikel ini, kami akan mempertimbangkan dua metode pertama, dan yang tersisa di metode berikutnya. </p><br><h2>  Fungsi Bersarang </h2><br><p>  Di F #, Anda dapat menentukan fungsi di dalam fungsi lain.  Ini adalah cara yang baik untuk merangkum fungsi tambahan yang hanya diperlukan untuk fungsi utama dan tidak boleh terlihat dari luar. </p><br><p> Pada contoh di bawah ini, <code>add</code> bersarang di <code>addThreeNumbers</code> : </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p>  Fungsi bersarang dapat mengakses parameter induk secara langsung, karena berada dalam cakupannya. <br>  Jadi, dalam contoh di bawah ini, fungsi bersarang <code>printError</code> tidak perlu parameter, karena  dia dapat mengakses dan <code>max</code> secara langsung. </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p>  Pola yang sangat umum adalah fungsi utama yang mendefinisikan fungsi pembantu rekursif bersarang, yang disebut dengan nilai awal yang sesuai. <br>  Berikut ini adalah contoh kode tersebut: </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p>  Cobalah untuk menghindari sarang yang dalam, terutama dalam kasus akses langsung (bukan dalam bentuk parameter) ke variabel induk. <br>  Fungsi bersarang terlalu dalam akan sulit untuk dipahami sebagai yang terburuk dari banyak cabang imperatif bersarang. </p><br><p>  Contoh cara <em>tidak</em> melakukan: </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2>  Modul </h2><br><p>  Modul hanyalah kumpulan fungsi yang dikelompokkan bersama, biasanya karena mereka bekerja dengan tipe data yang sama. </p><br><p>  Definisi modul sangat mirip dengan definisi fungsi.  Dimulai dengan kata kunci <code>module</code> , kemudian muncul tanda <code>=</code> , diikuti oleh isi modul. <br>  Isi modul <em>harus</em> diformat dengan offset, serta ekspresi dalam definisi fungsi. </p><br><p>  Definisi modul yang berisi dua fungsi: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Jika Anda membuka kode ini di Visual Studio, maka ketika Anda mengarahkan kursor ke <code>add</code> Anda bisa melihat nama lengkap <code>add</code> , yang sebenarnya adalah <code>MathStuff.add</code> , seolah-olah <code>MastStuff</code> adalah kelas, dan <code>add</code> adalah metode. </p><br><p>  Sebenarnya, inilah yang sebenarnya terjadi.  Di belakang layar, kompiler F # menciptakan kelas statis dengan metode statis.  Setara C # akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p>  Mengakui bahwa modul hanyalah kelas statis dan fungsi adalah metode statis akan memberikan pemahaman yang baik tentang bagaimana modul bekerja di F #, karena sebagian besar aturan yang berlaku untuk kelas statis juga berlaku untuk modul. </p><br><p>  Dan seperti dalam C #, setiap fungsi yang berdiri sendiri harus menjadi bagian dari kelas, dalam F #, setiap fungsi yang berdiri sendiri <em>harus</em> menjadi bagian dari modul. </p><br><h3>  Akses ke fungsi di luar modul </h3><br><p>  Jika Anda perlu mengakses suatu fungsi dari modul lain, Anda dapat merujuknya melalui nama lengkapnya. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p>  Anda juga dapat mengimpor semua fungsi modul lain menggunakan arahan <code>open</code> , setelah itu Anda dapat menggunakan nama pendek dan bukan nama lengkap. </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p>  Aturan untuk menggunakan nama sangat diharapkan.  Anda selalu dapat mengakses fungsi dengan nama lengkapnya, atau Anda dapat menggunakan nama relatif atau tidak lengkap tergantung pada ruang lingkup saat ini. </p><br><h3>  Modul Bersarang </h3><br><p>  Seperti kelas statis, modul dapat berisi modul bersarang: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Modul lain dapat merujuk ke fungsi dalam modul bersarang menggunakan nama lengkap atau relatif, yang sesuai: </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3>  Modul tingkat atas </h3><br><p>  Dengan demikian, karena modul dapat disarangkan, oleh karena itu, naik rantai, Anda dapat mencapai beberapa modul induk dari tingkat atas.  Memang benar. </p><br><p>  Modul tingkat atas didefinisikan secara berbeda, tidak seperti modul yang ditunjukkan sebelumnya. </p><br><ul><li>  Baris <code>module MyModuleName</code> <em>harus</em> merupakan deklarasi pertama dalam file </li><li>  Tanda <code>=</code> hilang </li><li>  Konten modul <em>tidak</em> boleh diindentasi </li></ul><br><p>  Secara umum, deklarasi "tingkat atas" harus ada di setiap file <code>.FS</code> sumber.  Ada beberapa pengecualian, tetapi ini masih merupakan praktik yang baik.  Nama modul tidak harus cocok dengan nama file, tetapi dua file tidak dapat berisi modul dengan nama yang sama. </p><br><p>  Untuk file <code>.FSX</code> , deklarasi modul tidak diperlukan, dalam hal ini nama file skrip secara otomatis menjadi nama modul. </p><br><p>  Contoh dari <code>MathStuff</code> dideklarasikan sebagai modul "modul teratas": </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Perhatikan bahwa tidak ada lekukan dalam kode "tingkat atas" ( <code>module MathStuff</code> ), sedangkan isi modul <code>FloatLib</code> bersarang masih harus diindentasi. </p><br><h3>  Isi modul lainnya </h3><br><p>  Selain fungsi, modul dapat berisi deklarasi lain, seperti deklarasi tipe, nilai sederhana, dan kode inisialisasi (misalnya, konstruktor statis) </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p>  Ngomong-ngomong, jika Anda menjalankan contoh-contoh ini secara interaktif, Anda mungkin perlu memulai kembali sesi cukup sering sehingga kode tetap "segar" dan tidak terinfeksi oleh perhitungan sebelumnya. </p><br><h3>  Penyembunyian (Tumpang tindih, Membayangi) </h3><br><p>  Ini lagi modul sampel kami.  Perhatikan bahwa <code>MathStuff</code> berisi fungsi <code>add</code> <em>serta</em> <code>FloatLib</code> . </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Apa yang terjadi jika Anda membuka <em>kedua</em> modul dalam ruang lingkup saat ini dan panggilan <code>add</code> ? </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p>  Dan kebetulan modul <code>MathStuff.FloatLib</code> mendefinisikan kembali <code>MathStuff</code> asli, yang diblokir (disembunyikan) oleh modul <code>FloatLib</code> . </p><br><p>  Akibatnya, kami mendapatkan kesalahan kompiler FS0001, karena parameter pertama <code>1</code> diharapkan sebagai float.  Untuk memperbaikinya, Anda harus mengubah <code>1</code> ke <code>1.0</code> . </p><br><p>  Sayangnya, dalam praktiknya ini <em>diam</em> - <em>diam</em> dan mudah diabaikan.  Terkadang menggunakan teknik ini Anda dapat melakukan trik-trik menarik, hampir seperti subclass, tetapi paling sering keberadaan fungsi dengan nama yang sama mengganggu (misalnya, dalam kasus fungsi <code>map</code> sangat umum). </p><br><p>  Jika Anda ingin menghindari perilaku ini, ada cara untuk menghentikannya dengan atribut <code>RequireQualifiedAccess</code> .  Contoh yang sama di mana kedua modul didekorasi dengan atribut ini: </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Sekarang arahan <code>open</code> tidak tersedia: </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p>  Tetapi Anda masih dapat mengakses fungsi (tanpa ambiguitas) melalui nama lengkapnya: </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3>  Kontrol akses </h3><br><p>  F # mendukung penggunaan operator kontrol akses .NET standar seperti <code>public</code> , <code>private</code> dan <code>internal</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel MSDN</a> berisi informasi lengkap. </p><br><ul><li>  Penentu akses ini dapat diterapkan pada fungsi, nilai, tipe, dan deklarasi tingkat atas ("biarkan terikat") lainnya dalam modul.  Mereka juga dapat ditentukan untuk modul itu sendiri (misalnya, modul bersarang pribadi mungkin diperlukan). </li><li>  Secara default, semuanya memiliki akses publik (dengan pengecualian beberapa kasus), jadi untuk melindunginya Anda harus menggunakan <code>private</code> atau <code>internal</code> . </li></ul><br><p>  Penentu akses ini hanyalah salah satu cara untuk mengontrol visibilitas di F #.  Cara yang sama sekali berbeda adalah dengan menggunakan file tanda tangan yang menyerupai file header C. Mereka secara abstrak menggambarkan isi modul.  Tanda tangan sangat berguna untuk enkapsulasi serius, tetapi untuk mempertimbangkan kemampuannya Anda harus menunggu seri yang direncanakan tentang enkapsulasi dan <em>keamanan berdasarkan pada kemampuan</em> . </p><br><h2>  Ruang nama </h2><br><p>  Ruang nama di F # mirip dengan ruang nama dari C #.  Mereka dapat digunakan untuk mengatur modul dan tipe untuk menghindari konflik nama. </p><br><p>  Namespace dideklarasikan menggunakan kata kunci <code>namespace</code> : </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Karena namespace ini, nama lengkap modul <code>MathStuff</code> menjadi <code>Utilities.MathStuff</code> , dan nama lengkapnya adalah <code>Utilities.MathStuff.add</code> . </p><br><p>  Aturan indentasi yang sama berlaku untuk modul dalam ruang nama yang ditunjukkan di atas untuk modul. </p><br><p>  Anda juga dapat mendeklarasikan namespace secara eksplisit dengan menambahkan periode pada nama modul.  Yaitu  Kode di atas dapat ditulis ulang seperti ini: </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Nama lengkap modul <code>MathStuff</code> masih <code>Utilities.MathStuff</code> , tetapi sekarang ini adalah modul tingkat atas dan isinya tidak perlu lekukan. </p><br><p>  Beberapa fitur tambahan untuk menggunakan ruang nama: </p><br><ul><li>  Ruang nama adalah opsional untuk modul.  Tidak seperti C #, untuk proyek F # tidak ada namespace default, jadi modul tingkat atas tanpa namespace akan bersifat global.  Jika Anda berencana membuat pustaka yang dapat digunakan kembali, Anda harus menambahkan beberapa ruang nama untuk menghindari konflik dengan kode pustaka lain. </li><li>  Namespaces dapat secara langsung mengandung deklarasi tipe, tetapi bukan deklarasi fungsi.  Seperti disebutkan sebelumnya, semua deklarasi fungsi dan nilai harus menjadi bagian dari modul. </li><li>  Akhirnya, ingatlah bahwa ruang nama tidak berfungsi dalam skrip.  Misalnya, jika Anda mencoba mengirim deklarasi namespace, seperti <code>namespace Utilities</code> , ke jendela interaktif, kesalahan diterima. </li></ul><br><h3>  Hirarki Namespace </h3><br><p>  Anda dapat membangun hierarki ruang nama dengan hanya membagi nama dengan titik-titik: </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p>  Anda juga dapat mendeklarasikan <em>dua</em> ruang nama dalam satu file jika Anda mau.  Perlu dicatat bahwa semua ruang nama <em>harus</em> dideklarasikan dengan nama lengkap mereka - mereka tidak mendukung bersarang. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p>  Konflik nama antara namespace dan modul tidak dimungkinkan. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2>  Mencampur jenis dan fungsi dalam modul </h2><br><p>  Seperti yang telah kita lihat, modul biasanya terdiri dari banyak fungsi yang saling tergantung yang berinteraksi dengan tipe data tertentu. </p><br><p>  Dalam OOP, struktur data dan fungsi di atasnya akan digabungkan bersama dalam kelas.  Dan dalam F # fungsional, struktur data dan fungsi di atas mereka digabungkan menjadi sebuah modul. </p><br><p>  Ada dua pola untuk menggabungkan jenis dan fungsi bersama: </p><br><ul><li>  tipe dideklarasikan secara terpisah dari fungsi </li><li>  tipe dideklarasikan dalam modul yang sama dengan fungsi </li></ul><br><p>  Dalam kasus pertama, tipe dideklarasikan di <em>luar</em> modul apa pun (tetapi di namespace), setelah itu fungsi yang bekerja dengan tipe ini ditempatkan dalam modul dengan tipe yang sama. </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p>  Atau, jenisnya dideklarasikan <em>di dalam</em> modul dan memiliki nama sederhana seperti " <code>T</code> " atau nama modul.  Akses ke fungsi kira-kira sebagai berikut: <code>MyModule.Func</code> dan <code>MyModule.Func2</code> , dan akses ke jenis: <code>MyModule.T</code> : </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p>  Perhatikan bahwa dalam kedua kasus harus ada fungsi konstruktor yang membuat instance baru dari jenis (pabrik).  Kemudian, dalam kode klien, Anda tidak perlu mengakses nama jenis secara eksplisit, dan Anda tidak perlu bertanya-tanya apakah jenisnya ada di dalam modul atau tidak. </p><br><p>  Jadi, cara mana yang harus dipilih? </p><br><ul><li>  Pendekatan pertama lebih seperti .NET klasik, dan harus lebih disukai jika Anda berencana untuk menggunakan perpustakaan ini untuk kode di luar F #, di mana kelas yang ada secara terpisah diharapkan. </li><li>  Pendekatan kedua lebih umum dalam bahasa fungsional lainnya.  Jenis di dalam modul dikompilasi sebagai kelas bersarang, yang biasanya tidak nyaman untuk bahasa OOP. </li></ul><br><p>  Untuk diri sendiri, Anda dapat bereksperimen dengan kedua metode ini.  Dalam hal pengembangan tim, satu gaya harus dipilih. </p><br><h3>  Modul yang hanya berisi tipe </h3><br><p>  Jika ada banyak jenis yang perlu dideklarasikan tanpa fungsi apa pun, jangan repot-repot menggunakan modul.  Anda bisa mendeklarasikan tipe secara langsung di namespace tanpa menggunakan kelas bersarang. </p><br><p>  Misalnya, Anda mungkin ingin melakukan ini: </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p>  Dan di sini ada cara lain untuk melakukan hal yang sama.  <code>module</code> kata hanya diganti dengan kata <code>namespace</code> . </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p>  Dalam kedua kasus, <code>PersonType</code> akan memiliki nama lengkap yang sama. </p><br><p>  Harap dicatat bahwa penggantian ini hanya berfungsi dengan jenis.  Fungsi harus <strong>selalu</strong> dinyatakan di dalam modul. </p><br><h1>  Sumber Daya Tambahan </h1><br><p>  Ada banyak tutorial untuk F #, termasuk materi untuk mereka yang datang dengan pengalaman C # atau Java.  Tautan berikut mungkin berguna saat Anda masuk lebih dalam ke F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk Kesenangan dan Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar X dalam Y Menit: F #</a> </li></ul><br><p>  Beberapa cara lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mulai belajar F #</a> juga dijelaskan. </p><br><p>  Akhirnya, komunitas F # sangat ramah pemula.  Ada obrolan yang sangat aktif di Slack, didukung oleh F # Software Foundation, dengan kamar pemula yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung dengan bebas</a> .  Kami sangat menyarankan Anda melakukan ini! </p><br><p>  Jangan lupa untuk mengunjungi situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas berbahasa Rusia F #</a> !  Jika Anda memiliki pertanyaan tentang belajar bahasa, dengan senang hati kami akan membahasnya di ruang obrolan: </p><br><ul><li>  kamar <code>#ru_general</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol di Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol dalam gitter</a> </li><li>  kamar #en_general di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Tentang penulis terjemahan </h2><br><p>  Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Perubahan terjemahan dan editorial dilakukan oleh upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas pengembang F # berbahasa Rusia</a> .  Kami juga berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@schvepsss</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@shwars</em></a> karena telah menyiapkan artikel ini untuk dipublikasikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433406/">https://habr.com/ru/post/id433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433396/index.html">Frontend 2018: hasil tahun ini</a></li>
<li><a href="../id433398/index.html">Pemikiran fungsional. Bagian 7</a></li>
<li><a href="../id433400/index.html">React Tutorial Bagian 2: Komponen Fungsional</a></li>
<li><a href="../id433402/index.html">Pemikiran fungsional. Bagian 8</a></li>
<li><a href="../id433404/index.html">Bereaksi Tutorial Bagian 3: File Komponen, Struktur Proyek</a></li>
<li><a href="../id433408/index.html">Penanganan memori yang efisien di Node.js</a></li>
<li><a href="../id433410/index.html">Pemikiran fungsional. Bagian 10</a></li>
<li><a href="../id433412/index.html">Pemikiran fungsional. Bagian 11: Final</a></li>
<li><a href="../id433414/index.html">Menguji Monitor Jaringan PRTG dan membandingkannya dengan Zabbix</a></li>
<li><a href="../id433420/index.html">Hasil ZeroNights 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>