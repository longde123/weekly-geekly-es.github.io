<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 ➖ 💜 Mengelola Rahasia dengan HashiCorp Vault 👩🏽‍🤝‍👩🏼 ↔️ 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara menyimpan rahasia? Di repositori, di sistem penyebaran atau di sistem manajemen konfigurasi? Di komputer pribadi, di server, atau mungk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengelola Rahasia dengan HashiCorp Vault</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/438740/">  Bagaimana cara menyimpan rahasia?  Di repositori, di sistem penyebaran atau di sistem manajemen konfigurasi?  Di komputer pribadi, di server, atau mungkin di dalam kotak di bawah tempat tidur?  Dan bagaimana mengelola rahasia untuk mencegah kebocoran? <br><br>  <strong>Sergey Noskov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Albibek</a> ) - kepala kelompok keamanan informasi platform dari Avito</strong> , mengetahui jawaban atas pertanyaan-pertanyaan ini dan akan berbagi dengan kami.  Di Avito, HashiCorp Vault telah aktif menggunakan HashiCorp Vault selama dua tahun, di mana saat itu mereka mendapatkan tonjolan dan memompa pengalaman ke level "Master". <br><br>  Dalam artikel ini kita akan berbicara secara komprehensif tentang Vault: apa itu, di mana dan bagaimana itu digunakan di perusahaan, bagaimana Avito mengelola rahasia menggunakan HashiCorp Vault, bagaimana Wayang dan Kubernet digunakan, menggunakan kasing dengan Wayang dan SCM lainnya, masalah apa yang muncul, apa yang mengganggu keamanan dan pengembang, dan, tentu saja, berbagi gagasan tentang cara memperbaikinya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDdDPU6moTs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><h2>  Apa itu rahasia? </h2><br>  Setiap informasi rahasia: <br><br><ul><li>  login dan kata sandi, misalnya, ke basis data; </li><li>  Kunci API </li><li>  Kunci Sertifikat Server (* .google.com) </li><li>  kunci sertifikat klien (mitra, uang Yandex, QIWI); </li><li>  kunci untuk menandatangani aplikasi seluler. </li></ul><br>  Semua informasi yang kami ingin rahasiakan, kami sebut rahasia.  Ini menciptakan masalah penyimpanan: menyimpan di repositori buruk, dalam bentuk terenkripsi - Anda perlu menyimpan kunci enkripsi di suatu tempat. <br><br>  <strong>HashiCorp Vault</strong> adalah salah satu solusi bagus untuk masalah ini. <br><br><ul><li>  Secara aman menyimpan dan mengelola kunci. </li><li>  Dipertajam di dunia layanan-mikro, karena layanan-mikro itu sendiri. </li><li>  <strong>HashiCorp Vault</strong> telah melakukan banyak hal untuk mengotentikasi dan mengotorisasi akses ke rahasia, seperti ACL dan prinsip hak minimum. </li><li>  SISA antarmuka dengan JSON. </li><li>  Keamanan tidak sempurna, tetapi pada tingkat yang cukup tinggi. </li></ul><br>  Menurut pendapat saya, ini adalah alat yang cukup nyaman. <br><br><h2>  Apa yang Baru di Gudang HashiCorp <br></h2><br>  Alat ini berkembang dan dalam beberapa tahun terakhir banyak fitur menarik telah muncul di dalamnya: header CORS untuk GUI tanpa perantara;  GUI bawaan;  integrasi asli dengan Kubernetes;  plugin untuk backend logis dan auth dan kerangka kerja. <br><br>  Sebagian besar perubahan yang saya sukai secara pribadi adalah <strong>kemampuan untuk tidak menulis ekstensi dan tambahan</strong> yang akan berdiri di luar alat. <br><br>  Misalnya, ada Vault, Anda ingin mengembangkannya - tulis logika tambahan atau UI Anda sendiri untuk otomatisasi, yang akan mengotomatisasi sesuatu.  Sebelum perubahan, saya harus meningkatkan layanan tambahan yang dihadapi Vault, dan mem-proksi semua permintaan: pertama permintaan pergi ke layanan, lalu ke Vault.  Ini buruk karena di layanan perantara mungkin ada tingkat keamanan yang berkurang, dan semua rahasia melewatinya.  <strong>Risiko keamanan jauh lebih tinggi ketika rahasianya melewati beberapa poin sekaligus!</strong> <br><br><h2>  Masalah Ayam dan Telur <br></h2><br>  Ketika Anda mengangkat masalah menyimpan informasi rahasia dan memutuskan untuk mengenkripsi, maka segera setelah Anda mengenkripsi sesuatu, rahasia Anda berpindah dari tempat enkripsi ke tempat kunci disimpan.  Ini terjadi setiap saat: segera setelah Anda menyimpan rahasia di suatu tempat atau mengubah yang sudah ada, Anda memiliki yang lain dan lingkaran terpesona dimulai - <strong>tempat menyimpan rahasia untuk akses ke rahasia itu</strong> . <br><br>  Rahasia untuk mengakses rahasia adalah bagian keamanan yang disebut <strong>otentikasi</strong> .  Keamanan memiliki bagian lain - <strong>otorisasi.</strong>  Dalam proses otorisasi, diperiksa apakah pengguna dapat mengakses secara tepat di mana ia meminta.  Dalam kasus Vault, ada pihak ketiga tepercaya yang memutuskan apakah akan memberikan rahasia atau tidak.  Otorisasi hanya menyelesaikan sebagian masalah. <br><br><h2>  HashiCorp Vault di Avito <br></h2><br>  Di Avito, HashiCorp diinstal di satu-satunya instalasi besar di seluruh jaringan.  HashiCorp Vault memiliki banyak backend yang berbeda.  Kami menggunakan backend berdasarkan <strong>Konsul</strong> juga dari HashiCorp, karena Vault hanya dapat mendukung toleransi kesalahannya sendiri melalui Konsul. <br><br>  <strong>Membuka segel</strong> adalah cara untuk tidak menyimpan kunci master di satu tempat.  Ketika Vault dimulai, ia mengenkripsi semua yang ada pada kunci, dan sekali lagi masalah ayam dan telur muncul: tempat menyimpan rahasia, yang akan mengenkripsi semua rahasia lainnya.  Untuk menghindari masalah ini, Vault menyediakan kunci komposit, yang memerlukan beberapa bagian kunci, yang kami bagikan ke beberapa karyawan.  Di Avito, kami mengonfigurasi Unseal di opsi untuk 3 orang dari 7. Jika kami memulai Vault, setidaknya 3 orang harus masuk dan memasukkan bagian kunci mereka agar dapat mulai bekerja.  Kuncinya dibagi menjadi 7 bagian dan Anda dapat membawanya. <br><br>  Kami telah mengumpulkan Vault uji kecil, kotak pasir untuk pengembang tempat mereka dapat bermain.  Itu dalam bentuk wadah Docker dan menciptakan rahasia sederhana sehingga orang dapat menyentuh alat dengan tangan mereka, merasa nyaman.  Tidak ada Konsul dan pengelompokan di kotak pasir, itu hanya sistem file tempat Vault menyimpan rahasia terenkripsi, dan skrip kecil untuk diinisialisasi. <br><br>  Inilah yang sekarang kami simpan di Vault: <br><br><ul><li>  Hampir semua rahasia untuk layanan microsoft Kubernetes: kata sandi basis data, kunci API, semua hal di atas. </li><li>  Rahasia untuk meletakkan di server "besi" dan LXC. </li><li>  Kami juga menaruh rahasia untuk CI / CD builds di TeamCity in Vault.  Cakupan tidak 100%, tetapi cukup dapat diterima. </li><li>  Kunci semua sertifikat: PKI internal, CA eksternal, misalnya, GeoTrust dan sejenisnya. </li><li>  Rahasia umum untuk tim. </li></ul><br>  Di dalam, Vault menyimpan semuanya hanya di JSON, itu tidak selalu nyaman dan memerlukan tindakan tambahan dari pengembang, jadi pada dasarnya kami memposting rahasia dalam bentuk file. <br><br><blockquote>  Kami mencoba menyampaikan rahasia dalam bentuk file. <br></blockquote><br>  Kami tidak memberi tahu pengembang: "Pergi ke Vault, ambil rahasia!", Tapi letakkan file di disk dan katakan: "Pengembang, file akan muncul di disk Anda, ambil rahasianya, dan kami akan mencari cara mendapatkannya dari Vault dan membawanya untukmu. " <br><img src="https://habrastorage.org/webt/rg/9o/mj/rg9omjizdszcnw0lzrr_iogfosc.png"><br><br>  Kami mengadopsi perjanjian sederhana untuk bidang JSON, di mana kami mengindikasikan dengan hak apa untuk mengunggah file.  Ini adalah metadata untuk sistem file, dan bidang data adalah string yang disandikan dengan rahasia itu sendiri, yang akan menjadi konten file. <br><br><h2>  Wayang + Hiera + Vault <br></h2><br>  Hampir semua infrastruktur Avito menggunakan Puppet, ia menggelar semua server. <br><br>  Wayang memiliki alat yang nyaman untuk mengatur hierarki - <strong>Hiera</strong> .  Vault terintegrasi sangat baik dengan Hiera melalui modul tambahan, karena permintaan nilai kunci dikirim ke perpustakaan ini, dan Vault sendiri adalah basis data nilai kunci, tetapi dengan semua fitur keamanan - dengan enkripsi transparan dan kemampuan untuk memilih akses ke kunci. <br><br>  Oleh karena itu, hal pertama yang kami terapkan adalah Vault di Wayang, tetapi dengan satu tambahan - kami memiliki lapisan perantara yang disebut <strong>Router backend</strong> .  Router backend - modul Hiera terpisah, hanya file pada disk yang mengatakan di mana Hiera harus pergi untuk kunci - di Vault atau di tempat lain. <br><br>  Dia diperlukan agar Hiera tidak pergi ke Vault terus-menerus, karena dia selalu melewati hierarki.  Ini bukan masalah Vault atau beban di atasnya, tetapi fitur Hiera itu sendiri.  Karena itu, jika Anda hanya menyisakan modul untuk Vault tanpa backend Router, master Wayang akan membutuhkan waktu yang sangat lama untuk mengumpulkan konfigurasi untuk agen Wayang, karena akan memeriksa setiap kunci di Vault. <br><img src="https://habrastorage.org/webt/dv/di/f6/dvdif6z09jpflg98zykbwf7l7cq.png"><br><br>  Untuk boneka, masalah ayam dan telur diselesaikan karena pihak yang berwenang adalah penguasa boneka.  Dialah yang memberikan rahasia untuk mengakses rahasia.  Master Wayang memiliki akses ke semua rahasia sekaligus, tetapi setiap tuan rumah diizinkan untuk hanya menerima satu yang dimaksudkan untuk itu.  Host pada master Wayang sudah disahkan oleh sertifikatnya, yang dihasilkan secara lokal dan tidak meninggalkan batas host.  Pada prinsipnya, rahasia untuk mengakses rahasia tetap ada, tetapi ini tidak terlalu kritis. <br><br>  Proses kami mengungkap rahasia baru di Wayang terdiri dari langkah-langkah berikut. <br><br><ul><li>  Kami mengambil rahasia di suatu tempat - seseorang memberikannya kepada kami atau memadamkannya. </li><li>  Menempatkan rahasia di Vault, dengan hierarki seperti di Hiera: <strong>/puppet/role/www/site.ssl.key</strong> . </li><li>  Kami mendaftarkan awalan di manifes Wayang, yang menunjukkan bahwa file tersebut ada di Vault dan di mana mendapatkannya. </li><li>  Kami menulis path di Vault di YAML untuk router Hiera dan backend sehingga Hiera dapat menemukannya. </li><li>  Tarik permintaan melalui GIT ke repositori manifes. </li><li>  Lari atau tunggu sampai agen Wayang lari. </li></ul><br>  Agen boneka melarikan diri bersama kami setiap 30 menit, jadi Anda harus menunggu sedikit sampai rahasia keluar.  Ini tidak menimbulkan masalah - <strong>kami tidak membagikan rahasia setiap hari</strong> .  Selama Kubernetes tidak terlibat dalam bisnis, tidak ada banyak biaya overhead dan kami siap untuk meletakkan rahasia di Vault dengan tangan kami dengan otomatisasi minimal. <br><br>  Tambahan tambahan kita mendapatkan "chip" Hiera - <strong>rahasia dapat ditata segera untuk sekelompok host</strong> atau tergantung pada peran host, yang kita atur dalam peran variabel. <br><br>  Satu-satunya <strong>bahaya</strong> : jika Anda memiliki Wayang dan Anda menggunakan Hiera, jangan mengganti apa pun yang masuk ke templat variabel karena banyak fakta dan variabel dikumpulkan di sisi klien.  Jika seorang penyerang mengganti fakta pada klien, Master Wayang akan memberinya rahasia orang lain.  <strong>Pastikan untuk memeriksa variabel</strong> : hanya gunakan <strong>variabel yang</strong> tidak bisa ditentukan oleh Puppet-master di sisi klien. <br><br><h2>  Apa yang harus dilakukan dengan SCM tanpa penyihir? <br></h2><br>  Jika tiba-tiba Anda tidak memiliki Wayang, maka kemungkinan besar Ansible.  Untuk Chef dan SCM terpusat lainnya, solusi mereka adalah plugin yang dapat mengakses Vault.  Saya menawarkan beberapa opsi yang dapat diimplementasikan dengan Ansible. <br><br><h3>  Agen lokal <br></h3><br>  Secara lokal untuk server, buat token, yang sebenarnya adalah kata sandi untuk mengakses Vault.  Token itu berlaku sepanjang waktu.  Anda dapat memperbarui atau mengotomatiskannya.  Dengan token ini, Anda pergi ke Vault dan mengambil rahasia Anda. <br><br>  Idenya adalah bahwa di server Anda di mana Anda perlu mengirimkan rahasia, agen yang datang ke Vault berputar, melihat semua rahasia dan menempatkannya dalam bentuk file.  Kami menggunakan agen di beberapa server terpisah di mana tidak ada Wayang. <br><br>  <strong>Cons:</strong> <br><br><ul><li>  Token mudah dimasukkan dalam segmen kecil, tetapi jika Anda memiliki beberapa lusin server yang digunakan per hari, Anda harus membuat token untuk setiap server dan menentukan kebijakan.  Ini tidak nyaman. </li><li>  Token perlu diperbarui. </li><li>  Mengelompokkan server berdasarkan peran, tujuan, atau fakta sulit, harus disinkronkan dengan Vault. </li></ul><br><h3>  Enkripsi transit <br></h3><br>  Vault memiliki fungsi enkripsi transit, intinya adalah bahwa Vault bertindak sebagai <strong>server enkripsi</strong> .  Anda hanya perlu memberinya plaintext, dan dia, di kunci pribadinya, yang hanya dia miliki, mengenkripsi dan mengeluarkan teks tertutup.  Kemudian Anda memilih siapa yang dapat mendekripsi teks tertutup ini. <br><br>  Ansible memiliki entitas, juga disebut Vault.  Ini bukan Vault HashiCorp, tetapi <strong>Vault Ansible</strong> .  Tidak perlu bingung, dan rahasia dapat disimpan dalam yang pertama dan kedua.  Ansible memiliki plugin yang sudah jadi untuk mengirimkan rahasia dari Hashicorp Vault.  Jika Anda memberikan akses pribadi ke Vault, maka Anda dapat mendekripsi rahasia.  Saat Anda menggulung Ansible, ia pergi ke Vault atas nama Anda, mendekripsi rahasia yang dienkripsi dalam repositori, dan menggulungnya ke dalam produksi. <br><br>  Ada juga kelemahan - <strong>setiap administrator mendapat akses ke rahasia</strong> .  Tetapi ada audit: Vault tahu cara menyimpan log aktivitas tentang pengguna mana yang masuk, rahasia apa yang mereka baca, yang mana yang dapat diakses.  Anda selalu tahu siapa, kapan dan apa yang dilakukan dengan rahasia.  Pilihan ini sepertinya baik untuk saya. <br><br><h3>  Kesalahan Besar # 1 <br></h3><br>  Kerugian terbesar yang menyebabkan rasa sakit terbesar di kami adalah bahwa di Vault Anda tidak dapat mendelegasikan kendali penuh ke <strong>bagian</strong> mana pun <strong>dari</strong> <strong>data kepada</strong> siapa pun.  Di Vault, akses ke rahasia dilakukan dengan cara yang mirip dengan jalur UNIX - nama biasanya dipisahkan oleh garis miring, dan hasilnya adalah "direktori".  Ketika Anda memiliki jalan seperti itu, kadang-kadang Anda ingin mengambil bagian dari jalan itu dan memberikannya kepada orang lain untuk kontrol. <br><img src="https://habrastorage.org/webt/w-/hq/gf/w-hqgfwmxgok3_dimlgnn8baxag.png"><br><br>  Misalnya, Anda mendapat sertifikat, dipanggil <strong>/ sertifikat</strong> , dan Anda ingin memberikannya kepada petugas keamanan individu yang berurusan dengan PKI.  Vault tidak dapat melakukan ini.  Anda tidak dapat memberikan hak untuk mengeluarkan hak di dalam awalan ini - sehingga penjaga keamanan itu sendiri dapat mendistribusikan hak untuk sertifikat kepada orang lain. <br><br>  <strong>Vault tidak memiliki kemampuan untuk secara selektif memberikan hak untuk memberikan hak</strong> .  Segera setelah Anda memberikan hak untuk memberikan hak, Anda juga memberi kesempatan untuk mendapatkan akses penuh ke semua rahasia.  Dengan kata lain, Anda tidak dapat memberikan akses ke bagian Vault. <br><br>  Ini adalah salah satu masalah terbesar.  Saya punya ide bagaimana menyelesaikannya, saya akan memberi tahu Anda nanti. <br><br><h2>  Kubernetes <br></h2><br>  Di RIT ++, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang sistem terpisah yang kami terapkan untuk <strong>Kubernetes</strong> : ini berfungsi sebagai pihak ketiga, pergi ke API, memeriksa akses dan kemudian meminta rahasia di Vault. <br><br>  Sekarang sistem kami telah kehilangan relevansi, karena di Vault 0.9, dukungan asli untuk Kubernetes telah muncul.  Sekarang Vault sendiri tahu cara pergi ke Kubernetes dan memastikan bahwa akses ke rahasia diizinkan.  Dia melakukan ini dengan <strong>Token Akun Layanan</strong> .  Misalnya, ketika pod Anda diluncurkan, ada <strong>JWT</strong> khusus, bertanda tangan dan resmi untuknya, dirancang untuk permintaan ke API Kubernetes.  Dengan token, Anda juga dapat masuk ke Vault dan mendapatkan rahasia khusus untuk namespace Anda. <br><br>  Semuanya dilakukan pada level Vault itu sendiri.  Benar, akan diperlukan untuk memulai peran untuk setiap namespace, yaitu, beri tahu Vault bahwa ada namespace seperti itu, akan ada otorisasi di dalamnya, dan mendaftar ke mana harus pergi ke Kubernetes.  Ini dilakukan sekali, dan kemudian Vault akan pergi ke API itu sendiri, mengkonfirmasi validitas JWT dan mengeluarkan token aksesnya sendiri. <br><br><h3>  Aturan Kubernetes <br></h3><br>  Dalam hal nama layanan dan metadata tambahan, kami mempercayai pengembang.  Ada kemungkinan kecil bahwa pengembang mungkin secara tidak sengaja atau sengaja mendapatkan rahasia layanan lain yang berputar di namespace yang sama, jadi kami memperkenalkan aturan: <strong>satu layanan</strong> - <strong>satu namespace.</strong> <br><br>  Layanan microser baru?  Dapatkan namespace baru dengan rahasia Anda.  Anda tidak dapat melintasi perbatasan ke perbatasan - mereka memiliki Token Akun Layanan mereka sendiri.  <strong>Batas keamanan di Kubernetes saat ini adalah namespace.</strong>  Jika dalam dua ruang nama yang berbeda Anda perlu satu rahasia - salinlah. <br><br>  Kubernetes memiliki <strong>rahasia kubernetes</strong> .  Mereka disimpan di etcd di Kubernetes dalam bentuk yang tidak terenkripsi dan dapat "menyala" di dasbor atau ketika kubectl mendapatkan pod dimulai.  Jika otentikasi di etcd dinonaktifkan di cluster Anda, atau jika Anda memberi seseorang akses read-only penuh, maka semua rahasia dapat dilihat olehnya.  Itulah sebabnya kami memperkenalkan dua aturan: <strong>dilarang menggunakan rahasia kubernet</strong> dan <strong>dilarang untuk menentukan rahasia dalam variabel lingkungan dalam manifes</strong> .  Jika Anda menulis rahasia di lingkungan di deployment.yaml, ini buruk, karena manifes itu sendiri dapat dilihat oleh siapa saja yang tidak malas. <br><br><h3>  Pengiriman Kubernetes <br></h3><br>  Seperti yang saya katakan, kita harus entah bagaimana meletakkan file di Kubernetes.  Kami memiliki rahasia: entitas, kata sandi yang ditulis dalam VSON di Vault.  Bagaimana mengubahnya menjadi file di dalam wadah di Kubernet sekarang? <br><img src="https://habrastorage.org/webt/gm/ki/wb/gmkiwblvlm7ca4hiwmvhhx14wxu.png"><br><br>  Opsi pengiriman pertama. <br><br><ul><li>  Kami memulai init-container khusus. </li><li>  Itu dimulai dari gambar kita. </li><li>  Gambar berisi utilitas kecil yang masuk ke Vault dengan Token Akun Layanan, mengambil rahasia dan memasukkannya ke dalam volume Bersama. </li><li>  Untuk utilitas, volume Bersama khusus dipasang hanya di memori TMPFS sehingga rahasia tidak melewati disk. </li><li>  Init-container pergi ke Vault, memasukkan volume ini dalam bentuk file semua rahasia yang ditemukan di jalur yang ditentukan. </li><li>  Selanjutnya, volume Bersama dipasang di wadah utama di mana diperlukan. </li><li>  Ketika wadah utama diluncurkan, segera mendapatkan apa yang dibutuhkan pengembang - rahasia dalam bentuk file pada disk. </li></ul><br>  Pengembang hanya perlu mengingat jalan di mana rahasianya terletak. <br><br>  Kami menggunakan sesuatu seperti awalan ini: <br><br><pre><code class="plaintext hljs">/k8s/&lt;cluster&gt;/&lt;namespace&gt;/&lt;service&gt;/some_secret</code> </pre> <br>  Nama awalan berisi nama cluster, namespace, dan nama layanan.  Setiap layanan memiliki rahasia sendiri, setiap namespace memiliki rahasia sendiri. <br><br>  Opsi kedua adalah <strong>titik masuk</strong> Anda <strong>sendiri</strong> .  Kami sekarang beralih ke Avito, karena pengembang memiliki masalah dengan init-container.  Dalam diagram, opsi ini ada di sebelah kanan. <br><br>  Tidak semua orang mampu membayar titik masuk mereka sendiri.  Kami bisa, jadi di setiap wadah kami memaksakan titik masuk khusus kami. <br><br>  Titik masuk kami melakukan hal yang sama dengan init-container: masuk ke Vault dengan Token Akun Layanan, mengambil rahasia dan mengeluarkannya.  Selain file, ia menempatkannya kembali di lingkungan.  Anda mendapatkan kesempatan untuk menjalankan aplikasi seperti yang direkomendasikan oleh konsep <strong>Aplikasi Dua Belas-Faktor</strong> : aplikasi mengambil semua pengaturan, termasuk rahasia, dari variabel lingkungan. <br><br>  Variabel lingkungan tidak terlihat di manifes dan dasbor, karena mereka ditetapkan oleh PID 1 (proses wadah utama) saat startup.  Ini bukan variabel lingkungan dari deployment.yaml, tetapi variabel lingkungan yang ditetapkan oleh titik masuk dalam proses.  Mereka tidak terlihat di dasbor, mereka tidak terlihat, bahkan jika Anda membuat exec kubectl dalam wadah, karena dalam kasus ini proses lain diluncurkan, sejajar dengan PID1. <br><br><h3>  Alur kerja <br></h3><br>  Dari sudut pandang organisasi, prosesnya adalah sebagai berikut.  Pengembang belajar dari juara keamanan atau dari dokumentasi bahwa ia tidak boleh menyimpan rahasia di repositori, tetapi hanya di Vault.  Lalu dia datang kepada kami dan bertanya di mana harus menyimpan rahasia - ia mengajukan aplikasi ke keamanan untuk membuat awalan.  Di masa mendatang, Anda dapat membuat awalan tanpa permintaan, segera saat membuat layanan. <br><br>  Pengembang sedang menunggu, dan ini buruk, karena  hal utama baginya adalah waktu-ke-pasar.  Kemudian dia membaca instruksi, berurusan dengan file-file panjang - "masukkan baris itu di sana, masukkan baris ini di sini".  Seorang pengembang belum pernah memulai init-container sebelumnya, tetapi ia dipaksa untuk mencari tahu dan mendaftarkannya di deployment.yaml (grafik kemudi). <br><br> <code>Commit -&gt; deploy -&gt; feel pain -&gt; fix -&gt; repeat</code> <br> <br>  Itu berkomitmen, menunggu TeamCity untuk meluncurkan, melihat kesalahan dalam TeamCity, mulai merasakan sakit, mencoba untuk memperbaiki sesuatu, mengalami rasa sakit lagi.  Selain itu, ditumpangkan bahwa setiap peluncuran di TeamCity masih dapat antri.  Terkadang seorang pengembang tidak dapat menemukannya sendiri, mendatangi kami, dan kami mengatasinya bersama-sama. <br><br>  Pada dasarnya, pengembang menderita karena kesalahannya sendiri: <strong>init-container tidak ditentukan dengan benar atau tidak membaca dokumentasi</strong> . <br><br>  Keamanan juga memiliki masalah.  Petugas keamanan menerima aplikasi di mana selalu ada sedikit informasi, dan kami masih menemukan pertanyaan yang hilang: cari tahu nama cluster, namespace layanan, karena pengembang tidak menunjukkannya dalam aplikasi dan bahkan tidak selalu tahu apa itu.  Ketika kami mengetahui semuanya, membuat kebijakan dan peran di Vault, menentukan kebijakan untuk grup, dan bersama dengan pengembang kami mulai mencari tahu di mana dan mengapa dia melakukan kesalahan, dan bersama-sama kami membaca log. <br><br>  Unit "Arsitektur" membantu menyelesaikan masalah dengan bersembunyi dari pengembang deployment.yaml.  Mereka mengembangkan karya yang menghasilkan segalanya untuk pengembang, termasuk titik masuk.  Karena kami mengganti entri kami, kami dapat menggunakannya tidak hanya untuk memberikan rahasia, tetapi juga untuk hal-hal lain yang mungkin perlu Anda lakukan saat startup. <br><br><h3>  Masalah yang jelas dengan rahasia Kubernetes. <br></h3><br><ul><li>  <strong>Alur kerja yang sangat rumit</strong> untuk pengembang dan penjaga keamanan. </li><li>  <strong>Anda tidak dapat mendelegasikan apa pun kepada siapa pun.</strong>  Petugas keamanan memiliki akses penuh ke Vault, dan akses parsial tidak dimungkinkan (lihat Cacat Besar # 1). </li><li>  Kesulitan muncul ketika memindahkan pengembang dari cluster ke cluster, dari namespace ke namespace, ketika rahasia bersama diperlukan, karena pada awalnya diasumsikan bahwa rahasia yang berbeda berbeda dalam kelompok yang berbeda. </li></ul><br>  Kami berkata: “Mengapa Anda membutuhkan rahasia produksi di klaster dev?  Dapatkan rahasia tes, ikuti saja! ”  Akibatnya, ada <strong>tambang</strong> <strong>dan rahasia</strong> yang sulit dikelola.  Jika rahasia telah berubah, Anda tidak boleh melupakannya, pergi dan ubah di mana-mana, dan sementara tidak ada cara untuk menentukan bahwa itu adalah rahasia yang sama, kecuali dengan nama layanan. <br><br><h3>  Ide: Kubernetes KMS <br></h3><br>  Dalam versi baru Kubernetes, subsistem KMS, Layanan Manajemen Kunci, adalah fitur enkripsi rahasia Kubernetes yang baru.  Di v1.11 itu dalam kondisi alfa, di v1.12 itu dipindahkan ke beta. <br><img src="https://habrastorage.org/webt/yq/nw/i9/yqnwi9a_t6atxpxdu_qrtu0qz80.png"><br>  <em>Gambar tersebut berasal dari situs proyek penyedia KMS untuk Vault, dan ada kesalahan padanya.</em>  <em>Jika Anda menemukan - tulis di komentar.</em> <br><br>  Arti KMS adalah untuk menghilangkan satu kelemahan tunggal - penyimpanan data tidak terenkripsi di etcd. <br><br>  KMS, seperti Ansible, dapat melakukan ini. <br><br><ul><li>  Pergi ke suatu tempat, mengenkripsi rahasia asli Kubernetes dan memasukkannya ke dalam bentuk terenkripsi. </li><li>  Jika perlu, kirim ke pod, dekripsi, dan masukkan ke dalam format dekripsi. </li></ul><br>  Pengembang telah menulis layanan khusus yang melakukan ini menggunakan enkripsi transit.  Gagasan itu tampaknya berhasil, tetapi penting untuk diingat bahwa rahasia tidak lagi berada di bawah kendali Vault dan pergi ke tempat lain, ke dalam area tanggung jawab administrator Kubernet. <br><br>  Kontra KMS. <br><br><ul><li>  <strong>Desentralisasi Penyimpanan</strong> - <strong>Pengalihan dari Vault ke Kubernetes (etcd)</strong> .  Rahasia menjadi tidak terkendali oleh Vault, dan itu bagus sebagai tempat penyimpanan rahasia yang terpusat.  Ternyata setengah dari rahasia di Vault, dan setengah di tempat lain. </li><li>  <strong>Solusi khusus Kubernetes</strong> .  Jika Anda memiliki infrastruktur khusus Kubernetes, Anda mengambil Vault, dan Anda hampir tidak berpikir apa yang disimpan di sana, karena  itu hanya berisi kunci enkripsi yang Anda kelola dengan benar - berputar secara teratur, dll ... Rahasia itu sendiri ada di Kubernetes, dan ini nyaman. </li><li>  <strong>Sulit berbagi rahasia antar cluster</strong> .  Untuk setiap cluster baru, Anda harus memulai dari awal lagi, menyalin rahasia seperti dalam kasus Vault tunggal mungkin tidak berfungsi. </li></ul><br>  Pro KMS. <br><br><ul><li>  <strong>Dukungan asli</strong> di Kubernetes, termasuk bersembunyi saat menunjukkan lingkungan. </li><li>  <strong>Otorisasi di wilayah Kubernetes menjadi tanggung jawab</strong> . </li><li>  <strong>Hampir tidak ada dukungan Vault yang diperlukan</strong> . </li><li>  <strong>Rotasi kunci keluar dari kotak</strong> . </li></ul><br><h2>  CI / CD: TeamCity <br></h2><br>  Semuanya sederhana di TeamCity, karena JetBrains menulis sebuah plug-in yang dengan sendirinya dapat menentukan rahasia untuk mengakses rahasia, mengenkripsi mereka dengan TeamCity, dan kemudian menggantinya di templat di suatu tempat sebagai parameter dalam persen.  Pada saat ini, agen TeamCity sendiri pergi ke Vault, mengambil rahasia dan membawanya ke build sebagai parameter. <br><br>  Beberapa rahasia diperlukan selama penyebaran, misalnya, migrasi basis data atau peringatan di Slack.  AppRole dimulai untuk setiap proyek - pengaturan juga mengandung rahasia (data untuk AppRole), tetapi dimasukkan dalam mode tulis-saja - TeamCity tidak mengizinkan membacanya nanti. <br><br>  TeamCity sendiri berhati-hati bahwa ketika sebuah rahasia memasuki log bangunan, ia secara otomatis menyamar.  Akibatnya, rahasianya tidak "melewati" sama sekali disk, atau dihapus dari disk menggunakan alat TeamCity.  Akibatnya, semua keamanan rahasia dijamin dengan baik oleh TeamCity sendiri dan plugin, dan tarian tambahan dengan rebana tidak diperlukan <br><br><h3>  CI / CD bukan TeamCity? <br></h3><br>  Ini adalah masalah utama yang perlu dipertimbangkan jika Anda menggunakan sistem yang berbeda (bukan TeamCity) sebagai CI. <br><br><ul><li>  Isolasi: batasi ruang lingkup rahasia untuk proyek, tim, dll. </li><li>  Siapa yang memberi otorisasi akses ke rahasia. </li><li>  Kecualikan kemampuan untuk melihat rahasia pihak yang berwenang. </li><li>  Tahap terpisah dari build adalah untuk mengimpor rahasia ke file. </li><li>  Bersihkan dirimu. </li></ul><br>  Akibatnya, kemungkinan besar Anda akan menulis sesuatu yang sangat mirip dengan plugin TeamCity untuk CI / CD Anda.  Pihak yang berwenang di sini kemungkinan besar adalah CI / CD, dan dialah yang akan memutuskan apakah bangunan ini dapat memiliki akses ke rahasia ini, dan apakah akan memberikan rahasia itu sendiri atau tidak berdasarkan hasil. <br><br>  Penting untuk tidak lupa <strong>membersihkan hasil build di akhir perakitan</strong> , jika diletakkan di disk, atau untuk memastikan bahwa mereka hanya di memori. <br><br><h2>  Sertifikasi <br></h2><br>  Tidak ada yang istimewa dengan sertifikat - kami menggunakan Vault terutama untuk penyimpanannya. <br><img src="https://habrastorage.org/webt/ix/ye/4j/ixye4jru2blznsbq2jxmljomqi8.png"><br><br>  Vault memiliki backend PKI khusus untuk menerbitkan sertifikat, di mana Anda dapat membuat Otoritas Sertifikat dan menandatangani sertifikat baru.  Kami memiliki satu PKI internal ... CA root dan CA tingkat kedua ada secara terpisah, dan kami sudah mengelola CA tingkat ketiga melalui Vault.  Untuk menyimpan sertifikat yang dikeluarkan dari tingkat mana pun, termasuk sertifikat yang ditandatangani oleh CA eksternal, kami menggunakan awalan terpisah, dan menempatkan hampir semua sertifikat yang valid di sana untuk keperluan akuntansi dan pemantauan.  Format untuk menyimpan sertifikat adalah hak milik, cocok untuk menyimpan kunci pribadi yang terpisah dan sertifikat itu sendiri. <br><br><h2>  Ringkasan <br></h2><br>  <strong>Terlalu banyak pekerjaan manual</strong> untuk penjaga keamanan, <strong>terlalu banyak ambang masuk untuk pengembang,</strong> dan tidak ada alat delegasi bawaan, meskipun saya benar-benar ingin ... <br><br>  Bagaimana menjadi  Kemudian mimpi dimulai. <br><br><h2>  Gagasan: bagaimana melakukan yang lebih baik <br></h2><br>  Bagaimana saya bisa menyingkirkan banyak salinan rahasia? <br><br><h3>  Master-slave pengiriman <br></h3><br>  Kami memiliki rahasia utama dan daemon khusus yang berjalan di sekitar, melihat rahasia dan metadata-nya, meletakkannya di tempat yang diperlukan, ternyata menjadi rahasia budak.  Di jalan di mana daemon memposting budak, tidak ada yang bisa diubah dengan tangan, karena daemon akan datang dan meletakkan kembali rahasia master di atas budak. <br><br>  Pada awalnya kami ingin membuat mekanisme symlink untuk hanya menunjukkan: "Carilah rahasia ini di sana!", Seperti di Linux.  Ternyata ada masalah dengan hak akses: tidak diketahui cara memeriksa hak akses - seperti di Linux atau tidak, dengan jalur induk, dengan transisi antara titik mount.  Ada terlalu banyak momen ambigu dan peluang untuk membuat kesalahan, jadi kami menolak symlink. <br><br><h3>  Otorisasi Kepemilikan <br></h3><br>  Hal kedua yang ingin kita lakukan adalah <strong>menentukan pemilik untuk setiap rahasia</strong> .  Secara default, rahasia itu milik orang yang membuatnya.  Jika perlu, Anda dapat memperluas area tanggung jawab ke unit dengan mengeluarkan grup pemilik. <br><br>  Ketika kita belajar untuk mendelegasikan, kita akan memberikan pemiliknya suatu rahasia, dan dia akan dapat melakukan dengan rahasia apa yang dia inginkan. <br><br><ul><li>  Sebarkan dalam k8s - kebijakan dibuat, salinan budak dibuat. </li><li>  Sebarkan di server - kebijakan dibuat, salinan budak dibuat. </li><li>  Spread dalam CI / CD - ... </li><li>  Transfer ke pemilik lain. </li><li>  Berikan akses baru, hasilkan ACL baru. </li></ul><br>  Sekarang kami bertanggung jawab atas semua rahasia dan keamanan, tetapi kami ingin mengalihkan tanggung jawab kepada pencipta.  <strong>Keamanan tidak akan terpengaruh</strong> , karena orang yang datang kepada kami dengan permintaan untuk menjaga rahasia memahami bahwa ia perlu menjaga rahasia dengan aman dan menyadari tanggung jawabnya. <br><br>  Karena dia adalah pemilik rahasia, untuk opsi pengiriman tuan-budak, dia bisa memilih di mana dan dalam format apa rahasia itu harus dikirimkan kepadanya.  Ternyata pemiliknya mengelola semuanya sendiri, tidak perlu mengirimkan aplikasi, Anda dapat mengambil sendiri awalan yang diperlukan, Anda juga dapat membuat dan menghapus rahasia sendiri. <br><br><h3>  Delegasi melalui ACL Templates <br></h3><br>  Kebijakan akses Daftar Akses Kontrol di Vault dibagi menjadi dua bagian: <br><br><ul><li>  Daftar Kontrol Akses dalam tampilan klasik, yang menjelaskan akses ke awalan, cara membaca dan menulis, yang hanya membaca, dll. </li><li>  Saat membuat ACL di dalamnya, Anda dapat menulis tanda bintang di bagian akhir, yang berarti "awalan ini, dan semua yang ada di bawahnya."  Awalan dapat ditugaskan sebagai operasi terpisah, diberikan kepada pengguna atau grup, yaitu, dilampirkan ke beberapa entitas yang berbeda. </li></ul><br>  Saat ini, hanya administrator Vault yang dapat mengubah ACL.  Setelah mendapatkan akses ke ACL seperti itu, Anda dapat meresepkan semua yang Anda inginkan di dalam, misalnya, <code>path “*” { capabilities = [sudo, ...] }</code> , dan dapatkan akses penuh.  Ini adalah inti dari <strong>Kesalahan Terbesar</strong> # 1 - <strong>tidak mungkin untuk melarang mengubah</strong> <strong>isi ACL.</strong> <br><br>  Kami ingin menetapkan ACL dengan templat yang sudah jadi yang berisi path dan placeholder yang memungkinkannya menghasilkan ACL baru untuk templat ini. <br><br><h4>  Contoh <br></h4><br>  Di bawah ini adalah font kuning, jalur ACL standar selesai dari Vault, dan selanjutnya tindakan yang diizinkan pada jalur ini.  Kami menganggapnya sebagai ACL untuk izin untuk mengubah ACL lain di bawah ini, yang diberikan dalam bentuk templat. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Kami ingin mendelegasikan akses ke / k8s, kami hanya mengizinkan templat yang dihasilkan.  Misalnya, berikan akses hanya baca ke kluster khusus, ruang nama, layanan, tetapi jangan ubah bidang kemampuan. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Selain itu, kami ingin memberikan izin untuk mengikat ACL ini dan mengeluarkan hak yang berbeda. <br><br>  Kami menerapkan templat untuk memberikan hak kepada pengembang.  Ketika templating, ia menjalankan perintah <code>$ vault write policy-mgr/create/k8s-microservice ...</code>  Dan sebagai hasilnya, kami mendapat ACL yang menyatakan cluster = prod, namespace = ..., service = ... dll.  Hak ditetapkan secara otomatis, kebijakan dibuat dengan nama <code>/k8s/some-srv</code> - ini hanya nama ACL yang dapat dihasilkan dari templat. <br><img src="https://habrastorage.org/webt/ro/ih/ur/roihurfk7gxhvrv-hjpik6lctxc.png"><br><br>  Akibatnya, pengembang, atas kebijakan kami, memberikan ACL ini kepada siapa pun yang ingin, dan menjadi pemiliknya sendiri, dapat mengelolanya sebagai rahasia: hapus, beri, dan ambil dari pengguna dan grup.  Sekarang orang itu sendiri yang bertanggung jawab atas awalannya: dia mengelola semua rahasia, menghasilkan ACL sesuai dengan templat, dapat menetapkan ACL kepada yang dia inginkan.  Secara alami, kita dapat membatasi itu juga. <br><br>  Semua sulap berfungsi dengan entitas Vault baru - <strong>plugin</strong> .  Mereka adalah layanan terpisah, sangat mirip dengan yang saya sebutkan di awal, dan bekerja hampir persis sama.  Satu-satunya perbedaan penting adalah bahwa mereka bukan proxy.  Plugin diluncurkan "di samping" Vault, dan meluncurkan proses Vault utama mereka.  Karena ini, semua permintaan tidak melalui layanan, tetapi ke Vault, yang sudah berinteraksi dengan plug-in, mengirimkannya permintaan yang diverifikasi dan dihapus. <br><br>  Tentang plugin, cara mengaturnya, dan cara menulisnya, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Vault</a> .  Yang terbaik untuk menulisnya di Go, yang cukup sederhana, karena  Ada kerangka kerja untuk Go.  Vault berkomunikasi dengan plugin melalui grpc, meluncurkannya sebagai layanan, tetapi jangan takut, Anda tidak menyentuhnya - semuanya sudah ada dalam framework.  Anda hanya menulis aplikasi REST standar lebih atau kurang di mana Anda menentukan titik akhir, memberi mereka fungsi siap pakai, penangan yang akan memiliki logika pada mereka. <br><br>  Jangan takut bahwa Anda akan merusak sesuatu di Vault utama.  Plugin adalah layanan terpisah.  Bahkan jika plugin Anda panik dan jatuh, itu tidak akan merusak Vault.  Vault hanya akan memulai ulang plugin dan terus bekerja. <br><br>  Selain itu, ada pengaturan tambahan untuk plugin itu sendiri: selalu memeriksa jumlah hash sehingga tidak ada yang mengubah biner.  <strong>Keamanan menjalankan plugin disediakan</strong> . <br><br><h2>  Tautan yang bermanfaat: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.vaultproject.io</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jovandeginste/hiera-router</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jsok/hiera-vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.owasp.org/index.php/Security_Champions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog.jetbrains.com/teamcity/2017/09/vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/oracle/kubernetes-vault-kms-plugin</a> </li></ul><br><blockquote>  Kita akan berbicara tentang DevOps dan keamanan, CI / CD, k8s, Puppet dan semua itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> (yang terdekat di St. Petersburg pada bulan April) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf</a> .  Ayo bagikan pengalaman Anda atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat</a> orang lain.  Agar tidak lupa, berlanggananlah ke blog dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> , di mana kami akan mengingatkan Anda tentang tenggat waktu dan mengumpulkan materi yang bermanfaat. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438740/">https://habr.com/ru/post/id438740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438726/index.html">Y Combinator: Cara menutup perusahaan</a></li>
<li><a href="../id438730/index.html">HomoLudens: Selamat Ulang Tahun, Sid Meyer (+ semua artikel dalam bahasa Rusia)</a></li>
<li><a href="../id438732/index.html">Pengukuran Radio Amatir: Analisis Sinyal Bus I2C</a></li>
<li><a href="../id438734/index.html">Kusut orang-orang yang berpikiran sama</a></li>
<li><a href="../id438736/index.html">DevDay for Managers: Kelola TI</a></li>
<li><a href="../id438746/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis. Lanjutan</a></li>
<li><a href="../id438748/index.html">Infrastruktur sebagai kode, kami menang dalam skala besar (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../id438750/index.html">Peradaban Mata Air, 4/5</a></li>
<li><a href="../id438752/index.html">Akuntansi langsung di bank: cara membuat pengusaha individu bahagia</a></li>
<li><a href="../id438754/index.html">Bagaimana kami melakukan pemantauan jaringan untuk 14.000 objek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>