<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏀 🐻 ⏏️ Virus mineur avec «Heaven's Gate» 📫 🥌 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! En prévision du démarrage d'une nouvelle filière au cours de reverse engineering, nous partageons avec vous la traduction d'un matérie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Virus mineur avec «Heaven's Gate»</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467193/">  Bonjour à tous!  En prévision du démarrage d'une nouvelle filière au cours de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reverse engineering, nous</a> partageons avec vous la traduction d'un matériel très intéressant.  Bonne lecture <br><br><img src="https://habrastorage.org/webt/ob/ex/ue/obexuezayzkv5cwefrnqwi2j7_8.png"><br><hr><br>  Les deux dernières années peuvent être appelées des années de hackers de ransomwares.  Les ransomwares sont sans aucun doute le type de malware le plus populaire.  Cependant, à la fin des dernières années, nous avons commencé à observer leur baisse de popularité et son augmentation en faveur des mineurs.  Il est possible qu'en 2018, cette tendance ne fera que croître. <a name="habracut"></a><br><br>  Du point de vue de la victime, c'est un soulagement, car les mineurs ne sont pas aussi dangereux que les ransomwares.  Oui, ils ralentissent le système, mais dès que vous vous en débarrassez, vous pouvez continuer à utiliser votre ordinateur comme avant.  Vos données ne sont ni volées ni perdues, comme c'est le cas avec le virus ransomware. <br><br>  Du point de vue d'un chercheur de logiciels malveillants, les mineurs sont décevants.  Ils ne fournissent pas suffisamment de nouveaux matériaux pour une analyse plus approfondie, principalement parce qu'ils sont basés sur des composants open source bien connus avec peu ou pas de confusion ou de furtivité. <br><br>  Cependant, de temps en temps, nous trouvons des mineurs utilisant des astuces intéressantes.  Nous avons récemment observé une technique appelée «Heaven's Gate», qui permet des injections dans des processus 64 bits à partir de chargeurs de démarrage 32 bits.  Cette idée n'est pas nouvelle, sa première implémentation remonte à 2009, mais il est intéressant de voir comment elle a été implémentée sous une nouvelle forme, obtenue directement «à l'état sauvage». <br><br>  Les débutants en analyse de virus peuvent lire un guide sur ce qu'est Heaven's Gate et comment aborder son analyse. <br><br><h3>  Matériel d'analyse </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7b3491e0028d443f11989efaeb0fbec2</a> - le premier compte-gouttes; </li></ul><br>  Ce modèle a été trouvé dans la suite de la campagne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ngay</a> (plus à ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  La vérification de la biographie de ces échantillons m'a conduit à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@_qaz_qaz</a> , qui décrit une campagne antérieure avec un échantillon similaire.  Cependant, son analyse n'a pas inclus la technologie Heaven's Gate. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ed575ba72ea8b41ac2c31c8c39ce303b</a> - le deuxième compte-gouttes; </li><li>  ca54fa2cf8a7e3e2cd457811f336de44 - chargeur de démarrage 32 bits. </li></ul><br><h3>  Analyse comportementale </h3><br>  Pour voir l'injection mentionnée, nous devons exécuter l'exemple sur un système 64 bits.  Nous voyons qu'il lance l'essence du portable, avec les paramètres spécifiques à l'extraction de crypto-monnaie: <br><br><img src="https://habrastorage.org/webt/j8/2m/wu/j82mwua73429bcc1dxa1krt7g6g.png"><br><br>  En regardant les lignes en mémoire dans ProcessExplorer, nous voyons que ce n'est pas un vrai portable, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mineur XMRig</a> Monero. <br><br><img src="https://habrastorage.org/webt/xj/st/jn/xjstjnrjz3pq90ujlsn1iulrsmu.png"><br><br>  Donc, pour le moment, nous sommes sûrs que l'image de l'ordinateur portable en mémoire a probablement été remplacée par la méthode RunPE (Process Hollowing). <br><br>  Le compte-gouttes principal est de 32 bits, mais déplace la charge utile vers un ordinateur portable 64 bits: <br><br><img src="https://habrastorage.org/webt/ks/tq/3f/kstq3f74qii0rguaotcf4ng0hls.png"><br><br>  Plus intéressant, ce type d'injection n'est pas pris en charge par l'API Windows officielle.  Nous pouvons lire / écrire dans la mémoire des processus 32 bits à partir d'une application 64 bits (en utilisant l'API WoW64), mais pas l'inverse. <br><br>  Cependant, il existe des solutions non officielles, comme une technique appelée «Heaven's Gate». <br><br><h3>  Critique de Heaven's Gate </h3><br>  La technique Heaven's Gate a été décrite pour la première fois en 2009 par un hacker avec le surnom de Roy G. Biv.  Plus tard, de nombreuses implémentations ont été créées, par exemple, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wow64ext</a> ou, sur cette base, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">W64oWoW64</a> .  Dans son blog de 2015, Alex Ionescu a décrit les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mesures de lutte contre cette technique</a> . <br>  Voyons comment cela fonctionne. <br><br><h3>  Exécution de processus 32 bits sur Windows 64 bits </h3><br>  Chaque processus 32 bits exécuté sur une version 64 bits de Windows s'exécute sur un sous-système spécial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WoW64</a> qui émule un environnement 32 bits.  Vous pouvez tracer une analogie avec un sandbox 32 bits créé dans un processus 64 bits.  Tout d'abord, un environnement de processus 64 bits est créé.  Et déjà à l'intérieur, un environnement 32 bits est créé.  L'application s'exécute dans cet environnement 32 bits, mais n'a pas accès à sa partie 64 bits. <br><br>  Si nous analysons un processus 32 bits de l'extérieur à l'aide d'un scanner 64 bits, nous verrons qu'il contient à la fois des DLL 32 et 64 bits.  Plus important encore, il a deux versions de NTDLL: 32 bits (chargé à partir du répertoire SysWow64) et 64 bits (chargé à partir du répertoire System32): <br><br><img src="https://habrastorage.org/webt/jp/kq/im/jpkqimhiu4fa-y1w1uwwq1up6ga.png"><br><br>  Cependant, le processus 32 bits lui-même ne voit pas la partie 64 bits et se limite à l'utilisation de DLL 32 bits.  Pour injecter dans un processus 64 bits, vous devez utiliser les versions 64 bits des fonctions correspondantes. <br><br><h3>  Segments de code </h3><br>  Pour accéder à la partie restreinte de l'environnement, nous devons comprendre comment l'isolement se fait.  Il s'avère que tout est assez simple.  L'exécution de code 32 bits et 64 bits est disponible via une adresse de segment de code différente: 32 bits - 0x23 et 64 bits - 0x33. <br><br>  Si nous appelons l'adresse de la manière habituelle, le mode utilisé pour l'interpréter est défini par défaut.  Cependant, nous pouvons explicitement demander une modification à l'aide du code assembleur. <br><br><h3>  À l'intérieur du mineur: mise en œuvre de Heaven's Gate </h3><br>  Je ne procéderai pas à une analyse complète de ce mineur, comme il a déjà été décrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Allons directement à l'endroit où le plaisir commence.  Le programme malveillant vérifie son environnement et s'il détecte qu'il s'exécute sur un système 64 bits, il utilise une méthode différente pour injecter dans le processus 64 bits: <br><br><img src="https://habrastorage.org/webt/gz/kw/ll/gzkwlluwayyv5qawjrd6bngp0-o.png"><br><br>  Après quelques vérifications anti-analyse, il crée un nouveau processus 64 bits suspendu (dans ce cas, un bloc-notes): <br><br><img src="https://habrastorage.org/webt/ey/ne/fj/eynefjkyabjcaqfkrwqc3hm9qe4.png"><br><br>  Il s'agit de la cible dans laquelle la charge malveillante sera implémentée. <br>  Comme nous l'avons appris précédemment, afin d'intégrer la charge utile dans un processus 64 bits, nous devons utiliser les fonctions 64 bits appropriées. <br><br>  Tout d'abord, le chargeur de démarrage passe le traitement NTDLL 64 bits: <br><br><img src="https://habrastorage.org/webt/mo/jj/bw/mojjbw2ddkok1n4weobjayjx4zu.png"><br><br>  Ce qui se passe à l'intérieur de la fonction <code>get_ntdll</code> nécessite une explication plus détaillée.  À titre d'explication, nous pouvons également jeter un œil à un <a href="">code</a> similaire dans la bibliothèque ReWolf. <br><br>  Pour accéder à la partie 64 bits de l'environnement de processus, nous devons travailler avec des sélecteurs de segments.  Voyons comment le malware passe en mode 64 bits. <br><br><img src="https://habrastorage.org/webt/yh/hw/7m/yhhw7mgp_g2ub-y4nqnabhj4vb8.png"><br><br>  Il semble que ce code ait été copié directement à partir de la bibliothèque ouverte: <a href="">https://github.com/rwfpl/rewolf-wow64ext/blob/master/src/internal.h#L26</a> <br><br>  Le sélecteur de segment 0x33 est poussé sur la pile.  Ensuite, le malware appelle la ligne suivante: (de cette manière, l'adresse de la ligne suivante est également poussée sur la pile.) <br><br><img src="https://habrastorage.org/webt/6o/bk/dl/6obkdlrqkdlurnpfrfzlc9axvdw.png"><br><br>  L'adresse qui a été <code>retf</code> pile est fixée en ajoutant 5 octets et est définie après <code>retf</code> : <br><br><img src="https://habrastorage.org/webt/zk/8t/5h/zk8t5hpbn68ngyilrkgldw5gv-g.png"><br><br>  À la fin, l'instruction RETF est appelée.  RETF est un «retour lointain» et, contrairement au RET normal, il vous permet de spécifier non seulement l'adresse à partir de laquelle vous souhaitez continuer l'exécution, mais également un segment.  Comme arguments, il prend deux DWORD de la pile.  Ainsi, lorsque RETF est exécuté, l'adresse de retour de retour devient: <br><br>  <b>0x33: 0x402A50</b> <br><br>  Grâce au segment modifié, le code commençant à l'adresse spécifiée est interprété comme 64 bits.  Ainsi, le code que le débogueur voit est 32 bits ... <br><br><img src="https://habrastorage.org/webt/kw/h8/7t/kwh87tqwggznnqzoxjf8elqt9ds.png"><br><br>  ... en fait 64 bits. <br><br>  Pour changer rapidement de vue, j'utilise la fonction PE-bear: <br><br><img src="https://habrastorage.org/webt/t0/7o/_w/t07o_w2ib83ptd1gfnldc0cposg.png"><br><br>  Et voici à quoi ressemble ce morceau de code s'il est interprété comme 64 bits: <br><br><img src="https://habrastorage.org/webt/c8/a2/1d/c8a21dbp7ot9hzx3ipb5-jkwhfo.png"><br><br>  Ainsi, le code qui est exécuté ici est responsable du déplacement du contenu du registre R12 vers une variable de la pile, puis repasse en mode 32 bits.  Ceci est fait afin d'obtenir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bloc d'informations sur les threads (TEB)</a> 64 bits, à partir duquel nous obtenons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bloc d'environnement de processus (PEB)</a> 64 bits à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> - nous examinons un <a href="">code similaire</a> . <br><br>  Un PEB 64 bits est utilisé comme point de départ pour rechercher une version 64 bits de NTDLL.  Cette partie est implémentée de manière assez <a href="">triviale</a> (une implémentation «vanille» de cette méthode peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), en utilisant un pointeur vers les bibliothèques chargées, qui sont l'un des champs de la structure PEB.  Donc, de PEB, nous obtenons un champ appelé <i>Ldr</i> : <br><br><img src="https://habrastorage.org/webt/y-/fi/v-/y-fiv-utn-eenbgynck30v3rxp4.png"><br><br>  <b><i>Ldr</i></b> est une structure de type <code>_PEB_LDR_DATA</code> .  Il contient une entrée appelée <code>InMemoryOrderModuleList</code> : <br><br><img src="https://habrastorage.org/webt/ri/oi/hk/rioihkllxtn7jcj_rs0i39jpegs.png"><br><br>  Cette liste contient toutes les bibliothèques chargées qui sont présentes dans la mémoire du processus à l'étude.  Nous parcourons la liste jusqu'à ce que nous trouvions la bibliothèque qui nous intéresse, dans notre cas c'est NTDLL.  C'est exactement ce que fait la fonction <code>get_ntdll</code> ci-dessus.  Pour trouver un nom approprié, il appelle la fonction suivante, désignée <code>is_ntdll_lib</code> , qui vérifie le nom de la bibliothèque par rapport à ntdll.dll par caractères.  L'équivalent de <a href="">ce</a> code s'avère. <br><br><img src="https://habrastorage.org/webt/se/zc/e9/sezce9ivnb5hccvl5gahlmnveqg.png"><br><br>  Si les noms correspondent, l'adresse de la bibliothèque est renvoyée dans deux registres: <br><br><img src="https://habrastorage.org/webt/as/_r/mo/as_rmojmqloqtgrbwwoh7cnafpi.png"><br><br>  Une fois que nous avons trouvé NTDLL, nous avons juste besoin d'obtenir les adresses des fonctions correspondantes.  Nous pouvons le faire en regardant la table d'exportation de la bibliothèque: <br><br><img src="https://habrastorage.org/webt/jl/oa/mm/jloamm2asyt0a3-xbwqnpawmwic.png"><br><br>  Les fonctions suivantes sont récupérées: <br><br><ul><li>  <i>NttUnmapViewOfSection</i> </li><li>  <i>NtGetContextThread</i> </li><li>  <i>NtAllocateVirtualMemory</i> </li><li>  <i>NtReadVirtualMemory</i> </li><li>  <i>NtWriteVirtualMemory</i> </li><li>  <i>NtSetContextThread.</i> </li></ul><br>  Comme nous le savons, ces fonctions sont typiques de la technique RunPE.  Tout d'abord, NtUnmapViewOfSection est utilisé pour démapper le fichier PE d'origine.  Ensuite, dans le processus distant, la mémoire est allouée et un nouveau PE est écrit.  À la fin, le contexte du processus est modifié de sorte que l'exécution commence à partir du module intégré. <br><br>  Les adresses de fonction sont stockées et appelées ultérieurement (de manière similaire à <a href="">ce</a> code) pour contrôler le processus distant. <br><br><h3>  Conclusion </h3><br>  Jusqu'à présent, les auteurs de mineurs n'ont pas fait preuve de beaucoup de créativité.  Ils atteignent leurs objectifs en s'appuyant sur des composants open source.  Le cas décrit reflète bien cette tendance, car une mise en œuvre prête à l'emploi a été utilisée. <br><br>  Heaven's Gate existe depuis plusieurs années.  Certains programmes malveillants l'utilisent pour augmenter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">furtivité</a> .  Mais dans le cas de ce mineur, les auteurs ont probablement cherché plutôt à maximiser les performances en utilisant la charge utile qui correspond le mieux à l'architecture cible. <br><br>  C’est tout.  Vous pouvez en savoir plus sur notre cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467193/">https://habr.com/ru/post/fr467193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467183/index.html">Étude des 50 meilleures plateformes de chat bot et assistants virtuels en 2019</a></li>
<li><a href="../fr467185/index.html">Descente en pente</a></li>
<li><a href="../fr467187/index.html">Créer la dernière bibliothèque technologique</a></li>
<li><a href="../fr467189/index.html">Échantillonnage de température</a></li>
<li><a href="../fr467191/index.html">Comment nous avons créé Vivaldi pour Android</a></li>
<li><a href="../fr467197/index.html">Comment le polymorphisme est implémenté dans la JVM</a></li>
<li><a href="../fr467199/index.html">Journal de Tom Hunter: Le chien des Baskerville</a></li>
<li><a href="../fr467201/index.html">Expérience CacheBrowser: Contournement d'un pare-feu chinois sans proxy à l'aide de la mise en cache de contenu</a></li>
<li><a href="../fr467203/index.html">Juste la division, ou comment créer une théorie mathématique et y gagner 400 000 $. Deuxième série, avant-dernière</a></li>
<li><a href="../fr467205/index.html">Nous développons une application qui envoie des données vers d'autres applications (application écosystème)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>