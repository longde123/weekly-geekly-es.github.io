<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾 🈯️ 👨🏿‍🎤 Permintaan-Respons Sinkron menggunakan Apache Kafka ⛏️ 👩🏻‍🤝‍👨🏿 ⚜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Arsitektur Event Driven pada umumnya, dan Apache Kafka pada khususnya, telah menarik banyak perhatian baru-baru ini. Untuk mengambil keuntungan penuh ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Permintaan-Respons Sinkron menggunakan Apache Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476156/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Event Driven</a> pada umumnya, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Kafka</a> pada khususnya, telah menarik banyak perhatian baru-baru ini.  Untuk mengambil keuntungan penuh dari arsitektur yang digerakkan oleh peristiwa, mekanisme pendelegasian acara harus pada dasarnya tidak sinkron.  Namun, mungkin ada beberapa skenario penggunaan khusus / aliran yang memerlukan semantik dari <b>Permintaan-Respons Sinkron</b> .  Rilis ini menunjukkan bagaimana menerapkan <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan-Respons</a></b> menggunakan <b>Apache Kafka</b> . <br><br>  Diterjemahkan oleh <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@middle_java</a></b> <br><a name="habracut"></a><br>  Tanggal artikel asli: 26 Oktober 2018 <br><br>  Apache Kafka secara inheren tidak sinkron.  Oleh karena itu, semantik <b>Permintaan-Respons</b> untuk Apache Kafka tidak wajar.  Namun, tantangan ini bukanlah hal baru.  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan-Balas</a></b> Pola Integrasi Perusahaan menyediakan mekanisme yang terbukti untuk pesan sinkron melalui saluran asinkron: <br><br><img src="https://habrastorage.org/webt/ww/cy/0h/wwcy0hvrj6iie7amwxpk1twfbui.gif"><br><br>  Pola <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alamat Pengembalian</a></b> melengkapi pola <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan-Balas</a></b> dengan mekanisme bagi pemohon untuk menunjukkan alamat yang harus dikirimi respons: <br><br><img src="https://habrastorage.org/webt/rw/nd/qq/rwndqqxh42kt82xadcbvgjb76wa.gif"><br><br>  Baru-baru ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Kafka</a> <b>2.1.3</b> menambahkan dukungan dari kotak pola “Request Reply”, dan dalam versi <b>2.2</b> beberapa kekasarannya telah dipoles.  Mari kita lihat bagaimana dukungan ini bekerja: <br><br><h2>  Sisi Klien: ReplyingKafkaTemplate </h2><br>  Abstraksi <b>Templat yang terkenal ini</b> membentuk dasar bagi bagian klien dari mekanisme Permintaan-Jawab di Musim Semi. <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; replyKafkaTemplate( ProducerFactory &lt; String, Request &gt; pf, KafkaMessageListenerContainer &lt; String, Reply &gt; lc) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplyingKafkaTemplate &lt; &gt; (pf, lc); }</code> </pre> <br>  Semuanya sangat mudah di sini: kami menyiapkan <b>ReplyingKafkaTemplate</b> , yang mengirim pesan permintaan dengan kunci String dan menerima pesan respons dengan kunci String.  Namun, ReplyingKafkaTemplate harus didasarkan pada Permintaan ProducerFactory, Respons ConsumerFactory, dan MessageListenerContainer dengan konfigurasi konsumen dan produsen yang sesuai.  Oleh karena itu, konfigurasi yang diperlukan cukup berat: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Request &gt; requestProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Reply &gt; replyConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Reply &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, Reply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties); }</code> </pre> <br>  Dalam hal ini, menggunakan <b>replyKafkaTemplate</b> untuk mengirim permintaan sinkron dan menerima respons adalah sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String requestTopic; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... RequestReply request = RequestReply.request(...); <span class="hljs-comment"><span class="hljs-comment">// producer record ProducerRecord &lt; String, Request &gt; record = new ProducerRecord &lt; String, Request &gt; (requestTopic, request); //       record.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); //     Kafka          RequestReplyFuture &lt; String, Request, Reply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); sendAndReceive.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; String, Reply &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; String, Reply &gt; result) { //   consumer record Reply reply = result.value(); System.out.println("Reply: " + reply.toString()); } });</span></span></code> </pre> <br>  Ada juga banyak boilerplate dan API tingkat rendah, dan bahkan API <b>ListenableFuture yang</b> usang ini bukan <b>CompletableFuture</b> modern. <br><br>  <b>requestReplyKafkaTemplate</b> menangani pembuatan dan pengaturan tajuk <b>KafkaHeaders.CORRELATION_ID</b> , tetapi kami harus menetapkan tajuk <b>KafkaHeaders.REPLY_TOPIC</b> secara eksplisit untuk permintaan tersebut.  Harap perhatikan juga bahwa topik yang sama untuk jawaban itu terlalu tidak disengaja di atas di <b>replyListenerContainer</b> .  Beberapa kotoran.  Tidak seperti yang saya harapkan dari abstraksi Spring. <br><br><h2>  Sisi Server: @KirimKe </h2><br>  Di sisi server, <b>KafkaListener yang</b> biasa mendengarkan topik untuk permintaan juga dihiasi dengan penjelasan <b>@ SendTo</b> untuk memberikan pesan respons.  Objek yang dikembalikan oleh metode pendengar secara otomatis dibungkus dengan pesan respons, <b>CORRELATION_ID</b> ditambahkan <b>,</b> dan responsnya diterbitkan dalam topik yang ditentukan dalam tajuk <b>REPLY_TOPIC</b> . <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Request &gt; requestConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Request &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory &lt; ConcurrentMessageListenerContainer &lt; String, Request &gt;&gt; requestListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory &lt; String, Request &gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory &lt; &gt; (); factory.setConsumerFactory(requestConsumerFactory()); factory.setReplyTemplate(replyTemplate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Reply &gt; replyProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaTemplate &lt; String, Reply &gt; replyTemplate() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate &lt; &gt; (replyProducerFactory()); }</code> </pre> <br>  Beberapa konfigurasi juga diperlukan di sini, tetapi konfigurasi pendengar lebih sederhana: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(topics = <span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>, containerFactory = <span class="hljs-string"><span class="hljs-string">"requestListenerContainerFactory"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@SendTo</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Reply </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Reply reply = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reply; }</code> </pre> <br><h2>  Tetapi bagaimana dengan beberapa contoh dari konsumen? </h2><br>  Segalanya tampak bekerja sampai kita menggunakan beberapa contoh dari konsumen.  Jika kami memiliki banyak instance klien, kami perlu memastikan bahwa respons dikirim ke instance klien yang benar.  Dokumentasi Spring Kafka mengasumsikan bahwa setiap konsumen dapat menggunakan topik unik atau bahwa nilai header <b>KafkaHeaders</b> tambahan dikirim dengan permintaan tersebut. <b>RESPONSE_PARTITION</b> adalah bidang empat byte yang berisi representasi BIG-ENDIAN dari nomor bagian integer.  Menggunakan topik terpisah untuk klien yang berbeda jelas tidak terlalu fleksibel, jadi kami memilih pengaturan <b>REPLY_PARTITION</b> eksplisit.  Maka klien harus tahu ke partisi mana ia ditugaskan.  Dokumentasi menyarankan menggunakan konfigurasi eksplisit untuk memilih partisi tertentu.  Mari tambahkan ke contoh kita: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply.partition}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> replyPartition; ... <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, RequestReply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); TopicPartitionInitialOffset initialOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopicPartitionInitialOffset(replyTopic, replyPartition); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties, initialOffset); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } ... record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition))); RequestReplyFuture &lt; String, RequestReply, RequestReply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); ...</code> </pre> <br>  Tidak terlalu cantik, tetapi berhasil.  Konfigurasi yang diperlukan luas dan API terlihat tingkat rendah.  Kebutuhan untuk secara eksplisit mengkonfigurasi partisi mempersulit proses penskalaan jumlah klien secara dinamis.  Jelas, Anda bisa melakukan yang lebih baik. <br><br><h2>  Enkapsulasi pemrosesan topik untuk respons dan partisi </h2><br>  Mari kita mulai dengan merangkum pola <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alamat Pengembalian</a></b> , meneruskan topik untuk respons dan partisi.  Topik untuk respons harus disuntikkan dalam <b>RequestReplyTemplate</b> dan, oleh karena itu, tidak boleh ada di API sama sekali.  Ketika datang ke partisi untuk jawaban, kami akan melakukan yang sebaliknya: ekstrak partisi yang ditugaskan untuk pendengar topik untuk jawabannya, dan transfer partisi ini secara otomatis.  Ini menghilangkan kebutuhan klien untuk mengurus tajuk ini. <br>  Pada saat yang sama, mari kita juga membuat API terlihat seperti standar <b>KafkaTemplate</b> (membebani metode <b>sendAndReceive () dengan</b> parameter yang disederhanakan dan menambahkan metode kelebihan beban yang sesuai menggunakan topik default): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopicPartition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstAssignedReplyTopicPartition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getAssignedReplyTopicPartitions() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; getAssignedReplyTopicPartitions().iterator().hasNext()) { TopicPartition replyPartition = getAssignedReplyTopicPartitions().iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.isDebugEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.debug(<span class="hljs-string"><span class="hljs-string">"Using partition "</span></span> + replyPartition.partition()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> replyPartition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaException(<span class="hljs-string"><span class="hljs-string">"Illegal state: No reply partition is assigned to this instance"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(<span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), key, data); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, key, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } ... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(ProducerRecord &lt; K, V &gt; record) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> RequestReplyFuture &lt; K, V, R &gt; doSendAndReceive(ProducerRecord &lt; K, V &gt; record) { TopicPartition replyPartition = getFirstAssignedReplyTopicPartition(); record.headers() .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, replyPartition.topic().getBytes())) .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition.partition()))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.sendAndReceive(record); } }</code> </pre> <br>  Langkah selanjutnya: Menyesuaikan <b>Future</b> yang Dapat <b>Didengarkan</b> ke <b>CompletableFuture yang</b> lebih modern. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFuture &lt; R &gt; adapt(RequestReplyFuture &lt; K, V, R &gt; requestReplyFuture) { CompletableFuture &lt; R &gt; completableResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture &lt; R &gt; () { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mayInterruptIfRunning)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = requestReplyFuture.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; <span class="hljs-comment"><span class="hljs-comment">//       requestReplyFuture.getSendFuture().addCallback(new ListenableFutureCallback &lt; SendResult &lt; K, V &gt;&gt; () { @Override public void onSuccess(SendResult &lt; K, V &gt; sendResult) { // NOOP } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); //     requestReplyFuture.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; K, R &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; K, R &gt; result) { completableResult.complete(result.value()); } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); return completableResult; } }</span></span></code> </pre> <br>  Kami akan mengemas ini ke perpustakaan utilitas dan sekarang kami memiliki API yang jauh lebih konsisten dengan filosofi desain utama Spring, <b>"Convention over Configuration"</b> .  Ini adalah kode klien terakhir: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFutureReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... requestReplyKafkaTemplate.requestReply(request).thenAccept(reply - &gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Reply: "</span></span> + reply.toString()); );</code> </pre> <br><h2>  Untuk meringkas </h2><br>  Untuk meringkas, Spring untuk Kafka 2.2 menyediakan implementasi berfungsi penuh dari pola <b>Permintaan-Balas</b> di Apache Kafka, tetapi API masih memiliki beberapa tepi yang kasar.  Dalam masalah ini, kami melihat bahwa beberapa abstraksi tambahan dan adaptasi API dapat memberikan API tingkat tinggi yang lebih logis. <br><br>  <b>Peringatan 1:</b> <br>  Salah satu keuntungan utama dari arsitektur yang digerakkan oleh peristiwa adalah decoupling antara produsen dan konsumen acara, yang memungkinkan untuk menciptakan sistem yang jauh lebih fleksibel dan berkembang.  Menggunakan semantik sinkron "Permintaan-Respons" adalah kebalikannya ketika pihak yang meminta dan merespons sangat terkait.  Karena itu, harus digunakan hanya jika perlu. <br><br>  <b>Peringatan 2:</b> <br>  Jika <b>Request-Response sinkron</b> diperlukan, maka <b>protokol</b> berbasis <b>HTTP</b> jauh lebih sederhana dan lebih efisien daripada menggunakan <b>saluran asinkron seperti Apache Kafka</b> . <br>  Namun, mungkin ada skenario di mana <b>Permintaan-Respons sinkron melalui Kafka</b> masuk akal.  Cukup pilih alat terbaik untuk pekerjaan itu. <br><br>  Contoh yang berfungsi penuh dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/callistaenterprise/blog-synchronous-kafka</a> . <br><br><h2>  Komentar </h2><br>  <i>Federico • 7 bulan lalu</i> <br>  Dan ketika kita memiliki kebutuhan hibrid, misalnya, dalam 50% kasus kita membutuhkan Permintaan-Respons dan dalam 50% kita membutuhkan manajemen acara?  Bagaimana kita melakukan ini?  Konfigurasi yang dibutuhkan oleh Spring Kafka terlihat sangat buruk. <br><br>  <i>Jehanzeb Qayyum • 6 bulan lalu</i> <br>  Spring sekarang memiliki dukungan default menggunakan partisi dalam satu topik umum untuk respons. <br><br>  Dimulai dengan versi 2.2, templat mencoba menentukan topik respons atau partisi dari wadah respons yang dikonfigurasi (wadah balasan). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.spring.io/spring-kafka/reference/html/#replying-template</a> <br><br>  <i>nir rozenberg • 8 bulan lalu</i> <br>  Hai <br>  Dalam paragraf terakhir, Anda menulis bahwa mungkin ada skenario ketika Permintaan-Respons sinkron melalui Kafka masuk akal dibandingkan dengan HTTP. <br>  Bisakah Anda memberikan contoh skenario seperti itu? <br>  Terima kasih <br>  Nir <br><br>  <i>Janne Keskitalo nir rozenberg • 8 bulan lalu</i> <br>  Kami akan membagi sistem pemrosesan transaksi volume besar menjadi beberapa layanan microser, dan saya punya ide untuk menggunakan pesan Permintaan-Respons Kafka untuk mencapai afinitas pemrosesan yang serupa.  Pada dasarnya, Kafka digunakan untuk merutekan semua panggilan dari satu klien ke proses prosesor transaksi yang sama, yang kemudian secara berurutan mengeksekusi mereka satu per satu.  Jenis pemrosesan ini memastikan kemampuan linieritas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/a/19515375/7430325</a> ), konektivitas kausal, dan juga memungkinkan caching yang efisien.  Pada dasarnya, upaya koordinasi akan ditransfer dari database ke Kafka, dan kami dapat memulai database dalam mode isolasi ketat Serializable. <br>  Saya belum menyelidiki rincian semantik transaksi kami untuk melihat di mana itu gagal, jadi ini hanya sebuah ide. <br><br>  Diterjemahkan oleh <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476156/">https://habr.com/ru/post/id476156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476140/index.html">Bagaimana cara meningkatkan mendengarkan jika Anda tahu 7000 kata tetapi tidak memahaminya secara langsung?</a></li>
<li><a href="../id476142/index.html">Mengapa hindari menggunakan pengecualian untuk mengontrol aliran Anda di Java</a></li>
<li><a href="../id476144/index.html">Apa yang Anda butuhkan dan tidak perlu menulis obrolan untuk bot menggunakan contoh bot saya untuk bermain Secret Santa</a></li>
<li><a href="../id476146/index.html">Bagaimana skala pusat data. Laporan Yandex</a></li>
<li><a href="../id476148/index.html">postfix + dovecot + mysql di FreeBSD</a></li>
<li><a href="../id476160/index.html">Kelahiran perangkat lunak pendidikan dan sejarahnya: dari mesin mekanik ke komputer pertama</a></li>
<li><a href="../id476162/index.html">Kami membuat aplikasi web modern. Kenalan dengan proyek dan persiapan untuk bekerja. Bagian 1</a></li>
<li><a href="../id476164/index.html">"Ini juga analisis data." Bicara tentang bioinformatika dengan Mikhail Gelfand</a></li>
<li><a href="../id476166/index.html">"Real Iron Man" memecahkan rekor kecepatan penerbangan</a></li>
<li><a href="../id476172/index.html">Konferensi BLACK HAT USA. Kaya atau mati: hasilkan uang di Internet menggunakan Black Hat. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>