<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∑ üë®üèø‚Äçüéì ü§òüèΩ Es reicht nicht aus, Polygone zu z√§hlen, um 3D-Modelle zu optimieren üôçüèª ü§ü üéÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem Sie die Grundlagen des Mesh-Rendering-Prozesses verstanden haben, k√∂nnen Sie verschiedene Techniken anwenden, um die Rendering-Geschwindigkeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Es reicht nicht aus, Polygone zu z√§hlen, um 3D-Modelle zu optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433186/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png" alt="Bild"></div><br>  Nachdem Sie die Grundlagen des Mesh-Rendering-Prozesses verstanden haben, k√∂nnen Sie verschiedene Techniken anwenden, um die Rendering-Geschwindigkeit zu optimieren. <br><br><h2>  Einf√ºhrung </h2><br>  Wie viele Polygone kann ich verwenden?  Dies ist eine sehr h√§ufige Frage, die K√ºnstler beim Erstellen von Modellen f√ºr das Echtzeit-Rendering stellen.  Diese Frage ist schwer zu beantworten, da es nicht nur um Zahlen geht. <br><br>  Ich begann meine Karriere als 3D-K√ºnstler in der √Ñra der ersten PlayStation und wurde sp√§ter Grafikprogrammierer.  Ich m√∂chte diesen Artikel lesen, bevor ich anfing, 3D-Modelle f√ºr Spiele zu erstellen.  Die darin ber√ºcksichtigten grundlegenden Grundlagen sind f√ºr viele K√ºnstler n√ºtzlich.  Obwohl die meisten Informationen in diesem Artikel die Produktivit√§t Ihrer t√§glichen Arbeit nicht wesentlich beeinflussen, erhalten Sie ein grundlegendes Verst√§ndnis daf√ºr, wie die Grafikverarbeitungseinheit (GPU) die von Ihnen erstellten Netze rendert. <br><br>  Die Geschwindigkeit des Renderns h√§ngt normalerweise von der Anzahl der Polygone im Netz ab.  Obwohl die Anzahl der Polygone h√§ufig mit der Bildrate pro Sekunde (FPS) korreliert, k√∂nnen Sie feststellen, dass das Netz auch nach dem Reduzieren der Anzahl der Polygone immer noch langsam gerendert wird.  Wenn Sie jedoch verstehen, wie Netze im Allgemeinen gerendert werden, k√∂nnen Sie eine Reihe von Techniken anwenden, um die Rendergeschwindigkeit zu erh√∂hen. <br><a name="habracut"></a><br><h2>  Wie Polygondaten dargestellt werden </h2><br>  Um zu verstehen, wie die GPU Polygone zeichnet, m√ºssen Sie zun√§chst die Datenstruktur ber√ºcksichtigen, die zur Beschreibung der Polygone verwendet wird.  Ein Polygon besteht aus einer Reihe von Punkten, die als Eckpunkte und Verkn√ºpfungen bezeichnet werden.  Scheitelpunkte werden h√§ufig wie beispielsweise in Abbildung 1 als Arrays von Werten gespeichert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb1/c94/4ffcb1c945c51025a430d752e475b1c3.png"></div><br>  <i>Abbildung 1. Ein Array einfacher Polygonwerte.</i> <br><br>  In diesem Fall ergeben vier Eckpunkte in drei Dimensionen (x, y und z) 12 Werte.  Um Polygone zu erstellen, beschreibt das zweite Wertearray die Scheitelpunkte selbst, wie in Abbildung 2 dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/1c9/3eb/01d1c93eb3645689d0d30de75b0ea524.png"></div><br>  <i>Abbildung 2. Eine Reihe von Verkn√ºpfungen zu den Scheitelpunkten.</i> <br><br>  Diese miteinander verbundenen Eckpunkte bilden zwei Polygone.  Beachten Sie, dass zwei Dreiecke mit jeweils drei Winkeln durch vier Eckpunkte beschrieben werden k√∂nnen, da die Eckpunkte 1 und 2 in beiden Dreiecken verwendet werden.  Damit die GPU diese Daten verarbeiten kann, wird angenommen, dass jedes Polygon dreieckig ist.  GPUs erwarten, dass Sie mit Dreiecken arbeiten, da diese speziell zum Zeichnen entwickelt wurden.  Wenn Sie Polygone mit einer anderen Anzahl von Scheitelpunkten zeichnen m√ºssen, ben√∂tigen Sie eine Anwendung, die sie vor dem Rendern auf der GPU in Dreiecke unterteilt.  Wenn Sie beispielsweise einen W√ºrfel mit sechs Polygonen erstellen, von denen jedes vier Seiten hat, ist dies nicht effektiver als das Erstellen eines W√ºrfels mit 12 Polygonen, die aus drei Seiten bestehen.  Es sind diese Dreiecke, die die GPU zeichnen wird.  Denken Sie an die Regel: Sie m√ºssen nicht Polygone, sondern Dreiecke z√§hlen. <br><br>  Die im vorherigen Beispiel verwendeten Scheitelpunktdaten sind dreidimensional, dies ist jedoch nicht erforderlich.  Zwei Dimensionen m√∂gen f√ºr Sie ausreichend sein, aber h√§ufig m√ºssen Sie andere Daten speichern, z. B. UV-Koordinaten f√ºr Texturen und Normal f√ºr die Beleuchtung. <br><br><h2>  Polygonzeichnung </h2><br>  Beim Rendern eines Polygons bestimmt die GPU zun√§chst, wo das Polygon gezeichnet werden soll.  Dazu berechnet er die Position auf dem Bildschirm, an der sich die drei Eckpunkte befinden sollen.  Diese Operation wird als Transformation bezeichnet.  Diese Berechnungen in der GPU werden von einem kleinen Programm namens Vertex Shader durchgef√ºhrt. <br><br>  Der Vertex-Shader f√ºhrt h√§ufig andere Arten von Operationen aus, z. B. das Verarbeiten von Animationen.  Nach der Berechnung der Positionen aller drei Eckpunkte des Polygons berechnet die GPU, welche Pixel sich in diesem Dreieck befinden, und beginnt dann, diese Pixel mit einem anderen kleinen Programm namens ‚ÄûFragment Shader‚Äú (Fragment Shader) zu f√ºllen.  Ein Fragment-Shader wird normalerweise einmal pro Pixel ausgef√ºhrt.  In einigen seltenen F√§llen kann es jedoch mehrmals pro Pixel ausgef√ºhrt werden, um beispielsweise das Anti-Aliasing zu verbessern.  Fragment-Shader werden h√§ufig als Pixel-Shader bezeichnet, da Fragmente in den meisten F√§llen Pixeln entsprechen (siehe Abbildung 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/5e6/4cc/16c5e64cc4daec8ceef7264fce4b8a08.png"></div><br>  <i>Abbildung 3. Ein auf dem Bildschirm gezeichnetes Polygon.</i> <br><br>  Abbildung 4 zeigt die Abfolge der Aktionen, die die GPU beim Rendern des Polygons ausf√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/c60/8d2/87cc608d2ac63afc4c818b824bc11fb5.png"></div><br>  <i>Abbildung 4. Die Reihenfolge der GPU, die das Polygon rendert.</i> <br><br>  Wenn Sie das Dreieck in zwei Teile teilen und beide Dreiecke zeichnen (siehe Abbildung 5), entspricht das Verfahren Abbildung 6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/34a/521/19a34a521bdd7ace482a8a1defb8c926.png"></div><br>  <i>Abbildung 5. Aufteilung des Polygons in zwei Teile.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/16c/07c/d0c16c07ce793e36aaa40e237ad60d78.png"></div><br>  <i>Abbildung 6. Vorgehensweise beim Zeichnen von zwei Polygonen durch die GPU.</i> <br><br>  In diesem Fall sind doppelt so viele Transformationen und Vorbereitungen erforderlich. Da jedoch die Anzahl der Pixel gleich bleibt, m√ºssen bei der Operation keine zus√§tzlichen Pixel gerastert werden.  Dies zeigt, dass das Verdoppeln der Anzahl der Polygone nicht unbedingt die Renderzeit verdoppelt. <br><br><h2>  Vertex-Cache verwenden </h2><br>  Wenn Sie sich die beiden Polygone aus dem vorherigen Beispiel ansehen, sehen Sie, dass sie zwei gemeinsame Eckpunkte haben.  Es kann davon ausgegangen werden, dass diese Scheitelpunkte zweimal berechnet werden m√ºssen. Mit einem Mechanismus, der als Scheitelpunkt-Cache bezeichnet wird, k√∂nnen Sie die Berechnungsergebnisse jedoch wiederverwenden.  Die Ergebnisse der Vertex-Shader-Berechnungen f√ºr die Wiederverwendung werden im Cache gespeichert, einem kleinen Speicherbereich, der die letzten Vertices enth√§lt.  Das Verfahren zum Zeichnen von zwei Polygonen mithilfe des Vertex-Cache ist in Abbildung 7 dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/272/d4a/4f0272d4aed10e3805af75688282cdc2.png"></div><br>  <i>Abbildung 7. Zeichnen von zwei Polygonen mithilfe des Scheitelpunktcaches</i> <br><br>  Dank des Scheitelpunkt-Cache k√∂nnen Sie zwei Polygone fast so schnell wie eines zeichnen, wenn sie gemeinsame Scheitelpunkte haben. <br><br><h2>  Wir besch√§ftigen uns mit den Parametern der Eckpunkte </h2><br>  Damit der Scheitelpunkt wiederverwendbar ist, muss er bei jeder Verwendung unver√§ndert bleiben.  Nat√ºrlich sollte die Position gleich bleiben, aber auch andere Parameter sollten sich nicht √§ndern.  Die nach oben √ºbergebenen Parameter h√§ngen vom verwendeten Motor ab.  Hier sind zwei allgemeine Parameter: <br><br><ul><li>  Texturkoordinaten </li><li>  Normal </li></ul><br>  Wenn UV-Strahlung auf ein 3D-Objekt angewendet wird, bedeutet jede erstellte Naht, dass die Scheitelpunkte entlang der Naht nicht gemeinsam genutzt werden k√∂nnen.  Daher sollten im allgemeinen Fall N√§hte vermieden werden (siehe Abbildung 8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8b/75d/854/c8b75d85471cc476ba6e6f8a9425c7a7.png"></div><br>  <i>Abbildung 8. UV-Nahttextur.</i> <br><br>  F√ºr eine ordnungsgem√§√üe Beleuchtung der Oberfl√§che speichert jeder Scheitelpunkt normalerweise eine Normale - einen von der Oberfl√§che gerichteten Vektor.  Aufgrund der Tatsache, dass alle Polygone mit einem gemeinsamen Scheitelpunkt durch eine Normale definiert sind, scheint ihre Form glatt zu sein.  Dies wird als glatte Schattierung bezeichnet.  Wenn jedes Dreieck seine eigenen Normalen hat, werden die Kanten zwischen den Polygonen ausgepr√§gt und die Oberfl√§che erscheint flach.  Daher wird dies als flach schattiert bezeichnet.  Abbildung 9 zeigt zwei identische Netze, eines mit glatter Schattierung und das andere mit flacher Schattierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/ee3/41f/379ee341f3720b32dba0d4b753c88b98.png"></div><br>  <i>Abbildung 9. Vergleich von glatter mit flacher Schattierung.</i> <br><br>  Diese glatt schattierte Geometrie besteht aus 18 Dreiecken und hat 16 gemeinsame Eckpunkte.  F√ºr die flache Schattierung von 18 Dreiecken sind 54 (18 x 3) Scheitelpunkte erforderlich, da keiner der Scheitelpunkte gemeinsam genutzt wird.  Selbst wenn zwei Netze die gleiche Anzahl von Polygonen haben, ist ihre Rendergeschwindigkeit immer noch unterschiedlich. <br><br><h2>  Bedeutung der Form </h2><br>  GPUs arbeiten schnell, haupts√§chlich weil sie viele Operationen parallel ausf√ºhren k√∂nnen.  GPU-Marketingmaterialien konzentrieren sich h√§ufig auf die Anzahl der Pipelines, die bestimmen, wie viele GPUs gleichzeitig arbeiten k√∂nnen.  Wenn die GPU das Polygon zeichnet, haben viele Pipelines die Aufgabe, die Pixelquadrate zu f√ºllen.  Dies ist normalerweise ein Quadrat von acht mal acht Pixeln.  Die GPU tut dies so lange, bis alle Pixel voll sind.  Offensichtlich sind die Dreiecke keine Quadrate, daher befinden sich einige Pixel des Quadrats innerhalb des Dreiecks und andere au√üerhalb.  Die Ausr√ºstung funktioniert mit allen Pixeln in einem Quadrat, auch mit Pixeln au√üerhalb des Dreiecks.  Nach der Berechnung aller Eckpunkte im Quadrat verwirft das Ger√§t die Pixel au√üerhalb des Dreiecks. <br><br>  Abbildung 10 zeigt ein Dreieck, f√ºr dessen Zeichnen drei Quadrate (Kacheln) erforderlich sind.  Die meisten berechneten Pixel (Cyan) werden verwendet, und die rot dargestellten Pixel √ºberschreiten die Grenzen des Dreiecks und werden verworfen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/c2e/262/74bc2e262019ac7b5f488babc01d7298.png"></div><br>  <i>Abbildung 10. Drei Kacheln zum Zeichnen eines Dreiecks.</i> <br><br>  Das Polygon in Abbildung 11 mit genau der gleichen Anzahl von Pixeln, jedoch gestreckt, erfordert mehr Kacheln zum F√ºllen.  Die meisten Ergebnisse in jeder Kachel (roter Bereich) werden verworfen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/a9e/286/9d0a9e28607c023f81928ea60c8c386a.png"></div><br>  <i>Abbildung 11. F√ºllen von Kacheln in einem gestreckten Bild.</i> <br><br>  Die Anzahl der gerenderten Pixel ist nur einer der Faktoren.  Die Form des Polygons ist ebenfalls wichtig.  Vermeiden Sie zur Steigerung der Effizienz lange, schmale Polygone und bevorzugen Sie Dreiecke mit ungef√§hr gleichen Seitenl√§ngen, deren Winkel nahe bei 60 Grad liegen.  Die beiden flachen Fl√§chen in Abbildung 12 sind auf zwei verschiedene Arten trianguliert, sehen jedoch beim Rendern gleich aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/5d0/965/6075d0965cddfabc1a639bc58b476bb1.png"></div><br>  <i>Abbildung 12. Auf zwei verschiedene Arten triangulierte Oberfl√§chen.</i> <br><br>  Sie haben genau die gleiche Anzahl von Polygonen und Pixeln, aber da die Oberfl√§che der linken Seite l√§ngere, schmalere Polygone als die rechte hat, wird sie langsamer gerendert. <br><br><h2>  Neu zeichnen </h2><br>  Um einen sechszackigen Stern zu zeichnen, k√∂nnen Sie ein Netz aus 10 Polygonen erstellen oder dieselbe Form aus nur zwei Polygonen zeichnen, wie in Abbildung 13 dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/86b/dff/55386bdffeaeabbedb9bda0a913f2dda.png"></div><br>  <i>Abbildung 13. Zwei verschiedene M√∂glichkeiten zum Rendern eines sechszackigen Sterns.</i> <br><br>  Sie k√∂nnen entscheiden, dass das Zeichnen von zwei Polygonen schneller als 10 ist. In diesem Fall ist dies jedoch h√∂chstwahrscheinlich falsch, da die Pixel in der Mitte des Sterns zweimal gezeichnet werden.  Dieses Ph√§nomen wird als √úberziehung bezeichnet.  Im Wesentlichen bedeutet dies, dass Pixel mehr als einmal neu gezeichnet werden.  Das Neuzeichnen erfolgt nat√ºrlich w√§hrend des gesamten Rendervorgangs.  Wenn ein Zeichen beispielsweise teilweise von einer Spalte ausgeblendet wird, wird es vollst√§ndig gezeichnet, obwohl die Spalte einen Teil des Zeichens √ºberlappt.  Einige Engines verwenden komplexe Algorithmen, um das Rendern von Objekten zu vermeiden, die im endg√ºltigen Bild nicht sichtbar sind. Dies ist jedoch eine schwierige Aufgabe.  Die CPU ist oft schwieriger herauszufinden, was nicht gerendert werden muss, als die GPU, um es zu zeichnen. <br><br>  Als K√ºnstler m√ºssen Sie sich damit abfinden, dass Sie das Neulackieren nicht loswerden k√∂nnen. Es empfiehlt sich jedoch, nicht sichtbare Oberfl√§chen zu entfernen.  Wenn Sie mit einem Entwicklungsteam zusammenarbeiten, bitten Sie darum, der Spiel-Engine einen Debugging-Modus hinzuzuf√ºgen, in dem alles transparent wird.  Dies erleichtert das Auffinden versteckter Polygone, die gel√∂scht werden k√∂nnen. <br><br><h2>  Implementierung einer Schublade auf dem Boden </h2><br>  Abbildung 14 zeigt eine einfache Szene: eine Kiste, die auf dem Boden steht.  Der Boden besteht nur aus zwei Dreiecken, und die Box besteht aus 10 Dreiecken.  Das Neuzeichnen in dieser Szene wird rot angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/227/ece/c87227ecea93c82e5870a6c68493bd00.png"></div><br>  <i>Abbildung 14. Eine Schublade auf dem Boden.</i> <br><br>  In diesem Fall zieht die GPU einen Teil des Bodens mit einer Schublade auf den Boden, obwohl er nicht sichtbar ist.  Wenn wir stattdessen ein Loch im Boden unter der Box erzeugt h√§tten, h√§tten wir mehr Polygone erhalten, aber viel weniger neu gezeichnet, wie aus Abbildung 15 ersichtlich ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/1e4/045/2021e4045609645f18c056179196bac0.png"></div><br>  <i>Abbildung 15. Ein Loch unter der Schublade, um ein erneutes Zeichnen zu vermeiden.</i> <br><br>  In solchen F√§llen h√§ngt alles von Ihrer Wahl ab.  Manchmal lohnt es sich, die Anzahl der Polygone zu reduzieren und daf√ºr eine Neuzeichnung zu erhalten.  In anderen Situationen lohnt es sich, Polygone hinzuzuf√ºgen, um ein erneutes Zeichnen zu vermeiden.  Ein weiteres Beispiel: Die beiden unten gezeigten Abbildungen sind gleich aussehende Oberfl√§chennetze, aus denen Punkte herausragen.  Im ersten Netz (Abbildung 16) befinden sich die Spitzen auf der Oberfl√§che. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/436/a65/569436a65cd84150968803a745098129.png"></div><br>  <i>Abbildung 16. Die Spitzen befinden sich auf der Oberfl√§che.</i> <br><br>  Im zweiten Netz in Abbildung 17 werden unter den Spitzen L√∂cher in die Oberfl√§che geschnitten, um das Nachzeichnen zu verringern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/815/692/9c2815692a63c60b9b13fb027405484c.png"></div><br>  <i>Abbildung 17. L√∂cher werden unter den Spitzen ausgeschnitten.</i> <br><br>  In diesem Fall wurden viele Polygone hinzugef√ºgt, um L√∂cher zu schneiden, von denen einige eine schmale Form haben.  Au√üerdem ist die Oberfl√§che der Neuzeichnung, die wir entfernt haben, nicht sehr gro√ü, so dass diese Technik in diesem Fall unwirksam ist. <br><br>  Stellen Sie sich vor, Sie modellieren ein Haus, das auf dem Boden steht.  Um es zu schaffen, k√∂nnen Sie entweder die Erde unver√§ndert lassen oder ein Loch in den Boden unter dem Haus schneiden.  Neu zeichnen ist mehr, wenn das Loch nicht unter dem Haus ausgeschnitten ist.  Die Wahl h√§ngt jedoch von der Geometrie und dem Blickwinkel ab, von dem aus der Spieler das Haus sehen wird.  Wenn Sie Erde unter die Basis des Hauses zeichnen, wird dies zu einer gro√üen Menge an Neuzeichnungen f√ºhren, wenn Sie in das Haus gehen und nach unten schauen.  Der Unterschied wird jedoch nicht besonders gro√ü sein, wenn Sie das Haus von einem Flugzeug aus betrachten.  In diesem Fall ist es am besten, einen Debugging-Modus in der Spiel-Engine zu haben, der die Oberfl√§chen transparent macht, damit Sie sehen k√∂nnen, was unter den f√ºr den Spieler sichtbaren Oberfl√§chen gezeichnet wird. <br><br><h2>  Wenn Z-Puffer einen Z-Konflikt haben </h2><br>  Wie bestimmt die GPU, wenn zwei √ºberlappende Polygone gezeichnet werden, welches √ºbereinander liegt?  Die ersten Computergrafikforscher haben viel Zeit damit verbracht, dieses Problem zu untersuchen.  Ed Catmell (der sp√§ter Pr√§sident von Pixar und Walt Disney Animation Studios wurde) schrieb einen Artikel, in dem zehn verschiedene Ans√§tze f√ºr diese Aufgabe beschrieben wurden.  In einem Teil des Artikels stellt er fest, dass die L√∂sung dieses Problems trivial sein wird, wenn Computer √ºber gen√ºgend Speicher verf√ºgen, um einen Tiefenwert pro Pixel zu speichern.  In den 1970er und 1980er Jahren war es eine sehr gro√üe Menge an Speicher.  Heutzutage funktionieren die meisten GPUs jedoch so: Ein solches System wird als Z-Puffer bezeichnet. <br><br>  Der Z-Puffer (auch als Tiefenpuffer bezeichnet) funktioniert wie folgt: Jedem Pixel ist sein Tiefenwert zugeordnet.  Wenn ein Ger√§t ein Objekt zeichnet, berechnet es, wie weit ein Pixel von der Kamera entfernt ist.  Anschlie√üend wird der Tiefenwert eines vorhandenen Pixels √ºberpr√ºft.  Wenn es weiter von der Kamera entfernt ist als das neue Pixel, wird das neue Pixel gezeichnet.  Befindet sich ein vorhandenes Pixel n√§her an der Kamera als ein neues, wird das neue Pixel nicht gezeichnet.  Dieser Ansatz l√∂st viele Probleme und funktioniert auch dann, wenn sich die Polygone schneiden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png"></div><br>  <i>Abbildung 18. Durchschneidende Polygone, die vom Tiefenpuffer verarbeitet werden.</i> <br><br>  Der Z-Puffer hat jedoch keine unendliche Genauigkeit.  Wenn sich zwei Oberfl√§chen fast im gleichen Abstand von der Kamera befinden, verwirrt dies die GPU und sie kann zuf√§llig eine der Oberfl√§chen ausw√§hlen, wie in Abbildung 19 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ec2/2e9/e7fec22e99a74b0147b42bc91bf7be33.png"></div><br>  <i>Abbildung 19. Oberfl√§chen mit derselben Tiefe weisen Anzeigeprobleme auf.</i> <br><br>  Dies nennt man Z-Fighting und sieht sehr fehlerhaft aus.  Oft verschlimmern sich Z-Konflikte, je weiter die Oberfl√§che von der Kamera entfernt ist.  Engine-Entwickler k√∂nnen Korrekturen einbauen, um dieses Problem zu beheben. Wenn ein K√ºnstler jedoch Polygone erstellt, die nahe genug sind und sich √ºberlappen, kann dennoch ein Problem auftreten.  Ein anderes Beispiel ist eine Wand mit einem Poster.  Das Poster befindet sich fast in der gleichen Tiefe von der Kamera wie die Wand dahinter, sodass das Risiko von Z-Konflikten sehr hoch ist.  Die L√∂sung besteht darin, ein Loch in die Wand unter dem Poster zu schneiden.  Dadurch wird auch das Neuzeichnen verringert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/4e2/536/da14e2536deb1d23b0e2a7b4de57bc33.png"></div><br>  <i>Abbildung 20. Ein Beispiel f√ºr einen Z-Konflikt √ºberlappender Polygone.</i> <br><br>  In extremen F√§llen kann ein Z-Konflikt auftreten, selbst wenn sich die Objekte ber√ºhren.  Abbildung 20 zeigt die Schublade auf dem Boden. Da wir unter der Schublade kein Loch in den Boden geschnitten haben, kann der Z-Puffer neben der Kante verwechselt werden, an der der Boden auf die Schublade trifft. <br><br><h2>  Draw Calls verwenden </h2><br>  GPUs sind extrem schnell geworden - so schnell, dass die CPUs m√∂glicherweise nicht mit ihnen Schritt halten.  Da GPUs im Wesentlichen f√ºr die Ausf√ºhrung einer Aufgabe ausgelegt sind, ist es viel einfacher, schnell zur Arbeit zu kommen.  Grafiken h√§ngen von Natur aus mit der Berechnung mehrerer Pixel zusammen, sodass Sie Ger√§te erstellen k√∂nnen, die mehrere Pixel parallel berechnen.  Die GPU rendert jedoch nur das, was sie zum Zeichnen der CPU befiehlt.  Wenn die CPU die GPU nicht schnell mit Daten ‚Äûversorgen‚Äú kann, befindet sich die Grafikkarte im Leerlauf.  Jedes Mal, wenn die CPU der GPU befiehlt, etwas zu zeichnen, wird dies als Zeichenaufruf bezeichnet.  Der einfachste Zeichenaufruf besteht aus dem Rendern eines Netzes, einschlie√ülich eines Shaders und eines Satzes von Texturen. <br><br>  Stellen Sie sich einen langsamen Prozessor vor, der 100 Zeichenaufrufe pro Frame √ºbertragen kann, und eine schnelle GPU, die eine Million Polygone pro Frame zeichnen kann.  In diesem Fall kann ein idealer Zeichenaufruf 10.000 Polygone zeichnen.  Wenn Ihre Netze nur aus 100 Polygonen bestehen, kann die GPU nur 10.000 Polygone pro Frame zeichnen.  Das hei√üt, 99% der Zeit ist die GPU inaktiv.  In diesem Fall k√∂nnen wir die Anzahl der Polygone in den Netzen leicht erh√∂hen, ohne etwas zu verlieren. <br><br>  Woraus der Draw Call besteht und welche Kosten er verursacht, h√§ngt stark von bestimmten Engines und Architekturen ab.  Einige Engines k√∂nnen viele Netze in einem Draw-Aufruf kombinieren (Batching, Batch ausf√ºhren), aber alle Netze m√ºssen denselben Shader haben oder andere Einschr√§nkungen haben.  Neue APIs wie Vulkan und DirectX 12 wurden speziell entwickelt, um dieses Problem zu l√∂sen, indem die Kommunikation des Programms mit dem Grafiktreiber optimiert wird, wodurch die Anzahl der Draw-Aufrufe erh√∂ht wird, die in einem einzelnen Frame √ºbertragen werden k√∂nnen. <br><br>  Wenn Ihr Team eine eigene Engine schreibt, fragen Sie die Entwickler der Engine, welche Einschr√§nkungen Draw Calls haben.  Wenn Sie eine vorgefertigte Engine wie Unreal oder Unity verwenden, f√ºhren Sie Leistungsbenchmarks aus, um die Grenzen der Funktionen der Engine zu bestimmen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√∂glicherweise k√∂nnen Sie die Anzahl der Polygone erh√∂hen, ohne die Geschwindigkeit zu verringern. </font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, dieser Artikel dient als gute Einf√ºhrung, um Ihnen zu helfen, die verschiedenen Aspekte der Renderleistung zu verstehen. </font><font style="vertical-align: inherit;">In GPUs verschiedener Hersteller wird alles ein wenig auf seine Weise implementiert. </font><font style="vertical-align: inherit;">Es gibt viele Vorbehalte und besondere Bedingungen in Bezug auf bestimmte Engines und Hardwareplattformen. </font><font style="vertical-align: inherit;">F√ºhren Sie immer einen offenen Dialog mit Rendering-Programmierern, um deren Empfehlungen in Ihrem Projekt zu verwenden.</font></font><br><br><h2>  √úber den Autor </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eskil Steenberg ist ein unabh√§ngiger Entwickler von Spielen und Tools. Er arbeitet als Berater und an unabh√§ngigen Projekten. </font><font style="vertical-align: inherit;">Alle Screenshots wurden in aktiven Projekten mit von Esquil entwickelten Tools aufgenommen. </font><font style="vertical-align: inherit;">Weitere </font><font style="vertical-align: inherit;">Informationen zu </font><font style="vertical-align: inherit;">seiner Arbeit finden Sie auf der Website von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel Solaar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und auf seinem Twitter-Konto bei @quelsolaar.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433186/">https://habr.com/ru/post/de433186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433176/index.html">Docker Remote-API f√ºr Zertifikatauthentifizierung mit Sperr√ºberpr√ºfung</a></li>
<li><a href="../de433178/index.html">Wie wir eine besch√§digte WAV-Datei wiederhergestellt haben</a></li>
<li><a href="../de433180/index.html">L√∂sen von Datentypproblemen in Ruby oder Machen Sie Daten wieder zuverl√§ssig</a></li>
<li><a href="../de433182/index.html">Ist es m√∂glich, einen Agenten f√ºr den Handel an der B√∂rse mit Verst√§rkung auszubilden? Implementierung der R-Sprache</a></li>
<li><a href="../de433184/index.html">ASP.NET Core 2.2 ver√∂ffentlicht. Was gibt's Neues? (2 von 3)</a></li>
<li><a href="../de433188/index.html">Die Staatsduma legte einen Gesetzentwurf zur autonomen Arbeit von Runet vor</a></li>
<li><a href="../de433192/index.html">Kubernetes: Eine erstaunlich erschwingliche pers√∂nliche Projektl√∂sung</a></li>
<li><a href="../de433194/index.html">Geplantes Nachtlicht</a></li>
<li><a href="../de433196/index.html">Neujahrsgeschenkf√ºhrer</a></li>
<li><a href="../de433198/index.html">10 Dollar f√ºr Hosting: Vor 20 Jahren und heute</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>