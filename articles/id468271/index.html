<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§•ğŸ¿ ğŸ§” ğŸ•°ï¸ Tes vs Jenis - Versi karat ğŸ˜ˆ ğŸ˜´ ğŸ¤’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa hari yang lalu 0xd34df00d telah menerbitkan terjemahan artikel tersebut , menjelaskan kemungkinan informasi tentang beberapa fungsi jika kita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes vs Jenis - Versi karat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p> Beberapa hari yang lalu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">0xd34df00d</a> telah menerbitkan terjemahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tersebut</a> , menjelaskan kemungkinan informasi tentang beberapa fungsi jika kita menggunakannya sebagai "kotak hitam", tidak mencoba membaca implementasinya.  Tentu saja, informasi ini sangat berbeda dari bahasa ke bahasa;  dalam artikel asli, empat kasus dipertimbangkan: </p><br><ul><li>  Python - pengetikan dinamis, hampir tidak ada informasi dari tanda tangan, beberapa petunjuk diperoleh oleh tes; </li><li>  C - pengetikan statis lemah, sedikit informasi lebih lanjut; </li><li>  Haskell - pengetikan statis yang kuat, dengan fungsi murni secara default, lebih banyak informasi; </li><li>  Mengetik Idris - dependen, kompiler dapat membuktikan kebenaran fungsi. </li></ul><br><p>  "Ini C dan ada Haskell, dan bagaimana dengan Rust?"  - ini adalah pertanyaan pertama dalam diskusi berikut.  Jawabannya ada di sini. </p><a name="habracut"></a><br><p>  Pertama-tama mari kita mengingat tugas: </p><br><blockquote>  Diberikan daftar nilai dan nilai, kembalikan indeks nilai dalam daftar atau tandakan bahwa itu tidak ada dalam daftar. </blockquote><p>  Jika seseorang tidak ingin tidak ingin membaca ini semua, contoh kode disediakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">taman bermain Rust</a> . <br>  Kalau tidak, mari kita mulai! </p><br><h4 id="simple-search">  Pencarian sederhana </h4><br><p>  Pendekatan pertama adalah tanda tangan yang hampir naif, berbeda dari kode C hanya dalam beberapa elemen idiomatik: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Apa yang kita ketahui tentang fungsi ini?  Yah, sebenarnya - tidak terlalu banyak.  Tentu saja, <code>Option&lt;usize&gt;</code> sebagai nilai balik adalah peningkatan besar atas apa pun yang disediakan oleh C, tetapi tidak ada informasi tentang fungsi semantik.  Secara khusus, kami tidak memiliki jaminan efek samping tidak ada dan tidak ada cara untuk memeriksa perilaku yang diinginkan. </p><br><p>  Bisakah tes meningkatkan ini?  Lihat di sini: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Tidak lebih, tampaknya - semua pemeriksaan ini bisa sama dengan Python (dan, untuk mengantisipasi, tes akan sedikit membantu untuk seluruh artikel). </p><br><h4 id="use-the-generics-luke">  Gunakan obat generik, Luke! </h4><br><p>  Tetapi apakah ada gunanya kita harus menggunakan hanya angka bertanda 32-bit?  Memperbaikinya: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Ya, itu sesuatu!  Sekarang kita dapat mengambil irisan apa pun, yang terdiri dari elemen-elemen dari jenis apa pun yang sebanding.  Polimorfisme eksplisit hampir selalu lebih baik daripada yang implisit (halo, Python) dan hampir selalu lebih baik daripada tidak ada polimorfisme sama sekali (halo, C), kan? </p><br><p>  Meskipun, fungsi ini mungkin secara tidak terduga lulus tes ini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Ini mengisyaratkan pada satu titik yang hilang, karena spesifikasi menginginkan fungsi <code>refl</code> , pada kenyataannya, untuk selalu mengembalikan <code>Some(0)</code> .  Tentu saja, ini semua disebabkan oleh perilaku spesifik dari tipe-tipe yang sepadan sebagian pada umumnya dan mengapung pada khususnya. <br>  Mungkin kita ingin menyingkirkan masalah ini?  Jadi, kami hanya akan memperketat ikatan pada tipe El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Sekarang, kami tidak hanya membutuhkan jenis yang sebanding, - kami membutuhkan perbandingan ini untuk menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setara</a> .  Ini, tentu saja, membatasi jenis yang mungkin untuk digunakan dengan fungsi ini, tetapi sekarang tanda tangan dan tes mengisyaratkan bahwa perilaku tersebut harus sesuai dengan spesifikasi. </p><br><div class="spoiler">  <b class="spoiler_title">Catatan: kami ingin LEBIH generik!</b> <div class="spoiler_text"><p>  Kasus ini tidak ada hubungannya dengan tugas awal, tetapi ini tampaknya menjadi contoh yang baik dari prinsip terkenal: "menjadi liberal dalam apa yang Anda terima, menjadi konservatif dalam apa yang Anda lakukan".  Dengan kata lain: jika Anda dapat menggeneralisasi tipe input tanpa merusak ergonomi dan kinerja - Anda mungkin harus melakukannya. </p><br><p>  Sekarang, kita akan periksa ini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Apa yang kita ketahui tentang fungsi ini sekarang?  Secara umum, semua sama, tetapi sekarang tidak hanya menerima irisan atau daftar, tetapi beberapa objek sewenang-wenang, yang dapat menghasilkan referensi ke tipe El, sehingga kami membandingkannya dengan objek yang dimaksud.  Sebagai contoh, jika saya tidak salah, di Java tipe ini akan <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="like-before-but-a-bit-more-strict">  Seperti sebelumnya, tetapi sedikit lebih ketat </h4><br><p>  Tapi sekarang, mungkin kita perlu jaminan lagi.  Atau kami ingin bekerja pada stack (dan karenanya tidak dapat menggunakan <code>Vec</code> ), tetapi perlu menggeneralisasi kode kami untuk setiap ukuran array yang memungkinkan.  Atau kami ingin mengkompilasi fungsi yang dioptimalkan untuk setiap ukuran array beton. </p><br><p>  Bagaimanapun, kita membutuhkan array generik - dan ada peti di Rust, memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">itu</a> . </p><br><p>  Sekarang, ini kode kami: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Apa yang kita ketahui darinya?  Kita tahu bahwa fungsi akan mengambil array dari beberapa ukuran tertentu, tercermin dalam tipenya (dan akan dikompilasi secara independen untuk setiap ukuran tersebut).  Untuk saat ini, ini hampir tidak ada - jaminan yang sama diberikan pada saat runtime oleh implementasi sebelumnya. </p><br><p>  Tapi kita bisa melangkah lebih jauh. </p><br><h4 id="type-level-arithmetic">  Aritmatika tingkat-jenis </h4><br><p>  Artikel awal menyebutkan beberapa jaminan yang diberikan oleh Idris yang tidak mungkin didapat dari bahasa lain.  Salah satunya - dan mungkin yang paling sederhana, karena tidak melibatkan bukti atau tes, hanya sedikit perubahan jenis, - menyatakan bahwa nilai kembali, jika bukan <code>Nothing</code> - <code>Nothing</code> , akan selalu kurang dari panjang daftar. </p><br><p>  Sepertinya jenis ketergantungan - atau sesuatu seperti itu - perlu untuk jaminan seperti itu, dan kita tidak bisa mendapatkan yang sama dari Rust, kan? </p><br><p>  Memenuhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">typenum</a> .  Dengan menggunakannya, kita dapat menulis fungsi kita dengan cara berikut: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  "Apa ini sihir hitam?!"  - kamu bisa bertanya.  Dan Anda benar: typenum <em>adalah</em> sihir hitam, dan segala upaya untuk menggunakannya bahkan lebih ajaib. <br><br>  Tapi tanda tangan fungsi ini cukup konkret. </p><br><ul><li>  Dibutuhkan array dari El dengan Ukuran panjang dan satu lagi El. </li><li>  Ini mengembalikan Opsi, yang, jika itu Beberapa, <br><ul><li>  memegang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek sifat</a> , berdasarkan pada ciri <code>UnsignedLessThan&lt;Size&gt;</code> ; </li><li>  dan <code>UnsignedLessThan&lt;T&gt;</code> diimplementasikan di mana pun <code>Unsigned</code> dan <code>IsLess&lt;T&gt;</code> diimplementasikan dan <code>IsLess&lt;T&gt;</code> mengembalikan B1, mis. true. </li></ul></li></ul><br><p>  Dengan kata lain, fungsi ini <em>dijamin</em> untuk mengembalikan integer unsigned <em>kurang dari</em> ukuran array (secara tegas, ia mengembalikan objek sifat, tetapi kita dapat memanggil metode <code>as_usize</code> dan mendapatkan integer). </p><br><p>  Sekarang saya dapat berbicara tentang dua peringatan utama: </p><br><ol><li>  Kita bisa kehilangan kinerja.  Jika entah bagaimana fungsi ini akan berada di jalur "panas" program, pengiriman dinamis konstan mungkin memperlambat seluruh proses.  Sebenarnya, ini mungkin bukan masalah besar, tapi ada yang lain: </li><li>  Untuk mengkompilasi fungsi ini, kita harus menulis bukti kebenarannya di dalamnya, atau menipu sistem tipe dengan beberapa yang <code>unsafe</code> .  Yang pertama cukup kompleks, dan yang terakhir hanya menipu. </li></ol><br><h4 id="conclusion">  Kesimpulan </h4><br><p>  Tentu saja, dalam praktiknya kita biasanya akan menggunakan pendekatan kedua (dengan irisan generik) atau pendekatan di spoiler (dengan iterator).  Semua diskusi selanjutnya mungkin tidak menarik secara praktis dan di sini hanya sebagai latihan dengan tipe. </p><br><p>  Bagaimanapun, fakta bahwa sistem tipe Rust dapat meniru fitur dari sistem tipe Idris yang lebih kuat, bagi saya, cukup mengesankan dengan sendirinya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468271/">https://habr.com/ru/post/id468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468253/index.html">Slider gambar sederhana dalam CSS dan Javascript</a></li>
<li><a href="../id468259/index.html">Lima highlights dari KTT Helm 2019 di Amsterdam</a></li>
<li><a href="../id468261/index.html">Gim baru dengan suasana lama di Three.js</a></li>
<li><a href="../id468263/index.html">Katakan halo ke terminal Visual Studio yang baru</a></li>
<li><a href="../id468265/index.html">Membuat permen dari Vim</a></li>
<li><a href="../id468277/index.html">Apakah pekerjaan programmer itu sulit - pandangan dari sudut pandang psikofisiologi</a></li>
<li><a href="../id468285/index.html">Perusahaan Pengembangan Perangkat Lunak Teratas untuk Perusahaan & Startup</a></li>
<li><a href="../id468287/index.html">C # Atribut: Tentang Semua Aspek</a></li>
<li><a href="../id468289/index.html">Pagi</a></li>
<li><a href="../id468291/index.html">Sinopsis dari buku Mark Gaulston "I Can Hear You Through"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>