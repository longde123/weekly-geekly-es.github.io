<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöï üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üéì Pemikiran fungsional. Bagian 11: Final üë®üèæ‚Äçüé® üåó üåÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami sedang menyelesaikan serangkaian artikel tentang pemrograman fungsional. Ternyata 11 bagian. Saya percaya ini adalah prestasi. Pada arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran fungsional. Bagian 11: Final</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433412/"><p>  Hari ini kami sedang menyelesaikan serangkaian artikel tentang pemrograman fungsional.  Ternyata 11 bagian.  Saya percaya ini adalah prestasi.  Pada artikel ini, kami menerapkan tumpukan kalkulator sederhana (juga dikenal sebagai "notasi Polandia terbalik").  Implementasinya hampir sepenuhnya dibangun di atas fungsi, dengan hanya satu jenis khusus, dan umumnya tanpa perbandingan dengan sampel, jadi ini adalah tempat pengujian yang sangat baik untuk konsep-konsep yang tercakup dalam seri kami. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><p>  Saya ingin mengucapkan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> secara terpisah.  Dialah yang bertindak sebagai penerjemah utama dan manajer dari seluruh rangkaian artikel.  Terima kasih </p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketiga</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keempat</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kelima</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keenam</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketujuh</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedelapan</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kesembilan</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesepuluh</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Jika Anda tidak terbiasa dengan kalkulator seperti itu, maka berfungsi sebagai berikut: angka didorong ke tumpukan, dan operasi, seperti penambahan dan perkalian, pilih angka dari bagian atas tumpukan, dan kemudian kembalikan hasil operasi. </p><br><p>  Skema perhitungan sederhana pada stack: </p><br><br><p>  Sebelum merancang sistem seperti itu, Anda harus mempertimbangkan bagaimana sistem itu akan digunakan.  Mengikuti sintaks yang mirip, kami akan memberi setiap tindakan label yang sesuai sehingga pada contoh di atas Anda dapat menulis sesuatu seperti: </p><br><pre><code class="plaintext hljs">EMPTY ONE THREE ADD TWO MUL SHOW</code> </pre> <br><p>  Mungkin mustahil untuk mendapatkan sintaksis ini, tapi mari kita coba sedekat mungkin dengan ini. </p><br><h2>  Stack tipe data </h2><br><p>  Pertama, Anda perlu menentukan struktur data untuk stack.  Untuk kesederhanaan, Anda dapat menggunakan daftar angka floating point. </p><br><pre> <code class="plaintext hljs">type Stack = float list</code> </pre> <br><p>  Tetapi lebih baik untuk membungkusnya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu jenis case union</a> untuk membuat jenis lebih visual, seperti ini: </p><br><pre> <code class="plaintext hljs">type Stack = StackContents of float list</code> </pre> <br><p>  Mengapa lebih baik melakukan hal itu, Anda dapat membaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Sekarang buat tumpukan baru menggunakan <code>StackContents</code> sebagai konstruktor: </p><br><pre> <code class="plaintext hljs">let newStack = StackContents [1.0;2.0;3.0]</code> </pre> <br><p>  Untuk mengekstrak konten dari Stack yang ada, gunakan pencocokan pola <code>StackContents</code> : </p><br><pre> <code class="plaintext hljs">let (StackContents contents) = newStack //  "contents"   // float list = [1.0; 2.0; 3.0]</code> </pre> <br><h2>  Fungsi dorong </h2><br><p>  Selanjutnya, kita perlu cara untuk meletakkan angka di tumpukan ini.  Untuk melakukan ini, tambahkan saja nilai baru ke atas daftar menggunakan " <code>::</code> ". </p><br><p>  Contoh fungsi: </p><br><pre> <code class="plaintext hljs">let push x aStack = let (StackContents contents) = aStack let newContents = x::contents StackContents newContents</code> </pre> <br><p>  Fitur ini memiliki sejumlah fitur yang layak dibahas. </p><br><p>  Pertama, Anda harus memperhatikan fakta bahwa struktur <code>list</code> tidak dapat diubah, yang berarti bahwa fungsi tersebut harus mengambil tumpukan yang ada dan mengembalikan yang baru.  Ini bukan hanya perubahan ke tumpukan yang ada.  Faktanya, semua fungsi dalam contoh ini akan memiliki format yang serupa: </p><br><pre> <code class="plaintext hljs">Input: Stack   -  Output:  Stack</code> </pre> <br><p>  Kedua, mengapa parameter dilakukan dalam urutan itu?  Mengapa tumpukan harus pertama atau terakhir?  Pada bagian tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merancang fungsi dengan aplikasi parsial,</a> dikatakan bahwa parameter yang paling sering berubah adalah yang terakhir.  Segera mungkin untuk memverifikasi bahwa rekomendasi ini sedang diikuti. </p><br><p>  Akhirnya, fungsi dapat dibuat lebih ringkas dengan mencocokkan dengan pola dalam parameter fungsi itu sendiri, alih-alih <code>let</code> dalam fungsi tubuh. </p><br><p>  Versi yang ditulis ulang: </p><br><pre> <code class="plaintext hljs">let push x (StackContents contents) = StackContents (x::contents)</code> </pre> <br><p>  Jauh lebih baik! </p><br><p>  Omong-omong, lihat tanda tangannya yang anggun: </p><br><pre> <code class="plaintext hljs">val push : float -&gt; Stack -&gt; Stack</code> </pre> <br><p>  Seperti yang disebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , tanda tangan banyak memberi tahu kita. <br>  Dalam hal ini, saya bisa menebak apa fungsi ini, hanya dengan tanda tangannya, bahkan tanpa mengetahui bahwa itu disebut "push". <br>  Ini adalah alasan lain mengapa ide mengetik jenis eksplisit adalah ide yang bagus.  Jika tumpukan itu hanya daftar angka floating point, maka fungsinya tidak akan begitu mendokumentasikan diri. </p><br><p>  Dengan satu atau lain cara, periksa: </p><br><pre> <code class="plaintext hljs">let emptyStack = StackContents [] let stackWith1 = push 1.0 emptyStack let stackWith2 = push 2.0 stackWith1</code> </pre> <br><p>  Bagus sekali! </p><br><h2>  Tumpuk superskrip atas menggunakan push </h2><br><p>  Dengan fungsi sederhana ini, Anda dapat dengan mudah menentukan operasi yang mendorong nomor tertentu pada tumpukan. </p><br><pre> <code class="plaintext hljs">let ONE stack = push 1.0 stack let TWO stack = push 2.0 stack</code> </pre> <br><p>  Tapi tunggu dulu!  Anda melihat bahwa parameter <code>stack</code> disebutkan di kedua sisi ekspresi?  Bahkan, tidak perlu menyebutkannya dua kali.  Sebagai gantinya, Anda dapat menghilangkan parameter dan menulis fungsi dengan aplikasi parsial: </p><br><pre> <code class="plaintext hljs">let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0</code> </pre> <br><p>  Sekarang jelas bahwa jika fungsi <code>push</code> memiliki urutan parameter yang berbeda, <code>stack</code> harus disebutkan dua kali. </p><br><p>  Anda juga perlu mendefinisikan fungsi yang membuat tumpukan kosong: </p><br><pre> <code class="plaintext hljs">let EMPTY = StackContents []</code> </pre> <br><p>  Periksa fungsi yang diterima: </p><br><pre> <code class="plaintext hljs">let stackWith1 = ONE EMPTY let stackWith2 = TWO stackWith1 let stackWith3 = THREE stackWith2</code> </pre> <br><p>  Apakah tumpukan menengah ini mengganggu?  Apakah mungkin untuk menyingkirkan mereka?  Tentu saja!  Perhatikan bahwa fungsi SATU, DUA, dan TIGA memiliki tanda tangan yang sama: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Jadi, mereka saling terhubung dengan sempurna!  Output dari satu fungsi dapat dimasukkan sebagai berikut: </p><br><pre> <code class="plaintext hljs">let result123 = EMPTY |&gt; ONE |&gt; TWO |&gt; THREE let result312 = EMPTY |&gt; THREE |&gt; ONE |&gt; TWO</code> </pre> <br><h2>  Muncul keluar dari tumpukan </h2><br><p>  Dengan tambahan pada stack yang ditemukan, tetapi bagaimana dengan fungsi <code>pop</code> ? </p><br><p>  Saat mengambil dari tumpukan, jelas perlu mengembalikan bagian atas tumpukan, tetapi apakah hanya itu? </p><br><p>  Dalam gaya berorientasi objek, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawabannya adalah ya</a> .  Tetapi dalam kasus OOP, tumpukan akan diubah di belakang layar, sehingga item teratas akan dihapus. </p><br><p>  Namun, dalam gaya fungsional, tumpukan tidak berubah.  Hanya ada satu cara untuk menghapus elemen atas - buat <em>tumpukan baru</em> tanpa elemen ini.  Agar pemanggil memiliki akses ke tumpukan yang dikurangi baru, itu harus dikembalikan bersama dengan elemen atas. </p><br><p>  Dengan kata lain, fungsi <code>pop</code> harus mengembalikan <em>dua</em> nilai, elemen atas dan tumpukan baru.  Cara paling sederhana untuk melakukan ini di F # adalah dengan menggunakan tuple. </p><br><p>  Implementasi: </p><br><pre> <code class="plaintext hljs">///     ///          let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack)</code> </pre> <br><p>  Fungsi yang dihasilkan juga sangat sederhana. </p><br><p>  Seperti sebelumnya, <code>contents</code> diekstraksi langsung dari parameter. </p><br><p>  Kemudian, isi <code>contents</code> diperiksa menggunakan <code>match..with</code> ekspresi. </p><br><p>  Kemudian elemen atas dipisahkan dari sisa daftar, tumpukan baru dibuat berdasarkan elemen yang tersisa, dan akhirnya semua ini dikembalikan sebagai pasangan tuple. </p><br><p>  Coba jalankan kode ini dan lihat apa yang terjadi.  Anda akan mendapatkan kesalahan kompilasi! <br>  Compiler telah mendeteksi sebuah case yang belum dikerjakan - apa yang terjadi jika stack kosong? </p><br><p>  Anda harus memutuskan bagaimana cara menanganinya. </p><br><ul><li>  Opsi 1: Kembalikan status khusus "Sukses" atau "Kesalahan", seperti yang dilakukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos dari seri "mengapa menggunakan F #?"</a>  . </li><li>  Opsi 2: Lempar pengecualian. </li></ul><br><p>  Saya biasanya lebih suka menggunakan keadaan khusus untuk kesalahan, tetapi dalam kasus khusus ini, saya lebih suka untuk melemparkan pengecualian.  Versi <code>pop</code> diperbaiki dengan penanganan case kosong: </p><br><pre> <code class="plaintext hljs">let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow"</code> </pre> <br><p>  Periksa: </p><br><pre> <code class="plaintext hljs">let initialStack = EMPTY |&gt; ONE |&gt; TWO let popped1, poppedStack = pop initialStack let popped2, poppedStack2 = pop poppedStack</code> </pre> <br><p>  dan tes pengecualian: </p><br><pre> <code class="plaintext hljs">let _ = pop EMPTY</code> </pre> <br><h2>  Fungsi aritmatika </h2><br><p>  Sekarang setelah penambahan dan penghapusan sudah ada, Anda dapat mulai bekerja dengan fungsi "tambah" dan "multiply": </p><br><pre> <code class="plaintext hljs">let ADD stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x + y //   push result s2 //     let MUL stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x * y //   push result s2 //    </code> </pre> <br><p>  Pengujian Online: </p><br><pre> <code class="plaintext hljs">let add1and2 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD let add2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; ADD let mult2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; MUL</code> </pre> <br><p>  Itu berhasil! </p><br><h3>  Waktu refactoring ... </h3><br><p>  Jelas, sejumlah besar kode digandakan dalam dua fungsi ini.  Bagaimana kita memperbaikinya? </p><br><p>  Kedua fungsi mengekstrak dua nilai dari stack, menerapkan fungsi biner tertentu untuknya, dan kemudian mendorong hasilnya kembali ke stack.  Anda dapat menampilkan kode umum ke fungsi biner, yang mengambil fungsi matematika dengan dua parameter: </p><br><pre> <code class="plaintext hljs">let binary mathFn stack = //    let y,stack' = pop stack //     let x,stack'' = pop stack' //  let z = mathFn xy //      push z stack''</code> </pre> <br><p>  <em>Perhatikan bahwa dalam implementasi ini, versi berbeda dari objek "sama" ditandai dengan jumlah tanda kutip yang berbeda.</em>  <em>Ini karena sufiks numerik dapat dengan mudah menyebabkan kebingungan.</em> </p><br><p>  Pertanyaan: mengapa parameter memiliki urutan yang persis seperti ini, alih-alih <code>mathFn</code> datang setelah <code>stack</code> ? </p><br><p>  Sekarang Anda memiliki fungsi <code>binary</code> , lebih mudah untuk mendefinisikan ADD dan fungsi lainnya: </p><br><p>  Upaya pertama untuk mengimplementasikan ADD menggunakan <code>binary</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (fun xy -&gt; x + y) aStack</code> </pre> <br><p>  Tetapi Anda dapat menyingkirkan lambda, karena  itu mewakili definisi yang <em>tepat</em> dari fungsi <code>+</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (+) aStack</code> </pre> <br><p>  Sekali lagi, sebagian aplikasi dapat digunakan untuk menyembunyikan parameter stack.  Definisi akhir: </p><br><pre> <code class="plaintext hljs">let ADD = binary (+)</code> </pre> <br><p>  Definisi fungsi matematika lainnya: </p><br><pre> <code class="plaintext hljs">let SUB = binary (-) let MUL = binary (*) let DIV = binary (../)</code> </pre> <br><p>  Cobalah online: </p><br><pre> <code class="plaintext hljs">let div2by3 = EMPTY |&gt; THREE|&gt; TWO |&gt; DIV let sub2from5 = EMPTY |&gt; TWO |&gt; FIVE |&gt; SUB let add1and2thenSub3 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD |&gt; THREE |&gt; SUB</code> </pre> <br><p>  Demikian pula, Anda dapat membuat fungsi bantu untuk operasi unary </p><br><pre> <code class="plaintext hljs">let unary f stack = let x,stack' = pop stack push (fx) stack'</code> </pre> <br><p>  Dan tentukan beberapa fungsi unary: </p><br><pre> <code class="plaintext hljs">let NEG = unary (fun x -&gt; -x) let SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Mode interaktif: </p><br><pre> <code class="plaintext hljs">let neg3 = EMPTY |&gt; THREE|&gt; NEG let square2 = EMPTY |&gt; TWO |&gt; SQUARE</code> </pre> <br><h2>  Menyatukan semuanya |  Menyatukan semuanya </h2><br><p>  Dalam persyaratan awal disebutkan bahwa kami ingin dapat menunjukkan hasilnya, jadi ada baiknya mendefinisikan fungsi SHOW. </p><br><pre> <code class="plaintext hljs">let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      </code> </pre> <br><p>  Harap dicatat bahwa dalam kasus ini, versi baru tumpukan yang diterima melalui <code>pop</code> diabaikan.  Hasil akhirnya adalah tumpukan asli, seolah-olah itu tidak pernah berubah. </p><br><p>  Akhirnya, Anda dapat menulis contoh berikut dari persyaratan aslinya </p><br><pre> <code class="plaintext hljs">EMPTY |&gt; ONE |&gt; THREE |&gt; ADD |&gt; TWO |&gt; MUL |&gt; SHOW</code> </pre> <br><h3>  Pindah </h3><br><p>  Ini menyenangkan, tetapi apa lagi yang bisa Anda lakukan? </p><br><p>  Anda dapat menetapkan beberapa fungsi tambahan: </p><br><pre> <code class="plaintext hljs">///      let DUP stack = //    let x,_ = pop stack //      push x stack ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let START = EMPTY</code> </pre> <br><p>  Dengan menggunakan fungsi-fungsi tambahan ini, Anda dapat menulis beberapa contoh elegan: </p><br><pre> <code class="plaintext hljs">START |&gt; ONE |&gt; TWO |&gt; SHOW START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW |&gt; THREE |&gt; ADD |&gt; SHOW START |&gt; THREE |&gt; DUP |&gt; DUP |&gt; MUL |&gt; MUL // 27 START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW // 3 |&gt; THREE |&gt; MUL |&gt; SHOW // 9 |&gt; TWO |&gt; SWAP |&gt; DIV |&gt; SHOW // 9 div 2 = 4.5</code> </pre> <br><h2>  Menggunakan komposisi alih-alih pipelining </h2><br><p>  Tapi itu belum semuanya.  Bahkan, ada cara lain yang menarik untuk mewakili fungsi-fungsi ini. </p><br><p>  Seperti disebutkan sebelumnya, mereka semua memiliki tanda tangan yang sama: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Karena input dan output adalah dari jenis yang sama, fungsi-fungsi ini juga dapat digabungkan menggunakan operator komposisi <code>&gt;&gt;</code> , dan tidak hanya melalui operator pipeline. </p><br><p>  Beberapa contoh: </p><br><pre> <code class="plaintext hljs">//    let ONE_TWO_ADD = ONE &gt;&gt; TWO &gt;&gt; ADD START |&gt; ONE_TWO_ADD |&gt; SHOW //    let SQUARE = DUP &gt;&gt; MUL START |&gt; TWO |&gt; SQUARE |&gt; SHOW //     let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL START |&gt; THREE |&gt; CUBE |&gt; SHOW //   let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2 START |&gt; THREE |&gt; SQUARE |&gt; SUM_NUMBERS_UPTO |&gt; SHOW</code> </pre> <br><p>  Dalam masing-masing contoh ini, fungsi baru didefinisikan menggunakan komposisi fungsi lainnya.  Ini adalah contoh yang baik dari pendekatan "kombinasi" untuk membangun fungsionalitas. </p><br><h2>  Konveyor vs. Komposisi </h2><br><p>  Kami melihat dua cara berbeda untuk menggunakan model kami;  menggunakan conveyor dan komposisi.  Tapi apa bedanya?  Dan mengapa seseorang harus lebih disukai daripada yang lain? </p><br><p>  Perbedaannya adalah bahwa pipa, dalam arti tertentu, merupakan operasi "transformasi waktu nyata".  Pada saat menggunakan pipa, operasi dilakukan segera, melalui transfer tumpukan tertentu. </p><br><p>  Di sisi lain, komposisi adalah sesuatu seperti "rencana" yang ingin kita terapkan, membangun fungsi dari serangkaian komponen tanpa aplikasi langsung. </p><br><p>  Misalnya, Anda dapat membuat "rencana" untuk menghitung kuadrat angka melalui kombinasi operasi kecil: </p><br><pre> <code class="plaintext hljs">let COMPOSED_SQUARE = DUP &gt;&gt; MUL</code> </pre> <br><p>  Saya tidak bisa memberikan yang setara berdasarkan jaringan pipa. </p><br><pre> <code class="plaintext hljs">let PIPED_SQUARE = DUP |&gt; MUL</code> </pre> <br><p>  Ini akan menghasilkan kesalahan kompilasi.  Saya perlu beberapa contoh stack khusus agar ekspresi berfungsi: </p><br><pre> <code class="plaintext hljs">let stackWith2 = EMPTY |&gt; TWO let twoSquared = stackWith2 |&gt; DUP |&gt; MUL</code> </pre> <br><p>  Dan bahkan dalam kasus ini, saya bisa mendapatkan jawaban hanya untuk input khusus ini, dan bukan rencana perhitungan umum berdasarkan input apa pun, seperti dalam contoh dengan <code>COMPOSED_SQUARE</code> . </p><br><p>  Cara lain untuk membuat "rencana" adalah dengan secara eksplisit meneruskan lambda ke fungsi yang lebih primitif: </p><br><pre> <code class="plaintext hljs">let LAMBDA_SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Ini adalah cara yang lebih eksplisit (dan kemungkinan besar lebih cepat), tetapi semua keuntungan dan kejelasan dari pendekatan komposisi hilang. </p><br><p>  Secara umum, jika mungkin, Anda harus berusaha untuk pendekatan komposisi! </p><br><h2>  Kode lengkap </h2><br><p>  Kode lengkap untuk semua contoh di atas: </p><br><pre> <code class="plaintext hljs">// ============================================== //  // ============================================== type Stack = StackContents of float list // ============================================== //   // ============================================== ///     let push x (StackContents contents) = StackContents (x::contents) ///        ///       let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow" // ============================================== //  () // ============================================== //     //      //     let binary mathFn stack = let y,stack' = pop stack let x,stack'' = pop stack' let z = mathFn xy push z stack'' //    //      //     let unary f stack = let x,stack' = pop stack push (fx) stack' // ============================================== //  () // ============================================== ///      let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      ///    let DUP stack = let x,s = pop stack push x (push xs) ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let DROP stack = let _,s = pop stack //   s //   // ============================================== // ,    // ============================================== //  // ------------------------------- let EMPTY = StackContents [] let START = EMPTY //  // ------------------------------- let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0 //   // ------------------------------- let ADD = binary (+) let SUB = binary (-) let MUL = binary (*) let DIV = binary (../) let NEG = unary (fun x -&gt; -x) // ============================================== // ,     // ============================================== let SQUARE = DUP &gt;&gt; MUL let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2</code> </pre> <br><h2>  Kesimpulan </h2><br><p>  Kami memiliki kalkulator berbasis tumpukan sederhana.  Kami melihat bagaimana, dimulai dengan beberapa operasi primitif ( <code>push</code> , <code>pop</code> , <code>binary</code> , <code>unary</code> ) dan lainnya, Anda dapat membangun DSL penuh, mudah diimplementasikan dan digunakan. </p><br><p>  Seperti yang Anda tebak, contoh ini cukup banyak didasarkan pada bahasa Forth.  Saya sangat merekomendasikan buku gratis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Thinking Forth"</a> , yang tidak hanya menceritakan tentang bahasa Forth, tetapi juga tentang metode lain ( <em>bukan</em> berorientasi objek!) Untuk menguraikan tugas yang sama-sama berlaku untuk pemrograman fungsional secara umum. </p><br><p>  Saya mendapat ide untuk artikel ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Ashley Feniello yang</a> cantik.  Jika Anda ingin terjun lebih dalam ke emulasi bahasa berbasis stack berdasarkan F #, mulailah dengan itu.  <em>Selamat bersenang-senang!</em> </p><br><h1>  Sumber Daya Tambahan </h1><br><p>  Ada banyak tutorial untuk F #, termasuk materi untuk mereka yang datang dengan pengalaman C # atau Java.  Tautan berikut mungkin berguna saat Anda masuk lebih dalam ke F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk Kesenangan dan Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar X dalam Y Menit: F #</a> </li></ul><br><p>  Beberapa cara lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mulai belajar F #</a> juga dijelaskan. </p><br><p>  Akhirnya, komunitas F # sangat ramah pemula.  Ada obrolan yang sangat aktif di Slack, didukung oleh F # Software Foundation, dengan kamar pemula yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung dengan bebas</a> .  Kami sangat menyarankan Anda melakukan ini! </p><br><p>  Jangan lupa untuk mengunjungi situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas berbahasa Rusia F #</a> !  Jika Anda memiliki pertanyaan tentang belajar bahasa, dengan senang hati kami akan membahasnya di ruang obrolan: </p><br><ul><li>  kamar <code>#ru_general</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol di Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol dalam gitter</a> </li><li>  kamar #en_general di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Tentang penulis terjemahan </h2><br><p>  Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Perubahan terjemahan dan editorial dilakukan oleh upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas pengembang F # berbahasa Rusia</a> .  Kami juga berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@schvepsss</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@shwars</em></a> karena telah menyiapkan artikel ini untuk dipublikasikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433412/">https://habr.com/ru/post/id433412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433402/index.html">Pemikiran fungsional. Bagian 8</a></li>
<li><a href="../id433404/index.html">Bereaksi Tutorial Bagian 3: File Komponen, Struktur Proyek</a></li>
<li><a href="../id433406/index.html">Pemikiran fungsional. Bagian 9</a></li>
<li><a href="../id433408/index.html">Penanganan memori yang efisien di Node.js</a></li>
<li><a href="../id433410/index.html">Pemikiran fungsional. Bagian 10</a></li>
<li><a href="../id433414/index.html">Menguji Monitor Jaringan PRTG dan membandingkannya dengan Zabbix</a></li>
<li><a href="../id433420/index.html">Hasil ZeroNights 2018</a></li>
<li><a href="../id433424/index.html">Apakah mungkin memuat level yang tidak bisa dilewati di Super Mario Maker?</a></li>
<li><a href="../id433428/index.html">Dari mana kreativitas berasal: analisis aktivitas gelombang alpha otak selama tes RAT</a></li>
<li><a href="../id433430/index.html">Kotak Mecool KM9 Android pada SoC Amlogic S905X2 segar dengan RAM 4 GB dan Android TV 8.1 - pahami dan maafkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>