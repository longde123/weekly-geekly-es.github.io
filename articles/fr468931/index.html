<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèª üèñÔ∏è üòò Ex√©cutez systemd dans le conteneur üõÑ üçí ‚ôæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous suivons depuis longtemps le sujet de l'utilisation de systemd dans des conteneurs. En 2014, notre ing√©nieur en s√©curit√© Daniel Walsh a √©crit un a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ex√©cutez systemd dans le conteneur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/468931/">  Nous suivons depuis longtemps le sujet de l'utilisation de systemd dans des conteneurs.  En 2014, notre ing√©nieur en s√©curit√© Daniel Walsh a √©crit un article intitul√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Running systemd</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un Docker Container</a> , et quelques ann√©es plus tard, un autre article intitul√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Running systemd dans un conteneur non privil√©gi√©</a> , dans lequel il a d√©clar√© que la situation n'√©tait pas tr√®s am√©lior√©.  En particulier, il a √©crit que ¬´malheureusement, et deux ans plus tard, si vous utilisez le syst√®me Docker sur Google, la premi√®re chose qui appara√Æt est le m√™me vieil article.  Il est donc temps de changer quelque chose. "  De plus, nous avons d√©j√† parl√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conflit entre les d√©veloppeurs de Docker et systemd</a> . <br><br><img src="https://habrastorage.org/webt/jw/is/oz/jwisoz8445mav6kqiwqr7gwpjns.png" width="100%"><br><br>  Dans cet article, nous montrerons ce qui a chang√© au cours du temps pass√© et comment Podman peut nous aider dans cette affaire. <br><a name="habracut"></a><br>  Il existe de nombreuses raisons pour ex√©cuter systemd √† l'int√©rieur d'un conteneur, telles que: <br><br><ol><li>  <b>Conteneurs multiservices</b> - de nombreuses personnes souhaitent retirer leurs applications multiservices des machines virtuelles et les ex√©cuter dans des conteneurs.  Il serait pr√©f√©rable, bien s√ªr, de diviser ces applications en microservices, mais tout le monde ne peut pas encore le faire ou il n'y a tout simplement pas de temps.  Par cons√©quent, le lancement de telles applications sous la forme de services lanc√©s par systemd √† partir de fichiers unitaires est parfaitement logique. </li><li>  <b>Fichiers d'unit√© Systemd</b> - la plupart des applications ex√©cut√©es √† l'int√©rieur de conteneurs sont compil√©es √† partir de code qui s'ex√©cutait auparavant sur des machines virtuelles ou physiques.  Ces applications ont un fichier unit√© qui a √©t√© √©crit pour ces applications et comprend comment les ex√©cuter.  Il est donc pr√©f√©rable de d√©marrer les services √† l'aide des m√©thodes prises en charge, plut√¥t que de pirater votre propre service init. </li><li>  <b>Systemd est un gestionnaire de processus.</b>  Il g√®re les services (arr√™te, red√©marre les services ou analyse les processus zombies) mieux que tout autre outil. </li></ol><br>  Il y a plusieurs raisons pour ne pas ex√©cuter systemd dans des conteneurs.  Le principal est que systemd / journald contr√¥le la sortie des conteneurs, et des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenShift</a> attendent des conteneurs qu'ils √©crivent le journal directement sur stdout et stderr.  Par cons√©quent, si vous avez l'intention de g√©rer des conteneurs via des outils d'orchestration tels que ceux mentionn√©s ci-dessus, vous devez s√©rieusement envisager l'utilisation de conteneurs bas√©s sur systemd.  De plus, les d√©veloppeurs de Docker et Moby √©taient souvent fortement oppos√©s √† l'utilisation de systemd dans des conteneurs. <br><br><h3>  L'arriv√©e de Podman </h3><br>  Nous sommes heureux d'annoncer que la situation a enfin d√©coll√©.  L'√©quipe responsable du lancement des conteneurs chez Red Hat a d√©cid√© de d√©velopper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leur propre moteur de conteneurs</a> .  Il a obtenu le nom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Podman</a> et propose la m√™me interface de ligne de commande (CLI) que Docker.  Et presque toutes les commandes Docker peuvent √™tre utilis√©es de la m√™me mani√®re dans Podman.  Nous organisons souvent des s√©minaires, qui s'appellent d√©sormais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Changer Docker en Podman</a> , et la premi√®re diapositive vous encourage √† vous inscrire: alias docker = podman. <br><br>  Beaucoup le font. <br><br>  Mon Podman et moi ne sommes en aucun cas contre les conteneurs bas√©s sur systemd.  Apr√®s tout, Systemd est le plus souvent utilis√© comme sous-syst√®me d'initialisation Linux, et ne pas le laisser fonctionner normalement dans des conteneurs signifie ignorer la fa√ßon dont des milliers de personnes sont habitu√©es √† ex√©cuter des conteneurs. <br><br>  Podman sait quoi faire pour que systemd fonctionne correctement dans le conteneur.  Elle a besoin de choses comme monter tmpfs sur / run et / tmp.  Elle aime quand l'environnement ¬´conteneur¬ª est activ√©, et elle attend les autorisations d'√©criture dans sa partie du r√©pertoire cgroup et dans le dossier / var / log / journald. <br><br>  Lors du d√©marrage d'un conteneur dans lequel init ou systemd est la premi√®re commande, Podman configure automatiquement tmpfs et Cgroups afin que systemd d√©marre sans probl√®me.  Pour bloquer ce mode de d√©marrage automatique, utilisez l'option --systemd = false.  Veuillez noter que Podman utilise le mode systemd uniquement lorsqu'il voit qu'il est n√©cessaire d'ex√©cuter la commande systemd ou init. <br><br>  Voici un extrait du manuel: <br><br><blockquote>  homme podman courir <br>  ... <br><br>  ‚ÄìSystemd = true | false <br><br>  Ex√©cution du conteneur en mode systemd.  Activ√© par d√©faut. <br><br>  Si une commande systemd ou init est ex√©cut√©e √† l'int√©rieur du conteneur, Podman configurera les points de montage tmpfs dans les r√©pertoires suivants: <br><br>  / run, / run / lock, / tmp, / sys / fs / cgroup / systemd, / var / lib / journal <br><br>  De plus, SIGRTMIN + 3 sera utilis√© comme signal d'arr√™t par d√©faut. <br><br>  Tout cela permet √† systemd de fonctionner dans un conteneur ferm√© sans aucune modification. <br><br>  REMARQUE: systemd tente d'√©crire dans le syst√®me de fichiers cgroup.  Cependant, SELinux emp√™che par d√©faut les conteneurs de le faire.  Pour activer l'√©criture, activez le param√®tre batch container_manage_cgroup: <br><br>  setsebool -P container_manage_cgroup true <br></blockquote><br>  Maintenant, regardez √† quoi ressemble le Dockerfile pour ex√©cuter systemd dans le conteneur lors de l'utilisation de Podman: <br><br><pre><code class="plaintext hljs"># cat Dockerfile FROM fedora RUN dnf -y install httpd; dnf clean all; systemctl enable httpd EXPOSE 80 CMD [ "/sbin/init" ]</code> </pre> <br>  C‚Äôest tout. <br><br>  Maintenant, r√©cup√©rez le conteneur: <br><br><pre> <code class="plaintext hljs"># podman build -t systemd .</code> </pre><br>  Nous demandons √† SELinux d'autoriser systemd √† modifier la configuration de Cgroups: <br><br><pre> <code class="plaintext hljs"># setsebool -P container_manage_cgroup true</code> </pre><br>  Beaucoup, au fait, oublient cette √©tape.  Heureusement, il suffit de le faire une seule fois et le param√®tre est enregistr√© apr√®s un red√©marrage du syst√®me. <br><br>  Maintenant, lancez simplement le conteneur: <br><br><pre> <code class="plaintext hljs"># podman run -ti -p 80:80 systemd systemd 239 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=hybrid) Detected virtualization container-other. Detected architecture x86-64. Welcome to Fedora 29 (Container Image)! Set hostname to &lt;1b51b684bc99&gt;. Failed to install release agent, ignoring: Read-only file system File /usr/lib/systemd/system/systemd-journald.service:26 configures an IP firewall (IPAddressDeny=any), but the local system does not support BPF/cgroup based firewalling. Proceeding WITHOUT firewalling in effect! (This warning is only shown for the first loaded unit using IP firewalling.) [ OK ] Listening on initctl Compatibility Named Pipe. [ OK ] Listening on Journal Socket (/dev/log). [ OK ] Started Forward Password Requests to Wall Directory Watch. [ OK ] Started Dispatch Password Requests to Console Directory Watch. [ OK ] Reached target Slices. ‚Ä¶ [ OK ] Started The Apache HTTP Server.</code> </pre><br>  Tout, le service a commenc√© et fonctionne: <br><br><pre> <code class="plaintext hljs">$ curl localhost &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; ‚Ä¶ &lt;/html&gt;</code> </pre><br>  REMARQUE: n'essayez pas de r√©p√©ter cela sur Docker!  L√†, des danses avec un tambourin sont encore n√©cessaires pour lancer de tels conteneurs √† travers un d√©mon.  (Des champs et des packages suppl√©mentaires seront n√©cessaires pour que cela fonctionne de mani√®re transparente dans Docker, ou devront √™tre ex√©cut√©s dans un conteneur privil√©gi√©. Voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tails</a> .) <br><br><h3>  Un peu plus de choses int√©ressantes sur Podman et systemd </h3><br><h4>  Podman fonctionne mieux que docker dans les fichiers d'unit√© systemd </h4><br>  Si les conteneurs doivent √™tre d√©marr√©s au d√©marrage du syst√®me, vous pouvez simplement ins√©rer les commandes Podman appropri√©es dans le fichier d'unit√© systemd, ce qui lancera le service et le surveillera.  Podman utilise le mod√®le fork-exec standard.  En d'autres termes, les processus de conteneur sont affili√©s au processus Podman, donc systemd peut facilement les surveiller. <br><br>  Docker utilise le mod√®le client-serveur et les commandes CLI Docker peuvent √©galement √™tre plac√©es directement dans le fichier d'unit√©.  Cependant, une fois que le client Docker s'est connect√© au d√©mon Docker, il (le client) devient juste un autre processus qui traite stdin et stdout.  √Ä son tour, systemd n'a aucune id√©e de la connexion entre le client Docker et le conteneur qui ex√©cute le d√©mon Docker, et par cons√©quent, sous ce mod√®le, systemd ne peut pas fondamentalement surveiller le service. <br><br><h4>  Activation de Systemd via socket </h4><br>  Podman remplit correctement l'activation via une prise.  √âtant donn√© que Podman utilise le mod√®le fork-exec, il peut transf√©rer un socket vers ses processus de conteneur enfant.  Docker ne sait pas comment, car il utilise un mod√®le client-serveur. <br><br>  Le service varlink que Podman utilise pour interagir avec des clients distants avec des conteneurs est en fait activ√© via le socket.  Le package cockpit-podman, √©crit en Node.js et faisant partie du projet cockpit, permet aux utilisateurs d'interagir avec les conteneurs Podman via une interface Web.  Le d√©mon Web sur lequel cockpit-podman s'ex√©cute envoie des messages au socket varlink que systemd √©coute.  Apr√®s cela, systemd active le programme Podman pour recevoir des messages et commencer √† g√©rer les conteneurs.  L'activation de systemd via un socket vous permet de vous passer d'un d√©mon fonctionnant en permanence lors de l'impl√©mentation d'API distantes. <br><br>  De plus, nous d√©veloppons un autre client pour Podman, appel√© podman-remote, qui impl√©mente la m√™me CLI Podman, mais appelle varlink pour lancer des conteneurs.  Podman-remote peut fonctionner en plus des sessions SSH, ce qui vous permet d'interagir en toute s√©curit√© avec des conteneurs sur diff√©rentes machines.  Au fil du temps, nous pr√©voyons d'utiliser podman-remote pour prendre en charge MacOS et Windows avec Linux, afin que les d√©veloppeurs sur ces plates-formes puissent ex√©cuter la machine virtuelle Linux avec Podman varlink en cours d'ex√©cution et avoir le sentiment que les conteneurs s'ex√©cutent sur la machine locale. <br><br><h4>  SD_NOTIFY </h4><br>  Systemd vous permet de retarder le lancement des services auxiliaires jusqu'au d√©marrage du service conteneuris√© requis.  Podman peut transmettre la socket SD_NOTIFY au service conteneuris√© afin que le service informe systemd de sa disponibilit√© au travail.  Et encore une fois, Docker, utilisant le mod√®le client-serveur, ne sait pas comment. <br><br><h3>  Dans les plans </h3><br>  Nous pr√©voyons d'ajouter la commande podman generate systemd CONTAINERID, qui g√©n√©rera le fichier d'unit√© systemd pour g√©rer un conteneur sp√©cifique.  Cela devrait fonctionner dans les modes root et rootless pour les conteneurs non privil√©gi√©s.  Nous avons m√™me vu une demande de cr√©ation d'un runtime systemd-nspawn compatible OCI. <br><br><h3>  Conclusion </h3><br>  L'ex√©cution de systemd dans un conteneur est un besoin compr√©hensible.  Et gr√¢ce √† Podman, nous avons enfin un environnement de lancement de conteneurs qui n'est pas hostile √† systemd, mais qui le rend facile √† utiliser. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468931/">https://habr.com/ru/post/fr468931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468913/index.html">Bouton Amazon Dash: r√©trospective</a></li>
<li><a href="../fr468915/index.html">Comment Cisco surveille-t-il la s√©curit√© des informations des entreprises absorb√©es et leur donne-t-il acc√®s √† leurs ressources?</a></li>
<li><a href="../fr468923/index.html">Je te rappelle</a></li>
<li><a href="../fr468927/index.html">Quintet au lieu de Byte - approche de stockage et de r√©cup√©ration des donn√©es</a></li>
<li><a href="../fr468929/index.html">Le mini-manuel sur la configuration d'un hackintosh est aussi simple et indolore que possible</a></li>
<li><a href="../fr468933/index.html">√âpineux et tranchant, o√π que vous regardiez: le m√©canisme d'auto-aff√ªtage des dents des oursins</a></li>
<li><a href="../fr468935/index.html">Le condens√© des √©v√©nements pour les professionnels des RH dans le domaine des TI en octobre 2019</a></li>
<li><a href="../fr468937/index.html">Attaques par carte bancaire sans contact</a></li>
<li><a href="../fr468943/index.html">cela et ScopeChain en EcmaScript</a></li>
<li><a href="../fr468945/index.html">ITIL et ITSM sont une histoire de grande d√©ception. Y a-t-il un avantage? Combien cela co√ªte-t-il et qui exactement ¬´n'impl√©mente pas ITIL¬ª?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>