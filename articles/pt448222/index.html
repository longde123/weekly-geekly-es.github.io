<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≤ üëÜüèª üåÖ GPU, aceleradores hexagonais e √°lgebra linear üï° üíÉ üëãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todas essas palavras est√£o muito mais relacionadas ao desenvolvimento m√≥vel do que parece √† primeira vista: aceleradores hexagonais j√° est√£o ajudando ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU, aceleradores hexagonais e √°lgebra linear</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448222/"> Todas essas palavras est√£o muito mais relacionadas ao desenvolvimento m√≥vel do que parece √† primeira vista: aceleradores hexagonais j√° est√£o ajudando a treinar redes neurais em dispositivos m√≥veis;  √°lgebra e matan s√£o √∫teis para conseguir um emprego na Apple;  A programa√ß√£o da GPU n√£o apenas permite acelerar os aplicativos, mas tamb√©m ensina a ver a ess√™ncia das coisas. <br><br>  Em qualquer caso, diz o chefe do desenvolvimento m√≥vel da Prisma, <b>Andrey Volodin</b> .  E tamb√©m sobre como as id√©ias fluem para o desenvolvimento m√≥vel do GameDev, como os paradigmas diferem, por que o Android n√£o possui desfoque nativo - e muito mais, uma vers√£o produtiva do AppsCast foi lan√ßada.  Sob o corte, falaremos sobre o relat√≥rio de Andrey no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> sem spoilers. <br><br><img src="https://habrastorage.org/webt/0q/af/fk/0qaffkk1onyogn5werp4i1_rcxg.jpeg"><br><a name="habracut"></a><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O AppsCast</a> √© o podcast da confer√™ncia para desenvolvedores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativos</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> .</i>  <i>Cada edi√ß√£o √© um novo convidado.</i>  <i>Cada convidado √© um orador da confer√™ncia com quem discutimos seu relat√≥rio e falamos sobre t√≥picos relacionados a ele.</i>  <i>O podcast √© organizado por membros do comit√™ do programa AppsConf, Alexei Kudryavtsev e Daniil Popov.</i> <br><br>  <strong>Alexey Kudryavtsev:</strong> Ol√° pessoal!  Andrey, por favor, conte-nos sobre a sua experi√™ncia. <br><br>  <b>Andrey Volodin</b> : N√≥s da Prisma estamos desenvolvendo produtos relacionados principalmente ao processamento de fotos e v√≠deos.  Nosso aplicativo principal √© o Prisma.  Agora, estamos criando outro aplicativo Lensa para funcionalidade do tipo Facetune. <br><br>  Lidero o desenvolvimento m√≥vel, mas sou treinador de jogos.  Eu tenho toda a parte principal, escrevo pipelines de GPU para todos esses aplicativos.  Desenvolvo estruturas b√°sicas para que os algoritmos e neur√¥nios desenvolvidos pela equipe de P&amp;D funcionem em dispositivos m√≥veis, funcionem em tempo real.  Em suma, matar a computa√ß√£o do servidor e tudo mais. <br><br>  <b>Alexei Kudryavtsev:</b> N√£o parece um desenvolvimento regular do iOS. <br><br>  <b>Andrey Volodin:</b> Sim, tenho essas especificidades - escrevo no Swift todos os dias, mas ao mesmo tempo est√° muito longe do que √© considerado desenvolvimento iOS. <br><br>  <b>Daniil Popov:</b> Voc√™ mencionou os pipelines da GPU, do que se trata? <br><br>  <b>Andrey Volodin:</b> Ao criar editores de fotos, voc√™ tamb√©m precisa configurar a arquitetura e decompor a l√≥gica, porque o aplicativo possui ferramentas diferentes.  Por exemplo, em Lensa, existe uma ferramenta de bokeh que desfoca o fundo usando um neur√¥nio, h√° uma ferramenta de retoque que deixa uma pessoa mais bonita.  Tudo isso precisa funcionar com mais efici√™ncia na GPU.  Al√©m disso, √© aconselh√°vel n√£o transferir dados entre o processador e a placa de v√≠deo todas as vezes, mas criar previamente um conjunto de opera√ß√µes, execut√°-las em uma execu√ß√£o e mostrar ao usu√°rio o resultado final. <br><br>  Os pipelines da GPU s√£o "pequenos peda√ßos" dos quais s√£o montadas as instru√ß√µes para uma placa de v√≠deo.  Ent√£o ela faz tudo isso de maneira r√°pida e eficiente, e voc√™ obt√©m o resultado de cada vez, e n√£o ap√≥s cada instrumento.  Garanto que nossos pipelines de GPU sejam o mais r√°pido poss√≠vel, eficientes e geralmente existam em princ√≠pio. <br><br>  <b>Alexey Kudryavtsev:</b> Diga-me, como voc√™ chegou a isso?  Um desenvolvedor iOS regular come√ßa com rebites e moldes, depois passa pela API e fica feliz.  Como aconteceu que voc√™ est√° fazendo algo completamente diferente? <br><br>  <b>Andrey Volodin:</b> Na maior parte, isso √© uma coincid√™ncia.  Antes de conseguir um emprego, fiz jogos para iOS.  Sempre foi interessante para mim, mas entendi que, na R√∫ssia, n√£o h√° lugar especialmente para se desenvolver nessa dire√ß√£o.  Aconteceu que nos encontramos com o Prisma.  Eles precisavam de um desenvolvedor iOS que pudesse escrever no Swift e, ao mesmo tempo, conhecer a GPU, em particular o Metal, que acabou de ser lan√ßada na √©poca, e eu definitivamente me encaixo nessa descri√ß√£o. <br><br>  Respondi √† vaga, tivemos uma sinergia e, pelo terceiro ano, estou aprofundando cada vez mais isso.  Se algo der errado agora, ent√£o eu j√° tenho todos esses Viper e MVVMs - nem sei como descriptografar - vou ter que entender desde o in√≠cio. <br><br><h2>  O que o engenheiro da GPU faz </h2><br>  <b>Daniil Popov:</b> Seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">perfil do</a> AppsConf diz a GPU do Engenheiro.  O que a GPU do Engineer faz a maior parte do dia al√©m de tomar caf√©? <br><br>  <b>Andrey Volodin:</b> Aqui √© necess√°rio mencionar como o processador √© fundamentalmente diferente da GPU.  O processador executa opera√ß√µes como se sequencialmente.  At√© o multithreading que possu√≠mos √© frequentemente falso: o processador para e alterna para realizar pequenos peda√ßos de tarefas diferentes e as executa em algumas partes.  A GPU funciona exatamente da maneira oposta.  Existem n processadores que realmente funcionam em paralelo e existe paralelismo entre processos e paralelismo na GPU. <br><br>  Meu trabalho principal, al√©m de coisas comuns, como otimizar o trabalho com mem√≥ria e organizar a reutiliza√ß√£o de c√≥digo, √© que eu porto os algoritmos escritos para a CPU nas placas de v√≠deo para que elas fiquem paralelas.  Isso nem sempre √© uma tarefa trivial, porque existem algoritmos muito eficientes que est√£o completamente ligados √† execu√ß√£o seq√ºencial de instru√ß√µes.  Meu trabalho √© apresentar, por exemplo, uma aproxima√ß√£o para um algoritmo que talvez n√£o seja exatamente a mesma coisa, mas visualmente o resultado n√£o possa ser distinguido.  Para que possamos obter acelera√ß√£o 100 vezes, um pouco de qualidade sacrificante. <br><br>  Eu tamb√©m estou portando neur√¥nios.  A prop√≥sito, em breve faremos um grande lan√ßamento de c√≥digo aberto.  Mesmo antes do Core ML aparecer, t√≠nhamos nosso pr√≥prio colega e finalmente amadurecemos para coloc√°-lo em c√≥digo aberto.  Seu paradigma √© um pouco diferente do Core ML.  Eu, inclusive, estou desenvolvendo sua parte principal. <br><br>  Em geral, fa√ßo tudo em torno dos algoritmos e da computa√ß√£o do Computer Vision. <br><br>  <b>Alexey Kudryavtsev:</b> Um an√∫ncio interessante. <br><br>  <b>Andrey Volodin:</b> Isso n√£o √© um segredo, n√£o o anunciaremos com algum tipo de alarde, apenas ser√° poss√≠vel ver um exemplo dos frameworks usados ‚Äã‚Äãno Prisma. <br><br><h2>  Por que otimizar para GPU </h2><br>  <b>Alexei Kudryavtsev:</b> Diga-me, por favor, por que otimizamos algoritmos para GPU em geral?  Pode parecer que basta adicionar n√∫cleos ao processador ou otimizar o algoritmo.  Por que exatamente a GPU? <br><br>  <b>Andrey Volodin: O</b> trabalho na GPU pode acelerar tremendamente os algoritmos.  Por exemplo, temos neur√¥nios que ser√£o executados no processador central Samsung S10 por 30 s e na GPU haver√° 1 quadro, ou seja, 1/60 s.  Isso est√° mudando incrivelmente a experi√™ncia do usu√°rio.  N√£o existe uma tela de carregamento eterno, voc√™ pode ver o resultado do algoritmo trabalhando no fluxo de v√≠deo ou girar o controle deslizante e ver os efeitos ali. <br><br><blockquote>  N√£o √© de todo interessante o fato de escrevermos na CPU, ent√£o reescrevemos tudo na GPU.  O uso de uma GPU tem um objetivo transparente - acelerar as coisas. </blockquote><br>  <b>Alexei Kudryavtsev: a</b> GPU lida com opera√ß√µes semelhantes entre si bem em paralelo.  Voc√™ tem exatamente essas opera√ß√µes e, portanto, consegue alcan√ßar esse sucesso? <br><br>  <b>Andrey Volodin:</b> Sim, a principal dificuldade n√£o √© codificar, mas criar esses algoritmos que s√£o bem transferidos para a GPU.  Isso nem sempre √© trivial.  Acontece que voc√™ descobriu como fazer tudo de bom, mas para isso voc√™ precisa de muitos pontos de sincroniza√ß√£o.  Por exemplo, voc√™ escreve tudo em uma propriedade, e este √© um sinal claro de que ser√° mal paralelo.  Se voc√™ escrever muito em um s√≥ lugar, todos os threads precisar√£o ser sincronizados para isso.  Nossa tarefa √© aproximar os algoritmos para que eles sejam paralelos. <br><br>  <b>Alexei Kudryavtsev:</b> Para mim, como desenvolvedor m√≥vel, soa como ci√™ncia de foguetes. <br><br>  <b>Andrey Volodin:</b> Na verdade, n√£o √© t√£o dif√≠cil.  Para mim, a ci√™ncia do foguete √© VIPER. <br><br><h2>  Terceiro chip </h2><br>  <b>Daniil Popov:</b> Parece que na √∫ltima confer√™ncia de E / S do Google eles anunciaram um peda√ßo de ferro para o TensorFlow e outras coisas.  Quando o terceiro chip finalmente aparecer√° em telefones celulares, TPU ou como ser√° chamado, o que tamb√©m far√° toda a m√°gica do ML no dispositivo? <br><br>  <b>Andrey Volodin:</b> Temos <b>exatamente</b> isso, ele se conecta via USB e voc√™ pode direcionar neur√¥nios do Google.  A Huawei j√° tem isso, at√© escrevemos software para seus aceleradores hexagonais, para que os neur√¥nios de segmenta√ß√£o perseguissem rapidamente o P20. <br><br>  Devo dizer que no iPhone eles j√° existem.  Por exemplo, no iPhone XS mais recente, existe um coprocessador chamado NPU (Unidade de processamento neural), mas at√© agora apenas a Apple tem acesso a ele.  Este coprocessador j√° est√° cortando a GPU no iPhone.  Alguns modelos Core ML usam NPUs e, portanto, s√£o mais r√°pidos que o bare metal. <br><br>  Isso √© significativo, j√° que, al√©m dos neur√¥nios de menor infer√™ncia, o N√∫cleo ML requer muita a√ß√£o adicional.  Primeiro, voc√™ precisa converter os dados de entrada no formato Core ML, process√°-los e depois devolv√™-los em seu formato - voc√™ precisa convert√™-los novamente e s√≥ depois mostr√°-los ao usu√°rio.  Isso tudo leva algum tempo.  Escrevemos pipelines livres de sobrecarga que funcionam do come√ßo ao fim na GPU, enquanto os modelos Core ML s√£o mais r√°pidos precisamente devido a esse processo de hardware. <br><br><blockquote>  Provavelmente, na WWDC em junho, eles mostrar√£o uma estrutura para trabalhar com NPU. </blockquote><br>  Ou seja, como voc√™ disse, j√° existem dispositivos, apenas os desenvolvedores ainda n√£o podem us√°-los ao m√°ximo.  Minha hip√≥tese √© que as pr√≥prias empresas ainda n√£o entendem como fazer isso com cuidado na forma de uma estrutura.  Ou eles simplesmente n√£o querem ceder para ter uma vantagem no mercado. <br><br>  <b>Alexei Kudryavtsev:</b> Com o scanner de impress√µes digitais, a mesma coisa estava no iPhone, pelo que me lembro. <br><br>  <b>Andrey Volodin:</b> Ele n√£o √© t√£o super acess√≠vel agora.  Voc√™ pode us√°-lo em n√≠vel superior, mas n√£o consegue obter a impress√£o em si.  Voc√™ pode simplesmente pedir √† Apple para permitir que o usu√°rio a use.  Ainda n√£o √© esse acesso total ao pr√≥prio scanner. <br><br><h2>  Aceleradores hexagonais </h2><br>  <b>Daniil Popov:</b> Voc√™ mencionou o termo aceleradores hexagonais.  Eu acho que nem todo mundo sabe o que √©. <br><br>  <b>Andrey Volodin:</b> Essa √© apenas uma parte da arquitetura de hardware que a Huawei usa.  Devo dizer que ela √© bastante sofisticada.  Poucas pessoas sabem, mas em alguns Huawei esses processadores s√£o, mas n√£o s√£o usados, porque possuem um bug de hardware.  Huawei lan√ßou-os e, em seguida, encontrou um problema, agora em alguns telefones chips especiais s√£o peso morto.  Em vers√µes novas, tudo j√° funciona. <br><br>  Na programa√ß√£o, existe o paradigma SIMD (Instru√ß√£o √önica, V√°rios Dados), quando as mesmas instru√ß√µes s√£o executadas em paralelo em dados diferentes.  O chip foi projetado de forma a poder processar alguma opera√ß√£o em paralelo em v√°rios fluxos de dados ao mesmo tempo.  Em particular, hexagonal significa que em 6 elementos em paralelo. <br><br>  <b>Alexei Kudryavtsev:</b> Eu pensei que a GPU simplesmente funciona assim: vetoriza uma tarefa e executa a mesma opera√ß√£o em dados diferentes.  Qual a diferen√ßa? <br><br>  <b>Andrey Volodin</b> : GPU √© de prop√≥sito mais geral.  Apesar de a programa√ß√£o da GPU ser de n√≠vel bastante baixo, no que diz respeito ao trabalho com coprocessadores, √© de n√≠vel bastante alto.  Para a programa√ß√£o na GPU, √© usada uma linguagem C.  No iOS, o c√≥digo ainda √© compilado com o LLVM nas instru√ß√µes da m√°quina.  E essas coisas para coprocessadores costumam ser escritas diretamente diretamente - no montador, nas instru√ß√µes da m√°quina.  Portanto, o aumento da produtividade √© muito mais percept√≠vel, porque eles s√£o aprimorados para opera√ß√µes espec√≠ficas.  Voc√™ n√£o pode contar com nada, mas pode contar apenas para o que eles foram originalmente destinados. <br><br>  <b>Alexei Kudryavtsev:</b> E por que eles geralmente s√£o projetados? <br><br>  <b>Andrey Volodin:</b> Agora principalmente para as opera√ß√µes mais comuns em redes neurais: convolu√ß√£o - convolu√ß√£o ou algum tipo de ativa√ß√£o intermedi√°ria.  Eles t√™m uma funcionalidade pr√©-cabeada que funciona super-rapidamente.  Portanto, eles s√£o muito mais r√°pidos em algumas tarefas que a GPU, mas em todo o resto eles simplesmente n√£o s√£o aplic√°veis. <br><br>  <b>Alexei Kudryavtsev:</b> Parece que os processadores DSP, que costumavam ser usados ‚Äã‚Äãpara √°udio, e todos os plugins e efeitos trabalharam neles muito rapidamente.  Foi vendido um hardware caro especial, mas os processadores cresceram e agora gravamos e processamos podcasts diretamente em laptops. <br><br>  <b>Andrey Volodin:</b> Sim, sobre o mesmo. <br><br><h2>  GPU n√£o apenas para gr√°ficos </h2><br>  <b>Daniil Popov:</b> Entendo corretamente que agora na GPU voc√™ pode processar dados que n√£o est√£o diretamente relacionados aos gr√°ficos?  Acontece que a GPU est√° perdendo seu objetivo original. <br><br>  <b>Andrey Volodin:</b> Exatamente.  Costumo falar sobre isso em confer√™ncias.  Os primeiros foram a NVidia, que apresentou o CUDA.  Essa √© uma tecnologia que simplifica a GPGPU (computa√ß√£o de uso geral em unidades de processamento gr√°fico).  Voc√™ pode escrever nele um superconjunto de algoritmos C ++ que s√£o paralelos na GPU. <br><br>  Mas as pessoas j√° fizeram isso antes.  Por exemplo, artes√£os no OpenGL ou no DirectX ainda mais antigo simplesmente gravaram dados na textura - cada pixel foi interpretado como dados: os primeiros 4 bytes no primeiro pixel, os segundos 4 bytes no segundo.  Eles processaram as texturas e depois os dados da textura foram extra√≠dos e interpretados.  Era muito apertado e complicado.  Agora, as placas de v√≠deo suportam l√≥gica de uso geral.  Voc√™ pode alimentar qualquer buffer na GPU, descrever suas estruturas, at√© a hierarquia de estruturas nas quais elas se referir√£o umas √†s outras, calcular algo e devolv√™-lo ao processador. <br><br>  <b>Daniil Popov:</b> Ou seja, podemos dizer que a GPU agora √© Data PU. <br><br>  <b>Andrey Volodin:</b> Sim, √†s vezes os gr√°ficos na GPU s√£o processados ‚Äã‚Äãmenos que os c√°lculos gerais. <br><br>  <b>Alexei Kudryavtsev: A</b> arquitetura da CPU e da GPU √© diferente em ess√™ncia, mas voc√™ pode considerar isso l√° e ali. <br><br>  <b>Andrey Volodin</b> : De fato, em alguns aspectos, a CPU √© mais r√°pida, em alguns aspectos, a GPU.  Isso n√£o quer dizer que a GPU seja sempre mais r√°pida. <br><br>  <b>Daniil Popov:</b> Tanto quanto me lembro, se a tarefa √© calcular algo muito diferente, ent√£o na CPU pode ser muito mais r√°pido. <br><br>  <b>Andrey Volodin: Tamb√©m</b> depende da quantidade de dados.  Sempre h√° a sobrecarga de transfer√™ncia de dados da CPU para a GPU e vice-versa.  Se voc√™ considerar, por exemplo, um milh√£o de elementos, o uso de uma GPU geralmente √© justificado.  Mas contar mil elementos em uma CPU pode ser mais r√°pido do que copi√°-los para uma placa gr√°fica.  Portanto, voc√™ deve sempre escolher a tarefa. <br><br>  A prop√≥sito, o Core ML faz isso.  O Core ML pode executar, de acordo com a Apple, a escolha de onde √© mais r√°pido calcular: no processador ou na placa de v√≠deo.  N√£o sei se isso funciona na realidade, mas eles dizem que sim. <br><br><h2>  Hardcore GPU Engineer conhecimento para um desenvolvedor m√≥vel </h2><br>  <b>Alexey Kudryavtsev:</b> Vamos voltar ao desenvolvimento m√≥vel.  Voc√™ √© um engenheiro de GPU, possui toneladas de conhecimento intenso.  Como esse conhecimento pode ser aplicado a um desenvolvedor de dispositivos m√≥veis?  Por exemplo, o que voc√™ v√™ no UIKit que outras pessoas n√£o veem? <br><br>  <b>Andrey Volodin:</b> Vou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falar</a> sobre isso em detalhes no AppsConf.  Voc√™ pode aplicar muito onde.  Quando vejo, por exemplo, como a API do UIKit funciona, posso entender imediatamente por que isso √© feito e por qu√™.  Observando a queda de desempenho ao renderizar algumas visualiza√ß√µes, posso entender o motivo, porque sei como a renderiza√ß√£o √© escrita dentro.  Entendo: para exibir os efeitos que o desfoque gaussiano realmente faz sobre o buffer de quadros, voc√™ primeiro precisa armazenar em cache toda a textura, aplicar uma opera√ß√£o de desfoque pesado a ela, retornar o resultado, terminar de renderizar o restante das visualiza√ß√µes e mostr√°-lo na tela.  Tudo isso deve caber em 1/60 de segundo, caso contr√°rio, diminuir√° a velocidade. <br><br>  √â absolutamente √≥bvio para mim por que isso faz muito tempo, mas para meus colegas isso n√£o est√° claro.  √â por isso que quero compartilhar os truques de design que costumamos usar no GameDev, e minhas id√©ias sobre como encaro os problemas e tento resolv√™-los.  Ser√° um experimento, mas acho que deve ser interessante. <br><br><h2>  Por que o Android n√£o tem desfoque nativo </h2><br>  <b>Daniil Popov:</b> Voc√™ mencionou o desfoque, e eu acho que tenho uma pergunta que preocupa todos os desenvolvedores do Android: por que existe um bluer nativo no iOS e n√£o no Android. <br><br>  <b>Andrei Volodin:</b> Eu acho que isso √© por causa da arquitetura.  As plataformas da Apple usam a arquitetura de renderiza√ß√£o Tiled Shading.  Com essa abordagem, nem todo o quadro √© renderizado, mas pequenos blocos - quadrados, partes da tela.  Isso permite otimizar a opera√ß√£o do algoritmo, porque o principal ganho de desempenho ao usar a GPU fornece um uso eficiente do cache.  No iOS, o quadro geralmente √© renderizado para que n√£o ocupe mem√≥ria.  Por exemplo, no iPhone 7 Plus, a resolu√ß√£o √© 1920 * 1080, que √© de cerca de 2 milh√µes de pixels.  N√≥s multiplicamos por 4 bytes por canal, resultando em cerca de 20 megabytes por quadro.  20 MB para simplesmente armazenar o buffer do quadro do sistema. <br><br>  A abordagem Tiled Shading permite dividir esse buffer em peda√ßos pequenos e renderiz√°-lo um pouco.  Isso aumenta muito o n√∫mero de acessos ao cache, porque, para desfocar, voc√™ precisa ler os pixels j√° desenhados e calcular a distribui√ß√£o Gaussiana neles.  Se voc√™ ler o quadro inteiro, a taxa de cache ser√° muito baixa, porque cada fluxo ler√° lugares diferentes.  Mas se voc√™ ler pequenos peda√ßos, a taxa de cache ser√° muito alta e a produtividade tamb√©m ser√° alta. <br><br>  Parece-me que a falta de desfoque nativo no Android est√° conectada aos recursos arquitet√¥nicos.  Embora, talvez essa seja uma solu√ß√£o de produto. <br><br>  <b>Daniil Popov:</b> No Android, existe o RenderScript para isso, mas √© preciso misturar, desenhar, incorporar com as m√£os.  Isso √© muito mais complicado do que definir uma caixa de sele√ß√£o no iOS. <br><br>  <b>Andrey Volodin:</b> Provavelmente, o desempenho tamb√©m √© menor. <br><br>  <b>Daniil Popov:</b> Sim, a fim de satisfazer a lista de desejos do designer, temos que reduzir a escala da imagem, deix√°-la em azul e, em seguida, aumentar a escala para salvar de alguma forma. <br><br>  <b>Andrey Volodin:</b> A prop√≥sito, com isso voc√™ pode fazer truques diferentes.  A distribui√ß√£o gaussiana √© um c√≠rculo desfocado.  O Gauss sigma depende do n√∫mero de pixels que voc√™ deseja que eles coligam.  Freq√ºentemente, como otimiza√ß√£o, voc√™ pode reduzir a escala da imagem e reduzir um pouco o sigma e, quando retornar a escala original, n√£o haver√° diferen√ßa, pois o sigma depende diretamente do tamanho da imagem.  Costumamos usar esse truque para acelerar o desfoque. <br><br>  <b>Daniil Popov:</b> No entanto, o RenderScript no Android n√£o permite que voc√™ fa√ßa um raio maior que 30. <br><br>  <b>Andrey Volodin:</b> Na verdade, um raio de 30 √© muito.  Mais uma vez, entendo que coletar 30 pixels usando uma GPU em cada thread √© muito caro. <br><br><h2>  O que s√£o desenvolvimento m√≥vel semelhante e GameDev </h2><br>  <b>Alexei Kudryavtsev:</b> Nas teses do seu relat√≥rio, voc√™ diz que o desenvolvimento m√≥vel e o GameDev t√™m muito em comum.  Me conte um pouco, o que exatamente? <br><br>  <b>Andrey Volodin: A</b> arquitetura do UIKit lembra muito os mecanismos de jogo e os antigos.  Os modernos foram na dire√ß√£o do Sistema de Componentes de Entidades, e isso tamb√©m estar√° no relat√≥rio.  Isso tamb√©m se aplica ao UIKit, existem artigos que escrevem sobre como voc√™ pode projetar visualiza√ß√µes em componentes.     GameDev,  Component System    Thief  98 . <br><br> , , Cocos2d,      ,  ,     ,  .  ,    Scene graph ‚Äî  ,      -,        ,    iOS  CGAffineTransform.    4*4,  ,    .     . <br><br>    ,   UIKit      .    -  ‚Äî       .    :  GameDev     ,   UIKit  setNeedsLayout, layoutIfNeeded. <br><br>        ‚Äî  ,   - ,   ,      Apple.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> . <br><br> <b> :</b> , API Cocos2d   iOS ( UI).  ,         ? <br><br> <b> :</b> ,  - . Cocos2d   2008-2009 ,  UIKit    UIKit,    .   ,  -    ,     ,     . <br><br> ,   :  core- Cocos2d    Apple,   Apple   Cocos2d,     . SpriteKit      ,    Cocos2d.    Apple   . <br><br> <b> :</b>  ,   ,   UIKit  2009,    MacOS,     .    setNeedsLayout, layoutIfNeeded ,  . <br><br> <b> :</b> ,  GameDev   ,  MacOS. <br><br> <b> :</b>  ! <br><br> <b> :</b>     Cocos2d   Apple,      ,    GameDev.   GameDev   ,   ‚Äî  .     ,  GameDev   ,    ,   .  ,  ,     . <br><br> <b> :</b> ,    - ,   ‚Äî  . <br><br> <b> </b> : ,   , ,       ,   ‚Äî  .    Protocol-Oriented Programming  Swift, ,    - .  GameDev      . <br><br> <b> :</b>  :     ,   .  ,    ,    ,     . <br><br><h2>     GameDev </h2><br> <b> :</b>    :  GameDev     ,    GameDev    ? <br><br> <b> :</b>  ,    ,     .       ¬´  ,  ¬ª.    ,     .      :    ,    ,  . <br><br> GameDev-    .     : 30  60        ,  ,   ,    .   ,      .      ‚Äî       .  --   1/60  1/30 .   ,     , ,  GPU  ,   CPU .        ,    . <br><br> <b> :</b>         ? <br><br> <b> :</b>    . -       , , ,         .     ‚Äî   .     , , ,  ‚Äî  - ,  - ,  .      ,      ,      . <br><br>      . , GPU     float,    double, -    . , ,     ,    .  CPU  ,        ,       ,   GPU     . <br><br>      ,      ,    ‚Äî     . <br><br><h2>      GameDev,    </h2><br> <b> :</b>        ,  ¬´     GameDev,   ¬ª.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>    ,     ,   .     ,  GameDev ‚Äî      .        ,  .      GameDev. <br><br> <b> :</b> , enterprise-   ,    GameDev    .      .   ,     ,    GameDev,     . <br><br> ,  .    ,      4*4.  CGAffineTransform ‚Äî    ,   -        ,   . <br><br><blockquote>        ,     ,   ,  ,    . </blockquote><br><h2>    </h2><br> <b> :</b>       ?  ,       UIKit,     ,     ?  ,   ,       ,   .   ,     ? <br><br> <b> :</b>    ‚Äî   pet project. <br><br> ,      :    GPU     ,     . iOS GPU      ,     .    iOS     ,     -  NVidia  AMD-   .    . API  ,   ,         . <br><br> <b> :</b>   API, ,   Cocos2d  Unity,      ‚Äî   - .    ,    ,   ,   UIKit    ? <br><br> <b> :</b> Cocos2d ‚Äî Open Source    .    ,      ,   ,     ,     .       objective-C,        . <br><br>      pet project,          ,   ,   API,  , , -. ,   API,   VHS-.    ,   GPU.    ,     .     ,      .      ,   : ¬´     saturation  Instagram,   lightroom!¬ª ,   ,   4      ‚Äî  . <br><br><blockquote>     ,   . </blockquote><br>         ‚Äî ,   , .     ,      ,    -  ,   ,      ,   . <br><br> <b> :</b>    ,   -  . ,  Cocos2d -  ‚Äî  5  ,       ,    ,    ,   . ,       ,   ,    .. <br><br> <b> :</b>   .       ,   .   ,         ,          ,        ,        ,    , , ,    ,     . <br><br> <b> :</b>     ,       . ,     ,    . <br><br> <b> :</b>     .    ,  ,       .       ,      Apple,   ARKit.       ,       ,    .    ,     ,        ,     ,   . <br><br> ,            ,  : ¬´,      IDE, ,   ,     ,   .        ¬ª. <br><br> <b> :</b>   ‚Äî  ? <br><br> <b> :</b> , ,    ,      . <br><br> <b> :</b>   ,   ,       . <br><br> <b> :</b> ,      ,   ,  VR   .    Project Template  Xcode,    ,   , - .    ,       . <br><br> <b> :</b>       . <br><br><h2>  </h2><br> <b> :</b>  -  ,      GameDev  GPU. <br><br> <b> :</b>    .   - ,      ,   ,  .   ,         ,   ,   ,  ,      UI: ,  , runtime Objective-C ‚Äî  ,    ,     .     .      ,     : ,  ‚Äî , X  Y, ! <br><br><blockquote>    ,  ,  - ,  GameDev  GPU- ‚Äî   . </blockquote><br> <b>        ,   .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> 22  23     .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448222/">https://habr.com/ru/post/pt448222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448212/index.html">Protocolo chin√™s AIBUS e reator qu√≠mico de laborat√≥rio</a></li>
<li><a href="../pt448214/index.html">Proxies ES6 na pr√°tica</a></li>
<li><a href="../pt448216/index.html">Configurar uma montagem conveniente de projetos no Visual Studio</a></li>
<li><a href="../pt448218/index.html">Nova seguran√ßa da MFP: imageRUNNER ADVANCE III</a></li>
<li><a href="../pt448220/index.html">No√ß√µes b√°sicas do formato GLTF e GLB, parte 1</a></li>
<li><a href="../pt448224/index.html">AppsConf para governar todos eles</a></li>
<li><a href="../pt448226/index.html">Em busca do mesmo (t√≥picos de relat√≥rio para AppsConf)</a></li>
<li><a href="../pt448228/index.html">Tipos de modelagem. No√ß√µes b√°sicas de escultura, retopologia e varredura</a></li>
<li><a href="../pt448230/index.html">Gerenciando a continuidade dos neg√≥cios com o ClearView</a></li>
<li><a href="../pt448234/index.html">AI e MO: algumas tend√™ncias e tend√™ncias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>