<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§› ğŸ§–ğŸ¼ ğŸŒœ Mengapa menulis Kotak Data Bereaksi Anda pada tahun 2019 ğŸ¤½ğŸ¿ ğŸ¤šğŸ½ ğŸ‘¨ğŸ½â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya terlibat dalam pengembangan sistem ECM. Dan dalam serangkaian artikel singkat saya ingin berbagi pengalaman dan sejarah pengembangan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa menulis Kotak Data Bereaksi Anda pada tahun 2019</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457504/"><p>  Halo, Habr!  Saya terlibat dalam pengembangan sistem ECM.  Dan dalam serangkaian artikel singkat saya ingin berbagi pengalaman dan sejarah pengembangan Kotak Data React saya (selanjutnya hanya kotak), yaitu: </p><br><ul><li>  mengapa kami meninggalkan komponen yang sudah jadi </li><li>  masalah dan tugas apa yang kami hadapi ketika mengembangkan jaringan kami </li><li>  apa keuntungan yang berkembang dari kisi Anda </li></ul><br><h3 id="predystoriya">  Latar belakang </h3><br><p>  Sistem kami memiliki aplikasi web tempat pengguna bekerja dengan daftar dokumen, hasil pencarian, direktori.  Selain itu, daftar dapat berupa kecil (10 karyawan) atau sangat besar (50.000 kontraktor).  Untuk menampilkan daftar ini, kami mengembangkan kisi kami sendiri: </p><br><p><img src="https://habrastorage.org/webt/1m/v3/py/1mv3pyhnf7emxc6xs2h8lcv8dis.png" alt="gambar"></p><a name="habracut"></a><br><p>  Ketika kami mulai mengembangkan aplikasi web, kami ingin menemukan perpustakaan yang sudah jadi untuk menampilkan kisi-kisi yang dapat melakukan semua yang kami butuhkan: mengurutkan dan mengelompokkan catatan, menyeret dan melepas kolom, bekerja dengan banyak pilihan, memfilter dan menghitung total kolom, sebagian Unduh data dari server dan tampilkan puluhan ribu catatan. </p><br><p>  Saya akan menjelaskan persyaratan terakhir "menampilkan puluhan ribu catatan."  Dalam kisi-kisi, persyaratan ini diimplementasikan dalam beberapa cara: paging, scrolling infinity, scrolling virtual. </p><br><p>  Pendekatan paging dan scrolling tanpa batas adalah umum di situs web, Anda menggunakannya setiap hari.  Misalnya, paging di Google: </p><br><p><img src="https://habrastorage.org/webt/v5/5q/vz/v55qvz8wjlhqmp-jfzievdnjvxe.png" alt="gambar"></p><br><p>  Atau gulir tak terhingga di Google yang sama pada gambar, tempat bagian gambar berikutnya dimuat saat Anda menggulir ke bagian akhir bagian pertama: </p><br><p><img src="https://habrastorage.org/webt/bs/r7/qk/bsr7qkhgokj6ezk3qlagzkkgdaq.png" alt="gambar"></p><br><p>  Tetapi pengguliran virtual (selanjutnya disebut pengguliran virtual) jarang digunakan di web, perbedaan utamanya dari pengguliran tak terhingga adalah kemampuan untuk dengan cepat menggulir daftar yang sangat besar di mana saja.  Dalam hal ini, hanya data yang terlihat oleh pengguna yang akan diunduh dan ditampilkan. </p><br><p><img src="https://habrastorage.org/webt/wf/j8/ct/wfj8ctaao00cbfi1txsytvpqwae.png" alt="gambar"></p><br><p>  Untuk aplikasi web kami, saya ingin menggunakan scrolling virtual.  Saya setuju bahwa menggulir ke tempat mana pun dalam daftar 10.000 entri adalah kasus yang agak diciptakan.  Namun, pengguliran acak dalam 500-1000 catatan adalah kasus nyata. </p><br><p>  Ketika mereka menerapkan pengguliran virtual, mereka sering mengimplementasikan API perangkat lunak untuk mengelola pengguliran ini.  Ini adalah fitur yang sangat penting.  Pengguliran perangkat lunak digunakan, misalnya, untuk menempatkan catatan yang dipilih di tengah layar saat membuka direktori: </p><br><p><img src="https://habrastorage.org/webt/ny/up/na/nyupnajuldvlpnb294u203xvy-w.png" alt="gambar"></p><br><p>  Kembali ke persyaratan.  Apa lagi yang kami butuhkan: </p><br><ul><li>  API Manajemen Pengguliran Virtual </li><li>  Kustomisasi tampilan kisi (baris, kolom, menu konteks) sehingga kisi tidak terlihat asing di aplikasi kita </li><li>  Dukungan untuk teknologi yang kami gunakan: react, redux, dan flexbox </li><li>  Bahwa grid bekerja di ie11 </li></ul><br><p>  Secara umum, ada banyak persyaratan. </p><br><h3 id="popytka-pervaya-2016-god-devextreme-javascript-data-grid">  Upaya pertama (2016).  Kotak Data JavaScript ExExtreme </h3><br><p>  Tidak lama menjelajahi perpustakaan yang ada, kami menemukan Grid Data JavaScript DevExtreme.  Dengan persyaratan fungsional, kisi-kisi ini memenuhi semua kebutuhan kami dan memiliki penampilan yang sangat rapi.  Namun, itu tidak cocok untuk persyaratan teknologi (tidak bereaksi, tidak redux, tidak flexbox).  Pada saat itu, DevExtreme tidak memiliki kotak reaksi. </p><br><p>  Yah, janganlah bereaksi, kami memutuskan, karena kisi-kisi itu indah dan fungsional, kami akan menggunakannya.  Dan mereka menambahkan perpustakaan ke proyek mereka.  Ternyata kami menambahkan 3 MB skrip. </p><br><p>  Selama beberapa minggu, kami mengintegrasikan kisi-kisi ke dalam aplikasi web kami dan meningkatkan fungsionalitas dasar: </p><br><ul><li>  Dibungkus kotak untuk berteman dengan reaksi dan redux </li><li>  Mengangkat pengguliran virtual dan memuat sebagian data dari server web kami </li><li>  Penyortiran dan seleksi yang diterapkan </li></ul><br><p>  Dalam proses mengacaukan kisi-kisi, dua masalah serius menjadi jelas dan sejumlah masalah yang kurang serius. </p><br><h3 id="pervaya-sereznaya-problema">  Masalah serius pertama </h3><br><p>  Untuk membuat DevExtreme JavaScript Data Grid dengan redux sangat sulit.  Kami berhasil mengontrol pengaturan kolom dan menyorot catatan melalui redux, tetapi untuk menyimpan data yang dimuat porsi dalam redux, dan melakukan operasi CRUD pada mereka melalui redux - ini tidak realistis.  Saya harus membuat kruk itu, melewati redux, memanipulasi data grid.  Tongkat itu ternyata rumit dan rapuh.  Ini adalah bel alarm pertama yang tidak cocok dengan jaringan kami, tetapi kami terus mengacaukannya. </p><br><h3 id="vtoraya-sereznaya-problema">  Masalah serius kedua </h3><br><p>  Tidak ada API manajemen gulir virtual.  Kami tidak dapat menolak kontrol perangkat lunak dari pengguliran, kami harus mengulang sumber DevExtreme dan menemukan API kontrol pengguliran internal.  Tentu saja, API ini memiliki sejumlah keterbatasan, karena dirancang untuk penggunaan internal.  Akibatnya, kami berhasil membuat API internal lebih atau kurang berfungsi pada kasus kami, tetapi sekali lagi, melewati redux, dan lagi sekelompok kruk. </p><br><h3 id="menee-sereznye-problemy">  Masalah yang kurang serius </h3><br><p>  Masalah yang kurang serius muncul setiap saat, karena fungsi standar Grid Data JavaScript DevExtreme tidak sepenuhnya cocok untuk kami, dan kami mencoba memperbaikinya: </p><br><ol><li>  Meregangkan grid DevExtreme di ketinggian tidak bekerja.  Saya harus menulis hack untuk mengajar DevExtreme bagaimana melakukan ini (mungkin tidak ada masalah dengan ini di versi terbaru). </li><li>  Ketika fokus tidak di grid, maka tidak mungkin untuk mengontrol pemilihan garis melalui keyboard (dan kami membutuhkannya).  Saya harus menulis kontrol keyboard saya. </li><li>  Saat mengubah komposisi kolom dan mengubah data, kami memiliki masalah berkedip data (dengan pengguliran virtual diaktifkan). </li><li>  Masalah sejumlah besar permintaan di tampilan pertama kotak.  Itu terutama terlihat ketika kami mengontrol pengguliran melalui API internal. </li><li>  Sulit untuk menyesuaikan beberapa bagian dari kisi UI.  Misalnya, ada keinginan di atas garis kisi yang dipilih untuk menggambar tindakan manajemen garis (hapus garis, salin, buka kartu).  Tetapi bagaimana mengacaukan ini ke DevExtreme tidak jelas, dan bahkan menggunakan react: <br><img src="https://habrastorage.org/webt/yo/zv/9b/yozv9boc174n-rxmbdsxoham4g8.png" alt="gambar"></li><li>  Sulit untuk menyortir penyortiran (kami ingin menyortir berdasarkan data yang tidak ditampilkan dalam kisi dan tidak dipetakan ke dalam kolom). </li><li>  Kruk diperlukan untuk mengacaukan komponen reaksi ke dalam sel-sel kisi (setelah semua, kisi tidak pada reaksi). </li><li>  Tidak mengetik kode DevExtreme (aliran / naskah). </li><li>  Masalah kecepatan dengan pengguliran virtual yang panjang. </li><li>  Masalah kecepatan saat meregangkan / menyusun ulang kolom (setelah pengguliran virtual yang berkepanjangan). </li><li>  Ukuran skrip kotak adalah 3 Mb. </li></ol><br><p>  Meskipun grid fungsionalitas DevExtreme berisi semua yang kami butuhkan, tetapi saya ingin menulis ulang hampir semua fungsionalitas standar.  Selama penggunaannya, ditambahkan ratusan baris kode yang sulit dipahami yang mencoba memecahkan masalah berinteraksi dengan redux dan bereaksi, sulit untuk menggunakan grid non-reaksi dalam aplikasi reaksi. </p><br><h3 id="otkaz-ot-devextreme-poisk-alternativ">  Penolakan DevExtreme.  Cari alternatif </h3><br><p>  Setelah beberapa waktu menggunakan DevExtreme, diputuskan untuk meninggalkannya.  Buang semua peretasan, kode kompleks, serta skrip DevExtreme 3 MB.  Dan temukan atau tulis kisi baru. </p><br><p>  Kali ini, kami lebih memperhatikan studi grid yang ada.  MS Fabric DetailsList, ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid, KendoUI Grid dipelajari. <br>  Persyaratannya tetap sama, tetapi sudah ada dalam daftar yang jelas bagi kami. </p><br><p>  Persyaratan Teknologi: </p><br><ul><li>  bereaksi </li><li>  redux </li><li>  flexbox </li></ul><br><p>  Persyaratan Fungsional: </p><br><ul><li>  Pengguliran virtual (dengan kemampuan menampilkan puluhan ribu catatan) </li><li>  API Manajemen Bergulir </li><li>  Menyimpan data dan pengaturan kisi dalam redux </li><li>  Batch memuat data dari server web </li><li>  Manajemen kolom (regangkan / atur ulang / kontrol visibilitas) </li><li>  Pemilahan kolom + pemfilteran </li><li>  Pilihan ganda </li><li>  Suka-cari dengan backlight </li><li>  Pengguliran horizontal </li><li>  Keyboard </li><li>  Menu konteks (pada garis, pada area kosong, pada kolom) </li><li>  Mendukung ie11, edge, chrome, ff, safari </li></ul><br><p>  Pada titik ini, versi pertama dari DevExtreme React Grid sudah muncul, tetapi kami segera menjatuhkannya karena alasan berikut: </p><br><ul><li>  Pengguliran virtual tidak didukung di ie11 </li><li>  Pengguliran virtual tidak berfungsi bersamaan dengan pengunduhan data batch dari server (meskipun tampaknya ada beberapa solusi). </li><li>  Dan yang paling penting, saya tidak ingin menginjak penggaruk yang sama ketika saya ingin menulis ulang setengah fungsi standar dari kisi pihak ketiga. </li></ul><br><p>  Analisis solusi yang ada menunjukkan bahwa tidak ada "peluru perak".  Tidak ada kisi yang mencakup semua persyaratan kami.  Diputuskan untuk menulis kisi kami sendiri, yang dalam hal fungsionalitas kami akan mengembangkan ke arah yang kami butuhkan, dan berteman dengan teknologi yang dibutuhkan oleh produk kami. </p><br><h3 id="razrabotka-svoego-react-data-grid">  Mengembangkan Kotak Data Bereaksi Anda </h3><br><p>  Pengembangan grid dimulai dengan prototipe, di mana mereka menguji topik yang paling sulit bagi kami: </p><br><ul><li>  gulir virtual </li><li>  penyimpanan semua data kisi di Redux </li></ul><br><h3 id="virtual-scrolling">  Pengguliran virtual </h3><br><p>  Yang paling sulit ternyata adalah pengguliran virtual.  Sebagian besar, itu dibuat dalam salah satu dari 3 cara: </p><br><p>  <strong>1. Virtualisasi halaman</strong> <br>  Data diambil dalam bagian - halaman.  Saat menggulir, halaman yang terlihat ditambahkan, yang tidak terlihat dihapus.  Halaman ini terdiri dari 20-60 baris (biasanya ukurannya dapat disesuaikan).  Di sinilah produk pergi: DevExtreme JavaScript Data Grid, MS Fabric DetailsList. </p><br><p><img src="https://habrastorage.org/webt/h7/tf/5l/h7tf5lynlgmje6wunlcowkeabqa.png" alt="gambar"></p><br><p>  <strong>2. Virtualisasi baris demi baris</strong> <br>  Hanya garis yang terlihat yang ditarik.  Begitu garis meninggalkan layar, itu segera dihapus.  Produk berjalan seperti ini: Kotak ReactVirtualized, Kotak React DevExtreme, Kotak Telerik. </p><br><p><img src="https://habrastorage.org/webt/9j/zs/bh/9jzsbhqw0_up5gnkt2g7cw3uth0.png" alt="gambar"></p><br><p>  <strong>3. Kanvas</strong> <br>  Semua garis dan isinya digambar menggunakan Kanvas.  Inilah yang dilakukan Google Documents. </p><br><p><img src="https://habrastorage.org/webt/12/f_/hd/12f_hdydog5ponrdm9filxne_1u.png" alt="gambar"></p><br><p>  Saat mengembangkan kisi, kami membuat prototipe untuk ketiga opsi virtualisasi (bahkan untuk Canvas).  Dan mereka memilih virtualisasi halaman per halaman. </p><br><h3 id="pochemu-otkazalis-ot-drugih-variantov">  Mengapa meninggalkan opsi lain? </h3><br><p>  Virtualisasi baris demi baris memiliki masalah dengan kecepatan rendering dalam prototipe.  Begitu isi baris menjadi lebih rumit (banyak teks, sorot, pemangkasan, ikon, sejumlah besar kolom, dan di mana-mana flexbox), menjadi mahal untuk menambah / menghapus garis beberapa kali per detik.  Tentu saja, hasilnya juga tergantung pada browser (kami membuat dukungan, termasuk untuk ie11, edge): </p><br><p><img src="https://habrastorage.org/webt/fe/4v/xh/fe4vxhw7r5zjwqqezc7rmxubmmm.png" alt="gambar"></p><br><p>  Opsi Canvas sangat menggoda dalam kecepatan rendering, tetapi melelahkan.  Diusulkan untuk menggambar semuanya: teks, pembungkus teks, pemangkasan teks, highlighting, ikon, garis pemisah, highlighting, indentasi.  Buat reaksi dengan mengklik tombol mouse pada Canvas, sorot garis ketika Anda mengarahkan kursor.  Pada saat yang sama, beberapa elemen Dom (menunjukkan petunjuk, "tindakan pop-up" di telepon) harus diterapkan di atas Kanvas.  Itu masih perlu untuk memecahkan masalah teks kabur dan ikon di Canvas.  Semua ini panjang dan sulit dilakukan.  Meskipun kami menguasai prototipe.  Pada saat yang sama, setiap kustomisasi baris dan sel di masa depan akan menghasilkan kesusahan besar bagi kita. </p><br><h4 id="plyusy-postranichnoy-virtualizacii">  Manfaat paging </h4><br><p>  Virtualisasi halaman-demi-halaman yang dipilih memiliki kelebihan dibandingkan dengan baris-demi-baris, yang menentukan pilihannya: </p><br><ul><li>  Jika halaman sudah dirender, maka menggulir ke dalam halaman itu murah (pohon DOM tidak berubah saat menggulir).  Virtualisasi baris demi baris untuk setiap pengguliran kecil membutuhkan perubahan pohon DOM, dan ini mahal ketika pohon DOM rumit dan flexbox digunakan di mana-mana. </li><li>  Untuk daftar kecil (&lt;200 entri) halaman tidak dapat dihapus, cukup tambahkan.  Cepat atau lambat, semua halaman akan dibangun, dan menggulir akan sepenuhnya gratis (dalam hal waktu render). </li></ul><br><h4 id="vybor-razmera-stranicy">  Pemilihan ukuran halaman </h4><br><p>  Masalah terpisah adalah pilihan ukuran halaman.  Saya menulis di atas bahwa ukurannya dapat disesuaikan dan biasanya adalah 20-60 baris.  Halaman besar digambar untuk waktu yang lama, halaman kecil mengarah ke tampilan sering "layar putih" saat menggulir.  Secara eksperimental, ukuran halaman 25 baris telah dipilih.  Namun, untuk ie11 ukurannya telah dikurangi menjadi 5 baris.  Terasa seperti antarmuka di IE lebih responsif jika Anda menggambar banyak halaman kecil dengan penundaan kecil daripada yang besar dengan penundaan besar. </p><br><h4 id="react-i-virtual-scrolling">  Bereaksi dan gulir virtual </h4><br><p>  Virtualisasi halaman harus diimplementasikan menggunakan reaksi.  Untuk melakukan ini, beberapa tugas harus diselesaikan: </p><br><p>  <strong>Tugas 1. Bagaimana cara menambah / menghapus halaman melalui reaksi saat menggulir?</strong> </p><br><p>  Untuk mengatasi masalah ini, konsep berikut diperkenalkan: </p><br><ul><li>  model halaman </li><li>  tampilan halaman </li></ul><br><p>  Model adalah informasi untuk membangun pandangan.  Tampilan adalah komponen Bereaksi. </p><br><p><img src="https://habrastorage.org/webt/ud/da/qi/uddaqigdtketfoh6cwk6lnklcpo.png" alt="gambar"></p><br><p>  Bahkan, tugas virtualisasi setelah ini adalah memanipulasi model halaman: menyimpan daftar model halaman, menambah dan menghapus model saat menggulir.  Dan sudah dari daftar model melalui reaksi membangun / membangun kembali tampilan: </p><br><p><img src="https://habrastorage.org/webt/4m/sr/g0/4msrg0gy9qwsv9u-8ljjqhzllwa.png" alt="gambar"></p><br><p>  Dalam proses implementasi, aturan untuk bekerja dengan model halaman dibentuk: </p><br><ul><li>  Halaman harus ditambahkan satu per satu.  Setelah setiap penambahan, berikan waktu untuk menggambar.  Dapat diterima untuk menambahkan 1 halaman setiap 300-500 ms - ini adalah situasi pengguliran yang cepat.  Jika Anda menambahkan, misalnya, 5 halaman sekaligus, maka antarmuka pengguna hang pada konstruksinya. </li><li>  Halaman tidak perlu disimpan dalam lusinan.  Contoh situasi masalah: 20 halaman ditampilkan, pengguna pergi ke daftar lain dan semua 20 halaman harus dihapus sekaligus.  Menghapus sejumlah besar halaman adalah operasi yang mahal, membersihkan pohon DOM akan memakan waktu 1 detik.  Untuk menghindari ini, lebih baik menyimpan tidak lebih dari 10 halaman sekaligus. </li><li>  Untuk setiap manipulasi kolom (penataan ulang, penambahan, penghapusan, peregangan) lebih baik untuk menghapus halaman yang tidak terlihat oleh pengguna sebelumnya.  Ini akan menghindari pembangunan kembali yang mahal dari semua halaman yang dirender. </li></ul><br><p>  <strong>Tugas 2. Bagaimana cara menampilkan scollbar?</strong> </p><br><p>  Pengguliran virtual mengasumsikan bahwa bilah gulir tersedia, yang memperhitungkan ukuran daftar dan memungkinkan Anda untuk menggulir ke mana saja: </p><br><p><img src="https://habrastorage.org/webt/lo/rc/ut/lorcutgz7bcopbjltcnziudkgks.png" alt="gambar"></p><br><p>  Bagaimana cara menampilkan scollbar?  Solusi paling sederhana adalah dengan menggambar div yang tidak terlihat dari ukuran yang dibutuhkan, bukan data nyata.  Dan sudah di atas div ini kami menampilkan halaman yang terlihat: </p><br><p><img src="https://habrastorage.org/webt/pp/_x/vg/pp_xvgowd1qtrnyigxnszou0xnw.png" alt="gambar"></p><br><p>  <strong>Tugas 3. Bagaimana cara memantau ukuran viewport?</strong> </p><br><p>  Viewport adalah area data yang terlihat dari grid.  Mengapa mengawasi ukuran tubuhnya?  Untuk menghitung jumlah halaman yang perlu ditampilkan kepada pengguna.  Misalkan kita memiliki ukuran halaman kecil (5 baris) dan resolusi layar besar (1920x1080).  Berapa banyak halaman yang perlu ditampilkan oleh pengguna untuk menutup seluruh viewport? </p><br><p><img src="https://habrastorage.org/webt/tt/g3/sx/ttg3sxfvvuf320ydcwe6esbukp4.png" alt="gambar"></p><br><p>  Anda dapat memecahkan masalah ini jika Anda tahu ketinggian viewport dan tinggi satu halaman.  Sekarang mari kita rumit tugasnya, misalkan pengguna mengubah skala secara tajam di browser - set 50%: </p><br><p><img src="https://habrastorage.org/webt/s8/47/mt/s847mtipiappdqe0qqsli_yvj14.png" alt="gambar"></p><br><p>  Situasi dengan skala menunjukkan bahwa tidak cukup untuk mengetahui ukuran viewport sekali, Anda perlu memonitor ukurannya.  Dan sekarang kami akan merumitkan tugas sepenuhnya: elemen html tidak memiliki acara pengubahan ukuran, yang dapat Anda ikuti dan pantau ukurannya.  Hanya objek jendela yang telah diubah ukurannya. </p><br><p>  Hal pertama yang terlintas dalam pikiran adalah menggunakan timer dan terus-menerus mengumpulkan tinggi elemen html.  Tetapi ada solusi yang lebih baik yang kami lihat dengan DevExtreme JavaScript Data Grid: buat iframe yang tak terlihat, rentangkan ke ukuran kisi dan berlangganan acara pengubahan ukuran iframe.contentWindow: </p><br><p><img src="https://habrastorage.org/webt/fa/gi/ta/fagitaw870f5ahtworjownk__mk.png" alt="gambar"></p><br><p><img src="https://habrastorage.org/webt/dd/m9/tq/ddm9tqblgsmpwepcc7_gq7g32sm.png" alt="gambar"></p><br><h3 id="rezyume">  Ringkasan </h3><br><p>  PS Ini bukan akhir.  Pada artikel selanjutnya saya akan menceritakan bagaimana kami berteman dengan redux. </p><br><p>  Untuk mendapatkan gulir virtual penuh, banyak tugas lain harus diselesaikan.  Tetapi yang dijelaskan di atas adalah yang paling menarik.  Berikut beberapa tugas lain yang juga muncul: </p><br><ul><li>  Mempertimbangkan arah dan kecepatan bergulir ketika menambah / menghapus halaman. </li><li>  Memperhatikan perubahan data akun untuk meminimalkan pembuatan kembali model halaman.  Misalnya, menghapus satu baris, atau menambahkan satu baris, apa yang harus dilakukan dengan halaman yang sudah dirender?  Buang semuanya, atau tinggalkan beberapa?  Ada ruang untuk optimasi. </li><li>  Saat mengubah pilihan, atur ulang jumlah halaman minimum yang diperlukan. </li></ul><br><p>  Jika Anda memiliki pertanyaan tentang implementasi, Anda dapat menuliskannya di komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457504/">https://habr.com/ru/post/id457504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457490/index.html">Aisioshechka dari Zuckerberg - secara singkat dan dalam kasus Libra</a></li>
<li><a href="../id457494/index.html">"Dan jika aku tidak tahu matematika, apakah aku putus asa?" - spesialis menjawab pertanyaan yang sering diajukan tentang profesi dalam Ilmu Data</a></li>
<li><a href="../id457496/index.html">"Temukan Lima Perbedaan." Perbedaan Scalable dan Generasi - Kumpulan Tes Baru</a></li>
<li><a href="../id457500/index.html">Bagaimana kami melakukan autopilot untuk stasiun layanan</a></li>
<li><a href="../id457502/index.html">Bagaimana Model Penilaian RICE Meningkatkan Prioritas Fitur Produk</a></li>
<li><a href="../id457508/index.html">Parenting vs Machine Learning: membandingkan seorang ibu muda</a></li>
<li><a href="../id457510/index.html">Gunakan mcrouter untuk mengukur memcached secara horizontal</a></li>
<li><a href="../id457512/index.html">Replikasi logis antara versi PostgreSQL</a></li>
<li><a href="../id457514/index.html">Nevanger</a></li>
<li><a href="../id457516/index.html">Menulis Model Ancaman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>