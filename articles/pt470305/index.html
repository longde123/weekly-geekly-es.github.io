<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙃 😚 👩‍👩‍👦‍👦 Preparando-se para a certificação profissional da Spring. Container, IoC, Feijão 👚 ✏️ 👃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia, Habr. 


 Hoje decidi apresentar uma tradução de uma série de artigos em preparação para a certificação profissional da Spring . 


 Esta tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preparando-se para a certificação profissional da Spring. Container, IoC, Feijão</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470305/"><p>  Bom dia, Habr. </p><br><p>  Hoje decidi apresentar uma tradução de uma <a href="">série de artigos</a> em preparação para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">certificação profissional da Spring</a> . </p><br><p>  Esta tradução é apenas o primeiro artigo; se for para o público, continuarei a publicar traduções. </p><br><div class="spoiler">  <b class="spoiler_title">Por que estou fazendo isso, porque já existem vários materiais especializados?</b> <div class="spoiler_text"><ol><li>  Frequentemente, as informações nelas não são estruturadas, não são coletadas ou não são relevantes <br></li><li>  Jovens desenvolvedores podem não saber inglês.  Este ciclo pode ser usado não apenas para certificação, mas também para auto-treinamento / repetição de materiais. <br></li><li>  Esses materiais podem ser utilizados na preparação da entrevista, como  eles são organizados na forma de perguntas e respostas. <br></li><li> Uma vantagem importante e mais importante, esse controle de qualidade é feito de perguntas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia</a> Pivotal Oficial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estudo</a> . <br></li></ol><br><ul><li>  Eu deliberadamente perdi algumas perguntas que me pareciam supérfluas ou que não estavam no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guia</a> . </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Sumário</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Injeção de dependência, contêiner, IoC, feijão</a> </li><li>  AOP (programação orientada a aspectos) </li><li>  JDBC, Transações, JPA, Dados da Primavera </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bota de mola</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spring mvc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segurança de primavera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">REST</a> </li><li>  Teste </li></ol></div></div><br><img src="https://habrastorage.org/webt/r4/jl/yi/r4jlyi8dwzp-e9xvywevoicmwsg.jpeg"><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Vou escrever uma lista de fontes das quais o autor tirou materiais</b> <div class="spoiler_text"><ul><li>  Primavera 5 padrões de design <br></li><li>  Primavera em Ação 4ª edição <br></li><li>  Spring Security - Terceira Edição <br></li><li>  Certificação Core Spring 5 em detalhes por Ivan Krizsan <br></li><li>  Documentação do Spring e javadocs da API do Spring <br></li></ul></div></div><br><p>  Então, vamos começar. </p><br><div class="spoiler">  <b class="spoiler_title">O que é injeção de dependência (DI) e quais são seus benefícios?</b> <div class="spoiler_text"><p>  A injeção de dependência é um padrão especial que reduz a comunicação entre os componentes do Spring.  Assim, ao aplicar o DI, seu código fica mais limpo, mais simples, fica mais fácil de entender e testar. <br>  De acordo com o padrão de DI, a criação de objetos para dependências é transferida para a fábrica ou fornecida a terceiros.  Isso significa que podemos nos concentrar no uso desses objetos em vez de criá-los. </p><br><div class="spoiler">  <b class="spoiler_title">Benefícios DI</b> <div class="spoiler_text"><ul><li>  Comunicação reduzida entre partes do aplicativo <br></li><li>  Teste aprimorado <br></li><li>  Arquitetura de aplicativos aprimorada <br></li><li>  Reduz o código padrão <br></li><li>  Padroniza o desenvolvimento de aplicativos <br></li></ul></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Por que as interfaces são recomendadas para a criação de Spring beans?</b> <div class="spoiler_text"><ul><li>  Teste aprimorado.  Nos testes, o bean pode ser substituído por um objeto especial (mock ou stub) que implementa a interface do bean. <br></li><li>  Permite usar o mecanismo de proxy dinâmico do JDK (por exemplo, ao criar um repositório via Spring Data) <br></li><li>  Permite ocultar a implementação <br></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">O que é o contexto do aplicativo?</b> <div class="spoiler_text"><p> No Spring Framework, a interface <code>org.springframework.factory.BeanFactory</code> fornece uma fábrica de <code>org.springframework.factory.BeanFactory</code> , que ao mesmo tempo é um contêiner de aplicativo de IoC.  O gerenciamento de bean é baseado em configuração (java ou xml). </p><br><p>  A interface <code>org.springframework.context.ApplicationContext</code> é um invólucro em uma fábrica de beans que fornece alguns recursos adicionais, como AOP, transações, segurança, i18n etc. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que é um contêiner e qual é o seu ciclo de vida?</b> <div class="spoiler_text"><p>  A base do Spring Framework é um contêiner e nossos objetos "vivem" nesse contêiner. <br>  Um contêiner normalmente cria muitos objetos com base em suas configurações e gerencia seu ciclo de vida desde a criação de um objeto até a destruição. </p><br><p>  Um contêiner é um objeto que implementa a interface <b>ApplicationContext</b> . </p><br><div class="spoiler">  <b class="spoiler_title">Ciclo de vida do contêiner</b> <div class="spoiler_text"><ol><li>  O contêiner é criado quando o aplicativo é iniciado. <br></li><li>  O contêiner lê dados de configuração <br></li><li>  A descrição dos compartimentos é criada a partir dos dados de configuração <br></li><li>  BeanFactoryPostProcessors manipula a descrição do bean <br></li><li>  O contêiner cria beans usando sua descrição <br></li><li>  Beans são inicializados - valores e dependências de propriedades são incorporados no bean <br></li><li>  Métodos de retorno de chamada de início BeanPostProcessor <br></li><li>  O aplicativo está em funcionamento <br></li><li>  Fechamento de aplicativo inicializado <br></li><li>  O contêiner fecha <br></li><li>  Os métodos de retorno de chamada são chamados <br></li></ol></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Como criar uma instância do ApplicationContext?</b> <div class="spoiler_text"><p>  A primavera fornece várias variações de contexto. </p><br><p>  Existem várias implementações básicas da interface ApplicationContext: </p><br><ul><li>  FileSystemXmlApplicationContext <br></li><li>  ClassPathXmlApplicationContext <br></li><li>  AnnotationConfigApplicationContext <br></li><li>  XmlWebApplicationContext <br></li><li>  AnnotationConfigWebApplicationContext <br></li></ul><br><p>  Exemplos de criação de um contexto: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemXmlApplicationContext(                                     <span class="hljs-string"><span class="hljs-string">"c:/bean_properties.xml"</span></span>); ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnnotationConfigApplicationContext(                            <span class="hljs-string"><span class="hljs-string">"com.springdemoapp.JavaConfig.class"</span></span>);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Você pode descrever o ciclo de vida de um feijão em um recipiente?</b> <div class="spoiler_text"><ol><li>  Carregando descrições de compartimento, criando um gráfico de dependência (entre beans) </li><li>  Criando e <code>BeanFactoryPostProcessors</code> </li><li>  Criar Beans </li><li>  Spring injeta valores e dependências nas propriedades do bean </li><li>  Se o bean implementar o método <code>setBeanName()</code> na interface NameBeanAware, o ID do bean será passado para o método </li><li>  Se o bean implementar o BeanFactoryAware, o Spring estabelecerá uma referência para a fábrica do bean via <code>setBeanFactory()</code> nessa interface. </li><li>  Se o bean implementar a interface ApplicationContextAware, o Spring estabelecerá uma referência ao ApplicationContext por meio de <code>setApplicationContext()</code> . </li><li>  <code>BeanPostProcessor</code> é uma interface especial (sobre isso abaixo), e o Spring permite que os compartimentos implementem essa interface.  Ao implementar o método <code>postProcessBeforeInitialization()</code> , você pode alterar a instância do bean antes de inicializá-lo (o bean) (definir propriedades, etc.) </li><li>  Se os métodos de retorno de chamada estiverem definidos, o Spring os chamará.  Por exemplo, este é um método anotado por <code>@PostConstruct</code> ou o método <code>initMethod</code> de uma anotação <code>@Bean</code> . </li><li>  O feijão está pronto para uso.  Pode ser obtido usando o método <code>ApplicationContext#getBean()</code> . </li><li>  Depois que o contexto é fechado ( <code>close()</code> do ApplicationContext), o bean é destruído. </li><li>  Se o bean tiver um método anotado por <code>@PreDestroy</code> , esse método será chamado antes da destruição.  Se o bean implementar DisposibleBean, o Spring chamará o método <code>destroy()</code> para limpar recursos ou eliminar processos no aplicativo.  Se o método <code>@Bean</code> for definido na <code>destroyMethod</code> , também será chamado. <br><img src="https://habrastorage.org/webt/kx/at/5e/kxat5ery0dcq_sujzijmiqyutda.png"></li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Como obter o ApplicationContext no teste de integração?</b> <div class="spoiler_text"><p>  Se você estiver usando o JUnit 5, precisará especificar duas anotações: </p><br><ul><li>  @ExtendWith (TestClass.class) - usado para indicar uma classe de teste <br></li><li>  @ContextConfoguration (classes = JavaConfig.class) - carrega a configuração java / xml para criar contexto no teste <br></li></ul><br><p>  Você pode usar a anotação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>@SpringJUnitConfig</code></a> , que combina essas duas anotações. <br>  Você pode usar a anotação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>@SpringJUnitWebConfig</code></a> para testar a camada da web. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Como desligar o contexto em um aplicativo?</b> <div class="spoiler_text"><p>  Se este não é um aplicativo da web, existem duas maneiras: </p><br><ul><li>  Registre o shutdown-hook usando a chamada do método <code>registerShutdownHook()</code> , ela também é implementada na classe AbstractApplicationContext.  Este é o método preferido. </li><li>  Você pode chamar o método <code>close()</code> da classe AbstractApplicationContext. </li></ul><br><p>  No aplicativo Spring Boot: </p><br><ul><li>  O Spring Boot registrará o gancho de desligamento para você sozinho. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">O que é a configuração Java?</b>  <b class="spoiler_title">Como é aplicado?</b> <div class="spoiler_text"><p>  Para criar uma classe com configuração baseada no código Java, é necessário anotá-la com <br>  <code>@Configuration</code> . <br>  Esta classe conterá métodos de fábrica para criar grãos no contêiner. <br>  Esses métodos devem ser anotados com a anotação <code>@Bean</code> . </p><br><p>  Um exemplo: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DSConfig</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder          .create()          .username(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .password(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .url(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .driverClassName(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .build();  } }</code> </pre> <br><p>  Essa classe colocará uma instância da classe DataSource no contêiner.  Posteriormente, pode ser usado ao acessar o banco de dados. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">DI usando anotações, varredura de classe</b> <div class="spoiler_text"><p>  Varredura de componentes - o Spring detecta automaticamente os grãos que estarão no contêiner.  Estes são compartimentos com estereótipos de anotações. </p><br><p>  No entanto, a verificação de componentes não está ativada por padrão. <br>  Para ativar a varredura, anote a classe @ Configuration com a anotação <code>@ComponentScanning</code> .  O Spring verificará automaticamente o pacote que contém essa classe e todos os seus subpacotes. <br>  Você pode especificar outros pacotes para verificação e até classes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 2  @Configuration(basePackages = {"soundsystem", "video"})</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  @Configuration(basePackageClasses = "MyClass.class")</span></span></code> </pre> <br><p>  Fiação automática - O Spring injeta automaticamente dependências ao digitalizar ou colocar uma bandeja em um contêiner. <br>  A injeção de dependência usa a anotação <code>@Autowire</code> . </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que são estereótipos (anotações-estereótipos)?</b> <div class="spoiler_text"><p>  Estereótipos são anotações que indicam funcionalidade especial. <br>  Todos os estereótipos incluem anotação <code>@Component</code> . </p><br><div class="scrollable-table"><table><tbody><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Componente</a> </td><td>  A anotação raiz que marca uma classe como candidata à implementação automática </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Controlador</a> </td><td>  Indica que a classe é o controlador para enviar dados para a frente. <br></td></tr><tr><td>  @RestController </td><td>  Indica que a classe é o controlador para o REST. <br>  Contém anotações <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Controller</a> e @ResponseBody </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Serviço</a> </td><td>  Indica que a classe é um serviço para executar a lógica de negócios. </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Repositório</a> </td><td>  Indica que a classe é um repositório para trabalhar com o banco de dados. </td></tr><tr><td>  @Configuration </td><td>  Indica que a classe contém uma configuração Java (métodos @ Bean) </td></tr></tbody></table></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Quais são os escopos da lixeira?</b>  <b class="spoiler_title">Qual é a visibilidade padrão deles?</b> <div class="spoiler_text"><p>  Escopo - escopo.  Existem 2 escopos padrão. </p><br><div class="scrollable-table"><table><tbody><tr><td>  Singleton <br></td><td>  O escopo padrão.  Há apenas 1 instância de bean no contêiner <br></td></tr><tr><td>  Protótipo <br></td><td>  Qualquer número de instâncias de posição pode estar no contêiner <br></td></tr></tbody></table></div><br><p>  E 4 escopos em um aplicativo da web. </p><br><div class="scrollable-table"><table><tbody><tr><td>  Pedido <br></td><td>  Escopo - 1 solicitação HTTP.  Um novo bean é criado para cada solicitação. <br></td></tr><tr><td>  Sessão <br></td><td>  Escopo - 1 sessão.  Um novo bean é criado para cada sessão. <br></td></tr><tr><td>  Aplicação <br></td><td>  Escopo - Ciclo de Vida do ServletContext <br></td></tr><tr><td>  Soquete da Web <br></td><td>  Escopo - Ciclo de vida do WebSocket <br></td></tr></tbody></table></div><br><p>  O escopo é indicado usando a anotação <code>@Bean</code> nos métodos <code>@Bean</code> . </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Como os vários escopos e multithreading estão relacionados?</b> <div class="spoiler_text"><p>  O escopo do protótipo não é seguro para threads porque  não garante que a mesma instância será chamada apenas em 1 thread. </p><br><p>  O Singleton Scope, por outro lado, é seguro para threads. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Como os beans são criados: instantânea ou preguiçosamente?</b>  <b class="spoiler_title">Como mudar esse comportamento?</b> <div class="spoiler_text"><p>  Os beans Singleton geralmente são criados imediatamente após a varredura. <br>  Os protótipos de feijão geralmente são criados somente mediante solicitação. </p><br><p>  Você pode usar a anotação <code>@Lazy</code> para indicar como inicializar. <br>  Ele é colocado nos métodos @ Bean, nas classes @ Configuration ou nas classes @ Component. <br>  Dependendo do parâmetro (verdadeiro ou falso) que a anotação aceita, a inicialização será lenta ou ocorrerá imediatamente.  Por padrão (ou seja, sem especificar um parâmetro), true é usado. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que acontece se um compartimento com um escopo for incorporado em um compartimento com outro escopo?</b> <div class="spoiler_text"><p>  O feijão Singleton pode ser incorporado em qualquer outro feijão. </p><br><p>  Somente <em><code>prototype</code></em> ou <em><code>singleton</code></em> pode ser incorporado no <em><code>singleton</code></em> . <br>  Se você implementar o protótipo, será criado um protótipo exclusivo para cada singleton. </p><br><p>  O protótipo pode ser uma dependência para qualquer bean. <br>  Você pode implementar apenas singleton ou protótipo. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que é um BeanFactoryPostProcessor e quando é usado?</b> <div class="spoiler_text"><ul><li>  <code>BeanFactoryPostProcessor</code> trabalha nas descrições de bin ou metadados de configuração antes que o bin seja criado. </li><li>  O Spring fornece várias implementações úteis do <code>BeanFactoryPostProcessor</code> , por exemplo, lendo arquivos de propriedades e obtendo propriedades de <code>BeanFactoryPostProcessor</code> deles. </li><li>  Você pode escrever sua própria implementação do BFPP. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Por que você precisa do método static @ Bean?</b> <div class="spoiler_text"><p>  Para usar o BFPP personalizado.  Você pode substituir o mecanismo para obter dados de metarquivos. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PropertySourcesPlaceholderConfigurer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pspc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//,    pspc }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Descreva as propriedades da anotação @Bean</b> <div class="spoiler_text"><ul><li>  <code>destroyMethod</code> - aponta para um método de retorno de chamada.  O método está na lixeira. </li><li>  <code>initMethod</code> - aponta para um método de retorno de chamada.  O método está na lixeira. </li><li>  <code>name</code> - o nome do bean.  Por padrão, o nome do bean é o nome do método. </li><li>  <code>value</code> - alias para name () </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">O que é um BeanPostProcessor e como ele é diferente de um BeanFactoryPostProcessor?</b> <div class="spoiler_text"><p>  O Spring usa vários BeanPostProcessors. <br>  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>CommonAnnotationPostProcessor</code></a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>AutowiredAnnotationBeanPostProcessor</code></a> . <br>  O BPP funciona com instâncias de bean, ou seja,  o contêiner cria a bandeja e, em seguida, o BPP é iniciado. </p><br><img src="https://habrastorage.org/webt/7u/-v/bt/7u-vbtqvcgkoscws4xca3e90yrw.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">O que são métodos de retorno de chamada e como usá-los?</b> <div class="spoiler_text"><p>  Existem 3 opções para criar esses métodos: </p><br><ul><li>  <code>@PreDestroy</code> e <code>@PostConstruct</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os</a> <code>destroyMethod</code> e <code>destroyMethod</code> na anotação <code>destroyMethod</code> que apontam para métodos na classe de bean </li><li>  <code>InitializingBean#afterPropertiesSet()</code> e <code>DisposableBean#destroy()</code> .  Para substituir esses métodos, você precisa implementar as interfaces correspondentes. </li></ul><br><img src="https://habrastorage.org/webt/y6/yz/yx/y6yzyxkd94o9omsqbjimep2fowg.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Como posso usar a anotação @Autowire e qual a diferença entre as maneiras?</b> <div class="spoiler_text"><p>  A seguir estão os tipos de DI que podem ser usados ​​no seu aplicativo: </p><br><ul><li>  Constructor DI </li><li>  Setter di </li><li>  Campo di </li></ul><br><p>  A DI através do construtor é considerada a melhor maneira, porque  para ele, não há necessidade de usar a reflexão, e ele também não tem as desvantagens da DI através do levantador. <br>  DI através do campo não é recomendado, porque  Para isso, é utilizada a reflexão que reduz a produtividade. <br>  A DI através do construtor pode levar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dependências circulares</a> .  Para evitar isso, você pode usar a inicialização lenta de beans ou DI através do configurador. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Descreva o comportamento da anotação @Autowired</b> <div class="spoiler_text"><ol><li>  O contêiner determina o tipo de objeto a ser incorporado. </li><li>  Um contêiner procura beans em um contexto (também conhecido como contêiner) que corresponde ao tipo desejado </li><li>  Se houver vários candidatos, e um deles estiver marcado como <code>@Primary</code> , será implementado </li><li>  Se as anotações do <code>@Autowire</code> + <code>Qualifier</code> forem usadas, o contêiner usará as informações do <code>@Qualifier</code> para descobrir qual componente implantar </li><li>  Caso contrário, o contêiner tentará injetar o componente com base em seu nome ou ID. </li><li>  Se nenhum dos métodos funcionou, uma exceção será lançada </li></ol><br><p>  O contêiner lida com a DI usando um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AutowiredAnnotationBeanPostProcessor</a> .  Nesse sentido, a anotação não pode ser usada em nenhum BeanFactoryPP ou BeanPP. </p><br><p>  Se o objeto injetado for uma matriz, coleção ou mapa com um genérico, o Spring incorporará todos os beans do tipo nessa matriz (ou outra estrutura de dados).  No caso do mapa, a chave será o nome do bean. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   DI @Authowired(required = true/false)</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Como fazer DI em um campo privado?</b> <div class="spoiler_text"><p>  Você pode usar diferentes tipos de implementação: </p><br><ul><li>  Construtor </li><li>  Setter </li><li>  Injeção em campo </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Valor</a> </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Como o uso do @Qualifier complementa o @Autowired?</b> <div class="spoiler_text"><p>  O Spring fornece anotações de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Qualificador</a> para superar o problema de ambiguidade de DI. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span>(<span class="hljs-string"><span class="hljs-string">"SomeClass1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SomeClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-comment"><span class="hljs-comment">//… @Autowire @Qualifier("SomeField1") public SomeClass someField;</span></span></code> </pre> <br><p>  Se houver vários compartimentos do mesmo tipo no contêiner (SomeClass), o contêiner implementará o bean com o qualificador correspondente acima do método @ Bean.  Você também não pode colocar um qualificador em um método, mas use o nome do bean como um parâmetro de qualificador. <br>  O nome do bean pode ser especificado através do parâmetro de anotação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Bean</a> e, por padrão, este é o nome do método de fábrica. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que são objetos proxy e que tipos de objetos proxy o Spring pode criar?</b> <div class="spoiler_text"><p>  Um proxy é um objeto especial que possui os mesmos métodos públicos que o bean, mas que possui funcionalidade adicional. <br>  Dois tipos de proxies: </p><br><ul><li>  JDK-proxy - proxy dinâmico.  APIs são construídas no JDK.  Precisa de uma interface </li><li>  Proxy CGLib - não incorporado ao JDK.  Usado quando a interface do objeto está indisponível. </li></ul><br><p>  Prós de objetos proxy: </p><br><ul><li>  Permitir adicionar extra.  lógica - gerenciamento de transações, segurança, registro </li><li>  Separa algum código (log etc.) da lógica principal </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Como um bean singleton é implementado?</b> <div class="spoiler_text"><p>  Se não houver instância de bean no contêiner, o método @ Bean será chamado.  Se houver uma instância de bean, o bean já criado será retornado. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">O que são perfis?</b>  <b class="spoiler_title">Quais são os motivos deles para usar?</b> <div class="spoiler_text"><p>  Ao usar a configuração Java, você pode usar a anotação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>@Profile</code></a> . <br>  Ele permite que você use configurações diferentes para o Spring, dependendo do perfil especificado. <br>  Ele pode ser colocado nas classes @Configuration e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Component</a> , bem como nos métodos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Bean</a> . </p><br><pre> <code class="java hljs">Profile(<span class="hljs-string"><span class="hljs-string">"!test"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,  </span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"production"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jndiDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"development"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standaloneDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Como incorporar valores simples em propriedades no Spring?</b> <div class="spoiler_text"><p>  Você pode usar a anotação <code>@Value</code> para <code>@Value</code> . <br>  Esses valores podem ser obtidos em arquivos de propriedades, em compartimentos etc. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"$some.key"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String stringWithDefaultValue;</code> </pre> <br><p>  Uma sequência será incorporada nessa variável, por exemplo, da propriedade ou da visualização. </p></div></div><br><blockquote>  Como sempre, envie correções ou erros encontrados no PM. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470305/">https://habr.com/ru/post/pt470305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470287/index.html">Migrant</a></li>
<li><a href="../pt470289/index.html">A linguagem de programação dos meus sonhos</a></li>
<li><a href="../pt470293/index.html">Como a vulnerabilidade no Yandex.Stations me inspirou no projeto: transferência de dados de música</a></li>
<li><a href="../pt470301/index.html">Árvore de palavras-chave: análise gráfica para extração semântica</a></li>
<li><a href="../pt470303/index.html">Instale o servidor tftp no CentOS 8 ou RedHat 8</a></li>
<li><a href="../pt470311/index.html">Brinquedos de madeira, parte sete - 1993</a></li>
<li><a href="../pt470313/index.html">Brinquedos de madeira, parte oito - 1994</a></li>
<li><a href="../pt470317/index.html">Folha de dicas da abreviação de C ++ e muito mais. Parte 2: "e não apenas"</a></li>
<li><a href="../pt470321/index.html">Brinquedos de madeira, parte nove - 1995</a></li>
<li><a href="../pt470323/index.html">DIY DeepFake [Parte 1]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>