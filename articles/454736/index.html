<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≥ üêö üìÇ Soporte de Visual Studio 2019 en PVS-Studio ‚õ≥Ô∏è üë©üèæ‚Äçü§ù‚Äçüë©üèº üèâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El soporte de Visual Studio 2019 en PVS-Studio afect√≥ una serie de componentes: el complemento en s√≠, el analizador de l√≠nea de comandos, los n√∫cleos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Soporte de Visual Studio 2019 en PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454736/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  El soporte de Visual Studio 2019 en PVS-Studio afect√≥ una serie de componentes: el complemento en s√≠, el analizador de l√≠nea de comandos, los n√∫cleos de los analizadores C ++ y C #, y algunas utilidades.  En este art√≠culo, explicar√© brevemente qu√© problemas encontramos al implementar el soporte del IDE y c√≥mo los abordamos. <br><a name="habracut"></a><br>  Antes de comenzar, me gustar√≠a repasar la historia del soporte de las versiones anteriores de Visual Studio en PVS-Studio para que comprenda mejor nuestra visi√≥n de la tarea y las soluciones que surgieron en cada situaci√≥n. <br><br>  Desde la primera versi√≥n de PVS-Studio que se envi√≥ con un complemento para Visual Studio (era Visual Studio 2005 en aquel entonces), admitir nuevas versiones de este IDE ha sido una tarea bastante trivial para nosotros, que b√°sicamente se redujo a actualizar el proyecto del complemento archivo y dependencias de las diversas extensiones de API de Visual Studio.  De vez en cuando tendr√≠amos que agregar soporte para nuevas caracter√≠sticas de C ++, con las cuales el compilador de Visual C ++ estaba aprendiendo gradualmente a trabajar, pero en general tampoco fue una tarea dif√≠cil y podr√≠a hacerse f√°cilmente justo antes de un nuevo lanzamiento de Visual Studio .  Adem√°s, PVS-Studio solo ten√≠a un analizador en ese momento, para C / C ++. <br><br>  Las cosas cambiaron cuando se lanz√≥ Visual Studio 2017.  Adem√°s de los grandes cambios en muchas de las extensiones de API del IDE, tambi√©n encontramos un problema con el mantenimiento de la compatibilidad con versiones anteriores del nuevo analizador C # agregado poco antes (as√≠ como de la nueva capa del analizador para que C ++ funcione con proyectos de MSBuild) Nuevas versiones de MSBuild \ Visual Studio. <br><br>  Teniendo en cuenta todo esto, le recomiendo encarecidamente que vea un art√≠culo relacionado sobre el soporte de Visual Studio 2017, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de Visual Studio 2017 y Roslyn 2.0 en PVS-Studio: a veces no es tan f√°cil usar soluciones preparadas como puede parecer</a> ", antes de seguir leyendo.  Ese art√≠culo analiza los problemas que enfrentamos la √∫ltima vez y el modelo de interacci√≥n entre diferentes componentes (como PVS-Studio, MSBuild y Roslyn).  Conocer estos detalles puede ayudarlo a comprender mejor el art√≠culo actual. <br><br>  Afrontar esos problemas en √∫ltima instancia condujo a cambios significativos en el analizador, y esper√°bamos que los nuevos enfoques aplicados nos ayudaran a admitir futuras versiones de Visual Studio \ MSBuild mucho m√°s f√°cil y m√°s r√°pido.  Esta esperanza ya comenz√≥ a ser realista a medida que se lanzaron las numerosas actualizaciones de Visual Studio 2017.  ¬øEl nuevo enfoque nos ayud√≥ a apoyar Visual Studio 2019?  Sigue leyendo para averiguarlo. <br><br><h2>  Complemento PVS-Studio para Visual Studio 2019 </h2><br>  El comienzo parec√≠a ser prometedor.  No nos llev√≥ mucho esfuerzo portar el complemento a Visual Studio 2019 y ejecutarlo y ejecutarlo bien.  Pero ya encontramos dos problemas a la vez que podr√≠an traer m√°s problemas m√°s adelante. <br><br>  El primero ten√≠a que ver con la interfaz <i>IVsSolutionWorkspaceService</i> utilizada para admitir el modo Lightweight Solution Load (que, por cierto, se hab√≠a deshabilitado en una de las actualizaciones anteriores, en Visual Studio 2017).  Estaba decorado con el atributo <i>Desaprobado</i> , que actualmente solo activaba una advertencia en el momento de la compilaci√≥n, pero que se convertir√≠a en un gran problema en el futuro.  Este modo no dur√≥ mucho ... Eso fue f√°cil de solucionar, simplemente dejamos de usar esta interfaz. <br><br>  El segundo problema fue el siguiente mensaje que recibimos al cargar Visual Studio con el complemento habilitado: <i>Visual Studio ha detectado una o m√°s extensiones que est√°n en riesgo o que no funcionan en una actualizaci√≥n VS de funci√≥n.</i> <br><br>  Los registros de los lanzamientos de Visual Studio (el archivo ActivityLog) ayudaron a aclararlo: <br><br>  <i>Advertencia: La extensi√≥n 'PVS-Studio' usa la caracter√≠stica 'carga autom√°tica s√≠ncrona' de Visual Studio.</i>  <i>Esta caracter√≠stica ya no ser√° compatible en una futura actualizaci√≥n de Visual Studio 2019, momento en el que esta extensi√≥n no funcionar√°.</i>  <i>P√≥ngase en contacto con el proveedor de la extensi√≥n para obtener una actualizaci√≥n.</i> <br><br>  Lo que significaba para nosotros era que tendr√≠amos que cambiar del modo de carga s√≠ncrono a as√≠ncrono.  Espero que no le importe si le ahorro los detalles de c√≥mo interactuamos con las interfaces COM de Visual Studio, y solo describo brevemente los cambios. <br><br>  Hay un art√≠culo de Microsoft sobre la carga de complementos de forma asincr√≥nica: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo: usar AsyncPackage para cargar VSPackages en segundo plano</a> ".  Sin embargo, ya estaba claro que hab√≠a m√°s cambios por venir. <br><br>  Uno de los mayores cambios fue en el modo de carga, o m√°s bien en el modo de inicializaci√≥n.  En versiones anteriores, toda la inicializaci√≥n necesaria se realizaba utilizando dos m√©todos: <i>Inicializar</i> nuestra clase heredando de <i>Package</i> y <i>OnShellPropertyChange</i> .  Este √∫ltimo tuvo que agregarse porque cuando se cargaba sincr√≥nicamente, Visual Studio podr√≠a estar en proceso de carga e inicializaci√≥n y, por lo tanto, algunas de las acciones necesarias eran imposibles de realizar durante la inicializaci√≥n del complemento.  Una forma de solucionar esto fue retrasar la ejecuci√≥n de esas acciones hasta que Visual Studio salga del estado 'zombie'.  Fue esta parte de la l√≥gica que seleccionamos en el m√©todo <i>OnShellPropertyChange</i> con una verificaci√≥n del estado 'zombie'. <br><br>  El m√©todo <i>Initialize</i> de la clase abstracta <i>AsyncPackage</i> , que carga los complementos de forma as√≠ncrona <i>heredada</i> , est√° <i>sellado</i> , por lo que la inicializaci√≥n debe hacerse en el m√©todo reemplazado <i>InitializeAsync</i> , que es exactamente lo que hicimos.  La l√≥gica de verificaci√≥n 'zombie' tambi√©n tuvo que cambiarse porque la informaci√≥n de estado ya no estaba disponible para nuestro complemento.  Adem√°s, todav√≠a ten√≠amos que realizar esas acciones que deb√≠an realizarse despu√©s de la inicializaci√≥n del complemento.  <i>Resolvimos</i> eso utilizando el m√©todo <i>OnPackageLoaded</i> de la interfaz <i>IVsPackageLoadEvents</i> , que es donde se realizaron esas acciones retrasadas. <br><br>  Otro problema resultante de la carga asincr√≥nica fue que los comandos del complemento no se pod√≠an usar hasta despu√©s de que Visual Studio se hubiera cargado.  Al abrir el registro del analizador haciendo doble clic en el administrador de archivos (si necesita abrirlo desde Visual Studio), se inici√≥ la versi√≥n correspondiente de devenv.exe con un comando para abrir el registro.  El comando de lanzamiento se parec√≠a a esto: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  El indicador "/ command" se usa aqu√≠ para ejecutar el comando registrado en Visual Studio.  Este enfoque ya no funcion√≥ ya que los comandos ya no estaban disponibles hasta despu√©s de que se cargara el complemento.  La soluci√≥n que se nos ocurri√≥ fue analizar el comando de lanzamiento devenv.exe despu√©s de que el complemento se haya cargado y ejecutar el comando abrir registro si se encuentra en el comando de lanzamiento.  Por lo tanto, descartar la idea de usar la interfaz "apropiada" para trabajar con comandos nos permiti√≥ mantener la funcionalidad necesaria, con la apertura retrasada del registro despu√©s de que el complemento se haya cargado por completo. <br><br>  Uf, parece que lo hicimos por fin;  el complemento se carga y se abre como se esperaba, sin advertencias. <br><br>  Y aqu√≠ es cuando las cosas van mal.  Paul (¬°Hola Paul!) Instala el complemento en su computadora y pregunta por qu√© todav√≠a no hemos cambiado a carga asincr√≥nica. <br><br>  Decir que nos sorprendi√≥ ser√≠a quedarse corto.  Eso no puede ser!  Pero es real: aqu√≠ est√° la nueva versi√≥n del complemento, y aqu√≠ hay un mensaje que dice que el paquete se est√° cargando sincr√≥nicamente.  Alexander (¬°Hola, Alexander!) Y pruebo la misma versi√≥n en nuestras respectivas computadoras, funciona bien.  ¬øC√≥mo es eso posible?  Luego se nos ocurre verificar las versiones de las bibliotecas PVS-Studio cargadas en Visual Studio, y encontramos que estas son las bibliotecas para Visual Studio 2017, mientras que el paquete VSIX contiene las nuevas versiones, es decir, para Visual Studio 2019. <br><br>  Despu√©s de jugar con VSIXInstaller por un tiempo, logramos descubrir que el problema ten√≠a que ver con la cach√© de paquetes.  Esta teor√≠a tambi√©n fue apoyada por el hecho de que restringir el acceso al paquete en cach√© (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) causado por VSIXInstaller para enviar un mensaje de error en el registro.  Curiosamente, cuando no se produjo el error, no apareci√≥ la informaci√≥n sobre la instalaci√≥n de paquetes en cach√©. <br><br>  <b>Nota al margen</b> .  Mientras estudiaba el comportamiento del instalador de VSIX y las bibliotecas que lo acompa√±an, pens√© que es genial que Roslyn y MSBuild sean de c√≥digo abierto, lo que le permite leer y depurar convenientemente su c√≥digo y rastrear su l√≥gica de trabajo. <br><br>  Entonces, esto es lo que sucedi√≥: al instalar el complemento, el instalador de VSIX vio que el paquete correspondiente ya estaba en cach√© (en realidad era el paquete .vsix para Visual Studio 2017) e instal√≥ ese paquete en lugar del nuevo.  Por qu√© ignor√≥ las restricciones / requisitos definidos en el archivo .vsixmanifest (que, entre otras cosas, restringi√≥ la instalaci√≥n de extensiones a una versi√≥n espec√≠fica de Visual Studio) es una pregunta que a√∫n no se ha respondido.  Como resultado, el complemento dise√±ado para Visual Studio 2017 se instal√≥ en Visual Studio 2019, a pesar de las restricciones especificadas en el archivo .vsixmanifest. <br><br>  Lo peor de todo, esa instalaci√≥n rompi√≥ el gr√°fico de dependencias de Visual Studio, y aunque el IDE parec√≠a estar funcionando bien, las cosas eran realmente terribles.  No pudo instalar o eliminar extensiones, actualizaciones, etc.  El proceso de "restauraci√≥n" tambi√©n fue doloroso ya que tuvimos que eliminar la extensi√≥n (es decir, los archivos que la conten√≠an) manualmente y, tambi√©n manualmente, editar los archivos de configuraci√≥n que almacenan la informaci√≥n sobre el paquete instalado.  En otras palabras, no fue divertido en absoluto. <br><br>  Para solucionar eso y asegurarnos de que no nos encontremos en situaciones como esa en el futuro, decidimos hacer nuestro propio GUID para que el nuevo paquete tenga los paquetes para Visual Studio 2017 y Visual Studio 2019 aislados de forma segura ( los paquetes m√°s antiguos estaban bien; siempre hab√≠an usado un GUID compartido). <br><br>  Desde que comenzamos a hablar de sorpresas desagradables, aqu√≠ hay otra: despu√©s de actualizar a la Vista previa 2, el men√∫ PVS-Studio "se movi√≥" a la pesta√±a "Extensiones".  No es un gran problema, pero hizo que acceder a la funcionalidad del complemento fuera menos conveniente.  Este comportamiento persisti√≥ durante las pr√≥ximas versiones de Visual Studio 2019, incluida la versi√≥n.  No he encontrado menciones de esta "caracter√≠stica" ni en la documentaci√≥n ni en el blog. <br><br>  Bien, ahora las cosas se ve√≠an bien y parec√≠a que finalmente hab√≠amos terminado con el soporte de Visual Studio 2019.  Esto result√≥ incorrecto al d√≠a siguiente despu√©s de lanzar PVS-Studio 7.02.  Era el modo de carga asincr√≥nica nuevamente.  Al abrir la ventana de resultados del an√°lisis (o comenzar el an√°lisis), la ventana del analizador aparecer√° "vac√≠a" para el usuario: sin botones, sin cuadr√≠cula, nada en absoluto. <br><br>  De hecho, este problema ocurri√≥ de vez en cuando durante el an√°lisis.  Pero afect√≥ solo a una computadora y no apareci√≥ hasta que Visual Studio se actualiz√≥ a una de las primeras iteraciones de 'Vista previa'.  Sospechamos que algo se hab√≠a roto durante la instalaci√≥n o actualizaci√≥n.  Sin embargo, el problema desapareci√≥ alg√∫n tiempo despu√©s y no ocurrir√≠a incluso en esa computadora en particular, por lo que pensamos que "se solucion√≥ por s√≠ solo".  Pero no, tuvimos suerte.  O desafortunado, para el caso. <br><br>  Como descubrimos, fue el orden en que se inicializ√≥ la ventana IDE (la clase derivada de <i>ToolWindowPane</i> ) y su contenido (nuestro control con la cuadr√≠cula y los botones).  Bajo ciertas condiciones, el control se inicializar√≠a antes del panel y, aunque las cosas funcionaban bien y el m√©todo <i>FindToolWindowAsync</i> (crear la ventana cuando se accede por primera vez) funcionaba bien, el control permaneci√≥ invisible.  Lo arreglamos agregando una inicializaci√≥n diferida para nuestro control al c√≥digo de relleno de panel. <br><br><h2>  Soporte de C # 8.0 </h2><br>  Hay una gran ventaja sobre el uso de Roslyn como base para el analizador: no tiene que agregar soporte para nuevas construcciones de lenguaje de forma manual: se realiza autom√°ticamente a trav√©s de las bibliotecas de an√°lisis de c√≥digo de Microsoft, y solo utilizamos las soluciones listas para usar.  Significa que la nueva sintaxis es compatible simplemente actualizando las bibliotecas. <br><br>  En cuanto al an√°lisis en s√≠, tuvimos que ajustar las cosas por nuestra cuenta, por supuesto, en particular, manejar nuevas construcciones de lenguaje.  Claro, ten√≠amos el nuevo √°rbol de sintaxis generado autom√°ticamente simplemente actualizando Roslyn, pero a√∫n ten√≠amos que ense√±arle al analizador c√≥mo interpretar y procesar exactamente los nodos de √°rbol de sintaxis nuevos o modificados. <br><br>  Los tipos de referencia anulables son quiz√°s la nueva caracter√≠stica m√°s discutida de C # 8. No voy a hablar de ellos ahora porque un tema tan grande vale un art√≠culo separado (que se est√° escribiendo actualmente).  Por ahora, hemos decidido ignorar las anotaciones anulables en nuestro mecanismo de flujo de datos (es decir, entendemos, analizamos y omitimos).  La idea es que a una variable, incluso de un tipo de referencia no anulable, se le puede asignar bastante f√°cilmente (o accidentalmente) el valor <i>nulo</i> , terminando con un NRE al intentar desreferenciarlo.  Nuestro analizador puede detectar tales errores e informar una posible desreferencia nula (si encuentra tal asignaci√≥n en el c√≥digo, por supuesto) incluso si la variable es de tipo referencia no anulable. <br><br>  El uso de tipos de referencia anulables y la sintaxis asociada le permite escribir c√≥digo bastante interesante.  Lo llamamos "sintaxis emocional".  Este fragmento es perfectamente compilable: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  Por cierto, mis experimentos me llevaron a descubrir un par de trucos que puedes usar para "bloquear" Visual Studio usando la nueva sintaxis.  Se basan en el hecho de que puedes escribir tantos '!'  personajes como quieras  Significa que podr√≠a escribir no solo c√≥digo como este: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  pero tambi√©n as√≠: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Y, empuj√°ndolo a√∫n m√°s, podr√≠as escribir cosas locas como esta: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Este c√≥digo es compilable, pero si intenta ver el √°rbol de sintaxis en Syntax Visualizer desde .NET Compiler Platform SDK, Visual Studio se bloquear√°. <br><br>  El informe de fallas se puede extraer del Visor de eventos: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Si te vuelves a√∫n m√°s loco y agregas varias veces m√°s signos de exclamaci√≥n, Visual Studio comenzar√° a fallar por s√≠ solo, sin la ayuda de Syntax Visualizer.  Las bibliotecas Microsoft.CodeAnalysis y el compilador csc.exe tampoco pueden hacer frente a dicho c√≥digo. <br><br>  Estos ejemplos son artificiales, por supuesto, pero ese truco me pareci√≥ divertido. <br><br><h2>  Conjunto de herramientas </h2><br>  Era obvio que actualizar el conjunto de herramientas ser√≠a la parte m√°s dif√≠cil.  Al menos as√≠ era al principio, pero ahora tiendo a pensar que el soporte del complemento fue la parte m√°s dif√≠cil.  Por un lado, ya ten√≠amos un conjunto de herramientas y un mecanismo para evaluar proyectos de MSBuild, lo cual era bueno, aunque todav√≠a no se hab√≠a extendido.  El hecho de que no tuvi√©ramos que escribir los algoritmos desde cero lo hizo mucho m√°s f√°cil.  La estrategia de confiar en "nuestro" conjunto de herramientas, a la que preferimos seguir cuando admitimos Visual Studio 2017, una vez m√°s demostr√≥ ser correcta. <br><br>  Tradicionalmente, el proceso comienza con la actualizaci√≥n de los paquetes NuGet.  La pesta√±a para administrar paquetes NuGet para la soluci√≥n actual contiene el bot√≥n "Actualizar" ... pero no ayuda.  Actualizar todos los paquetes a la vez caus√≥ m√∫ltiples conflictos de versiones, y tratar de resolverlos no parec√≠a una buena idea.  Una forma m√°s dolorosa pero presumiblemente m√°s segura fue actualizar selectivamente los paquetes de destino de Microsoft.Build / Microsoft.CodeAnalysis. <br><br>  Una diferencia se detect√≥ de inmediato al probar los diagn√≥sticos: la estructura del √°rbol de sintaxis cambi√≥ en un nodo existente.  No es gran cosa;  Lo arreglamos r√°pidamente. <br><br>  Perm√≠tame recordarle que probamos nuestros analizadores (para C #, C ++, Java) en proyectos de c√≥digo abierto.  Esto nos permite probar a fondo los diagn√≥sticos; por ejemplo, verificarlos para detectar falsos positivos o ver si hemos perdido alg√∫n caso (para reducir la cantidad de falsos negativos).  Estas pruebas tambi√©n nos ayudan a rastrear la posible regresi√≥n en el paso inicial de actualizaci√≥n de las bibliotecas / conjunto de herramientas.  Esta vez tambi√©n detectaron varios problemas. <br><br>  Una fue que el comportamiento dentro de las bibliotecas de CodeAnalysis empeor√≥.  Espec√≠ficamente, al verificar ciertos proyectos, comenzamos a obtener excepciones del c√≥digo de las bibliotecas en varias operaciones, como obtener informaci√≥n sem√°ntica, abrir proyectos, etc. <br><br>  Aquellos de ustedes que hayan le√≠do detenidamente el art√≠culo sobre el soporte de Visual Studio 2017 recuerden que nuestra distribuci√≥n viene con un ficticio: el archivo MSBuild.exe de 0 bytes. <br><br>  Ahora ten√≠amos que impulsar esta pr√°ctica a√∫n m√°s e incluir dummies vac√≠os para los compiladores csc.exe, vbc.exe y VBCSCompiler.exe.  Por qu√©  Se nos ocurri√≥ esta soluci√≥n despu√©s de analizar uno de los proyectos de nuestra base de pruebas y obtener informes de diferencias: la nueva versi√≥n del analizador no generar√≠a algunas de las advertencias esperadas. <br><br>  Descubrimos que ten√≠a que ver con s√≠mbolos de compilaci√≥n condicional, algunos de los cuales no se extrajeron correctamente al usar la nueva versi√≥n del analizador.  Para llegar a la ra√≠z del problema, tuvimos que profundizar en el c√≥digo de las bibliotecas de Roslyn. <br><br>  Los s√≠mbolos de compilaci√≥n condicional se <i>analizan</i> utilizando el m√©todo <i>GetDefineConstantsSwitch</i> de la clase <i>Csc</i> de la biblioteca <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  El an√°lisis se realiza utilizando el m√©todo <i>String.Split</i> en varios separadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Este mecanismo de an√°lisis funciona perfectamente;  Todos los s√≠mbolos de compilaci√≥n condicional se extraen correctamente.  Bien, sigamos cavando. <br><br>  El siguiente punto clave fue la llamada del m√©todo <i>ComputePathToTool</i> de la clase <i>ToolTask</i> .  Este m√©todo calcula la ruta al archivo ejecutable ( <i>csc.exe</i> ) y comprueba si est√° all√≠.  Si es as√≠, el m√©todo le devuelve la ruta o, de lo contrario, es <i>nulo</i> . <br><br>  El c√≥digo de llamada: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Como no hay <i>un</i> archivo <i>csc.exe</i> (¬øpor qu√© lo necesitamos?), A <i>PathToTool</i> se le asigna el valor <i>nulo</i> en este punto, y el m√©todo actual ( <i>ToolTask.Execute</i> ) devuelve <i>falso</i> .  Los resultados de la ejecuci√≥n de la tarea, incluidos los s√≠mbolos de compilaci√≥n condicional extra√≠dos, se ignoran. <br><br>  Bien, veamos qu√© sucede si colocamos el archivo <i>csc.exe</i> donde se espera que est√©. <br><br>  Ahora <i>pathToTool</i> almacena la ruta real al archivo actual, y <i>ToolTask.Execute</i> sigue ejecut√°ndose.  El siguiente punto clave es la llamada del m√©todo <i>ManagedCompiler.ExecuteTool</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  La propiedad <i>SkipCompilerExecution</i> es <i>verdadera</i> (l√≥gicamente, ya que no estamos compilando de verdad).  El m√©todo de llamada (el <i>ToolTask.Execute</i> ya mencionado) verifica si el valor de retorno para <i>ExecuteTool</i> es 0 y, de ser as√≠, devuelve <i>verdadero</i> .  Si su <i>csc.exe</i> era un compilador real o "Guerra y paz" de Leo Tolstoy, no importa en absoluto. <br><br>  Entonces, el problema tiene que ver con el orden en que se definieron los pasos: <br><br><ul><li>  verificar el compilador; </li><li>  comprobar si se debe iniciar el compilador; </li></ul><br>  Y esperar√≠amos un orden inverso.  Es para arreglar esto que se agregaron los dummies para los compiladores. <br><br>  Bien, pero ¬øc√≥mo logramos obtener los s√≠mbolos de compilaci√≥n, con el archivo csc.exe ausente (y los resultados de la tarea ignorados)? <br><br>  Bueno, tambi√©n hay un m√©todo para este caso: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> de la biblioteca <i>Microsoft.CodeAnalysis.CSharp</i> .  Tambi√©n realiza el an√°lisis llamando al m√©todo <i>String.Split</i> en varios separadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  ¬øVes c√≥mo este conjunto de separadores es diferente del que maneja el m√©todo <i>Csc.GetDefineConstantsSwitch</i> ?  Aqu√≠, un espacio no es un separador.  Significa que los s√≠mbolos de compilaci√≥n condicional separados por espacios no se analizar√°n correctamente mediante este m√©todo. <br><br>  Eso es lo que sucedi√≥ cuando verificamos los proyectos problem√°ticos: utilizaron s√≠mbolos de compilaci√≥n condicional separados por espacios y, por lo tanto, fueron analizados con √©xito por el m√©todo <i>GetDefineConstantsSwitch</i> pero no por el m√©todo <i>ParseConditionalCompilationSymbols</i> . <br><br>  Otro problema que apareci√≥ despu√©s de actualizar las bibliotecas fue el comportamiento roto en ciertos casos, espec√≠ficamente en proyectos que no se compilaron.  Afect√≥ a las bibliotecas de Microsoft. <i>Code Analysis</i> y se manifest√≥ como excepciones de todo tipo: <i>ArgumentNullException</i> (inicializaci√≥n fallida de alg√∫n registrador interno), <i>NullReferenceException</i> , etc. <br><br>  Me gustar√≠a contarle acerca de un error en particular que encontr√© bastante interesante. <br><br>  Lo encontramos al verificar la nueva versi√≥n del proyecto Roslyn: una de las bibliotecas estaba lanzando una <i>NullReferenceException</i> .  Gracias a la informaci√≥n detallada sobre su fuente, encontramos r√°pidamente el c√≥digo fuente del problema y, solo por curiosidad, decidimos verificar si el error persistir√≠a al trabajar en Visual Studio. <br><br>  Logramos reproducirlo en Visual Studio (versi√≥n 16.0.3).  Para hacer eso, necesita una definici√≥n de clase como esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Tambi√©n necesitar√° Syntax Visualizer (viene con .NET Compiler Platform SDK).  Busque el <i>TypeSymbol</i> (haciendo clic en el elemento de men√∫ "View TypeSymbol (if any)") del nodo del √°rbol de sintaxis de tipo <i>ConstantPatternSyntax</i> ( <i>nulo</i> ).  Visual Studio se reiniciar√° y la informaci√≥n de excepci√≥n, espec√≠ficamente el seguimiento de la pila, estar√° disponible en el Visor de eventos: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Como puede ver, el problema es causado por una referencia de referencia nula. <br><br>  Como ya mencion√©, encontramos un problema similar al probar el analizador.  Si lo compila utilizando las bibliotecas de depuraci√≥n de Microsoft. <i>Code Analysis</i> , puede ir directamente al punto problem√°tico buscando el <i>TypeSymbol</i> del nodo del √°rbol de sintaxis correspondiente. <br><br>  Eventualmente nos llevar√° al m√©todo <i>ClassifyImplicitBuiltInConversionSlow</i> mencionado en el seguimiento de la pila anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Aqu√≠, el par√°metro de <i>destino</i> es <i>nulo</i> , por lo que llamar a <i>destination.SpecialType</i> resulta en arrojar una <i>NullReferenceException</i> .  S√≠, la operaci√≥n de desreferencia est√° precedida por <i>Debug.Assert</i> , pero no ayuda porque, de hecho, no protege de nada, simplemente le permite detectar el problema en las versiones de depuraci√≥n de las bibliotecas.  O no lo hace. <br><br><h3>  Cambios en el mecanismo de evaluaci√≥n de proyectos C ++ </h3><br>  No hubo mucho inter√©s en esta parte: los algoritmos existentes no requer√≠an grandes modificaciones que valga la pena mencionar, pero es posible que desee saber sobre dos problemas menores. <br><br>  La primera fue que tuvimos que modificar los algoritmos que se basaban en el valor num√©rico de ToolsVersion.  Sin entrar en detalles, hay ciertos casos en los que necesita comparar conjuntos de herramientas y elegir, por ejemplo, la versi√≥n m√°s reciente.  La nueva versi√≥n, naturalmente, tiene un valor mayor.  Esper√°bamos que ToolsVersion para el nuevo MSBuild / Visual Studio tuviera el valor 16.0.  Si, claro!  La siguiente tabla muestra c√≥mo los valores de diferentes propiedades cambiaron a lo largo del historial de desarrollo de Visual Studio: <br><div class="scrollable-table"><table><tbody><tr><td>  Nombre del producto visual studio <br></td><td>  N√∫mero de versi√≥n de Visual Studio <br></td><td>  Versi√≥n de herramientas <br></td><td>  Versi√≥n PlatformToolset <br></td></tr><tr><td>  Visual studio 2010 <br></td><td>  10,0 <br></td><td>  4.0 4.0 <br></td><td>  100 <br></td></tr><tr><td>  Visual studio 2012 <br></td><td>  11,0 <br></td><td>  4.0 4.0 <br></td><td>  110 <br></td></tr><tr><td>  Visual studio 2013 <br></td><td>  12,0 <br></td><td>  12,0 <br></td><td>  120 <br></td></tr><tr><td>  Visual studio 2015 <br></td><td>  14.0 <br></td><td>  14.0 <br></td><td>  140 <br></td></tr><tr><td>  Visual studio 2017 <br></td><td>  15,0 <br></td><td>  15,0 <br></td><td>  141 <br></td></tr><tr><td>  Visual studio 2019 <br></td><td>  16,0 <br></td><td>  Actual <br></td><td>  142 <br></td></tr></tbody></table></div><br>  S√© que la broma sobre los n√∫meros de versi√≥n desordenados de Windows y Xbox es antigua, pero demuestra que no se pueden hacer predicciones confiables sobre los valores (ya sea en el nombre o la versi√≥n) de los futuros productos de Microsoft.  :) <br><br>  Resolvimos eso f√°cilmente agregando prioridades para conjuntos de herramientas (es decir, priorizando como una entidad separada). <br><br>  El segundo problema involucraba problemas al trabajar en Visual Studio 2017 o en un entorno relacionado (por ejemplo, cuando se establece la variable de entorno <i>VisualStudioVersion</i> ).  Ocurre porque los par√°metros inform√°ticos necesarios para evaluar un proyecto C ++ es una tarea mucho m√°s dif√≠cil que evaluar un proyecto .NET.  Para .NET, utilizamos nuestro propio conjunto de herramientas y el valor correspondiente de ToolsVersion.  Para C ++, podemos utilizar tanto nuestro propio conjunto de herramientas como los proporcionados por el sistema.  A partir de Build Tools for Visual Studio 2017, los conjuntos de herramientas se definen en el archivo <i>MSBuild.exe.config en</i> lugar del registro.  Es por eso que ya no pudimos obtenerlos de la lista global de conjuntos de herramientas (usando <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> , por ejemplo) a diferencia de los definidos en el registro (es decir, para Visual Studio 2015 y anteriores). <br><br>  Todo esto nos impide evaluar un proyecto usando <i>ToolsVersion 15.0</i> porque el sistema no ver√° el conjunto de herramientas requerido.  El conjunto de herramientas m√°s reciente, <i>Current</i> , seguir√° estando disponible, ya que es nuestro propio conjunto de herramientas y, por lo tanto, no existe tal problema en Visual Studio 2019. La soluci√≥n fue bastante simple y nos permiti√≥ solucionarlo sin cambiar los algoritmos de evaluaci√≥n existentes: simplemente tuvo que incluir otro conjunto de herramientas, <i>15.0</i> , en la lista de nuestros propios conjuntos de herramientas adem√°s de <i>Current</i> . <br><br><h3>  Cambios en el mecanismo de evaluaci√≥n de proyectos de C # .NET Core </h3><br>  Esta tarea involucraba dos cuestiones interrelacionadas: <br><br><ul><li>  agregar el conjunto de herramientas 'Actual' rompi√≥ el an√°lisis de proyectos de .NET Core en Visual Studio 2017; </li><li>  el an√°lisis no funcionar√≠a para proyectos .NET Core en sistemas sin al menos una copia de Visual Studio instalada. </li></ul><br>  Ambos problemas proven√≠an de la misma fuente: algunos de los archivos base .targets / .props se buscaron en rutas incorrectas.  Esto nos impidi√≥ evaluar un proyecto utilizando nuestro conjunto de herramientas. <br><br>  Si no tuviera instalada una instancia de Visual Studio, obtendr√≠a el siguiente error (con la versi√≥n anterior del conjunto de herramientas, <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>  Al evaluar un proyecto C # .NET Core en Visual Studio 2017, obtendr√≠a el siguiente error (con la versi√≥n actual del conjunto de herramientas, <i>Actual</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>  Dado que estos problemas son similares (que parecen ser), podr√≠amos intentar matar dos p√°jaros de un tiro. <br><br>  En los siguientes p√°rrafos, explicar√© c√≥mo lo logramos, sin entrar en detalles.  Estos detalles (sobre c√≥mo se eval√∫an los proyectos de C # .NET Core, as√≠ como los cambios en el mecanismo de evaluaci√≥n en nuestro conjunto de herramientas) ser√°n el tema de uno de nuestros futuros art√≠culos.  Por cierto, si estaba leyendo este art√≠culo cuidadosamente, probablemente haya notado que esta es la segunda referencia a nuestros futuros art√≠culos.  :) <br><br>  Ahora, ¬øc√≥mo resolvimos ese problema?  Ampliamos nuestro propio conjunto de herramientas con los archivos .targets / .props base de .NET Core SDK ( <i>Sdk.props</i> , <i>Sdk.targets</i> ).  Eso nos dio m√°s control sobre la situaci√≥n y m√°s flexibilidad en la gesti√≥n de importaciones, as√≠ como en la evaluaci√≥n de proyectos .NET Core en general.  S√≠, nuestro conjunto de herramientas se hizo un poco m√°s grande nuevamente, y tambi√©n tuvimos que agregar l√≥gica para configurar el entorno requerido para la evaluaci√≥n de proyectos .NET Core, pero parece que vale la pena. <br><br>  Hasta entonces, hab√≠amos evaluado los proyectos de .NET Core simplemente solicitando la evaluaci√≥n y confiando en MSBuild para hacer el trabajo. <br><br>  Ahora que ten√≠amos m√°s control sobre la situaci√≥n, el mecanismo cambi√≥ un poco: <br><br><ul><li>  configurar el entorno requerido para evaluar proyectos .NET Core; </li><li>  evaluaci√≥n: <ul><li>  iniciar la evaluaci√≥n utilizando archivos .targets / .props de nuestro conjunto de herramientas; </li><li>  Continuar la evaluaci√≥n utilizando archivos externos. </li></ul></li></ul><br>  Esta secuencia sugiere que la configuraci√≥n del entorno persigue dos objetivos principales: <br><br><ul><li>  iniciar la evaluaci√≥n utilizando archivos .targets / .props de nuestro conjunto de herramientas; </li><li>  redirigir todas las operaciones posteriores a archivos externos .targets / .props. </li></ul><br>  Se utiliza una biblioteca especial Microsoft.DotNet.MSBuildSdkResolver para buscar los archivos .targets / .props necesarios.  Con el fin de iniciar la configuraci√≥n del entorno utilizando archivos de nuestro conjunto de herramientas, utilizamos una variable de entorno especial utilizada por esa biblioteca para que podamos apuntar a la fuente desde donde importar los archivos necesarios (es decir, nuestro conjunto de herramientas).  Como la biblioteca est√° incluida en nuestra distribuci√≥n, no hay riesgo de una falla l√≥gica repentina. <br><br>  Ahora tenemos los archivos Sdk de nuestro conjunto de herramientas importados primero, y dado que ahora podemos cambiarlos f√°cilmente, controlamos completamente el resto de la l√≥gica de evaluaci√≥n.  Significa que ahora podemos decidir qu√© archivos y desde qu√© ubicaci√≥n importar.  Lo mismo se aplica a Microsoft.Common.props mencionado anteriormente.  Importamos este y otros archivos base de nuestro conjunto de herramientas para no tener que preocuparnos por su existencia o contenido. <br><br>  Una vez que se realizan todas las importaciones necesarias y se establecen las propiedades, pasamos el control sobre el proceso de evaluaci√≥n al .NET Core SDK real, donde se realizan todas las dem√°s operaciones requeridas. <br><br><h2>  Conclusi√≥n </h2><br>  En general, admitir Visual Studio 2019 fue m√°s f√°cil que admitir Visual Studio 2017 por varias razones.  Primero, Microsoft no cambi√≥ tantas cosas como lo hizo al actualizar Visual Studio 2015 a Visual Studio 2017. S√≠, cambiaron el conjunto de herramientas base y obligaron a los complementos de Visual Studio a cambiar al modo de carga as√≠ncrona, pero este cambio no fue que dr√°stico  En segundo lugar, ya ten√≠amos una soluci√≥n preparada que involucraba nuestro propio conjunto de herramientas y mecanismo de evaluaci√≥n de proyectos y simplemente no ten√≠amos que trabajar todo desde cero, solo construir sobre lo que ya ten√≠amos.  El proceso relativamente sencillo de respaldar el an√°lisis de proyectos de .NET Core en nuevas condiciones (y en computadoras sin copias de Visual Studio instaladas) al extender nuestro sistema de evaluaci√≥n de proyectos tambi√©n nos da la esperanza de haber tomado la decisi√≥n correcta al tomar parte del control en nuestras manos <br><br>  Pero me gustar√≠a repetir la idea comunicada en el art√≠culo anterior: a veces, usar soluciones preparadas no es tan f√°cil como parece. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454736/">https://habr.com/ru/post/454736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454720/index.html">¬øC√≥mo revivir la documentaci√≥n?</a></li>
<li><a href="../454728/index.html">Acceso a Internet abierto: la tecnolog√≠a LUWRAIN ayuda a los usuarios ciegos</a></li>
<li><a href="../454730/index.html">Reuni√≥n de Allure Server: grabaciones de video de informes</a></li>
<li><a href="../454732/index.html">5 t√©cnicas s√≥lidas de priorizaci√≥n para equipos de TI</a></li>
<li><a href="../454734/index.html">Copia de seguridad, Parte 4: Descripci√≥n general y prueba de zbackup, restic, borgbackup</a></li>
<li><a href="../454738/index.html">Soporte de Visual Studio 2019 en PVS-Studio</a></li>
<li><a href="../454740/index.html">Mayo de 2019 Joomla Digest</a></li>
<li><a href="../454742/index.html">Al menos un truco de Vim que no conoc√≠as</a></li>
<li><a href="../454744/index.html">Descripci√≥n general de los informes de seguimiento de Java de la conferencia RigaDevDays</a></li>
<li><a href="../454748/index.html">Gu√≠a de supervivencia de MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>