<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 🛃 🧕🏾 REST API di Java tanpa kerangka kerja 💪🏿 🔡 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan khusus untuk siswa kursus  "Pengembang Java . " 



 Ada banyak kerangka kerja dan perpustakaan di ekosistem Jawa. Meskip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REST API di Java tanpa kerangka kerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/480564/">  <i>Terjemahan artikel disiapkan khusus untuk siswa kursus</i> <i><a href="https://otus.pw/U0au/"></a></i>  <i><a href="https://otus.pw/U0au/">"Pengembang Java</a> . <a href="https://otus.pw/U0au/">"</a></i> <br><br><img src="https://habrastorage.org/webt/yo/6h/2y/yo6h2yiuq-mleja7zyfjkqe0p0q.png"><br><hr><br>  Ada banyak kerangka kerja dan perpustakaan di ekosistem Jawa.  Meskipun tidak sebanyak di JavaScript, mereka tidak berakhir dengan cepat.  Namun, itu membuat saya berpikir bahwa kami sudah lupa bagaimana menulis aplikasi tanpa kerangka kerja. <br><br>  Anda dapat mengatakan bahwa <a href="https://spring.io/">Spring</a> adalah standar dan mengapa menciptakan kembali kemudi?  Dan <a href="http://sparkjava.com/">Spark</a> adalah kerangka REST yang bagus dan nyaman.  Atau <a href="https://doc.networknt.com/getting-started/light-rest-4j/">Cahaya-istirahat-4 ji</a> .  Dan saya akan mengatakan bahwa Anda, tentu saja, benar. <br><br>  Namun seiring dengan kerangka itu, selain fungsi yang telah selesai, Anda mendapatkan banyak keajaiban, kesulitan belajar, fungsi tambahan yang kemungkinan besar tidak akan Anda gunakan, serta bug.  Dan semakin banyak kode pihak ketiga dalam layanan Anda, semakin besar kemungkinan Anda akan mengalami kesalahan. <br><br>  Komunitas open source sangat aktif, dan ada kemungkinan besar bahwa kesalahan dalam kerangka kerja akan cepat diperbaiki.  Tapi tetap saja, saya ingin Anda berpikir apakah Anda benar-benar membutuhkan kerangka kerja.  Jika Anda memiliki layanan kecil atau aplikasi konsol, Anda mungkin dapat melakukannya tanpa itu. <a name="habracut"></a><br><br>  Apa yang bisa Anda dapatkan (atau kehilangan) menggunakan kode Java murni?  Pikirkan tentang itu: <br><br><ul><li>  kode Anda bisa menjadi jauh lebih bersih dan lebih mudah dipahami (atau mungkin berantakan jika Anda seorang programmer yang buruk) </li><li>  Anda akan memiliki kontrol lebih besar atas kode Anda, Anda tidak akan dibatasi oleh kerangka kerja (meskipun Anda harus menulis lebih banyak kode Anda untuk fungsionalitas yang disediakan kerangka kerja di luar kotak) </li><li>  aplikasi Anda akan digunakan dan diluncurkan lebih cepat, karena kerangka kerja tidak perlu menginisialisasi puluhan kelas (atau tidak akan memulai sama sekali jika Anda mencampur sesuatu, misalnya, dalam multithreading) </li><li>  jika Anda menggunakan aplikasi di Docker, maka gambar Anda akan jauh lebih kecil, karena tabung Anda juga akan lebih kecil </li></ul><br>  Saya melakukan sedikit percobaan dan mencoba mengembangkan REST API tanpa kerangka.  Mungkin ini akan menarik dalam hal pembelajaran dan pengetahuan yang menyegarkan. <br><br>  Ketika saya mulai menulis kode ini, saya sering menjumpai situasi ketika tidak ada fungsi yang dimiliki Spring.  Pada saat-saat ini, alih-alih mengambil Spring, Anda harus memikirkan kembali dan mengembangkan semuanya sendiri. <br><br>  Saya menyadari bahwa untuk menyelesaikan masalah bisnis nyata, saya masih lebih suka menggunakan Spring daripada menciptakan kembali roda.  Namun, saya pikir latihan ini adalah pengalaman yang sangat menarik. <br><br><h3>  Memulai </h3><br>  Saya akan menjelaskan setiap langkah, tetapi saya tidak akan selalu memberikan kode sumber lengkap.  Anda dapat melihat kode lengkap di cabang terpisah dari <a href="https://github.com/piczmar/pure-java-rest-api">repositori git</a> . <br><br>  Pertama buat proyek Maven baru dengan <code>pom.xml</code> berikut. <br><br><pre> <code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>?&gt; &lt;project xmlns=<span class="hljs-string"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span> xmlns:xsi=<span class="hljs-string"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span> xsi:schemaLocation=<span class="hljs-string"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span></span>&gt; &lt;modelVersion&gt;<span class="hljs-number"><span class="hljs-number">4.0</span></span>.0&lt;/modelVersion&gt; &lt;groupId&gt;com.consulner.httpserver&lt;/groupId&gt; &lt;artifactId&gt;pure-java-rest-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">1.0</span></span>-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;<span class="hljs-number"><span class="hljs-number">11</span></span>&lt;/java.version&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt;&lt;/dependencies&gt; &lt;/project&gt;</code> </pre> <br>  Tambahkan <code>java.xml.bind</code> sebagai dependensi karena telah dihapus di JDK 11 ( <a href="http://openjdk.java.net/jeps/320">JEP-320</a> ). <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt; &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.4</span></span>.0-b180608.0325&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  dan <a href="https://github.com/FasterXML/jackson">Jackson</a> untuk serialisasi JSON <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.9</span></span>.7&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Untuk menyederhanakan kelas POJO, kita akan menggunakan <a href="https://projectlombok.org/">Lombok</a> : <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">1.18</span></span>.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;</code> </pre> <br>  dan <a href="http://www.vavr.io/">vavr</a> untuk alat pemrograman fungsional <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;io.vavr&lt;/groupId&gt; &lt;artifactId&gt;vavr&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">0.9</span></span>.2&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Kami juga membuat <code>Application</code> kelas kosong utama. <br><br>  Kode sumber di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-1">langkah-1</a> . <br><br><h3>  Titik akhir pertama </h3><br>  Aplikasi web kami akan didasarkan pada <code>com.sun.net.httpserver.HttpServer</code> kelas.  Dan titik akhir paling sederhana <code>/api/hello</code> mungkin terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.consulner.api; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.OutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.InetSocketAddress; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.sun.net.httpserver.HttpServer; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> serverPort = <span class="hljs-number"><span class="hljs-number">8000</span></span>; HttpServer server = HttpServer.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(serverPort), <span class="hljs-number"><span class="hljs-number">0</span></span>); server.createContext(<span class="hljs-string"><span class="hljs-string">"/api/hello"</span></span>, (exchange -&gt; { String respText = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; exchange.sendResponseHeaders(<span class="hljs-number"><span class="hljs-number">200</span></span>, respText.getBytes().length); OutputStream output = exchange.getResponseBody(); output.write(respText.getBytes()); output.flush(); exchange.close(); })); server.setExecutor(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// creates a default executor server.start(); } }</span></span></code> </pre> <br>  Server web berjalan pada port 8000 dan menyediakan titik akhir yang hanya mengembalikan Hello! .. Ini dapat diperiksa, misalnya, menggunakan curl: <br><br> <code>curl localhost:8000/api/hello</code> <br> <br>  Kode sumber di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-2">langkah-2</a> . <br><br><h3>  Dukungan untuk berbagai metode HTTP </h3><br>  Titik akhir pertama kami berfungsi dengan baik, tetapi Anda mungkin memperhatikan bahwa apa pun metode HTTP yang digunakan, selalu merespons dengan cara yang sama. <br><br>  Sebagai contoh: <br><br><pre> <code class="java hljs">curl -X POST localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/hello curl -X PUT localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/hello</code> </pre> <br>  Hal pertama yang harus dilakukan adalah menambahkan kode untuk membedakan antara metode, misalnya: <br><br><pre> <code class="java hljs">server.createContext(<span class="hljs-string"><span class="hljs-string">"/api/hello"</span></span>, (exchange -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"GET"</span></span>.equals(exchange.getRequestMethod())) { String respText = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; exchange.sendResponseHeaders(<span class="hljs-number"><span class="hljs-number">200</span></span>, respText.getBytes().length); OutputStream output = exchange.getResponseBody(); output.write(respText.getBytes()); output.flush(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { exchange.sendResponseHeaders(<span class="hljs-number"><span class="hljs-number">405</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">// 405 Method Not Allowed } exchange.close(); }));</span></span></code> </pre> <br>  Coba kueri lagi: <br><br><pre> <code class="java hljs">curl -v -X POST localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/hello</code> </pre> <br>  jawabannya akan seperti ini: <br><br><pre> <code class="java hljs">&gt; POST /api/hello HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span> &gt; User-Agent: curl/<span class="hljs-number"><span class="hljs-number">7.61</span></span>.0 &gt; Accept: *<span class="hljs-comment"><span class="hljs-comment">/* &gt; &lt; HTTP/1.1 405 Method Not Allowed</span></span></code> </pre> <br>  Ada juga beberapa hal yang perlu diingat.  Sebagai contoh, jangan lupa untuk melakukan <code>flush()</code> untuk <code>OutputStream</code> dan <code>close()</code> untuk <code>exchange</code> .  Saat menggunakan Spring, saya bahkan tidak perlu memikirkannya. <br><br>  Kode sumber di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-3">langkah-3</a> . <br><br><h3>  Parameter permintaan parsing </h3><br>  Memilah parameter kueri adalah "fungsi" lain yang perlu kita implementasikan sendiri. <br><br>  Misalkan kita ingin hello api kita mendapatkan nama dalam parameter <code>name</code> , misalnya: <br><br><pre> <code class="java hljs">curl localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/hello?name=Marcin Hello Marcin!</code> </pre> <br>  Kita dapat menguraikan parameter sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map&lt;String, List&lt;String&gt;&gt; splitQuery(String query) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || <span class="hljs-string"><span class="hljs-string">""</span></span>.equals(query)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyMap(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pattern.compile(<span class="hljs-string"><span class="hljs-string">"&amp;"</span></span>).splitAsStream(query) .map(s -&gt; Arrays.copyOf(s.split(<span class="hljs-string"><span class="hljs-string">"="</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>)) .collect(groupingBy(s -&gt; decode(s[<span class="hljs-number"><span class="hljs-number">0</span></span>]), mapping(s -&gt; decode(s[<span class="hljs-number"><span class="hljs-number">1</span></span>]), toList()))); }</code> </pre> <br>  dan gunakan seperti di bawah ini: <br><br><pre> <code class="java hljs">Map&lt;String, List&lt;String&gt;&gt; params = splitQuery(exchange.getRequestURI().getRawQuery()); String noNameText = <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span>; String name = params.getOrDefault(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, List.of(noNameText)).stream().findFirst().orElse(noNameText); String respText = String.format(<span class="hljs-string"><span class="hljs-string">"Hello %s!"</span></span>, name);</code> </pre> <br>  Contoh lengkap di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-4">langkah-4</a> . <br><br>  Demikian pula, jika kita ingin menggunakan parameter di jalur.  Sebagai contoh: <br><br><pre> <code class="java hljs">curl localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/items/<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Untuk mendapatkan elemen dengan id = 1, kita perlu mengurai url sendiri.  Itu menjadi besar. <br><br><h3>  Keamanan </h3><br>  Seringkali kita perlu melindungi akses ke beberapa titik akhir.  Misalnya, ini dapat dilakukan dengan menggunakan otentikasi dasar. <br><br>  Untuk setiap HttpContext, kita dapat menetapkan autentikator, seperti yang ditunjukkan di bawah ini: <br><br><pre> <code class="java hljs">HttpContext context = server.createContext(<span class="hljs-string"><span class="hljs-string">"/api/hello"</span></span>, (exchange -&gt; { <span class="hljs-comment"><span class="hljs-comment">//     })); context.setAuthenticator(new BasicAuthenticator("myrealm") { @Override public boolean checkCredentials(String user, String pwd) { return user.equals("admin") &amp;&amp; pwd.equals("admin"); } });</span></span></code> </pre><br>  Nilai "myrealm" di konstruktor <code>BasicAuthenticator</code> adalah ranah nama.  Realm adalah nama virtual yang dapat digunakan untuk memisahkan domain otentikasi. <br><br>  Anda dapat membaca lebih lanjut tentang ini di <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> . <br><br>  Sekarang Anda dapat memanggil titik akhir aman ini dengan menambahkan header <code>Authorization</code> : <br><br><pre> <code class="java hljs">curl -v localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/hello?name=Marcin -H <span class="hljs-string"><span class="hljs-string">'Authorization: Basic YWRtaW46YWRtaW4='</span></span></code> </pre> <br>  Teks setelah "Dasar" adalah <code>admin:admin</code> disandikan Base64 <code>admin:admin</code> teks <code>admin:admin</code> , yang merupakan kredensial yang dikodekan dalam contoh kami. <br><br>  Untuk otentikasi dalam aplikasi nyata, Anda mungkin akan mendapatkan kredensial dari header dan membandingkannya dengan nama pengguna dan kata sandi yang tersimpan dalam database. <br><br>  Jika Anda tidak menentukan judul, API akan merespons dengan status <br><br><pre> <code class="java hljs">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">401</span></span> Unauthorized</code> </pre> <br>  Contoh lengkap di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-5">langkah-5</a> . <br><br><h3>  JSON, penanganan pengecualian dan banyak lagi </h3><br>  Sekarang saatnya untuk contoh yang lebih kompleks. <br><br>  Dari pengalaman saya dalam pengembangan perangkat lunak, API paling umum yang saya kembangkan adalah pertukaran JSON. <br><br>  Kami akan mengembangkan API untuk mendaftarkan pengguna baru.  Untuk menyimpannya, kami akan menggunakan database dalam memori. <br><br>  Kami akan memiliki objek domain <code>User</code> sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String id; String login; String password; }</code> </pre><br>  Saya menggunakan Lombok untuk menyingkirkan boilerplate (konstruktor, getter). <br><br>  Di REST API, saya hanya ingin memasukkan login dan kata sandi, jadi saya membuat objek terpisah: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewUser</span></span></span><span class="hljs-class"> </span></span>{ String login; String password; }</code> </pre> <br>  Objek <code>User</code> dibuat di layanan yang akan kami gunakan di penangan API.  Metode layanan hanya menghemat pengguna. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NewUser user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.create(user); }</code> </pre> <br>  Anda dapat melakukan lebih banyak dalam aplikasi nyata.  Misalnya, kirim acara setelah pendaftaran pengguna berhasil. <br><br>  Implementasi repositori adalah sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.UUID; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ConcurrentHashMap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.consulner.domain.user.NewUser; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.consulner.domain.user.User; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.consulner.domain.user.UserRepository; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryUserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map USERS_STORE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NewUser newUser)</span></span></span><span class="hljs-function"> </span></span>{ String id = UUID.randomUUID().toString(); User user = User.builder() .id(id) .login(newUser.getLogin()) .password(newUser.getPassword()) .build(); USERS_STORE.put(newUser.getLogin(), user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } }</code> </pre> <br>  Akhirnya, rekatkan semuanya dalam <code>handle()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpExchange exchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!exchange.getRequestMethod().equals(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsupportedOperationException(); } RegistrationRequest registerRequest = readRequest(exchange.getRequestBody(), RegistrationRequest.class); NewUser user = NewUser.builder() .login(registerRequest.getLogin()) .password(PasswordEncoder.encode(registerRequest.getPassword())) .build(); String userId = userService.create(user); exchange.getResponseHeaders().set(Constants.CONTENT_TYPE, Constants.APPLICATION_JSON); exchange.sendResponseHeaders(StatusCode.CREATED.getCode(), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] response = writeResponse(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegistrationResponse(userId)); OutputStream responseBody = exchange.getResponseBody(); responseBody.write(response); responseBody.close(); }</code> </pre> <br>  Di sini, permintaan JSON dikonversi ke objek <code>RegistrationRequest</code> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegistrationRequest</span></span></span><span class="hljs-class"> </span></span>{ String login; String password; }</code> </pre> <br>  yang kemudian saya petakan ke objek <code>NewUser</code> untuk menyimpannya dalam database dan mengirim respons sebagai JSON. <br><br>  Saya juga perlu mengonversi objek <code>RegistrationResponse</code> kembali ke string JSON.  Untuk ini kami menggunakan Jackson <br>  ( <code>com.fasterxml.jackson.databind.ObjectMapper</code> ). <br><br>  Inilah cara saya membuat penangan baru di <code>main()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> serverPort = <span class="hljs-number"><span class="hljs-number">8000</span></span>; HttpServer server = HttpServer.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(serverPort), <span class="hljs-number"><span class="hljs-number">0</span></span>); RegistrationHandler registrationHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegistrationHandler(getUserService(), getObjectMapper(), getErrorHandler()); server.createContext(<span class="hljs-string"><span class="hljs-string">"/api/users/register"</span></span>, registrationHandler::handle); <span class="hljs-comment"><span class="hljs-comment">// here follows the rest.. }</span></span></code> </pre><br>  Contoh kerja dapat ditemukan di cabang <a href="https://github.com/piczmar/pure-java-rest-api/tree/step-6">langkah-6</a> .  Di sana saya juga menambahkan penangan pengecualian global untuk mengirim pesan kesalahan JSON standar.  Misalnya, jika metode HTTP tidak didukung atau permintaan ke API tidak dibentuk dengan benar. <br><br>  Anda dapat menjalankan aplikasi dan mencoba salah satu dari pertanyaan berikut: <br><br><ul><li>  contoh permintaan yang benar </li></ul><br><pre> <code class="java hljs">curl -X POST localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/users/register -d <span class="hljs-string"><span class="hljs-string">'{"login": "test" , "password" : "test"}'</span></span></code> </pre> <br>  jawab: <br><br><pre> <code class="java hljs">{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-string"><span class="hljs-string">"395eab24-1fdd-41ae-b47e-302591e6127e"</span></span>}</code> </pre> <br><ul><li>  contoh kesalahan </li></ul><br><pre> <code class="java hljs">curl -v -X POST localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>/api/users/register -d <span class="hljs-string"><span class="hljs-string">'{"wrong": "request"}'</span></span></code> </pre> <br>  jawab: <br><br><pre> <code class="java hljs">&lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> Bad Request &lt; Date: Sat, <span class="hljs-number"><span class="hljs-number">29</span></span> Dec <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> GMT &lt; Transfer-encoding: chunked &lt; Content-type: application/json &lt; * Connection #<span class="hljs-number"><span class="hljs-number">0</span></span> to host localhost left intact {<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-string"><span class="hljs-string">"message"</span></span>:<span class="hljs-string"><span class="hljs-string">"Unrecognized field \"wrong\" (class com.consulner.app.api.user.RegistrationRequest), not marked as ignorable (2 known properties: \"login\", \"password\"])\n at [Source: (sun.net.httpserver.FixedLengthInputStream); line: 1, column: 21] (through reference chain: com.consulner.app.api.user.RegistrationRequest[\"wrong\"])"</span></span>}</code> </pre> <br>  Selain itu, saya tidak sengaja berlari ke proyek <a href="https://github.com/Simonwep/java-express">java-express</a> , yang merupakan mitra Java dari kerangka kerja <a href="https://expressjs.com/">Express</a> untuk Node.js.  Ini juga menggunakan <code>jdk.httpserver</code> , sehingga Anda dapat mempelajari semua konsep yang dijelaskan dalam artikel ini pada kerangka nyata, yang, lebih dari itu, cukup kecil untuk mempelajari kodenya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480564/">https://habr.com/ru/post/id480564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480550/index.html">Hello World dari Bytecode untuk JVM</a></li>
<li><a href="../id480552/index.html">Firefox bertarung demi masa depan web</a></li>
<li><a href="../id480554/index.html">Masa depan komputasi awan Sun yang tidak pernah datang</a></li>
<li><a href="../id480556/index.html">NGINX: Verifikasi komunitas TI Rusia</a></li>
<li><a href="../id480558/index.html">Bagaimana tingkat penambangan impas memungkinkan Anda untuk menentukan titik pivot bitcoin</a></li>
<li><a href="../id480570/index.html">1.Elastic stack: analisis log keamanan. Pendahuluan</a></li>
<li><a href="../id480576/index.html">Tidak ada (hampir) yang tahu apa itu otorisasi.</a></li>
<li><a href="../id480580/index.html">Jadi sistem tidak berjalan</a></li>
<li><a href="../id480582/index.html">Security Week 51: kerentanan dalam prosesor iOS dan Intel</a></li>
<li><a href="../id480584/index.html">C ++ Rusia: masa lalu, sekarang dan masa depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>