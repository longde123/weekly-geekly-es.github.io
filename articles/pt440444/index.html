<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ˆğŸ½ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ ğŸ™ğŸ¾ Sistemas baseados em fila ğŸ™ ğŸ© ğŸ‘§ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! 

 Decidimos compartilhar a traduÃ§Ã£o do capÃ­tulo â€œSistemas baseados em filas de tarefasâ€. Da novidade a seguir, â€œSistemas distribuÃ­d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas baseados em fila</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/440444/">  Oi, habrozhiteli! <br><br>  Decidimos compartilhar a traduÃ§Ã£o do capÃ­tulo â€œSistemas baseados em filas de tarefasâ€. Da novidade a seguir, â€œSistemas distribuÃ­dos.  PadrÃµes de design â€(jÃ¡ na grÃ¡fica). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/c7/6k/c0c76kbloj9pjb2olgoma345bes.png" alt="imagem"></div><br>  A forma mais simples de processamento em lote Ã© a fila de tarefas.  Em um sistema com uma fila de tarefas, hÃ¡ um conjunto de tarefas que devem ser concluÃ­das.  Cada tarefa Ã© completamente independente das outras e pode ser processada sem nenhuma interaÃ§Ã£o com elas.  No caso geral, o objetivo de um sistema com uma fila de tarefas Ã© garantir que cada estÃ¡gio do trabalho seja concluÃ­do dentro de um determinado perÃ­odo de tempo.  O nÃºmero de fluxos de trabalho aumenta ou diminui de acordo com a alteraÃ§Ã£o na carga.  O esquema da fila de tarefas generalizadas Ã© apresentado na Fig.  10.1 <br><a name="habracut"></a><br><h3>  Um sistema baseado em uma fila de tarefas generalizada </h3><br>  A linha de tarefas Ã© um exemplo ideal que demonstra todo o poder dos padrÃµes de design de sistemas distribuÃ­dos.  A maior parte da lÃ³gica da fila de tarefas nÃ£o depende do tipo de trabalho executado.  Em muitos casos, o mesmo se aplica Ã  entrega das prÃ³prias tarefas. <br><br>  Vamos ilustrar esta declaraÃ§Ã£o usando a fila de tarefas mostrada na Fig.  10.1  Depois de examinar novamente, determine quais funÃ§Ãµes podem ser fornecidas por um conjunto compartilhado de contÃªineres.  Torna-se aparente que a maior parte da implementaÃ§Ã£o de uma fila de tarefas em contÃªiner pode ser usada por uma ampla variedade de usuÃ¡rios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8h/b2/qf/8hb2qfylszx_qmk8dicocvnvxtg.png" alt="imagem"></div><br>  O enfileiramento de tarefas baseado em contÃªiner requer interfaces correspondentes entre os contÃªineres da biblioteca e os contÃªineres com a lÃ³gica do usuÃ¡rio.  Na fila de tarefas em contÃªiner, sÃ£o distinguidas duas interfaces: a interface do contÃªiner de origem, que fornece um fluxo de tarefas que requerem processamento, e a interface do contÃªiner em execuÃ§Ã£o, que sabe como lidar com elas. <br><br><h3>  Interface do contÃªiner de origem </h3><br>  Qualquer fila de tarefas opera com base em um conjunto de tarefas que requerem processamento.  Dependendo do aplicativo especÃ­fico implementado com base na fila de tarefas, existem muitas fontes de tarefas que se enquadram nele.  PorÃ©m, apÃ³s receber um conjunto de tarefas, o esquema de operaÃ§Ã£o da fila Ã© bastante simples.  Portanto, podemos separar a lÃ³gica especÃ­fica do aplicativo da origem da tarefa do esquema generalizado de processamento da fila de tarefas.  Recordando os padrÃµes discutidos anteriormente de grupos de contÃªineres, aqui vocÃª pode ver a implementaÃ§Ã£o do padrÃ£o Ambassador.  O contÃªiner da fila de tarefas generalizada Ã© o contÃªiner principal do aplicativo, e o contÃªiner de origem especÃ­fico do aplicativo Ã© um embaixador transmitindo solicitaÃ§Ãµes do contÃªiner do despachante de fila para os executores de tarefas especÃ­ficos.  Este grupo de recipientes Ã© mostrado na Fig.  10.2 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/7u/pc/bx7upcqfw7gxqus2zqrhbrhqpes.png" alt="imagem"></div><br>  A propÃ³sito, embora o embaixador de contÃªiner seja especÃ­fico do aplicativo (o que Ã© Ã³bvio), tambÃ©m hÃ¡ vÃ¡rias implementaÃ§Ãµes generalizadas da API de origem da tarefa.  Por exemplo, a fonte pode ser uma lista de fotos localizadas em algum armazenamento na nuvem, um conjunto de arquivos em uma unidade de rede ou mesmo uma fila em sistemas operando com o princÃ­pio de "publicaÃ§Ã£o / assinatura", como Kafka ou Redis.  Apesar de os usuÃ¡rios poderem escolher os embaixadores de contÃªineres mais adequados para suas tarefas, eles devem usar uma implementaÃ§Ã£o generalizada de â€œbibliotecaâ€ do prÃ³prio contÃªiner.  Isso minimizarÃ¡ a quantidade de trabalho e maximizarÃ¡ a reutilizaÃ§Ã£o de cÃ³digo. <br><br>  <b>API da fila de tarefas</b>  Dado o mecanismo de interaÃ§Ã£o entre a fila de tarefas e o embaixador de contÃªiner especÃ­fico do aplicativo, devemos formular uma definiÃ§Ã£o formal da interface entre os dois contÃªineres.  Existem muitos protocolos diferentes, mas as APIs HTTP RESTful sÃ£o fÃ¡ceis de implementar e sÃ£o o padrÃ£o de fato para essas interfaces.  A fila de tarefas espera que os seguintes URLs sejam implementados no contÃªiner posterior: <br><br><ul><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost / api / v1 / items;</a> </li><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost / api / v1 / items</a> &lt;nome do item&gt;. </li></ul><blockquote>  Por que adicionar v1 Ã  sua definiÃ§Ã£o de API, vocÃª pergunta?  Alguma vez haverÃ¡ uma segunda versÃ£o da interface?  Parece ilÃ³gico, mas o custo de versionamento da API quando definido inicialmente Ã© mÃ­nimo.  Realizar a refatoraÃ§Ã£o apropriada posteriormente serÃ¡ extremamente caro.  EstabeleÃ§a como regra adicionar versÃµes a todas as APIs, mesmo se vocÃª nÃ£o tiver certeza se elas serÃ£o alteradas.  Deus salva o cofre. <br></blockquote>  URL / items / retorna uma lista de todas as tarefas: <br><br><pre><code class="plaintext hljs">{ kind: ItemList, apiVersion: v1, items: [ "item-1", "item-2", â€¦. ] }</code> </pre> <br>  A URL / items / &lt;item-name&gt; fornece informaÃ§Ãµes detalhadas sobre uma tarefa especÃ­fica: <br><br><pre> <code class="plaintext hljs">{ kind: Item, apiVersion: v1, data: { "some": "json", "object": "here", } }</code> </pre> <br>  Observe que a API nÃ£o fornece nenhum mecanismo para corrigir o fato da tarefa.  Pode-se desenvolver uma API mais complexa e transferir a maior parte da implementaÃ§Ã£o para um embaixador de contÃªiner.  Lembre-se, no entanto, que nosso objetivo Ã© concentrar o mÃ¡ximo da implementaÃ§Ã£o geral possÃ­vel no gerenciador de filas de tarefas.  Nesse sentido, o prÃ³prio gerenciador de filas de tarefas deve monitorar quais tarefas jÃ¡ foram processadas e quais ainda precisam ser processadas. <br><br>  A partir dessa API, obtemos informaÃ§Ãµes sobre uma tarefa especÃ­fica e depois passamos o valor do campo item.data da interface do contÃªiner do executor. <br><br><h3>  Executando a interface do contÃªiner </h3><br>  Assim que o gerenciador de filas receber a prÃ³xima tarefa, ele deverÃ¡ confiÃ¡-la a algum executor.  Essa Ã© a segunda interface na fila de tarefas generalizada.  O prÃ³prio contÃªiner e sua interface sÃ£o ligeiramente diferentes da interface do contÃªiner de origem por vÃ¡rios motivos.  Em primeiro lugar, Ã© uma API Ãºnica.  O trabalho do executor comeÃ§a com uma Ãºnica chamada e, durante o ciclo de vida do contÃªiner, nenhuma outra chamada Ã© feita.  Em segundo lugar, o contÃªiner em execuÃ§Ã£o e o gerenciador de filas de tarefas estÃ£o em diferentes grupos de contÃªineres.  O executor de contÃªiner Ã© iniciado por meio da API do orquestrador de contÃªineres em seu prÃ³prio grupo.  Isso significa que o gerenciador de filas de tarefas deve fazer uma chamada remota para iniciar o contÃªiner de execuÃ§Ã£o.  Isso tambÃ©m significa que vocÃª deve ter mais cuidado com problemas de seguranÃ§a, pois um usuÃ¡rio mal-intencionado do cluster pode carregÃ¡-lo com trabalho desnecessÃ¡rio. <br><br>  No contÃªiner de origem, usamos uma chamada HTTP simples para enviar a lista de tarefas ao gerenciador de tarefas.  Isso foi feito no pressuposto de que essa chamada Ã  API precisava ser feita vÃ¡rias vezes e os problemas de seguranÃ§a nÃ£o foram levados em consideraÃ§Ã£o, pois tudo funcionava na estrutura do host local.  A API do contÃªiner deve ser chamada apenas uma vez e Ã© importante garantir que outros usuÃ¡rios do sistema nÃ£o possam adicionar trabalho aos executores, mesmo por acidente ou por intenÃ§Ã£o maliciosa.  Portanto, para o contÃªiner em execuÃ§Ã£o, usaremos a API do arquivo.  ApÃ³s a criaÃ§Ã£o, transmitiremos ao contÃªiner uma variÃ¡vel de ambiente chamada WORK_ITEM_FILE, cujo valor se refere a um arquivo no sistema de arquivos interno do contÃªiner.  Este arquivo contÃ©m dados sobre a tarefa a ser concluÃ­da.  Esse tipo de API, como mostrado abaixo, pode ser implementado pelo objeto ConfigMap Kubernetes.  Pode ser montado em um grupo de contÃªineres como um arquivo (Fig. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/p0/zb/jnp0zbiduvl1qsstlwa1mphwrxq.png" alt="imagem"></div><br>  Esse mecanismo de API de arquivo Ã© mais fÃ¡cil de implementar usando um contÃªiner.  Um executor dentro de uma fila de tarefas geralmente Ã© um script de shell simples que acessa vÃ¡rias ferramentas.  NÃ£o Ã© prÃ¡tico criar um servidor Web inteiro para gerenciamento de tarefas - isso leva a uma complicaÃ§Ã£o da arquitetura.  Como no caso das fontes de tarefas, a maioria dos executores de contÃªineres serÃ¡ contÃªineres especializados para determinadas tarefas, mas tambÃ©m existem executores generalizados aplicÃ¡veis â€‹â€‹Ã  resoluÃ§Ã£o de vÃ¡rias tarefas diferentes. <br><br>  Considere o exemplo de um contÃªiner em execuÃ§Ã£o que baixa um arquivo do armazenamento em nuvem, executa um script de shell nele e copia o resultado novamente para o armazenamento em nuvem.  Esse contÃªiner pode ser geralmente geral, mas um cenÃ¡rio especÃ­fico pode ser passado a ele como parÃ¢metro.  Assim, a maior parte do cÃ³digo de manipulaÃ§Ã£o de arquivos pode ser reutilizada por muitos usuÃ¡rios / filas de tarefas.  O usuÃ¡rio final precisa apenas fornecer um script contendo as especificidades do processamento do arquivo. <br><br><h3>  Infraestrutura comum da fila de tarefas </h3><br>  O que resta a ser implementado em uma implementaÃ§Ã£o de fila reutilizÃ¡vel se vocÃª jÃ¡ possui implementaÃ§Ãµes das duas interfaces de contÃªiner descritas anteriormente?  O algoritmo bÃ¡sico da fila de tarefas Ã© bastante simples. <br><br><ol><li>  FaÃ§a o download das tarefas atualmente disponÃ­veis no contÃªiner de origem. </li><li>  EsclareÃ§a o status da fila de tarefas para quais tarefas jÃ¡ foram concluÃ­das ou ainda estÃ£o sendo executadas. </li><li>  Para cada uma das tarefas nÃ£o resolvidas, crie contÃªineres de contÃªiner com uma interface apropriada. </li><li>  ApÃ³s a conclusÃ£o bem-sucedida do contÃªiner em execuÃ§Ã£o, registre que a tarefa foi concluÃ­da. </li></ol><br>  Esse algoritmo Ã© simples em palavras, mas na realidade nÃ£o Ã© tÃ£o fÃ¡cil de implementar.  Felizmente, a orquestra Kubernetes possui vÃ¡rios recursos que simplificam bastante sua implementaÃ§Ã£o.  A saber: o Kubernetes possui um objeto de trabalho que garante uma operaÃ§Ã£o confiÃ¡vel da fila de tarefas.  VocÃª pode configurar o objeto Job para que ele inicie o contÃªiner em execuÃ§Ã£o correspondente uma vez ou atÃ© que a tarefa seja concluÃ­da com Ãªxito.  Se vocÃª configurar o contÃªiner em execuÃ§Ã£o para que seja executado antes que a tarefa seja concluÃ­da, mesmo quando a mÃ¡quina no cluster falhar, a tarefa serÃ¡ concluÃ­da com Ãªxito. <br><br>  Assim, o enfileiramento de tarefas Ã© bastante simplificado, pois a orquestra assume a responsabilidade pela execuÃ§Ã£o confiÃ¡vel das tarefas. <br><br>  AlÃ©m disso, o Kubernetes permite que vocÃª anote tarefas, o que nos permite marcar cada objeto de tarefa com o nome do elemento da fila de tarefas processadas.  EstÃ¡ se tornando mais fÃ¡cil distinguir entre tarefas que sÃ£o processadas e concluÃ­das com Ãªxito e com erro. <br><br>  Isso significa que podemos implementar a fila de tarefas no topo do orquestrador Kubernetes sem usar nosso prÃ³prio repositÃ³rio.  Tudo isso simplifica bastante a tarefa de construir a infraestrutura da fila de tarefas. <br><br>  Portanto, um algoritmo detalhado para a operaÃ§Ã£o do contÃªiner, o gerenciador de filas de tarefas, Ã© o seguinte. <br><br>  Repita sem parar. <br><br><ol><li>  Obtenha a lista de tarefas atravÃ©s da interface do contÃªiner - a origem das tarefas. </li><li>  Obtenha uma lista de tarefas que atendem a essa fila de tarefas. </li><li>  Com base nessas listas, selecione uma lista de tarefas nÃ£o processadas. </li><li>  Para cada tarefa nÃ£o processada, crie um objeto Job que gera o contÃªiner em execuÃ§Ã£o correspondente. </li></ol><br>  Aqui estÃ¡ um script Python que implementa esta fila: <br><br><pre> <code class="plaintext hljs">import requests import json from kubernetes import client, config import time namespace = "default" def make_container(item, obj): container = client.V1Container() container.image = "my/worker-image" container.name = "worker" return container def make_job(item): response = requests.get("http://localhost:8000/items/{}".format(item)) obj = json.loads(response.text) job = client.V1Job() job.metadata = client.V1ObjectMeta() job.metadata.name = item job.spec = client.V1JobSpec() job.spec.template = client.V1PodTemplate() job.spec.template.spec = client.V1PodTemplateSpec() job.spec.template.spec.restart_policy = "Never" job.spec.template.spec.containers = [ make_container(item, obj) ] return job def update_queue(batch): response = requests.get("http://localhost:8000/items") obj = json.loads(response.text) items = obj['items'] ret = batch.list_namespaced_job(namespace, watch=False) for item in items: found = False for i in ret.items: if i.metadata.name == item: found = True if not found: #    Job,  #   job = make_job(item) batch.create_namespaced_job(namespace, job) config.load_kube_config() batch = client.BatchV1Api() while True: update_queue(batch) time.sleep(10)</code> </pre> <br><h3>  SeminÃ¡rio  ImplementaÃ§Ã£o de um gerador de miniaturas para arquivos de vÃ­deo </h3><br>  Como exemplo de uso da fila de tarefas, considere a tarefa de gerar miniaturas de arquivos de vÃ­deo.  Com base nessas miniaturas, os usuÃ¡rios decidem quais vÃ­deos eles querem assistir. <br><br>  Para implementar as miniaturas, vocÃª precisa de dois contÃªineres.  O primeiro Ã© para a fonte das tarefas.  SerÃ¡ mais fÃ¡cil colocar tarefas em uma unidade de rede compartilhada conectada, por exemplo, via NFS (Sistema de arquivos de rede, sistema de arquivos de rede).  A fonte da tarefa recebe uma lista de arquivos nesse diretÃ³rio e os passa para o chamador. <br><br>  Vou dar um programa simples no NodeJS: <br><br><pre> <code class="plaintext hljs">const http = require('http'); const fs = require('fs'); const port = 8080; const path = process.env.MEDIA_PATH; const requestHandler = (request, response) =&gt; { console.log(request.url); fs.readdir(path + '/*.mp4', (err, items) =&gt; { var msg = { 'kind': 'ItemList', 'apiVersion': 'v1', 'items': [] }; if (!items) { return msg; } for (var i = 0; i &lt; items.length; i++) { msg.items.push(items[i]); } response.end(JSON.stringify(msg)); }); } const server = http.createServer(requestHandler); server.listen(port, (err) =&gt; { if (err) { return console.log('  ', err); } console.log(`    ${port}`) });</code> </pre> <br>  Esta fonte define a lista de filmes a serem processados.  O utilitÃ¡rio ffmpeg Ã© usado para extrair miniaturas. <br><br>  VocÃª pode criar um contÃªiner que execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">ffmpeg -i ${INPUT_FILE} -frames:v 100 thumb.png</code> </pre> <br>  O comando extrai um em cada 100 quadros (parÃ¢metro -frames: v 100) e o salva no formato PNG (por exemplo, thumb1.png, thumb2.png, etc.). <br><br>  Esse tipo de processamento pode ser implementado com base na imagem existente do ffmpeg Docker.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagem de jrottenberg / ffmpeg</a> Ã© popular. <br><br>  Ao definir um contÃªiner de origem simples e um executor de contÃªiner ainda mais simples, Ã© fÃ¡cil ver os benefÃ­cios de um sistema de gerenciamento de filas genÃ©rico e orientado a contÃªiner.  Reduz significativamente o tempo entre o design e a implementaÃ§Ã£o da fila de tarefas. <br><br><h3>  Dimensionamento dinÃ¢mico de artistas </h3><br>  A fila de tarefas considerada anteriormente Ã© bem adequada para processar tarefas Ã  medida que se tornam disponÃ­veis, mas pode levar a uma carga abrupta nos recursos do orquestrador de cluster de contÃªineres.  Isso Ã© bom quando vocÃª tem muitos tipos diferentes de tarefas que criam picos de carga em momentos diferentes e, assim, distribuem uniformemente a carga no cluster ao longo do tempo. <br><br>  Mas se vocÃª nÃ£o tiver tipos de carga suficientes, a abordagem "entÃ£o espessa e vazia" para escalar a fila de tarefas pode exigir a reserva de recursos adicionais para suportar rajadas de carga.  O resto do tempo, os recursos ficarÃ£o ociosos, esvaziando desnecessariamente sua carteira. <br><br>  Para resolver esse problema, vocÃª pode limitar o nÃºmero total de objetos de trabalho gerados pela fila de tarefas.  Isso naturalmente limita o nÃºmero de trabalhos processados â€‹â€‹em paralelo e, consequentemente, reduz o uso de recursos durante picos de carga.  Por outro lado, a duraÃ§Ã£o de cada tarefa individual aumentarÃ¡ com uma carga alta no cluster. <br><br>  Se a carga for espasmÃ³dica, isso nÃ£o serÃ¡ assustador, pois os intervalos de tempo de inatividade podem ser usados â€‹â€‹para concluir as tarefas acumuladas.  No entanto, se a carga constante for muito alta, a fila de tarefas nÃ£o terÃ¡ tempo para processar as tarefas recebidas e cada vez mais serÃ¡ gasto em sua implementaÃ§Ã£o. <br><br>  Em tal situaÃ§Ã£o, vocÃª precisarÃ¡ ajustar dinamicamente o nÃºmero mÃ¡ximo de tarefas paralelas e, consequentemente, os recursos de computaÃ§Ã£o disponÃ­veis para manter o nÃ­vel de desempenho necessÃ¡rio.  Felizmente, existem fÃ³rmulas matemÃ¡ticas que permitem determinar quando Ã© necessÃ¡rio escalar a fila de tarefas para processar mais solicitaÃ§Ãµes. <br><br>  Considere uma fila de tarefas em que uma nova tarefa apareÃ§a em mÃ©dia uma vez por minuto, e sua conclusÃ£o leve em mÃ©dia 30 segundos.  Essa fila Ã© capaz de lidar com o fluxo de tarefas que entram nela.  Mesmo que um grande pacote de tarefas chegue ao mesmo tempo, criando um engarrafamento, o engarrafamento serÃ¡ eliminado com o tempo, porque antes da prÃ³xima tarefa chegar, a fila consegue processar uma mÃ©dia de duas tarefas. <br><br>  Se uma nova tarefa chegar a cada minuto e levar uma mÃ©dia de 1 minuto para processar uma tarefa, esse sistema serÃ¡ idealmente equilibrado, mas nÃ£o responderÃ¡ bem a alteraÃ§Ãµes na carga.  Ela Ã© capaz de lidar com rajadas de carga, mas isso levarÃ¡ bastante tempo.  O sistema nÃ£o ficarÃ¡ ocioso, mas nÃ£o haverÃ¡ reserva de tempo no computador para compensar o aumento a longo prazo na velocidade de recebimento de novas tarefas.  Para manter a estabilidade do sistema, Ã© necessÃ¡rio ter uma reserva em caso de aumento de carga a longo prazo ou atrasos imprevistos nas tarefas de processamento. <br><br>  Por fim, considere um sistema no qual uma tarefa por minuto chega e o processamento da tarefa leva dois minutos.  Esse sistema constantemente perde desempenho.  A duraÃ§Ã£o da fila de tarefas aumentarÃ¡ junto com o atraso entre o recebimento e o processamento de tarefas (e o grau de irritaÃ§Ã£o dos usuÃ¡rios). <br><br>  Os valores desses dois indicadores devem ser constantemente monitorados.  Ao calcular a mÃ©dia do tempo entre o recebimento de tarefas por um longo perÃ­odo, por exemplo, com base no nÃºmero de tarefas por dia, obtemos uma estimativa do intervalo entre tarefas.  TambÃ©m Ã© necessÃ¡rio monitorar o tempo mÃ©dio de processamento da tarefa (excluindo o tempo gasto na fila).  Em uma fila de tarefas estÃ¡vel, o tempo mÃ©dio de processamento da tarefa deve ser menor que o intervalo entre tarefas.  Para garantir que essa condiÃ§Ã£o seja atendida, Ã© necessÃ¡rio ajustar dinamicamente o nÃºmero de filas disponÃ­veis de recursos de computaÃ§Ã£o.  Se os trabalhos forem processados â€‹â€‹em paralelo, o tempo de processamento deverÃ¡ ser dividido pelo nÃºmero de trabalhos processados â€‹â€‹em paralelo.  Por exemplo, se uma tarefa Ã© processada por minuto, mas quatro sÃ£o processadas em paralelo, o tempo efetivo de processamento de uma tarefa Ã© de 15 segundos, o que significa que o intervalo entre tarefas deve ser de pelo menos 16 segundos. <br><br>  Essa abordagem permite criar facilmente um mÃ³dulo para escalar a fila de tarefas para cima.  A reduÃ§Ã£o Ã© um pouco mais problemÃ¡tica.  No entanto, Ã© possÃ­vel usar os mesmos cÃ¡lculos de antes, estabelecendo adicionalmente a reserva de recursos computacionais determinados pela maneira heurÃ­stica.  Por exemplo, vocÃª pode reduzir o nÃºmero de tarefas paralelas atÃ© que o tempo de processamento de uma tarefa seja 90% do intervalo entre tarefas. <br><br><h3>  PadrÃ£o Multi-Trabalhador </h3><br>  Um dos principais tÃ³picos deste livro Ã© o uso de contÃªineres para encapsular e reutilizar o cÃ³digo.  TambÃ©m Ã© relevante para os padrÃµes de enfileiramento de tarefas descritos neste capÃ­tulo.  AlÃ©m dos contÃªineres que gerenciam a fila, Ã© possÃ­vel reutilizar grupos de contÃªineres que compÃµem a implementaÃ§Ã£o dos executores.  Suponha que vocÃª precise processar cada tarefa em uma fila de trÃªs maneiras diferentes.  Por exemplo, para detectar rostos em uma fotografia, combine-os com pessoas especÃ­ficas e depois desfoque as partes correspondentes da imagem.  VocÃª pode colocar todo o processamento em um contÃªiner em execuÃ§Ã£o, mas esta Ã© uma soluÃ§Ã£o Ãºnica que nÃ£o pode ser reutilizada.  Para encobrir outra coisa, como carros, na foto, vocÃª precisarÃ¡ criar um artista de contÃªiner do zero. <br><br>  A possibilidade desse tipo de reutilizaÃ§Ã£o pode ser alcanÃ§ada aplicando o padrÃ£o Multi-Worker, que Ã© realmente um caso especial do padrÃ£o Adapter descrito no inÃ­cio do livro.  O padrÃ£o Multi-Worker converte um conjunto de contÃªineres em um contÃªiner comum com a interface do software do contÃªiner em execuÃ§Ã£o.  Esse contÃªiner compartilhado delega o processamento para vÃ¡rios contÃªineres reutilizÃ¡veis â€‹â€‹separados.  Este processo Ã© mostrado esquematicamente na Fig.  10.4 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/wx/zv/eiwxzvdwvre9k_ftflo2xfz_bz4.png" alt="imagem"></div><br>  Ao reutilizar o cÃ³digo combinando a execuÃ§Ã£o de contÃªineres, o trabalho das pessoas que projetam sistemas de processamento em lote distribuÃ­do Ã© reduzido. <br><br>  Â»Mais informaÃ§Ãµes sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ConteÃºdo</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Para habrozhitelami desconto de 20% no cupom - <b>sistemas distribuÃ­dos</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440444/">https://habr.com/ru/post/pt440444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440432/index.html">SciFi de sexta-feira sobre as profissÃµes do futuro: â€œGarotas de Verdadeâ€</a></li>
<li><a href="../pt440434/index.html">IndÃºstria automobilÃ­stica russa: o caminho para tecnologias aditivas</a></li>
<li><a href="../pt440436/index.html">Tarefas prÃ¡ticas Java - para cursos e outras atividades</a></li>
<li><a href="../pt440438/index.html">PrÃ©-lanÃ§amento do MQTT / UDP: configuraÃ§Ã£o remota e assinatura digital</a></li>
<li><a href="../pt440440/index.html">Como consegui um emprego com um salÃ¡rio de US $ 300.000 no Vale do SilÃ­cio</a></li>
<li><a href="../pt440446/index.html">SÃ©rie de seminÃ¡rios on-line sobre o fluxo de trabalho do TDMS</a></li>
<li><a href="../pt440448/index.html">O que terminou a histÃ³ria com o programador sem-teto</a></li>
<li><a href="../pt440450/index.html">Existe um rublo para entrada, mas nÃ£o hÃ¡ saÃ­da: como os arquivos de terceiros entram no blockchain e o que fazer com ele</a></li>
<li><a href="../pt440454/index.html">Paul Graham: O que aprendi com o Hacker News</a></li>
<li><a href="../pt440458/index.html">PrevisÃ£o do status da rede VoIP com base nos arquivos de log de texto do servidor de aplicativos SIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>