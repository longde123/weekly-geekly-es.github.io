<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 👨‍👩‍👦 🙏🏾 Sistemas baseados em fila 🍙 🍩 👧🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! 

 Decidimos compartilhar a tradução do capítulo “Sistemas baseados em filas de tarefas”. Da novidade a seguir, “Sistemas distribuíd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas baseados em fila</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/440444/">  Oi, habrozhiteli! <br><br>  Decidimos compartilhar a tradução do capítulo “Sistemas baseados em filas de tarefas”. Da novidade a seguir, “Sistemas distribuídos.  Padrões de design ”(já na gráfica). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/c7/6k/c0c76kbloj9pjb2olgoma345bes.png" alt="imagem"></div><br>  A forma mais simples de processamento em lote é a fila de tarefas.  Em um sistema com uma fila de tarefas, há um conjunto de tarefas que devem ser concluídas.  Cada tarefa é completamente independente das outras e pode ser processada sem nenhuma interação com elas.  No caso geral, o objetivo de um sistema com uma fila de tarefas é garantir que cada estágio do trabalho seja concluído dentro de um determinado período de tempo.  O número de fluxos de trabalho aumenta ou diminui de acordo com a alteração na carga.  O esquema da fila de tarefas generalizadas é apresentado na Fig.  10.1 <br><a name="habracut"></a><br><h3>  Um sistema baseado em uma fila de tarefas generalizada </h3><br>  A linha de tarefas é um exemplo ideal que demonstra todo o poder dos padrões de design de sistemas distribuídos.  A maior parte da lógica da fila de tarefas não depende do tipo de trabalho executado.  Em muitos casos, o mesmo se aplica à entrega das próprias tarefas. <br><br>  Vamos ilustrar esta declaração usando a fila de tarefas mostrada na Fig.  10.1  Depois de examinar novamente, determine quais funções podem ser fornecidas por um conjunto compartilhado de contêineres.  Torna-se aparente que a maior parte da implementação de uma fila de tarefas em contêiner pode ser usada por uma ampla variedade de usuários. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8h/b2/qf/8hb2qfylszx_qmk8dicocvnvxtg.png" alt="imagem"></div><br>  O enfileiramento de tarefas baseado em contêiner requer interfaces correspondentes entre os contêineres da biblioteca e os contêineres com a lógica do usuário.  Na fila de tarefas em contêiner, são distinguidas duas interfaces: a interface do contêiner de origem, que fornece um fluxo de tarefas que requerem processamento, e a interface do contêiner em execução, que sabe como lidar com elas. <br><br><h3>  Interface do contêiner de origem </h3><br>  Qualquer fila de tarefas opera com base em um conjunto de tarefas que requerem processamento.  Dependendo do aplicativo específico implementado com base na fila de tarefas, existem muitas fontes de tarefas que se enquadram nele.  Porém, após receber um conjunto de tarefas, o esquema de operação da fila é bastante simples.  Portanto, podemos separar a lógica específica do aplicativo da origem da tarefa do esquema generalizado de processamento da fila de tarefas.  Recordando os padrões discutidos anteriormente de grupos de contêineres, aqui você pode ver a implementação do padrão Ambassador.  O contêiner da fila de tarefas generalizada é o contêiner principal do aplicativo, e o contêiner de origem específico do aplicativo é um embaixador transmitindo solicitações do contêiner do despachante de fila para os executores de tarefas específicos.  Este grupo de recipientes é mostrado na Fig.  10.2 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/7u/pc/bx7upcqfw7gxqus2zqrhbrhqpes.png" alt="imagem"></div><br>  A propósito, embora o embaixador de contêiner seja específico do aplicativo (o que é óbvio), também há várias implementações generalizadas da API de origem da tarefa.  Por exemplo, a fonte pode ser uma lista de fotos localizadas em algum armazenamento na nuvem, um conjunto de arquivos em uma unidade de rede ou mesmo uma fila em sistemas operando com o princípio de "publicação / assinatura", como Kafka ou Redis.  Apesar de os usuários poderem escolher os embaixadores de contêineres mais adequados para suas tarefas, eles devem usar uma implementação generalizada de “biblioteca” do próprio contêiner.  Isso minimizará a quantidade de trabalho e maximizará a reutilização de código. <br><br>  <b>API da fila de tarefas</b>  Dado o mecanismo de interação entre a fila de tarefas e o embaixador de contêiner específico do aplicativo, devemos formular uma definição formal da interface entre os dois contêineres.  Existem muitos protocolos diferentes, mas as APIs HTTP RESTful são fáceis de implementar e são o padrão de fato para essas interfaces.  A fila de tarefas espera que os seguintes URLs sejam implementados no contêiner posterior: <br><br><ul><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost / api / v1 / items;</a> </li><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost / api / v1 / items</a> &lt;nome do item&gt;. </li></ul><blockquote>  Por que adicionar v1 à sua definição de API, você pergunta?  Alguma vez haverá uma segunda versão da interface?  Parece ilógico, mas o custo de versionamento da API quando definido inicialmente é mínimo.  Realizar a refatoração apropriada posteriormente será extremamente caro.  Estabeleça como regra adicionar versões a todas as APIs, mesmo se você não tiver certeza se elas serão alteradas.  Deus salva o cofre. <br></blockquote>  URL / items / retorna uma lista de todas as tarefas: <br><br><pre><code class="plaintext hljs">{ kind: ItemList, apiVersion: v1, items: [ "item-1", "item-2", …. ] }</code> </pre> <br>  A URL / items / &lt;item-name&gt; fornece informações detalhadas sobre uma tarefa específica: <br><br><pre> <code class="plaintext hljs">{ kind: Item, apiVersion: v1, data: { "some": "json", "object": "here", } }</code> </pre> <br>  Observe que a API não fornece nenhum mecanismo para corrigir o fato da tarefa.  Pode-se desenvolver uma API mais complexa e transferir a maior parte da implementação para um embaixador de contêiner.  Lembre-se, no entanto, que nosso objetivo é concentrar o máximo da implementação geral possível no gerenciador de filas de tarefas.  Nesse sentido, o próprio gerenciador de filas de tarefas deve monitorar quais tarefas já foram processadas e quais ainda precisam ser processadas. <br><br>  A partir dessa API, obtemos informações sobre uma tarefa específica e depois passamos o valor do campo item.data da interface do contêiner do executor. <br><br><h3>  Executando a interface do contêiner </h3><br>  Assim que o gerenciador de filas receber a próxima tarefa, ele deverá confiá-la a algum executor.  Essa é a segunda interface na fila de tarefas generalizada.  O próprio contêiner e sua interface são ligeiramente diferentes da interface do contêiner de origem por vários motivos.  Em primeiro lugar, é uma API única.  O trabalho do executor começa com uma única chamada e, durante o ciclo de vida do contêiner, nenhuma outra chamada é feita.  Em segundo lugar, o contêiner em execução e o gerenciador de filas de tarefas estão em diferentes grupos de contêineres.  O executor de contêiner é iniciado por meio da API do orquestrador de contêineres em seu próprio grupo.  Isso significa que o gerenciador de filas de tarefas deve fazer uma chamada remota para iniciar o contêiner de execução.  Isso também significa que você deve ter mais cuidado com problemas de segurança, pois um usuário mal-intencionado do cluster pode carregá-lo com trabalho desnecessário. <br><br>  No contêiner de origem, usamos uma chamada HTTP simples para enviar a lista de tarefas ao gerenciador de tarefas.  Isso foi feito no pressuposto de que essa chamada à API precisava ser feita várias vezes e os problemas de segurança não foram levados em consideração, pois tudo funcionava na estrutura do host local.  A API do contêiner deve ser chamada apenas uma vez e é importante garantir que outros usuários do sistema não possam adicionar trabalho aos executores, mesmo por acidente ou por intenção maliciosa.  Portanto, para o contêiner em execução, usaremos a API do arquivo.  Após a criação, transmitiremos ao contêiner uma variável de ambiente chamada WORK_ITEM_FILE, cujo valor se refere a um arquivo no sistema de arquivos interno do contêiner.  Este arquivo contém dados sobre a tarefa a ser concluída.  Esse tipo de API, como mostrado abaixo, pode ser implementado pelo objeto ConfigMap Kubernetes.  Pode ser montado em um grupo de contêineres como um arquivo (Fig. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/p0/zb/jnp0zbiduvl1qsstlwa1mphwrxq.png" alt="imagem"></div><br>  Esse mecanismo de API de arquivo é mais fácil de implementar usando um contêiner.  Um executor dentro de uma fila de tarefas geralmente é um script de shell simples que acessa várias ferramentas.  Não é prático criar um servidor Web inteiro para gerenciamento de tarefas - isso leva a uma complicação da arquitetura.  Como no caso das fontes de tarefas, a maioria dos executores de contêineres será contêineres especializados para determinadas tarefas, mas também existem executores generalizados aplicáveis ​​à resolução de várias tarefas diferentes. <br><br>  Considere o exemplo de um contêiner em execução que baixa um arquivo do armazenamento em nuvem, executa um script de shell nele e copia o resultado novamente para o armazenamento em nuvem.  Esse contêiner pode ser geralmente geral, mas um cenário específico pode ser passado a ele como parâmetro.  Assim, a maior parte do código de manipulação de arquivos pode ser reutilizada por muitos usuários / filas de tarefas.  O usuário final precisa apenas fornecer um script contendo as especificidades do processamento do arquivo. <br><br><h3>  Infraestrutura comum da fila de tarefas </h3><br>  O que resta a ser implementado em uma implementação de fila reutilizável se você já possui implementações das duas interfaces de contêiner descritas anteriormente?  O algoritmo básico da fila de tarefas é bastante simples. <br><br><ol><li>  Faça o download das tarefas atualmente disponíveis no contêiner de origem. </li><li>  Esclareça o status da fila de tarefas para quais tarefas já foram concluídas ou ainda estão sendo executadas. </li><li>  Para cada uma das tarefas não resolvidas, crie contêineres de contêiner com uma interface apropriada. </li><li>  Após a conclusão bem-sucedida do contêiner em execução, registre que a tarefa foi concluída. </li></ol><br>  Esse algoritmo é simples em palavras, mas na realidade não é tão fácil de implementar.  Felizmente, a orquestra Kubernetes possui vários recursos que simplificam bastante sua implementação.  A saber: o Kubernetes possui um objeto de trabalho que garante uma operação confiável da fila de tarefas.  Você pode configurar o objeto Job para que ele inicie o contêiner em execução correspondente uma vez ou até que a tarefa seja concluída com êxito.  Se você configurar o contêiner em execução para que seja executado antes que a tarefa seja concluída, mesmo quando a máquina no cluster falhar, a tarefa será concluída com êxito. <br><br>  Assim, o enfileiramento de tarefas é bastante simplificado, pois a orquestra assume a responsabilidade pela execução confiável das tarefas. <br><br>  Além disso, o Kubernetes permite que você anote tarefas, o que nos permite marcar cada objeto de tarefa com o nome do elemento da fila de tarefas processadas.  Está se tornando mais fácil distinguir entre tarefas que são processadas e concluídas com êxito e com erro. <br><br>  Isso significa que podemos implementar a fila de tarefas no topo do orquestrador Kubernetes sem usar nosso próprio repositório.  Tudo isso simplifica bastante a tarefa de construir a infraestrutura da fila de tarefas. <br><br>  Portanto, um algoritmo detalhado para a operação do contêiner, o gerenciador de filas de tarefas, é o seguinte. <br><br>  Repita sem parar. <br><br><ol><li>  Obtenha a lista de tarefas através da interface do contêiner - a origem das tarefas. </li><li>  Obtenha uma lista de tarefas que atendem a essa fila de tarefas. </li><li>  Com base nessas listas, selecione uma lista de tarefas não processadas. </li><li>  Para cada tarefa não processada, crie um objeto Job que gera o contêiner em execução correspondente. </li></ol><br>  Aqui está um script Python que implementa esta fila: <br><br><pre> <code class="plaintext hljs">import requests import json from kubernetes import client, config import time namespace = "default" def make_container(item, obj): container = client.V1Container() container.image = "my/worker-image" container.name = "worker" return container def make_job(item): response = requests.get("http://localhost:8000/items/{}".format(item)) obj = json.loads(response.text) job = client.V1Job() job.metadata = client.V1ObjectMeta() job.metadata.name = item job.spec = client.V1JobSpec() job.spec.template = client.V1PodTemplate() job.spec.template.spec = client.V1PodTemplateSpec() job.spec.template.spec.restart_policy = "Never" job.spec.template.spec.containers = [ make_container(item, obj) ] return job def update_queue(batch): response = requests.get("http://localhost:8000/items") obj = json.loads(response.text) items = obj['items'] ret = batch.list_namespaced_job(namespace, watch=False) for item in items: found = False for i in ret.items: if i.metadata.name == item: found = True if not found: #    Job,  #   job = make_job(item) batch.create_namespaced_job(namespace, job) config.load_kube_config() batch = client.BatchV1Api() while True: update_queue(batch) time.sleep(10)</code> </pre> <br><h3>  Seminário  Implementação de um gerador de miniaturas para arquivos de vídeo </h3><br>  Como exemplo de uso da fila de tarefas, considere a tarefa de gerar miniaturas de arquivos de vídeo.  Com base nessas miniaturas, os usuários decidem quais vídeos eles querem assistir. <br><br>  Para implementar as miniaturas, você precisa de dois contêineres.  O primeiro é para a fonte das tarefas.  Será mais fácil colocar tarefas em uma unidade de rede compartilhada conectada, por exemplo, via NFS (Sistema de arquivos de rede, sistema de arquivos de rede).  A fonte da tarefa recebe uma lista de arquivos nesse diretório e os passa para o chamador. <br><br>  Vou dar um programa simples no NodeJS: <br><br><pre> <code class="plaintext hljs">const http = require('http'); const fs = require('fs'); const port = 8080; const path = process.env.MEDIA_PATH; const requestHandler = (request, response) =&gt; { console.log(request.url); fs.readdir(path + '/*.mp4', (err, items) =&gt; { var msg = { 'kind': 'ItemList', 'apiVersion': 'v1', 'items': [] }; if (!items) { return msg; } for (var i = 0; i &lt; items.length; i++) { msg.items.push(items[i]); } response.end(JSON.stringify(msg)); }); } const server = http.createServer(requestHandler); server.listen(port, (err) =&gt; { if (err) { return console.log('  ', err); } console.log(`    ${port}`) });</code> </pre> <br>  Esta fonte define a lista de filmes a serem processados.  O utilitário ffmpeg é usado para extrair miniaturas. <br><br>  Você pode criar um contêiner que execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">ffmpeg -i ${INPUT_FILE} -frames:v 100 thumb.png</code> </pre> <br>  O comando extrai um em cada 100 quadros (parâmetro -frames: v 100) e o salva no formato PNG (por exemplo, thumb1.png, thumb2.png, etc.). <br><br>  Esse tipo de processamento pode ser implementado com base na imagem existente do ffmpeg Docker.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagem de jrottenberg / ffmpeg</a> é popular. <br><br>  Ao definir um contêiner de origem simples e um executor de contêiner ainda mais simples, é fácil ver os benefícios de um sistema de gerenciamento de filas genérico e orientado a contêiner.  Reduz significativamente o tempo entre o design e a implementação da fila de tarefas. <br><br><h3>  Dimensionamento dinâmico de artistas </h3><br>  A fila de tarefas considerada anteriormente é bem adequada para processar tarefas à medida que se tornam disponíveis, mas pode levar a uma carga abrupta nos recursos do orquestrador de cluster de contêineres.  Isso é bom quando você tem muitos tipos diferentes de tarefas que criam picos de carga em momentos diferentes e, assim, distribuem uniformemente a carga no cluster ao longo do tempo. <br><br>  Mas se você não tiver tipos de carga suficientes, a abordagem "então espessa e vazia" para escalar a fila de tarefas pode exigir a reserva de recursos adicionais para suportar rajadas de carga.  O resto do tempo, os recursos ficarão ociosos, esvaziando desnecessariamente sua carteira. <br><br>  Para resolver esse problema, você pode limitar o número total de objetos de trabalho gerados pela fila de tarefas.  Isso naturalmente limita o número de trabalhos processados ​​em paralelo e, consequentemente, reduz o uso de recursos durante picos de carga.  Por outro lado, a duração de cada tarefa individual aumentará com uma carga alta no cluster. <br><br>  Se a carga for espasmódica, isso não será assustador, pois os intervalos de tempo de inatividade podem ser usados ​​para concluir as tarefas acumuladas.  No entanto, se a carga constante for muito alta, a fila de tarefas não terá tempo para processar as tarefas recebidas e cada vez mais será gasto em sua implementação. <br><br>  Em tal situação, você precisará ajustar dinamicamente o número máximo de tarefas paralelas e, consequentemente, os recursos de computação disponíveis para manter o nível de desempenho necessário.  Felizmente, existem fórmulas matemáticas que permitem determinar quando é necessário escalar a fila de tarefas para processar mais solicitações. <br><br>  Considere uma fila de tarefas em que uma nova tarefa apareça em média uma vez por minuto, e sua conclusão leve em média 30 segundos.  Essa fila é capaz de lidar com o fluxo de tarefas que entram nela.  Mesmo que um grande pacote de tarefas chegue ao mesmo tempo, criando um engarrafamento, o engarrafamento será eliminado com o tempo, porque antes da próxima tarefa chegar, a fila consegue processar uma média de duas tarefas. <br><br>  Se uma nova tarefa chegar a cada minuto e levar uma média de 1 minuto para processar uma tarefa, esse sistema será idealmente equilibrado, mas não responderá bem a alterações na carga.  Ela é capaz de lidar com rajadas de carga, mas isso levará bastante tempo.  O sistema não ficará ocioso, mas não haverá reserva de tempo no computador para compensar o aumento a longo prazo na velocidade de recebimento de novas tarefas.  Para manter a estabilidade do sistema, é necessário ter uma reserva em caso de aumento de carga a longo prazo ou atrasos imprevistos nas tarefas de processamento. <br><br>  Por fim, considere um sistema no qual uma tarefa por minuto chega e o processamento da tarefa leva dois minutos.  Esse sistema constantemente perde desempenho.  A duração da fila de tarefas aumentará junto com o atraso entre o recebimento e o processamento de tarefas (e o grau de irritação dos usuários). <br><br>  Os valores desses dois indicadores devem ser constantemente monitorados.  Ao calcular a média do tempo entre o recebimento de tarefas por um longo período, por exemplo, com base no número de tarefas por dia, obtemos uma estimativa do intervalo entre tarefas.  Também é necessário monitorar o tempo médio de processamento da tarefa (excluindo o tempo gasto na fila).  Em uma fila de tarefas estável, o tempo médio de processamento da tarefa deve ser menor que o intervalo entre tarefas.  Para garantir que essa condição seja atendida, é necessário ajustar dinamicamente o número de filas disponíveis de recursos de computação.  Se os trabalhos forem processados ​​em paralelo, o tempo de processamento deverá ser dividido pelo número de trabalhos processados ​​em paralelo.  Por exemplo, se uma tarefa é processada por minuto, mas quatro são processadas em paralelo, o tempo efetivo de processamento de uma tarefa é de 15 segundos, o que significa que o intervalo entre tarefas deve ser de pelo menos 16 segundos. <br><br>  Essa abordagem permite criar facilmente um módulo para escalar a fila de tarefas para cima.  A redução é um pouco mais problemática.  No entanto, é possível usar os mesmos cálculos de antes, estabelecendo adicionalmente a reserva de recursos computacionais determinados pela maneira heurística.  Por exemplo, você pode reduzir o número de tarefas paralelas até que o tempo de processamento de uma tarefa seja 90% do intervalo entre tarefas. <br><br><h3>  Padrão Multi-Trabalhador </h3><br>  Um dos principais tópicos deste livro é o uso de contêineres para encapsular e reutilizar o código.  Também é relevante para os padrões de enfileiramento de tarefas descritos neste capítulo.  Além dos contêineres que gerenciam a fila, é possível reutilizar grupos de contêineres que compõem a implementação dos executores.  Suponha que você precise processar cada tarefa em uma fila de três maneiras diferentes.  Por exemplo, para detectar rostos em uma fotografia, combine-os com pessoas específicas e depois desfoque as partes correspondentes da imagem.  Você pode colocar todo o processamento em um contêiner em execução, mas esta é uma solução única que não pode ser reutilizada.  Para encobrir outra coisa, como carros, na foto, você precisará criar um artista de contêiner do zero. <br><br>  A possibilidade desse tipo de reutilização pode ser alcançada aplicando o padrão Multi-Worker, que é realmente um caso especial do padrão Adapter descrito no início do livro.  O padrão Multi-Worker converte um conjunto de contêineres em um contêiner comum com a interface do software do contêiner em execução.  Esse contêiner compartilhado delega o processamento para vários contêineres reutilizáveis ​​separados.  Este processo é mostrado esquematicamente na Fig.  10.4 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/wx/zv/eiwxzvdwvre9k_ftflo2xfz_bz4.png" alt="imagem"></div><br>  Ao reutilizar o código combinando a execução de contêineres, o trabalho das pessoas que projetam sistemas de processamento em lote distribuído é reduzido. <br><br>  »Mais informações sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Para habrozhitelami desconto de 20% no cupom - <b>sistemas distribuídos</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440444/">https://habr.com/ru/post/pt440444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440432/index.html">SciFi de sexta-feira sobre as profissões do futuro: “Garotas de Verdade”</a></li>
<li><a href="../pt440434/index.html">Indústria automobilística russa: o caminho para tecnologias aditivas</a></li>
<li><a href="../pt440436/index.html">Tarefas práticas Java - para cursos e outras atividades</a></li>
<li><a href="../pt440438/index.html">Pré-lançamento do MQTT / UDP: configuração remota e assinatura digital</a></li>
<li><a href="../pt440440/index.html">Como consegui um emprego com um salário de US $ 300.000 no Vale do Silício</a></li>
<li><a href="../pt440446/index.html">Série de seminários on-line sobre o fluxo de trabalho do TDMS</a></li>
<li><a href="../pt440448/index.html">O que terminou a história com o programador sem-teto</a></li>
<li><a href="../pt440450/index.html">Existe um rublo para entrada, mas não há saída: como os arquivos de terceiros entram no blockchain e o que fazer com ele</a></li>
<li><a href="../pt440454/index.html">Paul Graham: O que aprendi com o Hacker News</a></li>
<li><a href="../pt440458/index.html">Previsão do status da rede VoIP com base nos arquivos de log de texto do servidor de aplicativos SIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>