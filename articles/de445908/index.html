<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 ⛩️ 🧑🏾‍🤝‍🧑🏼 Golang und die Entwicklung der Datenbankinteraktion 👲🏽 🤦 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel möchte ich die Probleme bei der Arbeit mit Datenbanken zusammenfassen, auf denen golang ausgeführt wird. Bei der Lösung einfacher Pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang und die Entwicklung der Datenbankinteraktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445908/"><p> In diesem Artikel möchte ich die Probleme bei der Arbeit mit Datenbanken zusammenfassen, auf denen golang ausgeführt wird.  Bei der Lösung einfacher Probleme sind diese Probleme normalerweise nicht sichtbar.  Wenn das Projekt wächst, wächst auch das Problem.  Das aktuellste von ihnen: </p><br><ul><li>  Verringern der Konnektivität einer Datenbankanwendung </li><li>  Abfrageprotokollierung im Debug-Modus </li><li>  Arbeiten Sie mit Replikaten </li></ul><br><p>  Der Artikel basiert auf dem Paket github.com/adverax/echo/database/sql.  Die Semantik der Verwendung dieses Pakets kommt dem Standard-Datenbank- / SQL-Paket so nahe wie möglich, sodass ich nicht glaube, dass irgendjemand Probleme haben wird, es zu verwenden. </p><a name="habracut"></a><br><h1 id="oblast-vidimosti">  Geltungsbereich </h1><br><p>  In der Regel versuchen große Systeme, eine lose Verbindung mit einem klaren Verantwortungsbereich für jede Komponente des Systems herzustellen.  Daher sind Entwurfsmuster für Verlage / Abonnenten weit verbreitet.  Betrachten Sie ein kleines Beispiel für die Registrierung eines neuen Benutzers im System. </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Language <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { id, err = m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } user.Id = id err = m.OnSignup(m.DB, user) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { res, err := m.DB.Exec(<span class="hljs-string"><span class="hljs-string">"INSERT ..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } id, err := res.LastInsertId() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(db *sql.DB, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  In diesem Beispiel interessieren wir uns hauptsächlich für das OnSignup-Ereignis.  Zur Vereinfachung wird der Handler durch eine einzige Funktion dargestellt (im wirklichen Leben ist alles komplizierter).  In der Ereignissignatur schreiben wir den Typ des ersten Parameters streng vor, was normalerweise weitreichende Konsequenzen hat. <br>  Angenommen, wir möchten jetzt die Funktionalität unserer Anwendung erweitern und im Falle einer erfolgreichen Benutzerregistrierung eine Nachricht an sein persönliches Konto senden.  Idealerweise sollte die Nachricht in derselben Transaktion wie die Benutzerregistrierung platziert werden. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *sql.Tx, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { tx, err := m.DB.Begin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> tx.Rollback() id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } user.Id = id err = m.OnSignup(tx, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx.Commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(db *sql.Tx, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  Wie Sie dem Beispiel entnehmen können, mussten wir die Signatur des Ereignisses ändern.  Diese Lösung ist nicht sauber und impliziert, dass die Handler den Kontext der Ausführung der Datenbankabfrage kennen.  Eine viel sauberere Lösung wäre die Verwendung einer generischen Datenbank und einer Transaktionsschnittstelle - Umfang. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/adverax/echo/database/sql"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope sql.Scope, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { tx, err := m.DB.Begin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> tx.Rollback() id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } err = m.OnSignup(tx, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx.Commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(scope sql.Scope, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  Um diesen Ansatz zu implementieren, benötigen wir Unterstützung für verschachtelte Transaktionen, da der Handler wiederum Transaktionen verwenden kann.  Glücklicherweise ist dies kein Problem, da die meisten DBMS den SAVEPOINT-Mechanismus unterstützen. </p><br><h1 id="baza-dannyh-i-kontekst">  Datenbank und Kontext </h1><br><p>  In der Regel wird die Verbindung zur Datenbank nicht wie oben gezeigt als Parameter übergeben, und jeder Manager behält eine Verbindung zur Verbindung zur Datenbank bei.  Dies vereinfacht die Methodensignaturen und verbessert die Lesbarkeit des Codes.  In unserem Fall ist dies nicht zu vermeiden, da Sie einen Link zur Transaktion übertragen müssen. <br>  Eine ziemlich elegante Lösung besteht darin, den Link zur Transaktion (Bereich) in den Kontext zu stellen, da der Kontext als Pass-Through-Parameter positioniert ist.  Dann können wir unseren Code weiter vereinfachen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/adverax/echo/database/sql"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sql.Repository OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Transaction( ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, scope sql.Scope)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } user.Id = id <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.OnSignup(ctx, user) }, ) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Messenger <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sql.Repository } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messenger *Messenger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSignupUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := messenger.Scope(ctx).Exec(<span class="hljs-string"><span class="hljs-string">"INSERT ..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db := ... messenger := &amp;Messenger{ Repository: sql.NewRepository(db), } manager := &amp;Manager{ Repository: sql.NewRepository(db), OnSignup: messenger.onSignup, } err := manager.Signup(&amp;User{...}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br><p>  Dieses Beispiel zeigt, dass wir die vollständige Isolation der Manager beibehalten, die Lesbarkeit des Codes verbessert und ihre gemeinsame Arbeit in einem einzigen Bereich erreicht haben. </p><br><h1 id="podderzhka-replikaciy">  Replikationsunterstützung </h1><br><p>  Die Bibliothek unterstützt auch die Verwendung der Replikation.  Alle Anfragen vom Typ Exec werden an den Master gesendet.  Anfragen vom Slave-Typ werden an einen zufällig ausgewählten Slave übertragen.  Geben Sie zur Unterstützung der Replikation einfach mehrere Datenquellen an: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { dsc := &amp;sql.DSC{ Driver: <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>, DSN: []*sql.DSN{ { Host: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, Database: <span class="hljs-string"><span class="hljs-string">"echo"</span></span>, Username: <span class="hljs-string"><span class="hljs-string">"root"</span></span>, Password: <span class="hljs-string"><span class="hljs-string">"password"</span></span>, }, { Host: <span class="hljs-string"><span class="hljs-string">"192.168.44.01"</span></span>, Database: <span class="hljs-string"><span class="hljs-string">"echo"</span></span>, Username: <span class="hljs-string"><span class="hljs-string">"root"</span></span>, Password: <span class="hljs-string"><span class="hljs-string">"password"</span></span>, }, }, } db := dsc.Open(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> db.Close() ... }</code> </pre> <br><p>  Wenn Sie beim Öffnen einer Datenbank eine einzelne Datenquelle verwenden, wird diese im normalen Modus ohne zusätzlichen Aufwand geöffnet. </p><br><h1 id="metriki">  Metriken </h1><br><p>  Wie Sie wissen, sind Metriken billig und Protokolle teuer.  Daher wurde beschlossen, die Standardmetriken zu unterstützen. </p><br><h1 id="profilirovanie-i-loggirovanie-zaprosov">  Abfrageprofilerstellung und Protokollierung </h1><br><p>  Es ist sehr wichtig, Datenbankabfragen während des Debuggens zu protokollieren.  Ich habe jedoch keinen hochwertigen Protokollierungsmechanismus ohne Overhead in der Produktion gesehen.  Mit der Bibliothek können Sie dieses Problem elegant lösen, indem Sie die Datenbank umschließen.  Um die Datenbank zu profilieren, übergeben Sie einfach den entsprechenden Aktivator: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dsc sql.DSC, debug </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sql.DB, error)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> debug { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dsc.Open(sql.OpenWithProfiler(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dsc.Open(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { dsc := ... db, err := openDatabase(dsc, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> db.Close() ... }</code> </pre> <br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Mit dem vorgeschlagenen Paket können Sie die Interaktionsmöglichkeiten mit der Datenbank erweitern und unnötige Details verbergen.  Auf diese Weise können Sie die Qualität des Codes verbessern und ihn trotz der zunehmenden Komplexität der Anwendung lose und transparent verbinden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445908/">https://habr.com/ru/post/de445908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445896/index.html">Warum Budget-3D-Scanner nicht für professionelle Aufgaben geeignet sind</a></li>
<li><a href="../de445898/index.html">Über neue Ideen, enge Ansichten und Mundpropaganda</a></li>
<li><a href="../de445900/index.html">So halten Sie erhöhten Systemlasten stand: Sprechen Sie über umfangreiche Vorbereitungen für den Black Friday</a></li>
<li><a href="../de445904/index.html">Arten von Unendlichkeiten und Hirnstamm</a></li>
<li><a href="../de445906/index.html">Iss kein Aspirin</a></li>
<li><a href="../de445910/index.html">Wie wir uns mit EF 6 MSSQL und PostgresSQL angefreundet haben</a></li>
<li><a href="../de445912/index.html">Hallo Habr, wir sind Advantech</a></li>
<li><a href="../de445914/index.html">Ist Docker ein Spielzeug oder nicht? Oder ist es wirklich so?</a></li>
<li><a href="../de445918/index.html">20 Jahre RollerCoaster Tycoon: Ein Interview mit dem Schöpfer des Spiels</a></li>
<li><a href="../de445920/index.html">Live: Wie Sie die iOS-Entwicklung in großen Teams eindämmen können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>