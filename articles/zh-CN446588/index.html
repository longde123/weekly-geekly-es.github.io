<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎲 ↪️ 🐣 检查Roslyn源代码 🥒 🎿 🍐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有时，我们返回到先前使用PVS-Studio检查过的项目，这些结果在各篇文章中都有介绍。 有两个原因使这些卷土重来令我们兴奋。 首先，有机会评估我们的分析仪的进度。 其次，监视项目作者对我们的文章和错误报告的反馈，这些错误通常是我们提供给他们的。 当然，没有我们的参与就可以纠正错误。 但是，当我们的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>检查Roslyn源代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio VS罗斯林"></div><br> 有时，我们返回到先前使用PVS-Studio检查过的项目，这些结果在各篇文章中都有介绍。 有两个原因使这些卷土重来令我们兴奋。 首先，有机会评估我们的分析仪的进度。 其次，监视项目作者对我们的文章和错误报告的反馈，这些错误通常是我们提供给他们的。 当然，没有我们的参与就可以纠正错误。 但是，当我们的努力有助于使一个项目变得更好时，总是很高兴。 罗斯林也不例外。 关于此项目检查的上一篇文章可追溯到2015年12月23日。考虑到自那时以来我们的分析仪所取得的进展，这已经是相当长的时间了。 由于PVS-Studio分析仪的C＃核心基于Roslyn，它使我们对该项目产生了更多的兴趣。 因此，我们对这个项目的代码质量非常满意。 现在，让我们再次进行测试，找出PVS-Studio能够找到的一些新的有趣的问题（但希望没有什么大的问题）。 <br><a name="habracut"></a><br> 我们的许多读者可能都非常了解Roslyn（或.NET编译器平台）。 简而言之，它是一组开源编译器和一个API，用于Microsoft的C＃和Visual Basic .NET语言的代码分析。 该项目的源代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 我将不对该平台进行详细描述，我建议所有感兴趣的读者阅读我的同事Sergey Vasiliev的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roslyn的介绍及其在程序开发中的用途</a> ”。 从本文中，您不仅可以了解罗斯林架构的功能，还可以了解我们如何使用该平台。 <br><br> 正如我之前提到的，距我的同事Andrey Karpov写了有关Roslyn支票的最新文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">New Year PVS-Studio 6.00 Release：Scaning Roslyn</a> ”已经3年多了。 从那时起，C＃PVS-Studio分析仪具有许多新功能。 实际上，Andrey的文章只是一个测试案例，因为那时C＃分析器才刚刚添加到PVS-Studio中。 尽管如此，我们还是设法检测出Roslyn项目中的错误，这肯定是高质量的。 那么，到目前为止，C＃代码分析器中发生了哪些变化，这将使我们能够进行更深入的分析？ <br><br> 从那时起，核心和基础设施都在发展。 我们增加了对Visual Studio 2017和Roslyn 2.0的支持，以及与MSBuild的深度集成。 我的同事Paul Eremeev的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在PVS-Studio中支持Visual Studio 2017和Roslyn 2.0：有时似乎不容易使用现成的解决方案</a> ”，描述了我们与MSBuild集成的方法以及做出此决定的原因。 <br><br> 目前，我们正在以与最初支持Visual Studio 2017相同的方式，积极向Roslyn 3.0迁移。它要求使用我们自己的工具集，该工具集包含在PVS-Studio发行版中，是一个“存根”，它是空的MSBuild .exe文件。 尽管它看起来像一个“拐杖”（由于库的可移植性很低，MSBuild API对于在第三方项目中重用不是很友好），但是这种方法已经帮助我们相对无缝地克服了Visual Studio方面的多个Roslyn更新2017年。到目前为止，它一直在帮助（即使有一些挑战）通过Visual Studio 2019更新，并为具有较旧MSBuild版本的系统保持完全的向后兼容性和性能。 <br><br> 分析仪核心也进行了许多改进。 主要功能之一是完整的过程间分析，其中要考虑输入和输出方法的值，评估（取决于这些参数）执行分支和返回点的可达性。 <br><br> 我们正在完成监视方法内部参数（例如，潜在的危险引用）以及保存其自动注释的任务。 对于使用数据流机制的诊断，这将考虑到在方法中传递参数时发生的危险情况。 在此之前，在分析此类危险场所时，不会生成警告，因为我们无法知道这种方法中所有可能的输入值。 现在我们可以检测到危险了，因为在所有调用此方法的地方，都将考虑这些输入参数。 <br><br> 注意：您可以在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio代码分析器中用于查找错误和潜在漏洞的技术</a> ”中了解基本的分析器机制，例如数据流和其他机制。 <br><br>  PVS-Studio C＃中的过程间分析不受输入参数和深度的限制。 唯一的限制是类中的虚方法，可以进行继承以及进行递归（进入递归操作时，分析会因重复调用已求值的方法而停止，从而停止分析）。 这样，假定递归的返回值未知，则将最终评估递归方法本身。 <br><br>  C＃分析器中的另一个重要新功能已经考虑到可能对空指针的取消引用。 在此之前，分析器抱怨可能存在null引用异常，并确保在所有执行分支中变量值将为null。 当然，在某些情况下这是错误的，这就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>诊断程序以前曾调用潜在的空引用的原因。 <br><br> 现在，分析器已经意识到以下事实：在执行分支之一中该变量可能为null（例如，在特定的<i>if</i>条件下）。 如果发现未检查就访问了这样的变量，它将发出V3080警告，但它的确定性要低于所有分支中都为null的警告。 与改进的过程间分析一起，这种机制还允许找到很难检测到的错误。 这是一个示例-想象一长串方法调用，您可能不熟悉其中的最后一个。 在某些情况下，它在<i>catch</i>块中返回null，但是您并没有受到保护，因为您还不知道。 在这种情况下，分析器仅在准确看到空分配时才抱怨。 在我们看来，它在质量上将我们的方法与C＃8.0的诸如可为空的类型引用之类的功能区分开来，实际上，它仅限于为每个方法设置是否为null的检查。 但是，我们建议您采取另一种方法-仅在真正可能发生空值的地方执行检查，而我们的分析仪现在可以搜索这种情况。 <br><br> 因此，让我们不要将要点拖延太久，而要去责备一下-分析Roslyn检查的结果。 首先，让我们考虑由于上述功能而发现的错误。 总而言之，这次Roslyn代码有很多警告。 我认为这与该平台的发展非常积极有关（此时，代码库大约为277万行（不包括空白）），并且我们没有对此项目进行长时间的分析。 但是，没有那么多关键错误，而本文中最关注它们。 像往常一样，我从支票中排除了测试，罗斯林中有很多测试。 <br><br> 我将以中等确定性级别的V3080错误开始，在该错误中，分析仪通过空引用检测到了可能的访问，但并非在所有可能的情况下（代码分支）都已检测到该访问。 <br><br>  <b>可能的空取消引用-中</b> <br><br>  V3080可能为空的取消引用。 考虑检查“当前”。  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br> 让我们考虑方法<i>GetNode</i> 。 分析器建议在<i>while</i>块的情况下可以通过空引用进行访问<i>。</i> 该变量在<i>while</i>块的主体中​​分配了一个值，这是<i>AsNode</i>方法的结果。 在某些情况下，该值将为<i>null</i> 。 实际的过程间分析的一个很好的例子。 <br><br> 现在让我们考虑类似的情况，其中通过两个方法调用执行过程间分析。 <br><br>  V3080可能为空的取消引用。 考虑检查“目录”。  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  <i>ExpandFileNamePattern</i>方法主体中的<i>目录</i>变量从方法<i>GetDirectoryName（字符串）</i>获取值。 依次返回重载方法<i>GetDirectoryName（字符串，布尔值）</i>的结果，该方法的值可以为<i>null</i> 。 由于使用变量<i>目录时</i>没有对方法<i>ExpandFileNamePattern</i>主体中的null进行初步检查-我们可以宣布分析器在发出警告时是正确的。 这是一种潜在的不安全构造。 <br><br> 为单行代码发布的另一个带有V3080错误的代码片段，更确切地说，有两个错误。 这里不需要过程间分析。 <br><br>  V3080可能为空的取消引用。 考虑检查“ spanStartLocation”。  TestWorkspace.cs 574 <br><br>  V3080可能为空的取消引用。 考虑检查“ spanEndLocationExclusive”。  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br> 变量<i>spanStartLocation</i>和<i>spanEndLocationExclusive</i>具有可为<i>null的int</i>类型，并由<i>null</i>初始化。 沿着代码进一步可以为它们分配值，但只能在某些条件下。 在某些情况下，它们的值保持为<i>null</i> 。 之后，可以通过引用访问这些变量，而无需对分析器进行初步检查是否为空。 <br><br>  Roslyn代码包含很多这样的错误，超过100个。这些错误的模式通常是相同的。 有某种通用方法，可能会返回<i>null</i> 。 此方法的结果在许多地方使用，有时通过数十个中间方法调用或其他检查使用。 重要的是要理解这些错误不是致命的，但它们可能导致空引用访问。 虽然检测此类错误非常具有挑战性。 这就是为什么在某些情况下应该考虑代码重构的原因，在这种情况下，如果返回<i>null</i> ，则该方法将引发异常。 否则，您只能通过常规检查来保护代码，这很累人，有时甚至不可靠。 无论如何，很明显，每个特定案例都需要基于项目规范的解决方案。 <br><br> 注意事项 碰巧的是，当方法返回<i>null</i>并且没有实际错误时，在给定的点上没有此类情况（输入数据）。 但是，这样的代码仍然不可靠，因为在引入某些代码更改时所有内容都可能更改。 <br><br> 为了删除<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>主题，让我们看一下高确定性级别的明显错误，当通过空引用进行访问是最有可能甚至不可避免的情况时。 <br><br>  <b>可能的空取消引用-高</b> <br><br>  V3080可能为空的取消引用。 考虑检查“ collectionType.Type”。  137第137章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br> 由于条件中的拼写错误（使用<i>&amp;&amp;</i>代替了运算符<i>||</i> ），因此代码的工作方式与预期的不同，并且对<i>collectionType.Type</i>变量的访问将在为<i>null</i>时执行。 该情况应更正如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br> 顺便说一句，事情可能会以另一种方式展开：在条件的第一部分，运算符<i>==</i>和<i>！=</i>被弄乱了<i>。</i> 然后正确的代码将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br> 此版本的代码逻辑性较差，但也可以纠正错误。 最终的解决方案由项目的作者决定。 <br><br> 另一个类似的错误。 <br><br>  V3080可能为空的取消引用。 考虑检查“动作”。 文字检视视窗_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br> 生成异常消息时出错。 接下来是尝试通过<i>action</i>变量（已知为<i>null）</i>访问<i>action.DisplayText</i>属性。 <br><br> 这是高级别的最后一个V3080错误。 <br><br>  V3080可能为空的取消引用。 考虑检查“类型”。  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br> 该方法很小，因此我完全引用它。  <i>返回</i>块中的条件不正确。 在某些情况下，访问<i>type.FullName</i>时可能会发生异常。 我将使用括号将其弄清楚（它们不会改变行为）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br> 根据操作优先级，代码将完全像这样工作。 如果<i>类型</i>变量为<i>null</i> ，我们将进行else-check，其中将使用<i>类型</i> null引用，并检查变量<i>targetTypeName</i>是否为<i>null</i> 。 代码可能是固定的，例如，如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br> 我认为，足够检查V3080错误。 现在是时候看看PVS-Studio分析仪设法找到的其他有趣的东西了。 <br><br>  <b>错字</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3005</a>将'SourceCodeKind'变量分配给它自己。  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br> 由于变量命名失败，因此在<i>DynamicFileInfo</i>类的构造函数中输入了错误。 为<i>SourceCodeKind</i>字段分配了自己的值，而不是使用参数<i>sourceCodeKind</i> 。 为了最大程度地减少此类错误的可能性，我们建议您在这种情况下对参数名称使用下划线前缀。 这是该代码的更正版本的示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>疏忽大意</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3006</a>已创建对象， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">但未使用</a>该对象。  'throw'关键字可能丢失：抛出新的InvalidOperationException（FOO）。  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br> 在一定条件下，析构函数必须抛出异常，但是仅创建异常对象时不会发生。  <i>throw</i>关键字丢失。 这是代码的更正版本： <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  C＃中的析构函数以及从中引发异常的问题是另一个讨论的主题，这不在本文的讨论范围之内。 <br><br>  <b>当结果不重要时</b> <br><br> 在所有情况下均获得相同值的方法触发了一定数量的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a>警告。 在某些情况下，它可能不是很关键，或者根本没有在调用代码中检查返回值。 我跳过了这样的警告。 但是一些代码片段似乎令人怀疑。 这是其中之一： <br><br>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <i>TryExecuteCommand</i>方法<i>只</i>返回<i>true</i> 。 这样做，在调用代码中，某些检查涉及返回的值。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br> 很难确切地说出这种行为在多大程度上是危险的。 但是，如果不需要结果，则可能应将返回值的类型更改为void，并且应在调用方法中进行一些小的编辑。 这将使代码更具可读性和安全性。 <br><br> 类似的分析仪警告： <br><br><ul><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 第138章 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 第164章 </li><li>  V3009奇怪的是，此方法总是返回一个相同的'false'值。  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 物件清单.cs 173 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 物件清单.cs 249 </li></ul><br>  <b>检查错了事</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a>可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“值”，“ valueToSerialize”。 漫游VisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  <i>值</i>变量<i>强制</i>转换为<i>NamingStylePreferences</i>类型。 问题出在随后的检查中。 即使<i>value</i>变量为非null，也不能保证类型转换成功并且<i>valueToSerialize</i>不包含<i>null</i> 。 可能<i>引发</i>异常<i>NullReferenceException</i> 。 该代码需要按以下方式更正： <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br> 另一个类似的错误： <br><br>  V3019可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“ columnState”，“ columnState2”。  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  <i>columnState</i>变量<i>强制</i>转换为<i>ColumnState2</i>类型。 但是，不会进一步检查操作结果（即变量<i>columnState2）</i>是否为<i>null</i> 。 而是使用条件<i>空运</i>算符检查<i>columnState</i>变量。 为什么此代码很危险？ 就像在前面的示例中一样，使用<i>as</i>运算符的转换可能会失败，并且变量将为<i>null</i> ，这将导致异常。 顺便说一句，错字可能归咎于这里。 看一下<i>if</i>块中的条件。 <br><br> 或许，作者想编写<i>columnState2？.Name</i>而不是<i>columnState？.Name</i> 。 考虑到错误的变量名称<i>columnState</i>和<i>columnState2</i> ，这很有可能<i>。</i> <br><br>  <b>冗余检查</b> <br><br> 对于非关键性但与冗余检查有关的潜在不安全构造，发出了大量警告（超过100个）。 例如，这就是其中之一。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式'navInfo == null'始终为false。  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br> 可能这里没有实际的错误。 这是演示“过程间分析+数据流分析”协同工作的一个很好的理由。 分析器建议第二次检查<i>navInfo == null</i>是多余的。 实际上，在此之前，将从方法<i>libraryService.NavInfoFactory.CreateForProject</i>获得分配给<i>navInfo</i>的值，该方法将构造并返回<i>NavInfo</i>类的新对象。 它不可能返回<i>null</i> 。 出现问题了，分析器为什么不为第一次检查<i>navInfo == null</i>发出警告？ 有一些原因。 首先，如果<i>符号</i>变量为<i>null</i> ，则<i>navInfo</i>值也将保持为空引用。 其次，即使<i>navInfo</i>从方法<i>ibraryService.NavInfoFactory.CreateForSymbol</i>获取值，该值也可以为<i>null</i> 。 因此，确实需要第一次检查<i>navInfo == null</i> 。 <br><br>  <b>检查不足</b> <br><br> 现在与上面讨论的情况相反。 该代码触发了多个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3042</a>警告，其中可以通过空引用进行访问。 甚至一两个小支票都可以解决所有问题。 <br><br> 让我们考虑另一个有趣的代码片段，其中有两个这样的错误。 <br><br>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“接收器”对象Binder_Expressions.cs 7770的成员 <br><br>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“接收器”对象Binder_Expressions.cs 7776的成员 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  <i>接收器</i>变量可以为null。 代码的作者对此很了解，因为他在<i>if</i>块的条件下使用条件<i>null</i>运算符来访问<i>接收者？</i> 。 此外，无需任何检查就可以使用<i>接收器</i>变量来访问<i>receive.Type</i> ， <i>receiver.Syntax</i>和<i>receiver.HasErrors</i> 。 这些错误必须纠正： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br> 我们还必须确保构造函数支持为其参数获取<i>空</i>值，否则我们需要执行其他重构。 <br><br> 其他类似错误： <br><br><ul><li>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ containsType”对象的成员SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042可能为NullReferenceException。  '？。' 和“。”  349运算符用于访问“表达式”对象ExpressionSyntaxExtensions.cs的成员 </li><li>  V3042可能为NullReferenceException。  '？。' 和“。”  349运算符用于访问“表达式”对象ExpressionSyntaxExtensions.cs的成员 </li></ul><br>  <b>条件错误</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3057</a> “子字符串”功能可以接收“ -1”值，而预期为非负值。 检查第二个参数。  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br> 如果<i>冒号</i>变量为0（根据代码中的条件很好），则<i>Substring</i>方法将引发异常。 这是必须解决的： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>可能的错字</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3065</a>方法的内部未使用参数't2'。  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  lambda表达式接受两个参数：t1和t2。 但是，仅使用t1。 考虑到在使用具有此类名称的变量时犯错有多容易，这看起来很可疑。 <br><br>  <b>疏忽大意</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a>事件'TagsChanged'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  <i>TagsChanged</i>事件是以不安全的方式调用的。 在检查<i>null</i>和调用事件之间，可能有人取消订阅该事件，然后将引发异常。 此外，在调用事件之前，在<i>if</i>块的主体中​​执行其他操作。 我将此错误称为“疏忽”，因为在其他地方，此事件的处理方式如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br> 使用附加的<i>处理程序</i>变量可防止出现此问题。 在方法<i>OnTextBufferChanged中，</i>必须进行编辑才能安全地处理该事件。 <br><br>  <b>相交范围</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3092</a>在条件表达式中可能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存在</a>范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br> 为了更好地理解，让我重写此代码，以其实际值更改常量名称： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br> 可能没有真正的错误，但是条件看起来很奇怪。 它的第二部分（ <i>否则为</i> ）将仅在2147483648 +1到4294967295的范围内执行。 <br><br> 另外一些类似的警告： <br><br><ul><li>  V3092在条件表达式中可能存在范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。 本地重写器_Literal.cs 109 </li><li>  V3092在条件表达式中可能存在范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>有关检查空值（或缺少空值）的更多信息</b> <br><br> 在使用变量后立即检查变量是否为null的几个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a>错误。 首先是模棱两可的，让我们考虑一下代码。 <br><br>  V3095在对null进行验证之前，已使用'displayName'对象。 检查行：498，503。FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br> 假定引用<i>displayName</i>可以为null。 为此，执行了<i>Debug.Assert</i>检查。 目前尚不清楚为什么使用字符串后会出现这种情况。 还必须考虑到，对于与Debug不同的配置，编译器将完全删除<i>Debug.Assert</i> <i>。</i> 这是否意味着只有Debug才能获取空引用？ 如果不是这样，例如，为什么作者要检查<i>string.IsNullOrEmpty（string）</i> 。 这是代码作者的问题。 <br><br> 以下错误更加明显。 <br><br>  V3095在验证是否为null之前，已使用'scriptArgsOpt'对象。 检查行：321、325。CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br> 我认为这段代码不需要任何解释。 让我给您固定版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br> 在Roslyn代码中，还有15个类似的错误： <br><br><ul><li>  V3095在对null进行验证之前，已使用'LocalFunctions'对象。 检查行：289、317。ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095在对null进行验证之前，已使用'resolution.OverloadResolutionResult'对象。 检查行：579、588。Binder_Invocation.cs 579 </li><li>  V3095在对null进行验证之前，已使用'resolution.MethodGroup'对象。 检查行：592、621。Binder_Invocation.cs 592 </li><li>  V3095在对null进行验证之前，已使用'touchedFilesLogger'对象。 检查行：111，126。CSharpCompiler.cs 111 </li><li>  V3095在对null进行验证之前，已使用'newExceptionRegionsOpt'对象。 检查行：736、743。AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095在验证是否为null之前，已使用'symbol'对象。 检查行：422、427。AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095在验证空值之前使用了'_state.BaseTypeOrInterfaceOpt'对象。 检查行：132，140。AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095在对null进行验证之前，已使用'element'对象。 检查线：232，233。ProjectUtil.cs 232 </li><li>  V3095在验证是否为null之前，已使用“语言”对象。 检查行：22，28。ExportCodeCleanupProvider.cs 22 </li><li>  V3095在对null进行验证之前，已使用'memberType'对象。 检查行：183，184。SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095在对null进行验证之前，已使用'validTypeDeclarations'对象。 检查行：223、228。SyntaxTreeExtensions.cs 223 </li><li>  V3095在验证是否为null之前，已使用“文本”对象。 检查行：376、385。MSBuildWorkspace.cs 376 </li><li>  V3095在对null进行验证之前，已使用'nameOrMemberAccessExpression'对象。 检查行：206，223。CSharpGenerateTypeService.cs 206 </li><li>  V3095在对null进行验证之前，已使用'simpleName'对象。 检查行：83，85。CSharpGenerateMethodService.cs 83 </li><li>  V3095在对null进行验证之前，已使用了'option'对象。 检查行：23，28。OptionKey.cs 23 </li></ul><br> 让我们考虑一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3105</a>错误。 在此，在初始化变量时使用条件<i>空运</i>算符，但是在不检查<i>null的</i>情况下使用该变量。 <br><br> 两个警告指示以下错误： <br><br>  V3105通过空条件运算符分配了'documentId'变量后，就使用了该变量。  NullReferenceException是可能的。  138 CodeLensReferencesService.cs <br><br>  V3105通过空条件运算符分配了'documentId'变量后，就使用了该变量。  NullReferenceException是可能的。  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br> 可以使用<i>null</i>初始化<i>documentId</i>变量。 结果，创建对象<i>ReferenceLocationDescriptor</i>将导致引发异常。 该代码必须是固定的： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br> 开发人员还应考虑传递给构造函数的变量为<i>null</i>的可能性<i>。</i> <br><br> 代码中的其他类似错误： <br><br><ul><li>  V3105通过空条件运算符分配了'symbol'变量后，即可使用。  NullReferenceException是可能的。  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105通过空条件运算符分配了'symbol'变量后，即可使用。  NullReferenceException是可能的。  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>优先事项和括号</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3123</a>也许'？：'运算符的工作方式与预期的不同。 在此条件下，它的优先级低于其他运营商的优先级。  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br> 返回块中的条件未按照开发人员的预期进行评估。 假定第一个条件是<i>_kind == other._kin</i> d，（这就是为什么在此条件之后会有换行符），然后<i>将按顺序</i>对带有运算符“ <i>？</i> ”的条件块进行评估。 实际上，第一个条件是<i>_kind == other._kind &amp;&amp;（_oldNode == null）</i> 。 这是由于以下事实：运算符<i>&amp;&amp;</i>的优先级高于运算符“ <i>？</i> ”。 要解决此问题，开发人员应该使用括号中所有运算符“ <i>？</i> ”的表达式： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br> 到此结束我对发现的错误的描述。 <br><br>  <b>结论</b> <br><br> 尽管我设法找到了很多错误，但就罗斯林项目代码的大小（2,770,000行）而言，它并不过分。 正如Andrey在上一篇文章中所写，我也准备承认该项目的高质量。 <br><br> 我想指出的是，这种偶尔的代码检查与静态分析的方法无关，并且几乎无济于事。 静态分析应定期进行，而不应逐案进行。 这样，许多错误将在最早的阶段得到纠正，因此修复这些错误的成本将减少十倍。 请在本小<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">笔记</a>中更详细地阐述这个想法，请检查一下。 <br><br> 您可以检查自己在该项目中还是在另一个项目中的一些错误。 为此，您只需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>并试用我们的分析仪。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446588/">https://habr.com/ru/post/zh-CN446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446572/index.html">Editor.js是一款出色的编辑器，可以将源代码保存为JSON格式</a></li>
<li><a href="../zh-CN446576/index.html">进口替代品，或俄罗斯直升机如何做错了事</a></li>
<li><a href="../zh-CN446578/index.html">基于明信片的编程语言</a></li>
<li><a href="../zh-CN446582/index.html">关于养蜂养蜂的思考</a></li>
<li><a href="../zh-CN446586/index.html">通过DHCP从FreeRadius进行网络设置</a></li>
<li><a href="../zh-CN446590/index.html">Java 12将提供39种新功能</a></li>
<li><a href="../zh-CN446592/index.html">检查Roslyn的源代码</a></li>
<li><a href="../zh-CN446598/index.html">重新创建CRT字体</a></li>
<li><a href="../zh-CN446602/index.html">通过场效应晶体管的最大直流电流</a></li>
<li><a href="../zh-CN446604/index.html">ESET：新的OceanLotus Cyber​​group后门交付方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>