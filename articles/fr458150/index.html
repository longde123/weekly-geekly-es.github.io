<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÑ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üíì Microoptimisation de judas dans les compilateurs C ++ et C # üö£üèº ü§∑üèª üí•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä l'√©cole, lorsque nous avons r√©solu des √©quations ou consid√©r√© des formules, nous avons essay√© de les r√©duire d'abord plusieurs fois, par exemple, Z ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microoptimisation de judas dans les compilateurs C ++ et C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458150/"><p> √Ä l'√©cole, lorsque nous avons r√©solu des √©quations ou consid√©r√© des formules, nous avons essay√© de les r√©duire d'abord plusieurs fois, par exemple, <code>Z = X - (Y + X)</code> r√©duit √† <code>Z = -Y</code> .  Dans les compilateurs modernes, il s'agit d'un sous-ensemble des optimisations dites de judas, dans lesquelles, en gros, un ensemble de mod√®les nous r√©duisons les expressions, rempla√ßons les instructions par des instructions plus rapides pour un processeur particulier, etc.  Dans cet article, j'ai compil√© une collection de ces optimisations trouv√©es dans les sources LLVM, GCC et .NET Core (CoreCLR). </p><br><p>  Commen√ßons par des exemples simples: </p><br><pre> <code class="cpp hljs"> X * <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X -X * -Y =&gt; X * Y -(X - Y) =&gt; Y - XX * Z - Y * Z =&gt; Z * (X - Y)</code> </pre> <br><p>  v√©rifiez le dernier exemple en C ++ et en C #: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * z - y * z; <span class="hljs-comment"><span class="hljs-comment">// =&gt; z * (x - y) }</span></span></code> </pre> <br><p>  et regardez l'assembleur de Clang (LLVM), GCC, MSVC et .NET Core: <br><img src="https://habrastorage.org/webt/up/xl/zo/upxlzopwz17gkq290kycswi4_qq.png"></p><a name="habracut"></a><br><p>  Les trois compilateurs C ++ (GCC, Clang et MSVC) ont r√©duit une multiplication (nous ne voyons qu'une seule instruction <code>imul</code> ).  C # ne l'a pas fait avec RyuJIT, mais ne vous pr√©cipitez pas pour le gronder, c'est juste que cette classe d'optimisations est disponible dans une composition limit√©e l√†-bas.  Pour vous faire comprendre, l'impl√©mentation de l'int√©gralit√© de la transformation InstCombine dans LLVM prend plus de 30k lignes de code (+ 20k lignes sur DAGCombiner.cpp), de plus, cette transformation entra√Æne souvent une longue compilation.  <a href="">Soit dit en passant, le site</a> responsable de cette optimisation est l√†.  GCC a une DSL sp√©ciale qui d√©crit le piphole d'optimisation, <a href="">voici un extrait</a> ). </p><br><p>  J'ai d√©cid√©, pour les besoins de l'article, d'essayer de mettre en ≈ìuvre cette optimisation en C # JIT (tenir ma bi√®re): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/14c/c65/69214cc65fd41d79f8d53caf4021c9af.png" alt="image"></p><br><p>  Le commit complet peut √™tre vu ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EgorBo / coreclr</a> .  V√©rifions maintenant mon am√©lioration (dans Visual Studio 2019 + Disasmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/e77/de9/e53e77de91d647f78f021d10fb57a8c9.png" alt="image"></p><br><p>  √áa marche!  <code>lea</code> + <code>imul</code> au lieu d' <code>imul</code> , <code>imul</code> et <code>add</code> . </p><br><p>  Revenons √† C ++ et suivons cette optimisation dans Clang.  Pour ce faire, demandez √† clang de nous donner l'IR LLVM initial via <code>-emit-llvm -g0</code> , puis de le donner √† LLVM √† l'optimiseur, en utilisant les <code>-O2 -print-before-all -print-after-all</code> afin de capturer le moment exact de la transformation supprime la multiplication de l'ensemble <code>-O2</code> (tout cela peut √™tre vu sur la merveilleuse ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">godbolt.org</a> ): </p><br><pre> <code class="plaintext hljs">; *** IR Dump Before Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = mul nsw i32 %0, %2 %5 = mul nsw i32 %1, %2 %6 = sub nsw i32 %4, %5 ret i32 %6 } ; *** IR Dump After Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = sub i32 %0, %1 %5 = mul i32 %4, %2 ret i32 %5 }</code> </pre> <br><p>  Vous pouvez √©galement vous amuser sur godbolt avec les outils LLVM - opt (optimiseur) et llc (pour compiler LLVM IR en asm): </p><br><p><img src="https://habrastorage.org/webt/yr/x-/dw/yrx-dw9mx9tqbrp97ts3smndy0i.png"></p><br><p>  Retour aux exemples.  J'ai trouv√© ce tr√®s bel exemple dans GCC. </p><br><pre> <code class="cpp hljs">X == C - X =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> C is odd</code> </pre> <br><p>  Et c'est vrai: si <code></code> (constant, litt√©ral) est pair alors, par exemple, vous pouvez √©crire <code>4 == 8 - 4</code> .  Mais si au lieu de 8 vous en √©crivez un impair, alors vous ne pouvez pas trouver un tel <code>X</code> pour que l'√©galit√© soit remplie: </p><br><p><img src="https://habrastorage.org/webt/lt/qn/pq/ltqnpqgmnbcyszoj0dv7nawouk8.png"></p><br><h3 id="ieee754-nanosit-otvetnyy-udar">  IEEE754 contre-attaque </h3><br><p>  De nombreuses optimisations fonctionnent pour diff√©rents types de donn√©es, par exemple, <code>byte</code> , <code>unsigned</code> , <code>unsigned</code> , <code>float</code> , <code>double</code> .  Avec ce dernier, les choses ne sont pas si simples et les optimisations sont g√©r√©es par la sp√©cification IEEE754, qui deviendra folle si vous r√©duisez <code>A - B - A</code> en <code>-B</code> ou <code>(A * B) * C</code> r√©organisant en <code>A * (B * C)</code> t. √†.  les op√©rations ne sont pas associatives.  Mais il y a un mode sp√©cial dans les compilateurs modernes qui vous permet de n√©gliger les valeurs de sp√©cification et de limite (NaN, + -Inf, + -0.0) dans de tels cas et d'effectuer des optimisations en toute s√©curit√© - c'est Fast Math (ma demande de PR pour ajouter un tel mode √† C # peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) </p><br><p>  Comme vous pouvez le voir dans <code>-ffast-math</code> il n'y a plus deux <code>vsubss</code> : <br><img src="https://habrastorage.org/webt/s3/et/-9/s3et-9dc6vml6f-ous27z-1xlhm.png"></p><br><p>  En plus des expressions, les optimiseurs prennent √©galement en compte le jonglage avec les fonctions math√©matiques de <code>math.h</code> , par exemple, le produit des modules du nombre X est √©gal au produit du nombre X: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) =&gt; X * X</code> </pre> <br><p>  La racine carr√©e est toujours positive: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; Y =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Y is negative. <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Pourquoi calculer la racine, s'il est possible au stade de la compilation de calculer le carr√© de la constante √† droite?: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &gt; C =&gt; X &gt; C * C</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/988/d7e/cbd/988d7ecbd50be253a6b3314760ed3348.png" alt="image"></p><br><p>  Plus d'op√©rations root: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) == <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; X == Y <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) =&gt; X <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X * Y) logN(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) =&gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>*logN(X)</code> </pre> <br><p>  Un peu plus de math√©matiques √† l'√©cole: </p><br><pre> <code class="cpp hljs">expN(X) * expN(Y) -&gt; expN(X + Y)</code> </pre> <br><p>  Et mon optimisation pr√©f√©r√©e: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(X) / <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(X) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(X)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/93a/875/4dd/93a8754dd42b07497f6a164bb60172af.png" alt="image"></p><br><p>  Beaucoup d'op√©rations ennuyeuses et bool√©ennes: </p><br><pre> <code class="cpp hljs">((a ^ b) | a) -&gt; (a | b) (a &amp; ~b) | (a ^ b) --&gt; a ^ b ((a ^ b) | a) -&gt; (a | b) (X &amp; ~Y) |^+ (~X &amp; Y) -&gt; X ^ Y A - (A &amp; B) into ~B &amp; A X &lt;= Y - <span class="hljs-number"><span class="hljs-number">1</span></span> equals to X &lt; Y A &lt; B || A &gt;= B -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...   !</code> </pre> <br><h3 id="nizkourovnevye-optimizacii">  Optimisations de bas niveau </h3><br><p>  Il existe un ensemble d'optimisation qui, √† premi√®re vue, n'a pas de sens avec t.z.  math√©maticiens, mais sont plus amicaux √† repasser. </p><br><pre> <code class="cpp hljs">X / <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p>  remplacer la division par la multiplication: </p><br><p><img src="https://habrastorage.org/webt/1n/nz/d2/1nnzd2msn5lxzxlx5t3-hr680cc.png"></p><br><p>  Le fonctionnement de la multiplication de flotte pr√©sente g√©n√©ralement de meilleures caract√©ristiques de latence / d√©bit que la division.  Par exemple, voici les options pour Intel Haswell: <br><img src="https://habrastorage.org/webt/i1/ej/l_/i1ejl__p9hfkduty-cn4vq0vzvu.png"></p><br><p>  En mode math√©matique non rapide, elle ne peut √™tre utilis√©e que si la constante est une puissance de deux. <br>  Au fait, j'ai r√©cemment essay√© d'ajouter une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telle</a> optimisation en C #.  C'est-√†-dire  si, par exemple, vous devez ouvrir un fichier avec un mod√®le 3D et r√©duire toutes les coordonn√©es de 10 fois, alors * 0,1 g√©rera cette vitesse de 20 √† 100% plus rapidement, ce qui peut √™tre important. </p><br><p>  La m√™me justification pour: </p><br><pre> <code class="cpp hljs">X * <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X + X</code> </pre> <br><p>  Comparer avec z√©ro ( <code>test</code> ) est meilleur que comparer avec l'unit√© ( <code>cmp</code> ) - mon PR pour plus de d√©tails est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / coreclr # 25458</a> : </p><br><pre> <code class="plaintext hljs">X &gt;= 1 =&gt; X &gt; 0 X &lt; 1 =&gt; X &lt;= 0 X &lt;= -1 =&gt; X &gt;= 0 X &gt; -1 =&gt; X &gt;= 0</code> </pre> <br><p>  Et comment aimez-vous cela: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.25</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; X * X ; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">mul </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=&gt; X * X * X ; <span class="hljs-number"><span class="hljs-number">2</span></span> mul</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/ag/lm/hdaglmbx5f7zfibbpgzdre0swjo.png"></p><br><p>  Que pensez-vous, combien d'op√©rations de multiplication avez-vous besoin pour compter le <code>mod(X, 4)</code> ou <code>X * X * X * X</code> ? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f5d/118/3c0/f5d1183c005a7f72b6fbabdd18995d7e.png" alt="image"></p><br><p>  Deux!  Ainsi que pour le calcul du 3√®me degr√©, et dans le cas 4 nous n'utilisons qu'un seul registre <code>xmm0</code> . </p><br><p>  De nombreux processeurs prennent en charge une instruction sp√©ciale (FMA), qui vous permet d'effectuer la multiplication et l'addition √† la fois, tout en conservant la pr√©cision pendant la multiplication: </p><br><pre> <code class="cpp hljs">X * Y + Z =&gt; fmadd(X, Y, Z)</code> </pre> <br><p><img src="https://habrastorage.org/webt/jf/z5/nh/jfz5nh9fl6-wkx8cfmubntv7o4g.png"></p><br><p>  Deux autres de mes exemples pr√©f√©r√©s sont le pliage de certains algorithmes en une seule instruction (si le processeur le prend en charge): <br><img src="https://habrastorage.org/webt/qj/pv/ya/qjpvya5-s-itzzxubosjpnwonkc.png"></p><br><h3 id="lovushki-dlya-optimizaciy">  Pi√®ges d'optimisation </h3><br><p>  Je pense que tout le monde comprend que vous ne pouvez pas vous pr√©cipiter et r√©duire les expressions pour trois raisons: </p><br><ul><li>  Vous pouvez casser le code sur certaines valeurs limites, d√©bordements, effets secondaires cach√©s, etc ... Bugzilla LLVM contient de nombreux bogues InstCombine. </li><li>  Id√©alement, les optimisations devraient fonctionner ensemble dans une s√©quence sp√©cifique. </li><li>  L'expression ou des parties de celle-ci que vous souhaitez r√©duire peuvent √™tre utilis√©es ailleurs et leur r√©duction entra√Ænera une d√©gradation des performances. </li></ul><br><p>  Regardons simplement un exemple pour le dernier paragraphe (espionn√© dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Future Directions for Optimizing Compilers</a> ). </p><br><p>  Imaginez que nous ayons ce code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  nous devons faire trois op√©rations: <code>0 - a</code> , <code>0 - b</code> et <code>na + nb</code> .  Mais l'optimiseur pour nous r√©duit cela √† deux - <code>return -(a + b);</code>  : </p><br><pre> <code class="plaintext hljs">define dso_local i32 @_Z4Foo1ii(i32, i32) { %3 = add i32 %0, %1 ; a + b %4 = sub i32 0, %3 ; 0 - %3 ret i32 %4 }</code> </pre> <br><p>  Imaginez maintenant que nous devons √©crire des valeurs interm√©diaires <code>na</code> et <code>nb</code> dans des variables globales: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; x = na; y = nb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  L'optimiseur trouve toujours ce mod√®le et supprime les op√©rations inutiles (de son point de vue) <code>0 - a</code> et <code>0 - b</code> , mais en fait il s'av√®re qu'elles sont n√©cessaires!  nous √©crivons les r√©sultats de ces op√©rations "inutiles" dans des variables globales!  Cela conduit √† ce code: </p><br><pre> <code class="cpp hljs">define dso_local i32 @_Z4Foo2ii(i32, i32) { %<span class="hljs-number"><span class="hljs-number">3</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - a %<span class="hljs-number"><span class="hljs-number">4</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - b store i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, i32* @x, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, i32* @y, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; a + b %<span class="hljs-number"><span class="hljs-number">6</span></span> = sub i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - %<span class="hljs-number"><span class="hljs-number">5</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">6</span></span> }</code> </pre> <br><p>  Quatre op√©rations math√©matiques au lieu de trois!  Notre optimiseur nous a fait d√©faut et n'√©tait pas convaincu que les expressions interm√©diaires qu'il optimisait √©taient encore n√©cessaires √† quelqu'un.  Voyons maintenant la sortie de C # RuyJIT, dans laquelle il n'y a pas une telle optimisation intelligente: </p><br><p><img src="https://habrastorage.org/webt/fs/ar/jf/fsarjfwtbnpmp5hzbidevgo3eui.png"></p><br><p>  Trois op√©rations au lieu de quatre - C # s'est av√©r√© √™tre plus rapide que C ++ :-)!. </p><br><h3 id="a-nuzhny-li-takie-optimizacii">  De telles optimisations sont-elles n√©cessaires? </h3><br><p>  Vous ne savez jamais √† quoi ressemblera le code apr√®s que le compilateur contienne tout ce qu'il peut et fait un pliage constant, une copie de propagation, un CSE, etc.  - une image compl√®tement diff√©rente s'ouvrira pour lui.  LLVM IR et .NET IL ne sont pas li√©s √† un langage de programmation sp√©cifique, et vous ne pouvez pas √™tre s√ªr qu'un PL sp√©cifique / nouveau peut se traduire efficacement en IR.  Eh bien, pourquoi en parler si vous pouvez tester les performances d'InstCombine on et off sur une application sp√©cifique ;-).  Il est peu probable que ce soit une diff√©rence impressionnante, mais qui sait. </p><br><h3 id="a-chto-na-schet-c">  Et C #? </h3><br><p>  Comme je l'ai dit, les optimisations des expressions que nous avons examin√©es sont tr√®s probablement absentes en C #.  Mais quand je dis C #, je veux dire que le runtime le plus populaire est CoreCLR et RyuJIT.  Mais en plus de CoreCLR, il existe d'autres environnements d'ex√©cution, y compris ceux utilisant LLVM comme backend: Mono (voir mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tweet</a> ), Unity Burst, IL2CPP (via clang) et LILLC - ici, vous pouvez comparer en toute s√©curit√© les r√©sultats C ++ avec clang.  Les gars d'Unity r√©√©crivent m√™me le code C ++ interne en C # sans aucune perte de performances, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preuve</a> ! </p><br><p>  Voici quelques pipettes d'optimisation qui peuvent √™tre trouv√©es dans le fichier <code>morph.cpp</code> dans le code source <code>morph.cpp</code> des commentaires (il y en a clairement un peu plus): </p><br><pre> <code class="cpp hljs">*(&amp;X) =&gt; X X % <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X / <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X X % Y =&gt; X - (X / Y) * Y X ^ <span class="hljs-number"><span class="hljs-number">-1</span></span> =&gt; ~x X &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> X + <span class="hljs-number"><span class="hljs-number">1</span></span> == C2 =&gt; X == C2 - C1 ((X + C1) + C2) =&gt; (X + (C1 + C2)) ((X + C1) + (Y + C2)) =&gt; ((X + Y) + (C1 + C2))</code> </pre> <br><p>  Un peu plus peut √™tre trouv√© dans <code>lowering.cpp</code> (bas niveau), mais en g√©n√©ral RyuJIT perd √©videmment ici aux compilateurs C ++.  RyuJIT a des priorit√©s l√©g√®rement diff√©rentes - avant l'av√®nement de la compilation par niveaux, il devait fournir une vitesse de compilation acceptable, ce qu'il fait tr√®s bien contrairement aux compilateurs C ++ (rappelez-vous de la passe InstCombine de 30 lignes dans LLVM et lisez l'int√©ressant article en g√©n√©ral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" "Lamentations C ++ modernes"</a> ) et il est beaucoup plus utile de d√©velopper des optimisations dans le domaine de la d√©virtualisation des appels, l'√©limination de la boxe et des allocations (la m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">allocation de pile d'objets</a> ) - tout cela, √©videmment, est beaucoup plus important que de minimiser la division du sinus par le cosinus en tangente. </p><br><p>  Peut-√™tre avec l'av√®nement de la compilation par niveaux, avec le temps, de nombreuses nouvelles optimisations ne seront pas essentielles au temps de compilation pour le niveau 1 ou m√™me le niveau 2.  Peut-√™tre m√™me avec votre Add-in API et DSL - vous venez de lire cet article, Prathamesh Kulkarni y a ajout√© l'optimisation d'expression dans GCC en quelques lignes DSL: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">simplify</span></span> (<span class="hljs-name"><span class="hljs-name">plus</span></span> (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag_unsafe_math_optimizations</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>. { build_one_cst (<span class="hljs-name"><span class="hljs-name">TREE_TYPE</span></span> (@<span class="hljs-number"><span class="hljs-number">0</span></span>))<span class="hljs-comment"><span class="hljs-comment">; }))</span></span></code> </pre> <br><p>  pour cette expression d'un manuel de math√©matiques ;-): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) equals to <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3 id="poleznye-ssylki">  Liens utiles </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Orientations futures pour l'optimisation des compilateurs"</a> , Nuno P. Lopes et John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Comment LLVM optimise une fonction"</a> , John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"L'habilet√© surprenante des compilateurs modernes"</a> , Daniel Lemire </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Ajout de l'optimisation des judas √† GCC"</a> , Prathamesh Kulkarni </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"1. C ++, C # et Unity"</a> , Lucas Meijer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Modern" C ++ Lamentations "</a> , Aras Pranckeviƒçius </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Optimisations de judas correctes avec Vive"</a> , Nuno P. Lopes, David Menendez, Santosh Nagarakatte et John Regehr </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458150/">https://habr.com/ru/post/fr458150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458136/index.html">Nouveau GitLab 12.0 avec des revues visuelles et une liste de d√©pendances</a></li>
<li><a href="../fr458142/index.html">D√©velopper Breakout sur Svelte</a></li>
<li><a href="../fr458144/index.html">Nouvelles de la semaine: Raspberry Pi 4 √† vendre, Internet sur l'examen d'√âtat unifi√©, Roskomnadzor et les services VPN, un r√©seau de neurones d√©pouille les gens</a></li>
<li><a href="../fr458146/index.html">Application de comptabilit√© de communication open source dans la r√©gion</a></li>
<li><a href="../fr458148/index.html">√âlectronique r√©tro. Montre intelligente des ann√©es 80</a></li>
<li><a href="../fr458154/index.html">L'histoire incroyable de l'origine du port USB qui a tout chang√©</a></li>
<li><a href="../fr458156/index.html">Benchmarking PostgreSQL avec FreeBSD, CentOS, Ubuntu Debian et openSUSE</a></li>
<li><a href="../fr458158/index.html">√Ä la recherche d'ast√©ro√Ødes - Projet Hubble Asteroid Hunter</a></li>
<li><a href="../fr458160/index.html">Verrouillage prioritaire dans .NET</a></li>
<li><a href="../fr458168/index.html">Sommaire des actualit√©s de l'apprentissage automatique et de l'intelligence artificielle de juin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>