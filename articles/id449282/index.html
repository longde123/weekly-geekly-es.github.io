<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤑 🦔 📭 Cadangan, Bagian 1: Tujuan, Ikhtisar Teknik dan Teknologi 👩🏿‍🤝‍👨🏼 🔧 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa Anda perlu membuat cadangan? Bagaimanapun, peralatan ini sangat, sangat andal, di samping itu, ada "cloud" yang lebih baik daripada server fis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cadangan, Bagian 1: Tujuan, Ikhtisar Teknik dan Teknologi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/449282/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/658/945/c47/658945c47c79b468058bdfa05712bab1.jpg" alt="Cadangkan? Saya tidak perlu cadangan !!"></div><br>  Mengapa Anda perlu membuat cadangan?  Bagaimanapun, peralatan ini sangat, sangat andal, di samping itu, ada "cloud" yang lebih baik daripada server fisik dalam hal keandalan: jika dikonfigurasi dengan benar, server "cloud" akan dengan mudah selamat dari kegagalan server fisik infrastruktur, dan dari sudut pandang pengguna layanan, akan ada lompatan kecil, hampir tidak terlihat dalam waktu layanan.  Selain itu, duplikasi informasi seringkali memerlukan pembayaran untuk waktu prosesor "ekstra", beban disk, lalu lintas jaringan. <br><a name="habracut"></a><br><blockquote>  Program ideal berjalan cepat, tidak mengalir melalui RAM, tidak memiliki lubang, dan tidak ada. <br><br>  —Tidak diketahui </blockquote>  Karena program masih ditulis oleh pengembang protein, dan proses pengujian sering tidak ada, ditambah pengiriman program sangat jarang dengan penggunaan "praktik terbaik" (yang juga merupakan program itu sendiri, dan karena itu tidak sempurna), administrator sistem sering harus menyelesaikan masalah yang terdengar singkat tapi ringkas: "kembali seperti semula," "bawa pangkalan kembali ke operasi normal," "itu bekerja perlahan - kita memutar kembali", dan juga favorit saya "Saya tidak tahu apa, tapi perbaiki". <br><br>  Selain kesalahan logis yang muncul sebagai hasil kerja pengembang yang ceroboh, atau kombinasi keadaan, serta pengetahuan yang tidak lengkap atau kesalahpahaman tentang fitur kecil dari program pembangunan - termasuk pengikat dan yang sistem, termasuk sistem operasi, driver dan firmware - ada juga kesalahan lainnya.  Sebagai contoh, sebagian besar pengembang mengandalkan runtime, benar-benar lupa tentang hukum fisik yang masih mustahil dilewati dengan bantuan program.  Ini termasuk keandalan tak terbatas dari subsistem disk dan setiap subsistem penyimpanan data secara umum (termasuk RAM dan cache prosesor!), Dan nol waktu pemrosesan pada prosesor, dan tidak adanya kesalahan selama transmisi melalui jaringan dan selama pemrosesan pada prosesor, dan latensi jaringan, yaitu 0. Jangan abaikan tenggat waktu yang terkenal, karena jika Anda tidak punya waktu untuk itu, akan ada masalah yang lebih bersih daripada nuansa jaringan dan disk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/171/855/c4d/171855c4dfec286b3624dd27efeb71e6.jpg" alt="Chef, semuanya hilang! berdasarkan pada tangan Berlian"><br><br>  Tetapi bagaimana dengan masalah yang muncul dalam pertumbuhan penuh dan menggantungnya data yang berharga?  Tidak ada yang bisa menggantikan pengembang langsung, dan bukan fakta bahwa itu akan mungkin dalam waktu dekat.  Di sisi lain, untuk sepenuhnya membuktikan bahwa program akan berfungsi sebagaimana dimaksud, sejauh ini hanya beberapa proyek yang berhasil, dan sama sekali tidak mungkin untuk mengambil dan menerapkan bukti ke proyek lain yang serupa.  Juga, bukti semacam itu membutuhkan banyak waktu, dan membutuhkan keterampilan dan pengetahuan khusus, dan ini praktis meminimalkan kemungkinan aplikasi mereka dengan tenggat waktu.  Selain itu, kami masih tidak tahu bagaimana teknologi yang sangat cepat, murah, dan andal untuk menyimpan, memproses, dan mentransmisikan informasi.  Teknologi semacam itu, jika ada, maka dalam bentuk konsep, atau - paling sering - hanya dalam buku dan film fiksi ilmiah. <br><blockquote>  Artis yang bagus meniru, seniman hebat mencuri. <br><br>  —Pablo Picasso. </blockquote>  Solusi yang paling sukses dan hal-hal sederhana yang mengejutkan biasanya terjadi di mana ada konsep, teknologi, pengetahuan, bidang sains yang benar-benar tidak kompatibel. <br><br>  Misalnya, burung dan pesawat memiliki sayap, tetapi terlepas dari kesamaan fungsional - prinsip operasi dalam beberapa mode adalah sama, dan masalah teknis diselesaikan dengan cara yang sama: tulang berlubang, penggunaan bahan yang kuat dan ringan, dll. - hasilnya sangat berbeda, meskipun sangat mirip.  Sampel terbaik yang kami amati dalam teknologi kami juga sebagian besar dipinjam dari alam: kompartemen kedap udara di kapal dan kapal selam - analogi langsung dengan annelida;  membangun susunan serangan dan memeriksa integritas data - duplikasi rantai DNA;  serta organ berpasangan, kemandirian kerja berbagai organ dari sistem saraf pusat (fungsi jantung otomatis) dan refleks adalah sistem otonom di Internet.  Tentu saja, mengambil dan menerapkan solusi siap pakai "langsung" penuh dengan masalah, tetapi siapa tahu, mungkin tidak ada solusi lain. <br><blockquote>  Jika saya tahu di mana Anda akan jatuh, saya akan meletakkan sedotan! <br><br>  —Pepatah Belarus </blockquote>  Jadi, cadangan sangat penting bagi mereka yang menginginkan: <br><br><ul><li>  Untuk dapat mengembalikan pengoperasian sistem mereka dengan downtime minimal, atau bahkan tanpa mereka </li><li>  Jangan ragu untuk bertindak, karena jika terjadi kesalahan selalu ada kemungkinan untuk kembalikan </li><li>  Minimalkan efek korupsi data yang disengaja </li></ul><br><div class="spoiler">  <b class="spoiler_title">Ini sedikit teori</b> <div class="spoiler_text"><blockquote>  Klasifikasi apa pun adalah arbitrer.  Alam tidak mengklasifikasikan.  Kami mengklasifikasikan, karena lebih nyaman bagi kami.  Dan kami mengklasifikasikan berdasarkan data, yang juga kami ambil secara sewenang-wenang. <br><br>  —Jan Bruler </blockquote>  Terlepas dari metode penyimpanan fisik, penyimpanan logis data dapat dibagi menjadi 2 cara mengakses data ini: blok dan file.  Divisi ini baru-baru ini sangat buram, karena murni blok, serta murni file, penyimpanan logis tidak ada.  Namun, untuk kesederhanaan, kami menganggap itu memang benar. <br><br>  Blok penyimpanan data menyiratkan bahwa ada perangkat fisik di mana data direkam dalam beberapa bagian tetap, blok.  Akses ke blok menuju ke alamat tertentu, setiap blok memiliki alamatnya sendiri di dalam perangkat. <br><br>  Pencadangan biasanya dilakukan dengan menyalin blok data.  Untuk memastikan integritas data pada saat penyalinan, pencatatan blok baru, serta modifikasi yang sudah ada, ditangguhkan.  Jika kita mengambil analogi dari dunia biasa, lemari terdekat adalah dengan sel bernomor yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/aa2/32f/ac1aa232faecb701dd3c82894239f34e.png" alt="Blokir penyimpanan data"><br><br>  Penyimpanan file data dengan prinsip perangkat logis dekat dengan penyimpanan blok dan sering diatur di atas.  Perbedaan penting adalah keberadaan hierarki penyimpanan dan nama yang dapat dibaca manusia.  Abstraksi disorot dalam bentuk file - area data bernama, serta direktori - file khusus di mana deskripsi dan akses ke file lain disimpan.  File dapat diberikan dengan metadata tambahan: waktu pembuatan, bendera akses, dll.  Mereka biasanya membuat cadangan dengan cara ini: mereka mencari file yang diubah, kemudian menyalinnya ke penyimpanan file lain dengan struktur yang sama.  Integritas data biasanya diimplementasikan dengan tidak adanya file yang sedang ditulis.  Metadata file didukung dengan cara yang sama.  Analogi terdekat adalah perpustakaan, yang memiliki bagian-bagian dengan buku yang berbeda, serta katalog dengan nama buku yang dapat dibaca manusia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/752/454/8cc/7524548cc8ff235cf9284d49d1fab007.jpg" alt="Penyimpanan data file"><br><br>  Baru-baru ini, opsi lain kadang-kadang dijelaskan, dengan mana, pada prinsipnya, penyimpanan file data dimulai, dan yang memiliki fitur kuno yang sama: penyimpanan data objek. <br><br>  Ini berbeda dari penyimpanan file karena tidak memiliki lebih dari satu sarang (tata letak datar), dan nama file, meskipun dapat dibaca oleh manusia, tetap lebih cocok untuk diproses oleh mesin.  Saat mencadangkan, penyimpanan objek paling sering diperlakukan seperti penyimpanan file, tetapi kadang-kadang ada opsi lain. <br><blockquote>  - Ada dua jenis administrator sistem, mereka yang tidak membuat cadangan, dan mereka yang sudah melakukannya. <br>  - Sebenarnya, ada tiga jenis: ada juga yang memverifikasi bahwa cadangan dapat dipulihkan. <br><br>  —Tidak diketahui </blockquote>  Penting juga dipahami bahwa proses pencadangan data dilakukan oleh program, sehingga memiliki semua kelemahan yang sama dengan program lain.  Untuk menghapus (tidak mengecualikan!) Ketergantungan pada faktor manusia, serta fitur - yang secara individual tidak sangat mempengaruhi, tetapi bersama-sama dapat memberikan efek nyata - menerapkan apa yang disebut  aturan 3-2-1.  Ada banyak opsi untuk mendekripsi, tetapi saya lebih suka interpretasi berikut: Anda perlu menyimpan 3 set data yang sama, 2 set harus disimpan dalam format yang berbeda, dan 1 set harus disimpan dalam penyimpanan yang jauh secara geografis. <br><br>  Format penyimpanan harus dipahami sebagai berikut: <br><br><ul><li>  Jika ada ketergantungan pada metode penyimpanan fisik, kami mengubah metode fisik. </li><li>  Jika ada ketergantungan pada metode penyimpanan logis, kami mengubah metode logis. </li></ul><br>  Untuk mencapai efek maksimum aturan 3-2-1, disarankan untuk mengubah format penyimpanan dengan dua cara. <br><br>  Dari sudut pandang kesiapan cadangan untuk tujuan yang dimaksudkan - pemulihan operabilitas, ada cadangan "panas" dan "dingin".  Panas dari dingin berbeda hanya dalam satu hal: mereka segera siap untuk bekerja, sementara dingin untuk pemulihan memerlukan beberapa tindakan tambahan: dekripsi, ekstraksi dari arsip, dll. <br><br>  Jangan bingung salinan panas dan dingin dengan salinan online dan offline, yang menyiratkan isolasi fisik data, dan pada kenyataannya, adalah tanda lain dari klasifikasi metode cadangan.  Jadi salinan offline - tidak terhubung langsung ke sistem di mana perlu dipulihkan - bisa panas atau dingin (dalam hal kesiapan untuk pemulihan).  Salinan online mungkin tersedia langsung di tempat yang perlu dipulihkan, dan paling sering panas, tetapi ada juga yang dingin. <br><br>  Selain itu, jangan lupa bahwa proses membuat cadangan biasanya tidak berakhir dengan membuat cadangan tunggal, dan mungkin ada cukup banyak salinan.  Oleh karena itu, perlu untuk membedakan antara cadangan lengkap, mis.  salinan yang dapat dipulihkan secara terpisah dari cadangan lain, serta salinan diferensial (inkremental, diferensial, decremental, dll.) - yang tidak dapat dipulihkan sendiri dan memerlukan pemulihan awal satu atau lebih cadangan lain. <br><br>  Cadangan inkremental diferensial - upaya untuk menghemat jumlah ruang untuk menyimpan cadangan.  Dengan demikian, hanya data yang dimodifikasi dari cadangan sebelumnya yang ditulis ke cadangan. <br><br>  Perbedaan decrementals dibuat untuk tujuan yang sama, tetapi dengan cara yang sedikit berbeda: cadangan penuh dibuat, tetapi hanya perbedaan antara salinan baru dan yang sebelumnya benar-benar disimpan. <br><br>  Secara terpisah, ada baiknya mempertimbangkan proses pencadangan di atas penyimpanan, yang mendukung tidak adanya penyimpanan duplikat.  Jadi, jika Anda menulis cadangan penuh di atasnya, pada kenyataannya hanya perbedaan antara cadangan yang akan dicatat, namun, proses pengembalian cadangan akan sama dengan memulihkan dari salinan lengkap dan sepenuhnya transparan. <br><br><blockquote>  Quis custodiet ipsos custodes? <br><br>  (Siapa yang akan menjaga sendiri penjaga? - lat.) </blockquote><br><br>  Sangat tidak menyenangkan ketika tidak ada cadangan, tetapi jauh lebih buruk jika cadangan tampaknya dibuat, tetapi selama pemulihan ternyata tidak dapat dipulihkan, karena: <br><br><ul><li>  Integritas sumber data telah dilanggar. </li><li>  Penyimpanan cadangan rusak. </li><li>  Pemulihan bekerja sangat lambat, Anda tidak dapat menggunakan data yang sebagian dipulihkan. </li></ul><br><br>  Proses pencadangan yang dibangun dengan benar harus memperhitungkan komentar semacam itu, terutama yang pertama. <br><br>  Integritas sumber data dapat dijamin dalam beberapa cara.  Yang paling umum digunakan adalah: a) membuat snapshot sistem file pada level blok, b) membekukan status sistem file, c) perangkat blok khusus dengan penyimpanan versi, d) rekaman berurutan file atau blok.  Checksum juga digunakan untuk memastikan verifikasi data selama pemulihan. <br><br>  Kerusakan pada penyimpanan juga dapat dideteksi menggunakan checksum.  Metode tambahan adalah penggunaan perangkat khusus atau sistem file di mana tidak mungkin untuk memodifikasi data yang sudah direkam, tetapi Anda dapat menambahkan yang baru. <br><br>  Untuk mempercepat pemulihan, pemulihan data digunakan dengan beberapa proses pemulihan - asalkan tidak ada "hambatan" dalam bentuk jaringan yang lambat atau sistem disk yang lambat.  Untuk menghindari situasi dengan data yang dipulihkan sebagian, dimungkinkan untuk memecah proses pencadangan menjadi subtugas yang relatif kecil, yang masing-masing dilakukan secara terpisah.  Dengan demikian, menjadi mungkin untuk secara konsisten mengembalikan kinerja dengan prediksi waktu pemulihan.  Masalah ini paling sering terletak pada bidang organisasi (SLA), jadi kami tidak akan membahasnya secara rinci. <br><br><blockquote>  Tahu banyak tentang rempah-rempah bukan orang yang menambahkannya ke setiap hidangan, tetapi orang yang tidak pernah menambahkan sesuatu yang berlebihan untuk itu. <br><br>  —B.  Sinyavsky </blockquote><br><br>  Praktik mengenai perangkat lunak yang digunakan oleh administrator sistem dapat bervariasi, tetapi prinsip-prinsip umum masih sama, satu atau lain cara, khususnya: <br><br><ul><li>  Solusi siap pakai sangat dianjurkan. </li><li>  Program harus bekerja dengan mudah, mis.  Seharusnya tidak ada fitur atau kemacetan yang tidak terdokumentasi. </li><li>  Menyiapkan setiap program harus cukup sederhana sehingga Anda tidak perlu membaca manual atau lembar contekan setiap saat. </li><li>  Solusinya harus universal, jika memungkinkan.  server dalam spesifikasi perangkat kerasnya dapat sangat bervariasi. </li></ul><br><br>  Program umum berikut tersedia untuk menghapus cadangan dari perangkat blok: <br><br><ul><li>  dd, akrab dengan veteran administrasi sistem, program serupa juga berlaku di sini (dd_rescue yang sama, misalnya). </li><li>  Utilitas (utilitas) dibangun ke dalam beberapa sistem file yang membuat dump dari sistem file. </li><li>  Utilitas omnivora;  mis. partclone. </li><li>  Keputusan sendiri, seringkali hak milik;  mis. NortonGhost dan yang lebih baru. </li></ul><br><br>  Untuk sistem file, tugas cadangan sebagian diselesaikan menggunakan metode yang berlaku untuk memblokir perangkat, namun, masalahnya dapat diselesaikan lebih efisien, menggunakan, misalnya: <br><br><ul><li>  Rsync, program dan protokol universal untuk menyinkronkan keadaan sistem file. </li><li>  Alat pengarsipan bawaan (ZFS). </li><li>  Alat pengarsipan pihak ketiga;  perwakilan yang paling populer adalah tar.  Ada yang lain, misalnya, mengganti tar dengan fokus pada sistem modern. </li></ul><br>  Secara terpisah, ada baiknya menyebutkan perangkat lunak konsistensi data saat membuat cadangan.  Opsi yang paling umum digunakan adalah: <br><br><ul><li>  Memasang sistem file dalam mode hanya baca (ReadOnly), atau membekukan sistem file (membekukan) - metode ini terbatas. </li><li>  Membuat snapshot dari keadaan sistem file atau memblokir perangkat (LVM, ZFS). </li><li>  Penggunaan alat pihak ketiga untuk mengatur gips, bahkan dalam kasus di mana paragraf sebelumnya tidak dapat diberikan karena alasan apa pun (program seperti hotcopy). </li><li>  Teknik copy-on-change (CopyOnWrite), bagaimanapun, itu paling sering dikaitkan dengan FS yang digunakan (BTRFS, ZFS). </li></ul><br></div></div><br>  Jadi, untuk server kecil, Anda perlu menyediakan skema cadangan yang memenuhi persyaratan berikut: <br><br><ul><li>  Mudah digunakan - tidak diperlukan langkah tambahan khusus saat bekerja, langkah minimal untuk membuat dan mengembalikan salinan. </li><li>  Universal - bekerja pada server besar dan kecil;  ini penting ketika meningkatkan jumlah server atau penskalaan. </li><li>  Itu diinstal oleh manajer paket, atau dalam satu atau dua perintah dari tipe "unduh dan unzip". </li><li>  Stabil - menggunakan format penyimpanan standar atau lama. </li><li>  Cepat dalam bekerja. </li></ul><br>  Pelamar dari mereka yang kurang lebih memenuhi persyaratan: <br><br><ul><li>  rdiff-backup </li><li>  rsnapshot </li><li>  sendawa </li><li>  duplikat </li><li>  bermuka dua </li><li>  dup deja </li><li>  sayang </li><li>  zbackup </li><li>  tenang </li><li>  borgbackup </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/a62/7e9/237/a627e923770a18cff68471cb826ec2bd.jpg" alt="Tempat tidur procrustean"><br><br>  Mesin virtual (berdasarkan XenServer) dengan karakteristik berikut akan digunakan sebagai bangku tes: <br><br><ul><li>  4 core 2,5 GHz, </li><li>  RAM 16 GB </li><li>  Penyimpanan hybrid 50 GB (penyimpanan dengan caching pada SSD sebesar 20% dari ukuran disk virtual) sebagai disk virtual terpisah tanpa partisi, </li><li>  Saluran Internet 200 Mbps. </li></ul><br>  Mesin yang hampir sama akan digunakan sebagai server tujuan cadangan, hanya dengan hard drive 500 GB. <br><br>  Sistem operasi - Centos 7 x64: kerusakan standar, partisi tambahan akan digunakan sebagai sumber data. <br><br>  Mari kita ambil situs wordpress sebagai sumber data, dengan file media 40 GB, database mysql.  Karena server virtual sangat bervariasi dalam karakteristik, serta untuk reproduktifitas yang lebih baik, ada <br><br><div class="spoiler">  <b class="spoiler_title">hasil tes server menggunakan sysbench.</b> <div class="spoiler_text">  sysbench --threads = 4 --time = 30 --cpu-max-prime = 20.000 cpu run <br>  sysbench 1.1.0-18a9f86 (menggunakan bundel LuaJIT 2.1.0-beta3) <br>  Menjalankan tes dengan opsi berikut: <br>  Jumlah utas: 4 <br>  Menginisialisasi generator angka acak dari waktu sekarang <br><br>  Batas bilangan prima: 20.000 <br><br>  Menginisialisasi utas pekerja ... <br><br>  Utas dimulai! <br><br>  Kecepatan CPU: <br>  acara per detik: 836.69 <br><br>  Throughput: <br>  acara / s (eps): 836.6908 <br>  waktu berlalu: 30.0039d <br>  total jumlah acara: 25104 <br><br>  Latensi (ms): <br>  min: 2,38 <br>  rata-rata: 4,78 <br>  maks: 22,39 <br>  Persentil ke-95: 10.46 <br>  jumlah: 119923,64 <br><br>  Keadilan benang: <br>  acara (rata-rata / stddev): 6276.0000 / 13.91 <br>  waktu eksekusi (rata-rata / stddev): 29.9809 / 0,01 <br><br>  sysbench --threads = 4 --time = 30 --memory-block-size = 1K --memory-scope = global --memory-total-size = 100G --memory-oper = read memory run <br>  sysbench 1.1.0-18a9f86 (menggunakan bundel LuaJIT 2.1.0-beta3) <br>  Menjalankan tes dengan opsi berikut: <br>  Jumlah utas: 4 <br>  Menginisialisasi generator angka acak dari waktu sekarang <br><br>  Menjalankan uji kecepatan memori dengan opsi berikut: <br>  ukuran blok: 1KiB <br>  ukuran total: 102400MiB <br>  operasi: baca <br>  ruang lingkup: global <br><br>  Menginisialisasi utas pekerja ... <br><br>  Utas dimulai! <br><br>  Total operasi: 50900446 (1696677.10 per detik) <br><br>  49707,47 MiB ditransfer (1656,91 MiB / detik) <br><br>  Throughput: <br>  acara / s (eps): 1696677.1017 <br>  waktu berlalu: 30.0001s <br>  total jumlah acara: 50900446 <br><br>  Latensi (ms): <br>  min: 0,00 <br>  rata-rata: 0,00 <br>  maks: 24,01 <br>  Persentil ke-95: 0,00 <br>  jumlah: 39106,74 <br><br>  Keadilan benang: <br>  acara (rata-rata / stddev): 12725111.5000 / 137775.15 <br>  waktu eksekusi (avg / stddev): 9.7767 / 0.10 <br><br>  sysbench --threads = 4 --time = 30 --memory-block-size = 1K --memory-scope = global --memory-total-size = 100G --memory-oper = tulis memory run <br>  sysbench 1.1.0-18a9f86 (menggunakan bundel LuaJIT 2.1.0-beta3) <br>  Menjalankan tes dengan opsi berikut: <br>  Jumlah utas: 4 <br>  Menginisialisasi generator angka acak dari waktu sekarang <br><br>  Menjalankan uji kecepatan memori dengan opsi berikut: <br>  ukuran blok: 1KiB <br>  ukuran total: 102400MiB <br>  operasi: tulis <br>  ruang lingkup: global <br><br>  Menginisialisasi utas pekerja ... <br><br>  Utas dimulai! <br><br>  Total operasi: 35910413 (1197008,62 per detik) <br><br>  35068,76 MiB ditransfer (1168,95 MiB / detik) <br><br>  Throughput: <br>  acara / s (eps): 1197008.6179 <br>  waktu berlalu: 30.0001s <br>  total jumlah acara: 35910413 <br><br>  Latensi (ms): <br>  min: 0,00 <br>  rata-rata: 0,00 <br>  maks: 16.90 <br>  Persentil ke-95: 0,00 <br>  jumlah: 43604,83 <br><br>  Keadilan benang: <br>  acara (rata-rata / stddev): 8977603.2500 / 233905.84 <br>  waktu eksekusi (avg / stddev): 10.9012 / 0.41 <br><br>  sysbench --threads = 4 --file-test-mode = rndrw --time = 60 --file-block-size = 4K --file-total-size = 1G file menjalankan <br>  sysbench 1.1.0-18a9f86 (menggunakan bundel LuaJIT 2.1.0-beta3) <br>  Menjalankan tes dengan opsi berikut: <br>  Jumlah utas: 4 <br>  Menginisialisasi generator angka acak dari waktu sekarang <br><br>  Bendera terbuka file ekstra: (tidak ada) <br>  128 file, masing-masing 8MiB <br>  Total ukuran file 1GiB <br>  Ukuran blok 4KiB <br>  Jumlah permintaan IO: 0 <br>  Rasio Baca / Tulis untuk uji IO acak kombinasi: 1,50 <br>  FSYNC Berkala diaktifkan, memanggil fsync () setiap 100 permintaan. <br>  Memanggil fsync () di akhir tes, Diaktifkan. <br>  Menggunakan mode I / O sinkron <br>  Melakukan uji r / w acak <br>  Menginisialisasi utas pekerja ... <br><br>  Utas dimulai! <br><br>  Throughput: <br>  baca: IOPS = 3868.21 15.11 MiB / s (15.84 MB / s) <br>  tulis: IOPS = 2578.83 10,07 MiB / s (10,56 MB / s) <br>  fsync: IOPS = 8226.98 <br><br>  Latensi (ms): <br>  min: 0,00 <br>  rata-rata: 0,27 <br>  maks: 18,01 <br>  Persentil ke-95: 1,08 <br>  jumlah: 238469.45 <br></div></div><br>  Catatan ini mulai besar <br><br><div class="spoiler">  <b class="spoiler_title">siklus artikel cadangan</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cadangan, bagian 1: Mengapa Anda memerlukan cadangan, tinjauan umum metode, teknologi</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  2:    rsync-based   </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  3:    duplicity, duplicati</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  4:    zbackup, restic, borgbackup</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  5:  Bacula  Veeam Backup for Linux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> :    :  AMANDA, UrBackup, BackupPC</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  6:    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,  7: </a> </li></ol><br></div></div><br><br> <u> </u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Finnix</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449282/">https://habr.com/ru/post/id449282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449270/index.html">Yandex telah menerbitkan ikhtisar pasar lowongan TI</a></li>
<li><a href="../id449274/index.html">Layar 7-segmen besar dengan lampu neon pada ESP8266</a></li>
<li><a href="../id449276/index.html">Karir berubah pada usia 35. Pengalaman saya dan kesuksesan pertama</a></li>
<li><a href="../id449278/index.html">Serangan Domain</a></li>
<li><a href="../id449280/index.html">Bagaimana platform gaming cloud untuk klien b2b dan b2c bekerja. Solusi untuk gambar yang bagus dan bertarung dengan mil terakhir</a></li>
<li><a href="../id449284/index.html">Saya menjual bawang secara online</a></li>
<li><a href="../id449286/index.html">Dapatkan API GraphQL saat bepergian</a></li>
<li><a href="../id449288/index.html">Tim apa yang dibutuhkan untuk membuat toko online yang benar-benar bagus?</a></li>
<li><a href="../id449290/index.html">Bagaimana pemindaian 3D memecahkan masalah kontrol kualitas produksi</a></li>
<li><a href="../id449292/index.html">Review Pena Digital MT6081 - Ambil Catatan Anda Langsung ke Komputer Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>