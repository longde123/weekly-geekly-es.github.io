<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ö üë©üèΩ üëÉüèª √çndices no PostgreSQL - 8 (RUM) #‚É£ üèîÔ∏è üè©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° discutimos o mecanismo de indexa√ß√£o do PostgreSQL, a interface dos m√©todos de acesso e os principais m√©todos de acesso, como: √≠ndices de hash , √°rv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 8 (RUM)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452116/">  J√° discutimos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do</a> PostgreSQL, a interface dos m√©todos de acesso e os principais m√©todos de acesso, como: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndices de hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SP-GiST</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GIN</a> .  Neste artigo, veremos como o gin se transforma em rum. <br><br><h1>  RUM </h1><br>  Embora os autores afirmem que o gin √© um g√™nio poderoso, o tema das bebidas acabou vencendo: a pr√≥xima gera√ß√£o de GIN foi chamada de RUM. <br><br>  Esse m√©todo de acesso expande o conceito subjacente ao GIN e nos permite executar a pesquisa de texto completo ainda mais rapidamente.  Nesta s√©rie de artigos, este √© o √∫nico m√©todo que n√£o est√° inclu√≠do em uma entrega padr√£o do PostgreSQL e √© uma extens√£o externa.  V√°rias op√ß√µes de instala√ß√£o est√£o dispon√≠veis para isso: <br><br><ul><li>  Pegue o pacote "yum" ou "apt" do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio PGDG</a> .  Por exemplo, se voc√™ instalou o PostgreSQL a partir do pacote "postgresql-10", tamb√©m instale "postgresql-10-rum". </li><li>  Crie a partir do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo-fonte no github</a> e instale por conta pr√≥pria (as instru√ß√µes tamb√©m est√£o l√°). </li><li>  Use como parte do Postgres Pro Enterprise (ou pelo menos leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a documenta√ß√£o</a> de l√°). </li></ul><br><h2>  Limita√ß√µes do gin </h2><br>  Quais limita√ß√µes do GIN o RUM nos permite transcender? <br><br>  Primeiro, o tipo de dados "tsvector" cont√©m n√£o apenas lexemas, mas tamb√©m informa√ß√µes sobre suas posi√ß√µes dentro do documento.  Como observamos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltima vez</a> , o √≠ndice GIN n√£o armazena essas informa√ß√µes.  Por esse motivo, as opera√ß√µes para procurar frases, que apareceram na vers√£o 9.6, s√£o suportadas pelo √≠ndice GIN ineficientemente e precisam acessar os dados originais para verificar novamente. <br><br>  Segundo, os sistemas de pesquisa geralmente retornam os resultados classificados por relev√¢ncia (o que isso significa).  Podemos usar as fun√ß√µes de classifica√ß√£o "ts_rank" e "ts_rank_cd" para esse fim, mas elas precisam ser calculadas para cada linha do resultado, o que certamente √© lento. <br><br>  Para uma primeira aproxima√ß√£o, o m√©todo de acesso RUM pode ser considerado como GIN, que armazena adicionalmente informa√ß√µes de posi√ß√£o e pode retornar os resultados na ordem necess√°ria (como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> pode retornar vizinhos mais pr√≥ximos).  Vamos avan√ßar passo a passo. <br><a name="habracut"></a><br><h2>  Procurando por Frases </h2><br>  Uma consulta de pesquisa em texto completo pode conter operadores especiais que levam em considera√ß√£o a dist√¢ncia entre lexemes.  Por exemplo, podemos encontrar documentos nos quais "m√£o" √© separada de "coxa" com mais duas palavras: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;3&gt; thigh'</span></span>);</code> </pre> <pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Ou podemos indicar que as palavras devem ser localizadas uma ap√≥s a outra: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;-&gt; slap'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  O √≠ndice GIN regular pode retornar os documentos que cont√™m os dois lexemas, mas podemos verificar a dist√¢ncia entre eles apenas olhando para tsvector: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector -------------------------------------- 'clap':1 'hand':3 'slap':4 'thigh':6 (1 row)</code> </pre><br>  No √≠ndice RUM, cada lexeme n√£o faz apenas refer√™ncia √†s linhas da tabela: cada TID √© fornecida com a lista de posi√ß√µes em que o lexeme ocorre no documento.  √â assim que podemos visualizar o √≠ndice criado na tabela "slit-sheet", que j√° √© bastante familiar para n√≥s (a classe de operador "rum_tsvector_ops" √© usada por tsvector por padr√£o): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> rum; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(doc_tsv);</code> </pre><br><br><img src="https://habrastorage.org/webt/k0/up/gn/k0upgnbhka1wfwq6oozy9qo24ka.png"><br><br>  Quadrados cinza na figura cont√™m as informa√ß√µes de posi√ß√£o adicionadas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  O GIN tamb√©m fornece uma inser√ß√£o adiada quando o par√¢metro "fastupdate" √© especificado;  essa funcionalidade √© removida do RUM. <br><br>  Para ver como o √≠ndice funciona com dados ativos, vamos usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo</a> familiar da lista de discuss√£o pgsql-hackers. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> default_text_search_config = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">... UPDATE 356125</code> </pre><br>  √â assim que uma consulta que usa a pesquisa de frases √© realizada com o √≠ndice GIN: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv); fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Rows Removed by Index Recheck: 1517 Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual time=2.204..2.204 rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.266 ms Execution time: 18.151 ms (8 rows)</code> </pre><br>  Como podemos ver no plano, o √≠ndice GIN √© usado, mas retorna 1776 correspond√™ncias em potencial, das quais 259 s√£o deixadas e 1517 s√£o descartadas no est√°gio de verifica√ß√£o novamente. <br><br>  Vamos excluir o √≠ndice GIN e criar o RUM. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin; fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_rum <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv);</code> </pre><br>  O √≠ndice agora cont√©m todas as informa√ß√µes necess√°rias e a pesquisa √© realizada com precis√£o: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Heap Blocks: exact=250 -&gt; Bitmap Index Scan on tsv_rum (actual time=2.768..2.768 rows=259 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.245 ms Execution time: 3.053 ms (7 rows)</code> </pre><br><h2>  Classificando por relev√¢ncia </h2><br>  Para retornar documentos prontamente na ordem necess√°ria, o √≠ndice RUM suporta operadores de pedidos, que discutimos no artigo relacionado ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> .  A extens√£o RUM define esse operador, <code>&lt;=&gt;</code> , que retorna uma certa dist√¢ncia entre o documento ("tsvector") e a consulta ("tsquery").  Por exemplo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&amp;gtl to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 16.4493 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'sheet'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 13.1595 (1 row)</code> </pre><br>  O documento parecia ser mais relevante para a primeira consulta do que para a segunda: quanto mais a palavra ocorre, menos "valiosa" √©. <br><br>  Vamos tentar novamente comparar GIN e RUM em um tamanho de dados relativamente grande: selecionaremos dez documentos mais relevantes que cont√™m "hello" e "hackers". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ts_rank(tsv,to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------- Limit (actual time=27.076..27.078 rows=10 loops=1) -&gt; Sort (actual time=27.075..27.076 rows=10 loops=1) Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) Sort Method: top-N heapsort Memory: 29kB -&gt; Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual ... rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Planning time: 0.276 ms Execution time: 27.121 ms (11 rows)</code> </pre><br>  O √≠ndice GIN retorna 1776 correspond√™ncias, que s√£o classificadas como uma etapa separada para selecionar dez melhores ocorr√™ncias. <br><br>  Com o √≠ndice RUM, a consulta √© realizada usando uma simples verifica√ß√£o de √≠ndice: nenhum documento extra √© examinado e nenhuma classifica√ß√£o separada √© necess√°ria: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> tsv &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------- Limit (actual time=5.083..5.171 rows=10 loops=1) -&gt; Index Scan using tsv_rum on mail_messages (actual ... rows=10 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) Planning time: 0.244 ms Execution time: 5.207 ms (6 rows)</code> </pre><br><h2>  Informa√ß√µes adicionais </h2><br>  O √≠ndice RUM, bem como o GIN, podem ser criados em v√°rios campos.  Por√©m, enquanto o GIN armazena lexemes de cada coluna independentemente dos de outra coluna, o RUM permite "associar" o campo principal ("tsvector" neste caso) a outro.  Para fazer isso, precisamos usar uma classe de operador especializada "rum_tsvector_addon_ops": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv RUM_TSVECTOR_ADDON_OPS, sent) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (ATTACH=<span class="hljs-string"><span class="hljs-string">'sent'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span>=<span class="hljs-string"><span class="hljs-string">'tsv'</span></span>);</code> </pre><br>  Podemos usar esse √≠ndice para retornar os resultados classificados no campo adicional: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | sent | ?column? ---------+---------------------+---------- 2298548 | 2017-01-01 15:03:22 | 202 2298547 | 2017-01-01 14:53:13 | 407 2298545 | 2017-01-01 13:28:12 | 5508 2298554 | 2017-01-01 18:30:45 | 12645 2298530 | 2016-12-31 20:28:48 | 66672 2298587 | 2017-01-02 12:39:26 | 77966 2298588 | 2017-01-02 12:43:22 | 78202 2298597 | 2017-01-02 13:48:02 | 82082 2298606 | 2017-01-02 15:50:50 | 89450 2298628 | 2017-01-02 18:55:49 | 100549 (10 rows)</code> </pre><br>  Aqui, pesquisamos as linhas correspondentes o mais pr√≥ximo poss√≠vel da data especificada, n√£o importa mais cedo ou mais tarde.  Para obter resultados estritamente anteriores (ou seguintes) √† data especificada, precisamos usar <code>&lt;=|</code>  operador (ou <code>|=&gt;</code> ). <br><br>  Como esperado, a consulta √© realizada apenas por uma simples verifica√ß√£o de √≠ndice: <br><br><pre> <code class="pgsql hljs">ts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Limit -&gt; Index Scan using mail_messages_tsv_sent_idx on mail_messages Index Cond: (tsv @@ to_tsquery('hello'::text)) Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) (4 rows)</code> </pre><br>  Se criarmos o √≠ndice sem as informa√ß√µes adicionais sobre a associa√ß√£o de campos, para uma consulta semelhante, teremos que classificar todos os resultados da verifica√ß√£o do √≠ndice. <br><br>  Al√©m da data, certamente podemos adicionar campos de outros tipos de dados ao √≠ndice RUM.  Praticamente todos os tipos de base s√£o suportados.  Por exemplo, uma loja online pode exibir rapidamente os produtos por novidade (data), pre√ßo (num√©rico) e popularidade ou valor do desconto (n√∫mero inteiro ou ponto flutuante). <br><br><h2>  Outras classes de operadores </h2><br>  Para completar, devemos mencionar outras classes de operadores dispon√≠veis. <br><br>  Vamos come√ßar com <strong>"rum_tsvector_hash_ops"</strong> e <strong>"rum_tsvector_hash_addon_ops"</strong> .  Eles s√£o semelhantes aos j√° discutidos "rum_tsvector_ops" e "rum_tsvector_addon_ops", mas o √≠ndice armazena o c√≥digo de hash do lexeme em vez do pr√≥prio lexeme.  Isso pode reduzir o tamanho do √≠ndice, mas √© claro que a pesquisa se torna menos precisa e requer nova verifica√ß√£o.  Al√©m disso, o √≠ndice n√£o suporta mais a pesquisa de uma correspond√™ncia parcial. <br><br>  √â interessante observar a classe de operador <strong>"rum_tsquery_ops"</strong> .  Ele nos permite resolver um problema "inverso": encontre consultas que correspondam ao documento.  Por que isso pode ser necess√°rio?  Por exemplo, para inscrever um usu√°rio em novos produtos de acordo com seu filtro ou para categorizar automaticamente novos documentos.  Veja este exemplo simples: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> categories(query <span class="hljs-type"><span class="hljs-type">tsquery</span></span>, category <span class="hljs-type"><span class="hljs-type">text</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (to_tsquery(<span class="hljs-string"><span class="hljs-string">'vacuum | autovacuum | freeze'</span></span>), <span class="hljs-string"><span class="hljs-string">'vacuum'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'xmin | xmax | snapshot | isolation'</span></span>), <span class="hljs-string"><span class="hljs-string">'mvcc'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'wal | (write &amp; ahead &amp; log) | durability'</span></span>), <span class="hljs-string"><span class="hljs-string">'wal'</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(query); fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> array_agg(category) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector( <span class="hljs-string"><span class="hljs-string">'Hello hackers, the attached patch greatly improves performance of tuple freezing and also reduces size of generated write-ahead logs.'</span></span> ) @@ query;</code> </pre><pre> <code class="plaintext hljs"> array_agg -------------- {vacuum,wal} (1 row)</code> </pre><br>  As classes de operador restantes <strong>"rum_anyarray_ops"</strong> e <strong>"rum_anyarray_addon_ops"</strong> foram projetadas para manipular matrizes em vez de "tsvector".  Isso j√° foi discutido pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltima vez no</a> GIN e n√£o precisa ser repetido. <br><br><h2>  Os tamanhos do √≠ndice e do log write-ahead (WAL) </h2><br>  √â claro que, como o RUM armazena mais informa√ß√µes que o GIN, ele deve ter um tamanho maior.  Est√°vamos comparando os tamanhos de diferentes √≠ndices da √∫ltima vez;  vamos adicionar RUM a esta tabela: <br><br><pre> <code class="plaintext hljs"> rum | gin | gist | btree --------+--------+--------+-------- 457 MB | 179 MB | 125 MB | 546 MB</code> </pre><br>  Como podemos ver, o tamanho aumentou bastante, que √© o custo da pesquisa r√°pida. <br><br>  Vale a pena prestar aten√ß√£o em mais um ponto n√£o √≥bvio: o RUM √© uma extens√£o, ou seja, pode ser instalado sem nenhuma modifica√ß√£o no n√∫cleo do sistema.  Isso foi ativado na vers√£o 9.6 gra√ßas a um patch de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexander Korotkov</a> .  Um dos problemas que precisaram ser resolvidos para esse fim foi a gera√ß√£o de registros de log.  Uma t√©cnica para registro de opera√ß√µes deve ser absolutamente confi√°vel, portanto, uma extens√£o n√£o pode ser deixada nesta cozinha.  Em vez de permitir que a extens√£o crie seus pr√≥prios tipos de registros de log, existe o seguinte: o c√≥digo da extens√£o comunica sua inten√ß√£o de modificar uma p√°gina, faz altera√ß√µes nela, sinaliza a conclus√£o e √© o n√∫cleo do sistema, que compara as vers√µes antiga e nova da p√°gina e gera registros de log unificados necess√°rios. <br><br>  O algoritmo atual de gera√ß√£o de log compara p√°ginas byte a byte, detecta fragmentos atualizados e registra cada um desses fragmentos, juntamente com seu deslocamento desde o in√≠cio da p√°gina.  Isso funciona bem ao atualizar apenas v√°rios bytes ou a p√°gina inteira.  Mas se adicionarmos um fragmento dentro de uma p√°gina, movendo o restante do conte√∫do para baixo (ou vice-versa, removendo um fragmento, movendo o conte√∫do para cima), significativamente mais bytes ser√£o alterados do que realmente foram adicionados ou removidos. <br><br>  Devido a isso, a altera√ß√£o intensa do √≠ndice RUM pode gerar registros de tamanho significativamente maior que o GIN (que, n√£o sendo uma extens√£o, mas uma parte do n√∫cleo, gerencia o log por conta pr√≥pria).  A extens√£o desse efeito irritante depende muito de uma carga de trabalho real, mas para obter uma id√©ia do problema, vamos tentar remover e adicionar v√°rias linhas v√°rias vezes, intercalando essas opera√ß√µes com "v√°cuo".  Podemos avaliar o tamanho dos registros de log da seguinte maneira: no come√ßo e no final, lembre-se da posi√ß√£o no log usando a fun√ß√£o "pg_current_wal_location" ("pg_current_xlog_location" nas vers√µes anteriores a dez) e depois observe a diferen√ßa. <br><br>  Mas, √© claro, devemos considerar muitos aspectos aqui.  Precisamos garantir que apenas um usu√°rio esteja trabalhando com o sistema (caso contr√°rio, registros "extras" ser√£o levados em considera√ß√£o).  Mesmo se esse for o caso, levamos em conta n√£o apenas o RUM, mas tamb√©m as atualiza√ß√µes da pr√≥pria tabela e do √≠ndice que suporta a chave prim√°ria.  Os valores dos par√¢metros de configura√ß√£o tamb√©m afetam o tamanho (o n√≠vel de log "r√©plica", sem compacta√ß√£o, foi usado aqui).  Mas vamos tentar assim mesmo. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> start_lsn \gset</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3576</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3590</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3605</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">98</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3637</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3625</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">97</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3668</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> end_lsn \gset fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(:<span class="hljs-string"><span class="hljs-string">'end_lsn'</span></span>::pg_lsn - :<span class="hljs-string"><span class="hljs-string">'start_lsn'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 3114 MB (1 row)</code> </pre><br>  Ent√£o, temos cerca de 3 GB.  Mas se repetirmos o mesmo experimento com o √≠ndice GIN, isso render√° apenas cerca de 700 MB. <br><br>  Portanto, √© desej√°vel ter um algoritmo diferente, que encontre o n√∫mero m√≠nimo de opera√ß√µes de inser√ß√£o e exclus√£o que podem transformar um estado da p√°gina em outro.  O utilit√°rio "Diff" funciona de maneira semelhante.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oleg Ivanov</a> j√° implementou esse algoritmo e seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch</a> est√° sendo discutido.  No exemplo acima, esse patch permite reduzir o tamanho dos registros de log em 1,5 vezes, para 1900 MB, ao custo de uma pequena desacelera√ß√£o. <br><br><blockquote>  Infelizmente, o patch travou e n√£o h√° atividade em torno dele. <br></blockquote><br><h2>  Propriedades </h2><br>  Como de costume, vamos examinar as propriedades do m√©todo de acesso RUM, prestando aten√ß√£o √†s diferen√ßas do GIN (consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° foram fornecidas</a> ). <br><br>  A seguir est√£o as propriedades do m√©todo de acesso: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- rum | can_order | f rum | can_unique | f rum | can_multi_col | t rum | can_exclude | t -- f for gin</code> </pre><br>  As seguintes propriedades da camada de √≠ndice est√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t -- f for gin bitmap_scan | t backward_scan | f</code> </pre><br>  Observe que, diferentemente do GIN, o RUM suporta a verifica√ß√£o de √≠ndice - caso contr√°rio, n√£o seria poss√≠vel retornar exatamente o n√∫mero necess√°rio de resultados em consultas com a cl√°usula "limit".  N√£o h√° necessidade da contrapartida do par√¢metro "gin_fuzzy_search_limit" de acordo.  E, como consequ√™ncia, o √≠ndice pode ser usado para suportar restri√ß√µes de exclus√£o. <br><br>  A seguir est√£o as propriedades da camada de coluna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | t -- f for gin returnable | f search_array | f search_nulls | f</code> </pre><br>  A diferen√ßa aqui √© que o RUM suporta operadores de pedidos.  No entanto, isso n√£o √© verdade para todas as classes de operadores: por exemplo, isso √© falso para "tsquery_ops". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452116/">https://habr.com/ru/post/pt452116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452106/index.html">Convidamos palestrantes para a reuni√£o de bricolage de ver√£o em 16 de junho de 2019</a></li>
<li><a href="../pt452108/index.html">Docker: conselhos inofensivos</a></li>
<li><a href="../pt452110/index.html">Automatize a substitui√ß√£o do disco com o Ansible</a></li>
<li><a href="../pt452112/index.html">CRM ++</a></li>
<li><a href="../pt452114/index.html">HolyJS 2019: Analisando a partir do SEMrush (Parte 1)</a></li>
<li><a href="../pt452118/index.html">Cientista quebra o c√≥digo do misterioso manuscrito de Voynich</a></li>
<li><a href="../pt452122/index.html">"P√≠lula do dem√¥nio" em movimento</a></li>
<li><a href="../pt452124/index.html">‚ÄúPrecisamos ter fome de conhecimento e realiza√ß√µes‚Äù - como √© ser um testador no Alfa-Bank</a></li>
<li><a href="../pt452128/index.html">Equ√≠vocos populares sobre a resist√™ncia √† radia√ß√£o de microcircuitos</a></li>
<li><a href="../pt452130/index.html">A lua est√° encolhendo, causa terremotos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>