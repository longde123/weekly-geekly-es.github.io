<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🍳 ♂️ ♏️ Comment j'ai réparé une base cassée et ce qui en est sorti 🎀 🚃 🐇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois, on m'a demandé d'aider à «réparer» une base de données. CHECKDB lors de la vérification a donné une liste d'erreurs, dont certaines ont été ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai réparé une base cassée et ce qui en est sorti</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485144/">  Une fois, on m'a demandé d'aider à «réparer» une base de données.  CHECKDB lors de la vérification a donné une liste d'erreurs, dont certaines ont été marquées comme «incorrigibles».  L'application a fonctionné, mais elle était encore quelque peu agitée. <br><br>  Oui, la bonne solution dans une telle situation serait de faire une sauvegarde à partir du moment où les erreurs n'apparaissent toujours pas, de localiser les données corrompues et de les écraser à partir d'une copie propre.  Mais ... comme cela arrive souvent, l'erreur a été détectée trop tard, il n'y avait donc vraiment rien à récupérer.  D'un autre côté - il y aurait une sauvegarde, il n'y aurait pas cette histoire. <br><a name="habracut"></a><br><h2>  Anamnèse </h2><br>  La première étape consiste à lancer DBCC CHECKDB afin de comprendre l'ampleur de la tragédie.  L'équipe a honnêtement parcouru toutes les tables, pour la plupart ne trouvant aucun problème.  Dans la même conclusion, il y a eu cent rapports d'erreurs «corrigibles».  Quelque chose comme ça: <br><br><pre><code class="plaintext hljs">Index row (1:386974:44) with values (C_FK_6bb5032ec2f94557a7d4a9d39a356168 = '04DA7FC4-B8F2-4D97-B8D2-B207A918D3DF' and C_PK_dd87d9cad5504a1199d4ddaf511ea6a9 = 'F44E8C34-862D-4952-8821-D0E87143A74E') pointing to the data row identified by (C_PK_dd87d9cad5504a1199d4ddaf511ea6a9 = 'F44E8C34-862D-4952-8821-D0E87143A74E').</code> </pre> <br>  Et quelques erreurs plus graves: <br><br><pre> <code class="plaintext hljs">Table error: Object ID 1333579789, index ID 1, partition ID 72057609974841344, alloc unit ID 72057610075701248 (type In-row data). Page (1:20426) is missing a reference from previous page (1:267203). Possible chain linkage problem.</code> </pre> <br>  Eh bien.  L'échelle de travail est décrite, commençons! <br><br><h2>  Erreurs corrigibles </h2><br>  Afin de comprendre pourquoi certaines erreurs peuvent être facilement corrigées automatiquement, rappelons comment les index sont organisés dans MS SQL.  Vous pouvez les diviser en 2 types: cluster et (étonnamment) non-cluster.  (Nous ne nous pencherons pas sur des sujets particuliers tels que les indices columnstore - ce n'est pas le cas).  Les deux sont un arbre équilibré, ce qui est très pratique pour trouver des données. <br><br>  Il est important que les index de cluster à leur niveau «feuille» stockent directement le contenu des lignes de table.  Mais les index non clusterisés stockent uniquement les données clés (et, si disponibles, les champs «inclus»), ainsi qu'un lien vers la ligne d'index de cluster.  Autrement dit, si nous avons un problème dans un index non cluster, nous pouvons simplement prendre et écraser les données endommagées de l'index cluster.  Eh bien, ou reconstruisez simplement l’index battu - c’est bien, la composition des champs est connue et les données source sont proches, intactes. <br><br>  La tâche n'est absolument pas créative, vous pouvez donc la confier en toute sécurité à une voiture sans âme.  Exécutez la commande <br><br><pre> <code class="plaintext hljs">DBCC CHECKDB (&lt; &gt;, REPAIR_REBUILD)</code> </pre> <br>  et étudier le rapport d'étape. <br><br>  Le journal source et le journal après le "correctif" contiennent les adresses des pages corrompues.  Nous comparons ces adresses et nous assurons que toutes les erreurs marquées comme «corrigibles» ont bien été résolues. <br><br><h2>  Trouble de la connectivité des données </h2><br>  Maintenant quelque chose de plus grave.  Après avoir corrigé les index non clusterisés et effacé le journal des messages d'information, le rapport contient trois enregistrements d'erreurs «fatales» <br><br>  Vous pouvez, bien sûr, abandonner et couper avec la commande DBCC CHECKDB (&lt;nom DB&gt;, REPAIR_ALLOW_DATA_LOSS).  Mais ... je ne veux tout simplement pas perdre les données.  Je veux restaurer tout ce qui est possible au maximum.  Par conséquent, voyons plus en détail ce que le rapport d'erreur nous dit en général. <br><br><pre> <code class="plaintext hljs">Table error: Object ID 1333579789, index ID 1, partition ID 72057609974841344, alloc unit ID 72057610075701248 (type In-row data). Page (1:20426) is missing a reference from previous page (1:267203). Possible chain linkage problem. Table error: Object ID 1333579789, index ID 1, partition ID 72057609974841344, alloc unit ID 72057610075701248 (type In-row data). The previous link (1:267203) on page (1:267204) does not match the previous page (1:20426) that the parent (1:218898), slot 213 expects for this page. Table error: Object ID 1333579789, index ID 1, partition ID 72057609974841344, alloc unit ID 72057610075701248 (type In-row data). B-tree chain linkage mismatch. (1:20426)-&gt;next = (1:267204), but (1:267204)-&gt;Prev = (1:267203).</code> </pre> <br>  Le rapport contient une histoire trouble qu'une page s'attend à voir un voisin, mais le voisin n'en sait rien.  Certains marins pelevinsky Zheleznyak: sont allés sur le pont, mais pas de pont. <br><br>  Pour une compréhension complète, plus de détails sont nécessaires et ils devront aller directement au contenu des pages.  Mais avant cela, nous allons voir comment les pages d'index SQL Server sont liées en général. <br><br>  De toute évidence, les pages ont des liens hiérarchiques «verticaux», qui forment l'arborescence B.  La page supérieure contient des liens vers des pages d'un niveau inférieur et ainsi de suite jusqu'aux feuilles mêmes.  Comme je l'ai déjà dit, cela est très pratique pour trouver des valeurs: vous voulez trouver «Vasya Pupkin» et après quelques pages («de B à G» → «de Ba à Bb» → «Vasya Pupkin»), vous trouvez celle souhaitée. <br><br>  Mais il y a des situations où une requête doit sélectionner immédiatement des gammes entières de lignes ("De Vasya à Grisha").  Dans ce cas, chaque fois que vous descendez de l'arbre de haut en bas, vous vous y heurtez.  Pour répondre à de telles demandes, les pages stockent des liens "horizontaux": chaque page connaît le numéro du voisin "avant" et "après".  Avec ces relations, les analyses d'index sont beaucoup plus faciles à effectuer. <br><br>  À en juger par le journal des erreurs, nous avons eu une inadéquation des connexions horizontales et verticales.  Mais pour en être finalement convaincu, regardons les pages elles-mêmes. <br><br><h2>  Nous devons aller plus loin! </h2><br>  Pour consulter les pages, nous utiliserons l'ancienne équipe DBCC PAGE, bien méritée et non documentée.  Il prend 4 paramètres: <br><br><ul><li>  Eid Base </li><li>  Identifiant du fichier de base </li><li>  Identifiant de la page </li><li>  Niveau de détail (0 à 3) </li></ul><br>  En fonction du dernier paramètre, vous pouvez voir soit uniquement l'en-tête de service (0), soit l'intégralité du contenu de la page (3), soit l'en-tête et une partie du contenu (1 et 2) <br><br>  Soit dit en passant, dans SQL Server 2019, une vue documentée <a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-db-page-info-transact-sql%3Fview%3Dsql-server-ver15">sys.db_db_page_info est</a> enfin apparue, qui effectue des tâches similaires.  Malheureusement, il ne montre que les données d'en-tête (analogiques au drilldown 0), donc il ne répond toujours pas complètement à nos tâches. <br><br>  Donc, pour commencer, exécutez la commande <br><br><pre> <code class="sql hljs">DBCC TRACEON (3604, 1)</code> </pre> <br>  de sorte que la sortie des commandes DBCC restantes arrive à notre console, et non à ErrorLog <br><br>  Après cela, regardez le titre de la page 20426: <br><br><pre> <code class="sql hljs">DBCC PAGE (11, 1, 20426, 0)</code> </pre> <br><img src="https://habrastorage.org/webt/q9/sk/db/q9skdbv1yyn36mc3ch4c_ecobfu.jpeg" alt="image"><br><br>  Je vois.  La page veut être au milieu entre les pages 267203 et 267204. Mais qu'en est-il de ces mêmes pages? <br><br><img src="https://habrastorage.org/webt/gm/f-/tq/gmf-tqwjc6dhcxqxal5oxty2jn4.jpeg" alt="image"><br><br><img src="https://habrastorage.org/webt/d-/rp/zp/d-rpzpniwp9siohorqo-hgynp14.jpeg" alt="image"><br><br>  Pas de sommeil, pas d'esprit!  Ils sont bien sans invités non invités. <br>  Eh bien, regardons la table des matières à venir: <br><br><img src="https://habrastorage.org/webt/qi/em/-n/qiem-nxa_e4vfnkysraukw4kifs.jpeg" alt="image"><br><br>  Le puzzle se développe progressivement: <br><br><ul><li>  En termes de liens «verticaux» (arborescence d'index), la page 20426 doit être comprise entre 267203 et 267204 </li><li>  Les connexions horizontales contredisent cela et disent qu'il n'y a personne entre 267203 et 267204. </li></ul><br>  Essayons maintenant de comprendre quel type de données a souffert de l'échec. <br><br>  Les lignes de la page sont triées par clé d'index.  Par conséquent, en connaissant la première et la dernière valeur de clé sur la page, vous pouvez trouver la plage d'enregistrements «affectés». <br><br>  La clé peut être consultée simplement dans la description de l'index.  Nous utiliserons la commande <a href="https://docs.microsoft.com/en-US/sql/relational-databases/system-stored-procedures/sp-helpindex-transact-sql%3Fview%3Dsql-server-ver15">sp_helpindex</a> pour cela.  Dans ce cas, la clé est une seule colonne, incl.  fais attention à elle. <br><br><img src="https://habrastorage.org/webt/9t/6q/ao/9t6qaomdml8lcbre3lv5mpknaaq.jpeg" alt="image"><br><br>  Afin de trouver les clés qui se trouvent sur la page, nous utilisons DBCC PAGE avec un maximum de 3 niveaux de détails.  Si vous faites défiler le journal de sortie, vous pouvez voir le contenu "brut" de chaque ligne et une ventilation pour chaque champ: <br><br><img src="https://habrastorage.org/webt/nz/ag/wc/nzagwchaipe2uq0rgennpakg2om.jpeg" alt="image"><br><br>  Par ailleurs, les valeurs de limite de clé (la première valeur sur la page) peuvent également être vues dans la sortie PAGE DBCC pour la page d'index supérieure (218898, voir la capture d'écran ci-dessus).  Ils sont affichés dans la colonne qui suit immédiatement le numéro de page. <br><br>  Un examen des pages montre que la page 20426 contient exactement la moitié des lignes de la page 267203. La nature de l'échec devient claire.  Lorsque la page de la base de données est pleine et qu'elle n'a plus d'espace pour insérer de nouvelles données, elle est divisée en deux en 2 nouvelles pages.  Apparemment, lorsque la page 267203 est devenue pleine, la page de problème 20426 a été créée. Le SGBD a commencé à reconstruire ses liens: il a réussi à écrire une nouvelle page dans la structure d'index.  Mais pour une raison quelconque, les enregistrements horizontaux n'ont pas pu être mis à jour et la nouvelle page s'est «accrochée» dans un état indéfini. <br><br><h2>  Qu'est-ce que tout cela sera pour nous? </h2><br>  Il n'y a certainement pas grand-chose de bon.  Des liens de page sont évidemment nécessaires pour accéder aux données.  Lors de l'exécution de la requête, le SGBD détermine indépendamment le chemin d'accès à ces mêmes données.  Mais la règle générale (à partir de laquelle des exceptions sont possibles) est la suivante: <br><br><ul><li>  Les sélections «larges» (par exemple, pour les rapports) sont effectuées à l'aide d'enregistrements horizontaux.  Il est plus facile de faire défiler plusieurs pages séquentiellement, en choisissant une large plage </li><li>  Les requêtes «ponctuelles» (mise à jour d'un enregistrement spécifique) sont effectuées par une recherche «table des matières». </li></ul><br>  Il s'avère que lorsque des enregistrements spécifiques changent, le SGBD accède au «problème» page 20426. Et lorsqu'il exécute le rapport, il lit les données «horizontalement» et ne voit pas les modifications apportées.  Encore une fois: en pratique, l'algorithme peut être plus compliqué, mais la classe des problèmes possibles est toujours compréhensible. <br><br><h2>  Les questions éternelles de l'intellectuel russe </h2><br>  Pour être honnête, je ne vois toujours pas comment cela pourrait se produire.  Un SGBD moderne est en fait une chose assez fiable.  Toutes les modifications du fichier de base de données (y compris l'ajustement des relations horizontales et verticales) sont effectuées dans une transaction.  Ces opérations sont enregistrées dans le journal des transactions et, s'il n'y a aucune confirmation d'une opération réussie dans ce journal, toutes les opérations sont annulées.  Ici, vous pouvez voir que la transaction s'est terminée avec succès, mais certaines des modifications le long du chemin d'accès au fichier de données ont été «perdues». <br><br>  La seule explication plausible qui m'est venue à l'esprit était une panne du cache du sous-système de disque.  Toutes les données sont entrées dans le cache, puis une partie des enregistrements du fichier de données et du journal ont été écrits sur le disque - puis quelqu'un a tiré le commutateur.  En conséquence, les enregistrements «horizontaux» modifiés n'ont pas pu être enregistrés, mais la base de données n'en savait déjà rien.  (Et ici, de nombreux lecteurs devraient se précipiter pour vérifier les batteries de leurs contrôleurs de disques industriels) <br><br>  Que faire est beaucoup plus clair.  Pour restaurer la connectivité d'une table, il suffit de copier ses données dans une autre table pour que la lecture horizontale soit utilisée lors de la copie.  Pour la fidélité, vous pouvez spécifier explicitement la bonne méthode d'accès au SGBD à l'aide de l'indication FORCESCAN <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> T_bca79e9e77c24cdc8bbb7cfd0ddc16fd_BKP <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T_bca79e9e77c24cdc8bbb7cfd0ddc16fd <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (FORCESCAN)</code> </pre> <br>  Après cela, vous pouvez effacer la table source et y renvoyer les données copiées. <br><br>  Mais les modifications apportées à la page 20426 seront perdues. <b>Par conséquent, avant de faire une copie du tableau, vous devez copier les lignes avec les identificateurs de la page 20426.</b> Et après avoir restauré le tableau, corrigez les entrées nécessaires.  L'accès aux enregistrements de la page 20426 est explicitement nécessaire par des identifiants: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T_bca79e9e77c24cdc8bbb7cfd0ddc16fd <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> C_PK_bca79e9e77c24cdc8bbb7cfd0ddc16fd = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br>  Les identifiants peuvent être obtenus en lisant le contenu de la page avec la même PAGE DBCC.  Comme je l'ai déjà écrit, il y avait exactement la moitié de ces pages 267203, soit 15 liens. <br><br>  Sauvegardez les pages endommagées, rechargez la table et faites correspondre les enregistrements correspondants - après quelques dizaines de minutes, la table a été restaurée. <br><br><h2>  Hourra, nous avons gagné!  Mais est-ce vrai? </h2><br>  La vérité est.  Les données ont été restaurées, CHECKDB a cessé de verser des erreurs, même le soleil a regardé par la fenêtre.  Vous pouvez vous vanter en toute sécurité, lever un verre bien mérité d'une boisson de hussard et ... rappelez-vous que les données de la base de données ne sont pas uniquement liées à des liens vers des pages.  Il est donc temps de prendre <a href="https://docs.microsoft.com/en-US/sql/t-sql/database-console-commands/dbcc-checkconstraints-transact-sql%3Fview%3Dsql-server-ver15">DBCC CHECKCONSTRAINTS</a> et de plonger tête baissée dans la liste des clés étrangères cassées.  Mais c'est une histoire complètement différente ... <br><br><h2>  Quoi d'autre à lire sur le sujet </h2><br><ul><li>  Syntaxe de commande <a href="https://docs.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-checkdb-transact-sql%3Fview%3Dsql-server-ver15">CHECKDB</a> (Faites attention aux avertissements sur les risques possibles d'utilisation de la commande!) </li><li>  La description non officielle de <a href="https://www.sqlskills.com/blogs/paul/inside-the-storage-engine-using-dbcc-page-and-dbcc-ind-to-find-out-if-page-splits-ever-roll-back/">DBCC PAGE</a> </li><li>  Un bon <a href="https://habr.com/en/post/247373/">article</a> sur les index MS SQL qui explique beaucoup de choses intéressantes.  Y compris la façon dont les index physiques sont stockés dans la base de données </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485144/">https://habr.com/ru/post/fr485144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485126/index.html">Mu-mu, woof-woof, quack-quack: évolution de la communication acoustique</a></li>
<li><a href="../fr485128/index.html">Économisez sur les licences Mikrotik CHR</a></li>
<li><a href="../fr485132/index.html">Rejoignez le Google Play Indie Games Festival</a></li>
<li><a href="../fr485136/index.html">Suivi et surveillance d'Istio: microservices et principe d'incertitude</a></li>
<li><a href="../fr485138/index.html">Localisation d'applications: comment nous nous sommes fait des amis traduction et développement</a></li>
<li><a href="../fr485146/index.html">Salaires en informatique au second semestre 2019: selon le calculateur de carrière Habr</a></li>
<li><a href="../fr485148/index.html">Cet adorable Unicode</a></li>
<li><a href="../fr485150/index.html">Physique pour un tireur PvP mobile, ou comment nous avons refait un jeu à deux dimensions en un jeu à trois dimensions</a></li>
<li><a href="../fr485152/index.html">Stage de printemps pour développeurs mobiles chez Redmadrobot</a></li>
<li><a href="../fr485154/index.html">Comment faire un geek de marque à partir d'un développeur: un système de motivation de programmeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>