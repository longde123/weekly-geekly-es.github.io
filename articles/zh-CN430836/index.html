<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🏞️ 💣 Kotlin：不存在的静态 🤱🏻 🤵🏻 🍾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文将讨论在Kotlin中使用静态方法。 
 让我们开始吧。 
 Kotlin没有静电！ 

 官方文档中对此进行了说明。 

 看来这可以完成本文。 但是，让我怎么做？ 毕竟，如果您将Java代码插入Android Studio中的Kotlin文件中，那么智能转换器将发挥作用，将所有内容以正确的语...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin：不存在的静态</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br> 本文将讨论在Kotlin中使用静态方法。 <br> 让我们开始吧。 <br>  Kotlin没有静电！ <br><br> 官方文档中对此进行了说明。 <br><br> 看来这可以完成本文。 但是，让我怎么做？ 毕竟，如果您将Java代码插入Android Studio中的Kotlin文件中，那么智能转换器将发挥作用，将所有内容以正确的语言转换为代码，然后它将起作用！ 但是如何与Java完全兼容呢？ <br><br> 此时，任何了解Kotlin缺乏静态性的开发人员都将进入文档和论坛来解决此问题。 让我们沉思和艰苦地相聚。 在本文结尾处，我将尽量减少问题。 <a name="habracut"></a><br><br>  Java中的静态是什么？ 有： <br><ul><li> 类静态字段 </li><li> 静态类方法 </li><li> 静态嵌套类 </li></ul><br><br> 让我们做一个实验（这是我想到的第一件事）。 <br><br> 创建一个简单的Java类： <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br> 一切都很容易：在类中，我们创建了一个静态字段和一个静态方法。 我们公开进行所有操作，以进行外部访问的实验。 我们在逻辑上连接字段和方法。 <br><br> 现在创建一个空的Kotlin类，并尝试将SimpleClassJava1类的所有内容复制到其中。 我们对转换产生的问题回答“是”，然后看看发生了什么： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br> 似乎这并不是我们真正需要的。为了确保这一点，我们将把此类的字节码转换为Java代码，然后看看发生了什么： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br> 是的 一切都看起来一样。 这里没有静电的味道。 转换器简单地将签名中的static修饰符斩掉，好像它不在那里一样。 以防万一，我们将立即得出一个结论：不要盲目地信任转换器，有时它会带来不愉快的惊喜。 <br><br> 顺便说一下，大约六个月前，将相同的Java代码转换为Kotlin会显示出稍微不同的结果。 再说一遍：注意自动转换！ <br><br> 我们做进一步的实验。 <br><br> 我们进入Kotlin上的任何类，并尝试在其中调用Java类的静态元素： <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br> 这是怎么回事！ 一切都被完美调用，甚至代码的自动完成也告诉了我们一切！ 很好奇 <br><br> 现在，让我们继续进行更重要的部分。 确实，Kotlin的创造者决定以我们习惯使用它的形式摆脱静态。 为什么我们这样做，而我们不作其他讨论-网络中对此主题存在很多争议和意见。 我们将弄清楚如何使用它。 自然，我们不仅被剥夺了静电。  Kotlin为我们提供了一套可以弥补损失的工具。 它们适合在室内使用。 并承诺与Java代码完全兼容。 走吧 <br><br> 您可以意识到并开始使用的最快，最简单的方法是我们提供的替代方法，而不是静态方法-包级函数。 这是什么 这是一个不属于任何类的函数。 也就是说，这种逻辑在封装空间的某个地方处于真空中。 我们可以在包中感兴趣的任何文件中对其进行描述。 例如，将此文件命名为JustFun.kt并将其放在包<code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br> 用Java转换此文件的字节码，并查看内部： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br> 我们看到在Java中创建了一个类，该类的名称考虑了描述函数的文件的名称，并且函数本身变成了静态方法。 <br><br> 现在，如果我们想从位于<code>package com.example.mytestapplication</code> （即与该函数相同的包）中的一个类（或相同的函数）调用Kotlin中的<code>testFun</code>函数，那么我们可以简单地访问它而无需其他技巧。 如果我们从另一个包中调用它，那么我们必须导入，这对我们来说是熟悉的，并且通常适用于类： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br> 如果我们谈论从Java代码调用函数t <code>estFun</code> ，那么无论我们从哪个包调用它，我们总是需要导入该函数： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br> 该文档说，在大多数情况下，使用静态的方法而不是静态的方法，对于我们来说，使用包级函数就足够了。 但是，以我个人的观点（不一定与其他所有人的观点一致），这种实现静态的方法仅适用于小型项目。 <br> 事实证明，这些函数并不明确地属于任何类。 从视觉上看，它们的调用类似于对我们所位于的类方法（或其父类）的调用，有时可能会造成混淆。 好吧，最重要的是-包中只有一个具有该名称的函数。 即使我们尝试在另一个文件中创建相同名称的功能，系统也会给我们一个错误。 如果我们谈论大型项目，那么经常会有例如拥有相同名称的静态方法的不同工厂。 <br><br> 让我们看一下实现静态方法和字段的其他方法。 <br><br> 回想一下类的静态字段是什么。 类的此字段属于在其中声明该类的类，但不属于该类的特定实例，即，它是在整个类的单个实例中创建的。 <br><br> 为了达到这些目的，Kotlin为我们提供了一些额外的实体，这些实体也存在于单个副本中。 换句话说，单身人士。 <br><br>  Kotlin有一个object关键字来声明单调。 <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br> 此类对象被延迟初始化，即在第一次调用它们时。 <br><br> 好的，Java中也有单调，统计在哪里？ <br><br> 对于Kotlin中的任何类，我们都可以创建一个伴随对象或伴随对象。 与特定班级相关的单身人士。 可以同时使用2个<code>companion  object</code>关键字<code>companion  object</code>关键字来完成此操作： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br> 在这里，我们有<code>SimpleClassKotlin1</code>类，在其中我们使用object关键字声明了一个单例，并将其绑定到随同关键字在其中声明它的对象。 在这里，您需要注意一个事实，与之前的单例声明（MySingltoneClass）不同，该单例类的名称未指明。 如果对象被声明为同伴，则不允许其名称。 然后它将自动命名为<code>Companion</code> 。 如有必要，我们可以通过以下方式获取伴随类的实例： <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br> 但是，可以通过对附加类的属性和方法的调用来直接对其进行调用： <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br> 它看起来很像调用静态字段和类，对吗？ <br><br> 如有必要，我们可以给同伴类起一个名字，但是实际上很少这样做。 在伴随类的有趣特征中，应该指出的是，与任何普通类一样，它可以实现接口，有时可以帮助我们向代码添加更多顺序： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br> 同伴班只能有一个班。 但是，没有人禁止我们在该类内声明任何数量的单例对象，但是在这种情况下，我们必须显式指定该类的名称，并因此在引用该类的字段和方法时指定该名称。 <br><br> 说到声明为对象的类，可以说我们还可以在其中声明嵌套对象，但是不能在其中声明伴侣对象。 <br><br> 是时候看起来“在幕后”了。 参加我们的简单课程： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br> 现在在Java中反编译其字节码： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br> 我们看看发生了什么。 <br><br> 伴随对象的属性表示为我们类的静态字段： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br> 这似乎正是我们想要的。 但是，此字段是私有的，可以通过我们的伴随类的getter和setter访问，该同名类在此处作为<code>public static final class</code>呈现，其实例作为常量呈现： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  partnerFun函数并未成为我们类的静态方法（可能不会）。 它仍然是在SimpleClassKotlin1类中初始化的单例的功能。 但是，如果您考虑一下，那么从逻辑上讲这是同一件事。 <br><br> 对于<code>OneMoreObject</code>类<code>OneMoreObject</code>情况非常相似。 值得一提的是，与同伴不同，这里的类值字段没有移到<code>SimpleClassKotlin1</code>类，而是保留在<code>OneMoreObject</code> ，而且变为静态并接收生成的getter和setter。 <br><br> 让我们尝试理解以上所有内容。 <br> 如果我们想在Kotlin中实现静态字段或类方法，那么我们应该使用在此类内部声明的伴随对象。 <br> 从Kotlin调用这些字段和函数看起来与在Java中调用静态函数完全相同。 但是，如果我们尝试用Java调用这些字段和函数呢？ <br><br> 自动完成功能告诉我们可以进行以下调用： <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br> 也就是说，在这里我们从直接指示同伴的名字开始别无他法。 因此，此处使用分配给默认伴随对象的名称。 不是很方便吧？ <br><br> 尽管如此，Kotlin的创建者还是有可能使它在Java中看起来更加熟悉。 有几种方法可以做到这一点。 <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br> 如果将这个注释应用于<code>companionField</code>对象的<code>companionField</code>字段，则在将字节码转换为Java时，我们会看到静态字段<code>companionField</code>字段SimpleClassKotlin1不再是私有的，而是公共的，并且<code>companionField</code>字段的getter和setter在静态<code>Companion</code>类中消失了。 现在，我们可以以通常的方式从Java代码访问<code>companionField</code> 。 <br><br> 第二种方法是为伴随<code>lateinit</code>属性（具有较晚初始化的属性）指定<code>lateinit</code>修饰符。 不要忘记，这仅适用于var-properties，并且其类型应为非null且不应为原始类型。 好吧，不要忘记处理此类属性的规则。 <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br> 还有一种方法：我们可以通过指定修饰符const来将伴随对象的属性声明为常量。 很容易猜到这应该是一个val属性。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br> 在每种情况下，生成的Java代码将包含通常的公共静态字段，对于const，此字段也将是最终的。 当然，值得理解的是，这3种情况中的每一种都有其逻辑目的，并且只有第一种是专门为易于Java使用而设计的，其余的都像在负载中一样获得了这种“优惠”。 <br><br> 应当单独注意，const修饰符可用于对象，伴随对象的属性以及包级别的属性。 在后一种情况下，我们获得与使用包级功能相同的条件，并且具有相同的限制。  Java代码是使用类中的静态公共字段生成的，其名称考虑了我们在其中描述了常量的文件的名称。 一个包只能有一个具有指定名称的常量。 <br><br> 如果我们希望在生成Java代码时也将伴随对象的功能转换为静态方法，那么我们需要为此功能应用<code>@JvmStatic</code>批注。 <br> 也可以将<code>@JvmStatic</code>注释应用于伴随对象（仅单例对象）的属性。 在这种情况下，该属性不会变成静态字段，但是会为此属性生成一个静态的getter和setter。 为了更好的理解，请看以下Kotlin类： <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br> 在这种情况下，以下调用对Java有效： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br> 以下通话在Kotlin中有效： <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br> 很明显，对于Java，您应该使用前3个，对于Kotlin，请使用前2个。其余调用仅是有效的。 <br><br> 现在有待澄清后者。 静态嵌套类呢？ 这里的一切都很简单-Kotlin中此类的类比是没有修饰符的常规嵌套类： <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br> 将字节码转换为Java后，我们看到： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br> 确实，这就是我们所需要的。 如果我们不希望类为最终类，那么在Kotlin代码中，我们为其指定open修饰符。 我记得这是为了以防万一。 <br><br> 我想你可以总结一下。 确实，正如所说的那样，在科特林本身中，我们习惯于看到它的形式没有任何静态。 但是建议的工具集允许我们在生成的Java代码中实现所有类型的静态函数。 还提供了与Java的完全兼容性，并且我们可以直接从Kotlin调用Java类的静态字段和方法。 <br> 在大多数情况下，在Kotlin中实现统计信息需要多几行代码。 当您需要用Kotlin编写更多文章时，这也许是少数几种，或者也许是唯一的情况。 但是，您很快就习惯了。 <br> 我认为在Kotlin和Java代码共享的项目中，您可以灵活地选择所用语言。 例如，在我看来，Java更适合存储常量。 但是在这里，与其他许多方面一样，值得以常识和项目中编写代码的规则为指导。 <br><br> 在本文的结尾，有这样的信息。 也许将来在Kotlin中会出现static修饰符，从而消除了许多问题，并使开发人员的工作更轻松，代码更短。 我通过在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kotlin功能说明的</a>第17段中找到适当的文字来做出此假设。 <br> 是的，这份文件的日期是2017年5月，而院子里已经是2018年底了。 <br><br> 这就是我的全部。 我认为该主题已得到详细整理。 问题写在评论中。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430836/">https://habr.com/ru/post/zh-CN430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430826/index.html">如何发展开发经理</a></li>
<li><a href="../zh-CN430828/index.html">使用基于MELT产品的LCD显示器的经验</a></li>
<li><a href="../zh-CN430830/index.html">黑色星期五，关于购物的传统和英语成语</a></li>
<li><a href="../zh-CN430832/index.html">人类黑色星期五价格</a></li>
<li><a href="../zh-CN430834/index.html">10位演讲者的致命罪</a></li>
<li><a href="../zh-CN430838/index.html">人群营销的奇迹，或如何通过评论促进业务</a></li>
<li><a href="../zh-CN430840/index.html">如果没有严格的证据，哪些证据可以说服数学家？</a></li>
<li><a href="../zh-CN430842/index.html">我们使用区块链来打击腐败和网络欺凌</a></li>
<li><a href="../zh-CN430844/index.html">如何为UPS选择电池</a></li>
<li><a href="../zh-CN430846/index.html">新增功能：有关新Zen 2架构实施的详细信息已广为人知</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>