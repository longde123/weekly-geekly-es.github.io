<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏼 🙆🏻 📟 Cage Remote File Access System 👡 ⛴️ 👊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Systemzweck 


 Unterstützung für den Remotezugriff auf Dateien auf Computern im Netzwerk. Das System unterstützt „virtuell“ alle grundlegenden Dateiv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cage Remote File Access System</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463085/"><h3>  Systemzweck </h3><br><p>  Unterstützung für den Remotezugriff auf Dateien auf Computern im Netzwerk.  Das System unterstützt „virtuell“ alle grundlegenden Dateivorgänge (Erstellen, Löschen, Lesen, Schreiben usw.), indem Transaktionen (Nachrichten) mithilfe des TCP-Protokolls ausgetauscht werden. </p><br><h3>  Anwendungsbereiche </h3><br><p>  Die Funktionalität des Systems ist in folgenden Fällen wirksam: <br><br></p><ul><li>  in nativen Anwendungen für mobile und eingebettete Geräte (Smartphones, integrierte Steuerungssysteme usw.), die unter den Bedingungen wahrscheinlicher vorübergehender Verbindungsunterbrechungen (mit dem Offline-Betrieb) einen schnellen Zugriff auf Dateien auf Remote-Servern erfordern; </li><li>  in geladenen DBMS, wenn Anforderungen auf einigen Servern und Datenspeicher auf anderen verarbeitet werden; </li><li>  in verteilten Unternehmensnetzwerken zur Erfassung und Verarbeitung von Informationen, die einen schnellen Datenaustausch, Redundanz und Zuverlässigkeit erfordern; </li><li>  in komplexen Systemen mit Microservice-Architektur, in denen Verzögerungen beim Informationsaustausch zwischen Modulen kritisch sind. </li></ul><a name="habracut"></a><br><h3>  Struktur </h3><br><p> Das Cage-System (es gibt eine Implementierung - Beta-Version unter Python 3.7 unter Windows) besteht aus zwei Hauptteilen: <br><br></p><ol><li>  <b>Cageserver</b> - ein Dateiserverprogramm (Funktionspaket), das auf Computern im Netzwerk ausgeführt wird, die <b>Remotezugriff</b> auf Dateien benötigen. </li><li>  <b>Cage-</b> Klasse mit einer Methodenbibliothek für Client-Software, die die Codierung von Serverinteraktionen vereinfacht. </li></ol><br><h3>  Verwenden des Systems auf der Clientseite </h3><br><p>  Die Methoden der Cage-Klasse ersetzen die üblichen "routinemäßigen" Dateisystemoperationen: <i>Erstellen, Öffnen, Schließen, Löschen von</i> Dateien sowie <i>Lesen / Schreiben von Daten im Binärformat</i> (Angabe der Position und Größe der Daten).  Konzeptionell liegen diese Methoden in der Nähe der Dateifunktionen der Sprache C, bei denen das Öffnen / Schließen von Dateien "auf den Kanälen" der Eingabe / Ausgabe erfolgt. </p><br><p>  Mit anderen Worten, der Programmierer arbeitet nicht mit Methoden von "Datei" -Objekten (Klasse <b>_io</b> in Python), sondern mit Methoden der Cage-Klasse. </p><br><p>  Beim Erstellen einer Instanz des Cage-Objekts wird die anfängliche Verbindung mit dem Server (oder mehreren Servern) hergestellt, die Autorisierung anhand der Client-ID übergeben und eine Bestätigung mit der dedizierten Portnummer für alle Dateivorgänge erhalten.  Wenn ein Cage-Objekt gelöscht wird, weist es den Server an, die Verbindung zu beenden und die Dateien zu schließen.  Die Beendigung der Kommunikation kann die Server selbst initiieren. </p><br><p>  Das System verbessert die Lese- / Schreibleistung basierend auf dem Puffern häufig verwendeter Dateifragmente von Client-Programmen im Cache (Puffer) des RAM. <br>  Die Client-Software kann eine beliebige Anzahl von Cage-Objekten mit verschiedenen Einstellungen verwenden (Größe des Pufferspeichers, Größe der Blöcke beim Austausch mit dem Server usw.). </p><br><p>  Ein einzelnes Cage-Objekt kann Daten mit mehreren Dateien auf mehreren Servern austauschen.  Kommunikationsparameter (IP-Adresse oder DNS-Server, Hauptport für die Autorisierung, Pfad und Dateiname) werden beim Erstellen des Objekts festgelegt. </p><br><p>  Da jedes Cage-Objekt mit mehreren Dateien gleichzeitig arbeiten kann, wird der gemeinsam genutzte Speicherplatz zum Puffern verwendet.  Cache-Größe - Die Anzahl der Seiten und ihre Größe werden beim Erstellen eines Cage-Objekts dynamisch festgelegt.  Ein 1-GB-Cache umfasst beispielsweise 1.000 Seiten mit jeweils 1 MB oder 10.000 Seiten mit jeweils 100 KB oder 1 Million Seiten mit jeweils 1 KB.  Die Auswahl der Seitengröße und der Anzahl der Seiten ist eine spezifische Aufgabe für jede Anwendung. </p><br><p>  Sie können mehrere Cage-Objekte gleichzeitig verwenden, um je nach den Funktionen für den Zugriff auf Informationen in verschiedenen Dateien unterschiedliche Pufferspeichereinstellungen zu definieren.  Grundsätzlich wird der einfachste Pufferalgorithmus verwendet: Nachdem die angegebene Speichermenge erschöpft ist, verdrängen neue Seiten die alten Seiten nach dem Prinzip des Ruhestands mit einer minimalen Anzahl von Treffern.  Das Puffern ist besonders effektiv bei ungleichmäßiger (im statistischen Sinne) Freigabe, zum einen für verschiedene Dateien und zum anderen für Fragmente jeder Datei. </p><br><p>  Die Cage-Klasse unterstützt die Eingabe / Ausgabe nicht nur an Datenadressen (Angabe der Position und Länge des Arrays, "Ersetzen" von Dateisystemoperationen), sondern auch auf einer niedrigeren "physischen" Ebene - nach Seitenzahlen im Pufferspeicher. </p><br><p>  Für Cage-Objekte wird die ursprüngliche Funktion <i>"Ruhezustand"</i> ("Ruhezustand") unterstützt. Sie können "minimiert" werden (z. B. bei Trennung vom Server oder beim Stoppen der Anwendung usw.) und schnell in eine lokale Speicherauszugsdatei auf der Clientseite Wiederherstellung aus dieser Datei (nach Wiederaufnahme der Kommunikation, wenn Sie die Anwendung neu starten).  Dies ermöglicht es, den Datenverkehr beim Aktivieren des Client-Programms nach einem vorübergehenden "Offline" -Verfahren erheblich zu reduzieren, da sich häufig verwendete Dateifragmente bereits im Cache befinden. </p><br><p>  Cage besteht aus ca. 3.600 Codezeilen. </p><br><h3>  Prinzipien zum Erstellen von Servern </h3><br><p>  Cageserver-Dateiserver können mit einer beliebigen Anzahl von Ports gestartet werden, von denen einer (der „Haupt“) nur zur Autorisierung aller Clients verwendet wird, der Rest für den Datenaustausch.  Das Cage-Serverprogramm benötigt nur Python.  Parallel dazu kann ein Computer mit einem Dateiserver jede andere Arbeit ausführen. </p><br><p>  Der Server startet zunächst als Kombination von zwei Hauptprozessen: <br><br></p><ol><li>  <b>"Verbindungen"</b> - ein Prozess zum Ausführen von Vorgängen zum Herstellen der Kommunikation mit Clients und deren Beendigung auf Initiative des Servers; </li><li>  <b>"Operationen"</b> - ein Prozess zum Ausführen von Aufgaben (Operationen) von Clients beim Arbeiten mit Dateien sowie zum Schließen von Kommunikationssitzungen mit Clientbefehlen. </li></ol><br><p>  Beide Prozesse sind nicht synchronisiert und als endlose Zyklen des Empfangens und Sendens von Nachrichten basierend auf Multiprozesswarteschlangen, Proxyobjekten, Sperren und Sockets organisiert. <br>  Der Prozess „Verbindungen“ bietet jedem Client einen Port zum Empfangen und Senden von Daten.  Die Anzahl der Ports wird beim Start des Servers festgelegt.  Die Korrespondenz zwischen Ports und Clients wird in einem Proxy-Speicher gespeichert, der von Prozessen gemeinsam genutzt wird. </p><br><p>  Der Operations-Prozess unterstützt die Trennung von Dateiressourcen, und mehrere verschiedene Clients können Daten aus einer Datei zusammen lesen ( <i>quasi parallel</i> , da der Zugriff durch Sperren gesteuert wird), wenn dies beim ersten Öffnen durch den "ersten" Client zulässig war. <br></p><p>  Die Verarbeitung von Befehlen zum Erstellen / Löschen / Öffnen / Schließen von Dateien auf dem Server erfolgt im "Operations" -Prozess streng sequentiell unter Verwendung des Dateisubsystems des Server-Betriebssystems. </p><br><p>  Für die allgemeine Lese- / Schreibbeschleunigung werden diese Operationen in Threads ausgeführt, die durch den Prozess "Operationen" erzeugt werden.  Die Anzahl der Threads entspricht normalerweise der Anzahl der geöffneten Dateien.  Lese- / Schreibaufgaben von Clients werden an die allgemeine Warteschlange gesendet, und der erste freigegebene Thread nimmt die Aufgabe aus ihrem Kopf.  Spezielle Logik verhindert das Überschreiben von Daten im RAM des Servers. </p><br><p>  Der "Operations" -Prozess überwacht die Aktivität von Kunden und stoppt deren Service sowohl durch ihre Befehle als auch wenn das Inaktivitätszeitlimit überschritten wird. </p><br><p>  Um die Zuverlässigkeit zu gewährleisten, protokolliert Cageserver alle Transaktionen.  Ein allgemeines Journal enthält Kopien von Nachrichten von Clients mit Aufgaben zum Erstellen / Öffnen / Umbenennen / Löschen von Dateien.  Für jede Arbeitsdatei wird ein separates Protokoll erstellt, in das Kopien von Nachrichten mit Aufgaben zum Lesen und Schreiben von Daten in dieser Arbeitsdatei sowie Arrays aufgezeichneter (neuer) Daten und Arrays von Daten geschrieben werden, die beim Überschreiben zerstört wurden (Schreiben neuer Daten "über" alte) ) </p><br><p>  Diese Protokolle bieten die Möglichkeit, neue Änderungen in Sicherungen wiederherzustellen und vom aktuellen Inhalt auf den richtigen Zeitpunkt in der Vergangenheit zurückzusetzen. </p><br><p>  Cageserver besteht aus ca. 3.100 Codezeilen. </p><br><img src="https://habrastorage.org/webt/lu/yt/c-/luytc-_temnbxvrqtkbxfmqj88u.jpeg" alt="Bild"><br><h3>  Starten des Cageserver-Dateiserverprogramms </h3><br><p>  Wenn Sie im Dialogfeld starten, müssen Sie Folgendes festlegen: <br>  - Haupthafen für die Genehmigung; <br>  - Die Anzahl der Ports für den Austausch von Transaktionen mit autorisierten Clients (ab 1 oder mehr beginnt der Nummernpool mit dem nächsten nach der Nummer des Hauptports). </p><br><h3>  Verwenden der Käfigklasse </h3><br><p>  <b>Klassenkäfig</b> .  <b>Cage</b> ( <i>cage_name = "", pagesize = 0, numpages = 0, maxstrlen = 0, server_ip = {}, wait = 0, awake = False, cache_file = ""</i> ) </p><br><p>  Aus dieser Klasse werden Objekte erstellt, die mit Dateiservern interagieren und Pufferspeicher enthalten. </p><br><p>  <b><u>Parameter</u></b> </p><br><ul><li>  <b>cage_name</b> ( <i>str</i> ) - Der bedingte Name des Objekts, mit dem Clients auf der Serverseite identifiziert werden </li><li>  <b>Seitengröße</b> ( <i>int</i> ) - Größe einer Seite des Pufferspeichers (in Bytes) </li><li>  <b>numpages</b> ( <i>int</i> ) - Anzahl der Seiten des Pufferspeichers </li><li>  <b>maxstrlen</b> ( <i>int</i> ) - maximale Byte-String-Länge bei Schreib- und Leseoperationen </li><li>  <b>server_ip</b> ( <i>dict</i> ) - Ein Wörterbuch mit den Adressen der verwendeten Server, wobei der Schlüssel der bedingte Name des Servers ist (Server-ID in der Anwendung) und der Wert eine Zeichenfolge mit der Adresse: "IP-Adresse: Port" oder "DNS: Port" (übereinstimmende Namen und echte Adressen sind temporär kann geändert werden) </li><li>  <b>wait</b> ( <i>int</i> ) - Wartezeit auf eine Antwort vom Server beim Empfang von Ports (in Sekunden) </li><li>  <b>awake</b> ( <i>boolean</i> ) - Flag der Methode zum Erstellen des Objekts ( <i>False</i> - wenn ein neues Objekt erstellt wird, <i>True</i> - wenn das Objekt aus einem zuvor "minimierten" Objekt erstellt wird - standardmäßig mit der Operation "Hibernation" False) </li><li>  <b>cache_file</b> ( <i>str</i> ) - Dateiname für den Ruhezustand </li></ul><br><p>  <b><u>Methoden</u></b> </p><br><p>  Käfig.  <b>file_create</b> ( <i>Server, Pfad</i> ) - erstellt eine neue Datei </p><br><p>  Käfig.  <b>Dateiname</b> ( <i>Server, Pfad, neuer Name</i> ) - Datei umbenennen </p><br><p>  Käfig.  <b>file_remove</b> ( <i>Server, Pfad</i> ) - Löscht die Datei </p><br><p>  Käfig.  <b>open</b> ( <i>Server, Pfad, Mod</i> ) - Datei öffnen </p><br><p>  Gibt die <i>Kanalkanalnummer zurück</i> .  Der <i>Mod-</i> Parameter ist der Dateiöffnungsmodus: "wm" ist exklusiv (Lesen / Schreiben), "rs" ist schreibgeschützt und wird nur von anderen Clients geteilt, ws wird gelesen / geschrieben und nur von anderen Clients geteilt. </p><br><p>  Käfig.  <b>close</b> ( <i>fchannel</i> ) - schließt die Datei </p><br><p>  Käfig.  <b>write</b> ( <i>fchannel, begin, data</i> ) - schreibt eine Byte-Zeichenfolge in eine Datei </p><br><p>  Käfig.  <b>read</b> ( <i>fchannel, begin, len_data</i> ) - <i>Liest</i> eine Byte-Zeichenfolge aus einer Datei </p><br><p>  Käfig.  <b>put_pages</b> ( <i>fchannel</i> ) - "schiebt" alle Seiten des angegebenen Kanals, die geändert wurden, vom Puffer zum Server.  Es wird an den Stellen im Algorithmus verwendet, an denen Sie sicherstellen müssen, dass alle Vorgänge auf dem Kanal physisch in einer Datei auf dem Server gespeichert sind. </p><br><p>  Käfig.  <b>push_all</b> () - "schiebt" alle Seiten aller Kanäle für die Cage-Klasseninstanz, die geändert wurden, vom Puffer zum Server.  Es wird verwendet, wenn Sie sicherstellen müssen, dass alle Vorgänge auf allen Kanälen auf dem Server gespeichert sind. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463085/">https://habr.com/ru/post/de463085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausfälle?</a></li>
<li><a href="../de463073/index.html">QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
<li><a href="../de463083/index.html">Schutz von iPhone-Backups</a></li>
<li><a href="../de463089/index.html">Implementierung eines Unternehmenssuchsystems für Konstrukteure unter Verwendung der Low-Code-Plattform</a></li>
<li><a href="../de463095/index.html">Warum nicht SQL?</a></li>
<li><a href="../de463097/index.html">Go Produktentwicklung: Eine Projekthistorie</a></li>
<li><a href="../de463099/index.html">1000 und 1 Feedback. Wie man Feedback gibt und anderen beibringt, die Lamoda-Erfahrung</a></li>
<li><a href="../de463101/index.html">Verwalten von Hunderten von Servern für Lasttests: automatische Skalierung, benutzerdefinierte Überwachung, DevOps-Kultur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>