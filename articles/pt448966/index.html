<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¨ üõÑ üå† Aplicativo para Android na mem√≥ria. Relat√≥rio de otimiza√ß√£o para Yandex.Luncher üö® üë®‚Äçüî¨ üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O sistema leve Android Go aumentou os requisitos para aplicativos pr√©-instalados - o tamanho e a mem√≥ria usados. Enfrentamos o desafio de atender a es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicativo para Android na mem√≥ria. Relat√≥rio de otimiza√ß√£o para Yandex.Luncher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/448966/">  O sistema leve Android Go aumentou os requisitos para aplicativos pr√©-instalados - o tamanho e a mem√≥ria usados.  Enfrentamos o desafio de atender a esses requisitos.  Realizamos v√°rias otimiza√ß√µes e decidimos alterar seriamente a arquitetura de nosso shell gr√°fico - Yandex.Luncher.  O chefe da equipe de desenvolvimento de aplicativos m√≥veis Alexander Starchenko compartilhou essa experi√™ncia. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N0KQBUZE78E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Meu nome √© Alexander, sou de S√£o Petersburgo, da equipe que desenvolve o Yandex.Loncher e o Yandex.Phone.  Hoje vou contar como otimizamos a mem√≥ria no Launcher.  Primeiro, explicarei brevemente o que √© o Launcher.  A seguir, discutimos os motivos pelos quais precisamos otimizar a mem√≥ria.  Depois disso, consideraremos como medir corretamente a mem√≥ria e em que ela consiste.  Ent√£o vamos seguir praticando.  Vou falar sobre como otimizamos a mem√≥ria no Launcher e como chegamos a uma solu√ß√£o radical para o problema.  E no final, falarei sobre como monitoramos o uso da mem√≥ria, como a mantemos sob controle. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/xr/t0/xs/xrt0xsqk_pktna1g_ggaf3rd780.jpeg"><br><br>  "Launcher" ou "Launcher" - n√£o √© t√£o importante.  N√≥s da Yandex costumava cham√°-lo de Launcher e, no relat√≥rio, usarei a palavra "Launcher". <br><br><img src="https://habrastorage.org/webt/h8/dr/cg/h8drcg1kc0mm6cmr6zxew8g60gs.jpeg"><br><br>  Outro ponto importante: o Launcher √© amplamente distribu√≠do por meio de predefini√ß√µes, ou seja, quando voc√™ compra um novo telefone, o Yandex.Loncher pode se tornar o √∫nico gerenciador de aplicativos, o gerenciador de desktop dom√©stico do seu telefone. <br><br>  Agora, pelas raz√µes pelas quais precisamos otimizar a mem√≥ria.  Vou come√ßar com a nossa raz√£o.  Em suma, este √© o Android Go.  E agora mais.  No final de 2017, o Google lan√ßou o Android Oreo e sua vers√£o especial, a edi√ß√£o Android Oreo Go.  Sobre o que √© especial?  Esta vers√£o foi projetada para low-end, para telefones baratos com at√© um gigabyte de RAM.  O que mais ela √© especial?  Para aplicativos pr√©-instalados nesta vers√£o do Android, o Google apresenta requisitos adicionais.  Em particular - os requisitos para o consumo de RAM.  Grosso modo, algum tempo ap√≥s o lan√ßamento, a mem√≥ria do aplicativo √© removida e o tamanho n√£o deve exceder de 30 a 50 megabytes para o Launcher, dependendo do tamanho da tela do telefone.  30 nos menores, 50 nos tel√µes. <br><br>  Note-se tamb√©m que o Google continua a desenvolver essa √°rea e j√° existe uma edi√ß√£o do Android Pie Go. <br><br>  Que outros motivos poderiam ter para otimizar o uso da mem√≥ria?  Primeiro, √© menos prov√°vel que seu aplicativo fa√ßa o download.  Em segundo lugar, ele funcionar√° mais r√°pido, pois ser√° menos prov√°vel que funcione com o coletor de lixo e a mem√≥ria ser√° alocada com menos frequ√™ncia.  Objetos extras n√£o ser√£o criados, visualiza√ß√µes extras n√£o ser√£o infladas, etc. Indiretamente, a julgar pela nossa experi√™ncia, isso levar√° a uma diminui√ß√£o no tamanho do apk do seu aplicativo.  Tudo isso junto fornecer√° mais instala√ß√µes e melhores classifica√ß√µes no Google Play. <br><br>  Ok, agora sabemos por que otimizar a mem√≥ria.  Vamos ver por que meios medi-lo e em que consiste. <br><br><img src="https://habrastorage.org/webt/k5/ne/mc/k5nemcimfyrquzgc_jdeijvo0mq.jpeg"><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sub></sup> </h5><br>  Provavelmente muitos de voc√™s j√° viram esta foto.  Esta √© uma captura de tela do perfil do Android Studio, de uma exibi√ß√£o de mem√≥ria.  Essa ferramenta √© descrita em detalhes suficientes em developer.android.com.  Provavelmente muitos de voc√™s j√° os usaram.  Quem n√£o usou - tente. <br><br>  O que √© bom aqui?  Est√° sempre √† m√£o.  √â conveniente usar no processo de desenvolvimento.  No entanto, tem algumas desvantagens.  Nem todas as aloca√ß√µes do seu aplicativo s√£o vis√≠veis aqui.  Por exemplo, as fontes baixadas n√£o s√£o vis√≠veis aqui.  Al√©m disso, com a ajuda dessa ferramenta, √© inconveniente ver quais classes est√£o carregadas na mem√≥ria e voc√™ n√£o pode us√°-la no modo autom√°tico, ou seja, n√£o pode configurar algum tipo de teste autom√°tico com base no perfil do Android Studio. <br><br><img src="https://habrastorage.org/webt/-g/hh/gz/-ghhgzcyruqxpu3trjt_ipssimi.jpeg"><h5>  <sup><sub>Links do slide: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a></sub></sup> </h5><br>  A ferramenta a seguir existe desde o desenvolvimento do Android no Eclipse, √© o Memory Analyzer, MAT, para abreviar.  Ele √© fornecido como um aplicativo independente e √© compat√≠vel com despejos de mem√≥ria que voc√™ pode salvar no Android Studio. <br><br>  Para fazer isso, voc√™ precisar√° usar um pequeno utilit√°rio, um conversor profissional.  Ele vem com a edi√ß√£o Android Go e tem v√°rias vantagens.  Por exemplo, ele pode criar caminhos para ra√≠zes gs.  Nos ajudou muito a ver exatamente quais classes s√£o carregadas pelo Launcher e quando elas s√£o carregadas.  N√£o foi poss√≠vel fazer isso usando o Android Studio Profiler. <br><br><img src="https://habrastorage.org/webt/4r/uj/gz/4rujgzsgzvpcrxk6f5izyljrb8y.jpeg"><br><br>  A pr√≥xima ferramenta √© o utilit√°rio dumpsys, especificamente dumpsys meminfo.  Aqui voc√™ v√™ parte da sa√≠da deste comando.  Ele fornece um conhecimento relativamente alto do consumo de mem√≥ria.  No entanto, tem certas vantagens.  √â conveniente usar no modo autom√°tico.  Voc√™ pode configurar facilmente testes que simplesmente chamam este comando.  Tamb√©m mostra a mem√≥ria imediatamente para todos os processos.  E mostra todos os locais.  At√© onde sabemos, o Google usa o valor da mem√≥ria dessa ferramenta no processo de teste. <br><br>  Vamos usar um exemplo de sa√≠da para descrever brevemente em que consiste a mem√≥ria do aplicativo.  O primeiro √© o Java Heap, todos os locais do seu c√≥digo Java e Kotlin.  Geralmente esta se√ß√£o √© grande o suficiente.  Em seguida √© a pilha nativa.  Aqui est√£o as aloca√ß√µes do c√≥digo nativo.  Mesmo se voc√™ n√£o usar explicitamente o c√≥digo nativo em seu aplicativo, as aloca√ß√µes estar√£o presentes aqui, pois muitos objetos Android - a mesma exibi√ß√£o - alocam mem√≥ria nativa.  A pr√≥xima se√ß√£o √© C√≥digo.  Tudo relacionado ao c√≥digo chega aqui: bytecode, fontes.  O c√≥digo tamb√©m pode ser muito grande se voc√™ usar muitas bibliotecas de terceiros n√£o otimizadas.  A seguir, √© apresentada a pilha de software Java e c√≥digo nativo, geralmente pequena.  Em seguida, vem a mem√≥ria gr√°fica.  Isso inclui Superf√≠cie, texturas, ou seja, a mem√≥ria que se espalha entre a CPU e a GPU √© usada para renderiza√ß√£o.  A seguir, a se√ß√£o Outros Privados.  Isso inclui tudo o que n√£o caiu nas se√ß√µes acima, tudo o que o sistema n√£o p√¥de espalhar sobre elas.  Geralmente, esses s√£o alguns tipos de aloca√ß√µes nativas.  A seguir, √© a se√ß√£o Sistema, essa √© a parte da mem√≥ria do sistema atribu√≠da ao seu aplicativo. <br><br>  E no final, temos TOTAL, esta √© a soma de todas as se√ß√µes listadas.  Queremos reduzi-lo. <br><br><img src="https://habrastorage.org/webt/py/uo/bk/pyuobklgdmuxby3witoq9fltrve.jpeg"><br><br>  O que mais √© importante saber sobre a medi√ß√£o de mem√≥ria?  Primeiro de tudo, nosso aplicativo n√£o controla totalmente todas as aloca√ß√µes.  Ou seja, n√≥s, como desenvolvedores, n√£o temos controle total sobre qual c√≥digo ser√° baixado. <br><br>  O seguinte.  A mem√≥ria do aplicativo pode saltar bastante.  Durante o processo de medi√ß√£o, voc√™ pode observar fortes diferen√ßas nas leituras.  Isso pode ser devido ao tempo gasto, bem como a v√°rios cen√°rios.  Nesse sentido, quando otimizamos a mem√≥ria, analisamos, √© muito importante fazer isso nas mesmas condi√ß√µes.  Idealmente, no mesmo dispositivo.  Melhor ainda, se voc√™ tiver a op√ß√£o de ligar para o Garbage Collector. <br><br>  √ìtimo.  Sabemos por que precisamos otimizar a mem√≥ria, como medi-la corretamente e em que consiste.  Vamos praticar, e eu vou lhe dizer como otimizamos a mem√≥ria no Launcher. <br><br><img src="https://habrastorage.org/webt/zy/t3/1q/zyt31qv6xboliaaetsqazvim8bi.jpeg"><br><br>  Essa foi a situa√ß√£o a princ√≠pio.  T√≠nhamos tr√™s processos, que no total alocavam cerca de 120 megabytes.  Isso √© quase quatro vezes mais do que gostar√≠amos de receber. <br><br><img src="https://habrastorage.org/webt/xe/yt/tz/xeyttza29z1cbtkjhtwhanq2owm.jpeg"><br><br>  Em rela√ß√£o √† aloca√ß√£o do processo principal, havia uma grande se√ß√£o do Java Heap, muitos gr√°ficos, c√≥digo grande e um Native Heap bastante grande. <br><br><img src="https://habrastorage.org/webt/yl/8o/d6/yl8od64p4hs9jorsk5iftlexh-s.jpeg"><br><br>  Primeiro, abordamos o problema de maneira bastante ing√™nua e decidimos seguir algumas recomenda√ß√µes do Google a partir de alguns recursos, tentar resolver o problema rapidamente.  Chamamos aten√ß√£o para os m√©todos sint√©ticos que s√£o gerados durante o processo de compila√ß√£o.  T√≠nhamos mais de 2 mil deles.  Em algumas horas, todos os exclu√≠mos e removemos a mem√≥ria. <br><br><img src="https://habrastorage.org/webt/-n/k5/sx/-nk5sxehumnmvysfxp79-yjecq0.jpeg"><br><br>  E eles obtiveram um ganho de cerca de um ou dois megabytes na se√ß√£o de c√≥digo.  √ìtimo. <br><br>  Em seguida, voltamos nossa aten√ß√£o para enum.  Como voc√™ sabe, enum √© uma classe.  E, como o Google finalmente admitiu, o enum n√£o √© muito eficiente em termos de mem√≥ria.  Traduzimos todo o enum para InDef e StringDef.  Aqui voc√™ pode contestar que o ProgArt ajudar√° aqui.  Mas, de fato, o ProgArt n√£o substituir√° todo o enum por tipos primitivos.  √â melhor fazer voc√™ mesmo.  A prop√≥sito, tivemos mais de 90 enum, bastante. <br><br><img src="https://habrastorage.org/webt/cs/na/lo/csnalohjmgwggcngzvyhk3p57wo.jpeg"><br><br>  Essa otimiza√ß√£o j√° levou dias, j√° que a maioria tinha que ser feita manualmente, e ganhamos cerca de tr√™s a seis megabytes na se√ß√£o heap Java. <br><br>  Em seguida, chamamos a aten√ß√£o para a cole√ß√£o.  Usamos cole√ß√µes Java bastante padr√£o, como o HashMap.  T√≠nhamos mais de 150 deles e todos foram criados no in√≠cio do Launcher.  Os substitu√≠mos por SparseArray, SimpleArrayMap e ArrayMap e come√ßamos a criar cole√ß√µes com um tamanho predeterminado para que os slots vazios n√£o fossem alocados.  Ou seja, passamos o tamanho da cole√ß√£o para o construtor. <br><br><img src="https://habrastorage.org/webt/dl/rt/k9/dlrtk9aikfqhhp1d5mduorrq2wy.jpeg"><br><br>  Isso tamb√©m deu um certo ganho, e essa otimiza√ß√£o tamb√©m levou dias, a maioria dos quais fizemos manualmente. <br><br>  Depois, demos um passo mais espec√≠fico.  Vimos que temos tr√™s processos.  Como sabemos, mesmo um processo vazio no Android consome cerca de 8 a 10 megabytes de mem√≥ria, bastante. <br><br>  Detalhes sobre os processos foram contados pelo meu colega Arthur Vasilov.  N√£o faz muito tempo, na confer√™ncia Mosdroid, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foi o seu relat√≥rio</a> , tamb√©m sobre o Android Go. <br><br><img src="https://habrastorage.org/webt/16/i-/z-/16i-z-on0lf0lvdu5vk6fv0yilm.jpeg"><br><br>  O que t√≠nhamos depois dessas otimiza√ß√µes?  No dispositivo de teste principal, observamos o consumo de mem√≥ria na regi√£o de 80 a 100 megabytes, n√£o ruim o suficiente, mas ainda n√£o o suficiente.  Come√ßamos a medir a mem√≥ria em outros dispositivos.  Descobrimos que em dispositivos mais r√°pidos, o consumo de mem√≥ria era muito maior.  Aconteceu que t√≠nhamos muitas inicializa√ß√µes pendentes diferentes.  Depois de algum tempo, o Launcher aumentou algumas visualiza√ß√µes, iniciou algumas bibliotecas, etc. <br><br><img src="https://habrastorage.org/webt/qh/ql/ci/qhqlcieho2jhn-xhewlehklbg_s.jpeg"><br><br>  O que fizemos?  Primeiro, analisamos a visualiza√ß√£o, todos os layouts.  Removidas todas as visualiza√ß√µes que foram infladas com a visibilidade perdida.  Eles os colocaram em layouts separados, come√ßaram a infl√°-los programaticamente.  Aqueles que n√£o precis√°vamos, geralmente par√°vamos de inflar at√© o momento em que o usu√°rio precisava deles.  Prestamos aten√ß√£o √† otimiza√ß√£o de imagens.  Paramos de carregar imagens que o usu√°rio n√£o v√™ no momento.  No caso do Launcher, estas eram imagens-√≠cones de aplicativos na lista completa de aplicativos.  At√© a sua abertura, n√£o os enviamos.  Isso nos deu uma vit√≥ria muito boa na se√ß√£o de gr√°ficos. <br><br>  Tamb√©m verificamos nossos caches de imagem na mem√≥ria.  Verificou-se que nem todas eram √≥timas; nem todas as imagens correspondentes √† tela do telefone em que o Launcher estava executando estavam armazenadas na mem√≥ria. <br><br>  Depois disso, come√ßamos a analisar a se√ß√£o de c√≥digo e percebemos que t√≠nhamos muitas classes bastante pesadas de algum lugar.  Descobriu-se que estas s√£o principalmente classes de biblioteca.  Encontramos algumas coisas estranhas em algumas bibliotecas.  Uma das bibliotecas criou o HashMap e, em um inicializador est√°tico, o obstruiu com um n√∫mero suficientemente grande de objetos. <br><br><img src="https://habrastorage.org/webt/l4/vz/tf/l4vztfbwdffshzw5jf9ltshzjbs.jpeg"><br><br>  Outra biblioteca tamb√©m carregou arquivos de √°udio em um bloco est√°tico, que ocupava cerca de 700 kilobytes de mem√≥ria. <br><br><img src="https://habrastorage.org/webt/uz/ku/-p/uzku-pmqzppvtwsdiexoxm3cs6q.jpeg"><br><br>  Paramos de inicializar essas bibliotecas e come√ßamos a trabalhar com elas somente quando essas fun√ß√µes s√£o realmente necess√°rias aos usu√°rios.  Todas essas otimiza√ß√µes levaram v√°rias semanas.  Testamos muito, verificamos que n√£o apresentamos problemas adicionais.  Mas tamb√©m obtivemos uma vit√≥ria bastante boa, cerca de 25 dos 40 megabytes nas se√ß√µes Native, Heap, Code e Java Heap. <br><br>  Mas isso n√£o foi suficiente.  O consumo de mem√≥ria ainda n√£o caiu para 30 megabytes.  Parecia que t√≠nhamos esgotado todas as op√ß√µes para algumas otimiza√ß√µes autom√°ticas e seguras simples. <br><br>  Decidimos considerar solu√ß√µes radicais.  Aqui vimos duas op√ß√µes - a cria√ß√£o de um aplicativo lite separado ou o processamento da arquitetura do Launcher e a transi√ß√£o para uma arquitetura modular com a capacidade de fazer montagens do Launcher sem m√≥dulos adicionais.  A primeira op√ß√£o √© bastante longa e cara.  Provavelmente, a cria√ß√£o de um aplicativo resultar√° em um aplicativo separado completo para voc√™, que precisar√° ser totalmente suportado e desenvolvido.  Por outro lado, a op√ß√£o com uma arquitetura modular tamb√©m √© bastante cara, arriscada, mas ainda √© mais r√°pida, j√° que voc√™ j√° est√° trabalhando com uma base de c√≥digo conhecida, j√° possui um conjunto de testes de unidade autom√°ticos, testes de integra√ß√£o e testes manuais casos. <br><br>  Note-se que, independentemente da op√ß√£o escolhida, voc√™ ter√° que abandonar parte dos recursos do seu aplicativo na vers√£o para Android Go.  Isso √© normal.  O Google faz o mesmo em seus aplicativos Go. <br><br>  Como resultado, implementando uma arquitetura modular, resolvemos com seguran√ßa nossos problemas de mem√≥ria e come√ßamos a passar em testes mesmo em dispositivos com uma tela pequena, ou seja, reduzimos o consumo de mem√≥ria para 30 megabytes. <br><br><img src="https://habrastorage.org/webt/jy/n1/hc/jyn1hce7pywfquvccv4w8n1bfl4.jpeg"><br><br>  Um pouco sobre o monitoramento de mem√≥ria, sobre como mantemos o uso da mem√≥ria sob controle.  Antes de tudo, configuramos analisadores est√°ticos, o mesmo erro no caso de usar enum, criar m√©todos sint√©ticos ou usar cole√ß√µes n√£o otimizadas. <br><br>  Ainda mais dif√≠cil.  Configuramos testes de integra√ß√£o autom√°tica que executam o Launcher em emuladores e depois de um tempo diminuem o consumo de mem√≥ria.  Se for muito diferente da compila√ß√£o anterior, avisos e alertas ser√£o acionados.  Come√ßamos a investigar o problema e n√£o publicamos altera√ß√µes que aumentam o uso da mem√≥ria do Launcher. <br><br>  Para resumir.  Existem v√°rias ferramentas para monitorar a mem√≥ria, medindo a mem√≥ria para uma opera√ß√£o r√°pida e eficiente.  √â melhor us√°-los todos, pois eles t√™m seus pr√≥s e contras. <br><br>  Solu√ß√µes radicais com arquitetura modular se mostraram mais confi√°veis ‚Äã‚Äãe eficientes para n√≥s.  Lamentamos que n√£o os tenhamos imediatamente.  Mas os passos sobre os quais falei no in√≠cio do relat√≥rio n√£o foram em v√£o.  Percebemos que a vers√£o principal do aplicativo come√ßou a otimizar o uso da mem√≥ria, para trabalhar mais rapidamente.  Obrigada </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448966/">https://habr.com/ru/post/pt448966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448956/index.html">Raiva do c√≥digo: programadores e negatividade</a></li>
<li><a href="../pt448958/index.html">Como a Amazon escolhe suas ofertas aparentemente aleat√≥rias do dia. E por que os vendedores est√£o t√£o atr√°s deles</a></li>
<li><a href="../pt448960/index.html">Tecnologia XR ilimitada na era da computa√ß√£o distribu√≠da</a></li>
<li><a href="../pt448962/index.html">A efic√°cia do funil de marketing AARRR</a></li>
<li><a href="../pt448964/index.html">A torradeira oferece aos usu√°rios mais direitos</a></li>
<li><a href="../pt448968/index.html">PHP ass√≠ncrono. Porque</a></li>
<li><a href="../pt448970/index.html">Autentica√ß√£o de dois fatores para SSH</a></li>
<li><a href="../pt448974/index.html">Abordagem sem servidor para o r√°pido desenvolvimento de um servi√ßo de v√≠deo em funcionamento</a></li>
<li><a href="../pt448976/index.html">Eventos de primavera Gamedev em HSE</a></li>
<li><a href="../pt448980/index.html">Nosso primeiro almo√ßo juntos: por que e como passamos o dia do teste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>