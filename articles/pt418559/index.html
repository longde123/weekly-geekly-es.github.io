<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ üöÅ ü§õüèæ NL2API: Criando interfaces de linguagem natural para a API da Web üëßüèº üèîÔ∏è #‚É£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Mais recentemente, falamos brevemente sobre interfaces de linguagem natural. Bem, hoje n√£o temos brevemente. Abaixo, voc√™ encontrar√° uma his...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NL2API: Criando interfaces de linguagem natural para a API da Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418559/">  Ol√° Habr!  Mais recentemente, falamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">brevemente</a> sobre interfaces de linguagem natural.  Bem, hoje n√£o temos brevemente.  Abaixo, voc√™ encontrar√° uma hist√≥ria completa sobre a cria√ß√£o do NL2API para a Web-API.  Nossos colegas da Research tentaram uma abordagem √∫nica para coletar dados de treinamento para a estrutura.  Inscreva-se agora! <br><br><img src="https://habrastorage.org/webt/ry/bd/kj/rybdkjnazdjarwxlrggugof4pja.jpeg"><a name="habracut"></a><br><br><h2>  Anota√ß√£o </h2><br>  √Ä medida que a Internet evolui para uma arquitetura orientada a servi√ßos, as interfaces de software (APIs) est√£o se tornando cada vez mais importantes como forma de fornecer acesso a dados, servi√ßos e dispositivos.  Estamos trabalhando na quest√£o da cria√ß√£o de uma interface de linguagem natural para a API (NL2API), com foco em servi√ßos da web.  As solu√ß√µes NL2API t√™m muitos benef√≠cios em potencial, por exemplo, ajudando a simplificar a integra√ß√£o de servi√ßos da Web em assistentes virtuais. <br><br>  Oferecemos a primeira plataforma abrangente (estrutura) que permite criar NL2API para uma API da web espec√≠fica.  A principal tarefa √© coletar dados para treinamento, ou seja, os pares "comando NL - chamada de API", permitindo que o NL2API estude a sem√¢ntica de ambos os comandos NL que n√£o possuem um formato estritamente definido e chamadas formalizadas √† API.  Oferecemos nossa pr√≥pria abordagem exclusiva para coletar dados de treinamento para NL2API usando crowdsourcing - atraindo muitos trabalhadores remotos para gerar v√°rias equipes de NL.  Otimizamos o pr√≥prio processo de crowdsourcing para reduzir custos. <br><br>  Em particular, oferecemos um modelo probabil√≠stico hier√°rquico fundamentalmente novo que nos ajudar√° a distribuir o or√ßamento para crowdsourcing, principalmente entre as chamadas de API de alto valor para o aprendizado da NL2API.  Aplicamos nossa estrutura a APIs reais e mostramos que ela permite coletar dados de treinamento de alta qualidade a um custo m√≠nimo, al√©m de criar NL2API de alto desempenho a partir do zero.  Tamb√©m demonstramos que nosso modelo de crowdsourcing melhora a efici√™ncia desse processo, ou seja, os dados de treinamento coletados em sua estrutura fornecem um desempenho mais alto de NL2API, o que excede significativamente a linha de base. <br><br><h2>  1. Introdu√ß√£o </h2><br>  As interfaces de programa√ß√£o de aplicativos (APIs) est√£o desempenhando um papel cada vez mais importante no mundo virtual e f√≠sico, gra√ßas ao desenvolvimento de tecnologias como arquitetura orientada a servi√ßos (SOA), computa√ß√£o em nuvem e Internet das Coisas (IoT).  Por exemplo, os servi√ßos web hospedados na nuvem (clima, esportes, finan√ßas, etc.) por meio da API da web fornecem dados e servi√ßos aos usu√°rios finais, e os dispositivos IoT permitem que outros dispositivos de rede usem suas funcionalidades. <br><br><img src="https://habrastorage.org/webt/tc/kd/fb/tckdfbxc1i4zg4km413wnducl_4.png"><br>  <i>Figura 1. Os pares ‚Äúcomando NL (esquerda) e chamada de API (direita)‚Äù reunidos</i> <i><br></i>  <i>nossa estrutura e compara√ß√£o com o IFTTT.</i>  <i>GET-Messages e GET-Events s√£o duas APIs da web para localizar emails e eventos de calend√°rio, respectivamente.</i>  <i>A API pode ser chamada com v√°rios par√¢metros.</i>  <i>N√≥s nos concentramos em chamadas de API totalmente parametrizadas, enquanto o IFTTT √© limitado a APIs com par√¢metros simples.</i> <br><br>  Normalmente, as APIs s√£o usadas em uma variedade de software: aplicativos de desktop, sites e aplicativos m√≥veis.  Eles tamb√©m atendem aos usu√°rios por meio de uma interface gr√°fica do usu√°rio (GUI).  A GUI fez uma grande contribui√ß√£o para a populariza√ß√£o dos computadores, mas, √† medida que a tecnologia de computadores evoluiu, suas muitas limita√ß√µes se manifestam cada vez mais.  Por um lado, √† medida que os dispositivos se tornam menores, mais m√≥veis e inteligentes, os requisitos para exibi√ß√£o gr√°fica na tela aumentam constantemente, por exemplo, no que diz respeito a dispositivos port√°teis ou dispositivos conectados √† IoT. <br><br>  Por outro lado, os usu√°rios precisam se adaptar a v√°rias GUIs especializadas para v√°rios servi√ßos e dispositivos.  √Ä medida que o n√∫mero de servi√ßos e dispositivos dispon√≠veis aumenta, o custo do treinamento e da adapta√ß√£o do usu√°rio tamb√©m aumenta.  As interfaces de linguagem natural (NLIs), como os assistentes virtuais Apple Siri e Microsoft Cortana, tamb√©m chamadas de interfaces de conversa√ß√£o ou de di√°logo (CUIs), demonstram um potencial significativo como uma ferramenta inteligente √∫nica para uma ampla gama de servi√ßos e dispositivos de servidor. <br><br>  Neste artigo, consideramos o problema de criar uma interface de linguagem natural para a API (NL2API).  Mas, diferentemente dos assistentes virtuais, esses n√£o s√£o NLIs de uso geral, <br>  estamos desenvolvendo abordagens para criar NLIs para APIs da web espec√≠ficas, ou seja, APIs de servi√ßos da web, como o servi√ßo multiesporte ESPN1.  Esses NL2APIs podem resolver o problema de escalabilidade dos NLIs de uso geral, permitindo o desenvolvimento distribu√≠do.  A utilidade de um assistente virtual depende em grande parte da amplitude de seus recursos, ou seja, do n√∫mero de servi√ßos que ele suporta. <br><br>  No entanto, integrar servi√ßos da Web em um assistente virtual, um de cada vez, √© um trabalho incrivelmente minucioso.  Se os provedores de servi√ßos da web individuais tivessem uma maneira barata de criar NLIs para suas APIs, os custos de integra√ß√£o seriam significativamente reduzidos.  Um assistente virtual n√£o precisaria processar interfaces diferentes para diferentes servi√ßos da web.  Seria o suficiente para ele simplesmente integrar NL2APIs individuais, que alcan√ßam uniformidade gra√ßas √† linguagem natural.  Por outro lado, o NL2API tamb√©m pode simplificar a descoberta de servi√ßos da Web e sistemas de recomenda√ß√£o e assist√™ncia de programa√ß√£o para APIs, eliminando a necessidade de lembrar o grande n√∫mero de APIs da Web dispon√≠veis e sua sintaxe. <br><br>  <b>Exemplo 1.</b> Dois exemplos s√£o mostrados na Figura 1. A API pode ser chamada com v√°rios par√¢metros.  No caso da API de pesquisa de email, os usu√°rios podem filtrar email por propriedades espec√≠ficas ou procurar emails por palavras-chave.  A principal tarefa do NL2API √© mapear comandos NL para as chamadas de API correspondentes. <br><br>  <b>Desafio.</b>  A coleta de dados de treinamento √© uma das tarefas mais importantes associadas √† pesquisa no desenvolvimento de interfaces NLI e sua aplica√ß√£o pr√°tica.  As NLIs usam dados de treinamento controlados, que no caso da NL2API consistem em pares de "comando NL - chamada de API" para estudar a sem√¢ntica e mapear inequivocamente os comandos NL para as representa√ß√µes formalizadas correspondentes.  A linguagem natural √© muito flex√≠vel, para que os usu√°rios possam descrever a chamada √† API de maneiras sintaticamente diferentes, ou seja, a parafraseando ocorre. <br><br>  Considere o segundo exemplo na Figura 1. Os usu√°rios podem reformular esta pergunta da seguinte maneira: ‚ÄúOnde ser√° a pr√≥xima reuni√£o‚Äù ou ‚ÄúEncontre um local para a pr√≥xima reuni√£o‚Äù.  Portanto, √© extremamente importante coletar dados de treinamento suficientes para que o sistema reconhe√ßa ainda mais essas op√ß√µes.  Os NLIs existentes geralmente aderem ao princ√≠pio "melhor poss√≠vel" na coleta de dados.  Por exemplo, o an√°logo mais pr√≥ximo de nossa metodologia para comparar comandos NL com chamadas de API usa o conceito de IF-This-Then-That (IFTTT) - "se for, ent√£o" (Figura 1).  Os dados de treinamento v√™m diretamente do site da IFTTT. <br><br>  No entanto, se a API n√£o for suportada ou n√£o for totalmente suportada, n√£o h√° como corrigir a situa√ß√£o.  Al√©m disso, os dados de treinamento coletados dessa maneira n√£o s√£o aplic√°veis ‚Äã‚Äãao suporte a comandos avan√ßados com v√°rios par√¢metros.  Por exemplo, analisamos os logs de chamadas anonimizados da API da Microsoft para procurar e-mails para o m√™s e descobrimos que cerca de 90% deles usam dois ou tr√™s par√¢metros (aproximadamente a mesma quantidade), e esses par√¢metros s√£o bastante diversos.  Portanto, nos esfor√ßamos para fornecer suporte completo √† parametriza√ß√£o de API e implementar comandos avan√ßados de NL.  O problema de implantar um processo ativo e personaliz√°vel de coleta de dados de treinamento para uma API espec√≠fica atualmente permanece sem solu√ß√£o. <br><br>  Os problemas do uso do NLI em combina√ß√£o com outras representa√ß√µes formalizadas, como bancos de dados relacionais, bases de conhecimento e tabelas da web, foram bem trabalhados, embora quase nenhuma aten√ß√£o tenha sido dada ao desenvolvimento do NLI para APIs da web.  Oferecemos a primeira plataforma abrangente (estrutura) que permite criar NL2API para uma API da web espec√≠fica do zero.  Na implementa√ß√£o da API da web, nossa estrutura inclui tr√™s est√°gios: (1) Apresenta√ß√£o.  O formato original da API da web HTTP cont√©m muitos detalhes redundantes e, portanto, perturbadores do ponto de vista da NLI. <br><br>  Sugerimos o uso de uma representa√ß√£o sem√¢ntica intermedi√°ria para a API da Web, para n√£o sobrecarregar o NLI com informa√ß√µes desnecess√°rias.  (2) Um conjunto de dados de treinamento.  Oferecemos uma nova abordagem para obter dados de treinamento controlados com base no crowdsourcing.  (3) NL2API.  Tamb√©m oferecemos dois modelos NL2API: um modelo de extra√ß√£o baseado em linguagem e um modelo de rede neural recorrente (Seq2Seq). <br><br>  Um dos principais resultados t√©cnicos deste trabalho √© uma abordagem fundamentalmente nova para a coleta ativa de dados de treinamento para NL2API com base em crowdsourcing - usamos executivos remotos para anotar chamadas de API ao compar√°-las com comandos de NL.  Isso permite que voc√™ alcance tr√™s objetivos de design, fornecendo: (1) Personaliza√ß√£o.  Voc√™ deve poder especificar quais par√¢metros para qual API usar e quantos dados de treinamento coletar.  (2) baixo custo.  Os servi√ßos dos trabalhadores de crowdsourcing s√£o uma ordem de magnitude mais barata que os servi√ßos de especialistas especializados, e √© por isso que eles devem ser contratados.  (3) de alta qualidade.  A qualidade dos dados de treinamento n√£o deve ser reduzida. <br><br>  Ao projetar essa abordagem, dois problemas principais surgem.  Primeiro, as chamadas de API com parametriza√ß√£o avan√ßada, como na Figura 1, s√£o incompreens√≠veis para o usu√°rio m√©dio; portanto, voc√™ precisa decidir como formular o problema da anota√ß√£o para que os funcion√°rios do crowdsourcing possam lidar com ele facilmente.  Come√ßamos desenvolvendo uma representa√ß√£o sem√¢ntica intermedi√°ria para a API da web (consulte a se√ß√£o 2.2), o que nos permite gerar chamadas de API com os par√¢metros necess√°rios. <br><br>  Depois, pensamos na gram√°tica para converter automaticamente cada chamada de API em um comando NL can√¥nico, o que pode ser bastante complicado, mas ficar√° claro para o funcion√°rio comum de crowdsourcing (consulte a se√ß√£o 3.1).  Os artistas s√≥ ter√£o que reformular a equipe can√¥nica para torn√°-la mais natural.  Essa abordagem permite evitar muitos erros na coleta de dados de treinamento, uma vez que a tarefa de reformular √© muito mais simples e mais compreens√≠vel para o funcion√°rio comum de crowdsourcing. <br><br>  Em segundo lugar, voc√™ precisa entender como definir e anotar apenas as chamadas de API que s√£o de valor real para aprender NL2API.  A ‚Äúexplos√£o combinat√≥ria‚Äù que surge durante a parametriza√ß√£o leva ao fato de que o n√∫mero de chamadas, mesmo para uma API, pode ser bastante grande.  N√£o faz sentido anotar todas as chamadas.  Oferecemos um modelo probabil√≠stico hier√°rquico fundamentalmente novo para a implementa√ß√£o do processo de crowdsourcing (consulte a se√ß√£o 3.2).  Por analogia com a modelagem de linguagem com o objetivo de obter informa√ß√µes, assumimos que os comandos NL s√£o gerados com base nas chamadas de API correspondentes, portanto o modelo de linguagem deve ser usado para cada chamada de API para registrar esse processo "generativo". <br><br>  Nosso modelo √© baseado na natureza composicional das chamadas de API ou representa√ß√µes formalizadas da estrutura sem√¢ntica como um todo.  Em um n√≠vel intuitivo, se uma chamada de API consistir em chamadas mais simples (por exemplo, "e-mails n√£o lidos sobre um candidato ao curso de ci√™ncias" = "e-mails n√£o lidos" + "e-mails para um candidato ao curso de ci√™ncias", podemos constru√≠-lo modelo de linguagem a partir de chamadas simples √† API, mesmo sem anota√ß√£o, portanto, anotando um pequeno n√∫mero de chamadas √† API, podemos calcular o modelo de linguagem para todos os outros. <br><br>  Obviamente, os modelos de linguagem calculados est√£o longe do ideal, caso contr√°rio, j√° ter√≠amos resolvido o problema de criar o NL2API.  No entanto, essa extrapola√ß√£o do modelo de linguagem para chamadas de API n√£o anotadas nos fornece uma vis√£o hol√≠stica de todo o espa√ßo das chamadas de API, bem como a intera√ß√£o da linguagem natural e das chamadas de API, o que nos permite otimizar o processo de crowdsourcing.  Na Se√ß√£o 3.3, descrevemos um algoritmo para anotar seletivamente chamadas de API para ajudar a tornar as chamadas de API mais distingu√≠veis, ou seja, para maximizar a discrep√¢ncia entre seus modelos de idioma. <br><br>  Aplicamos nossa estrutura a duas APIs implantadas do pacote Microsoft Graph API2.  Demonstramos que dados de treinamento de alta qualidade podem ser coletados a um custo m√≠nimo, se a abordagem proposta for usada3.  Tamb√©m mostramos que nossa abordagem melhora o crowdsourcing.  A custos semelhantes, coletamos melhores dados de treinamento, excedendo significativamente a linha de base.  Como resultado, nossas solu√ß√µes NL2API oferecem maior precis√£o. <br><br>  Em geral, nossa principal contribui√ß√£o inclui tr√™s aspectos: <br><br><ul><li>  Fomos um dos primeiros a estudar os problemas do NL2API e propusemos uma estrutura abrangente para a cria√ß√£o do NL2API do zero. </li><li>  Propusemos uma abordagem √∫nica para a coleta de dados de treinamento usando crowdsourcing e um modelo probabil√≠stico hier√°rquico fundamentalmente novo para otimizar esse processo. </li><li>  Aplicamos nossa estrutura a APIs da Web reais e demonstramos que uma solu√ß√£o NL2API suficientemente eficaz pode ser criada do zero. </li></ul><br><img src="https://habrastorage.org/webt/t4/fs/vl/t4fsvlxndjmziwbvzjh2rwqut2c.png"><br>  <i>Tabela 1. Par√¢metros de consulta OData.</i> <br><br><h2>  Pre√¢mbulo </h2><br><h4>  API RESTful </h4><br>  Recentemente, as APIs da web que est√£o em conformidade com o estilo de arquitetura REST, ou seja, a API RESTful, est√£o se tornando cada vez mais populares devido √† sua simplicidade.  APIs RESTful tamb√©m s√£o usadas em smartphones e dispositivos IoT.  As APIs Restful funcionam com recursos endere√ßados via URIs e fornecem acesso a esses recursos para uma ampla gama de clientes usando comandos HTTP simples: GET, PUT, POST, etc. Trabalharemos principalmente com a API RESTful, mas os m√©todos b√°sicos podem ser usados e outras APIs. <br><br>  Por exemplo, considere o popular Open Data Protocol (OData) para a API RESTful e duas APIs da web do pacote Microsoft Graph API (Figura 1), que, respectivamente, s√£o usadas para procurar emails e eventos de calend√°rio do usu√°rio.  Recursos no OData s√£o entidades, cada uma delas associada a uma lista de propriedades.  Por exemplo, a entidade Mensagem - um email - possui propriedades como assunto (assunto), de (de), isRead (leitura), receivedDateTime (data e hora do recebimento), etc. <br><br>  Al√©m disso, o OData define um conjunto de par√¢metros de consulta, permitindo executar manipula√ß√µes avan√ßadas nos recursos.  Por exemplo, o par√¢metro FILTER permite procurar e-mails de um remetente espec√≠fico ou cartas recebidas em uma data espec√≠fica.  Os par√¢metros de solicita√ß√£o que usaremos s√£o apresentados na Tabela 1. Chamamos cada combina√ß√£o do comando HTTP e da entidade (ou conjunto de entidades) como uma API, por exemplo, GET-Messages - para procurar emails.  Qualquer solicita√ß√£o parametrizada, por exemplo, FILTER (isRead = False), √© chamada de par√¢metro e uma chamada de API √© uma API com uma lista de par√¢metros. <br><br><h4>  NL2API </h4><br>  A principal tarefa do NLI √© comparar uma instru√ß√£o (um comando em uma linguagem natural) com uma certa representa√ß√£o formalizada, por exemplo, formul√°rios l√≥gicos ou consultas SPARQL para bases de conhecimento ou APIs da Web no nosso caso.  Quando √© necess√°rio focar no mapeamento sem√¢ntico sem se distrair com detalhes irrelevantes, uma representa√ß√£o sem√¢ntica intermedi√°ria geralmente √© usada para n√£o trabalhar diretamente com o destino.  Por exemplo, a gram√°tica categ√≥rica combinat√≥ria √© amplamente usada na cria√ß√£o de NLIs para bancos de dados e bases de conhecimento.  Uma abordagem semelhante √† abstra√ß√£o tamb√©m √© muito importante para o NL2API.  Muitos detalhes, incluindo conven√ß√µes de URL, cabe√ßalhos HTTP e c√≥digos de resposta, podem "distrair" o NL2API da solu√ß√£o do principal problema - o mapeamento sem√¢ntico. <br><br>  Portanto, criamos uma visualiza√ß√£o intermedi√°ria para APIs RESTful (Figura 2) com o nome frame da API; essa visualiza√ß√£o reflete a sem√¢ntica do frame.  O quadro da API consiste em cinco partes.  HTTP Verb (Comando HTTP) e Recurso s√£o os elementos b√°sicos para uma API RESTful.  O Tipo de retorno permite criar APIs compostas, ou seja, combinar v√°rias chamadas de API para executar uma opera√ß√£o mais complexa.  Os par√¢metros necess√°rios s√£o usados ‚Äã‚Äãcom mais frequ√™ncia em chamadas PUT ou POST na API, por exemplo, o endere√ßo, o cabe√ßalho e o corpo da mensagem s√£o par√¢metros necess√°rios para o envio de email.  Par√¢metros opcionais geralmente est√£o presentes nas chamadas GET na API, eles ajudam a restringir a solicita√ß√£o de informa√ß√µes. <br><br>  Se os par√¢metros necess√°rios estiverem ausentes, serializamos o quadro da API, por exemplo: Mensagens GET {FILTER (isRead = False), SEARCH ("aplicativo de doutorado"), COUNT ()}.  Um quadro de API pode ser determin√≠stico e convertido em uma chamada de API real.  Durante o processo de convers√£o, os dados contextuais necess√°rios ser√£o adicionados, incluindo ID do usu√°rio, local, data e hora.  No segundo exemplo (Figura 1), o valor now no par√¢metro FILTER ser√° substitu√≠do pela data e hora da execu√ß√£o do comando correspondente durante a convers√£o do quadro da API em uma chamada de API real.  Al√©m disso, os conceitos de um quadro de API e uma chamada de API ser√£o usados ‚Äã‚Äãde forma intercambi√°vel. <br><br><img src="https://habrastorage.org/webt/zq/ya/1s/zqya1s2fappwxv0soevosjshp6o.png"><br>  <i>Figura 2. O quadro da API.</i>  <i>Acima: equipe de linguagem natural.</i>  <i>No meio: API do quadro.</i> <i>:  API.</i> <br><br><img src="https://habrastorage.org/webt/d1/4j/br/d14jbrsdzhethdl8tpvjlf0v7bq.png"><br> <i> 3.  .</i> <br><br><h2>    </h2><br>                NL2API   .     API        ,     ( 3.1),          ( 3).     API,       ( 3.2),      ( 3.3). <br><br><img src="https://habrastorage.org/webt/-m/hx/zh/-mhxzhnfom3w3n8cck-nkazfwiu.png"><br> <i> 4.   . :   . :  .</i> <br><br><h4>  API    </h4><br>    API     API.   ,       ,        API,   API  .      ,  Boolean,     (True/False). <br><br>      ,  Datetime,     ,  today  this_week  receivedDateTime.  ,        API           (,    )    API    API. <br><br>     ,        API .        . ,     TOP,         ORDERBY.  ,   Boolean,  isRead,  ORDERBY   .    ¬´ ¬ª         API   API. <br><br>      API.       API   .     API     API  ( 4).            ( HTTP, ,    ). ,   ‚ü®sender ‚Üí NP[from]‚ü© ,     from  ¬´sender¬ª,    ‚Äî   (NP),     . <br><br>       (V),   (VP),  (JJ), - (CP),   ,       (NP/NP),    (PP/NP),  (S)  . . <br><br>  ,       API     ,           RESTful API    OData ‚Äî ¬´ ¬ª    . 17     4     API,     ( 5). <br><br>   ,          API.     ‚ü®t1, t2, ..., tn ‚Üí c[z]‚ü©,  <img src="https://habrastorage.org/webt/h5/rj/n2/h5rjn28vmc1twejoa5459flx0gm.png">    , z    API,  cz ‚Äî   .     4.   API    ,     S,     G4,     API   . C    ,          ,               - ¬´that is not read¬ª. <br><br>  ,      . ,  VP[x = False]     B2,   B4,       x.  x     VP,   B2 (, x is hasAttachments ‚Üí ¬´do not have attachment¬ª);    JJ,    B4 (, x is isRead ‚Üí ¬´is not read¬ª).       (¬´do not read¬ª or ¬´is not have attachment¬ª)       . <br><br><h4>   </h4><br>  Podemos gerar um grande n√∫mero de chamadas de API usando a abordagem acima, mas anotar todas elas usando o crowdsourcing n√£o √© economicamente vi√°vel.  Portanto, propomos um modelo probabil√≠stico hier√°rquico para crowdsourcing que ajuda a decidir quais chamadas de API devem ser anotadas.  At√© onde sabemos, este √© o primeiro modelo probabil√≠stico de uso de crowdsourcing para criar interfaces NLI, o que nos permite resolver a tarefa √∫nica e intrigante de modelar a intera√ß√£o entre representa√ß√µes da linguagem natural e representa√ß√µes formalizadas da estrutura sem√¢ntica.  Representa√ß√µes formalizadas da estrutura sem√¢ntica em geral e chamadas de API em particular s√£o de natureza composicional.  Por exemplo, z12 = GET-Messages {COUNT (), FILTER (isRead = False)} consiste em z1 = GET-Messages {FILTER (isRead = False)} e z2 = GET-Messages {COUNT ()} (esses exemplos s√£o mais detalhados discutir mais). <br><br><img src="https://habrastorage.org/webt/fa/w0/eh/faw0ehohhnasifwgtragzrqwg3o.png"><br>  <i>Figura 5. A rede sem√¢ntica.</i>  <i>A i-√©sima camada consiste em chamadas de API com par√¢metros i.</i>  <i>Costelas s√£o composi√ß√µes.</i>  <i>As distribui√ß√µes de probabilidade nos v√©rtices caracterizam os modelos de linguagem correspondentes.</i> <br><br>  Um dos principais resultados de nosso estudo foi a confirma√ß√£o de que essa composicionalidade pode ser usada para modelar o processo de crowdsourcing. <br><br>  Primeiro, definimos a composi√ß√£o com base em um conjunto de par√¢metros de chamada da API. <br><br>  <b>Defini√ß√£o 3.1 (composi√ß√£o).</b>  Fa√ßa uma API e um conjunto de chamadas de API <br><img src="https://habrastorage.org/webt/jp/nd/rx/jpndrxembixwz20-sym5vtxyhaq.png">  se definirmos r (z) como um conjunto de par√¢metros para z, ent√£o <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  √© uma composi√ß√£o <img src="https://habrastorage.org/webt/_a/1x/jv/_a1xjvs9yduvatefhmfdk6xumq8.png">  se e somente se <img src="https://habrastorage.org/webt/0e/oy/hw/0eoyhwaahe8xlrbplt1nqajeego.png">  faz parte <img src="https://habrastorage.org/webt/np/q5/sy/npq5syhh47uv3yvyba_t1_4tqc0.png"><br><br>  Com base nos relacionamentos de composi√ß√£o das chamadas de API, voc√™ pode organizar todas as chamadas de API em uma √∫nica estrutura hier√°rquica.  As chamadas de API com o mesmo n√∫mero de par√¢metros s√£o representadas como os v√©rtices de uma camada e as composi√ß√µes s√£o representadas como <br>  costelas direcionadas entre as camadas.  Chamamos essa estrutura de rede sem√¢ntica (ou SeMesh). <br><br>  Por analogia com a abordagem baseada na modelagem de linguagem na recupera√ß√£o de informa√ß√µes, assumimos que as instru√ß√µes correspondentes a uma chamada da API z s√£o geradas usando um processo estoc√°stico caracterizado por um modelo de linguagem <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  .  Para simplificar, focamos nas probabilidades das palavras, <img src="https://habrastorage.org/webt/on/eh/p5/onehp5mxamc9ehgpsl1u4pbkfr4.png">  onde <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  denota um dicion√°rio. <br><br>  Por raz√µes que se tornar√£o aparentes um pouco mais tarde, em vez do modelo de unigrama de linguagem padr√£o, sugerimos o uso de um conjunto de distribui√ß√µes de Bernoulli (Bag of Bernoulli, BoB).  Cada distribui√ß√£o de Bernoulli corresponde a uma vari√°vel aleat√≥ria W, determinando se a palavra w aparece na senten√ßa gerada com base em z, e a distribui√ß√£o BoB √© um conjunto de distribui√ß√µes de Bernoulli para todas as palavras <img src="https://habrastorage.org/webt/k0/gw/fj/k0gwfjeikxqircdxhndamv6xbba.png">  .  Vamos usar <img src="https://habrastorage.org/webt/j1/vn/qm/j1vnqmhyhigxbdpj7s5irirmxae.png">  como uma nota√ß√£o curta para <img src="https://habrastorage.org/webt/ub/xi/rx/ubxirxha2um6wer3obznfezis7w.png">  . <br><br>  Suponha que tenhamos formado um (multi) conjunto de declara√ß√µes <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  para z, <br>  a estimativa de m√°xima verossimilhan√ßa (MLE) para a distribui√ß√£o BoB permite selecionar instru√ß√µes contendo w: <br><br><img src="https://habrastorage.org/webt/ix/gv/2q/ixgv2qua9ifqtxbp1mi3hf58izc.png"><br><br>  <b>Exemplo 2.</b> Com rela√ß√£o √† chamada de API acima z1, suponha que tenhamos duas instru√ß√µes u1 = "encontrar e-mails n√£o lidos" e u2 = "e-mails que n√£o s√£o lidos" e u = {u1, u2}.  pb ("emails" | z) = 1.0, pois "emails" est√° presente nas duas instru√ß√µes.  Da mesma forma, pb ("n√£o lido" | z) = 0,5 e pb ("reuni√£o" | z) = 0,0. <br><br>  Na rede sem√¢ntica, h√° tr√™s opera√ß√µes b√°sicas no n√≠vel do v√©rtice: <br>  Anota√ß√£o, layout e interpola√ß√£o. <br><br>  <b>ANOTAR</b> (anotar) significa coletar instru√ß√µes <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  parafrasear o comando can√¥nico do v√©rtice z usando crowdsourcing e avaliar a distribui√ß√£o emp√≠rica <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  m√©todo de m√°xima verossimilhan√ßa. <br><br>  <b>COMPOSE</b> (compor) tenta derivar um modelo de linguagem baseado em composi√ß√µes para calcular a distribui√ß√£o esperada <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  .  Como mostramos experimentalmente, <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  √â uma composi√ß√£o para z.  Se prosseguirmos com a suposi√ß√£o de que as declara√ß√µes correspondentes s√£o caracterizadas pela mesma conex√£o composicional, ent√£o <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  deve ser apresentado em <img src="https://habrastorage.org/webt/xe/zj/vd/xezjvdelmyapzpsz-c-ubbyrowq.png">  : <br><br><img src="https://habrastorage.org/webt/1j/kw/gy/1jkwgy2cjdyy2tkd9fd94_vdtf0.png"><br><br>  onde f √© uma fun√ß√£o composicional.  Para a distribui√ß√£o BoB, a fun√ß√£o de composi√ß√£o ficar√° assim: <br><br><img src="https://habrastorage.org/webt/-j/yo/yc/-jyoycveazjjahzb2va3w26sfv0.png"><br><br>  Em outras palavras, se ui √© uma afirma√ß√£o zi, u √© uma afirma√ß√£o <img src="https://habrastorage.org/webt/lr/ls/g_/lrlsg_9r0ga50mjkj47anmczlga.png">  composicionalmente forma u, ent√£o a palavra w n√£o pertence a u.  Se e somente se n√£o pertencer a nenhuma interface do usu√°rio.  Quando z tem muitas composi√ß√µes, Œ∏e x √© calculado separadamente e depois calculado a m√©dia.  O modelo de unigrama de linguagem padr√£o n√£o leva a uma fun√ß√£o composicional natural.  No processo de normaliza√ß√£o das probabilidades de palavras, est√° envolvido o comprimento das frases, as quais, por sua vez, levam em considera√ß√£o a complexidade das chamadas de API, violando a decomposi√ß√£o na equa√ß√£o (2).  √â por isso que oferecemos distribui√ß√£o BoB. <br><br>  <b>Exemplo 3.</b> Suponha que preparamos uma anota√ß√£o para as chamadas API mencionadas anteriormente z1 e z2, cada uma das quais com duas instru√ß√µes: <img src="https://habrastorage.org/webt/zy/pr/yx/zypryx-8unafep9q1_lu2bnwewi.png">  = {"Localizar emails n√£o lidos", "emails que n√£o s√£o lidos"} e <img src="https://habrastorage.org/webt/7n/4a/74/7n4a746gi-pf2_nf0ocy0dohdqm.png">  = {"Quantos emails eu tenho", "encontre o n√∫mero de emails"}.  Classificamos modelos de idiomas <img src="https://habrastorage.org/webt/7a/uj/od/7aujod7s9qek21mw3zemkcgaake.png">  e <img src="https://habrastorage.org/webt/vp/so/fn/vpsofnkfxhjn38dfcjpm6bqzzio.png">  .  A opera√ß√£o de composi√ß√£o est√° tentando avaliar <img src="https://habrastorage.org/webt/qt/tm/ud/qttmudo6ekcwmdeptxfjigmmcck.png">  sem perguntar <img src="https://habrastorage.org/webt/hx/6c/sn/hx6csng8_0l_yqxgvteefbapkm0.png">  .  Por exemplo, para a palavra "e-mails", pb ("e-mails" | z1) = 1.0 e pb ("e-mails" | z2) = 1.0, portanto, da equa√ß√£o (3) segue que pb ("e-mails" | z12) = 1.0, isto √©, acreditamos que esta palavra ser√° inclu√≠da em qualquer declara√ß√£o da z12.  Da mesma forma, pb ("encontrar" | z1) = 0,5 e pb ("encontrar" | z2) = 0,5, portanto, pb ("encontrar" | z12) = 0,75.  Uma palavra tem uma boa chance de ser gerada a partir de qualquer z1 ou z2, portanto, sua probabilidade para z12 deve ser maior. <br><br>  Obviamente, nem sempre as declara√ß√µes s√£o combinadas em termos de composi√ß√£o.  Por exemplo, v√°rios elementos em uma representa√ß√£o formalizada de uma estrutura sem√¢ntica podem ser transmitidos em uma √∫nica palavra ou frase em uma linguagem natural, esse fen√¥meno √© chamado de composicionalidade sublexica.  Um exemplo √© mostrado na Figura 3, onde os tr√™s par√¢metros - TOP (1), FILTER (start&gt; now) e ORDERBY (start, asc) - s√£o representados pela palavra "next".  No entanto, √© imposs√≠vel obter essas informa√ß√µes sem anotar a chamada da API; portanto, o problema se assemelha ao problema de frango e ovos.  Na aus√™ncia de tais informa√ß√µes, √© razo√°vel aderir √† suposi√ß√£o padr√£o de que as instru√ß√µes s√£o caracterizadas pelo mesmo relacionamento de composi√ß√£o que as chamadas de API. <br><br>  Esta √© uma suposi√ß√£o plaus√≠vel.  Vale ressaltar que essa suposi√ß√£o √© usada apenas para modelar o processo de crowdsourcing com o objetivo de coletar dados.  Na fase de teste, as declara√ß√µes de usu√°rios reais podem n√£o corresponder a essa suposi√ß√£o.  A interface de linguagem natural ser√° capaz de lidar com essas situa√ß√µes n√£o composicionais se elas forem cobertas pelos dados de treinamento coletados. <br><br>  <b>INTERPOLATE</b> (interpola√ß√£o) combina todas as informa√ß√µes dispon√≠veis sobre z, ou seja, declara√ß√µes anotadas z e informa√ß√µes obtidas das composi√ß√µes e obt√©m uma estimativa mais precisa <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  por interpola√ß√£o <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  e <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br><img src="https://habrastorage.org/webt/s4/qk/00/s4qk00v3xupp-nglc-ge-mmgwxa.png"><br><br>  O par√¢metro de balan√ßo Œ± controla trade-offs entre anota√ß√µes <br>  os picos atuais que s√£o precisos, mas suficientes, e as informa√ß√µes obtidas de composi√ß√µes baseadas na suposi√ß√£o de composi√ß√£o podem n√£o ser t√£o precisas, mas fornecem uma cobertura mais ampla.  Em certo sentido, <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  serve ao mesmo objetivo que o anti-aliasing na modelagem de linguagem, o que permite uma melhor estimativa da distribui√ß√£o de probabilidade com dados insuficientes (anota√ß√µes).  Mais que <img src="https://habrastorage.org/webt/xt/ml/w5/xtmlw5p16zioqn1amioucvjhe5o.png">  quanto mais peso <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  Para um v√©rtice raiz que n√£o tem composi√ß√£o, <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  Para um topo n√£o anotado <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br>  Em seguida, descrevemos o algoritmo de atualiza√ß√£o de rede sem√¢ntica, ou seja, c√°lculos <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  para todo z (algoritmo 1), mesmo que apenas uma pequena parte dos v√©rtices tenha sido anotada.  Assumimos que o valor <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  J√° atualizado para todos os sites anotados.  Descendo de cima para baixo, calculamos sequencialmente <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  e <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  para cada v√©rtice z.  Primeiro, voc√™ precisa atualizar as camadas superiores para poder calcular a distribui√ß√£o esperada dos v√©rtices do n√≠vel inferior.  Anotamos todos os v√©rtices raiz, para que possamos calcular <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  para todos os v√©rtices. <br><br>  <i>Algoritmo 1. Distribui√ß√µes de n√≥s de atualiza√ß√£o da malha sem√¢ntica</i> <br><br><img src="https://habrastorage.org/webt/wd/ja/xx/wdjaxx4oqk_1rqniul9rnbc-fno.png"><br><br><h4>  3.3 Otimiza√ß√£o de Crowdsourcing </h4><br>  A rede sem√¢ntica forma uma vis√£o hol√≠stica de todo o espa√ßo das chamadas de API, bem como a intera√ß√£o de instru√ß√µes e chamadas.  Com base nessa vis√£o, podemos anotar seletivamente apenas um subconjunto de chamadas √† API de alto valor.  Nesta se√ß√£o, descrevemos nossa estrat√©gia de distribui√ß√£o diferencial para otimizar o crowdsourcing. <br><br>  Considere uma rede sem√¢ntica com muitos v√©rtices Z. Nossa tarefa √© determinar um subconjunto de v√©rtices dentro do processo iterativo <img src="https://habrastorage.org/webt/ti/9x/ac/ti9xacqha0b1hbtkyeejh30f3sk.png">  para ser anotado por trabalhadores de crowdsourcing.  Os v√©rtices anotados anteriormente ser√£o chamados de state state, <br>  ent√£o precisamos encontrar pol√≠ticas de pol√≠tica <img src="https://habrastorage.org/webt/9i/oc/9m/9ioc9mao9yuvhq7uhkiemeqet4g.png">  para avaliar cada v√©rtice n√£o anotado com base no estado atual. <br><br>  Antes de aprofundar na discuss√£o de abordagens para calcular pol√≠ticas eficazes, suponha que j√° tenhamos uma e forne√ßa uma descri√ß√£o de alto n√≠vel de nosso algoritmo de crowdsourcing (Algoritmo 2) para descrever os m√©todos que a acompanham.  Mais especificamente, primeiro anotamos todos os v√©rtices raiz para avaliar a distribui√ß√£o de todos os v√©rtices em Z (linha 3).  A cada itera√ß√£o, atualizamos a distribui√ß√£o de v√©rtices (linha 5), ‚Äã‚Äãcalculamos <br>  uma pol√≠tica baseada no estado atual da rede sem√¢ntica (linha 6), selecione o v√©rtice n√£o anotado com a classifica√ß√£o m√°xima (linha 7) e anote o v√©rtice e o resultado no novo estado (linha 8).  Em termos pr√°ticos, voc√™ pode anotar v√°rios v√©rtices como parte de uma itera√ß√£o para aumentar a efici√™ncia. <br><br><img src="https://habrastorage.org/webt/va/tz/hs/vatzhsjcogvaktg8wh4h0a8al70.png"><br>  <i>Figura 6. Distribui√ß√£o diferencial.</i>  <i>z12 e z23 representam o par de v√©rtices em estudo.</i>  <i>w √© uma estimativa calculada com base em d (z12, z23) e se propaga iterativamente de baixo para cima, dobrada em cada itera√ß√£o.</i>  <i>A estimativa para o v√©rtice ser√° a diferen√ßa absoluta de suas estimativas de z12 e z23 (portanto diferencial).</i>  <i>z2 obt√©m uma pontua√ß√£o de 0 porque √© a entidade pai comum de z12 e z23;</i>  <i>a anota√ß√£o neste caso ser√° de pouca utilidade em termos de garantir a distin√ß√£o entre z12 e z23.</i> <br><br>  Em um sentido amplo, as tarefas que resolvemos podem ser atribu√≠das ao problema da aprendizagem ativa; estabelecemos o objetivo de identificar um subconjunto de exemplos para anota√ß√£o, a fim de obter um conjunto de treinamento que possa melhorar os resultados da aprendizagem.  No entanto, v√°rias diferen√ßas importantes n√£o permitem a aplica√ß√£o direta de m√©todos cl√°ssicos de ensino ativo, como "incerteza de amostragem".  Normalmente, no processo de aprendizado ativo, o aluno, que no nosso caso seria a interface NLI, tenta estudar o mapeamento f: X ‚Üí Y, onde X √© a amostra do espa√ßo de entrada, consistindo em um pequeno conjunto de amostras marcadas e um grande n√∫mero de amostras n√£o marcadas, e Y geralmente √© um conjunto de marcadores classe. <br><br>  O aluno avalia o valor informativo dos exemplos n√£o identificados e seleciona o mais informativo para obter uma nota Y dos trabalhadores de crowdsourcing.  Mas, dentro da estrutura do problema que estamos resolvendo, o problema da anota√ß√£o √© colocado de maneira diferente.  Precisamos selecionar uma inst√¢ncia de Y, um grande espa√ßo de chamada da API, e pedir aos funcion√°rios de crowdsourcing que o rotulem especificando padr√µes em X, o espa√ßo da frase.  Al√©m disso, n√£o estamos vinculados a um trainee espec√≠fico.  Assim, propomos uma nova solu√ß√£o para o problema em quest√£o.  N√≥s nos inspiramos em v√°rias fontes de aprendizado ativo. <br><br>  Primeiro, determinaremos a meta, com base na qual o conte√∫do das informa√ß√µes dos n√≥s ser√° avaliado.  Obviamente, queremos que diferentes chamadas de API sejam distingu√≠veis.  Na rede sem√¢ntica, isso significa que a distribui√ß√£o <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  picos diferentes t√™m diferen√ßas √≥bvias.  Para come√ßar, apresentamos cada distribui√ß√£o <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  como um vetor n-dimensional <img src="https://habrastorage.org/webt/nv/ky/pn/nvkypndwq-7j6xnikrteas3oiq4.png">  onde n = | <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  |  - o tamanho do dicion√°rio.  Por uma certa m√©trica da dist√¢ncia do vetor d (em nossos experimentos, usamos a dist√¢ncia entre os vetores pL1), queremos dizer <img src="https://habrastorage.org/webt/jc/z9/de/jcz9demx4drw0fsgz1niisgavd0.png">  , ou seja, a dist√¢ncia entre dois v√©rtices √© igual √† dist√¢ncia entre suas distribui√ß√µes. <br><br>  O objetivo √≥bvio √© maximizar a dist√¢ncia total entre todos os pares de v√©rtices.  No entanto, a otimiza√ß√£o de todas as dist√¢ncias aos pares pode ser muito complicada para c√°lculos, e mesmo isso n√£o √© necess√°rio.  Um par de picos distantes j√° possui diferen√ßas suficientes, portanto, um aumento adicional na dist√¢ncia n√£o faz sentido.  Em vez disso, podemos nos concentrar nos pares de v√©rtices que causam mais confus√£o, ou seja, a dist√¢ncia entre eles √© a menor. <br><br><img src="https://habrastorage.org/webt/of/tp/sl/oftpslo2cmmijyxtccepbyqsmsc.png"><br><br>  onde <img src="https://habrastorage.org/webt/1g/-h/nh/1g-hnhpklydkghmo4z7pq7ujouu.png">  aponta para os primeiros K pares de v√©rtices se classificarmos todos os pares de n√≥s por dist√¢ncia em ordem crescente. <br><br>  <i>Algoritmo 2. Anote iterativamente uma malha sem√¢ntica com uma pol√≠tica</i> <br><br><img src="https://habrastorage.org/webt/5p/j2/2r/5pj22rp_c5npknusixp4k4ulfli.png"><br><br>  <i>Algoritmo 3. Pol√≠tica de computa√ß√£o baseada na propaga√ß√£o diferencial</i> <br><br><img src="https://habrastorage.org/webt/s5/ee/zb/s5eezb7ls03ly9nfndyotsqhlva.png"><br><br>  <i>Algoritmo 4. Propague recursivamente uma pontua√ß√£o de um n√≥ de origem para todos os seus n√≥s pais</i> <br><br><img src="https://habrastorage.org/webt/m9/ge/vt/m9gevt8-vlgwxxulaxyfxkovdmk.png"><br><br>  V√©rtices com maior conte√∫do de informa√ß√µes ap√≥s a anota√ß√£o potencialmente aumentam o valor de Œò.  Para quantifica√ß√£o, neste caso, propomos o uso de uma estrat√©gia de distribui√ß√£o diferencial.  Se a dist√¢ncia entre um par de v√©rtices for pequena, examinaremos todos os seus v√©rtices pai: se o v√©rtice pai for comum para um par de v√©rtices, ele dever√° receber uma classifica√ß√£o baixa, pois a anota√ß√£o levar√° a altera√ß√µes semelhantes nos dois v√©rtices. <br><br>  Caso contr√°rio, o v√©rtice deve ser altamente classificado e, quanto mais pr√≥ximo o par de v√©rtices, maior ser√° a classifica√ß√£o.  Por exemplo, se a dist√¢ncia entre os v√©rtices de "e-mails n√£o lidos sobre o aplicativo PhD" e "quantos e-mails s√£o sobre o aplicativo PhD" √© pequena, a anota√ß√£o do v√©rtice pai "e-mails sobre o aplicativo PhD" n√£o faz muito sentido do ponto de vista da distin√ß√£o entre esses v√©rtices.  √â mais aconselh√°vel anotar n√≥s pai que n√£o ser√£o comuns a eles: "emails n√£o lidos" e "quantos emails". <br><br>  Um exemplo dessa situa√ß√£o √© mostrado na Figura 6 e seu algoritmo √© o algoritmo 3. Como estimativa, tomamos o rec√≠proco da dist√¢ncia do n√≥ limitada por uma constante (linha 6), para que os pares de v√©rtices mais pr√≥ximos tenham o maior impacto.  Ao trabalhar com um par de v√©rtices, atribu√≠mos simultaneamente uma avalia√ß√£o de cada v√©rtice a todos os seus v√©rtices pai (linha 9, 10 e algoritmo 4).  Uma estimativa de um v√©rtice n√£o anotado √© a diferen√ßa absoluta nas estimativas do par de v√©rtices correspondente com a soma de todos os pares de v√©rtices (linha 12). <br><br><h2>  Interface de linguagem natural </h2><br>  Para avaliar a estrutura proposta, √© necess√°rio treinar os modelos NL2API usando os dados coletados.  No momento, o modelo NL2API finalizado n√£o est√° dispon√≠vel, mas estamos adaptando dois modelos NLI testados de outras √°reas para aplic√°-los √† API. <br><br><h4>  Modelo de extra√ß√£o de modelo de linguagem </h4><br>  Com base nos desenvolvimentos recentes no campo do NLI para bases de conhecimento, podemos considerar a cria√ß√£o do NL2API no contexto do problema de extra√ß√£o de informa√ß√µes, a fim de adaptar o modelo de extra√ß√£o baseado no modelo de linguagem (LM) √†s nossas condi√ß√µes. <br><br>  Para dizer "u", voc√™ precisa encontrar uma chamada da API z na rede sem√¢ntica com a melhor correspond√™ncia para "u".  Primeiro, transformamos a distribui√ß√£o do BoB <img src="https://habrastorage.org/webt/rq/qs/9-/rqqs9-qn12-qsdd7mahxx5tg-si.png">  cada chamada da API z para o modelo de unigrama do idioma: <br><br><img src="https://habrastorage.org/webt/lr/4f/pt/lr4fptel7voyxz2pelzjinbyu14.png"><br><br>  onde usamos suaviza√ß√£o aditiva e 0 ‚â§ Œ≤ ‚â§ 1 √© o par√¢metro de suaviza√ß√£o.  Maior valor <img src="https://habrastorage.org/webt/rh/1e/wc/rh1ewczas_fvleaxd5za0qvury0.png">  , maior o peso das palavras que ainda n√£o foram analisadas.  As chamadas de API podem ser classificadas por sua probabilidade logar√≠tmica: <br><br><img src="https://habrastorage.org/webt/3c/sf/fu/3csffus3jr7h6kpxq6czdyvhdtm.png"><br><br>  (sujeito a uma distribui√ß√£o uniforme de probabilidade a priori) <br><br><img src="https://habrastorage.org/webt/0s/xu/y-/0sxuy-xon3k12zlsbn2f41wzyco.png"><br><br>  A chamada da API com a classifica√ß√£o mais alta √© usada como resultado da simula√ß√£o. <br><br><h4>  M√≥dulo de reformula√ß√£o Seq2Seq </h4><br>  As redes neurais est√£o se tornando mais difundidas como modelos para NLI, enquanto o modelo Seq2Seq √© melhor que os outros para esse fim, pois permite processar naturalmente sequ√™ncias de entrada e sa√≠da de comprimentos vari√°veis.  N√≥s adaptamos este modelo para NL2API. <br><br>  Para sequ√™ncia de entrada e <img src="https://habrastorage.org/webt/sl/zv/2w/slzv2wvhssrsrt-2cehxkcosmr0.png">  , o modelo estima a distribui√ß√£o de probabilidade condicional p (y | x) para todas as sequ√™ncias de sa√≠da poss√≠veis <img src="https://habrastorage.org/webt/zz/ar/74/zzar74ttz1utynmp2qpkuprrhwc.png">  .  Os comprimentos T e T 'podem variar e assumir qualquer valor.  No NL2API, x √© a instru√ß√£o de sa√≠da.  y pode ser uma chamada de API serializada ou seu comando can√¥nico.  Usaremos comandos can√¥nicos como sequ√™ncias de sa√≠da de destino, o que realmente transforma nosso problema em um problema de reformula√ß√£o. <br><br>  Um codificador implementado como uma rede neural recorrente (RNN) com unidades de recorr√™ncia controlada (GRU) primeiro representa x como um vetor de tamanho fixo, <br><br><img src="https://habrastorage.org/webt/_l/vv/ht/_lvvhtq3g73uajiwibi7r5xzspc.png"><br><br>  onde RN N √© uma breve representa√ß√£o para aplicar GRU a toda a sequ√™ncia de entrada, marcador por marcador, seguido pela sa√≠da do √∫ltimo estado oculto. <br><br>  O decodificador, que tamb√©m √© um RNN com GRU, toma h0 como o estado inicial e processa a sequ√™ncia de sa√≠da y, marcador por marcador, para gerar uma sequ√™ncia de estados, <br><br><img src="https://habrastorage.org/webt/eo/lg/9l/eolg9ljwlyskjfurunypvlmswaa.png"><br><br>  A camada de sa√≠da toma cada estado do decodificador como um valor de entrada e gera uma distribui√ß√£o de dicion√°rio <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  como o valor de sa√≠da.  Apenas usamos a transforma√ß√£o afim seguida pela fun√ß√£o log√≠stica multi-vari√°vel softmax: <br><br><img src="https://habrastorage.org/webt/qr/ty/c9/qrtyc9lsayvqiczswbr-837_pba.png"><br><br>  A probabilidade condicional final, que nos permite avaliar at√© que ponto o comando can√¥nico reformula a instru√ß√£o de entrada x, √© <img src="https://habrastorage.org/webt/l5/yt/wn/l5ytwnga_iegxtspqogvabwe5g0.png"><img src="https://habrastorage.org/webt/ul/7k/ny/ul7knyk1imjwc0p_hrjisfmy8-e.png">  .  As chamadas de API s√£o ent√£o classificadas pela probabilidade condicional de seu comando can√¥nico.  Recomendamos que voc√™ se familiarize com a fonte, onde o processo de aprendizado do modelo √© descrito em mais detalhes. <br><br><h2>  Experi√™ncias </h2><br>  Experimentalmente, estudamos os seguintes assuntos de pesquisa: [PI1]: Podemos usar a estrutura proposta para coletar dados de treinamento de alta qualidade a um pre√ßo razo√°vel?  [PI2]: A rede sem√¢ntica fornece uma avalia√ß√£o mais precisa dos modelos de linguagem do que a avalia√ß√£o de probabilidade m√°xima?  [PI3]: Uma estrat√©gia de distribui√ß√£o diferencial melhora a efici√™ncia do crowdsourcing? <br><br><h4>  Crowdsourcing </h4><br>       -API  Microsoft ‚Äî GET-Events  GET-Messages ‚Äî              .       API,    API ( 3.1)      .   API    2.      ,  Amazon Mechanical Turk.    ,     API    . <br><br>             .   API  10 ,       10 .    201 ,        .          44 ,     82       ,    8,2 , ,   ,  .    ,    400    ,     17,4 %. <br><br>         (,     ORDERBY  a COUNT parameter)     (,    ,        ).       .            NLI.  ,  ,    [1] .           . <br><br>  ,      ,         ,   ,  API    (. 3).   API       .        ,    .     61  API  157   GET-Messages,   77  API  190   GET-Events.        ,  ,    API (,    )     , ,     . <br><br><img src="https://habrastorage.org/webt/dc/yk/nv/dcyknvmod2su0cutkru02tpklti.png"><br> <i> 2.   API.</i> <br><br><img src="https://habrastorage.org/webt/x9/dm/_b/x9dm_bbbgyua7xe0cl1fzjloc5o.png"><br> <i> 3.   :  ().</i> <br><br><h4>   </h4><br>       ,     ,      .    ,   Œ± = 0,3,    LM Œ≤ = 0,001.    K,    ,  100 000.    , ,      Seq2Seq ‚Äî 500.           (  ). <br><br>                  NLI,     .          . <br><br><h4>    </h4><br>  .         ,  ,            .         LM:   ,   .     ,     . ROOT ‚Äî   . TOP2 = ROOT +    2;  TOP3 = TOP2 +    3.            . <br><br>     4.      LM      (MLE)    ,     <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">    ,      . ,    ,      ,  MLE       . <br><br>    MLE,      <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">   ,  <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png"> -    ,    .     API    .    16   API (ROOT)   LM  SeMesh        Seq2Seq       API (TOP2)    ,   500   API (TOP3). <br><br>    ,   ,     ,  ,     ( 3.2)   .  ,    GET-Events    ,   GET-Messages.   ,  GET-Events  <br>  ,    ,        ,         . <br><br><img src="https://habrastorage.org/webt/pb/ym/e4/pbyme4xdpxcqabwlawu_bmkefkg.png"><br> <i> 4.    .        LM,       Seq2Seq,      .  ,        .</i> <br><br>  LM +  ,      ,       <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">     Œ∏em with <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png"> ,    ,    ROOT,          <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    ,        ,    .             MLE.  ,  ,    [2] . <br><br>        0,45  0,6:    ,           NLI   .    ,            API.        API (.   7)     ,    RNN   ,     .       . <br><br>  .        :   |u |    Œ±.   -     LM ( 7).    ,  |u | &lt; 10,         10  .     GET-Events,  GET-Messages  . <br><br> ,         ,   ,    . ,    ,    .   ,       Œ±,        ([0.1, 0.7]).   Œ±      ,   ,      . <br><br><h4>   </h4><br>            (DP)   .       API  .       50  API,    ,    NL2API      . <br><br> ,     .     LM,      .             .           ,       ( 5.1),          API   . <br><br><img src="https://habrastorage.org/webt/lg/xz/z9/lgxzz9zznpwnk0c4vdqfnfaurrg.png"><br>  7.  . <br><br><img src="https://habrastorage.org/webt/ak/5p/da/ak5pda8vlogeadhfjphy-t33dcg.png"><br>  8.    . : GET-Events. : GET-Messages <br><br>       breadth first (BF),          .    .     .  API    ,       API  . <br><br>      8.    NL2API   API  DP      .     300    API,    Seq2Seq, DP      7 %   API.       ,  .  ,  DP    API,      NL2API.  ,  ,    [3] . <br><br><h2>    </h2><br> - .   -  (NLI)     .  NLI    . ,   ,       .                . <br><br>      NLI    ,    -,    API   .  NL2API     :      API ,   - ,   .      .      API    REST           . <br><br> <b>    NLI.</b>        NLI    ¬´  ¬ª. ,         Google Suggest API,        API   IFTTT.         NLI,       .        ,   . <br><br>          NLI,                  .        NLI   ,          .           ,           ,        . <br><br>                  API  .         ,          -API.                  . <br><br> <b>   -API.</b>     ,   -API. ,   -API      API,         -API   .  NL2API     , ,          API. <br><br><h2>      </h2><br>     -   -API (NL2API)       NL2API  .                NL2API   .       : (1)  .            , , ? (2)  . <br><br>      ? (3)  NL2API. ,               API. (4)  API.         API? (5)    :    NL2API        ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418559/">https://habr.com/ru/post/pt418559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418547/index.html">Programa√ß√£o ass√≠ncrona com exemplos: reconstruindo m√©todos java.util.concurrent.CompletableFuture</a></li>
<li><a href="../pt418549/index.html">Criando um bot para participar do mini cup da AI 2018 com base em uma rede neural recorrente (parte 3)</a></li>
<li><a href="../pt418551/index.html">Quanto um programador deve saber matem√°tica?</a></li>
<li><a href="../pt418553/index.html">Javasript + React vs Kotlin + React</a></li>
<li><a href="../pt418557/index.html">C√°lculo dos processos de onda em uma linha hidr√°ulica usando o m√©todo de caracter√≠sticas</a></li>
<li><a href="../pt418561/index.html">M√°quinas de estado ao servi√ßo do MVP. Palestra Yandex</a></li>
<li><a href="../pt418563/index.html">O resumo de materiais interessantes para o desenvolvedor de dispositivos m√≥veis # 263 (23 a 29 de julho)</a></li>
<li><a href="../pt418565/index.html">No caminho para 100% de cobertura de c√≥digo com testes no Go usando o sql-dumper como exemplo</a></li>
<li><a href="../pt418567/index.html">A Dell deixar√° de ser uma empresa privada e, pela primeira vez em cinco anos, colocar√° a√ß√µes na bolsa de valores</a></li>
<li><a href="../pt418569/index.html">Novos sat√©lites - novos bugs: o sensor infravermelho de sat√©lite GOES-17 n√£o esfria bem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>