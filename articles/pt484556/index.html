<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏐 📁 👨‍👩‍👦‍👦 Então, quando ainda é possível usar! 🤾🏽 📙 👩🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qualquer característica nas mãos "tortas" fica ruim. O importador não é exceção. O ruim não é o que ele sabe, mas a maneira como ele é usado. 



 Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Então, quando ainda é possível usar!</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484556/">  Qualquer característica nas mãos "tortas" fica ruim.  O importador não é exceção.  O ruim não é o que ele sabe, mas a maneira como ele é usado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/272/487/29b/27248729b20fda44cdcbb9aca8b0efa9.gif" alt="Imagem animada na qual Malloy adiciona veneno ao prato."><br><a name="habracut"></a><br><h2>  Como funciona! </h2><br>  Em CSS, usamos o mecanismo de especificidade para priorizar estilos.  Escrevemos cascatas ou seletores complexos, aumentamos o peso do seletor, indicando ao navegador a prioridade de alguns estilos em detrimento de outros. <br><br>  Por exemplo: <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre> <br>  Nesse caso, apesar de a cor azul ser aplicada ao cabeçalho depois do vermelho, como resultado, obteremos um cabeçalho vermelho.  Como o primeiro seletor é mais específico (se de repente você não estiver familiarizado com isso, não leia mais - só vai piorar, <a href="https://habr.com/ru/post/436610/">é</a> melhor <a href="https://habr.com/ru/post/436610/">aqui</a> e aprender especificidade). <br><br>  Então, usando o mesmo exemplo, mas com! Importante, descobrimos de repente que ele não se importa com sua especificidade. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre><br>  O título será azul!  Essa propriedade viola o fluxo natural das regras que escrevemos e atribui aos estilos de menor prioridade a maior prioridade. <br><br>  Bem, no entanto, como "cuspir" ... Na verdade não, e cuspir.  Vamos adicionar outro importador. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre><br>  E a manchete está vermelha novamente.  Porque temos dois conflitos importantes, e esse conflito é resolvido através da comparação dos pesos dos seletores. <br><br>  Um importador é ruim quando é: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  <i>“Hmm, eu escrevi em vermelho, por que minha manchete não é vermelha?</i>  <i>E se sim?</i> <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre><br>  <i>“Ótimo!</i>  <i>Vermelho! ”</i> Mas é realmente bom? <br><br>  Essa abordagem é ruim, pelo menos porque você redefine os estilos sem entender por que eles não foram aplicados sem um importador.  Provavelmente, o peso do seletor usado acabou sendo insuficiente e, escrevendo um seletor um pouco mais preciso e "pesado", você resolveria o problema e redefiniria rigidamente os estilos, e é bom se você conhecer e verificar todos os lugares em que essa classe foi usada, mas se não for, você subordinou o elemento em um lugar e provavelmente quebrou em outro. <br><br><h2>  Ferramenta para hotfix </h2><br>  Muitas vezes, quando faço uma pergunta a alguém sobre importadores, ouço uma resposta no estilo de: <i>"Uso importante quando preciso resolver rapidamente o problema e não tenho tempo para entender o código que não escrevi e que está muito mal escrito"</i> . <br><br>  Sim, mas apenas as tarefas são sempre "urgentes"; geralmente, essas tarefas nunca terminam, portanto, deixe-o.  Você mesmo não percebeu como piorou ainda mais o "código alienígena ruim". <br><br>  O que significa fast?  É tão difícil e demorado descobrir o peso necessário do seletor para redefinição?  Estamos usando ativamente o DevTools no desenvolvimento e temos a resposta para resolver esse problema. <br><br>  Inspecionamos o elemento que queremos mudar.  Sua cor atual é preta.  Examinamos a que seletor essa cor foi atribuída? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/033/ce7/602/033ce7602623bfb9b92eb2c203e1e9c8.png" alt="Captura de tela de um inspetor da web com um exemplo de inspeção da cor de um elemento"><br><br>  Usamos o mesmo seletor para atribuir uma nova cor ou aumentar o peso, e o ponto está no chapéu, não importa quão difícil seja esse seletor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f9/25f/0ca/4f925f0ca11cedc9d1f9975c823bbaf2.png" alt="Captura de tela de um inspetor da web com um exemplo de inspeção da cor de um elemento"><br><br>  Isso é longo?  Parece-me que isso difere pouco no tempo da escrita! Importante, mas é muito mais correto e seguro. <br><br><h2>  Soluções de terceiros e código de outra pessoa </h2><br>  A segunda resposta mais popular à pergunta sobre a necessidade de usar importadores: <i>"Eu uso! Importante ao redefinir os estilos de bibliotecas e plug-ins de terceiros ou CMS-ok"</i> . <br><br>  Essa resposta está um pouco mais próxima da verdade, mas apenas se for formulada com um pouco mais de precisão.  É dessa forma que está incorreta, porque os estilos de arquivos de terceiros podem ser substituídos da mesma maneira que os seus, apenas adicionando-os após conectar os estilos de outras pessoas e aumentar o peso do seletor. <br><br>  No entanto, em alguns casos, essa resposta "entra" na pergunta.  Por exemplo, se você conectou um controle deslizante à sua página, que é implementado para que, ao alternar o slide, o JavaScript substitua os valores de algumas propriedades no CSS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6a/184/e6a/a6a184e6aa9bd38ea19007dd11d9386d.png" alt="Captura de tela de um inspetor da Web com uma mudança dinâmica de estilos para um elemento"><br><br>  E, por algum motivo, você precisa substituir essas propriedades, ignorando as alterações no próprio plugin. <br><br>  JS só pode reatribuir valores de propriedade usando estilos embutidos.  Ou seja, quaisquer propriedades alteradas para um elemento usando JavaScript serão simplesmente gravadas no atributo style.  Do ponto de vista do mecanismo de especificidade, esses estilos são mais prioritários e, não importa como você aumente o peso do seletor, você não poderá substituí-los. <br><br>  Este é precisamente o <i>primeiro</i> caso em que simplesmente não podemos prescindir de algo importante. <br>  Se precisarmos redefinir os estilos embutidos, apenas importante nos ajudará. <br>  A prioridade dos estilos com um importador é maior que a prioridade dos estilos embutidos, e se por algum motivo você precisar reescrever estilos embutidos, não terá outra opção a não ser usar! Importante. <br><br><h2>  Importante para o bem </h2><br>  Vamos considerar mais um caso, que às vezes é usado no código de várias bibliotecas e plugins. <br><br>  Se você abrir o código-fonte CSS da biblioteca Bootstrap, verá que os desenvolvedores da biblioteca frequentemente recorrem ao uso de importadores.  Talvez eles também precisassem consertar rapidamente e o fizeram (sarcasmo), mas em geral há uma explicação mais adequada.  Nesse caso, s importantes são usados ​​"para sempre".  Dessa maneira, os desenvolvedores do Bootstrap “protegem” seu código. <br><br>  O fato é que, ao conectar esta biblioteca ao seu site, você pode redefinir seus estilos originais.  Assim, os desenvolvedores são ressegurados e a quebra do comportamento de seu código será mais difícil se você não souber como a especificidade funciona.  Mas se você entender como o mecanismo de especificidade do CSS funciona, poderá redefinir o importador escrevendo seus estilos com o importador também, mas com um seletor mais "pesado". <br><br>  Assim, chegamos ao <i>segundo</i> caso em que é impossível sem importador. <br>  Se você precisar substituir importantes (a sua ou de uma biblioteca de terceiros), apenas o! Important o ajudará. <br><br>  É por isso que é incorreto dizer: “Uso importadores quando preciso redefinir os estilos de bibliotecas de terceiros”, seria mais correto dizer: “Uso importadores quando preciso redefinir estilos embutidos ou outros! Importante”.  E não importa de onde vêm esses estilos: dos seus arquivos ou de terceiros. <br><br><h2>  Ajudantes </h2><br>  De fato, no parágrafo anterior, todos os casos são descritos quando o uso de importadores será normal e correto.  São casos em que o uso de importadores será inevitável.  Mas ainda existem casos em que o uso de importadores será permitido, embora talvez já não seja inteiramente apropriado. <br><br>  Às vezes, precisamos de classes universais auxiliares que usamos em nosso código com o objetivo de reutilizar o código e alguma simplificação. <br>  Por exemplo, criamos algum tipo de classe .warning, que aplicaremos a vários elementos da página, indicando sua importância. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.warning</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  E queremos que, ao aplicar essa classe a qualquer elemento, definitivamente tornaremos o texto nesse elemento vermelho.  Mas um elemento pode ter estilos de prioridade mais alta gravados usando um seletor mais preciso e, em seguida, nossa cor da classe .warning será alterada.  Nesse caso, ao adicionar importantes à nossa classe auxiliar, a tornamos mais universal, porque a cor usada nessa classe será mais prioritária.  No entanto, não posso dizer que seja bom.  Afinal, isso torna os estilos de classe mais prioritários, mas ainda não garante cem por cento de trabalho, pois esse ajudante pode encontrar outras coisas importantes e, mesmo assim, tudo dará errado.  E então, quando acontece que, em um certo caso, essa classe deve tornar o texto “não tão vermelho”, você imediatamente “dará à luz” um novo seletor com repetição do importador. <br><br><h2>  Quando ainda é possível </h2><br>  É correto e normal usar! Importante quando você precisa substituir estilos embutidos ou outros! Importante. <br><br>  Se você seguir esta regra, no layout usual, principalmente se estiver impondo uma página do zero, você não precisará usar um importador até o momento em que começar a conectar soluções de terceiros à sua página, mas mesmo assim acima, não necessariamente leva ao seu uso. <br><br>  Metodologias modernas como o BEM também ditam suas próprias regras, nas quais o uso de estilos em linha ou importadores será inadequado. <br><br>  Você não precisa de um importador, não porque ele seja misterioso e terrível, mas simplesmente porque na maioria dos casos você pode ficar sem ele. <br><br>  Todas as exceções que eu determinei para mim, em regra, se resumem a casos não muito típicos.  Por exemplo, talvez você precise usá-lo quando estiver desenvolvendo sua própria biblioteca, plug-in ou extensão de navegador e precisar de um comportamento de prioridade mais alta para estilos específicos.  No entanto, isso está longe do uso regular típico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484556/">https://habr.com/ru/post/pt484556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484546/index.html">10 perguntas populares da entrevista TypeScript (com respostas curtas)</a></li>
<li><a href="../pt484548/index.html">Como a vulnerabilidade crítica do Citrix NetScaler CVE-2019-19781 expôs problemas ocultos no setor de TI</a></li>
<li><a href="../pt484550/index.html">A holacracia é necessária em uma empresa de TI: prós e contras</a></li>
<li><a href="../pt484552/index.html">Leitura para um geek: 10 materiais sobre a tecnologia de áudio - como as faixas de música, os discos em HD e o som 8D são organizados</a></li>
<li><a href="../pt484554/index.html">Criar um botão com o Ripple Effect para XMars UI</a></li>
<li><a href="../pt484564/index.html">Escrevemos um driver para um laptop para diversão e lucro, ou como se comprometer com o kernel, mesmo que você seja um tolo</a></li>
<li><a href="../pt484568/index.html">Hack The Box - Jogador passo a passo. Exploração do FFmpeg, JWT e várias listagens na web</a></li>
<li><a href="../pt484572/index.html">Minha abordagem de gerenciamento de tempo / tarefa usando VSCode</a></li>
<li><a href="../pt484574/index.html">Sem carrapatos! Vetor de plantas versus doença de Lyme</a></li>
<li><a href="../pt484578/index.html">Objetivos do nível de serviço - Experiência do Google (tradução do capítulo do livro do Google SRE)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>