<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòï üë©üèæ‚Äçüè≠ üë®üèø‚Äç‚úàÔ∏è Uma vis√£o geral breve e din√¢mica da arquitetura do compilador üëÇüèΩ üâë üòé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maioria dos compiladores possui a seguinte arquitetura: 



 Neste artigo, vou dissecar essa arquitetura em detalhes, elemento por elemento. 
 Podem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma vis√£o geral breve e din√¢mica da arquitetura do compilador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  A maioria dos compiladores possui a seguinte arquitetura: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  Neste artigo, vou dissecar essa arquitetura em detalhes, elemento por elemento. <br>  Podemos dizer que este artigo √© uma adi√ß√£o √† enorme quantidade de recursos existentes no t√≥pico de compiladores.  √â uma fonte aut√¥noma que permitir√° que voc√™ entenda os conceitos b√°sicos de design e implementa√ß√£o de linguagens de programa√ß√£o. <br><br>  O p√∫blico-alvo do artigo s√£o pessoas cuja ideia do trabalho dos compiladores √© extremamente limitada (o m√°ximo √© que eles est√£o envolvidos na compila√ß√£o).  No entanto, espero que o leitor entenda estruturas e algoritmos de dados. <br><br>  O artigo n√£o √© de forma alguma dedicado aos compiladores de produ√ß√£o modernos com milh√µes de linhas de c√≥digo - n√£o, este √© um curso de curta dura√ß√£o "compiladores para manequins" para ajud√°-lo a entender o que √© um compilador. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Atualmente, estou trabalhando na linguagem do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Krug</a> inspirada no Rust and Go.  No artigo, vou me referir a Krug como um exemplo para ilustrar meus pensamentos.  O Krug est√° em desenvolvimento, mas j√° est√° dispon√≠vel em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/krug-lang</a> nos reposit√≥rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caasper</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">krug</a> .  A linguagem n√£o √© muito t√≠pica em compara√ß√£o com a arquitetura usual de compiladores, que me inspirou parcialmente a escrever um artigo - mas mais sobre isso mais tarde. <br><br>  Corro para inform√°-lo que n√£o sou especialista em compiladores!  N√£o tenho doutorado e n√£o fiz nenhum treinamento formal - estudei sozinho tudo o que foi descrito no artigo no meu tempo livre.  Devo tamb√©m dizer que n√£o estou descrevendo a abordagem real e correta para criar um compilador, mas apresento os m√©todos b√°sicos adequados para criar um pequeno compilador "brinquedo". <br><br><h2>  Frontend </h2><br>  Voltemos ao diagrama acima: as setas √† esquerda direcionadas para o campo de front-end s√£o linguagens conhecidas e amadas como C. O front-end se parece com isso: an√°lise lexical -&gt; analisador. <br><br><h2>  An√°lise lexical </h2><br>  Quando comecei a estudar compiladores e design de linguagem, me disseram que an√°lise lexical √© o mesmo que tokeniza√ß√£o.  Usaremos essa descri√ß√£o.  O analisador pega os dados de entrada na forma de seq√º√™ncias de caracteres ou um fluxo de caracteres e reconhece padr√µes neles, que s√£o cortados em tokens. <br><br>  No caso de um compilador, ele recebe um programa escrito na entrada.  Ele √© lido em uma sequ√™ncia de um arquivo e o analisador tokeniza seu c√≥digo-fonte. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  Nesse fragmento, escrito em uma linguagem em forma de C, voc√™ pode ver a estrutura que cont√©m o l√©xico acima mencionado, bem como o TokenType, que serve para reconhecer esse token. <br><br>  Nota: o artigo n√£o √© uma instru√ß√£o para criar um idioma com exemplos - mas, para uma melhor compreens√£o, inserirei trechos de c√≥digo de tempos em tempos. <br><br>  Os analisadores geralmente s√£o os componentes mais simples do compilador.  De fato, todo o front-end √© bastante simples comparado ao restante das pe√ßas do quebra-cabe√ßa.  Embora dependa muito do seu trabalho. <br><br>  Pegue o seguinte peda√ßo de c√≥digo C: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Ap√≥s a leitura de um arquivo para uma linha e a execu√ß√£o de uma verifica√ß√£o linear, voc√™ poder√° fatiar tokens.  Identificamos os tokens de maneira natural - visto que int √© uma "palavra" e 0 na declara√ß√£o de retorno √© um "n√∫mero".  O analisador lexical executa o mesmo procedimento que n√≥s - depois examinaremos esse processo com mais detalhes.  Por exemplo, analise os n√∫meros: <br><br><pre> <code class="plaintext hljs">0xdeadbeef ‚Äî HexNumber ( ) 1231234234 ‚Äî WholeNumber ( ) 3.1412 ‚Äî FloatingNumber (   ) 55.5555 ‚Äî FloatingNumber (   ) 0b0001 ‚Äî BinaryNumber ( )</code> </pre> <br>  Definir palavras pode ser dif√≠cil.  A maioria dos idiomas define uma palavra como uma sequ√™ncia de letras e n√∫meros, e um identificador geralmente deve come√ßar com uma letra ou sublinhado.  Por exemplo: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  No Go, esse c√≥digo n√£o ser√° considerado correto e ser√° analisado nos seguintes tokens: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  A maioria dos identificadores encontrados fica assim: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Os analisadores ter√£o que resolver outros problemas, por exemplo, com espa√ßos, coment√°rios de v√°rias linhas e de linha √∫nica, identificadores, n√∫meros, sistemas num√©ricos e formata√ß√£o de n√∫meros (por exemplo, 1_000_000) e codifica√ß√µes (por exemplo, suporte para UTF8 em vez de ASCII). <br><br>  E se voc√™ acha que pode recorrer a express√µes regulares - melhor n√£o vale a pena.  √â muito mais f√°cil escrever um analisador do zero, mas eu recomendo a leitura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste artigo</a> do nosso rei e deus Rob Pike.  As raz√µes pelas quais o Regex n√£o √© adequado para n√≥s s√£o descritas em muitos outros artigos, por isso vou omitir este ponto.  Al√©m disso, escrever um analisador √© muito mais interessante do que se atormentar com longas express√µes verbais carregadas no regex101.com √†s 5:24 da manh√£.  No meu primeiro idioma, usei a fun√ß√£o <code>split(str)</code> para tokeniza√ß√£o - e n√£o fui longe. <br><br><h2>  An√°lise </h2><br>  A an√°lise √© um pouco mais complicada do que a an√°lise lexical.  Existem muitos analisadores e analisadores-geradores - aqui o jogo come√ßa em grande estilo. <br><br>  Os analisadores nos compiladores geralmente recebem entradas na forma de tokens e constroem uma √°rvore espec√≠fica - uma √°rvore de sintaxe abstrata ou uma √°rvore de an√°lise.  Por sua natureza, eles s√£o semelhantes, mas t√™m algumas diferen√ßas. <br><br>  Esses est√°gios podem ser representados como fun√ß√µes: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  Normalmente, os compiladores s√£o criados a partir de muitos componentes pequenos que recebem, alteram ou convertem em sa√≠da diferente.  Essa √© uma das raz√µes pelas quais as linguagens funcionais s√£o adequadas para a cria√ß√£o de compiladores.  Outras raz√µes s√£o excelentes refer√™ncias e bibliotecas padr√£o bastante extensas.  Curiosidade: a primeira implementa√ß√£o do compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust</a> foi no Ocaml. <br><br>  Aconselho que voc√™ mantenha esses componentes o mais simples e aut√¥nomo poss√≠vel - a modularidade facilitar√° bastante o processo.  Na minha opini√£o, o mesmo pode ser dito sobre muitos outros aspectos do desenvolvimento de software. <br><br><h2>  √Årvores </h2><br><h4>  √Årvore de an√°lise </h4><br>  Que diabos √© isso?  Tamb√©m conhecida como √°rvore de an√°lise, essa √°rvore espessa serve para visualizar o programa de origem.  Eles cont√™m todas as informa√ß√µes (ou a maioria delas) sobre o programa de entrada, geralmente as mesmas descritas na gram√°tica do seu idioma.  Cada n√≥ da √°rvore ser√° √† direita ou √† direita, por exemplo, NumberConstant ou StringConstant. <br><br><h4>  √Årvore de sintaxe abstrata </h4><br>  Como o nome indica, o ASD √© uma <i>√°rvore de</i> sintaxe <i>abstrata</i> .  A √°rvore de an√°lise cont√©m muitas informa√ß√µes (geralmente redundantes) sobre o seu programa e, no caso de um ASD, isso n√£o √© necess√°rio.  O ASD n√£o precisa de informa√ß√µes in√∫teis sobre a estrutura e a gram√°tica, o que n√£o afeta a sem√¢ntica do programa. <br><br>  Suponha que sua √°rvore tenha uma express√£o como ((5 + 5) -3) +2.  Na √°rvore de an√°lise, voc√™ a armazenaria completamente, juntamente com colchetes, operadores e valores 5, 5, 3 e 2. Mas voc√™ pode simplesmente se associar ao ASD - precisamos apenas conhecer os valores, operadores e sua ordem. <br><br>  A imagem abaixo mostra a √°rvore para a express√£o a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD pode ser representado da seguinte maneira: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Essa vis√£o √© bastante limitada, mas espero que voc√™ possa ver como seus n√≥s ser√£o estruturados.  Para an√°lise, voc√™ pode recorrer ao seguinte procedimento: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  Espero que voc√™ entenda como a an√°lise passo a passo dos n√≥s restantes prosseguir√°, come√ßando com constru√ß√µes de linguagem de alto n√≠vel.  Como exatamente um analisador com uma descida recursiva √© implementado, voc√™ precisa se estudar. <br><br><h2>  Gram√°tica </h2><br>  A an√°lise em um ADS de um conjunto de tokens pode ser dif√≠cil.  Normalmente voc√™ deve come√ßar pela gram√°tica do seu idioma.  Em ess√™ncia, a gram√°tica determina a estrutura do seu idioma.  Existem v√°rios idiomas para definir idiomas que podem descrever (ou analisar) eles mesmos. <br><br>  Um exemplo de um idioma para determinar idiomas √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">forma estendida de Backus-Naur</a> (RBNF).  √â uma varia√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BNF</a> com menos colchetes angulares.  Aqui est√° um exemplo de RBNF de um artigo da Wikipedia: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  As regras de produ√ß√£o s√£o definidas: elas indicam qual modelo de terminal √© "n√£o terminal".  Os terminais fazem parte do alfabeto, por exemplo, o token if ou 0 e 1 no exemplo acima s√£o terminais.  Os n√£o terminais s√£o o seu oposto, est√£o do lado esquerdo das regras de produ√ß√£o e podem ser considerados vari√°veis ‚Äã‚Äãou "indicadores nomeados" para grupos de terminais e n√£o terminais. <br><br>  Muitos idiomas t√™m especifica√ß√µes que cont√™m gram√°tica.  Por exemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">D.</a> <br><br><h2>  Analisadores de descida recursiva </h2><br>  A descida recursiva √© a mais f√°cil de muitas abordagens de an√°lise. <br><br>  Analisadores de descida recursiva - descendente, com base em procedimentos recursivos.  √â muito mais f√°cil escrever um analisador, porque sua gram√°tica n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deixou recurs√£o</a> .  Na maioria das linguagens "de brinquedo", essa t√©cnica √© suficiente para analisar.  O GCC usa um analisador descendente escrito √† m√£o, embora o YACC tenha sido usado anteriormente. <br><br>  No entanto, a an√°lise desses idiomas pode causar problemas.  Em particular, C, onde <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  pode ser interpretado como <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  ou como <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  A implementa√ß√£o Clang tamb√©m usa um analisador de descida recursiva: <br><br>  <i>Como esse √© um c√≥digo C ++ comum, uma descida recursiva facilita a compreens√£o dos iniciantes.</i>  <i>Ele suporta regras personalizadas e outras coisas estranhas que o C / C ++ exige e ajuda a diagnosticar e corrigir erros com facilidade.</i> <br><br>  Tamb√©m vale a pena prestar aten√ß√£o a outras abordagens: <br><br><ul><li>  LL descendente, descida recursiva </li><li>  LR ascendente, deslocamento, descida ascendente </li></ul><br><h2>  Geradores de analisador </h2><br>  Outro bom caminho.  Obviamente, tamb√©m existem desvantagens - mas isso pode ser dito sobre qualquer outra escolha que os programadores fa√ßam ao criar software. <br><br>  Os geradores de analisador funcionam muito rapidamente.  Us√°-los √© mais f√°cil do que escrever seu pr√≥prio analisador e obter um resultado de qualidade - embora eles n√£o sejam muito amig√°veis ‚Äã‚Äãe nem sempre exibam mensagens de erro.  Al√©m disso, voc√™ precisar√° aprender a usar o gerador de analisador e, ao promover o compilador, provavelmente precisar√° desenrolar o gerador de analisador. <br><br>  Um exemplo de um gerador de analisador √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ANTLR</a> , existem muitos outros. <br><br>  Eu acho que essa ferramenta √© adequada para aqueles que n√£o querem gastar tempo escrevendo um front-end e que preferem escrever o meio e o back-end do compilador / int√©rprete e analisar qualquer coisa. <br><br><h2>  Aplicativo de an√°lise </h2><br>  Se voc√™ ainda n√£o se entende.  At√© o frontend do compilador (lex / parse) pode ser usado para resolver outros problemas: <br><br><ul><li>  destaque de sintaxe </li><li>  An√°lise de HTML / CSS para mecanismo de renderiza√ß√£o </li><li>  transpilers: TypeScript, CoffeeScript </li><li>  ligantes </li><li>  REGEX </li><li>  an√°lise de dados da interface </li><li>  An√°lise de URL </li><li>  ferramentas de formata√ß√£o como <i>gofmt</i> </li><li>  An√°lise de SQL e muito mais. </li></ul><br><h2>  Meados </h2><br>  An√°lise sem√¢ntica!  A an√°lise da sem√¢ntica da linguagem √© uma das tarefas mais dif√≠ceis ao criar um compilador. <br><br>  Voc√™ precisa garantir que todos os programas de entrada funcionem corretamente.  Na minha linguagem Krug, aspectos relacionados √† an√°lise sem√¢ntica ainda n√£o foram inclu√≠dos e, sem ela, o programador sempre ser√° obrigado a escrever o c√≥digo correto.  Na realidade, isso √© imposs√≠vel - e sempre escrevemos, compilamos, √†s vezes executamos, corrigimos erros.  Essa espiral √© intermin√°vel. <br><br>  Al√©m disso, a compila√ß√£o de programas √© imposs√≠vel sem a an√°lise da corre√ß√£o da sem√¢ntica no est√°gio apropriado da compila√ß√£o. <br><br>  Uma vez me deparei com um gr√°fico sobre a porcentagem de front-end, regi√£o central e back-end.  Ent√£o parecia <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Hoje √© algo como <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  O frontend se preocupa principalmente com o gerador e, em linguagens sem contexto que n√£o possuem a dualidade da gram√°tica, elas podem ser conclu√≠das rapidamente - uma descida recursiva ajudar√° aqui. <br><br>  Com a tecnologia LLVM, a maior parte do trabalho de otimiza√ß√£o pode ser carregada na estrutura, que apresenta v√°rias otimiza√ß√µes prontas. <br><br>  O pr√≥ximo passo √© a an√°lise sem√¢ntica, uma parte essencial da fase de compila√ß√£o. <br><br>  Por exemplo, no Rust, com seu modelo de gerenciamento de mem√≥ria, o compilador atua como uma m√°quina grande e poderosa que executa v√°rios tipos de an√°lise est√°tica em formas introdut√≥rias.  Parte desta tarefa √© converter os dados de entrada em um formul√°rio mais conveniente para an√°lise. <br><br>  Por esse motivo, a an√°lise sem√¢ntica desempenha um papel importante na arquitetura do compilador, e um trabalho preparat√≥rio exaustivo, como otimizar o assembly gerado ou ler os dados de entrada no ASD, √© feito para voc√™. <br><br><h2>  Passagens Sem√¢nticas </h2><br>  No curso da an√°lise sem√¢ntica, a maioria dos compiladores realiza um grande n√∫mero de "passagens sem√¢nticas" no SDA ou em outra forma abstrata de express√£o de c√≥digo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Este artigo</a> fornece detalhes sobre a maioria das passagens feitas no compilador .NET C #. <br><br>  N√£o considerarei cada passagem, especialmente porque elas variam dependendo do idioma, mas v√°rias etapas s√£o descritas abaixo em Krug. <br><br><h2>  An√∫ncio de n√≠vel superior </h2><br>  O compilador examinar√° todos os an√∫ncios de "n√≠vel superior" nos m√≥dulos e estar√° ciente de sua exist√™ncia.  Ele n√£o se aprofundar√° em blocos - ele simplesmente declarar√° quais estruturas, fun√ß√µes etc.  est√£o dispon√≠veis em um ou outro m√≥dulo. <br><br><h2>  Nome / S√≠mbolo Resolu√ß√£o </h2><br>  O compilador percorre todos os blocos de c√≥digo em fun√ß√µes, etc.  e os resolve - ou seja, localiza caracteres que requerem permiss√£o.  Essa √© uma passagem comum e √© a partir daqui que o erro <i>XYZ sem esse s√≠mbolo</i> geralmente ocorre ao compilar o c√≥digo Go. <br><br>  A execu√ß√£o desse passe pode ser muito dif√≠cil, especialmente se houver depend√™ncias circulares no seu diagrama de depend√™ncias.  Alguns idiomas n√£o os permitem, por exemplo, o Go lan√ßar√° um erro se um dos seus pacotes formar um loop, como a minha linguagem Krug.  Depend√™ncias c√≠clicas podem ser consideradas um efeito colateral da arquitetura ruim. <br><br>  Os loops podem ser determinados modificando o DFS no diagrama de depend√™ncia ou usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Tarjan</a> (como feito por Krug) para definir (v√°rios) loops. <br><br><h2>  Infer√™ncia de tipo </h2><br>  O compilador passa por todas as vari√°veis ‚Äã‚Äãe exibe seus tipos.  A infer√™ncia de tipo no Krug √© muito fraca; simplesmente gera vari√°veis ‚Äã‚Äãcom base em seus valores.  N√£o √© de forma alguma um sistema bizarro, como os que voc√™ pode encontrar em linguagens funcionais como Haskell. <br><br>  Os tipos podem ser derivados usando o processo de "unifica√ß√£o" ou "unifica√ß√£o de tipo".  Para sistemas do tipo mais simples, uma implementa√ß√£o muito simples pode ser usada. <br><br>  Tipos s√£o implementados no Krug assim: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Voc√™ tamb√©m pode ter uma infer√™ncia de tipo simples, na qual atribui um tipo a n√≥s de express√£o, por exemplo, <code>IntegerConstantNode</code> pode ser do tipo IntegerType (64).  E ent√£o voc√™ poder√° obter a fun√ß√£o <code>unify(t1, t2)</code> , que selecionar√° o tipo mais amplo que pode ser usado para deduzir o tipo de express√µes mais complexas, como as bin√°rias.  Portanto, √© uma quest√£o de atribuir uma vari√°vel √† esquerda aos valores dos tipos fornecidos √† direita. <br><br>  Certa vez, escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">elenco de tipos</a> simples no Go, que se tornou uma implementa√ß√£o de prot√≥tipo para o Krug. <br><br><h2>  Passe de Mutabilidade </h2><br>  Krug (como Rust) √© por padr√£o uma linguagem imut√°vel, ou seja, as vari√°veis ‚Äã‚Äãpermanecem inalteradas, a menos que especificado de outra forma: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  O compilador percorre todos os blocos e fun√ß√µes e verifica se suas ‚Äúvari√°veis ‚Äã‚Äãest√£o corretas‚Äù, ou seja, n√£o alteramos o que n√£o segue e que todas as vari√°veis ‚Äã‚Äãpassadas para determinadas fun√ß√µes s√£o constantes ou alter√°veis, quando necess√°rio. <br><br>  Isso √© feito com a ajuda de informa√ß√µes simb√≥licas que foram coletadas nos passes anteriores.  Uma tabela de s√≠mbolos com base nos resultados da passagem sem√¢ntica cont√©m nomes de token e sinais de variabilidade vari√°vel.  Pode conter outros dados, por exemplo, em C ++, uma tabela pode armazenar informa√ß√µes sobre se um s√≠mbolo √© externo ou est√°tico. <br><br><h2>  Tabelas de caracteres </h2><br>  Uma tabela de caracteres, ou "facada", √© uma tabela para encontrar os caracteres usados ‚Äã‚Äãno seu programa.  Uma tabela √© criada para cada escopo, e todos eles cont√™m informa√ß√µes sobre os caracteres presentes em um escopo espec√≠fico. <br><br>  Essas informa√ß√µes incluem propriedades como o nome do s√≠mbolo, tipo, sinal de mutabilidade, presen√ßa de comunica√ß√£o externa, local na mem√≥ria est√°tica e assim por diante. <br><br><h3>  √Çmbito de aplica√ß√£o </h3><br>  Este √© um conceito importante em linguagens de programa√ß√£o.  Obviamente, seu idioma n√£o precisa possibilitar a cria√ß√£o de escopos aninhados, tudo pode ser colocado em um espa√ßo para nome comum! <br><br>  Embora representar o escopo seja uma tarefa interessante para a arquitetura do compilador, na maioria das linguagens do tipo C, o escopo se comporta (ou √©) como uma estrutura de dados da pilha. <br><br>  Geralmente, criamos e destru√≠mos escopos, e eles geralmente s√£o usados ‚Äã‚Äãpara gerenciar nomes, ou seja, eles nos permitem ocultar vari√°veis ‚Äã‚Äã(sombreadas): <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Pode ser representado de maneira diferente: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Um pequeno offtopic, mas eu recomendo ler sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilha de espaguete</a> .  Essa √© uma estrutura de dados usada para armazenar √°reas de visibilidade nos n√≥s ASD dos blocos opostos. <br><br><h2>  Sistemas de tipos </h2><br>  Muitas das se√ß√µes a seguir podem ser desenvolvidas em artigos separados, mas parece-me que esse t√≠tulo merece mais isso.  Hoje, muitas informa√ß√µes est√£o dispon√≠veis sobre sistemas de tipos, bem como variedades dos pr√≥prios sistemas, em torno das quais muitas c√≥pias s√£o quebradas.  N√£o vou me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aprofundar</a> neste t√≥pico, basta deixar um link para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente artigo de Steve Klabnik</a> . <br><br>  Um sistema de tipos √© o que √© fornecido e definido semanticamente no compilador usando representa√ß√µes do compilador e an√°lise dessas representa√ß√µes. <br><br><h2>  Posse </h2><br>  Este conceito √© usado na programa√ß√£o cada vez mais.  Os princ√≠pios da sem√¢ntica de propriedade e movimento est√£o incorporados na linguagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust</a> , e espero que apare√ßam em outras l√≠nguas.  O Rust executa muitos tipos diferentes de an√°lise est√°tica, que verifica se a entrada satisfaz um conjunto de regras relacionadas √† mem√≥ria: quem possui qual mem√≥ria, quando a mem√≥ria √© destru√≠da e quantas refer√™ncias (ou empr√©stimos) existem para esses valores ou mem√≥ria. <br><br>  A beleza do Rust reside no fato de que tudo isso √© feito durante a compila√ß√£o, dentro do compilador, para que o programador n√£o precise lidar com a coleta de lixo ou a contagem de links.  Todas essas sem√¢nticas s√£o atribu√≠das ao sistema de tipos e podem ser fornecidas mesmo antes de o programa ser apresentado na forma de um arquivo bin√°rio completo. <br><br>  N√£o sei dizer como tudo funciona, mas tudo isso √© resultado de uma an√°lise est√°tica e de uma maravilhosa pesquisa da equipe Mozilla e dos participantes do projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cyclone</a> . <br><br><h2>  Gr√°ficos de fluxo de controle </h2><br>  Para representar fluxos de programa, usamos gr√°ficos de fluxo de controle (CFGs), que cont√™m todos os caminhos que a execu√ß√£o do programa pode seguir.  Isso √© usado na an√°lise sem√¢ntica para excluir se√ß√µes ociosas do c√≥digo, ou seja, blocos, fun√ß√µes e at√© m√≥dulos que nunca ser√£o alcan√ßados durante a execu√ß√£o do programa.  Os gr√°ficos tamb√©m podem ser usados ‚Äã‚Äãpara identificar ciclos que n√£o podem ser interrompidos.  Ou para procurar c√≥digo inacess√≠vel, por exemplo, quando voc√™ chama um ‚Äúp√¢nico‚Äù (chama um p√¢nico), ou retorna em um loop, e o c√≥digo fora do loop n√£o √© executado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A an√°lise do fluxo de dados</a> desempenha um papel importante durante a fase sem√¢ntica do compilador, por isso recomendo a leitura sobre os tipos de an√°lise que voc√™ pode executar, como eles funcionam e quais otimiza√ß√µes podem ser feitas. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>A parte final do nosso esquema de arquitetura.</i> <br><br>  Fizemos a maior parte do trabalho de gera√ß√£o de bin√°rios execut√°veis.  Isso pode ser feito de v√°rias maneiras, que discutiremos abaixo. <br><br>        - ,   . ,     ,    ¬´¬ª. <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ ‚Äî Cfront ‚Äî     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    ¬´¬ª ,     ,             ,       ,    ¬´  ¬ª  .        ‚Äî   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    ¬´ ¬ª,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      ‚Äî     , ‚Äî     ,      . <br><br> Go ‚Äî    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  ¬´¬ª       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   ‚Äî Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Godbolt</a> ‚Äî  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  ¬´¬ª,       IR   . , SSA ‚Äî Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   ‚Äî             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) ‚Äî   (NP- ).      ,     (liveness ranges) . <br></li><li>   ‚Äî       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   ‚Äî  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RLS</a> . <br><br>    Krug ‚Äî        ‚Äî   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  Links √∫teis </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jack Crenshaw</a> ‚Äî        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  LLVM ( Go)</a> ‚Äî ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PL/0</a> <br></li><li> The Dragon Book ‚Äî  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451894/">https://habr.com/ru/post/pt451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451878/index.html">Transmiss√£o ao vivo de v√≠deo est√©reo para √≥culos VR (Oculus Go)</a></li>
<li><a href="../pt451880/index.html">DevPRO'19: vista do estande da Wrike</a></li>
<li><a href="../pt451884/index.html">Sete anos trabalhando como desenvolvedor: que li√ß√µes aprendi</a></li>
<li><a href="../pt451886/index.html">Usando matem√°tica discreta nos testes</a></li>
<li><a href="../pt451890/index.html">Delega√ß√£o de uma zona de sub-rede reversa menor que / 24 no BIND. Como isso funciona</a></li>
<li><a href="../pt451896/index.html">Um eyeDisk "inquebr√°vel" √© protegido por uma varredura de √≠ris, mas transmite uma senha em texto n√£o criptografado</a></li>
<li><a href="../pt451898/index.html">Inova√ß√£o em russo</a></li>
<li><a href="../pt451900/index.html">Primeira contribui√ß√£o para a API do navegador do Facebook</a></li>
<li><a href="../pt451902/index.html">Acampamento do desenvolvedor do Microsoft Azure na R√∫ssia</a></li>
<li><a href="../pt451904/index.html">√Äs vezes, mais √© menos. Quando uma diminui√ß√£o na carga leva a um aumento no atraso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>