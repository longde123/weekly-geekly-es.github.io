<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍉 🧕🏻 🛍️ 使用P̶y̶t̶h̶o̶̶n̶Rust和WebAssembly解决日语填字游戏 🦄 👴🏻 🗻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如何为Python制作非图解算器，将其重写为Rust，以便可以通过WebAssembly在浏览器中直接运行它。 


 TL; DR 
 开始 


 关于Habré上的日语填字游戏（无字），已经有几篇文章。 例子 
 还有一个 。 
 图像使用位于行左侧和列上方的数字进行加密。 数字的数量显示相应...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用P̶y̶t̶h̶o̶̶n̶Rust和WebAssembly解决日语填字游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="防锈徽标为非图形"></p><br><p> 如何为Python制作非图解算器，将其重写为Rust，以便可以通过WebAssembly在浏览器中直接运行它。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo"> 开始 </h2><br><p> 关于Habré上的日语填字游戏（无字），已经有几篇文章。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例子</a> <br> 还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a> 。 </p><br><blockquote> 图像使用位于行左侧和列上方的数字进行加密。 数字的数量显示相应行或列中有多少组黑色（或颜色，对于颜色填字游戏），以及数字本身-这些组中的每一个包含多少个合并的单元格（例如，一组三个数字-4，1，和3表示该行中有三组：第一组-四个，第二组-一个，第三组-三个黑格。 在黑白填字游戏中，组必须至少由一个空白单元格隔开;在彩色填字游戏中，此规则仅适用于一种颜色的组，并且多色的组可以紧密隔开（空单元格也可以沿着行的边缘）。 有必要确定细胞组的位置。 </blockquote><p> 最普遍接受的观点之一是“正确”填字游戏只能称为以“逻辑”方式解决的填字游戏。 这通常称为解决方案方法，其中不考虑不同行和/或列之间的依赖关系。 换句话说，一种解决方案是对各个行或列的一系列<strong>独立</strong>决策，直到所有单元格都被填充为止（有关以下算法的更多信息）。 例如，只能在网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://nonograms.org/（http://nonograms.ru/</a> ）上找到此类非图。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在以光速解决日本有色填字游戏</a>一文中，已经引用了此站点的非图形作为示例。 为了进行比较和验证，我的求解器还增加了对从此站点下载和解析填字游戏的支持（感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">KyberPrizrak</a>允许使用其站点的资料）。 </p><br><p> 但是，当通常的“逻辑”方法导致死胡同时，非图的概念可以扩展到更普遍的问题。 在这种情况下，必须对一个单元格的颜色进行假设，并在证明这种颜色导致矛盾之后，为该单元格标记相反的颜色。 这些步骤的顺序可以（如果有耐心的话）为我们提供所有解决方案。 本文将主要讨论解决此类填字游戏的更一般情况。 </p><br><h2 id="python"> 巨蟒 </h2><br><p> 大约一年半以前，我无意间偶然发现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一篇</a>描述一种解决单行方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a> （后来发现，该方法相当慢）。 </p><br><p> 当我在Python（我的主要工作语言）中实现此方法并添加所有行的顺序更新时，我发现所有这些并没有很快得到解决。 在研究了材料之后，事实证明，在这个主题上，有许多作品和实现为这项任务提供了不同的方法。 </p><br><p> 在我看来，分析各种求解器实现的最雄心勃勃的工作是由扬·沃尔特（Jan Wolter）进行的，并在他的网站上发布（据我所知，它仍然是Internet上最大的非图公共公共存储库），该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细研究</a>包含大量信息和链接，可以帮助创建自己的求解器。 </p><br><p> 研究了大量资源（它们将在本文的结尾），我逐渐提高了求解器的速度和功能。 结果，我上瘾了，并且在空闲的时间里从事了10个月的算法实现，重构和调试。 </p><br><h3 id="osnovnye-algoritmy"> 核心算法 </h3><br><p> 生成的求解器可以用四个决策层的形式表示： </p><br><ul><li><p>  （ <strong>line</strong> ）线性求解器：在输入处，一行单元格和一条描述线（线索），在输出处，部分求解的线。 在python解决方案中，我实现了4种不同的算法（其中3种适用于颜色填字游戏）。 最快的是BguSolver算法，以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始来源</a>命名。 这是使用动态编程求解非图字符串的一种非常有效且几乎是标准的方法。 例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在本文中</a>找到此方法的伪代码。 </p><br></li><li><p>  （ <strong>传播</strong> ）我们将所有行和列放入队列中，并使用线性求解器进行遍历，当我们在求解行（列）时收到新信息时，我们分别使用新列（行）更新队列。 继续直到行为空。 </p><br><div class="spoiler">  <b class="spoiler_title">示例和代码</b> <div class="spoiler_text"><p>我们采取下一个任务从队列中解决。 使其为长度为7的空（未解析）字符串（我们将其表示为<code>???????</code> ），并带有对块<code>[2, 3]</code> 。 线性求解器将产生部分分解的字符串<code>?X??XX?</code> 其中<code>X</code>是填充的单元格。 更新行时，我们看到编号为1、4、5的列已更改（索引从0开始）。 这意味着新信息已出现在指示的列中，并且可以将其返回到“线性”求解器。 我们将这些列放在优先级较高的任务队列中（以便接下来将它们提供给线性求解器）。 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  （ <strong>探测</strong> ）每个未解析的单元格，我们对所有颜色选项进行排序，然后尝试使用此新信息进行传播。 如果存在矛盾，则将这种颜色从单元格的颜色选项中排除，然后尝试通过传播再次从中受益。 如果解决了，我们将解决方案添加到解决方案列表中，但继续尝试其他颜色（可能有几种解决方案）。 如果遇到无法进一步解决的情况，我们只需忽略并以其他颜色/单元重复该过程。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><p> 如果由于样本而收到矛盾，则返回True。 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  （ <strong>回溯</strong> ）如果在探测过程中您没有忽略部分解决的难题，而是继续递归地调用相同的过程，我们将进行回溯（换句话说，就是完全进入潜在决策树的深度）。 在这里，一个重要的角色开始发挥作用，将选择哪个单元作为潜在解决方案的下一个扩展。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此出版物中</a>对此主题进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>很好的研究。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><p> 回溯对我来说很混乱，但是这两个函数大致描述了递归搜索期间发生的情况 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p> 因此，我们从第二个层次开始解决我们的填字游戏（第一个仅适用于简并的情况，因为在整个填字游戏中只有一行或一列），然后逐步上移。 您可能会猜到，每个级别都会多次导致基础级别，因此，对于有效的解决方案，必须具有快速的第一级和第二级，对于复杂的难题可以调用数百万次。 </p><br><p> 在这个阶段，事实证明（完全可以预期），python根本不适合在这种CPU密集型任务中实现最高性能的工具：与低级语言相比，python中的所有计算效率极低。 例如，根据测量结果，在算法上最接近的BGU求解器（在Java中）在各种任务上的速度提高了7到17倍（有时高达27倍）。 </p><br><div class="spoiler">  <b class="spoiler_title">更多细节</b> <div class="spoiler_text"><pre>         Pynogram_my BGU_my加速
舞者0.976 0.141 6.921986      
猫1.064 0.110 9.672727      
防滑1.084 0.101 10.732673     
雄鹿1.116 0.118 9.457627      
边缘1.208 0.094 12.851064     
烟1.464 0.120 12.200000     
结1.332 0.140 9.514286      
秋千1.784 0.138 12.927536     
妈妈2.108 0.147 14.340136     
迪卡普2.076 0.176 11.795455     
悲剧2.368 0.265 8.935849      
默卡2.084 0.196 10.632653     
石油2.948 0.219 13.461187     
 M＆M 3.588 0.375 9.568000      
签名4.068 0.242 16.809917     
轻3.848 0.488 7.885246      
永远111.000 13.570 8.179808  
中心5.700 0.327 17.431193     
热门3.150 0.278 11.330935     
空手道2.500 0.219 11.415525     
 9堂510.000 70.416 7.242672      
国旗149.000 5.628 26.474769     
狮子71.000 2.895 24.525043     
马利12.108 4.405 2.748695      
东西321.000 46.166 6.953169      
自然inf 433.138 inf     
 Sierp inf inf NaN      
盖蒂国际基金会      
</pre><br><p> 测量是在我的车上进行的，困惑是根据Jan Wolter在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较中</a>使用的标准设置得出的 </p></div></div><br><p> 而且这已经是我开始使用PyPy之后的时间，在标准CPython上，计算时间比在PyPy上要长4-5倍！ 可以说，类似的Java求解器的性能比CPython代码高出28-85倍。 </p><br><p> 尝试使用性能分析（cProfile，SnakeViz，line_profiler）来提高我的求解器的性能虽然有所提高，但是它们并没有给出令人难以置信的结果。 </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> ： </h3><br><p>  <strong>+</strong>求解器可以解决<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//webpbn.com，http://nonograms.org</a>及其网站（基于ini）格式的所有难题 </p><br><p>  <strong>+</strong>解决任意数量的颜色的黑白和彩色非图（满足的最大颜色数为10） </p><br><p>  <strong>+</strong>解决缺少方块大小（填色）的难题。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这样的难题的一个例子</a> 。 </p><br><p>  <strong>+</strong>可以在浏览器中的控制台/诅咒/窗口中呈现拼图（安装附加的<em>Pynogram-web</em>选项时）。 对于所有模式，都支持实时查看解决方案的进度。 </p><br><p>  <strong>-</strong>计算速度慢（与求解程序的文章比较中描述的实现方式相比，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表</a> ）。 </p><br><p>  <strong>-</strong>低效的回溯：某些难题可以解决数小时（当决策树很大时）。 </p><br><h2 id="rust"> 铁锈 </h2><br><p> 年初，我开始学习Rust。 我像往常一样从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The Book开始</a> ，了解了WASM，并完成了所<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议的教程</a> 。 但是，我想要一些真正的任务，在其中您可以发挥语言的优势（主要是其超级性能），而不是某人发明的一些示例。 所以我回到了非图论。 但是现在我已经有了Python中所有算法的有效版本，可以直接重写。 </p><br><p> 好消息从一开始就对我充满期待：事实证明，Rust及其类型系统完美地描述了我的任务的数据结构。 例如，一种基本的对应关系<em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock</em>允许<em>您</em>永久地分离黑白和彩色非图。 如果在代码中的某处尝试使用普通的二进制描述块来解决彩色字符串，则会收到有关类型不匹配的编译错误。 </p><br><div class="spoiler">  <b class="spoiler_title">基本类型看起来像这样</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p> 在移植代码时，有些要点清楚地表明，静态类型的语言（例如Rust（很好，例如C ++））更适合此任务。 更准确地说，泛型和特征比类层次结构更好地描述了一个域。 因此，在Python代码中，我有两个用于线性<code>BguSolver</code>类<code>BguSolver</code>和<code>BguColoredSolver</code>它们分别求解黑白线和彩色线。 在Rust代码中，我仍然具有唯一的通用<code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code>结构，它可以解决两种类型的任务，具体取决于创建过程中传递的类型（ <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ）。 当然，这并不意味着在Python中无法完成类似的操作，只是在Rust中，类型系统清楚地向我表明，如果不这样做，就必须编写大量重复代码。 </p><br><p> 另外，当编写代码的过程归结为以下伪元算法时，任何尝试用Rust进行编写的人无疑都会注意到编译器中“信任”的影响： </p><br><pre> write_initial_code
 while（compiler_hints = $（货物检查））！= 0; 做
     fix_errors（compiler_hints）
结束
</pre><br><p> 当编译器停止发出错误和警告时，您的代码将与类型系统和借位检查器一致，并且您将预先警告一系列潜在的错误的发生（当然，要精心设计数据类型）。 </p><br><p> 我将给出一些函数示例，这些示例说明了Rust代码的简洁程度（与Python相比）。 </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p> 给出给定点（x，y）的未解决“邻居”列表 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">part_sums</b> <div class="spoiler_text"><p> 对于描述一条线的一组块，给出部分和（考虑到块之间的所需间隙），结果索引将指示该块可以终止的最小位置（此信息稍后将用于线性求解器）。 </p><br><p> 例如，对于这样的一组块<code>[2, 3, 1]</code>我们在输出<code>[2, 6, 8]</code>中有一个表示，这意味着第一个块可以最大程度地向左移动，以便其右边缘占据第二个单元格，其余的类似块： </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 1个区块的结尾|  |  | 
第2区块末尾-------- |
第3区块结束
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p> 移植时，我做了几处更改 </p><br><ul><li> 求解器核心（算法）进行了较小的更改（主要是为了支持单元和块的通用类型） </li><li> 留下了唯一（最快）的线性求解器算法 </li><li> 代替ini格式，引入了稍微修改的TOML格式 </li><li> 并未添加对填字游戏的支持，因为严格来讲，这是另一类任务 </li><li><p> 留下了唯一的输出方式-仅输出到控制台，但是现在控制台中的彩色单元格已绘制成真正的彩色（由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此板条箱</a> ） </p><br><div class="spoiler">  <b class="spoiler_title">像那样</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="杰克·斯派洛"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty"> 有用的工具 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clippy</a>是标准的静态分析器，有时甚至可以提供一些技巧，从而略微提高代码性能。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">valgrind</a>是用于动态应用程序分析的工具。 我用它作为探查器来搜索botneks（ <code>valrgind --tool=callgrind</code> ），尤其是内存<code>valrgind --tool=massif</code>代码的部分（ <code>valrgind --tool=massif</code> ）。 提示：在启动分析器之前，将<em>[profile.release] debug = true设置</em>为Cargo.toml。 这会将调试字符保留在可执行文件中。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kcachegrind</a>查看callgrind文件。 一个非常有用的工具，用于查找性能方面最棘手的地方。 </li></ul><br><h3 id="proizvoditelnost"> 性能表现 </h3><br><p> 开始在Rust上进行重写。 我们从已经提到的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较表中</a>提取填字游戏，并通过原始文章中描述的最佳求解器进行操作。 运行结果和描述。 我们获取结果<a href="">文件</a>并在其上构建几个图，由于求解时间从毫秒到数十分钟不等，因此该图以对数标度绘制。 </p><br><div class="spoiler">  <b class="spoiler_title">在jupyter笔记本电脑中运行</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  python求解器 </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="体能表现"><br></a> <br>  （ <em>图片可点击</em> ） </p><br><p> 我们看到这里的<em>笔法图</em>比所有提出的求解器都慢。 该规则的唯一例外是基于SAT的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tamura / Copris</a>解算器，它比我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解题</a>器解决最简单的难题（图的左侧）的时间更长。 但是，这是SAT求解器的功能：它们是为超复杂的填字游戏而设计的，其中常规的求解器会长时间滞留在回溯中。 这在图的右侧清晰可见，其中<em>Tamura / Copris</em>解决最困难的难题的速度比其他人快数十和数百倍。 </p><br><h5 id="rust-solver"> 除锈剂 </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="非全性能"><br></a> <br>  （ <em>图片可点击</em> ） </p><br><p> 该图表明，在简单任务上的非<em>齐格勒式</em>也能应付或稍差于用C和C ++编写的高性能求解器（ <em>Wolter</em>和<em>Syromolotov</em> ）。 随着任务的复杂化，我们的求解器大致重复了<em>BGU</em>求解器（Java）的轨迹，但几乎总是领先于其大约一个数量级。 在最艰巨的任务上， <em>田村/ Copris</em>始终领先于所有人。 </p><br><h5 id="rust-vs-python"> 锈与Python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-性能"><br></a> <br>  （ <em>图片可点击</em> ） </p><br><p> 最后，我们对这里描述的两个求解器进行了比较。 可以看出，Rust解算器几乎总是比python解算器提前1-3个数量级。 </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> ： </h3><br><p>  <strong>+</strong>求解器可以解决<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://webpbn.com</a>网站上的所有难题（不包括印迹-具有部分隐藏的块大小）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http</a> ：//nonograms.org及其自身（基于TOML）格式 </p><br><p>  <strong>+</strong>解决任意数量颜色的黑白和彩色非图 </p><br><p>  <strong>+</strong>可以将拼图渲染到控制台（颜色c webpbn.com绘制真实颜色） </p><br><p>  <strong>+</strong>运行速度快（与求解程序的文章比较中所述的实现方式相比，请参见表）。 </p><br><p>  <strong>-</strong>像Python解决方案一样，回溯仍然无效：某些难题（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，无害的20x20</a> ）可以解决数小时（当决策树很大时）。 也许值得回溯，而不是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集线器</a>上已经提到的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SAT解算器</a> 没错，我乍看之下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Rust</a>上发现的唯一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SAT求解器</a>似乎尚未完成并被抛弃。 </p><br><h2 id="webassembly"> 网络组装 </h2><br><p> 因此，用Rust重写代码已获得回报：求解器变得更快。 但是，Rust为我们提供了另一个非常酷的功能：WebAssembly中的编译以及直接在浏览器中运行代码的功能。 </p><br><p> 为了实现此功能，有一个用于Rust的特殊工具，它提供了必要的绑定器并生成样板，可以让您<em>轻松地</em>在JS代码中运行Rust函数<em>-wasm-pack</em> （+ <em>wasm-bindgen</em> ）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust和WebAssembly教程中</a>已经描述了与它以及其他重要工具有关的大多数工作。 但是，我必须自己弄清几点： </p><br><ul><li><p> 阅读时，会产生一种感觉，即该教程主要是为希望使用Rust加速其代码的JS开发人员编写的。 好吧，或者至少对于熟悉<em>npm的人来说</em> 。 对于我来说，作为一个远离前端的人，令人惊讶地发现，即使本书中的标准示例也不想使用与<code>npm run start</code>不同的第三方Web服务器。 </p><br><p> 幸运的是，wasm-pack具有一种模式，允许您生成常规JS代码（这不是npm模块）。  <code>wasm-pack build --target no-modules --no-typescript</code>将仅在输出中提供两个文件： <em>project-name.wasm-</em>编译为WebAssembly和<em>project-name.js</em>的Rust代码的二进制文件。 可以将最后一个文件添加到任何HTML页面<code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code>并使用WASM函数，而无需担心npm，webpack，ES6，模块和现代JS开发人员的其他乐趣。  <code>no-modules</code>模式非常适合WASM应用程序开发期间的非前端开发人员以及示例和演示，因为它不需要任何其他前端基础结构。 </p><br></li><li><p>  WebAssembly非常适合JavaScript繁重的任务。 首先，这些是执行许多计算的任务。 如果是这样，即使使用WebAssembly，也可以长时间执行此类任务，从而违反了现代Web的异步原理。 我正在谈论各种各样的<em>警告：</em>我的求解器工作时碰巧观察到的<em>无响应脚本</em> 。 要解决此问题，可以使用<em>Web worker</em>机制。 在这种情况下，使用“大量” WASM函数的方案可能如下所示： </p><br><ol><li> 从事件的主脚本（例如，单击按钮）中发送消息给工作人员，以启动重功能。 </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th> id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td> 5.4 </td><td> 7.4 </td><td> 9.2 </td></tr><tr><td> 8098 </td><td> 21.5 </td><td> 28.4 </td><td> 29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo"> TODO </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi"> 总结 </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454586/">https://habr.com/ru/post/zh-CN454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454574/index.html">小额信贷中的机器学习：为信用记录为空的客户建立评分模型</a></li>
<li><a href="../zh-CN454576/index.html">GandCrab作者停止工作：他们声称已经偷了足够多的东西</a></li>
<li><a href="../zh-CN454578/index.html">如何在Android WebView中连接PhotoSwipe画廊</a></li>
<li><a href="../zh-CN454582/index.html">是否应该将数组长度存储到C＃中的局部变量中？</a></li>
<li><a href="../zh-CN454584/index.html">界面开发学校：明斯克的任务分析和莫斯科的一套新任务</a></li>
<li><a href="../zh-CN454588/index.html">俄罗斯天然气工业股份公司邀请您访问：GPN数据科学聚会</a></li>
<li><a href="../zh-CN454590/index.html">Zimbra协作套件和带有ABQ的移动控制</a></li>
<li><a href="../zh-CN454592/index.html">通过黑客眼中的WAF</a></li>
<li><a href="../zh-CN454596/index.html">信息安全中的心理模型</a></li>
<li><a href="../zh-CN454598/index.html">无服务器架构和微服务：完美匹配？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>