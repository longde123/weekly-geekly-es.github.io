<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 🤵🏾 🖨️ Winkel-Zwei-Wege-Bindung, etwas verständnisvoller 📔 💺 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom Übersetzer  Von einem Übersetzer : Vor zwei Jahren startete ich mein erstes Projekt zu Angular (2+) mit einem großen und erfolgreichen AngularJS-H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winkel-Zwei-Wege-Bindung, etwas verständnisvoller</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453696/"><div class="spoiler">  <b class="spoiler_title">Vom Übersetzer</b> <div class="spoiler_text">  <b>Von einem Übersetzer</b> : Vor zwei Jahren startete ich mein erstes Projekt zu Angular (2+) mit einem großen und erfolgreichen AngularJS-Hintergrund.  Der Übergang erforderte eine spürbare Formatierung des Denkens, da zu viel auf A1 und A2 + „ein bisschen anders“ gemacht wird.  Der Schmerz des Übergangs hat den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gedankenstram-</a> Blog für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mich</a> deutlich reduziert.  Vor einem Jahr erhielt ich die Erlaubnis, diesen Artikel "über elementare und für alle leicht verständliche" zu übersetzen.  Aber sie sind solche Hände (ihre Artikel sind ein Haufen unfertiger).  Überraschenderweise lässt sich der Artikel gut auf Google Übersetzer übersetzen.  Einige der Nuancen dieser Übersetzung gingen jedoch verloren, ganz zu schweigen vom Stil des Autors.  Der Stil des Autors ist in meiner Version nicht vollständig erhalten geblieben.  Aber ich hoffe, ich habe es geschafft, die Stimmung und Gedanken des Artikels zu vermitteln. <br><br>  Ich verstehe, dass Angular nicht das beliebteste Thema bei Habré ist, aber ich hoffe, dass die Übersetzung jemandem hilft, so wie mir der ursprüngliche Artikel einmal geholfen hat. <br></div></div><br>  Das hat den Wow-Effekt im guten alten AngularJS verursacht, also ist es "Zwei-Wege-Bindung".  Diese Magie verliebte sich sofort in AngularJS und brach alle Ideen über langweilige Seitenprogrammierung und (oh, Horror!) Webformulare.  Änderungen an Daten werden sofort auf dem Bildschirm angezeigt und umgekehrt.  Diejenigen, die zuvor jQuery-Anwendungen entwickelt hatten, empfanden das Verknüpfen als ein Märchen.  Und bärtige Monster, die vor jQuery dicke Kunden sägten, begannen verzweifelt, die dumm verlorenen Mannmonate zu zählen. <br><br>  Darüber hinaus war die Magie der bidirektionalen Bindung nicht nur für spezielle Notationen und ausgewählte Komponenten verfügbar.  Wir könnten es leicht in unseren eigenen Anweisungen und Komponenten verwenden (nur durch Einstellen des Konfigurationsparameters). <br><br>  <b>In Angular2 + haben die Ersteller die integrierte bidirektionale Datenbindung aufgegeben</b> (außer über ngModel).  Dies bedeutet jedoch nicht, dass wir in unseren eigenen Anweisungen keine bidirektionale Bindung verwenden können. Es ist nur so, dass das Werbegeschenk vorbei ist und wir jetzt etwas selbst tun müssen.  Und vorzugsweise mit einem Verständnis dafür, wie es in Angular funktioniert. <br><a name="habracut"></a><br><h3>  Inhaltsverzeichnis </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwei-Wege-Bindung auf den Punkt gebracht</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NgModel verstehen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie Ihre eigenen bidirektionalen Datenbindungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><a name="in2word"></a><h3>  Zwei-Wege-Bindung auf den Punkt gebracht </h3><br>  In A2 + implementiert nur eine einzige Direktive die <b>bidirektionale</b> Datenbindung: <b>ngModel</b> .  Und auf den ersten Blick ist dies die gleiche Magie wie in AngularJS (nur in einer anderen Notation).  Aber was ist unter der Haube? <br><br>  Überraschenderweise ist unter der Haube alles relativ einfach und logisch: Die bidirektionale Bindung wird auf Eigenschaftsbindung und Ereignisbindung reduziert.  Zwei einseitige Bindungen statt einer bilateralen?  Ok, lass uns zwei. <br><br>  Und sofort ein Beispiel: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ja, ja, dies ist eine wunderschöne und erstaunliche Angular2-Demo aus dem Jahr 2009.  Kein Scherz, schön.  Beim Ändern des Felds fällt der <b>Benutzername</b> in das Modell und wird sofort in der Begrüßungsnachricht auf dem Formular angezeigt. <br><br>  Aber wie funktioniert es?  Denken Sie daran, dass die bidirektionale Bindung in Angular2 eine Eigenschaftsbindung und eine Ereignisbindung ist.  Und ja, sie können gleichzeitig in einer Richtlinie verfügbar sein.  Darüber hinaus <b>könnten</b> wir auch ohne <b>ngModel</b> problemlos eine <b>bidirektionale Datenbindung</b> implementieren.  Zum Beispiel so: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event.target.value"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Die Ausgabe <b>{{Benutzername}} ist</b> klar, aber was steht dort in der <b>Eingabe</b> ?  Lassen Sie uns verstehen: <br><br><ul><li>  <b>[value] = "Benutzername"</b> - Notation in eckigen Klammern, ordnet den Benutzernamenausdruck der value-Eigenschaft zu </li><li>  <b>(Eingabe) = "Ausdruck"</b> - eine Notation in Klammern, der Ausdruck wird an das <b>Eingabeereignis</b> angehängt (ja, es gibt ein solches Ereignis).  In unserem Fall: <br><ul><li>  <b>Benutzername = $ event.target.value</b> - Dieser Ausdruck wird als Antwort auf das Eingabeereignis ausgeführt </li><li>  <b>$ event</b> ist eine synthetische Variable in Angular-Ereignissen, die eine Nutzlast enthält. In diesem Fall enthält sie Informationen über das Geschehen und die Umgebung </li></ul></li></ul><br>  Wird es klarer?  Wir reparieren es. <br><br>  Wir binden die <b>Benutzername-</b> Eigenschaft des Angular-Modells an die <b>value-</b> Eigenschaft des Browser-Eingabeelements (Einwegbindung vom Modell zur Ansicht). <br><br>  Wir binden auch einen Ausdruck an das <b>Eingabeereignis</b> unseres Elements.  <b>Womit</b> der <b>Benutzername-</b> Eigenschaft des Modells der Wert von <b>$ event.target.value zugewiesen wird</b> . <br><br>  Was ist <b>$ event.target.value</b> ?  Wie bereits erwähnt, enthält <b>$ event</b> verschiedene nützliche Informationen zum Ereignis.  In diesem Fall handelt es sich um ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InputEventObject,</a> bei dem sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zieleigenschaft</a> auf das DOM-Element bezieht, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Ereignis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgelöst hat</a> (d. H. Unser Eingabeelement). <br><br>  Alles, was wir im Wesentlichen tun, ist, den Inhalt ( <b>Wert</b> ) des Eingabeelements ( <b>$ event.target</b> ) zu <b>lesen,</b> wenn der Benutzer einen Wert eingibt.  Wenn wir diesen Benutzernamenwert zuweisen, werden die Ansichtsdaten an das Modell gesendet. <br><br>  <b>Das ist alles.</b>  <b>Dies ist "Zwei-Wege-Bindung auf den Punkt gebracht".</b>  Schönheit? <br><br>  Aber wann kommt <b>ngModel</b> ins Spiel?  Das Szenario der Arbeit mit Eingabeelementen ist sehr verbreitet und gefragt.  Und aus irgendeinem Grund möchte ich eine Direktive haben, die die Implementierung verbirgt und vor zusätzlichen Tastenanschlägen schützt. <br><br><a name="ngModel"></a><h3>  NgModel verstehen </h3><br>  Wenn Sie sich die Quelle ansehen, können Sie sicherstellen, dass <b>ngModel</b> auch eine Bindung zur Eigenschaft und zum Ereignis hat.  So sieht unser ngModel-Beispiel aus, jedoch ohne Verwendung der Kurzsyntax: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModelChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Fast alles ist gleich.  Durch die Bindung der <b>Eigenschaft [ngModel] wird</b> der Wert des Eingabeelements aktualisiert.  Eine Ereignisbindung <b>(ngModelChange)</b> benachrichtigt die Welt, dass Änderungen im DOM auftreten. <br><br>  Und Sie haben festgestellt, dass der <b>Handlerausdruck</b> nur <b>$ event</b> und nicht <b>$ event.target.value verwendet</b> .  Stimmt hier etwas nicht?  Überhaupt nicht.  Wie oben erwähnt, ist <b>$ event</b> eine synthetische Variable, die eine <b>Nutzlast</b> trägt.  Die Entscheidung darüber, was als nützlich erachtet wird, trifft Angular.  Mit anderen Worten, <b>ngModelChange</b> kümmert sich um das Extrahieren von <b>target.value</b> aus dem internen <b>$</b> <b>-Ereignis</b> und gibt uns einfach das, was wir wollen, ohne Verpackung und Tamburin.  Um technisch korrekt zu sein, sind dies diejenigen von <a href="">DefaultValueAccessor</a> : Er ist es, der die Daten extrahiert und an das Basis-DOM-Objekt überträgt, obwohl ... Sie können einfach nicht darüber nachdenken). <br><br>  <b>Da das</b> zweimalige Schreiben von <b>Benutzername</b> und <b>ngModel</b> immer noch redundant ist, ermöglicht Angular die Verwendung der abgekürzten Syntax <b>[()]</b> , die auch als „Banane in einer Box“ bezeichnet wird.  Dies ähnelt dem vorherigen Beispiel und bringt uns zum Beispiel vom Anfang des Abschnitts zurück, jedoch mit einem Verständnis der <b>ngModel-</b> Implementierung.  Bereitstellung der gleichen bidirektionalen Bindung. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><a name="bindings"></a><br><h3>  Erstellen Sie Ihre eigenen bidirektionalen Datenbindungen </h3><br>  Jetzt wissen wir genug, um unsere eigenen bidirektionalen Datenbindungen zu erstellen.  Alles, was Sie tun müssen, ist einfach die gleichen Regeln wie <b>ngModel zu befolgen</b> , nämlich: <br><br><ul><li>  Geben Sie eine Eigenschaftsbindung ein (zum Beispiel: <b>[foo]</b> ) </li><li>  Binden Sie an ein Ereignis mit demselben Namen und Suffix <b>Ändern</b> (zum Beispiel: <b>(fooChange)</b> ) </li><li>  Stellen Sie sicher, dass die Ereignisbindung das Abrufen der Eigenschaft übernimmt (falls erforderlich). </li></ul><br>  Beachten Sie, dass das Erstellen einer bidirektionalen Datenbindung erheblich mehr Arbeit erfordert als AngularJS?  Dies könnte für uns sehr frustrierend sein ... Wenn wir versuchen würden, wo immer möglich unsere eigene Zwei-Wege-Bindung zu verwenden.  Im wirklichen Leben sollten Sie immer überlegen, ob wir eine bidirektionale Bindung benötigen und ob es bei Bedarf einfacher ist, ngModel zu nutzen.  Letzteres findet beispielsweise beim Erstellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierter Formularsteuerelemente statt</a> . <br><br>  Angenommen, wir erstellen eine benutzerdefinierte Zählerkomponente (und möchten kein benutzerdefiniertes Formularsteuerelement verwenden). <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'custom-counter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;{{counter}}&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } set counter(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = value; } decrement() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter--; } increment() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre><br>  Wir haben die Eigenschaft der <b>Zählerkomponente</b> , den aktuellen Wert des Zählers anzuzeigen.  Um es in beide Richtungen zu binden, müssen Sie es zunächst in einen <b>Eingabeparameter</b> umwandeln.  Hierfür ist der <b>Dekorator @Input ()</b> sehr nützlich: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; @Input() get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } ... }</code> </pre><br>  Auf diese Weise können Sie die Komponenteneigenschaft bereits wie folgt an den Verbraucher binden: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Jetzt müssen wir das Ereignis <b>@Output ()</b> mit demselben Namen ( <b>Zähler</b> ) und dem Suffix <b>Change setzen</b> (es stellt sich heraus, counterChange).  Wir möchten dieses Ereignis jedes Mal <b>auslösen,</b> wenn sich der <b>Zähler</b> ändert.  Warum die Eigenschaft <b>@Output ()</b> hinzufügen <b>?</b>  Und wir beenden in ein paar Schritten den Zählersetzer, in dem wir die Änderung des Wertes abfangen und das Ereignis mit dem aktuellen Zählerwert auswerfen: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ ... @Output() counterChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); set counter(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterChange.emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue); } ... }</code> </pre><br>  Das ist es!  Jetzt können wir den Ausdruck mithilfe der bidirektionalen Datenbindungssyntax an diese Eigenschaft binden: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>counterValue = {{someValue}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Schauen Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo an</a> und probieren Sie es aus! <br><br>  Denken Sie auch hier daran, dass eine Komponente wie ein benutzerdefinierter Zähler am besten mit einem benutzerdefinierten Formularsteuerelement implementiert werden kann, und nutzen Sie <b>ngModel</b> , um die <b>bidirektionale Datenbindung</b> zu implementieren, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel beschrieben</a> . <br><br><a name="conclusion"></a><h3>  Fazit </h3><br>  Angular verfügt nicht mehr über eine integrierte bidirektionale Datenbindung.  Stattdessen enthält das Feld APIs, mit denen Sie die vollständige Bindung als Bindungseigenschaften und -ereignisse implementieren können. <br><br>  <b>ngModel ist</b> eine in FormsModule integrierte bidirektionale Bindungsanweisung (denken Sie daran, sie dem <b>Importabschnitt</b> der <b>@ NgModule-</b> Deklaration <b>hinzuzufügen</b> : ca. per).  Die Verknüpfung über ngModel sollte bevorzugt werden, wenn Komponenten erstellt werden, die als benutzerdefinierte Formularsteuerelemente dienen.  Ansonsten hängt alles von Ihrer Vorstellungskraft ab. <br><br>  <b>PS vom Übersetzer:</b> <i>Die verbindliche Implementierung in A2 + ist moderner geworden.</i>  <i>Jetzt werden fast "freie" Setter verwendet, um Änderungen durch "Feng Shui" zu überwachen (obwohl klar ist, dass die Mechanismen für die Schmutzprüfung zumindest für hochrangige Benutzerkomponenten bestehen bleiben).</i>  <i>Dies ermöglichte es, 100.500 Beobachter aufzugeben (Verfahren zur Überwachung von Änderungen in „ihren“ Daten).</i>  <i>Was in A1 gerne eine böswillige Belastung des Browsers verursachte und ungewöhnlich direkte Hände bei der Planung umfangreicher interaktiver Seiten erforderte.</i> <i><br><br></i>  <i>Mit richtig gestalteten Komponenten reagiert A2 sofort besser.</i>  <i>Lassen Sie auf Kosten der Arbeit der Programmierer.</i>  <i>Jetzt können Sie eine Legion von Komponenten auf der Seite platzieren und müssen sich keine Gedanken mehr über Prozessorressourcen machen.</i> <i><br><br></i>  <i>Die Kehrseite der Medaille waren die anfänglichen Kosten des "Einstiegsprozesses" in A2 +, die die Popularität des Frameworks beeinflussten.</i>  <i>A1 hatte aber auch hohe Einstiegskosten, nur wurde es in die Major League verbannt.</i>  <i>Aufgrund mangelnden Verständnisses für die Organisation großer Anwendungen sind viele Prototypen auf A1 „gestartet“, dann „zusammengebrochen“ und entsprachen React and Vue.</i> <i><br><br></i>  <i>Ich hoffe, dass ich mit diesem Artikel dazu beitragen werde, die Schwelle für den ersten Zugang zu A2 +, der weiterhin gefragt ist (was ich aus erster Hand weiß), leicht zu senken.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453696/">https://habr.com/ru/post/de453696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453682/index.html">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs. Teil 2. Programmcode</a></li>
<li><a href="../de453686/index.html">Sicherheitswoche 22: Bedrohungsstatistiken, Bankentrojaner und beliebte Exploits</a></li>
<li><a href="../de453688/index.html">Java ist nicht nur ein blutiges Unternehmen, sondern auch schnell latenzempfindliche Anwendungen</a></li>
<li><a href="../de453692/index.html">3D Game Shader für Anfänger: Effekte</a></li>
<li><a href="../de453694/index.html">Stellen Sie wie unter Linux eine Verbindung zu Windows über SSH her</a></li>
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungsprüfung für Google Cloud Professional Data Engineer bestanden habe</a></li>
<li><a href="../de453708/index.html">AQUA RTOS Echtzeit-Betriebssystem für MK AVR in der BASCOM AVR-Umgebung</a></li>
<li><a href="../de453710/index.html">Entwicklungspraxis in großen Projekten: mitp SberPractice iOS # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>