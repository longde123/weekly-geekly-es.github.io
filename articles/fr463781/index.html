<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ üíÜüèª üë©‚Äçüöí Composants isol√©s zen dans l'architecture Android ‚ùî üë©üèæ‚Äçü§ù‚Äçüë©üèº üíÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques ann√©es, chez Badoo, nous avons commenc√© √† utiliser l'approche MVI pour le d√©veloppement Android. Il √©tait destin√© √† simplifier une bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Composants isol√©s zen dans l'architecture Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br>  Il y a quelques ann√©es, chez Badoo, nous avons commenc√© √† utiliser l'approche MVI pour le d√©veloppement Android.  Il √©tait destin√© √† simplifier une base de code complexe et √† √©viter le probl√®me des √©tats incorrects: dans des sc√©narios simples, il est facile, mais plus le syst√®me est complexe, plus il est difficile de le maintenir sous la forme correcte et plus il est facile de manquer un bogue. <br><br>  Dans Badoo, toutes les applications sont asynchrones - non seulement en raison des nombreuses fonctionnalit√©s disponibles pour l'utilisateur via l'interface utilisateur, mais √©galement en raison de la possibilit√© d'envoi de donn√©es √† sens unique par le serveur.  En utilisant l'ancienne approche de notre module de discussion, nous sommes tomb√©s sur plusieurs bogues √©tranges difficiles √† reproduire, que nous avons d√ª consacrer beaucoup de temps √† √©liminer. <br><br>  Notre coll√®gue Zsolt Kocsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> ) du bureau de Londres a expliqu√© comment l'utilisation de MVI nous permet de cr√©er des composants ind√©pendants faciles √† r√©utiliser, quels avantages nous obtenons et quels inconv√©nients nous avons rencontr√©s lors de l'utilisation de cette approche. <a name="habracut"></a><br><br>  Il s'agit du troisi√®me article d'une s√©rie d'articles sur l'architecture Badoo Android.  Liens vers les deux premiers: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Architecture MVI moderne bas√©e sur Kotlin</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construire un syst√®me de composants r√©actifs avec Kotlin</a> . <br></li></ol><br><h2>  Ne vous attardez pas sur des composants mal connect√©s. </h2><br>  Une connectivit√© faible est consid√©r√©e comme meilleure que forte.  Si vous ne comptez que sur des interfaces et non sur des impl√©mentations sp√©cifiques, il vous sera plus facile de remplacer des composants, il est plus facile de passer √† d'autres impl√©mentations sans r√©√©crire la majeure partie du code, ce qui simplifie notamment les tests unitaires. <br><br>  Nous terminons g√©n√©ralement ici et disons que nous avons fait tout notre possible en termes de connectivit√©. <br><br>  Cependant, cette approche n'est pas optimale.  Supposons que vous ayez une classe A qui doit utiliser les capacit√©s de trois autres classes: B, C et D. M√™me si vous vous y r√©f√©rez via des interfaces, la classe A devient plus difficile avec chacune de ces classes: <br><br><ul><li>  il conna√Æt toutes les m√©thodes de toutes les interfaces, leurs noms et types de retour, m√™me s'il ne les utilise pas; <br></li><li>  lors du test de A, vous devez configurer davantage de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simulations</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objet factice</a> ); <br></li><li>  il est plus difficile d'utiliser A √† plusieurs reprises dans d'autres contextes o√π nous n'avons pas ou ne voulons pas avoir B, C et D. <br></li></ul><br>  Bien entendu, c'est pr√©cis√©ment la classe A qui doit d√©terminer l'ensemble minimum d'interfaces n√©cessaire pour cela (principe de s√©gr√©gation des interfaces de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SOLID</a> ).  Cependant, dans la pratique, nous avons tous d√ª faire face √† des situations o√π, pour des raisons de commodit√©, une approche diff√©rente a √©t√© adopt√©e: nous avons pris une classe existante qui impl√©mente certaines fonctionnalit√©s, extrait toutes ses m√©thodes publiques dans l'interface, puis utilis√© cette interface l√† o√π la classe mentionn√©e √©tait n√©cessaire.  Autrement dit, l'interface n'a pas √©t√© utilis√©e sur la base de ce que ce composant est requis, mais sur la base de ce qu'un autre composant peut offrir. <br><br>  Avec cette approche, la situation s'aggrave avec le temps.  Chaque fois que nous ajoutons de nouvelles fonctionnalit√©s, nos classes sont li√©es dans un r√©seau de nouvelles interfaces dont elles ont besoin de conna√Ætre.  Les classes augmentent en taille et les tests deviennent de plus en plus difficiles. <br><br>  Par cons√©quent, lorsque vous devez les utiliser dans un contexte diff√©rent, il sera presque impossible de les d√©placer sans tout cet enchev√™trement avec lequel ils sont connect√©s, m√™me via des interfaces.  Vous pouvez faire une analogie: vous voulez utiliser une banane, et c'est entre les mains d'un singe qui pend sur un arbre, donc en cons√©quence, dans la charge sur la banane, vous obtiendrez un morceau entier de la jungle.  En bref, le processus de transfert prend beaucoup de temps et vous vous demandez rapidement pourquoi, en pratique, il est si difficile de r√©utiliser le code. <br><br><h2>  Composants Black Box </h2><br>  Si nous voulons que le composant soit facilement et r√©utilisable, alors pour cela nous n'avons pas besoin de conna√Ætre deux choses: <br><br><ul><li>  √† quel autre endroit il est utilis√©; <br></li><li>  sur d'autres composants qui ne sont pas li√©s √† sa mise en ≈ìuvre interne. <br></li></ul><br>  La raison est claire: si vous ne connaissez pas le monde ext√©rieur, vous ne serez pas connect√© avec lui. <br><br>  Ce que nous attendons vraiment du composant: <br><br><ul><li>  d√©finir ses propres donn√©es d'entr√©e (entr√©e) et de sortie (sortie); <br></li><li>  Ne pensez pas d'o√π viennent ces donn√©es ni o√π elles vont; <br></li><li>  il doit √™tre autosuffisant pour que nous n'ayons pas besoin de conna√Ætre la structure interne du composant pour son utilisation. <br></li></ul><br>  Vous pouvez consid√©rer le composant comme une bo√Æte noire ou un circuit int√©gr√©.  Elle a des contacts d'entr√©e et de sortie.  Vous les soudez - et le microcircuit fait partie d'un syst√®me dont il ne sait rien. <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br>  Jusqu'√† pr√©sent, on supposait que nous parlions de flux de donn√©es bidirectionnels: si la classe A a besoin de quelque chose, elle extrait une m√©thode via l'interface B et re√ßoit le r√©sultat sous la forme de la valeur retourn√©e par la fonction. <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br>  Mais alors A conna√Æt B, et nous voulons √©viter cela. <br><br>  Bien s√ªr, un tel sch√©ma est logique pour les fonctionnalit√©s d'impl√©mentation de bas niveau.  Mais si nous avons besoin d'un composant r√©utilisable qui fonctionne comme une bo√Æte noire autonome, nous devons nous assurer qu'il ne sait rien des interfaces externes, des noms de m√©thode ou des valeurs de retour. <br><br><h2>  On passe √† l'unidirectionnalit√© </h2><br>  Mais sans noms et m√©thodes d'interface, nous ne pouvons rien appeler!  Il ne reste plus qu'√† utiliser un flux de donn√©es unidirectionnel, dans lequel nous obtenons simplement des entr√©es et g√©n√©rons des sorties: <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br>  Au d√©but, cela peut ressembler √† une limitation, mais une telle solution pr√©sente de nombreux avantages, qui seront discut√©s ci-dessous. <br><br>  D√®s le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article,</a> nous savons que les fonctionnalit√©s (Feature) d√©finissent leurs propres donn√©es d'entr√©e (Wish) et leurs propres donn√©es de sortie (State).  Par cons√©quent, peu importe pour eux d'o√π vient le souhait ou o√π va l'√âtat. <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br>  Voil√† ce dont nous avons besoin!  Les fonctionnalit√©s peuvent √™tre utilis√©es partout o√π vous pouvez leur donner une entr√©e, et avec la sortie, vous pouvez faire ce que vous voulez.  Et comme les fonctionnalit√©s ne communiquent pas directement avec d'autres composants, ce sont des modules autonomes et ind√©pendants. <br><br>  Maintenant, prenez la vue et concevez-la pour qu'elle soit √©galement un module autonome. <br><br>  Tout d'abord, la vue doit √™tre aussi simple que possible afin qu'elle ne puisse g√©rer que ses t√¢ches internes. <br><br>  Quel genre de t√¢ches?  Il y en a deux: <br><br><ul><li>  rendu ViewModel (entr√©e); <br></li><li>  d√©clenchement de ViewEvents en fonction des actions de l'utilisateur (sortie). <br></li></ul><br>  Pourquoi utiliser ViewModel?  Pourquoi ne pas dessiner directement l'√©tat de la fonction? <br><br><ul><li>  (Non) afficher une fonctionnalit√© √† l'√©cran ne fait pas partie de l'impl√©mentation.  La vue doit pouvoir s'afficher si les donn√©es proviennent de plusieurs sources. <br></li><li>  Pas besoin de refl√©ter la complexit√© de l'√©tat dans la vue.  Le ViewModel ne doit contenir que les informations pr√™tes √† √™tre affich√©es qui sont n√©cessaires pour rester simple. <br></li></ul><br>  En outre, View ne devrait pas √™tre int√©ress√© par les √©l√©ments suivants: <br><br><ul><li>  d'o√π viennent tous ces ViewModels; <br></li><li>  ce qui se passe lorsque ViewEvent est d√©clench√©; <br></li><li>  toute logique m√©tier; <br></li><li>  suivi analytique; <br></li><li>  journalisation <br></li><li>  d'autres t√¢ches. <br></li></ul><br>  Toutes ces t√¢ches sont externes et View ne doit pas y √™tre connect√©.  Arr√™tons-nous et r√©sumons la simplicit√© de la vue: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Une impl√©mentation Android devrait: <br><br><ol><li>  Trouvez les vues Android par leur ID. <br></li><li>  Impl√©mentez la m√©thode accept de l'interface client en d√©finissant la valeur √† partir du ViewModel. <br></li><li>  D√©finissez les √©couteurs (ClickListeners) pour interagir avec l'interface utilisateur pour g√©n√©rer des √©v√©nements sp√©cifiques. <br></li></ol><br>  Un exemple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br>  S'il ne se limite pas aux fonctionnalit√©s et √† la vue, voici √† quoi ressemblera tout autre composant avec cette approche: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Maintenant, tout est clair avec le motif! <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2>  Unissez-vous, unissez-vous, unissez-vous! </h2><br>  Mais que se passe-t-il si nous avons diff√©rents composants et chacun d'eux a sa propre entr√©e et sortie?  Nous allons les connecter! <br><br>  Heureusement, cela peut facilement √™tre fait √† l'aide de Binder, ce qui aide √©galement √† cr√©er la bonne port√©e, comme nous le savons dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me article</a> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2>  Le premier avantage: facile √† √©tendre sans modifications </h2><br>  L'utilisation de composants non li√©s sous la forme de bo√Ætes noires qui ne sont connect√©es que temporairement nous permet d'ajouter de nouvelles fonctionnalit√©s sans modifier les composants existants. <br><br>  Prenons un exemple simple: <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br>  Ici, les fonctionnalit√©s (F) et View (V) sont simplement connect√©es les unes aux autres. <br><br>  Les liaisons correspondantes seront: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br>  Supposons que nous voulons ajouter le suivi de certains √©v√©nements d'interface utilisateur √† ce syst√®me. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br>  La bonne nouvelle est que nous pouvons le faire simplement en r√©utilisant le canal de vue de sortie existant: <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br>  En code, cela ressemble √† ceci: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br>  De nouvelles fonctionnalit√©s peuvent √™tre ajout√©es avec une seule ligne de reliure suppl√©mentaire.  Maintenant, non seulement nous ne pouvons pas changer une seule ligne de vue de code, mais il ne sait m√™me pas que la sortie est utilis√©e pour r√©soudre un nouveau probl√®me. <br><br>  De toute √©vidence, il nous est d√©sormais plus facile d‚Äô√©viter des soucis suppl√©mentaires et des composants inutilement compliqu√©s.  Ils restent simples.  Vous pouvez ajouter des fonctionnalit√©s au syst√®me en connectant simplement les composants aux composants existants. <br><br><h2>  Deuxi√®me avantage: facilit√© d'utilisation r√©p√©t√©e </h2><br>  En utilisant l'exemple de Feature and View, on peut clairement voir que nous pouvons ajouter une nouvelle source d'entr√©e ou un consommateur de donn√©es de sortie avec une seule ligne avec liaison.  Cela facilite grandement la r√©utilisation des composants dans diff√©rentes parties de l'application. <br><br>  Cependant, cette approche n'est pas limit√©e aux classes.  Cette fa√ßon d'utiliser les interfaces nous permet de d√©crire des composants r√©actifs autonomes de toute taille. <br><br>  En nous limitant √† certaines donn√©es d'entr√©e et de sortie, nous nous d√©barrassons de la n√©cessit√© de savoir comment tout fonctionne sous le capot, et donc nous √©vitons facilement de lier accidentellement les composants internes des composants avec d'autres parties du syst√®me.  Et sans liaison, vous pouvez facilement et simplement utiliser des composants √† plusieurs reprises. <br><br>  Nous y reviendrons dans l'un des articles suivants et examinerons des exemples d'utilisation de cette technique pour connecter des composants de niveau sup√©rieur. <br><br><h2>  Premi√®re question: o√π mettre les fixations? </h2><br><ol><li>  Choisissez le niveau d'abstraction.  Selon l'architecture, il peut s'agir d'une activit√©, d'un fragment ou d'un ViewController.  J'esp√®re que vous avez encore un certain niveau d'abstraction dans les parties o√π il n'y a pas d'interface utilisateur.  Par exemple, dans certaines des √©tendues de l'arborescence de contexte DI. <br></li><li>  Cr√©ez une classe distincte pour la liaison au m√™me niveau que cette partie de l'interface utilisateur.  S'il s'agit de FooActivity, FooFragment ou FooViewController, vous pouvez placer FooBindings √† c√¥t√©. <br></li><li>  Assurez-vous d'int√©grer FooBindings dans les m√™mes instances de composant que vous utilisez dans l'activit√©, le fragment, etc. <br></li><li>  Pour former l'√©tendue des liaisons, utilisez le cycle de vie Activit√© ou fragment.  Si cette boucle n'est pas li√©e √† Android, vous pouvez cr√©er des d√©clencheurs manuellement, par exemple, lors de la cr√©ation ou de la destruction d'une √©tendue DI.  D'autres exemples de port√©e sont d√©crits dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me article</a> . <br></li></ol><br><h3>  Deuxi√®me question: les tests </h3><br>  Puisque notre composant ne sait rien des autres, nous n'avons g√©n√©ralement pas besoin de stubs √† la place.  Les tests sont simplifi√©s pour v√©rifier la bonne r√©ponse du composant aux donn√©es d'entr√©e et produire les r√©sultats attendus. <br><br>  Dans le cas de Feature, cela signifie: <br><br><ul><li>  la possibilit√© de tester si certaines donn√©es d'entr√©e g√©n√®rent l'√©tat attendu (sortie). <br></li></ul><br>  Et dans le cas de View: <br><br><ul><li>  nous pouvons tester si un ViewModel particulier (entr√©e) conduit √† l'√©tat attendu de l'interface utilisateur; <br></li><li>  nous pouvons tester si la simulation de l'interaction avec l'interface utilisateur conduit √† l'initialisation dans le ViewEvent attendu (sortie). <br></li></ul><br>  Bien s√ªr, les interactions entre les composants ne disparaissent pas comme par magie.  Nous venons d'extraire ces t√¢ches des composants eux-m√™mes.  Ils doivent encore √™tre test√©s.  Mais o√π? <br><br>  Dans notre cas, Binders est responsable de la connexion des composants: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br>  Nos tests devraient confirmer ce qui suit: <br><br>  1. Transformateurs (mappeurs). <br><br>  Certaines connexions ont des mappeurs, et vous devez vous assurer qu'ils convertissent correctement les √©l√©ments.  Dans la plupart des cas, un test unitaire tr√®s simple suffit pour cela, car les mappeurs sont g√©n√©ralement aussi tr√®s simples: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2. Communication. <br><br>  Vous devez vous assurer que les connexions sont correctement configur√©es.  Quel est l'int√©r√™t du travail des composants individuels et des mappeurs, si pour une raison quelconque la connexion entre eux n'a pas √©t√© √©tablie?  Tout cela peut √™tre test√© en configurant l'environnement de liaison avec des talons, des sources d'initialisation et en v√©rifiant si les r√©sultats attendus sont re√ßus c√¥t√© client: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br>  Et bien que pour les tests, vous devrez √©crire sur la m√™me quantit√© de code qu'avec d'autres approches, cependant, les composants autosuffisants facilitent le test des parties individuelles, car les t√¢ches sont clairement s√©par√©es. <br><br><h2>  Mati√®re √† r√©flexion </h2><br>  Bien que la description de notre syst√®me sous la forme d'un graphique de cases noires soit bonne pour la compr√©hension g√©n√©rale, cela ne fonctionne que tant que la taille du syst√®me est relativement petite. <br><br>  Cinq √† huit lignes de reliure sont acceptables.  Mais, ayant plus connect√©, il sera assez difficile de comprendre ce qui se passe: <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br>  Nous √©tions confront√©s au fait qu'avec une augmentation du nombre de liens (il y en avait encore plus que dans le fragment de code pr√©sent√©) la situation devenait encore plus compliqu√©e.  La raison n'√©tait pas seulement dans le nombre de lignes - certaines sortes de liaisons pouvaient √™tre regroup√©es et extraites pour diff√©rentes m√©thodes - mais aussi parce qu'il devenait de plus en plus difficile de tout garder en vue.  Et c'est toujours un mauvais signe.  Si des dizaines de composants diff√©rents sont situ√©s au m√™me niveau, il est impossible d'imaginer toutes les interactions possibles. <br><br>  La raison en est l'utilisation de composants - bo√Ætes noires ou autre chose? <br><br>  De toute √©vidence, si la port√©e que vous d√©crivez est initialement complexe, aucune approche ne vous sauvera du probl√®me mentionn√© jusqu'√† ce que vous divisiez le syst√®me en parties plus petites.  Ce sera compliqu√© m√™me sans une √©norme liste de fixations, ce ne sera tout simplement pas si √©vident.  De plus, il vaut mieux que la complexit√© soit exprim√©e explicitement et non cach√©e.  Il est pr√©f√©rable de voir une liste croissante de jointures sur une seule ligne qui vous rappelle le nombre de composants individuels que vous ne connaissez pas sur ces liens cach√©s √† l'int√©rieur des classes dans diff√©rents appels de m√©thode. <br><br>  √âtant donn√© que les composants eux-m√™mes sont simples (ce sont des bo√Ætes noires et que des processus suppl√©mentaires n'y entrent pas), il est plus facile de les s√©parer, ce qui signifie que c'est un pas dans la bonne direction.  Nous avons d√©plac√© la difficult√© √† un seul endroit - √† la liste des fixations, un coup d'≈ìil qui vous permet d'√©valuer la situation g√©n√©rale et de commencer √† r√©fl√©chir √† la fa√ßon de sortir de ce g√¢chis. <br><br>  La recherche d'une solution nous a pris beaucoup de temps, et elle est toujours en cours.  Nous pr√©voyons de discuter de la fa√ßon de faire face √† ce probl√®me dans les articles suivants.  Restez en contact! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463781/">https://habr.com/ru/post/fr463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463769/index.html">Mitap Netologii ¬´Carri√®re en science des donn√©es: du d√©butant au interm√©diaire¬ª</a></li>
<li><a href="../fr463771/index.html">[Peter] Rencontre JUG.ru avec Sebastian Dashner - Rendre les tests d'entreprise plus joyeux</a></li>
<li><a href="../fr463773/index.html">Comment la protection des enfants contre les informations est organis√©e - et l'histoire enchanteresse sur l'origine de ces informations (18+)</a></li>
<li><a href="../fr463775/index.html">Qui utilise le protocole d'authentification SAML 2.0</a></li>
<li><a href="../fr463777/index.html">Surveillance de la disponibilit√© des h√¥tes Powershell</a></li>
<li><a href="../fr463785/index.html">Pr√©sentation des √©mulateurs de terminaux</a></li>
<li><a href="../fr463787/index.html">La grande vieille surprise de HP</a></li>
<li><a href="../fr463789/index.html">La puissance des g√©n√©riques dans Swift. 2e partie</a></li>
<li><a href="../fr463791/index.html">Poign√©e en fer: cin√©matique du d√©barquement des oiseaux en fonction de la g√©om√©trie et de la texture de la surface</a></li>
<li><a href="../fr463795/index.html">Nuances de sens en anglais: comment utiliser les verbes conseiller, recommander, sugg√©rer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>