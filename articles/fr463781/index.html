<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 💆🏻 👩‍🚒 Composants isolés zen dans l'architecture Android ❔ 👩🏾‍🤝‍👩🏼 💂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques années, chez Badoo, nous avons commencé à utiliser l'approche MVI pour le développement Android. Il était destiné à simplifier une bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Composants isolés zen dans l'architecture Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br>  Il y a quelques années, chez Badoo, nous avons commencé à utiliser l'approche MVI pour le développement Android.  Il était destiné à simplifier une base de code complexe et à éviter le problème des états incorrects: dans des scénarios simples, il est facile, mais plus le système est complexe, plus il est difficile de le maintenir sous la forme correcte et plus il est facile de manquer un bogue. <br><br>  Dans Badoo, toutes les applications sont asynchrones - non seulement en raison des nombreuses fonctionnalités disponibles pour l'utilisateur via l'interface utilisateur, mais également en raison de la possibilité d'envoi de données à sens unique par le serveur.  En utilisant l'ancienne approche de notre module de discussion, nous sommes tombés sur plusieurs bogues étranges difficiles à reproduire, que nous avons dû consacrer beaucoup de temps à éliminer. <br><br>  Notre collègue Zsolt Kocsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> ) du bureau de Londres a expliqué comment l'utilisation de MVI nous permet de créer des composants indépendants faciles à réutiliser, quels avantages nous obtenons et quels inconvénients nous avons rencontrés lors de l'utilisation de cette approche. <a name="habracut"></a><br><br>  Il s'agit du troisième article d'une série d'articles sur l'architecture Badoo Android.  Liens vers les deux premiers: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Architecture MVI moderne basée sur Kotlin</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construire un système de composants réactifs avec Kotlin</a> . <br></li></ol><br><h2>  Ne vous attardez pas sur des composants mal connectés. </h2><br>  Une connectivité faible est considérée comme meilleure que forte.  Si vous ne comptez que sur des interfaces et non sur des implémentations spécifiques, il vous sera plus facile de remplacer des composants, il est plus facile de passer à d'autres implémentations sans réécrire la majeure partie du code, ce qui simplifie notamment les tests unitaires. <br><br>  Nous terminons généralement ici et disons que nous avons fait tout notre possible en termes de connectivité. <br><br>  Cependant, cette approche n'est pas optimale.  Supposons que vous ayez une classe A qui doit utiliser les capacités de trois autres classes: B, C et D. Même si vous vous y référez via des interfaces, la classe A devient plus difficile avec chacune de ces classes: <br><br><ul><li>  il connaît toutes les méthodes de toutes les interfaces, leurs noms et types de retour, même s'il ne les utilise pas; <br></li><li>  lors du test de A, vous devez configurer davantage de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simulations</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objet factice</a> ); <br></li><li>  il est plus difficile d'utiliser A à plusieurs reprises dans d'autres contextes où nous n'avons pas ou ne voulons pas avoir B, C et D. <br></li></ul><br>  Bien entendu, c'est précisément la classe A qui doit déterminer l'ensemble minimum d'interfaces nécessaire pour cela (principe de ségrégation des interfaces de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SOLID</a> ).  Cependant, dans la pratique, nous avons tous dû faire face à des situations où, pour des raisons de commodité, une approche différente a été adoptée: nous avons pris une classe existante qui implémente certaines fonctionnalités, extrait toutes ses méthodes publiques dans l'interface, puis utilisé cette interface là où la classe mentionnée était nécessaire.  Autrement dit, l'interface n'a pas été utilisée sur la base de ce que ce composant est requis, mais sur la base de ce qu'un autre composant peut offrir. <br><br>  Avec cette approche, la situation s'aggrave avec le temps.  Chaque fois que nous ajoutons de nouvelles fonctionnalités, nos classes sont liées dans un réseau de nouvelles interfaces dont elles ont besoin de connaître.  Les classes augmentent en taille et les tests deviennent de plus en plus difficiles. <br><br>  Par conséquent, lorsque vous devez les utiliser dans un contexte différent, il sera presque impossible de les déplacer sans tout cet enchevêtrement avec lequel ils sont connectés, même via des interfaces.  Vous pouvez faire une analogie: vous voulez utiliser une banane, et c'est entre les mains d'un singe qui pend sur un arbre, donc en conséquence, dans la charge sur la banane, vous obtiendrez un morceau entier de la jungle.  En bref, le processus de transfert prend beaucoup de temps et vous vous demandez rapidement pourquoi, en pratique, il est si difficile de réutiliser le code. <br><br><h2>  Composants Black Box </h2><br>  Si nous voulons que le composant soit facilement et réutilisable, alors pour cela nous n'avons pas besoin de connaître deux choses: <br><br><ul><li>  à quel autre endroit il est utilisé; <br></li><li>  sur d'autres composants qui ne sont pas liés à sa mise en œuvre interne. <br></li></ul><br>  La raison est claire: si vous ne connaissez pas le monde extérieur, vous ne serez pas connecté avec lui. <br><br>  Ce que nous attendons vraiment du composant: <br><br><ul><li>  définir ses propres données d'entrée (entrée) et de sortie (sortie); <br></li><li>  Ne pensez pas d'où viennent ces données ni où elles vont; <br></li><li>  il doit être autosuffisant pour que nous n'ayons pas besoin de connaître la structure interne du composant pour son utilisation. <br></li></ul><br>  Vous pouvez considérer le composant comme une boîte noire ou un circuit intégré.  Elle a des contacts d'entrée et de sortie.  Vous les soudez - et le microcircuit fait partie d'un système dont il ne sait rien. <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br>  Jusqu'à présent, on supposait que nous parlions de flux de données bidirectionnels: si la classe A a besoin de quelque chose, elle extrait une méthode via l'interface B et reçoit le résultat sous la forme de la valeur retournée par la fonction. <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br>  Mais alors A connaît B, et nous voulons éviter cela. <br><br>  Bien sûr, un tel schéma est logique pour les fonctionnalités d'implémentation de bas niveau.  Mais si nous avons besoin d'un composant réutilisable qui fonctionne comme une boîte noire autonome, nous devons nous assurer qu'il ne sait rien des interfaces externes, des noms de méthode ou des valeurs de retour. <br><br><h2>  On passe à l'unidirectionnalité </h2><br>  Mais sans noms et méthodes d'interface, nous ne pouvons rien appeler!  Il ne reste plus qu'à utiliser un flux de données unidirectionnel, dans lequel nous obtenons simplement des entrées et générons des sorties: <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br>  Au début, cela peut ressembler à une limitation, mais une telle solution présente de nombreux avantages, qui seront discutés ci-dessous. <br><br>  Dès le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article,</a> nous savons que les fonctionnalités (Feature) définissent leurs propres données d'entrée (Wish) et leurs propres données de sortie (State).  Par conséquent, peu importe pour eux d'où vient le souhait ou où va l'État. <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br>  Voilà ce dont nous avons besoin!  Les fonctionnalités peuvent être utilisées partout où vous pouvez leur donner une entrée, et avec la sortie, vous pouvez faire ce que vous voulez.  Et comme les fonctionnalités ne communiquent pas directement avec d'autres composants, ce sont des modules autonomes et indépendants. <br><br>  Maintenant, prenez la vue et concevez-la pour qu'elle soit également un module autonome. <br><br>  Tout d'abord, la vue doit être aussi simple que possible afin qu'elle ne puisse gérer que ses tâches internes. <br><br>  Quel genre de tâches?  Il y en a deux: <br><br><ul><li>  rendu ViewModel (entrée); <br></li><li>  déclenchement de ViewEvents en fonction des actions de l'utilisateur (sortie). <br></li></ul><br>  Pourquoi utiliser ViewModel?  Pourquoi ne pas dessiner directement l'état de la fonction? <br><br><ul><li>  (Non) afficher une fonctionnalité à l'écran ne fait pas partie de l'implémentation.  La vue doit pouvoir s'afficher si les données proviennent de plusieurs sources. <br></li><li>  Pas besoin de refléter la complexité de l'état dans la vue.  Le ViewModel ne doit contenir que les informations prêtes à être affichées qui sont nécessaires pour rester simple. <br></li></ul><br>  En outre, View ne devrait pas être intéressé par les éléments suivants: <br><br><ul><li>  d'où viennent tous ces ViewModels; <br></li><li>  ce qui se passe lorsque ViewEvent est déclenché; <br></li><li>  toute logique métier; <br></li><li>  suivi analytique; <br></li><li>  journalisation <br></li><li>  d'autres tâches. <br></li></ul><br>  Toutes ces tâches sont externes et View ne doit pas y être connecté.  Arrêtons-nous et résumons la simplicité de la vue: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Une implémentation Android devrait: <br><br><ol><li>  Trouvez les vues Android par leur ID. <br></li><li>  Implémentez la méthode accept de l'interface client en définissant la valeur à partir du ViewModel. <br></li><li>  Définissez les écouteurs (ClickListeners) pour interagir avec l'interface utilisateur pour générer des événements spécifiques. <br></li></ol><br>  Un exemple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br>  S'il ne se limite pas aux fonctionnalités et à la vue, voici à quoi ressemblera tout autre composant avec cette approche: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Maintenant, tout est clair avec le motif! <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2>  Unissez-vous, unissez-vous, unissez-vous! </h2><br>  Mais que se passe-t-il si nous avons différents composants et chacun d'eux a sa propre entrée et sortie?  Nous allons les connecter! <br><br>  Heureusement, cela peut facilement être fait à l'aide de Binder, ce qui aide également à créer la bonne portée, comme nous le savons dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième article</a> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2>  Le premier avantage: facile à étendre sans modifications </h2><br>  L'utilisation de composants non liés sous la forme de boîtes noires qui ne sont connectées que temporairement nous permet d'ajouter de nouvelles fonctionnalités sans modifier les composants existants. <br><br>  Prenons un exemple simple: <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br>  Ici, les fonctionnalités (F) et View (V) sont simplement connectées les unes aux autres. <br><br>  Les liaisons correspondantes seront: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br>  Supposons que nous voulons ajouter le suivi de certains événements d'interface utilisateur à ce système. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br>  La bonne nouvelle est que nous pouvons le faire simplement en réutilisant le canal de vue de sortie existant: <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br>  En code, cela ressemble à ceci: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br>  De nouvelles fonctionnalités peuvent être ajoutées avec une seule ligne de reliure supplémentaire.  Maintenant, non seulement nous ne pouvons pas changer une seule ligne de vue de code, mais il ne sait même pas que la sortie est utilisée pour résoudre un nouveau problème. <br><br>  De toute évidence, il nous est désormais plus facile d’éviter des soucis supplémentaires et des composants inutilement compliqués.  Ils restent simples.  Vous pouvez ajouter des fonctionnalités au système en connectant simplement les composants aux composants existants. <br><br><h2>  Deuxième avantage: facilité d'utilisation répétée </h2><br>  En utilisant l'exemple de Feature and View, on peut clairement voir que nous pouvons ajouter une nouvelle source d'entrée ou un consommateur de données de sortie avec une seule ligne avec liaison.  Cela facilite grandement la réutilisation des composants dans différentes parties de l'application. <br><br>  Cependant, cette approche n'est pas limitée aux classes.  Cette façon d'utiliser les interfaces nous permet de décrire des composants réactifs autonomes de toute taille. <br><br>  En nous limitant à certaines données d'entrée et de sortie, nous nous débarrassons de la nécessité de savoir comment tout fonctionne sous le capot, et donc nous évitons facilement de lier accidentellement les composants internes des composants avec d'autres parties du système.  Et sans liaison, vous pouvez facilement et simplement utiliser des composants à plusieurs reprises. <br><br>  Nous y reviendrons dans l'un des articles suivants et examinerons des exemples d'utilisation de cette technique pour connecter des composants de niveau supérieur. <br><br><h2>  Première question: où mettre les fixations? </h2><br><ol><li>  Choisissez le niveau d'abstraction.  Selon l'architecture, il peut s'agir d'une activité, d'un fragment ou d'un ViewController.  J'espère que vous avez encore un certain niveau d'abstraction dans les parties où il n'y a pas d'interface utilisateur.  Par exemple, dans certaines des étendues de l'arborescence de contexte DI. <br></li><li>  Créez une classe distincte pour la liaison au même niveau que cette partie de l'interface utilisateur.  S'il s'agit de FooActivity, FooFragment ou FooViewController, vous pouvez placer FooBindings à côté. <br></li><li>  Assurez-vous d'intégrer FooBindings dans les mêmes instances de composant que vous utilisez dans l'activité, le fragment, etc. <br></li><li>  Pour former l'étendue des liaisons, utilisez le cycle de vie Activité ou fragment.  Si cette boucle n'est pas liée à Android, vous pouvez créer des déclencheurs manuellement, par exemple, lors de la création ou de la destruction d'une étendue DI.  D'autres exemples de portée sont décrits dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième article</a> . <br></li></ol><br><h3>  Deuxième question: les tests </h3><br>  Puisque notre composant ne sait rien des autres, nous n'avons généralement pas besoin de stubs à la place.  Les tests sont simplifiés pour vérifier la bonne réponse du composant aux données d'entrée et produire les résultats attendus. <br><br>  Dans le cas de Feature, cela signifie: <br><br><ul><li>  la possibilité de tester si certaines données d'entrée génèrent l'état attendu (sortie). <br></li></ul><br>  Et dans le cas de View: <br><br><ul><li>  nous pouvons tester si un ViewModel particulier (entrée) conduit à l'état attendu de l'interface utilisateur; <br></li><li>  nous pouvons tester si la simulation de l'interaction avec l'interface utilisateur conduit à l'initialisation dans le ViewEvent attendu (sortie). <br></li></ul><br>  Bien sûr, les interactions entre les composants ne disparaissent pas comme par magie.  Nous venons d'extraire ces tâches des composants eux-mêmes.  Ils doivent encore être testés.  Mais où? <br><br>  Dans notre cas, Binders est responsable de la connexion des composants: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br>  Nos tests devraient confirmer ce qui suit: <br><br>  1. Transformateurs (mappeurs). <br><br>  Certaines connexions ont des mappeurs, et vous devez vous assurer qu'ils convertissent correctement les éléments.  Dans la plupart des cas, un test unitaire très simple suffit pour cela, car les mappeurs sont généralement aussi très simples: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2. Communication. <br><br>  Vous devez vous assurer que les connexions sont correctement configurées.  Quel est l'intérêt du travail des composants individuels et des mappeurs, si pour une raison quelconque la connexion entre eux n'a pas été établie?  Tout cela peut être testé en configurant l'environnement de liaison avec des talons, des sources d'initialisation et en vérifiant si les résultats attendus sont reçus côté client: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br>  Et bien que pour les tests, vous devrez écrire sur la même quantité de code qu'avec d'autres approches, cependant, les composants autosuffisants facilitent le test des parties individuelles, car les tâches sont clairement séparées. <br><br><h2>  Matière à réflexion </h2><br>  Bien que la description de notre système sous la forme d'un graphique de cases noires soit bonne pour la compréhension générale, cela ne fonctionne que tant que la taille du système est relativement petite. <br><br>  Cinq à huit lignes de reliure sont acceptables.  Mais, ayant plus connecté, il sera assez difficile de comprendre ce qui se passe: <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br>  Nous étions confrontés au fait qu'avec une augmentation du nombre de liens (il y en avait encore plus que dans le fragment de code présenté) la situation devenait encore plus compliquée.  La raison n'était pas seulement dans le nombre de lignes - certaines sortes de liaisons pouvaient être regroupées et extraites pour différentes méthodes - mais aussi parce qu'il devenait de plus en plus difficile de tout garder en vue.  Et c'est toujours un mauvais signe.  Si des dizaines de composants différents sont situés au même niveau, il est impossible d'imaginer toutes les interactions possibles. <br><br>  La raison en est l'utilisation de composants - boîtes noires ou autre chose? <br><br>  De toute évidence, si la portée que vous décrivez est initialement complexe, aucune approche ne vous sauvera du problème mentionné jusqu'à ce que vous divisiez le système en parties plus petites.  Ce sera compliqué même sans une énorme liste de fixations, ce ne sera tout simplement pas si évident.  De plus, il vaut mieux que la complexité soit exprimée explicitement et non cachée.  Il est préférable de voir une liste croissante de jointures sur une seule ligne qui vous rappelle le nombre de composants individuels que vous ne connaissez pas sur ces liens cachés à l'intérieur des classes dans différents appels de méthode. <br><br>  Étant donné que les composants eux-mêmes sont simples (ce sont des boîtes noires et que des processus supplémentaires n'y entrent pas), il est plus facile de les séparer, ce qui signifie que c'est un pas dans la bonne direction.  Nous avons déplacé la difficulté à un seul endroit - à la liste des fixations, un coup d'œil qui vous permet d'évaluer la situation générale et de commencer à réfléchir à la façon de sortir de ce gâchis. <br><br>  La recherche d'une solution nous a pris beaucoup de temps, et elle est toujours en cours.  Nous prévoyons de discuter de la façon de faire face à ce problème dans les articles suivants.  Restez en contact! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463781/">https://habr.com/ru/post/fr463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463769/index.html">Mitap Netologii «Carrière en science des données: du débutant au intermédiaire»</a></li>
<li><a href="../fr463771/index.html">[Peter] Rencontre JUG.ru avec Sebastian Dashner - Rendre les tests d'entreprise plus joyeux</a></li>
<li><a href="../fr463773/index.html">Comment la protection des enfants contre les informations est organisée - et l'histoire enchanteresse sur l'origine de ces informations (18+)</a></li>
<li><a href="../fr463775/index.html">Qui utilise le protocole d'authentification SAML 2.0</a></li>
<li><a href="../fr463777/index.html">Surveillance de la disponibilité des hôtes Powershell</a></li>
<li><a href="../fr463785/index.html">Présentation des émulateurs de terminaux</a></li>
<li><a href="../fr463787/index.html">La grande vieille surprise de HP</a></li>
<li><a href="../fr463789/index.html">La puissance des génériques dans Swift. 2e partie</a></li>
<li><a href="../fr463791/index.html">Poignée en fer: cinématique du débarquement des oiseaux en fonction de la géométrie et de la texture de la surface</a></li>
<li><a href="../fr463795/index.html">Nuances de sens en anglais: comment utiliser les verbes conseiller, recommander, suggérer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>