<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèº ü§ó ‚óªÔ∏è Utreexo: comprimiendo una gran cantidad de UTXO Bitcoin üë®üèæ‚Äç‚öñÔ∏è üå≠ üß°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 


 En la red Bitcoin, todos los nodos acuerdan por consenso sobre los muchos UTXO: cu√°ntas monedas est√°n disponibles para gastar, a qui√©n ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: comprimiendo una gran cantidad de UTXO Bitcoin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Hola Habr! </p><br><p>  En la red Bitcoin, todos los nodos acuerdan por consenso sobre los muchos UTXO: cu√°ntas monedas est√°n disponibles para gastar, a qui√©n y bajo qu√© condiciones.  Un conjunto de UTXO es un conjunto de datos que es m√≠nimamente necesario para un nodo validador, sin el cual un nodo no puede verificar la validez de las transacciones entrantes y los bloques que las contienen. </p><br><p>  En este sentido, se hacen intentos en todos los sentidos para reducir la representaci√≥n almacenada de este conjunto, para comprimirlo sin p√©rdida de garant√≠as de seguridad.  Cuanto menor sea el volumen de datos almacenados, menores ser√°n los requisitos para el espacio en disco del nodo validador, lo que hace que el lanzamiento del nodo validador sea econ√≥mico, le permite expandir la red y, por lo tanto, aumentar la estabilidad de la red. </p><br><p>  En esta nota, cubriremos el prototipo Rust de una propuesta reciente del coautor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Utreexo: un acumulador din√°mico basado en hash optimizado para el conjunto Bitcoin UTXO</a> , que reduce los requisitos de espacio en disco para los nodos de validaci√≥n. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Cual es el problema </h2><br><p>  Uno de los problemas eternos de Bitcoin fue su escalabilidad.  La idea de "ser due√±o de un banco" requiere que los participantes de la red realicen un seguimiento de todos los fondos disponibles para su uso.  En Bitcoin, los fondos disponibles se expresan como un conjunto de salidas no gastadas: conjunto UTXO.  Aunque esta no es una presentaci√≥n particularmente intuitiva, es ventajosa en t√©rminos de rendimiento de implementaci√≥n, en comparaci√≥n con una presentaci√≥n en la que cada billetera tiene un "equilibrio" como una entrada separada, y tambi√©n agrega privacidad (por ejemplo, proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoinJoin</a> ). </p><br><p>  Es importante distinguir entre un historial de transacciones (lo que se llama una cadena de bloques) y el estado actual del sistema.  El historial de transacciones de Bitcoin actualmente ocupa alrededor de 200 GB de espacio en disco y contin√∫a creciendo.  Sin embargo, el estado del sistema es mucho m√°s peque√±o, aproximadamente 4 GB, y solo tiene en cuenta el hecho de que alguien posee actualmente monedas.  El volumen de estos datos tambi√©n aumenta con el tiempo, pero a un ritmo mucho m√°s bajo y a veces incluso tiende a disminuir (ver KDPV). </p><br><p>  Los clientes ligeros (SPV) intercambian garant√≠as de seguridad para la capacidad de no almacenar ning√∫n estado m√≠nimo (conjunto UTXO), excepto las claves privadas. </p><br><h2 id="utxo-i-utxo-set">  UTXO y UTXO-set </h2><br><p>  UTXO (Salida de transacci√≥n no utilizada): salida de transacci√≥n no utilizada, el punto final del viaje de cada satoshi transmitido en transacciones.  Las salidas no gastadas se convierten en entradas de nuevas transacciones y, al mismo tiempo, se gastan y se eliminan del conjunto UTXO. </p><br><p>  Los nuevos UTXO siempre se crean mediante transacciones: </p><br><ul><li>  transacciones de coinbase sin entradas: cree nuevos UTXO durante la emisi√≥n de monedas por parte de mineros </li><li>  transacciones convencionales: cree nuevos UTXO, mientras gasta un conjunto de UTXO existentes </li></ul><br><p>  El proceso de trabajar con UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Las billeteras consideran la cantidad de monedas disponibles para gastar (saldo) en funci√≥n de la cantidad de UTXO disponible para esta billetera para gastar. </p><br><p>  Cada nodo del validador, para evitar intentos de doble gasto, debe rastrear la colecci√≥n de <strong>todos los</strong> UTXO durante la verificaci√≥n de <strong>cada</strong> transacci√≥n de <strong>cada</strong> bloque. </p><br><p>  El nodo debe tener l√≥gica: </p><br><ul><li>  Adiciones al conjunto UTXO </li><li>  Eliminaciones de UTXO-set </li><li>  Comprueba la presencia de un solo UTXO en el conjunto </li></ul><br><p>  Hay formas de reducir los requisitos de informaci√≥n almacenada sobre el conjunto, al tiempo que conserva la capacidad de agregar y eliminar elementos, verificar y probar la existencia de un elemento en el conjunto utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bater√≠as criptogr√°ficas</a> . </p><br><h2 id="akkumulyatory-dlya-utxo">  Bater√≠as para UTXO </h2><br><p>  La idea de usar bater√≠as para almacenar muchos UTXO ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sido discutida</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">previamente</a> . </p><br><p>  UTXO-set se construye sobre la marcha, durante la carga inicial de la cadena de bloques (IBD, descarga inicial del bloque), se almacena completa y constantemente, mientras que su contenido cambia despu√©s de procesar las transacciones de cada bloque de red nuevo y correcto.  Este proceso requiere descargar aproximadamente 200 GB de bloques de datos y verificar cientos de millones de firmas digitales.  Despu√©s de que se complete el proceso de EII, en el residuo seco, el conjunto UTXO ocupar√° aproximadamente 4 GB. </p><br><p>  Sin embargo, cuando se usan bater√≠as, las reglas de consenso con respecto a los fondos se reducen a verificar y generar evidencia criptogr√°fica, y la carga de rastrear los fondos disponibles recae sobre los hombros del propietario de estos fondos, lo que proporciona evidencia de su presencia y propiedad. </p><br><p>  La bater√≠a se puede llamar una representaci√≥n compacta del conjunto.  El tama√±o de la vista almacenada, en este caso, debe ser constante <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  , o aumentar sublinealmente en relaci√≥n con la potencia del conjunto y el tama√±o del elemento en s√≠, por ejemplo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-29" x="3797" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  donde n es el poder del conjunto almacenado. </p><br><p>  En este caso, la bater√≠a deber√≠a permitir generar evidencia de la inclusi√≥n de un elemento en el conjunto (prueba de inclusi√≥n) y permitirle verificar efectivamente esta prueba. </p><br><p>  Una bater√≠a se llama <strong>din√°mica</strong> si le permite agregar elementos y eliminar elementos del conjunto. </p><br><p>  Un ejemplo de dicha bater√≠a es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bater√≠a RSA propuesta por Boneh, Bunz, Fisch en diciembre de 2018</a> .  Dicha bater√≠a tiene un tama√±o constante de la vista almacenada, pero requiere un <em>secreto compartido</em> (configuraci√≥n confiable).  Este requisito niega la aplicabilidad de dicho acumulador para redes sin confianza como Bitcoin, ya que la fuga de datos durante la generaci√≥n de un secreto puede permitir a los atacantes crear evidencia falsa de la existencia de UTXO al falsificar nodos con un conjunto UTXO basado en dicho acumulador. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  El dise√±o Thaddeus Dryja propuesto por Utreexo le permite crear una bater√≠a <strong>din√°mica</strong> <strong>sin</strong> una configuraci√≥n confiable. </p><br><p>  Utreexo es un bosque de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles Merkle</a> binarios ideales y es un desarrollo de las ideas presentadas en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acumuladores as√≠ncronos eficientes para pki distribuido</a> , agregando la capacidad de eliminar elementos del conjunto. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  La estructura l√≥gica de la bater√≠a. </h4><br><p>  Las celdas de la bater√≠a est√°n dispuestas en un bosque de √°rboles binarios perfectos.  Los √°rboles est√°n ordenados por altura.  Esta presentaci√≥n fue elegida como la m√°s visual y le permite visualizar la fusi√≥n de √°rboles durante las operaciones con la bater√≠a. </p><br><p>  El autor se√±ala que, dado que todos los √°rboles del bosque son perfectos, su altura se expresa mediante el poder de dos, al igual que cualquier n√∫mero natural puede representarse como la suma de los poderes de dos.  En consecuencia, cualquier conjunto de hojas puede agruparse en forma de √°rboles binarios, y en todos los casos, agregar un nuevo elemento requiere conocimiento <em>solo sobre los nodos ra√≠z de los √°rboles almacenados</em> . </p><br><p>  Por lo tanto, la vista almacenada de la bater√≠a Utreexo es una lista de nodos ra√≠z (ra√≠z de Merkle), <em>y no todo el bosque de √°rboles</em> . </p><br><p> Imagine la lista de elementos ra√≠z como <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  El tipo opcional <code>Option&lt;Hash&gt;</code> indica que puede faltar el elemento ra√≠z, lo que significa que el √°rbol no tiene un √°rbol con una altura adecuada. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Agregar elementos </h4><br><p>  Primero, describimos la funci√≥n <code>parent()</code> , que reconoce el nodo padre para dos elementos dados. </p><br><div class="spoiler">  <b class="spoiler_title">Funci√≥n Parent ()</b> <div class="spoiler_text"><p>  Como usamos √°rboles Merkle, el padre de cada uno de los dos nodos es un nodo que almacena el hash de concatenaci√≥n de los hashes de los nodos descendientes: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  El autor se√±ala que para evitar los ataques descritos por Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir y Sebastien Zimmer en <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los segundos ataques de preimagen en funciones de hash fragmentadas</a> , adem√°s de dos hashes, deben agregar altura dentro del √°rbol a la concatenaci√≥n. </p></div></div><br><p>  Al agregar elementos a la bater√≠a, debe realizar un seguimiento de los elementos ra√≠z que se est√°n cambiando.  Siguiendo el camino de cambiar los elementos ra√≠z para cada elemento agregado, m√°s tarde puede construir una prueba de la presencia de estos elementos. </p><br><div class="spoiler">  <b class="spoiler_title">Seguimiento de cambios durante la carga</b> <div class="spoiler_text"><p>  Para realizar un seguimiento de los cambios realizados, declararemos la estructura de <code>Update</code> , que almacenar√° datos sobre los cambios en los nodos. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Para agregar un elemento a la bater√≠a, necesita: </p><br><ul><li>  Cree una matriz de cestas de elementos ra√≠z <code>new_roots</code> y coloque all√≠ los elementos ra√≠z existentes, uno para cada cesta: </li></ul><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Agregue los elementos agregados (matriz de <code>insertions</code> ) a la primera canasta <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  Realice la "fusi√≥n" de los art√≠culos agregados a la primera canasta con el resto: <br><ul><li>  Para todas las cestas con m√°s de un art√≠culo: <br><ol><li>  Tomamos dos elementos del final de la canasta, calculamos su elemento primario, eliminamos ambos elementos </li><li>  Agregue el padre calculado a la pr√≥xima cesta. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Mueva los elementos ra√≠z de las cestas al conjunto de bater√≠as resultante </li></ul><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Crear evidencia para elementos agregados </h4><br><p>  La prueba de la inclusi√≥n del elemento en la bater√≠a ( <code>Proof</code> ) ser√° el Camino Merkle, que consiste en una cadena de <code>ProofStep</code> de <code>ProofStep</code> .  Si el camino no conduce a ninguna parte, entonces la prueba est√° equivocada. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Usando la informaci√≥n obtenida anteriormente durante la adici√≥n del elemento (Estructura de <code>Update</code> ), puede crear evidencia de que el elemento se agreg√≥ a la bater√≠a.  Para hacer esto, recorra la tabla de cambios realizados y agregue cada paso a la ruta de Merkle, que posteriormente servir√° como prueba: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Proceso de evidencia</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Prueba de evidencia de un art√≠culo </h4><br><p>  La comprobaci√≥n de la prueba de inclusi√≥n de un elemento (prueba de inclusi√≥n) se reduce a seguir el camino de Merkle, hasta que conduce al elemento ra√≠z existente: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Claramente: </p><br><div class="spoiler">  <b class="spoiler_title">Proceso de verificaci√≥n de evidencia para A</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Eliminar elementos </h4><br><p>  Para quitar un elemento de la bater√≠a, debe proporcionar una prueba v√°lida de que el elemento est√° all√≠.  Usando los datos de la prueba, podemos calcular los nuevos elementos ra√≠z de la bater√≠a para los cuales esta prueba ya no ser√° cierta. </p><br><p>  El algoritmo es el siguiente: </p><br><ol><li>  Al igual que con la adici√≥n, organizamos un conjunto de cestas vac√≠as correspondientes a los √°rboles Merkle con una altura igual a dos del √≠ndice de la cesta </li><li>  Inserte art√≠culos de los escalones del camino Merkle en las cestas;  el √≠ndice de la cesta es igual al n√∫mero de paso actual </li><li>  Eliminamos el elemento ra√≠z al que conduce la ruta de la prueba. </li><li>  Al igual que con la adici√≥n, calculamos los nuevos elementos ra√≠z, combinando los elementos de las canastas en pares y moviendo el resultado de la uni√≥n a la siguiente canasta </li></ol><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  El proceso de eliminar el elemento "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integraci√≥n en una red existente </h2><br><p>  Usando la bater√≠a propuesta, los nodos pueden negarse a usar la base de datos para almacenar todos los UTXO, mientras mantienen la capacidad de cambiar el conjunto UTXO.  Sin embargo, existe el problema de trabajar con evidencia. </p><br><p>  Llamaremos a un nodo validador que utiliza una bater√≠a UTXO <em>compacta</em> (nodo de estado compacto) y un validador sin bater√≠a - <em>lleno</em> (nodo completo).  La existencia de dos clases de nodos crea el problema de integrarlos en una sola red, ya que los nodos compactos requieren prueba de la existencia de UTXO, que se gasta en transacciones, pero los nodos completos no.  Si todos los nodos de la red al mismo tiempo y de manera coordinada no cambian a Utreexo, entonces los nodos compactos se quedar√°n atr√°s y no podr√°n trabajar en la red Bitcoin. </p><br><p>  Para resolver el problema de integrar nodos compactos en la red, se propone introducir una clase adicional de nodos: <em>puentes</em> .  Un nodo puente es un nodo completo que, entre otras cosas, almacena la bater√≠a Utreexo y la evidencia de inclusi√≥n para <strong>todos</strong> los UTXO del conjunto UTXO.  Los puentes calculan nuevos hashes y actualizan la bater√≠a y la evidencia a medida que llegan nuevos bloques con las transacciones.  El soporte y la actualizaci√≥n de la bater√≠a y la evidencia no imponen una carga computacional adicional en dichos nodos.  Los puentes sacrifican espacio en disco: mantenga el orden en orden <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  hashes en comparaci√≥n con <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhlOILOSYCYO5CLuGtB3YcZv_Upgg#MJMAIN-29" x="2254" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  hashes para nodos compactos, donde n es la potencia del conjunto UTXO. </p><br><h3 id="arhitektura-seti">  Arquitectura de red </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Los puentes permiten agregar gradualmente nodos compactos a la red sin cambiar el software de los nodos existentes.  Los nodos completos funcionan como antes, distribuyendo transacciones y bloques entre ellos.  Los nodos de puente son nodos completos que adem√°s almacenan datos de la bater√≠a Utreexo y un conjunto de evidencia de inclusi√≥n para <strong>todos los</strong> UTXO en este momento.  El nodo puente no se anuncia como tal, pretendiendo ser un nodo completo para todos los nodos completos y un nodo compacto para todos los nodos compactos.  Aunque los puentes conectan ambas redes, en realidad, necesitan conectarse en una sola direcci√≥n: desde nodos completos existentes hasta nodos compactos.  Esto es posible porque el formato de transacci√≥n no necesita ser cambiado, y la evidencia de UTXO para nodos compactos puede descartarse, por lo que cualquier nodo compacto puede enviar transacciones a todos los participantes de la red de la misma manera sin la participaci√≥n de nodos puente. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Revisamos la bater√≠a Utreexo e implementamos su prototipo en Rust.  Examinamos la arquitectura de red, que integrar√° los nodos en funci√≥n de la bater√≠a.  La ventaja de la captura compacta es el tama√±o de los datos almacenados, que depende logar√≠tmicamente de la potencia de muchos UTXO, lo que reduce en gran medida los requisitos de espacio en disco y el rendimiento de almacenamiento para dichos nodos.  La desventaja es el tr√°fico adicional de nodos para la transferencia de evidencia, pero las t√©cnicas de agregaci√≥n de evidencia (cuando una prueba demuestra la existencia de varios elementos) y el almacenamiento en cach√© pueden ayudar a mantener el tr√°fico dentro de l√≠mites aceptables. </p><br><p>  <strong>Referencias</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Utreexo Rust Prototype GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Utreexo: un acumulador din√°mico basado en hash optimizado para el conjunto Bitcoin UTXO</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ilustraciones animadas de un art√≠culo</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456424/">https://habr.com/ru/post/456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456412/index.html">Innovaci√≥n controvertida de Yandex: inicie sesi√≥n en su cuenta a trav√©s de una carta</a></li>
<li><a href="../456414/index.html">Protecci√≥n contra incendios en centros de datos o c√≥mo se almacenan los datos.</a></li>
<li><a href="../456416/index.html">Libro √°gil para todos</a></li>
<li><a href="../456418/index.html">Una breve historia del enga√±o de videojuegos</a></li>
<li><a href="../456422/index.html">Anuncio de una nueva versi√≥n de Styled Components v5: Animal Grin</a></li>
<li><a href="../456426/index.html">BASS: un marco para la s√≠ntesis autom√°tica de firmas antivirus</a></li>
<li><a href="../456428/index.html">C√≥mo implementar un enfoque de BI para el an√°lisis de datos: recomendaciones pr√°cticas</a></li>
<li><a href="../456430/index.html">La eterna cuesti√≥n de la deuda t√©cnica.</a></li>
<li><a href="../456432/index.html">Semana de la seguridad 25: vulnerabilidad de Evernote y cientos de tiendas en l√≠nea pirateadas</a></li>
<li><a href="../456434/index.html">Profesiones del futuro: "¬øCon qui√©n trabajar√°s en Marte?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>