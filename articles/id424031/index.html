<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüåæ ‚è© üë©üèª‚Äçüîß Pemrograman reaktif dengan JAX-RS üíí üë®üèº‚Äçüè´ üöè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Tahun lalu, kursus Java Enterprise Developer, telah berhasil diluncurkan dan kami memiliki materi terakhir tentang topik ini yang in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman reaktif dengan JAX-RS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424031/"> Halo semuanya! <br><br>  Tahun lalu, kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Enterprise Developer, telah</a> berhasil diluncurkan dan kami memiliki materi terakhir tentang topik ini yang ingin kami bagikan dengan Anda, yang membahas penggunaan pendekatan asinkron dan pementasan untuk mengembangkan aplikasi responsif responsif. <br><br>  Ayo pergi. <br><br>  Pemrograman reaktif pada awalnya terdengar seperti nama paradigma yang muncul, tetapi pada kenyataannya, itu mengacu pada metode pemrograman di mana pendekatan berorientasi peristiwa digunakan untuk bekerja dengan aliran data asinkron.  Berdasarkan data yang terus-menerus terkini, sistem reaktif meresponsnya dengan melakukan serangkaian acara. <br>  Pemrograman reaktif mengikuti pola desain "Observer", yang dapat didefinisikan sebagai berikut: jika keadaan berubah dalam satu objek, maka semua objek lainnya akan diberi tahu dan diperbarui.  Oleh karena itu, alih-alih polling acara untuk perubahan, acara didorong secara tidak sinkron sehingga pengamat dapat memprosesnya.  Dalam contoh ini, pengamat adalah fungsi yang dieksekusi ketika acara dikirim.  Dan aliran data yang disebutkan adalah yang sebenarnya dapat diamati. <br><br>  Hampir semua bahasa dan kerangka kerja menggunakan pendekatan ini dalam ekosistem mereka, dan versi terbaru Jawa tidak terkecuali.  Pada artikel ini, saya akan menjelaskan bagaimana pemrograman reaktif dapat diterapkan menggunakan versi terbaru JAX-RS di Java EE 8 dan fungsi Java 8. <br><br><img src="https://habrastorage.org/webt/zp/g6/dr/zpg6dry4ynjfjnr6y6fkmkluoea.png"><a name="habracut"></a><br><br>  <b>Manifes Jet</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jet Manifesto</a> mencantumkan empat aspek mendasar bahwa suatu aplikasi perlu lebih fleksibel, longgar, dan mudah untuk diukur, dan karenanya mampu reaktif.  Ini menyatakan bahwa aplikasi harus responsif, fleksibel (dan karenanya dapat diskalakan), ulet dan didorong oleh pesan. <br><br>  Tujuan yang mendasarinya adalah aplikasi yang benar-benar responsif.  Misalkan ada aplikasi di mana satu utas besar terlibat dalam memproses permintaan pengguna, dan setelah menyelesaikan pekerjaan, utas ini mengirimkan tanggapan kembali ke pemohon asli.  Ketika sebuah aplikasi menerima lebih banyak permintaan daripada yang bisa ditangani, utas ini menjadi hambatan, dan aplikasi kehilangan respons sebelumnya.  Untuk menjaga daya tanggap, aplikasi harus scalable dan ulet.  Berkelanjutan dapat dianggap sebagai aplikasi yang memiliki fungsi pemulihan otomatis.  Dalam pengalaman sebagian besar pengembang, hanya arsitektur berbasis pesan yang memungkinkan aplikasi menjadi skalabel, tangguh, dan responsif. <br><br>  Pemrograman reaktif diperkenalkan di Java 8 dan Java EE 8. Java memperkenalkan konsep seperti <code>CompletionStage</code> dan penerapan <code>CompletableFuture</code> , dan Java mulai menggunakan fitur ini dalam spesifikasi seperti API Klien Reaktif di JAX-RS. <br><br>  <b>JAX-RS 2.1 API Klien Reaktif</b> <br><br>  Mari kita lihat bagaimana pemrograman reaktif dapat digunakan dalam aplikasi Java EE 8. Untuk memahami prosesnya, Anda memerlukan pengetahuan dasar tentang Java EE API. <br><br>  JAX-RS 2.1 memperkenalkan cara baru untuk membuat klien REST dengan dukungan untuk pemrograman reaktif.  Implementasi invoker default yang ditawarkan di JAX-RS adalah sinkron, yang berarti bahwa klien yang dibuat akan mengirim panggilan pemblokiran ke titik akhir server.  Contoh implementasi disajikan pada Listing 1. <br><br>  Listing 1 <br><br><pre> <code class="java hljs">Response response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .get();</code> </pre> <br>  Dimulai dengan versi 2.0, JAX-RS menyediakan dukungan untuk membuat invoker asinkron pada API klien dengan panggilan sederhana ke metode <code>async()</code> , seperti yang ditunjukkan pada Listing 2. <br><br>  Listing 2 <br><br><pre> <code class="java hljs">Future&lt;Response&gt; response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .async() .get();</code> </pre> <br>  Menggunakan penyerang asinkron pada klien mengembalikan contoh <code>Future</code> dari jenis <code>javax.ws.rs.core.Response</code> .  Ini dapat menyebabkan polling respons, dengan panggilan ke <code>future.get()</code> , atau mendaftarkan panggilan balik yang akan dipanggil saat respons HTTP tersedia.  Kedua implementasi cocok untuk pemrograman asinkron, tetapi hal-hal biasanya menjadi rumit jika Anda ingin mengelompokkan panggilan balik atau menambahkan kasus bersyarat ke minimum eksekusi asinkron ini. <br><br>  JAX-RS 2.1 menyediakan cara reaktif untuk mengatasi masalah ini dengan API Klien Reaktif JAX-RS baru untuk membangun klien.  Ini sesederhana memanggil metode <code>rx()</code> selama membangun klien.  Dalam Listing 3, metode <code>rx()</code> mengembalikan invoker reaktif yang ada selama eksekusi klien, dan klien mengembalikan respons tipe <code>CompletionStage.rx()</code> , yang memungkinkan transisi dari invoker sinkron ke invoker asinkron dengan invoker sederhana dengan panggilan sederhana. <br><br>  Listing 3 <br><br><pre> <code class="java hljs">CompletionStage&lt;Response&gt; response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .rx() .get();</code> </pre> <br>  <code>CompletionStage&lt;&gt;</code> adalah antarmuka baru yang diperkenalkan di Java 8. Ini mewakili komputasi, yang dapat menjadi langkah dalam perhitungan yang lebih besar, seperti namanya.  Ini adalah satu-satunya perwakilan reaktivitas Java 8 yang menekan JAX-RS. <br>  Setelah menerima contoh respons, saya dapat memanggil <code>AcceptAsync()</code> , di mana saya dapat memberikan sepotong kode yang akan dieksekusi secara tidak sinkron ketika respons tersedia, seperti yang ditunjukkan pada Listing 4. <br><br>  Listing 4 <br><br><pre> <code class="java hljs">response.thenAcceptAsync(res -&gt; { Temperature t = res.readEntity(Temperature.class); <span class="hljs-comment"><span class="hljs-comment">//do stuff with t });</span></span></code> </pre> <br>  <b>Menambahkan reaktivitas ke titik akhir REST</b> <br><br>  Pendekatan reaktif tidak terbatas pada sisi klien di JAX-RS;  itu juga dapat digunakan di sisi server.  Sebagai contoh, pertama saya akan membuat skrip sederhana di mana saya dapat meminta daftar lokasi satu tujuan.  Untuk setiap posisi, saya akan melakukan panggilan terpisah dengan data lokasi ke titik lain untuk mendapatkan nilai suhu.  Interaksi tujuan akan seperti yang ditunjukkan pada Gambar 1. <br><br><img src="https://habrastorage.org/webt/rd/zr/cr/rdzrcrvbeyyfkp_bc5szid_t9au.png"><br>  <i>Gambar 1. Interaksi antara titik tujuan</i> <br><br>  Pertama, saya cukup mendefinisikan model domain, dan kemudian layanan untuk masing-masing model.  Listing 5 menunjukkan bagaimana kelas <code>Forecast</code> didefinisikan, yang membungkus kelas <code>Location</code> dan <code>Temperature</code> . <br><br>  Listing 5 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Temperature</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Double temperature; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String scale; <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters } public class Location { String name; public Location() {} public Location(String name) { this.name = name; } // getters &amp; setters } public class Forecast { private Location location; private Temperature temperature; public Forecast(Location location) { this.location = location; } public Forecast setTemperature( final Temperature temperature) { this.temperature = temperature; return this; } // getters }</span></span></code> </pre> <br>  Untuk membungkus daftar perkiraan, kelas <code>ServiceResponse</code> diimplementasikan pada Listing 6. <br><br>  Listing 6 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> processingTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Forecast&gt; forecasts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setProcessingTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> processingTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingTime = processingTime; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServiceResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forecasts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Forecast&gt; forecasts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecasts = forecasts; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// getters }</span></span></code> </pre> <br>  <code>LocationResource</code> ditunjukkan pada Listing 7 mendefinisikan tiga lokasi sampel yang dikembalikan dengan path <code>/location</code> . <br><br>  Listing 7 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocationResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Location&gt; locations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"London"</span></span>)); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span>)); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"Prague"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericEntity&lt;List&lt;Location&gt;&gt;(locations){}).build(); } }</code> </pre> <br>  <code>TemperatureResource</code> ditunjukkan pada Listing 8 mengembalikan nilai suhu yang dihasilkan secara acak antara 30 dan 50 untuk lokasi tertentu.  Penundaan 500 ms telah ditambahkan ke implementasi untuk mensimulasikan pembacaan sensor. <br><br>  Listing 8 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/temperature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemperatureResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/{city}"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"city"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String cityName) </span></span>{ Temperature temperature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Temperature(); temperature.setTemperature((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(<span class="hljs-number"><span class="hljs-number">20</span></span>) + <span class="hljs-number"><span class="hljs-number">30</span></span>)); temperature.setScale(<span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ignored) { ignored.printStackTrace(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(temperature).build(); } }</code> </pre> <br>  Pertama, saya akan menunjukkan implementasi <code>ForecastResource</code> sinkron (lihat Listing 9), yang mengembalikan semua lokasi.  Kemudian, untuk setiap posisi, ia memanggil layanan suhu untuk mendapatkan nilai dalam derajat Celcius. <br><br>  Listing 9 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/forecast"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForecastResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget locationTarget; <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"temperature/{city}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget temperatureTarget; <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocationsWithTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime = System.currentTimeMillis(); ServiceResponse response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceResponse(); List&lt;Location&gt; locations = locationTarget .request() .get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericType&lt;List&lt;Location&gt;&gt;(){}); locations.forEach(location -&gt; { Temperature temperature = temperatureTarget .resolveTemplate(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, location.getName()) .request() .get(Temperature.class); response.getForecasts().add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Forecast(location).setTemperature(temperature)); }); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> endTime = System.currentTimeMillis(); response.setProcessingTime(endTime - startTime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(response).build(); } }</code> </pre> <br>  Ketika tujuan perkiraan diminta sebagai <code>/forecast</code> , Anda akan mendapatkan output yang mirip dengan yang ditunjukkan pada Listing 10. Perhatikan bahwa waktu pemrosesan permintaan memakan waktu 1,533 ms, yang logis, karena permintaan sinkron untuk nilai suhu dari tiga lokasi berbeda menambahkan hingga 1,5 ms <br><br>  Listing 10 <br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"forecasts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"London"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">38</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Prague"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">46</span></span> } } ], <span class="hljs-string"><span class="hljs-string">"processingTime"</span></span>: <span class="hljs-number"><span class="hljs-number">1533</span></span> }</code> </pre><br>  Sejauh ini, semuanya berjalan sesuai rencana.  Sudah saatnya untuk memperkenalkan pemrograman reaktif di sisi server, di mana panggilan ke setiap lokasi dapat dilakukan secara paralel setelah menerima semua lokasi.  Ini jelas dapat meningkatkan aliran sinkron yang ditunjukkan sebelumnya.  Ini dilakukan pada Listing 11, yang menunjukkan definisi versi layanan perkiraan reaktif. <br><br>  Listing 11 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/reactiveForecast"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForecastReactiveResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget locationTarget; <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"temperature/{city}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget temperatureTarget; <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocationsWithTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Suspended </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AsyncResponse async)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">//   (stage)    CompletionStage&lt;List&lt;Location&gt;&gt; locationCS = locationTarget.request() .rx() .get(new GenericType&lt;List&lt;Location&gt;&gt;() {}); //      , //  ,   , //    CompletionStage final CompletionStage&lt;List&lt;Forecast&gt;&gt; forecastCS = locationCS.thenCompose(locations -&gt; { //      //   ompletionStage List&lt;CompletionStage&lt;Forecast&gt;&gt; forecastList = //      //     locations.stream().map(location -&gt; { //     //      //    final CompletionStage&lt;Temperature&gt; tempCS = temperatureTarget .resolveTemplate("city", location.getName()) .request() .rx() .get(Temperature.class); //   CompletableFuture,   //    //      return CompletableFuture.completedFuture( new Forecast(location)) .thenCombine(tempCS, Forecast::setTemperature); }).collect(Collectors.toList()); //    CompletableFuture, //     completable future //  return CompletableFuture.allOf( forecastList.toArray( new CompletableFuture[forecastList.size()])) .thenApply(v -&gt; forecastList.stream() .map(CompletionStage::toCompletableFuture) .map(CompletableFuture::join) .collect(Collectors.toList())); }); //   ServiceResponse, //       //    . //   future    // forecastCS,    //      CompletableFuture.completedFuture( new ServiceResponse()) .thenCombine(forecastCS, ServiceResponse::forecasts) .whenCompleteAsync((response, throwable) -&gt; { response.setProcessingTime( System.currentTimeMillis() - startTime); async.resume(response); }); } }</span></span></code> </pre> <br>  Implementasi reaktif mungkin tampak rumit pada pandangan pertama, tetapi setelah penelitian yang lebih hati-hati, Anda akan melihat bahwa itu sangat sederhana.  Dalam penerapan <code>ForecastReactiveResource</code> saya pertama kali membuat panggilan klien ke layanan lokasi menggunakan API Klien Reaktif JAX-RS.  Seperti yang saya sebutkan di atas, ini adalah add-on untuk Java EE 8, dan ini membantu untuk membuat panggilan reaktif hanya menggunakan metode <code>rx()</code> . <br><br>  Sekarang saya membuat fase baru berdasarkan lokasi untuk mengumpulkan daftar perkiraan.  Mereka akan disimpan sebagai daftar perkiraan dalam satu tahap penyelesaian besar yang disebut <code>forecastCS</code> .  Pada akhirnya, saya akan membuat respons panggilan layanan hanya menggunakan <code>forecastCS</code> . <br><br>  Dan sekarang, mari kita kumpulkan prakiraan dalam bentuk daftar tahap penyelesaian yang ditentukan dalam daftar <code>forecastList</code> variabel.  Untuk membuat tahap penyelesaian untuk setiap perkiraan, saya meneruskan data berdasarkan lokasi, dan kemudian membuat variabel <code>tempCS</code> , sekali lagi menggunakan JAX-RS Reactive Client API, yang memanggil layanan suhu dengan nama kota.  Di sini, saya menggunakan metode <code>resolveTemplate()</code> untuk membangun klien, dan ini memungkinkan saya untuk meneruskan nama kota ke kolektor sebagai parameter. <br><br>  Sebagai langkah terakhir dalam streaming, saya melakukan panggilan ke <code>CompletableFuture.completedFuture()</code> , dengan mengirimkan contoh <code>Forecast</code> baru sebagai parameter.  Saya menggabungkan masa depan ini dengan tahap <code>tempCS</code> sehingga saya memiliki nilai suhu untuk lokasi yang dipantau. <br><br>  Metode <code>CompletableFuture.allOf()</code> di Listing 11 mengubah daftar tahap penyelesaian menjadi <code>forecastCS</code> .  Melakukan langkah ini mengembalikan instance masa depan yang dapat diselesaikan yang besar ketika semua objek masa depan yang dapat diselesaikan yang lengkap selesai. <br><br>  Respons layanan adalah turunan dari kelas <code>ServiceResponse</code> , jadi saya membuat masa depan yang selesai, dan kemudian menggabungkan tahap penyelesaian <code>forecastCS</code> dengan daftar perkiraan dan menghitung waktu respons layanan. <br><br>  Tentu saja, pemrograman reaktif hanya memaksa sisi server untuk berjalan secara tidak sinkron;  sisi klien akan diblokir sampai server mengirim respons kembali ke pemohon.  Untuk mengatasi masalah ini, Server Terkirim Acara (SSE) dapat digunakan untuk mengirim sebagian tanggapan segera setelah itu tersedia sehingga nilai suhu untuk setiap lokasi ditransmisikan ke klien satu per satu.  Output dari <code>ForecastReactiveResource</code> akan serupa dengan yang disajikan pada Listing 12. Seperti yang ditunjukkan dalam output, waktu pemrosesan adalah 515 ms, yang merupakan runtime yang ideal untuk mendapatkan nilai suhu dari satu lokasi. <br><br>  Listing 12 <br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"forecasts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"London"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">49</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Prague"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span> } } ], <span class="hljs-string"><span class="hljs-string">"processingTime"</span></span>: <span class="hljs-number"><span class="hljs-number">515</span></span> }</code> </pre> <br>  <b>Kesimpulan</b> <br><br>  Dalam contoh di artikel ini, saya pertama kali menunjukkan cara sinkron untuk mendapatkan perkiraan menggunakan layanan lokasi dan suhu.  Kemudian, saya pergi ke pendekatan reaktif sehingga pemrosesan asinkron dilakukan antara panggilan layanan.  Ketika Anda menggunakan API Klien Reaktif JAX-RS di Java EE 8 bersama dengan kelas <code>CompletionStage</code> dan <code>CompletableFuture</code> tersedia di Java 8, kekuatan pemrosesan asinkron akan terputus berkat pemrograman reaktif. <br><br>  Pemrograman reaktif lebih dari sekadar menerapkan model asinkron dari model sinkron;  itu juga menyederhanakan bekerja dengan konsep-konsep seperti tahap bersarang.  Semakin banyak digunakan, semakin mudah untuk mengelola skrip kompleks dalam pemrograman paralel. <br><br>  AKHIR <br><br>  Terima kasih atas perhatian anda  Seperti biasa, kami menunggu komentar dan pertanyaan Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424031/">https://habr.com/ru/post/id424031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424021/index.html">Tantangan pemrograman belajar mandiri dan cara mengatasinya</a></li>
<li><a href="../id424023/index.html">Kami mengotomatiskan perakitan aplikasi iOS menggunakan Fastlane</a></li>
<li><a href="../id424025/index.html">Routing di aplikasi Bereaksi besar</a></li>
<li><a href="../id424027/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 2</a></li>
<li><a href="../id424029/index.html">Dan lagi tentang kemalasan</a></li>
<li><a href="../id424033/index.html">Apa yang dilakukan Kotlin: wawancara dengan Andrei Breslav</a></li>
<li><a href="../id424035/index.html">2019 adalah tahun Intel berhenti</a></li>
<li><a href="../id424037/index.html">Tur singkat GraphQL</a></li>
<li><a href="../id424039/index.html">Kriptografi setelah pendaratan alien</a></li>
<li><a href="../id424041/index.html">Pengantar Singkat untuk Biologi Sel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>