<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 🐍 🧑🏼‍🤝‍🧑🏼 Kotlin DSL, Fixtures und elegante UI-Tests in Android 🧓🏿 🎳 🤲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich Kotlin DSL kennenlernte, dachte ich: Großartig, es ist schade, dass es bei der Produktentwicklung nicht nützlich sein wird. Ich habe mich jedo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin DSL, Fixtures und elegante UI-Tests in Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/455042/"><p>  Als ich Kotlin DSL kennenlernte, dachte ich: Großartig, es ist schade, dass es bei der Produktentwicklung nicht nützlich sein wird.  Ich habe mich jedoch geirrt: Er hat uns dabei geholfen, eine sehr präzise und elegante Methode zum Schreiben von End-to-End-UI-Tests in Android zu entwickeln. </p><br><p><img src="https://habrastorage.org/webt/sh/f7/ej/shf7ejqt1wouqjj5vjej-vwbnzi.jpeg" alt="Bild"></p><a name="habracut"></a><br><h1 id="pro-servis-testovye-dannye-i-pochemu-vse-ne-tak-prosto">  Über den Service, Testdaten und warum es nicht so einfach ist </h1><br><p>  Zunächst ein kleiner Kontext zu unserem Service, damit Sie verstehen, warum wir bestimmte Entscheidungen getroffen haben. </p><br><p>  Wir helfen Arbeitssuchenden und Arbeitgebern, einander zu finden: </p><br><ul><li>  Arbeitgeber registrieren ihre Unternehmen und stellen offene Stellen aus </li><li>  Arbeitssuchende suchen nach Jobs, fügen sie zu Favoriten hinzu, abonnieren Suchergebnisse, erstellen Lebensläufe und senden Feedback </li></ul><br><p>  Um reale Benutzerszenarien zu simulieren und sicherzustellen, dass die Anwendung auf ihnen ordnungsgemäß funktioniert, müssen alle diese Testdaten auf dem Server erstellt werden.  Sie werden sagen: „Erstellen Sie also im Voraus Testarbeitgeber und Arbeitssuchende und arbeiten Sie dann mit ihnen in den Tests zusammen.“  Es gibt jedoch einige Probleme: </p><br><ol><li>  während der Tests ändern wir die Daten; </li><li>  Tests laufen parallel. </li></ol><br><h1 id="testovoe-okruzhenie-i-fikstury">  Testumgebung und Vorrichtungen </h1><br><p>  End-to-End-Tests werden auf Prüfständen ausgeführt.  Sie haben fast ein militärisches Umfeld, aber es gibt keine wirklichen Daten.  In dieser Hinsicht erfolgt die Indizierung beim Hinzufügen neuer Daten fast sofort. </p><br><p>  Um dem Stand Daten hinzuzufügen, verwenden wir spezielle Befestigungsmethoden.  Sie fügen Daten direkt zur Datenbank hinzu und indizieren sie sofort: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestFixtureUserApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@POST(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fx/employer/create"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEmployerUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Body</span></span></span></span><span class="hljs-function"><span class="hljs-params"> employer: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestEmployer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;TestEmployer&gt; }</code> </pre> <br><p>  Vorrichtungen sind nur über das lokale Netzwerk und nur für Prüfstände erhältlich.  Die Methoden werden unmittelbar vor Beginn der Startaktivität aus dem Test aufgerufen. </p><br><h1 id="dsl">  DSL </h1><br><p>  Also kamen wir zum saftigsten.  Wie ist der Datensatz für den Test? </p><br><pre> <code class="kotlin hljs">initialisation{ applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> isOptional = <span class="hljs-literal"><span class="hljs-literal">true</span></span> resumeStatus = ResumeStatus.APPROVED } resume { title = <span class="hljs-string"><span class="hljs-string">"Some other Resume"</span></span> } } employer { vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> } vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Working hard"</span></span> } vacancy { title = <span class="hljs-string"><span class="hljs-string">"Resume for similar Vacancy"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Working very hard"</span></span> } } }</code> </pre> <br><p>  Im Initialisierungsblock starten wir die für den Test erforderlichen Entitäten: Im obigen Beispiel haben wir einen Bewerber mit zwei Lebensläufen sowie einen Arbeitgeber erstellt, der mehrere offene Stellen bereitgestellt hat. </p><br><p>  Um Fehler im Zusammenhang mit der Überschneidung von Testdaten zu vermeiden, generieren wir eine eindeutige Kennung für den Test und für jede Entität. </p><br><p>  <strong>Beziehungen zwischen Entitäten</strong> </p><br><p>  Was ist die Hauptbeschränkung bei der Arbeit mit DSL?  Aufgrund seiner Baumstruktur ist es ziemlich schwierig, Verbindungen zwischen verschiedenen Zweigen eines Baumes herzustellen. </p><br><p>  In unserer Bewerbung für Bewerber gibt es beispielsweise einen Abschnitt „Geeignete Stellenangebote für Lebensläufe“.  Damit offene Stellen in dieser Liste angezeigt werden, müssen sie so festgelegt werden, dass sie mit dem Lebenslauf des aktuellen Benutzers zusammenhängen. </p><br><pre> <code class="kotlin hljs">initialisation { applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } employer { vacancy { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  Hierfür wird eine eindeutige Testkennung verwendet.  Daher werden bei der Arbeit mit der Anwendung die angegebenen Stellenangebote für diesen Lebenslauf empfohlen.  Darüber hinaus ist zu beachten, dass in dieser Liste keine weiteren offenen Stellen angezeigt werden. </p><br><p>  <strong>Initialisieren Sie Daten desselben Typs</strong> </p><br><p>  Aber was ist, wenn Sie viele offene Stellen machen müssen?  Ist es jeder Block so kopieren?  Natürlich nicht!  Wir erstellen eine Methode mit einem Block von offenen Stellen, die die erforderliche Anzahl von offenen Stellen angibt, und einem Transformator, um diese in Abhängigkeit von der eindeutigen Kennung zu diversifizieren. </p><br><pre> <code class="kotlin hljs">initialisation { employer { vacancyBlock { size = <span class="hljs-number"><span class="hljs-number">10</span></span> transformer = { it.also { vacancyDsl -&gt; vacancyDsl.description = <span class="hljs-string"><span class="hljs-string">"Some description with text </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${vacancyDsl.uniqueVacancyId}</span></span></span><span class="hljs-string">"</span></span> } } } } }</code> </pre> <br><p>  Im Block vacancyBlock geben wir an, wie viele Klone von Stellenangeboten erstellt werden müssen und wie sie abhängig von der Seriennummer transformiert werden sollen. </p><br><p>  <strong>Arbeiten Sie mit Daten im Test</strong> </p><br><p>  Während des Tests wird das Arbeiten mit Daten sehr einfach.  Alle von uns erstellten Daten stehen uns zur Verfügung.  In unserer Implementierung werden sie in speziellen Wrappern für Sammlungen gespeichert.  Daten können von ihnen sowohl über die Seriennummer des Jobs (Stellenangebote [0]) als auch über das Tag, das in dsl (Stellenangebote [„meine Stellenangebote“]) festgelegt werden kann, und über Verknüpfungen (Stellenangebote.first () abgerufen werden. </p><br><div class="spoiler">  <b class="spoiler_title">TaggedItemContainer</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaggedItemContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: MutableList&lt;TaggedItem&lt;T&gt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[index].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.first { it.tag == tag }.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plusAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TaggedItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { items += item } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) action.invoke(item.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">third</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[items.size - <span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> } }</code> </pre> </div></div><br><p>  In fast 100% der Fälle verwenden wir beim Schreiben von Tests die Methoden first () und second (), der Rest wird aus Gründen der Flexibilität beibehalten.  Unten finden Sie ein Beispiel für einen Test mit Initialisierung und Schritten in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kakao</a> </p><br><pre> <code class="kotlin hljs">initialisation { applicant { resume { title = <span class="hljs-string"><span class="hljs-string">"TEST_VACANCY_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uniqueTestId</span></span></span><span class="hljs-string">"</span></span> } } }.run { mainScreen { positionField { click() } jobPositionScreen { positionEntry(vacancies.first().title) } searchButton { click() } } }</code> </pre> <br><p>  <strong>Was passt nicht in DSL</strong> </p><br><p>  Können alle Daten in DSL passen?  Unser Ziel war es, DSL so präzise und einfach wie möglich zu halten.  In unserer Implementierung ist es aufgrund der Tatsache, dass die Arbeitsreihenfolge von Bewerbern und Arbeitgebern nicht wichtig ist, nicht möglich, ihre Beziehung - die Antworten - anzupassen. <br>  Die Erstellung von Antworten wird bereits im nächsten Block durch Operationen an Entitäten durchgeführt, die bereits auf dem Server erstellt wurden. </p><br><h1 id="realizaciya-dsl">  DSL-Implementierung </h1><br><p>  Wie Sie aus dem Artikel verstanden haben, lautet der Algorithmus zum Spezifizieren von Testdaten und Durchführen des Tests wie folgt: </p><br><ul><li>  Ein Teil des DSL wird bei der Initialisierung analysiert. </li><li>  Basierend auf den erhaltenen Werten werden Testdaten auf dem Server erstellt. </li><li>  Der optionale Transformationsblock wird ausgeführt, in dem Sie Antworten festlegen können. </li><li>  Ein Test wird mit einem bereits endgültigen Datensatz durchgeführt. </li></ul><br><p>  <strong>Analysieren von Daten aus einem Initialisierungsblock</strong> </p><br><p>  Welche Art von Magie ist dort los?  Überlegen Sie, wie das TestCaseDsl-Element der obersten Ebene aufgebaut ist: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@TestCaseDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseDsl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicants = mutableListOf&lt;ApplicantDsl&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> employers = mutableListOf&lt;EmployerDsl&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueTestId = CommonUtils.unique <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicantDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicantDsl = ApplicantDsl( uniqueTestId, uniqueApplicantId = CommonUtils.unique applicantDsl.block() applicants += applicantDsl } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">employer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EmployerDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> employerDsl = EmployerDsl( uniqueTestId = uniqueTestId, uniqueEmployerId = CommonUtils.unique employerDsl.block() employers += employerDsl } }</code> </pre> <br><p>  In der Bewerbermethode erstellen wir ApplicantDsl. </p><br><div class="spoiler">  <b class="spoiler_title">AntragstellerDsl</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@TestCaseDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicantDsl</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueTestId: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniqueApplicantId: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tag: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> login: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> password: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> middleName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> email: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> siteId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areaId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resumeViewLimit: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isMailingSubscription: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resumes = mutableListOf&lt;ResumeDsl&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ResumeDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {}) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resumeDslBuilder = ResumeDsl( uniqueTestId = uniqueTestId, uniqueApplicantId = uniqueApplicantId, uniqueResumeId = CommonUtils.unique ) resumeDslBuilder.apply(block) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.resumes += resumeDslBuilder } }</code> </pre> </div></div><br><p>  Dann führen wir Operationen aus dem Blockblock aus: ApplicantDsl. () -&gt; Unit.  Dieses Design ermöglicht es uns, problemlos mit ApplicantDsl-Feldern in unserem DSL zu arbeiten. </p><br><p>  Bitte beachten Sie, dass uniqueTestId und uniqueApplicantId (eindeutige Bezeichner für die Kommunikation zwischen Entitäten) zum Zeitpunkt der Ausführung des Blocks bereits festgelegt sind und wir darauf zugreifen können. </p><br><p>  Der Initialisierungsblock hat intern eine ähnliche Struktur: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialisation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestCaseDsl</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Initialisation { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCaseDsl = TestCaseDsl().apply(block) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase = TestCaseCreator.create(testCaseDsl) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Initialisation(testCase) }</code> </pre> <br><p>  Wir erstellen einen Test, wenden Blockaktionen darauf an und verwenden dann TestCaseCreator, um Daten auf dem Server zu erstellen und in Sammlungen abzulegen.  Die Funktion TestCaseCreator.create () ist recht einfach: Wir durchlaufen die Daten und erstellen sie auf dem Server. </p><br><h1 id="podvodnye-kamni-i-idei">  Fallstricke und Ideen </h1><br><blockquote>  Einige Tests sind sehr ähnlich und unterscheiden sich nur in den Eingabedaten und Möglichkeiten zur Steuerung ihrer Anzeigen (z. B. wenn in der Vakanz unterschiedliche Währungen angegeben sind). </blockquote><p>  In unserem Fall gab es nur wenige solcher Tests, und wir haben beschlossen, DSL nicht mit einer speziellen Syntax zu überladen </p><br><blockquote>  In den Tagen vor DSL haben wir Daten lange Zeit indiziert. Um Zeit zu sparen, haben wir viele Tests in einer Klasse durchgeführt und alle Daten in einem statischen Block erstellt. </blockquote><p>  Tun Sie dies nicht - es macht es Ihnen unmöglich, den gefallenen Test neu zu starten.  Tatsache ist, dass wir beim Start des Falltests die anfänglichen Daten auf dem Server ändern können.  Zum Beispiel könnten wir Ihren Favoriten eine freie Stelle hinzufügen.  Wenn Sie den Test dann neu starten, führt das Klicken auf das Sternchen im Gegenteil dazu, dass die freie Stelle aus der Favoritenliste entfernt wird. Dies ist ein Verhalten, das wir nicht erwarten. </p><br><h1 id="itogi">  Zusammenfassung </h1><br><p>  Diese Methode zur Angabe von Testdaten vereinfachte die Arbeit mit Tests erheblich: <br>  Beim Schreiben von Tests müssen Sie nicht darüber nachdenken, ob es einen Server gibt und in welcher Reihenfolge Sie die Daten initialisieren müssen. <br>  Alle Entitäten, die auf dem Server festgelegt werden können, werden problemlos in IDE-Hinweisen angezeigt. <br>  Es gibt eine einzige Möglichkeit, Daten zu initialisieren und miteinander zu kommunizieren. </p><br><p>  <strong>Verwandte Materialien</strong> </p><br><p>  Wenn Sie an unserem Ansatz zum Testen der Benutzeroberfläche interessiert sind, empfehle ich Ihnen, sich vor Beginn mit den folgenden Materialien vertraut zu machen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Type-Safe Builders</a> - offizielle Dokumentation auf der Website kotlinlang.org; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin DSL: Theorie und Praxis</a> - ausgezeichneter Bericht von jPoint 2018 über kotlin dsl und seine Dekodierung; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kakao - wie man UI-Tests wieder großartig macht</a> - Grundkenntnisse über das Kakao-Framework für UI-Tests; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Sie aufhören können, Angst zu haben, und mit Kakao UI-Tests schreiben</a> - ein Vortrag über Kakao mit AppsConf 2019. Bisher sind nur Folien verfügbar, dann wird es ein Video geben. </li></ul><br><p>  <strong>Was weiter</strong> </p><br><p>  Dieser Artikel ist der erste einer Reihe von Tools und allgemeinen Frameworks zum Schreiben und Unterstützen von UI-Tests in Android.  Sobald neue Teile verfügbar sind, werde ich sie mit diesem Artikel verknüpfen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455042/">https://habr.com/ru/post/de455042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455026/index.html">Telefonie mit Snom: für diejenigen, die zu Hause arbeiten</a></li>
<li><a href="../de455030/index.html">PHP-Spezifikationen</a></li>
<li><a href="../de455032/index.html">Kein Fehler, sondern ein Merkmal: eine Untersuchung der Motilität und Gehirnaktivität einer Person mit Polydaktylie</a></li>
<li><a href="../de455038/index.html">Wie Plesk die KubeCon besucht hat</a></li>
<li><a href="../de455040/index.html">Verbesserung der Arbeit von Wi-Fi. Teil 2. Ausstattungsmerkmale</a></li>
<li><a href="../de455046/index.html">N + 7 nützliche Bücher</a></li>
<li><a href="../de455050/index.html">Verwenden der Oracle-Datenbank für die technische Marktanalyse</a></li>
<li><a href="../de455052/index.html">Sommer DIYorDIE Meetup 16. Juni</a></li>
<li><a href="../de455056/index.html">Primitive Grafiken für Lazy, Oldfags und Lazy Oldfags</a></li>
<li><a href="../de455058/index.html">Berechnete Handlung oder Rollenspielinfektion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>