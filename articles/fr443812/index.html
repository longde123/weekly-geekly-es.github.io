<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüöí üì£ üêØ Comment impl√©menter un langage de programmation en JavaScript. Partie 2: interpr√®te üëÆ üö¥üèø üßöüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Je vous pr√©sente la deuxi√®me partie de ma traduction du guide d'impl√©mentation de votre langage de programmation JavaScript - PL Tutorial . 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment impl√©menter un langage de programmation en JavaScript. Partie 2: interpr√®te</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Bonjour  Je vous pr√©sente la deuxi√®me partie de ma traduction du guide d'impl√©mentation de votre langage de programmation JavaScript - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Du traducteur </h1><br><p>  Nous allons cr√©er notre propre langage de programmation - langage <strong>Œª</strong> (dans l'original - Œªanguage).  Dans le processus de cr√©ation, nous utiliserons de nombreuses techniques int√©ressantes, telles que la descente r√©cursive, le style de transfert de contr√¥le et les techniques d'optimisation de base.  Deux versions de l'interpr√©teur seront cr√©√©es - les interpr√®tes standard et CPS, le trans-compilateur en JavaScript. </p><br><p>  L'auteur de l'original est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mihai Bazon</a> , l'auteur de la c√©l√®bre biblioth√®que UglifyJS (un outil pour minimiser et formater le code JS). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: analyseur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: interpr√®te</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: interpr√®te CPS</a> </li><li>  Comment impl√©menter un langage de programmation en JavaScript.  Partie 4: Trans Compilation dans JS </li></ol></div></div><br><p> PS Il y a un bug dans l'interpr√©teur et le compilateur: dans des expressions comme <code>a() &amp;&amp; b()</code> ou <code>a() || b()</code>  <code>a() || b()</code> deux parties sont toujours ex√©cut√©es.  Bien s√ªr, cela est faux car <code>a()</code> faux pour l'op√©rateur <code>&amp;&amp;</code> , ou pas faux pour le <code>||</code>  , alors la valeur de <code>b()</code> ne joue aucun r√¥le.  Ce n'est pas difficile √† r√©soudre. </p><br><h1 id="prostoy-interpretator">  Interpr√®te simple </h1><br><p>  Dans la partie pr√©c√©dente, nous avons √©crit 3 fonctions: <code>InputStream</code> , <code>TokenStream</code> et <code>parse</code> .  Pour obtenir l'AST du code, nous utilisons le code suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  √âcrire un interpr√©teur est plus facile qu'un analyseur: nous parcourons simplement r√©cursivement l'arborescence et ex√©cutons les expressions dans leur ordre normal. </p><br><h2 id="kontekst-environment">  Contexte ( <code>Environment</code> ) </h2><br><p>  Pour une ex√©cution correcte du code, nous avons besoin d'un contexte - un objet contenant toutes les variables dans un emplacement donn√©.  Il sera transmis en tant qu'argument √† la fonction d' <code>evaluate</code> . </p><br><p>  Chaque fois que nous entrons dans le n≈ìud <code>lambda</code> , nous devons ajouter de nouvelles variables aux arguments de la fonction de contexte.  Si l'argument chevauche la variable du bloc externe, nous devons restaurer l'ancienne valeur de la variable apr√®s avoir quitt√© la fonction. </p><br><p>  La fa√ßon la plus simple de proc√©der consiste √† utiliser l'h√©ritage JavaScript prototype.  Lorsque nous entrons dans une nouvelle fonction, nous cr√©ons un nouveau contexte, d√©finissons le contexte externe comme son prototype et appelons la fonction dans le nouveau contexte.  Gr√¢ce √† cela, nous n'avons rien - dans le contexte externe, toutes ses variables resteront. </p><br><p>  Voici l'impl√©mentation de l'objet <code>Environment</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  L'objet <code>Environment</code> a un champ <code>parent</code> qui pointe vers le contexte externe.  Il sera <code>null</code> pour le contexte global.  Il a un champ <code>vars</code> dans lequel toutes les variables appartiennent √† ce contexte.  Pour un contexte global, il est imm√©diatement √©gal √† un objet vide ( <code>Object.create(null)</code> ) et une copie des variables du contexte parent ( <code>Object.create(parent.vars)</code> ) pour un non global. </p><br><p>  Il a plusieurs m√©thodes: </p><br><ul><li>  <code>extend()</code> - copie le contexte actuel. </li><li>  <code>lookup(name)</code> - recherchez le contexte dans lequel la variable nomm√©e <code>name</code> d√©finie. </li><li>  <code>get(name)</code> - r√©cup√®re la valeur d'une variable nomm√©e <code>name</code> .  L√®ve une exception si la variable n'a pas √©t√© d√©finie. </li><li>  <code>set(name, value)</code> - d√©finit la valeur d'une variable.  Cette m√©thode recherche le contexte dans lequel la variable est d√©finie.  S'il n'est pas d√©fini et que nous ne sommes pas dans un contexte global, une exception sera lev√©e. </li><li>  <code>def(name, value)</code> - cr√©e (ou chevauche ou remplace) une variable dans le contexte actuel. </li></ul><br><h2 id="funkciya-evaluate">  <code>evaluate</code> fonction </h2><br><p>  Maintenant que nous avons l'objet <code>Environment</code> , nous pouvons passer √† la r√©solution du probl√®me principal.  Cette fonction sera un grand bloc de <code>switch</code> , qui effectuera une action en fonction du type du n≈ìud transmis: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Pour les litt√©raux, nous renvoyons simplement sa valeur: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  Les variables sont extraites du contexte (le nom de la variable est contenu dans le champ de <code>value</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Pour attribuer, nous devons nous assurer que sur le c√¥t√© gauche, nous avons le nom de la variable (n≈ìud <code>var</code> ).  Sinon, nous lan√ßons simplement une exception (nous ne prenons pas en charge l'affectation √† autre chose que des variables).  Ensuite, nous d√©finissons la valeur de la variable en utilisant <code>env.set</code> .  Notez que le c√¥t√© droit de l'expression doit √™tre calcul√© √† l'aide de l'appel r√©cursif pour <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  Pour un n≈ìud de type <code>binary</code> nous devons appliquer l'op√©rateur pour les deux op√©randes.  Nous √©crirons la fonction <code>apply_op</code> plus tard.  Aussi, nous appelons <code>evaluate</code> pour les deux parties de l'expression: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Un n≈ìud de type <code>lambda</code> renverra une fermeture JavaScript normale, il peut donc √™tre appel√© comme une fonction r√©guli√®re m√™me √† partir de JavaScript.  J'ai ajout√© la fonction <code>make_lambda</code> , que je montrerai plus tard: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  L'ex√©cution du n≈ìud <code>if</code> assez simple: on trouve d'abord la valeur de la condition.  Si ce n'est pas faux, retournez la valeur de la branche <code>then</code> .  Sinon, s'il y a une branche <code>else</code> , alors sa valeur, ou <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  Le n≈ìud <code>prog</code> est une s√©quence d'expressions.  Nous ex√©cutons simplement toutes les expressions dans l'ordre et prenons la valeur de cette derni√®re (la valeur de la s√©quence vide est <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  Pour un n≈ìud de type <code>call</code> nous devons appeler une fonction.  Avant cela, nous allons trouver la valeur de la fonction elle-m√™me, trouver les valeurs de tous les arguments et appeler la fonction en utilisant <code>apply</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  Nous n'arriverons jamais ici, mais au cas o√π nous ajouterions un nouveau type de n≈ìud √† l'analyseur et oublierions de l'ajouter √† l'interpr√©teur: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  C'√©tait la partie principale de l'interpr√®te.  Ci-dessus, nous avons utilis√© deux fonctions que nous n'avons pas encore impl√©ment√©es, alors commen√ßons: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Il re√ßoit le type d'op√©rateur et les arguments.  <code>switch</code> simple et intuitif.  Contrairement √† JavaScript, qui peut prendre n'importe quelle valeur, comme les variables, m√™me celles qui n'ont aucun sens.  Nous exigeons que les op√©randes des op√©rateurs arithm√©tiques soient des nombres et ne permettent pas la division par z√©ro.  Pour les cordes, nous trouverons quelque chose plus tard. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Comme vous pouvez le voir ci-dessus, il renvoie une fonction JavaScript standard qui utilise le contexte pass√© et les fonctions AST.  Tout le travail n'est effectu√© que lorsque la fonction elle-m√™me est appel√©e: un contexte est cr√©√©, des arguments sont d√©finis (s'ils ne suffisent pas, ils deviennent <code>false</code> ).  Ensuite, le corps de la fonction est simplement ex√©cut√© dans un nouveau contexte. </p><br><h4 id="nativnye-funkcii">  Fonctions natives </h4><br><p>  Comme vous pouvez le voir, nous n'avions aucun moyen d'interagir avec JavaScript √† partir de notre langue.  J'avais l'habitude d'utiliser les fonctions <code>print</code> et <code>println</code> , mais je ne les ai d√©finies nulle part.  Nous devons les √©crire en JavaScript et les ajouter simplement au contexte global. </p><br><p>  Voici un exemple d'un tel code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  Code entier </h4><br><p>  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©charger tout le code</a> que nous avons √©crit tout ce temps.  Il peut √™tre lanc√© √† l'aide de NodeJS.  Passez simplement le code au flux standard: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Exemples de code </h1><br><p>  Notre langage de programmation, bien que simple, peut (th√©oriquement) r√©soudre tout probl√®me qui peut √™tre r√©solu par un ordinateur.  En effet, certains mecs plus intelligents que moi ne le seront jamais - Alonzo Church et Alan Turing - ont d√©j√† prouv√© que le Œª-calcul (lambda calcul) est √©quivalent √† une machine de Turing, et notre langage Œª impl√©mente le Œª-calcul. </p><br><p>  Cela signifie que m√™me si notre langue n'a pas d'opportunit√©s, nous pouvons tout de m√™me pouvoir les r√©aliser en utilisant ce que nous avons d√©j√†.  Ou, si cela est difficile √† faire, nous pouvons √©crire un interpr√®te pour une autre langue. </p><br><h4 id="cikly">  Cycles </h4><br><p>  Les boucles ne sont pas un probl√®me si nous avons une r√©cursivit√©.  J'ai d√©j√† montr√© un exemple de boucle impl√©ment√©e au-dessus de la r√©cursivit√©.  Essayons encore. </p><br><pre> <code class="python hljs">print_range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Mais ici, nous avons un probl√®me: si nous augmentons le nombre d'it√©rations, disons, √† 1000. Par exemple, j'obtiens l'erreur ¬´Taille maximale de la pile d'appels d√©pass√©e¬ª apr√®s 600. Cela se produit car l'interpr√©teur est r√©cursif et la r√©cursivit√© atteint la profondeur maximale. </p><br><p>  Il s'agit d'un probl√®me grave, mais il existe une solution.  Je voudrais ajouter de nouvelles constructions pour l'it√©ration ( <code>for</code> ou <code>while</code> ), mais essayons de nous en passer.  La r√©cursivit√© est magnifique, alors laissons-la.  Nous verrons plus loin comment contourner cette limitation. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Structures de donn√©es (leur absence) </h4><br><p>  Il existe trois types de donn√©es dans notre langage Œª: les nombres, les cha√Ænes et les types bool√©ens.  Il peut sembler que vous ne pouvez pas cr√©er de types complexes, tels que des tableaux ou des objets.  Mais ce n'est pas un tat, nous avons un autre type: fonction.  Il s'av√®re que si nous suivons le Œª-calcul, nous pouvons cr√©er toutes les structures de donn√©es, y compris les objets, m√™me avec h√©ritage. </p><br><p>  Je vais le montrer sur l'exemple des listes.  Imaginons que nous ayons une fonction <code>cons</code> qui cr√©e un objet contenant deux valeurs.  Appelons cet objet "cellule" ou "paire".  Nous nommerons l'une des valeurs ¬´voiture¬ª et l'autre ¬´cdr¬ª.  Tout simplement parce qu'ils sont appel√©s ainsi en Lisp.  Maintenant, si nous avons un objet "cellule", alors nous pouvons obtenir ses valeurs en utilisant les fonctions <code>car</code> et <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Maintenant, nous pouvons facilement d√©finir une liste: </p><br><blockquote>  Une liste est une paire contenant le premier √©l√©ment dans `car` et les autres √©l√©ments dans` cdr`.  Mais `cdr` ne peut contenir qu'une seule valeur!  Cette valeur sera une liste.  Une liste est une paire contenant le premier √©l√©ment dans `car` et les autres √©l√©ments dans` cdr`.  Mais `cdr` ne peut contenir qu'une seule valeur!  Cette valeur sera une liste.  [...] <br></blockquote><p>  Il s'agit d'un type de donn√©es r√©cursif.  Mais un probl√®me demeure: quand devez-vous arr√™ter?  Logiquement, nous devrions arr√™ter lorsque <code>cdr</code> est une liste vide.  Mais qu'est-ce qu'une liste vide?  Pour ce faire, ajoutons un nouvel objet appel√© "NIL".  Il peut √™tre utilis√© en couple (nous pouvons utiliser <code>car</code> et <code>cdr</code> dessus, mais leur r√©sultat sera <code>NIL</code> lui-m√™me).  Cr√©ons maintenant une liste des √©l√©ments 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Cela a l'air horrible quand il n'y a pas de syntaxe sp√©ciale pour cela.  Mais je voulais juste montrer que cela peut √™tre fait en utilisant les fonctionnalit√©s existantes du langage Œª.  Voici l'impl√©mentation: </p><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL);</code> </pre> <br><p>  Quand j'ai vu pour la premi√®re fois <code>cons</code> / <code>car</code> / <code>cdr</code> fait de cette fa√ßon, j'ai √©t√© surpris qu'ils n'aient pas besoin d'un seul <code>if</code> (mais c'est √©trange √©tant donn√© qu'il n'est pas dans le Œª-calcul d'origine).  Bien s√ªr, aucun langage de programmation ne proc√®de de cette fa√ßon, car il est extr√™mement inefficace, mais cela ne rend pas les Œª-calculs moins beaux.  Dans un langage clair, ce code effectue les op√©rations suivantes: </p><br><ul><li>  la fonction <code>cons</code> prend deux valeurs ( <code>a</code> et <code>b</code> ) et retourne la fonction qui les contient.  Cette fonction est l'objet m√™me de la paire.  Elle prend un argument et l'appelle pour les deux valeurs de la paire. </li><li>  La fonction <code>car</code> appelle l'argument pass√©, en passant une fonction qui renvoie le premier argument. </li><li>  la fonction <code>cdr</code> fait la m√™me chose que la fonction <code>car</code> , mais avec la seule diff√©rence √©tant que la fonction pass√©e renvoie le deuxi√®me argument. </li><li>  la fonction <code>NIL</code> fonctionne de la m√™me mani√®re que <code>cons</code> , mais renvoie une paire avec deux valeurs √©gales √† NIL. </li></ul><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Il existe de nombreux algorithmes sur les listes qui peuvent √™tre impl√©ment√©s de mani√®re r√©cursive et semblent logiques.  Par exemple, voici une fonction qui appelle la fonction transmise pour chaque √©l√©ment de liste: </p><br><pre> <code class="python hljs">foreach = Œª(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  Et voici un autre qui cr√©e une liste pour une plage de nombres: </p><br><pre> <code class="python hljs">range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), Œª(x) println(x * x));</span></span></code> </pre> <br><p>  Les listes que nous avons impl√©ment√©es ci-dessus sont immuables (nous ne pouvons pas changer de <code>car</code> ou de <code>cdr</code> fois la liste cr√©√©e).  La plupart des lisp ont des fonctions pour changer une paire.  Dans Scheme, ils sont appel√©s <code>set-car!</code>  / <code>set-cdr!</code>  .  En Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Cette fois, nous utilisons les noms de Scheme: </p><br><pre> <code class="python hljs">cons = Œª(x, y) Œª(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Cela montre que nous pouvons impl√©menter des structures de donn√©es mutables.  Je n'entrerai pas dans les d√©tails de son fonctionnement, cela ressort clairement du code. </p><br><p>  Nous pouvons aller plus loin et impl√©menter les objets, mais sans changement de syntaxe ce sera difficile √† faire.  Une autre fa√ßon est d'impl√©menter une nouvelle syntaxe dans le tokenizer / parser et d'ajouter leur traitement dans l'interpr√©teur.  Tous les principaux langages de programmation font cela, et il est n√©cessaire d'atteindre des performances normales.  Nous ajouterons une nouvelle syntaxe dans la prochaine partie de l'article. </p><br><p>  [Du traducteur: si vous √™tes int√©ress√© par le calcul lambda, il y a un article sympa sur Habr√© d√©di√© √† ce sujet: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">calcul lambda en JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Nouvelles constructions syntaxiques </h1><br><p>  Notre langage Œª a pas mal de constructions syntaxiques.  Par exemple, il n'existe aucun moyen direct d'ajouter de nouvelles variables.  Comme je l'ai d√©j√† dit, nous devons utiliser IIFE, donc cela ressemble √† ceci: </p><br><pre> <code class="python hljs">(Œª(x, y){ (Œª(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Nous ajouterons le mot cl√© <code>let</code> .  Cela nous permettra d'√©crire quelque chose comme ceci: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  Pour chaque variable du bloc <code>let</code> , les variables pr√©c√©dentes doivent √™tre disponibles m√™me √† partir du m√™me bloc.  Par cons√©quent, le code ci-dessus sera √©quivalent √† ce qui suit: </p><br><pre> <code class="python hljs">(Œª(x){ (Œª(y){ (Œª(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Ces modifications peuvent √™tre effectu√©es directement dans l'analyseur et ne n√©cessiteront alors pas de modifications dans l'interpr√©teur.  Au lieu d'ajouter un nouveau n≈ìud <code>let</code> , nous pouvons le transformer en n≈ìuds d' <code>call</code> et <code>lambda</code> .  Cela signifie que nous n'avons effectu√© aucun changement s√©mantique dans notre langage - c'est ce qu'on appelle le ¬´sucre syntaxique¬ª, et l'op√©ration de conversion en n≈ìuds AST qui existait auparavant est appel√©e ¬´sans sucre¬ª (original: ¬´desugaring¬ª). </p><br><p>  Cependant, nous devons quand m√™me changer l'analyseur.  Ajoutons un nouveau n≈ìud ¬´let¬ª car il peut √™tre interpr√©t√© plus efficacement (pas besoin de cr√©er de fermetures et de les appeler tout de suite, il suffit de copier et changer le contexte). </p><br><p>  En outre, nous ajouterons la prise en charge de "let named", qui √©tait dans Scheme.  Cela facilite la cr√©ation de boucles: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Il s'agit d'une boucle "r√©cursive" qui compte la somme de 10 + 9 + ... + 0. Auparavant, nous devions le faire comme ceci: </p><br><pre> <code class="python hljs">print((Œª(loop){ loop = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  De plus, pour faciliter cela, nous ajouterons la syntaxe des "fonctions avec un nom".  Cela ressemblera √† ceci: </p><br><pre> <code class="python hljs">print((Œª loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Modifications √† effectuer pour cela: </p><br><ul><li>  Prise en charge du nom facultatif apr√®s <code>lambda</code> mot cl√© <code>lambda</code> .  S'il est pr√©sent, alors nous devons ajouter une variable au contexte actuel qui pointera vers la fonction elle-m√™me.  C'est exactement la m√™me chose que les fonctions avec un nom en JavaScript. </li><li>  Prise en charge du nouveau mot cl√© <code>let</code> .  Vient ensuite un nom facultatif et une liste (√©ventuellement vide) de d√©finitions de variables sous cette forme: <code>foo = EXPRESSION</code> , s√©par√©s par des virgules.  Le corps de l'expression <code>let</code> est une expression unique (qui, bien s√ªr, peut √™tre une s√©quence d'expressions). </li></ul><br><h4 id="izmeneniya-v-parsere">  Modifications de l'analyseur </h4><br><p>  Tout d'abord, un petit changement dans le tokenizer, ajoutez le mot cl√© <code>let</code> √† la liste des mots cl√©s: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda Œª true false "</span></span>;</code> </pre> <br><p>  Modifiez la fonction <code>parse_lambda</code> qu'elle lit un nom facultatif: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  Ajoutez maintenant une fonction qui analyse l'expression <code>let</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Cela g√®re deux cas.  Si apr√®s <code>let</code> il y a un jeton de type <code>var</code> , alors il est <code>let</code> avec un nom.  De plus, nous lisons la liste des d√©finitions en utilisant la fonction <code>delimited</code> , car elles sont entre crochets et s√©par√©es par des virgules, et nous utilisons la fonction <code>parse_vardef</code> , qui est montr√©e ci-dessous.  Ensuite, nous retournons un n≈ìud de type <code>call</code> , qui appelle imm√©diatement une fonction nomm√©e (IIFE).  Les arguments de la fonction sont les variables d√©finies par <code>let</code> , et le n≈ìud d' <code>call</code> passera les valeurs comme arguments.  Et, bien s√ªr, le corps de la fonction est lu √† l'aide de <code>parse_expression()</code> . </p><br><p>  S'il s'agit d'un <code>let</code> simple, alors nous retournons un noeud de type <code>let</code> avec les champs <code>vars</code> et <code>body</code> .  Le champ <code>vars</code> contient un tableau de variables au format suivant: <code>{ name: VARIABLE, def: AST }</code> , qui sont analys√©es par la fonction suivante: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  De plus, vous devez ajouter une v√©rification pour un nouveau type d'expression dans la fonction <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Changements d'interpr√®te </h4><br><p>  Puisque nous avons d√©cid√© de changer la structure de l'AST au lieu de la ¬´casser¬ª dans les anciens types de n≈ìuds, nous devons ajouter le traitement de la nouvelle logique √† l'interpr√©teur. </p><br><p>  Afin d'ajouter la prise en charge du nom de fonction facultatif, nous modifions la fonction <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Si la fonction a un nom, alors lorsque nous cr√©ons la fermeture, nous faisons une copie du contexte et ajoutons la fonction au contexte.  Le reste reste le m√™me. </p><br><p>  Et enfin, pour traiter un n≈ìud de type <code>let</code> , nous ajoutons le cas suivant √† l'interpr√©teur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Notez que pour chaque variable, un nouveau contexte est cr√©√© dans lequel une nouvelle variable est ajout√©e.  Apr√®s cela, nous ex√©cutons simplement le corps dans le dernier contexte. </p><br><h4 id="primery">  Des exemples </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   ‚Äî  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> , ,           ,     .        JavaScript    Œª. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( Œª() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  Œª  ,  ,   JS   4 . , ,  . </p><br><p>       Œª  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   ‚Äî JavaScript. ,         JavaScript ‚Äî     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp ‚Äî   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: interpr√®te CPS</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443812/">https://habr.com/ru/post/fr443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443792/index.html">Erreurs typiques lors de l'utilisation de PostgreSQL. 2e partie</a></li>
<li><a href="../fr443798/index.html">Piratage Zotero: stockage synchronis√© illimit√© et son utilisation fluide avec rmarkdown</a></li>
<li><a href="../fr443804/index.html">C # est un langage de bas niveau?</a></li>
<li><a href="../fr443808/index.html">Analytique des filles √† faible responsabilit√© sociale (charg√©e de Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../fr443810/index.html">Combien gagnent les d√©veloppeurs de diff√©rentes qualifications, 2018</a></li>
<li><a href="../fr443814/index.html">Donner est mon "ancienne entreprise"</a></li>
<li><a href="../fr443816/index.html">Le minist√®re des Communications insiste sur un seul op√©rateur 5G</a></li>
<li><a href="../fr443818/index.html">R√©sum√© des √©v√©nements informatiques de mars (deuxi√®me partie)</a></li>
<li><a href="../fr443820/index.html">Comment l'a√©roport de Fukuoka a d√©couvert quelles mesures seraient efficaces pour r√©duire les files d'attente</a></li>
<li><a href="../fr443822/index.html">Orchestre de performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>