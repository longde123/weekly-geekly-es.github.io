<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¦ğŸ» â™¾ ğŸ•µğŸ» Zenject: Como um contÃªiner de IoC pode matar a injeÃ§Ã£o de dependÃªncia em seu projeto ğŸ’¦ ğŸ‘¨â€â¤ï¸â€ğŸ‘¨ ğŸ‘·ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Onde comeÃ§a o perigo? Suponha que vocÃª esteja firmemente determinado a desenvolver um projeto, aderindo a um conceito ou abordagem especÃ­fica. Em noss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zenject: Como um contÃªiner de IoC pode matar a injeÃ§Ã£o de dependÃªncia em seu projeto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420235/">  Onde comeÃ§a o perigo?  Suponha que vocÃª esteja firmemente determinado a desenvolver um projeto, aderindo a um conceito ou abordagem especÃ­fica.  Em nossa situaÃ§Ã£o, isso Ã© DI, embora a ProgramaÃ§Ã£o Reativa, por exemplo, tambÃ©m esteja em seu lugar.  Ã‰ lÃ³gico que, para alcanÃ§ar seu objetivo, vocÃª se voltarÃ¡ para soluÃ§Ãµes prontas (em nosso exemplo, o recipiente DI Zenject).  VocÃª se familiarizarÃ¡ com a documentaÃ§Ã£o e comeÃ§arÃ¡ a construir a estrutura do aplicativo usando a funcionalidade principal.  Se, nos primeiros estÃ¡gios do uso da soluÃ§Ã£o, vocÃª nÃ£o tiver sensaÃ§Ãµes desagradÃ¡veis, provavelmente isso permanecerÃ¡ no seu projeto por toda a vida.  Ao trabalhar com as funÃ§Ãµes bÃ¡sicas da soluÃ§Ã£o (contÃªiner), vocÃª pode ter dÃºvidas ou desejos para tornar algumas funcionalidades mais bonitas ou eficazes.  Certamente, em primeiro lugar, vocÃª se voltarÃ¡ para os "recursos" mais avanÃ§ados da soluÃ§Ã£o (contÃªiner) para isso.  E, nesse estÃ¡gio, pode surgir a seguinte situaÃ§Ã£o: vocÃª jÃ¡ conhece bem e confia na soluÃ§Ã£o escolhida, devido Ã  qual muitos podem nÃ£o pensar em quÃ£o ideologicamente correto o uso de um ou outro funcional na soluÃ§Ã£o pode ser ou a transiÃ§Ã£o para outra soluÃ§Ã£o jÃ¡ Ã© bastante cara e inadequada ( por exemplo, o prazo estÃ¡ se aproximando).  Ã‰ nesse estÃ¡gio que a situaÃ§Ã£o mais perigosa pode surgir - a funcionalidade da soluÃ§Ã£o Ã© usada com pouco cuidado ou, em casos raros, simplesmente na mÃ¡quina (sem pensar). <br><a name="habracut"></a><br><h3>  Quem poderia estar interessado nisso? </h3><br>  Este artigo serÃ¡ Ãºtil para aqueles que estÃ£o familiarizados com os adeptos de DI e iniciantes.  Para entender o conhecimento bÃ¡sico suficiente sobre quais padrÃµes sÃ£o usados â€‹â€‹pelo DI, o objetivo do DI e as funÃ§Ãµes que um contÃªiner de IoC executa.  NÃ£o se trata dos meandros da implementaÃ§Ã£o do Zenject, mas da aplicaÃ§Ã£o de parte de sua funcionalidade.  O artigo se baseia apenas na documentaÃ§Ã£o oficial do Zenject e nos exemplos de cÃ³digo dele, bem como no livro de Mark Siman, "Dependency Injection in .NET", que Ã© um trabalho exaustivo clÃ¡ssico sobre o tema da teoria da DI.  Todas as citaÃ§Ãµes neste artigo sÃ£o trechos do livro de Mark Siman.  Apesar de falarmos sobre um contÃªiner especÃ­fico, o artigo pode ser Ãºtil para quem usa outros contÃªineres. <br><br>  O objetivo deste artigo Ã© mostrar como uma ferramenta cujo objetivo Ã© ajudÃ¡-lo a implementar a DI no seu projeto pode levÃ¡-lo a uma direÃ§Ã£o completamente diferente, forÃ§ando-o a cometer erros que vinculam seu cÃ³digo, reduzir a testabilidade do cÃ³digo e geralmente privÃ¡-lo de todas as vantagens que podem oferecer vocÃª DI. <br><br>  <i><b>IsenÃ§Ã£o de responsabilidade</b></i> : O objetivo deste artigo nÃ£o Ã© criticar o Zenject ou seus autores.  O Zenject pode ser usado para o propÃ³sito a que se destina e serve como uma excelente ferramenta para implementar a DI, desde que vocÃª nÃ£o use um conjunto completo de funÃ§Ãµes, tendo definido algumas limitaÃ§Ãµes para si mesmo. <br><br><h3>  1. IntroduÃ§Ã£o </h3><br>  <i>O Zenject</i> Ã© um contÃªiner de injeÃ§Ã£o de dependÃªncia de cÃ³digo aberto projetado para ser usado com o mecanismo de jogo Unity3D, que funciona na maioria das plataformas suportadas pelo Unity3D.  Vale ressaltar que o Zenject tambÃ©m pode ser usado para aplicativos C # desenvolvidos sem o Unity3D.  Esse contÃªiner Ã© bastante popular entre os desenvolvedores do Unity, Ã© suportado e desenvolvido ativamente.  AlÃ©m disso, o Zenject possui toda a funcionalidade necessÃ¡ria do contÃªiner DI. <br><br>  Eu usei o Zenject em 3 grandes projetos do Unity e tambÃ©m me comuniquei com um grande nÃºmero de desenvolvedores que o usaram.  O motivo de escrever este artigo sÃ£o perguntas frequentes: <br><br><ul><li>  O uso do Zenject Ã© uma boa soluÃ§Ã£o? </li><li>  O que hÃ¡ de errado com o Zenject? </li><li>  Que dificuldades surgem ao usar o Zenject? </li></ul><br>  E tambÃ©m alguns projetos nos quais o uso do Zenject nÃ£o levou Ã  soluÃ§Ã£o de problemas de forte conectividade de cÃ³digo e arquitetura malsucedida, mas, pelo contrÃ¡rio, exacerbaram a situaÃ§Ã£o. <br><br>  Vamos ver por que os desenvolvedores tÃªm essas perguntas e problemas.  VocÃª pode responder da seguinte maneira: <br><blockquote>  Ironicamente, os prÃ³prios contÃªineres DI tendem a ser dependÃªncias estÃ¡veis.  ... Ao decidir desenvolver seu aplicativo com base em um contÃªiner DI especÃ­fico, vocÃª corre o risco de ficar limitado a essa opÃ§Ã£o por todo o ciclo de vida do aplicativo. </blockquote>  Vale a pena notar que, com o uso adequado e limitado do contÃªiner, mudar para o uso de outro contÃªiner no aplicativo (ou recusar o uso do contÃªiner em favor da â€œ <i>implementaÃ§Ã£o para os pobres</i> â€) Ã© bem possÃ­vel e nÃ£o levarÃ¡ muito tempo.  Ã‰ verdade que, em tal situaÃ§Ã£o, Ã© improvÃ¡vel que vocÃª precise. <br><br>  Antes de comeÃ§ar a desmontar a funcionalidade potencialmente perigosa do Zenject, faz sentido atualizar superficialmente vÃ¡rios aspectos bÃ¡sicos do DI. <br><br>  O primeiro aspecto Ã© o <i>objetivo dos contÃªineres DI.</i>  Mark Siman escreve o seguinte em seu livro sobre este assunto: <br><blockquote>  Um contÃªiner de DI Ã© uma biblioteca de software que pode automatizar muitas das tarefas executadas ao montar objetos e gerenciar seu ciclo de vida. </blockquote><blockquote>  NÃ£o espere que o contÃªiner de DI transforme magicamente cÃ³digo fortemente acoplado em cÃ³digo pouco acoplado.  Um contÃªiner pode melhorar a eficiÃªncia do uso de DI, mas a Ãªnfase no aplicativo deve ser colocada principalmente no uso de padrÃµes e no trabalho com DI. </blockquote>  O segundo aspecto sÃ£o os <i>padrÃµes de DI</i> .  Mark Siman identifica quatro padrÃµes principais, classificados por frequÃªncia e pela necessidade de seu uso: <br><br><ol><li>  ImplementaÃ§Ã£o do construtor - Como podemos garantir que a dependÃªncia necessÃ¡ria estarÃ¡ sempre disponÃ­vel para a classe que estÃ¡ sendo desenvolvida? </li><li>  ImplementaÃ§Ã£o de propriedade - como posso ativar o DI como uma opÃ§Ã£o na classe se houver um padrÃ£o local adequado? </li><li>  ImplementaÃ§Ã£o do mÃ©todo - Como injetar dependÃªncias em uma classe se elas sÃ£o diferentes para cada operaÃ§Ã£o? </li><li>  Contexto do ambiente - Como podemos disponibilizar uma dependÃªncia em cada mÃ³dulo sem incluir aspectos transversais do aplicativo em cada componente da API? </li></ol><br>  As perguntas indicadas ao lado do nome dos padrÃµes descrevem completamente seu escopo.  Ao mesmo tempo, o artigo nÃ£o discutirÃ¡ a ImplementaÃ§Ã£o do Construtor (jÃ¡ que praticamente nÃ£o hÃ¡ queixas sobre sua implementaÃ§Ã£o no Zenject) e o Contexto Ambiental (sua implementaÃ§Ã£o nÃ£o estÃ¡ no contÃªiner, mas vocÃª pode implementÃ¡-lo facilmente com base na funcionalidade existente). <br>  Agora vocÃª pode ir diretamente para a funcionalidade potencialmente perigosa do Zenject. <br><br><h3>  Funcionalidade perigosa. </h3><br><h4>  Propriedades do Implemento </h4><br>  Este Ã© o segundo padrÃ£o de DI mais comum, apÃ³s a implementaÃ§Ã£o do construtor, mas Ã© usado com muito menos frequÃªncia.  Implementado no Zenject da seguinte maneira: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  AlÃ©m disso, o Zenject tambÃ©m possui um conceito como â€œInjeÃ§Ã£o de Campoâ€.  Vamos ver por que em todo Zenject essa funcionalidade Ã© a mais perigosa. <br><br><ul><li>  Um atributo Ã© usado para mostrar ao container qual campo incorporar.  Esta Ã© uma soluÃ§Ã£o completamente compreensÃ­vel, do ponto de vista da simplicidade e lÃ³gica de implementaÃ§Ã£o do prÃ³prio contÃªiner.  No entanto, vemos um atributo (assim como espaÃ§o para nome) no cÃ³digo da classe.  Ou seja, pelo menos indiretamente, mas a classe comeÃ§a a saber de onde obtÃ©m a dependÃªncia.  AlÃ©m disso, estamos comeÃ§ando a apertar o cÃ³digo da classe no contÃªiner.  Em outras palavras, nÃ£o podemos mais nos recusar a usar o Zenject sem manipular o cÃ³digo da classe. </li><li>  O prÃ³prio padrÃ£o Ã© usado em situaÃ§Ãµes em que a dependÃªncia possui um padrÃ£o local.  Ou seja, essa Ã© uma dependÃªncia opcional e, se o contÃªiner nÃ£o puder fornecÃª-lo, nÃ£o haverÃ¡ erros no projeto e tudo funcionarÃ¡.  No entanto, usando o Zenject, vocÃª sempre obtÃ©m essa dependÃªncia - a dependÃªncia se torna nÃ£o opcional. </li><li>  Como a dependÃªncia nesse caso nÃ£o Ã© opcional, ela comeÃ§a a estragar toda a lÃ³gica da implementaÃ§Ã£o do construtor, porque apenas as dependÃªncias necessÃ¡rias devem ser introduzidas lÃ¡.  Ao implementar dependÃªncias nÃ£o opcionais por meio de propriedades, vocÃª tem a oportunidade de criar dependÃªncias circulares no cÃ³digo.  Eles nÃ£o serÃ£o tÃ£o Ã³bvios, porque no Zenject, a implementaÃ§Ã£o do construtor Ã© realizada primeiro e, em seguida, a implementaÃ§Ã£o da propriedade, e vocÃª nÃ£o receberÃ¡ um aviso do contÃªiner. </li><li>  O uso do contÃªiner de DI implica a implementaÃ§Ã£o do padrÃ£o Raiz de ComposiÃ§Ã£o, no entanto, o uso do atributo para configurar a implementaÃ§Ã£o da propriedade leva ao fato de vocÃª configurar o cÃ³digo nÃ£o apenas na Raiz da ComposiÃ§Ã£o, mas tambÃ©m conforme necessÃ¡rio em cada classe. </li></ul><br><h4>  FÃ¡bricas (e MemoryPool) </h4><br>  A documentaÃ§Ã£o do Zenject tem uma <a href="">seÃ§Ã£o</a> inteira sobre fÃ¡bricas.  Essa funcionalidade Ã© implementada no nÃ­vel do prÃ³prio contÃªiner e tambÃ©m Ã© possÃ­vel criar suas prÃ³prias fÃ¡bricas personalizadas.  Vamos dar uma olhada no primeiro exemplo da documentaÃ§Ã£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  JÃ¡ neste exemplo, hÃ¡ uma violaÃ§Ã£o grave da DI.  Mas este Ã© um exemplo de como fazer uma fÃ¡brica totalmente personalizada.  Qual Ã© o principal problema aqui? <br><blockquote>  Um contÃªiner de DI pode ser erroneamente considerado um localizador de serviÃ§o, mas deve ser usado apenas como um mecanismo para vincular grÃ¡ficos de objetos.  Se considerarmos o contÃªiner desse ponto de vista, faz sentido limitar seu uso apenas Ã  raiz do layout.  Essa abordagem tem a vantagem importante de eliminar qualquer ligaÃ§Ã£o entre o contÃªiner e o restante do cÃ³digo do aplicativo. </blockquote>  Vejamos como as fÃ¡bricas "embutidas" da Zenject funcionam.  Existe uma interface IFactory para isso, cuja implementaÃ§Ã£o nos leva Ã  classe PlaceholderFactory: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Nele, vemos o parÃ¢metro InjectContext, que possui muitos construtores, no formato: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  E, novamente, obtemos a transferÃªncia do prÃ³prio contÃªiner como uma dependÃªncia para a classe.  Essa abordagem Ã© uma violaÃ§Ã£o grave da DI e uma transformaÃ§Ã£o parcial do contÃªiner em um Localizador de ServiÃ§os. <br>  AlÃ©m disso, a desvantagem desta soluÃ§Ã£o Ã© que o contÃªiner Ã© usado para criar dependÃªncias de curto prazo e deve criar apenas dependÃªncias de longo prazo. <br><br>  Para evitar essas violaÃ§Ãµes, os autores do contÃªiner podem excluir completamente a possibilidade de passar o contÃªiner como uma dependÃªncia para todas as classes registradas.  NÃ£o seria difÃ­cil implementÃ¡-lo, uma vez que todo o contÃªiner funciona por meio de reflexÃ£o e anÃ¡lise dos parÃ¢metros de mÃ©todos e construtores para criar e distribuir o grÃ¡fico de objetos de aplicativo. <br><br><h4>  ImplementaÃ§Ã£o de mÃ©todo </h4><br>  A lÃ³gica da implementaÃ§Ã£o do MÃ©todo no Zenject Ã© a seguinte: primeiro, em todas as classes, o construtor Ã© implementado, depois as propriedades sÃ£o implementadas e, finalmente, o mÃ©todo Ã© implementado.  Considere o exemplo de implementaÃ§Ã£o fornecido na documentaÃ§Ã£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  Quais sÃ£o as desvantagens aqui: <br><br><ul><li>  VocÃª pode escrever qualquer nÃºmero de mÃ©todos que serÃ£o implementados na estrutura de uma classe.  Assim, como no caso da implementaÃ§Ã£o da propriedade, temos a oportunidade de fazer o maior nÃºmero possÃ­vel de dependÃªncias cÃ­clicas. </li><li>  Como a implementaÃ§Ã£o de uma propriedade, a implementaÃ§Ã£o de um mÃ©todo Ã© implementada por meio de um atributo, que associa seu cÃ³digo ao cÃ³digo do prÃ³prio contÃªiner. </li><li>  A implementaÃ§Ã£o do mÃ©todo no Zenject Ã© usada apenas como uma alternativa aos construtores, o que Ã© conveniente no caso das classes MonoBehavior, mas contradiz absolutamente a teoria descrita por Mark Siman.  O exemplo clÃ¡ssico da implementaÃ§Ã£o canÃ´nica do mÃ©todo pode ser considerado o uso de fÃ¡bricas (mÃ©todos de fÃ¡brica). </li><li>  Se houver vÃ¡rios mÃ©todos introduzidos na classe ou, alÃ©m do mÃ©todo, tambÃ©m houver um construtor, as dependÃªncias necessÃ¡rias para a classe serÃ£o espalhadas em locais diferentes, o que interferirÃ¡ na imagem como um todo.  Ou seja, se a classe 1 tiver um construtor, o nÃºmero de seus parÃ¢metros poderÃ¡ mostrar claramente se hÃ¡ erros de design na classe e se o princÃ­pio de responsabilidade exclusiva Ã© violado e se as dependÃªncias sÃ£o dispersas por vÃ¡rios mÃ©todos, pelo construtor ou talvez por algumas propriedades, entÃ£o a imagem nÃ£o serÃ¡ tÃ£o Ã³bvia quanto poderia ser. </li></ul><br>  Conclui-se que a presenÃ§a dessa implementaÃ§Ã£o da implementaÃ§Ã£o do mÃ©todo no contÃªiner, o que contradiz a teoria da DI, nÃ£o possui uma Ãºnica vantagem.  Com uma grande ressalva, uma vantagem sÃ³ pode ser considerada a possibilidade de usar o mÃ©todo implementado, como um construtor para o MonoBehaviour.  Mas este Ã© um momento bastante controverso, jÃ¡ que, do ponto de vista da lÃ³gica do contÃªiner, dos padrÃµes DI e do dispositivo de memÃ³ria interna do Unity3D, todos os objetos MonoBehaviour em seu aplicativo podem ser considerados gerenciados por recursos e, nesse caso, serÃ¡ muito mais eficiente delegar o gerenciamento do ciclo de vida desses objetos. nÃ£o um contÃªiner de DI, mas uma classe auxiliar (seja Wrapper, ViewModel, Fasade ou qualquer outra coisa). <br><br><h4>  LigaÃ§Ãµes Globais </h4><br>  Essa Ã© uma funcionalidade auxiliar bastante conveniente que permite definir aglutinantes globais que podem viver independentemente da transiÃ§Ã£o entre as cenas.  VocÃª pode ler mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na documentaÃ§Ã£o</a> .  Essa funcionalidade Ã© extremamente conveniente e bastante Ãºtil.  Vale ressaltar que ele nÃ£o viola os padrÃµes e princÃ­pios da DI, mas possui uma implementaÃ§Ã£o nÃ£o Ã³bvia e feia.  A linha inferior Ã© que vocÃª cria um tipo especial de prÃ©-fabricaÃ§Ã£o, anexa um script com a configuraÃ§Ã£o do contÃªiner (Installer) e salva em uma pasta de projeto estritamente definida, sem a capacidade de mover-se para algum lugar e sem links para ele.  A desvantagem desta ferramenta reside unicamente na sua implicitaÃ§Ã£o.  Quando se trata de instaladores comuns, tudo Ã© bem simples: vocÃª tem um objeto no palco, o script do instalador fica nele.  Se um novo desenvolvedor vier ao projeto, o instalador se tornarÃ¡ um excelente ponto para imersÃ£o no projeto.  Com base em um Ãºnico instalador, um desenvolvedor pode ter uma idÃ©ia de quais mÃ³dulos um projeto consiste e como um grÃ¡fico de objetos Ã© construÃ­do.  PorÃ©m, com o uso de ligantes globais, o instalador no palco deixa de ser uma fonte suficiente dessas informaÃ§Ãµes.  NÃ£o hÃ¡ um Ãºnico link para a ligaÃ§Ã£o global no cÃ³digo de outros instaladores (presente nas cenas) e, portanto, vocÃª nÃ£o vÃª o grÃ¡fico completo dos objetos.  E somente durante a anÃ¡lise das classes vocÃª entende que alguns dos ligantes nÃ£o sÃ£o suficientes no instalador no palco.  Mais uma vez, farei uma reserva de que essa desvantagem Ã© puramente cosmÃ©tica. <br><br><h4>  Identificadores </h4><br>  A capacidade de definir uma ligaÃ§Ã£o especÃ­fica para um identificador para obter uma certa dependÃªncia de um conjunto de dependÃªncias semelhantes em uma classe.  Um exemplo: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  Essa funcionalidade pode ser realmente situacionalmente Ãºtil e Ã© uma opÃ§Ã£o adicional para a implementaÃ§Ã£o de propriedades.  No entanto, alÃ©m da conveniÃªncia, ele herda todos os problemas identificados na seÃ§Ã£o "Propriedades de implementaÃ§Ã£o", adicionando ainda mais coerÃªncia ao cÃ³digo, introduzindo uma certa constante que vocÃª precisa lembrar ao configurar seu cÃ³digo.  Se vocÃª excluir acidentalmente esse identificador, poderÃ¡ obter facilmente um nÃ£o ativo do aplicativo em funcionamento. <br><br><h4>  Sinais e ITickable </h4><br>  Os sinais sÃ£o anÃ¡logos do mecanismo do Agregador de Eventos embutido no contÃªiner.  A idÃ©ia de implementar essa funcionalidade Ã©, sem dÃºvida, nobre, pois visa reduzir o nÃºmero de conexÃµes entre objetos que se comunicam atravÃ©s do mecanismo de assinatura de eventos.  Um exemplo bastante volumoso pode ser encontrado na <a href="">documentaÃ§Ã£o</a> , no entanto, nÃ£o estarÃ¡ no artigo, porque a implementaÃ§Ã£o especÃ­fica nÃ£o importa. <br><br>  Suporte para a interface ITickable - substituindo os mÃ©todos padrÃ£o Update, LateUpdate e FixedUpdate no Unity, delegando chamadas para mÃ©todos de atualizaÃ§Ã£o de objetos com a interface ITickable no contÃªiner.  Um exemplo tambÃ©m estÃ¡ na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentaÃ§Ã£o</a> , e sua implementaÃ§Ã£o no contexto do artigo tambÃ©m nÃ£o importa. <br><br>  O problema dos sinais e do ITickable nÃ£o se refere a aspectos de sua implementaÃ§Ã£o, sua raiz estÃ¡ no uso de efeitos colaterais do contÃªiner.  Em sua essÃªncia, o contÃªiner conhece quase todas as classes e suas instÃ¢ncias no projeto, mas sua responsabilidade Ã© criar um grÃ¡fico de objetos e gerenciar seu ciclo de vida.  Adicionando mecanismos como Signals, ITickable, etc., adicionamos mais responsabilidades ao contÃªiner e cada vez mais anexamos o cÃ³digo do aplicativo, tornando-o a parte exclusiva e insubstituÃ­vel do cÃ³digo, praticamente um "objeto divino". <br><br><h3>  Em vez de saÃ­da </h3><br><blockquote>  O mais importante sobre contÃªineres Ã© entender que o uso de DI Ã© independente do uso de um contÃªiner de DI.  Um aplicativo pode ser criado a partir de muitas classes e mÃ³dulos fracamente acoplados, e nenhum desses mÃ³dulos deve saber nada sobre o contÃªiner. </blockquote>  Cuidado ao usar soluÃ§Ãµes prontas para o uso (em caixa) ou pequenos plugins.  Use-os pensativamente.  De fato, coisas ainda mais grandiosas nas quais vocÃª confia (por exemplo, mecanismos de jogos da escala do prÃ³prio Unity3D) podem pecar com esses erros e borrÃµes teÃ³ricos.  E isso, em Ãºltima anÃ¡lise, afetarÃ¡ nÃ£o o trabalho da soluÃ§Ã£o que vocÃª usa, mas a sustentabilidade, o trabalho e a qualidade do seu produto final.  Espero que todo mundo que leu atÃ© o final, o artigo seja Ãºtil ou, pelo menos, nÃ£o se arrependa pelo tempo gasto na leitura. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420235/">https://habr.com/ru/post/pt420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420223/index.html">Algumas dicas simples: como evitar danos ao drone</a></li>
<li><a href="../pt420225/index.html">Melodia AlgorÃ­tmica Infinita Baseada em NÃºmeros Primos</a></li>
<li><a href="../pt420227/index.html">Presidente turco anuncia proibiÃ§Ã£o de importaÃ§Ã£o de eletrÃ´nicos nos EUA</a></li>
<li><a href="../pt420229/index.html">As crianÃ§as das aldeias podem se tornar programadores se, nas proximidades, ensinarem apenas ferroviÃ¡rios. Conversa com o "CÃ­rculo"</a></li>
<li><a href="../pt420233/index.html">UE4 Equipamento para Multiplayer # 5 | TransferÃªncia de informaÃ§Ãµes entre servidor e cliente</a></li>
<li><a href="../pt420237/index.html">Wrapper Qt em torno da estrutura gRPC em C ++</a></li>
<li><a href="../pt420239/index.html">Desenvolvimento mÃ³vel. Swift: o mistÃ©rio dos protocolos</a></li>
<li><a href="../pt420243/index.html">Filantropia inovadora: Projetos de inovaÃ§Ã£o humanitÃ¡ria</a></li>
<li><a href="../pt420245/index.html">Como evitar a saturaÃ§Ã£o de memÃ³ria ao usar coleÃ§Ãµes Java</a></li>
<li><a href="../pt420251/index.html">Apple afirma que o complexo da sede da empresa custa apenas US $ 200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>