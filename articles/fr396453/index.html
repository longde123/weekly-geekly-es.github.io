<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅰️ ⚰️ 🌭 Tapis avec un cheval et un éléphant. Base de décision 🏇🏻 🖖🏻 🍍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous voulez énigmer un joueur d'échecs débutant? 
 Demandez-lui de mater avec un cheval et un éléphant. 
 
 Vous voulez surprendre un programmeur novi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tapis avec un cheval et un éléphant. Base de décision</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/396453/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voulez énigmer un joueur d'échecs débutant? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Demandez-lui de mater avec un cheval et un éléphant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous voulez surprendre un programmeur novice? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Demandez-lui de calculer le tapis avec un cheval et un éléphant. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/552/4b2/6d8/5524b26d81625b9ae809054ed010ee1d.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les problèmes d'échecs excitent l'imagination du programmeur, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c'est pourquoi pour la démonstration pratique de la combinatoire </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
j'ai choisi le problème d'échecs le plus difficile du cycle "échec et mat au roi solitaire".</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fixation d'objectifs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but du projet est de créer une base de solutions, c'est-à-dire une liste des bons mouvements pour tous les emplacements possibles du roi blanc, de l'éléphant, du cheval et du roi noir sur l'échiquier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette publication, je vais vous expliquer comment j'ai résolu ce problème, quelles difficultés j'ai dû affronter, et aussi vous montrer ce qui s'est finalement produit. Technologies utilisées: C #, JavaScript, PHP, HTML, CSS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant un joueur d'échecs très médiocre, je n'ai jamais appris à mater rapidement avec un cheval et un éléphant. Par conséquent, j'ai décidé de compenser cette lacune par mes compétences en programmation, de trier toutes les positions possibles et de trouver le bon choix pour chacune.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant d'écrire au moins une ligne de code, j'ai élaboré un plan «napoléonien» sur la façon dont je le ferais pendant plusieurs semaines. </font><font style="vertical-align: inherit;">Je voulais vraiment commencer à résoudre ce problème depuis la fin, en triant toutes les combinaisons mates. </font><font style="vertical-align: inherit;">Et puis, faites un pas en arrière jusqu'à ce que toutes les options possibles soient épuisées.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combien d'options existe-t-il?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a 64 cellules sur un échiquier. </font><font style="vertical-align: inherit;">Nous avons quatre chiffres. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre de combinaisons possibles est 64 * 64 * 64 * 64 = 16 777 216. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous ne pouvez laisser qu'un éléphant à poitrine blanche. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre d'options sera divisé par deux: 64 * 32 * 64 * 64 = 8 388 608. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tant de postes seront dans notre base de données de solutions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, il y a encore moins de combinaisons: deux pièces ne peuvent pas se tenir sur une case, les rois ne peuvent pas se tenir sur des cases adjacentes, le roi noir ne peut pas être sous le contrôle, et ainsi de suite. </font><font style="vertical-align: inherit;">Pour l'avenir, je dirai que la base de données des solutions s'est avérée être 5 609 790 combinaisons, le tableau sera rempli de 67%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, pour simplifier l'algorithme et accélérer l'accès aux données de la base de données, j'ai décidé de ne pas «perdre de temps dessus» et de créer un tableau à quatre dimensions pour toutes les combinaisons.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure suivante est définie pour stocker chaque combinaison:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Combo<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKing;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteBishop;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKnight;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord blackKing;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'intérieur, une autre structure Coord est utilisée pour enregistrer les coordonnées de la figure, avec la possibilité de calculer l'indice de 0 à 63, ainsi qu'avec un opérateur de comparaison surchargé.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coord<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//    0  7 ( a  h)</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> y; <span class="hljs-comment"><span class="hljs-comment">//    0  7</span></span><font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y * <span class="hljs-number"><span class="hljs-number">8</span></span>; }
            <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { x = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> % <span class="hljs-number"><span class="hljs-number">8</span></span>); <font></font>
                  y = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>); }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (Coord a, Coord b)<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.x == b.x &amp;&amp; a.y == b.y;<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure s'est avérée très pratique pour passer comme argument à diverses fonctions auxiliaires, par exemple:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheck</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckmate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckByBishop</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     </span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, pour enregistrer le résultat de la base de décisions de cette structure ne suffit pas, nous avons encore besoin ... </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boîte blanche</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'objectif de notre programme sera de créer une "boîte blanche", dans laquelle toutes les positions dans lesquelles le "mouvement est blanc", et pour lesquelles on sait quel mouvement prendre, et à travers combien de mouvements il sera garanti de mater, seront additionnées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une partie intégrante de la «boîte blanche» est la structure suivante:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WhitesMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves;     <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveFrom; <span class="hljs-comment"><span class="hljs-comment">//   - </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveTo;   <span class="hljs-comment"><span class="hljs-comment">// </span></span><font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La façon la plus simple d'organiser une «boîte blanche» consiste à ouvrir une matrice à quatre dimensions. </font><font style="vertical-align: inherit;">Chaque dimension de cette matrice correspond à la position possible de chaque figure:</font></font><br>
<br>
<pre><code class="cs hljs">    WhitesMove [ , , , ] box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WhitesMove [<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>];
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la première dimension est la coordonnée du roi blanc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la deuxième dimension est la coordonnée de l'éléphant blanc / 2. la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
troisième dimension est la coordonnée du cheval blanc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la quatrième dimension est la coordonnée du roi noir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'essentiel est de ne pas confondre leur commande :) Le tableau s'avérera être déchargé à 33%, mais très pratique pour le traitement. </font><font style="vertical-align: inherit;">C'est dans ce tableau que 8 388 608 entrées seront stockées pour résoudre les combinaisons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, avant de commencer à écrire tous les algorithmes de recherche, j'ai créé un projet vide et initialisé cette matrice à quatre dimensions, afin de s'assurer qu'il y a suffisamment de mémoire et qu'il ne sera pas nécessaire d'inventer quelque chose de plus. </font><font style="vertical-align: inherit;">Apparemment, l'expérience de participer aux olympiades informatiques du dernier millénaire, où la taille de la structure ne pouvait pas dépasser 64 kilo-octets, a affecté Turbo Pascal 7.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idée de l'algorithme</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décrivez brièvement l'idée principale de résoudre ce problème. </font><font style="vertical-align: inherit;">Il est basé sur un premier algorithme de recherche, qui a dû être légèrement modifié, car deux personnes jouent aux échecs et des mouvements sont effectués à tour de rôle. </font><font style="vertical-align: inherit;">Par conséquent, au lieu d'une ligne, nous avons besoin de deux - «noir» et «blanc».</font></font><br>
<br>
<pre><code class="cs hljs">    Queue&lt;BlacksMove&gt; blackQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;BlacksMove&gt;();<font></font>
    Queue&lt;WhitesMove&gt; whiteQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;WhitesMove&gt;();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec la structure de WhitesMove, nous nous sommes déjà rencontrés. </font><font style="vertical-align: inherit;">La structure de BlacksMove est un peu plus simple, car il n'est pas nécessaire d'y stocker le dernier mouvement de Black.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlacksMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves; <font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, dans la «ligne noire», nous placerons toutes les positions mates dans lesquelles le mouvement est noir. </font><font style="vertical-align: inherit;">Ensuite, à partir de chacune de ces positions, nous effectuerons un mouvement inverse pour les Blancs et formerons une "ligne blanche" - une liste de positions dans lesquelles les Blancs se déplaceront. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces étapes devront être répétées jusqu'à épuisement de toutes les combinaisons possibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme principal sous forme de pseudo-code:</font></font><br>
<br>
<pre><code class="cs hljs">       <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
         <font></font>
         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      <font></font>
      {<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                    <font></font>
                      <font></font>
                           <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                      <font></font>
                        <font></font>
                      <span class="hljs-string"><span class="hljs-string">" "</span></span>
                         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      }  <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
<font></font>
       <span class="hljs-string"><span class="hljs-string">" "</span></span>   
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position mate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création de la base des bons mouvements commence par une recherche de toutes les combinaisons de mattes. </font><font style="vertical-align: inherit;">L'utilisation d'énumérateurs a permis de décrire assez efficacement ce processus.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Combo combo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllCheckmates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span><font></font>
    {<font></font>
        BlacksMove checkmate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlacksMove { combo = combo, moves = <span class="hljs-number"><span class="hljs-number">0</span></span> };<font></font>
        blackQueue.Enqueue(checkmate);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Total a trouvé 232 positions mates. </font><font style="vertical-align: inherit;">Permettez-moi de vous rappeler que nous nous sommes limités uniquement à un éléphant à fond blanc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains d'entre eux sont assez exotiques, inexistants et «coopératifs», c'est alors que le roi noir lui-même est monté sous le tapis. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/cb8/72f/c4e/cb872fc4e552449343b0bb9ad2e80303.png" alt="Mat.  Quelle a été la décision de White?"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les joueurs d'échecs savent très bien qu'un tapis avec un cheval et un éléphant à fond blanc doit être placé dans un coin blanc. </font><font style="vertical-align: inherit;">Dans le coin noir, échec et mat n'est possible que si le noir joue avec. </font><font style="vertical-align: inherit;">J'ai spécialement posté une photo avec un tel pseudo-automate au début de l'article afin de provoquer l'attention des vrais joueurs d'échecs :)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapis en un seul mouvement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'étape suivante consiste à inverser le blanc. </font><font style="vertical-align: inherit;">Autrement dit, pour chaque position mate trouvée, effectuez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tous les reculs blancs possibles</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment faire un mouvement inverse? </font><font style="vertical-align: inherit;">Étant donné qu'aucune capture n'est prévue dans nos positions, l'algorithme est assez simple - faites n'importe quel mouvement par les Blancs, après quoi il n'y aura pas de contrôle au roi noir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les positions trouvées de cette manière peuvent déjà être mises dans la «boîte blanche», indiquant qu'il y a un mouvement avant le tapis et quel type de mouvement pour ce faire. </font><font style="vertical-align: inherit;">En cours de route, nous mettons les combinaisons trouvées dans la «ligne noire». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble cette partie de l'algorithme:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (blackQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
        BlacksMove black = blackQueue.Dequeue();<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
            </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//     </span></span></span><span class="hljs-function">
            </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!isCheck(white.combo</span></span></span><span class="hljs-function">))
                </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//      " "</span></span></span><span class="hljs-function">
                </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!whiteBox.Exists(white.combo</span></span></span><span class="hljs-function">))</span></span><font></font>
                {<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteBox.Put (white);<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteQueue.Enqueue(white);<font></font>
                }<font></font>
    }<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, sur le rendement</font></font></b><div class="spoiler_text">   yield-      , ,         :<br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;WhitesMove&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlacksMove black</span></span></span><span class="hljs-function">)</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBishopMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKnightMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;<font></font>
        }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un total de 920 positions de ce type ont été trouvées, voici les plus intéressantes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mouvement cheval </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/a3c/5e9/e2a/a3c5e9e2a6de27f57d40720cf3caa044.png" alt="Knight 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/b30/477/955/b3047795519e369386b6d4c98582310f.png" alt="coup de chevalier 2"> <img src="https://habrastorage.org/getpro/geektimes/post_images/8aa/d2b/728/8aad2b72884640ec4fe9469efa89088d.png" alt="Chevalier 3"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: Mouvement éléphant: Mouvement </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af8/447/b26/af8447b26f2c45bd93595887f84f4a65.png" alt="éléphant se déplace 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/cdf/b7b/735/cdfb7b7359a3e69f93aa8b8b67651206.png" alt="éléphant se déplacent 2"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
roi:</font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/689/946/f2e/689946f2eb8e8d5eac9d0cc8d2a3834b.png" alt="déménagement du roi"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapis en un mouvement et demi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'étape suivante consiste à inverser le noir. Avec cet algorithme j'ai passé le plus de temps, beaucoup d'erreurs ont été commises avant que tout fonctionne correctement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À première vue, tout est similaire à la version précédente: pour chaque position de la «ligne blanche» il faut trier tous les mouvements possibles du roi noir. Et ajoutez toutes les combinaisons trouvées à la «ligne noire» - après tout, c'est un échec et mat en un mouvement et demi, à partir duquel vous pouvez ensuite effectuer à nouveau un mouvement inverse pour les Blancs - il y aura un échec et mat en deux mouvements - et continuer jusqu'à ce que toutes les options soient révisées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'était l'erreur. Avec n'importe quel mouvement possible, Black obtient un échec et mat matelassé «coopératif» en un mouvement et demi, mais en réalité le roi ne passera pas nécessairement sous l'échec et mat. Dmitry Grin m'a signalé cette erreur, qui a assisté à tous mes webinaires sur la création de ce programme, pour lesquels je le remercie séparément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme correct est le suivant: pour chaque position N après le mouvement inverse du roi noir, vous devez passer par tous les mouvements directs possibles de celui-ci pour vous assurer qu'ils mènent tous à des positions familières à partir de la "boîte blanche", c'est-à-dire conduire au tapis. Et seulement après cette position, N peut être ajouté à la «ligne noire». Et si le roi noir peut «s'échapper» de la position N, alors nous sautons cette option. Elle se réunira lors des itérations suivantes, lorsqu'il y aura des postes plus familiers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble cette partie de l'algorithme:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (whiteQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N  " "</span></span><font></font>
        WhitesMove white = whiteQueue.Dequeue();<font></font>
        Combo whiteFigures = white.combo;<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N      </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">BlacksMove black </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBlackBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">white</span></span></span><span class="hljs-function">))</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> solved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;
            <span class="hljs-comment"><span class="hljs-comment">//      </span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Coord blackKing </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black.combo.blackKing</span></span></span><span class="hljs-function">))</span></span><font></font>
            {<font></font>
                whiteFigures.blackKing = blackKing; <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCheck(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (box.Exists(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;<font></font>
                solved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ""</span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;<font></font>
            }<font></font>
            <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
            <span class="hljs-comment"><span class="hljs-comment">//     " "</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solved)
                <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                blackQueue.Enqueue(black);<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au total, 156 combinaisons de «mouvements mat et demi» ont été trouvées.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À mi-parcours itératif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les algorithmes décrits pour créer des demi-passes doivent être bouclés. </font><font style="vertical-align: inherit;">À partir de la «ligne noire», nous formons la «ligne blanche», et vice versa - à partir de la ligne «blanche», nous formons la «ligne noire». </font><font style="vertical-align: inherit;">Et ainsi de suite jusqu'à épuisement de toutes les nouvelles positions. </font><font style="vertical-align: inherit;">La «boîte blanche» est remplie au stade de la formation de la «ligne blanche», car elle place les positions dans lesquelles les blancs se déplacent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme prêt à l'emploi pour l'énumération de toutes les options a fonctionné quelque part en 12 minutes et s'est arrêté au mouvement 33. </font><font style="vertical-align: inherit;">C'est le nombre de mouvements maximum nécessaires pour accoupler le roi noir avec un cheval et un éléphant de n'importe quelle position. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, il n'y avait pas tellement de postes «les plus difficiles», seulement 156, en voici un:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af4/481/e7c/af4481e7cfe9f5d9e5787d4f287238f6.png" alt="Tapis en 33 mouvements"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mata ne le sera pas!</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe de nombreuses positions dans lesquelles, même après le mouvement des Blancs, le roi noir peut manger un chevalier ou un évêque et obtenir un match nul. </font><font style="vertical-align: inherit;">Il existe également des options de blocage. </font><font style="vertical-align: inherit;">Voici quelques-uns des articles les plus intéressants.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/b87/90d/11f/b8790d11ff993e53cb6620167448e7fb.png" alt="Pas de compagnon"> <img src="https://habrastorage.org/getpro/geektimes/post_images/885/786/cad/885786cad2d99e49c3d176a83217bda4.png" alt="Pas de compagnon"><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/09c/f2c/cf2/09cf2ccf2d1855e834a1e2e38e0205e2.png" alt="Pas de compagnon"> <img src="https://habrastorage.org/getpro/geektimes/post_images/6ef/659/f74/6ef659f744134d6e4c993c56dd71a213.png" alt="Pas de compagnon"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment stocker une base de données de solution</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment stocker la base de solutions trouvée? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La manière la plus simple et la plus fausse est d'utiliser la sérialisation. Le tableau en quatre dimensions sérialisé de la structure a pris 1,7 gigaoctets (!) D'espace disque. Le processus de sérialisation a duré environ six minutes, la désérialisation a pris environ la même chose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette option, bien sûr, ne convient pas. De plus, en pratique, il n'est pas nécessaire d'utiliser la totalité du réseau à quatre dimensions. Une seule entrée est nécessaire pour un élément de campagne spécifique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eureka! Pour économiser de l'espace, vous pouvez toujours vous débarrasser du stockage des coordonnées des chiffres pour chaque combinaison. Lorsque nous avons un tableau à quatre dimensions, la position de chaque figure sur la carte est uniquement déterminée par son indice dans le tableau.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a été décidé de stocker l'intégralité de la base de données de solutions dans un seul fichier - sous la forme d'un balayage linéaire d'un tableau à quatre dimensions. Pour toute position possible, l'adresse est calculée à laquelle la bonne réponse est enregistrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment enregistrer la réponse dont nous avons besoin de manière aussi compacte que possible? La position des figures n'a pas besoin d'être stockée, il ne reste donc que trois chiffres - combien de mouvements vers le tapis, quoi aller et où aller. C'est ainsi que la bonne décision pour les Blancs est déterminée de manière unique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 bits Le nombre de déplacements vers le tapis est un entier de 0 à 33,2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bits. Quelle figure marche - trois options possibles, un roi, un éléphant ou un cheval. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 bits Où va la pièce - l'indice du champ sur la carte est de 0 à 63. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, pour chaque enregistrement de décision, deux octets suffisent: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 octet - combien de mouvements vers le tapis, ou 0 si la position n'est pas familière. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 octets - FFNNNNNN</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FF - numéro de la figure à marcher (1 - roi, 2 - éléphant, 3 - cheval) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NNNNNN - coordonnée cellulaire - où aller (de 0 à 63). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le fichier de base de données de solution prend 64 * 32 * 64 * 64 mots = exactement 16 mégaoctets. </font><font style="vertical-align: inherit;">La position des chiffres est définie par les coordonnées de chaque mot, dans le premier octet - le nombre de mouvements vers le tapis (ou 0 s'il n'y a pas de solution), le deuxième mouvement stocke le mouvement correct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il serait possible de réduire la taille du fichier de moitié si vous ne stockiez pas le nombre de coups sur le tapis, mais ce ne serait pas intéressant de jouer comme ça.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonnées de l'éléphant blanc au carré noir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de payer pour l'optimisation. </font><font style="vertical-align: inherit;">Il est nécessaire de mettre en œuvre un algorithme de recalcul des coordonnées pour les combinaisons avec un éléphant «noir et blanc». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela a été fait comme suit. </font><font style="vertical-align: inherit;">Si les coordonnées de l'éléphant tombent sur un champ noir, alors les coordonnées de toutes les figures du tableau doivent être "inversées". </font><font style="vertical-align: inherit;">Dans ce cas, la coordonnée Y reste inchangée et X passe à 7-X. </font><font style="vertical-align: inherit;">Une démonstration visuelle d'un retournement de coordonnées, voir la figure. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/1cb/019/1f7/1cb0191f7642a5b963437278ed9ca783.png" alt="Renversement de coordonnées"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'éléphant est debout sur une cage blanche, vous devez d'abord "inverser" les coordonnées de toutes les figures. </font><font style="vertical-align: inherit;">Recherchez ensuite une position dans la base de données des solutions. </font><font style="vertical-align: inherit;">Et encore une fois «retournez» la coordonnée du mouvement correct lu à partir de là.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisation de la base de solution</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, le problème est résolu! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La base de données des solutions a été créée. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment le démontrer? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La façon la plus évidente est d'utiliser les technologies Web pour pouvoir simplement donner un lien vers un exemple de travail. Sur ma "formule de programmeur", le cours photo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nano-Chess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">a déjà été créé </font><font style="vertical-align: inherit;">, où en utilisant les technologies HTML, CSS, JavaScript et PHP un échiquier interactif a été créé pour jouer sans règles à deux. Ce script a été pris comme base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai laissé que quatre morceaux, supprimé la possibilité de capture, ajouté des fonctions PHP pour lire les mouvements corrects de la base de la solution et «respiré la vie» via JavaScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la page </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.videosharp.info/chess,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous pouvez expérimenter avec la base de données de solutions.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/9fb/3ce/7bc/9fb3ce7bc6645d2c96536c2a19c663a2.png" alt="Tapis interactif avec cheval et éléphant"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour chaque position, les déplacements sont calculés pour le blanc et le noir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les blancs - le meilleur coup qui mène à l'échec et mat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le noir - combien de mouvements vers le tapis pour tout mouvement possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez faire n'importe quel mouvement des figures avec la souris, pas nécessairement selon les règles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le script calculera l'option pour n'importe quelle position, ou notera qu'il n'y a pas d'options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est intéressant de jouer, d'effectuer les mouvements proposés ou de déplacer les pièces à votre discrétion.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un excellent travail intéressant a été fait pour résoudre le problème des échecs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez répéter de cette façon, vous pouvez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regarder des vidéos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la création de ce programme de zéro au résultat avec des explications détaillées et des tâches indépendantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonne chance!</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr396453/">https://habr.com/ru/post/fr396453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr396441/index.html">L'Italie pourrait perdre ses oliviers en raison de la méfiance des scientifiques</a></li>
<li><a href="../fr396443/index.html">"Les sages de Sion" sont devenus une autre raison de bloquer Wikipédia</a></li>
<li><a href="../fr396445/index.html">Клоны овечки Долли помогают доказывать безопасность SCNT-клонирования</a></li>
<li><a href="../fr396447/index.html">Prix ​​de l'électronique populaire du passé en argent d'aujourd'hui: les années 1970</a></li>
<li><a href="../fr396451/index.html">Crimes et châtiments du mois dernier</a></li>
<li><a href="../fr396455/index.html">Matériel informatique des pays du CAEM. Deuxième partie: Tchécoslovaquie</a></li>
<li><a href="../fr396457/index.html">APEIGAMING en chiffres. Un mois après le début (vidéo)</a></li>
<li><a href="../fr396459/index.html">Examen de l'unité de système de jeu ASUS ROG GT51CA</a></li>
<li><a href="../fr396461/index.html">Technologies de sécurité Blockchain</a></li>
<li><a href="../fr396467/index.html">Есть ли у тёмной материи практическое применение?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>