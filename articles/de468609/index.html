<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöå üôé ‚úîÔ∏è Die unverst√§ndliche Leistung der Mehrfachplanung üòÖ ü§ì ‚öôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Zwischensequenz wird eine Entschl√ºsselung des Berichts von Stefan Karpinsky, einem der wichtigsten Entwickler der Julia-Sprache, vorgeschlagen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die unverst√§ndliche Leistung der Mehrfachplanung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468609/"><p>  In der Zwischensequenz wird eine Entschl√ºsselung des Berichts von Stefan Karpinsky, einem der wichtigsten Entwickler der Julia-Sprache, vorgeschlagen.  In dem Bericht er√∂rtert er die unerwarteten Ergebnisse des bequemen und effizienten Mehrfachversands, der als Hauptparadigma f√ºr Julia angesehen wird. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Von einem √úbersetzer</em> : Der Titel des Berichts bezieht sich auf einen Artikel von Eugene Wigner, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die unverst√§ndliche Wirksamkeit der Mathematik in den Naturwissenschaften".</a> </p><br><p> Multiple Dispatch - ein Schl√ºsselparadigma Julia Sprache, und w√§hrend seiner Existenz, wir haben die Entwickler der Sprache, beachteten etwas erwartet, aber zugleich r√§tselhaft.  Zumindest haben wir das nicht in dem Ma√üe erwartet, wie wir es gesehen haben.  Dies ist etwas - eine erstaunliche Stufe der Wiederverwendung von Code im Julia-√ñkosystem, die viel h√∂her ist als in jeder anderen Sprache, die ich kenne. </p><br><p>  Wir sehen st√§ndig, dass einige Leute verallgemeinerten Code schreiben, jemand anderes einen neuen Datentyp definiert, diese Leute nicht miteinander vertraut sind und dann jemand diesen Code auf diesen ungew√∂hnlichen Datentyp anwendet ... Und alles funktioniert einfach.  Und das passiert <em>√ºberraschend oft</em> . <br>  Ich habe immer gedacht, dass ein solches Verhalten von objektorientierter Programmierung erwartet werden sollte, aber ich habe viele objektorientierte Sprachen verwendet, und es stellt sich heraus, dass normalerweise einfach nicht alles in ihnen funktioniert.  Deshalb dachte ich irgendwann: Warum ist Julia in dieser Hinsicht eine so effektive Sprache?  Warum ist der Code-Wiederverwendungsgrad dort so hoch?  Und auch - welche Lehren k√∂nnen daraus gezogen werden, die andere Sprachen von Julia ausleihen k√∂nnten, um besser zu werden? </p><br><p>  Manchmal, wenn ich sage, dass die √ñffentlichkeit mich nicht glauben, aber man muss JuliaCon, so dass Sie wissen, was geschieht, so dass ich auf, warum konzentrieren werde, meiner Meinung nach, dies geschieht. </p><br><p>  Aber f√ºr den Anfang - eines meiner Lieblingsbeispiele. </p><br><p><img src="https://habrastorage.org/webt/mv/o0/i8/mvo0i8xjflhnxxuurnshmsfolbi.png"></p><br><p> Auf der Folie ist das Ergebnis der Arbeit von Chris Rakaukas.  Er schreibt alle m√∂glichen <em>sehr verallgemeinerten</em> Pakete zur L√∂sung von Differentialgleichungen.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Zahlen</a> oder BigFloat f√ºttern, was immer Sie wollen.  Und irgendwie hat er beschlossen, dass er den Fehler des Integrationsergebnisses sehen will.  Und es gab ein Messpaket, das sowohl den Wert einer physikalischen Gr√∂√üe als auch die Ausbreitung eines Fehlers durch eine Folge von Formeln verfolgen kann.  Dieses Paket unterst√ºtzt auch die elegante Syntax f√ºr Unsicherheitswerte mit dem Unicode-Zeichen <code>¬±</code> .  Hier auf dem Objekttr√§ger wird gezeigt, dass die Erdbeschleunigung, die L√§nge des Pendels, die Anfangsgeschwindigkeit und der Abweichungswinkel alle mit einer Art Fehler bekannt sind.  Sie definieren also ein einfaches Pendel, f√ºhren seine Bewegungsgleichungen durch den L√∂ser ODE und - <strong>bam!</strong>  - <em>Alles funktioniert</em> .  Und Sie sehen eine Grafik mit Schnurrbart-Ungenauigkeiten.  Und ich zeige noch nicht den Code Grafiken zum Zeichnen - zu allgemein und Sie nur mit einem Fehler von Measurements.jl auf den Wert starten und eine Grafik mit den Fehlern bekommen. </p><br><p>  Der Grad der Kompatibilit√§t verschiedener Pakete und die Verallgemeinerung des Codes sind einfach hirnhaltig.  <em>Wie funktioniert es <strong>einfach</strong> ?</em>  Es stellt sich ja heraus. </p><br><p>  Nun, nicht, dass wir das <em>√ºberhaupt</em> nicht erwartet h√§tten.  Schlie√ülich haben wir das Konzept des Mehrfachversands <em>genau</em> deshalb in die Sprache aufgenommen <em>,</em> weil es uns erm√∂glicht, verallgemeinerte Algorithmen auszudr√ºcken.  Das alles ist also nicht so verr√ºckt.  Aber es ist eine Sache, dies theoretisch zu wissen und eine andere, in der Praxis zu sehen, dass der Ansatz wirklich funktioniert.  Schlie√ülich sollten auch Single Dispatching und Operator Overloading in C ++ zu einem √§hnlichen Ergebnis f√ºhren - aber in Wirklichkeit funktionieren sie oft nicht so, wie sie es m√∂chten. </p><br><p>  Dar√ºber hinaus erleben wir etwas mehr als wir bei der Entwicklung der Sprache vorausgesehen hatten: Es wird nicht nur verallgemeinerter Code geschrieben.  Als n√§chstes werde ich versuchen zu sagen, was meiner Meinung nach mehr ist. </p><br><p>  So gibt es zwei Arten von Wiederverwendung von Code, und sie sind ganz anders.  Einer ist verallgemeinerte Algorithmen, und dies ist das erste, woran sie sich erinnern.  Der zweite, weniger offensichtliche, aber wichtigere Aspekt scheint die Einfachheit zu sein, mit der Julia dieselben Datentypen in einer Vielzahl von Paketen verwendet.  In gewissem Ma√üe geschieht dies, weil Typmethoden kein Hindernis f√ºr ihre Verwendung darstellen: Sie m√ºssen sich nicht mit dem Typautor √ºber die von ihm geerbten Schnittstellen und Methoden einig sein.  Sie k√∂nnen einfach sagen: ‚ÄûOh, ich wie dieser RGB Art von Operationen darauf, den ich mit ihren eigenen kommen, aber die Struktur ist mir angenehm.‚Äú. </p><br><h3 id="predislovie-mnozhestvennaya-dispetcherizaciya-protiv-peregruzki-funkciy">  Vorwort  Mehrfachplanung versus Funktions√ºberlastung </h3><br><p>  Jetzt muss ich die Funktions√ºberladung in C ++ oder Java erw√§hnen, da mir st√§ndig Fragen dazu gestellt werden.  Auf den ersten Blick unterscheidet es sich nicht von der Mehrfachplanung.  Was ist der Unterschied und warum ist die Funktions√ºberlastung schlimmer? </p><br><p>  Ich beginne mit einem Beispiel f√ºr Julia: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> Pet <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dog &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Cat &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encounter(a::Pet, b::Pet) verb = meets(a, b) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(a.name)</span></span></span><span class="hljs-string"> meets </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(b.name)</span></span></span><span class="hljs-string"> and </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$verb</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> meets(a::Dog, b::Dog) = <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span> meets(a::Dog, b::Cat) = <span class="hljs-string"><span class="hljs-string">"chases"</span></span> meets(a::Cat, b::Dog) = <span class="hljs-string"><span class="hljs-string">"hisses"</span></span> meets(a::Cat, b::Cat) = <span class="hljs-string"><span class="hljs-string">"slinks"</span></span></code> :: Pet) <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> Pet <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dog &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Cat &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encounter(a::Pet, b::Pet) verb = meets(a, b) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(a.name)</span></span></span><span class="hljs-string"> meets </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(b.name)</span></span></span><span class="hljs-string"> and </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$verb</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> meets(a::Dog, b::Dog) = <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span> meets(a::Dog, b::Cat) = <span class="hljs-string"><span class="hljs-string">"chases"</span></span> meets(a::Cat, b::Dog) = <span class="hljs-string"><span class="hljs-string">"hisses"</span></span> meets(a::Cat, b::Cat) = <span class="hljs-string"><span class="hljs-string">"slinks"</span></span></code> </pre> <br><p>  Wir definieren den abstrakten Typ von <code>Pet</code> , f√ºhren die Untertypen von <code>Dog</code> und <code>Cat</code> , sie haben ein Namensfeld (der Code wiederholt sich ein wenig, ist aber tolerierbar) und definieren eine verallgemeinerte Funktion des "Treffens", die zwei Objekte vom Typ <code>Pet</code> Argumenten akzeptiert.  Darin berechnen wir zuerst die ‚ÄûAktion‚Äú, die durch das Ergebnis des Aufrufs der generalisierten Funktion <code>meet()</code> wird, und drucken dann den Satz aus, der die Besprechung beschreibt.  Die Funktion <code>meets()</code> , wir mehrere Versand verwenden , um die Aktion zu bestimmen , die ein Tier bei einem Treffen mit dem anderen macht. </p><br><p>  F√ºgen Sie ein paar Hunde und ein paar Katzen hinzu und sehen Sie sich die Ergebnisse des Treffens an: </p><br><pre> <code class="julia hljs">fido = Dog(<span class="hljs-string"><span class="hljs-string">"Fido"</span></span>) rex = Dog(<span class="hljs-string"><span class="hljs-string">"Rex"</span></span>) whiskers = Cat(<span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>) spots = Cat(<span class="hljs-string"><span class="hljs-string">"Spots"</span></span>) encounter(fido, rex) encounter(rex, whiskers) encounter(spots, fido) encounter(whiskers, spots)</code> </pre> <br><p>  Jetzt werden wir dasselbe so w√∂rtlich wie m√∂glich in C ++ "√ºbersetzen".  Definieren Sie die <code>Pet</code> Klasse mit dem Namensfeld - in C ++ k√∂nnen wir dies tun (einer der Vorteile von C ++ besteht √ºbrigens darin, dass Datenfelder sogar zu abstrakten Typen hinzugef√ºgt werden k√∂nnen. Dann definieren wir die Funktion base <code>meets()</code> , definieren die Funktion <code>meets()</code> f√ºr zwei Objekte vom Typ <code>Pet</code> und, Definieren Sie abschlie√üend die abgeleiteten Klassen <code>Dog</code> und <code>Cat</code> und f√ºhren Sie f√ºr sie √úberlastungs- <code>meets()</code> durch: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; }; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FALLBACK"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> verb = meets(a, b); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a.name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" meets "</span></span> &lt;&lt; b. name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and "</span></span> &lt;&lt; verb &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"chases"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hisses"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"slinks"</span></span>; }</code> </pre> <br><p>  Die Funktion <code>main()</code> , wie in dem Code zu Julia, der Schaffung Hunde und Katzen und macht sie zu treffen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dog fido; fido.name = <span class="hljs-string"><span class="hljs-string">"Fido"</span></span>; Dog rex; rex.name = <span class="hljs-string"><span class="hljs-string">"Rex"</span></span>; Cat whiskers; whiskers.name = <span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>; Cat spots; spots.name = <span class="hljs-string"><span class="hljs-string">"Spots"</span></span>; encounter(fido, rex); encounter(rex, whiskers); encounter(spots, fido); encounter(whiskers, spots); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Also Mehrfachversand gegen Funktions√ºberlastung.  Gong! </p><br><p><img src="https://habrastorage.org/webt/sj/6u/ob/sj6uobzsl8adbgqxjlxuibpcnpc.png"></p><br><p>  Was wird Ihrer Meinung nach den Code mit Mehrfachversand zur√ºckgeben? </p><br><div class="spoiler">  <b class="spoiler_title">$ Julia Haustiere.jl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and sniffs Rex meets Whiskers and chases Spots meets Fido and hisses Whiskers meets Spots and slinks</code> </pre> <br><p>  Die Tiere treffen sich, schn√ºffeln, zischen und spielen Aufholjagd - wie beabsichtigt. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">$ g ++ -o Haustiere Haustiere.cpp &amp;&amp; ./ Haustiere</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and FALLBACK Rex meets Whiskers and FALLBACK Spots meets Fido and FALLBACK Whiskers meets Spots and FALLBACK</code> </pre> <br><p>  In allen F√§llen wird die Option "Fallback" zur√ºckgegeben. </p><br><p>  Warum?  Denn so funktioniert Funktions√ºberladung.  Wenn mehrere Dispatchings funktionieren w√ºrden, w√ºrden <code>meets(a, b)</code> innerhalb von <code>encounter()</code> mit den spezifischen Typen aufgerufen, die <code>a</code> und <code>b</code> zum Zeitpunkt des Anrufs hatten.  Da jedoch eine √úberladung angewendet wird, wird <code>meets()</code> f√ºr die <em>statischen</em> Typen <code>a</code> und <code>b</code> aufgerufen, die in diesem Fall beide <code>Pet</code> . </p></div></div><br><p>  Beim C ++ - Ansatz ergibt die direkte "√úbersetzung" von generischem Julia-Code nicht das gew√ºnschte Verhalten, da der Compiler Typen verwendet, die in der Kompilierungsphase statisch abgeleitet werden.  Und der springende Punkt ist, dass wir eine Funktion auf der Grundlage des tats√§chlichen konkreten Typs nennen wollen, dass die Variablen in der Runtime sind.  Obwohl Vorlagenfunktionen die Situation etwas verbessern, erfordern sie zum Zeitpunkt der Kompilierung statische Kenntnisse aller im Ausdruck enthaltenen Typen, und es ist einfach, ein Beispiel zu finden, bei dem dies unm√∂glich w√§re. </p><br><p>  F√ºr mich zeigen solche Beispiele, dass Mehrfachversand das Richtige tut, und alle anderen Ans√§tze sind einfach keine sehr gute Ann√§herung an das richtige Ergebnis. </p><br><p>  Nun sehen wir uns eine solche Tabelle an.  Ich hoffe, Sie finden es sinnvoll: </p><br><div class="scrollable-table"><table><thead><tr><th>  Planungsart </th><th>  Syntax </th><th>  Versandargumente </th><th>  Grad der Ausdruckskraft </th><th>  Ausdrucksstarke Gelegenheit </th></tr></thead><tbody><tr><td>  Nein </td><td>  f (x <sub>1,</sub> x <sub>2,</sub> ...) </td><td>  {} </td><td>  O (1) </td><td>  konstant </td></tr><tr><td>  einsam </td><td>  x <sub>1</sub> .F (x <sub>2,</sub> ...) </td><td>  {X <sub>1}</sub> </td><td>  O (| X <sub>1</sub> |) </td><td>  linear </td></tr><tr><td>  mehrfach </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {X <sub>1,</sub> x <sub>2,</sub> ...} </td><td>  O (| X <sub>1</sub> | | X <sub>2</sub> | ...) </td><td>  exponentiell </td></tr></tbody></table></div><br><p>  In Sprachen ohne Versand schreiben Sie einfach <code>f(x, y, ...)</code> , die Typen aller Argumente sind festgelegt, d. H.  Ein Aufruf von <code>f()</code> ist ein Aufruf einer einzelnen Funktion <code>f()</code> , die sich im Programm befinden kann.  Der Grad der Ausdruckskraft ist konstant: Der Aufruf von <code>f()</code> immer nur eine Sache.  Der Einzelversand war ein wichtiger Durchbruch beim √úbergang zu OOP in den 1990er und 2000er Jahren.  Normalerweise wird die Punktsyntax verwendet, die die Leute wirklich m√∂gen.  Und es erscheint eine zus√§tzliche Ausdrucksm√∂glichkeit: Der Anruf wird entsprechend dem Objekttyp x <sub>1</sub> abgesetzt.  Eine Ausdrucksm√∂glichkeit ist durch die Kraft der Menge | X <sub>1</sub> | gekennzeichnet  Typen mit der Methode <code>f()</code> .  In der gleichen Scheduling mehrere Anzahl potentieller Ausf√ºhrungsform f√ºr die Funktion <code>f()</code> ist gleich die Leistung des kartesischen Produkts von S√§tzen Typen , auf die Argumente geh√∂ren.  In der Realit√§t braucht nat√ºrlich kaum jemand so viele verschiedene Funktionen in einem Programm.  Der entscheidende Punkt hierbei ist jedoch, dass der Programmierer eine einfache und nat√ºrliche M√∂glichkeit erh√§lt, jedes Element dieser Art zu verwenden, was zu einem exponentiellen Wachstum der M√∂glichkeiten f√ºhrt. </p><br><h3 id="chast-1-obobschyonnoe-programmirovanie">  Teil 1. Allgemeine Programmierung </h3><br><p>  Lassen Sie uns √ºber verallgemeinerten Code sprechen - das Hauptmerkmal des Mehrfachversands. </p><br><p>  Hier ist ein (v√∂llig k√ºnstliches) Beispiel f√ºr generischen Code: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LinearAlgebra <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> inner_sum(A, vs) t = zero(eltype(A)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vs t += inner(v, A, v) <span class="hljs-comment"><span class="hljs-comment">#  ! end return t end inner(v, A, w) = dot(v, A * w) #   </span></span></code> </pre> <br><p>  Hier ist <code>A</code> etwas Matrixartiges (obwohl ich die Typen nicht angegeben habe und ich kann etwas anhand des Namens erraten), <code>vs</code> ist der Vektor einiger vektor√§hnlicher Elemente, und dann wird das Skalarprodukt durch diese "Matrix" betrachtet. f√ºr die eine verallgemeinerte Definition ohne Angabe von Typen angegeben wird.  Die verallgemeinerte Programmierung besteht hier in diesem Aufruf der Funktion <code>inner()</code> in einer Schleife (professioneller Rat: Wenn Sie verallgemeinerten Code schreiben m√∂chten, entfernen Sie einfach alle Typbeschr√§nkungen). </p><br><p>  Also, "schau, Mama, es funktioniert": </p><br><pre> <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>√ó<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> - <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>√ó<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> , <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>√ó<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> </pre> <br><p>  Nichts Besonderes, es berechnet einen Wert.  <em>Aber</em> - der Code ist in einem verallgemeinerten Stil geschrieben und funktioniert f√ºr jedes <code>A</code> und <code>vs</code> , wenn es nur m√∂glich w√§re, die entsprechenden Operationen an ihnen auszuf√ºhren. </p><br><p>  Was die Effizienz bei bestimmten Datentypen betrifft - wie viel Gl√ºck.  Ich meine, dass dieser Code f√ºr dichte Vektoren und Matrizen "so macht, wie er sollte" - er erzeugt Maschinencode mit Aufruf von BLAS-Operationen usw.  usw.  Wenn Sie statische Arrays √ºbergeben, ber√ºcksichtigt der Compiler dies, erweitert die Zyklen und wendet die Vektorisierung an - alles ist so, wie es sollte. </p><br><p>  Aber was noch wichtiger ist, der Code funktioniert f√ºr neue Typen, und Sie k√∂nnen ihn nicht nur super effizient, sondern auch super effizient machen!  Definieren wir einen neuen Typ (dies ist der reale Datentyp, der beim maschinellen Lernen verwendet wird), einen einheitlichen Vektor (One-Hot-Vektor).  Dies ist ein Vektor, in dem eine der Komponenten 1 ist und alle anderen Null sind.  Sie k√∂nnen es sich sehr kompakt vorstellen: Alles, was gespeichert werden muss, ist die L√§nge des Vektors und die Nummer der Nicht-Null-Komponente. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base: size, getindex, * <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OneHotVector &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractVector</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>} len :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ind :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> size(v::OneHotVector) = (v.len,) getindex(v::OneHotVector, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(i == v.ind)</code> </pre> <br><p>  Tats√§chlich ist dies die gesamte Typdefinition aus dem Paket, das sie hinzuf√ºgt.  Und mit dieser Definition <code>inner_sum()</code> auch: </p><br><pre> <code class="julia hljs">julia&gt; vs = [OneHotVector(<span class="hljs-number"><span class="hljs-number">3</span></span>, rand(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{OneHotVector,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">2.6493739294755123</span></span></code> </pre> <br><p>  F√ºr ein skalares Produkt wird hier jedoch eine allgemeine Definition verwendet - f√ºr diese Art von Daten ist es langsam, nicht cool! </p><br><p>  Allgemeine Definitionen funktionieren also, aber nicht immer optimal, und bei der Verwendung von Julia kann dies gelegentlich auftreten: "Nun, eine allgemeine Definition wird aufgerufen, deshalb funktioniert dieser GPU-Code seit der f√ºnften Stunde ..." </p><br><p>  In <code>inner()</code> wird standardm√§√üig die allgemeine Definition des Matrixprodukts durch einen Vektor aufgerufen, die bei Multiplikation mit einem einheitlichen Vektor eine Kopie einer der Spalten vom Typ <code>Vector{Float64}</code> .  Dann rief er eine allgemeine Definition des Skalarprodukts <code>dot()</code> mit einem einheitlichen Vektor und dieser Spalte, die eine Menge unn√∂tiger Arbeit macht.  Tats√§chlich wird f√ºr jede Komponente gepr√ºft: "Sind Sie gleich eins? Und Sie?"  usw. </p><br><p>  Wir k√∂nnen dieses Verfahren stark optimieren.  Ersetzen Sie beispielsweise die Matrixmultiplikation durch <code>OneHotVector</code> , indem <code>OneHotVector</code> einfach eine Spalte ausw√§hlen.  Gut, definieren Sie diese Methode und fertig. </p><br><pre> <code class="julia hljs">*(A::<span class="hljs-built_in"><span class="hljs-built_in">AbstractMatrix</span></span>, v::OneHotVector) = A[:, v.ind]</code> </pre> <br><p>  Und hier ist es, <strong>Macht</strong> : Wir sagen "wir wollen <em>auf das zweite Argument loslegen</em> ", egal was im ersten ist.  Eine solche Definition zieht einfach die Zeile aus der Matrix und ist viel schneller als die allgemeine Methode - Iteration und Summierung √ºber Spalten werden entfernt. </p><br><p>  Sie k√∂nnen jedoch noch weiter gehen und <code>inner()</code> direkt optimieren, da durch Multiplizieren zweier einheitlicher Vektoren durch eine Matrix einfach ein Element dieser Matrix herausgezogen wird: </p><br><pre> <code class="julia hljs">inner(v::OneHotVector, A, w::OneHotVector) = A[v.ind, w.ind]</code> </pre> <br><p>  Das ist die versprochene Super-Duper-Effizienz.  Und alles, was ben√∂tigt wird, ist diese <code>inner()</code> Methode zu definieren. </p><br><p>  Dieses Beispiel zeigt eine der Anwendungen der Mehrfachplanung: Es gibt eine allgemeine Definition einer Funktion, die jedoch f√ºr einige Datentypen nicht optimal funktioniert.  Und dann f√ºgen wir punktuell eine Methode hinzu, die das Funktionsverhalten f√ºr diese Typen beibeh√§lt, aber viel <em>effizienter arbeitet</em> . </p><br><p>  Aber es gibt noch einen anderen Bereich - wenn es keine allgemeine Definition einer Funktion gibt, ich aber f√ºr einige Typen Funktionen hinzuf√ºgen m√∂chte.  Dann k√∂nnen Sie es mit minimalem Aufwand hinzuf√ºgen. </p><br><p>  Und die dritte Option - Sie m√∂chten nur den gleichen Funktionsnamen, aber mit unterschiedlichem Verhalten f√ºr verschiedene Datentypen -, zum Beispiel, damit sich eine Funktion beim Arbeiten mit W√∂rterb√ºchern und Arrays unterschiedlich verh√§lt. </p><br><p>  Wie kann man ein √§hnliches Verhalten in einzelnen Versandsprachen erzielen?  Es ist m√∂glich, aber schwierig.  Problem: Beim √úberladen der Funktion <code>*</code> das zweite Argument und nicht das erste Argument ausgel√∂st werden.  Sie k√∂nnen eine Doppel - Ausgabe machen: zuerst dispetcherizuem das erste Argument und rufen Sie die Methode <code>AbstractMatrix.*(v)</code> .  Und diese Methode ruft wiederum so etwas wie <code>v.__rmul__(A)</code> , d.h.  Das zweite Argument im urspr√ºnglichen Aufruf ist nun das Objekt geworden, dessen Methode tats√§chlich aufgerufen wird.  <code>__rmul__</code> hier wird aus dem Python genommen, wo ein solches Verhalten - ein Standardmuster, aber es funktioniert, wie es scheint, nur f√ºr die Addition und Multiplikation.  Das hei√üt,  Das Problem des doppelten Versands ist gel√∂st, wenn wir eine Funktion namens <code>+</code> oder <code>*</code> aufrufen m√∂chten, andernfalls leider nicht unseren Tag.  In C ++ und anderen Sprachen m√ºssen Sie Ihr Fahrrad bauen. </p><br><p>  OK, was ist mit <code>inner()</code> ?  Jetzt gibt es drei Argumente, und der Versand erfolgt √ºber das erste und dritte.  Was in Sprachen mit Einzelversand zu tun ist, ist nicht klar.  ‚ÄûTriple Scheduling‚Äú Ich lebe noch nie getroffen.  Es gibt keine guten L√∂sungen.  Wenn ein √§hnlicher Bedarf auftritt (und in numerischen Codes sehr h√§ufig vorkommt), implementieren die Benutzer normalerweise ihr Mehrfachversandsystem.  Wenn Sie sich gro√üe Projekte f√ºr numerische Berechnungen in Python ansehen, werden Sie erstaunt sein, wie viele davon in diese Richtung gehen.  Nat√ºrlich funktionieren solche Implementierungen situativ, schlecht designt, voller Fehler und langsam ( <em>Verweis auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Greenspans zehnte Regel</a> - ca. √ºbersetzt</em> ), da Jeff Besancon an keinem dieser Projekte gearbeitet hat (der <em>Autor und Hauptentwickler des Typversandsystems in Julia - ca.. Perevi.).</em> </p><br><h3 id="chast-2-obschie-tipy">  Teil 2. Allgemeine Typen </h3><br><p>  Ich werde auf die Kehrseite des Julia-Paradigmas eingehen - die allgemeinen Typen.  Dies ist meiner Meinung nach das wichtigste "Arbeitstier" der Sprache, da ich in diesem Bereich einen hohen Grad an Wiederverwendung von Code beobachte. </p><br><p>  Angenommen, Sie eine Art von RGB haben, wie dieser in ColorTypes.jl verf√ºgbar.  Es ist nichts Kompliziertes daran, nur drei Werte werden zusammengef√ºhrt.  Der Einfachheit halber nehmen wir an, dass der Typ nicht parametrisch ist (aber h√§tte sein k√∂nnen), und der Autor hat f√ºr ihn mehrere grundlegende Operationen definiert, die er f√ºr n√ºtzlich hielt.  Sie nehmen diesen Typ und denken: "Hmm, ich m√∂chte weitere Operationen f√ºr diesen Typ hinzuf√ºgen."  Stellen Sie sich beispielsweise RGB als einen Vektorraum vor (was streng genommen falsch ist, aber auf eine erste Ann√§herung hinausl√§uft).  In Julia nehmen Sie einfach alle fehlenden Operationen und f√ºgen sie in Ihren Code ein. </p><br><p>  Stellt sich die Frage - <em>und Cho?</em>  Warum konzentriere ich mich so sehr darauf?  Es stellt sich heraus, dass ein solcher Ansatz in objektorientierten Sprachen, die auf Klassen basieren, √ºberraschend schwierig zu implementieren ist.  Da sich die Methodendefinitionen in diesen Sprachen innerhalb der Klassendefinition befinden, gibt es nur zwei M√∂glichkeiten, eine Methode hinzuzuf√ºgen: Bearbeiten Sie entweder den Klassencode, um das gew√ºnschte Verhalten hinzuzuf√ºgen, oder erstellen Sie eine Vererbungsklasse mit den erforderlichen Methoden. </p><br><p>  Die erste Option erh√∂ht die Definition der Basisklasse und zwingt den Entwickler der Basisklasse, sich beim √Ñndern des Codes um die Unterst√ºtzung aller hinzugef√ºgten Methoden zu k√ºmmern.  Was k√∂nnte eines Tages dazu f√ºhren, dass eine solche Klasse nicht mehr unterst√ºtzt wird? </p><br><p>  Vererbung ist eine klassische ‚Äûempfohlene‚Äú Option, aber auch nicht ohne M√§ngel.  Zuerst m√ºssen Sie den Klassennamen √§ndern - lassen Sie es jetzt nicht <code>RGB</code> , sondern <code>MyRGB</code> .  Dar√ºber hinaus funktionieren neue Methoden f√ºr die urspr√ºngliche <code>RGB</code> Klasse nicht mehr.  Wenn ich meine neue Methode auf ein <code>RGB</code> Objekt anwenden m√∂chte, das im Code einer anderen Person erstellt wurde, muss ich es konvertieren oder in <code>MyRGB</code> .  Aber das ist nicht das Schlimmste.  Wenn ich eine <code>MyRGB</code> Klasse mit zus√§tzlichen Funktionen erstellt habe, eine andere <code>OurRGB</code> Klasse usw.  - Wenn jemand eine Klasse mit allen neuen Funktionen haben m√∂chte, m√ºssen Sie die Mehrfachvererbung verwenden (und dies nur, wenn die Programmiersprache dies √ºberhaupt zul√§sst!). </p><br><p>  Also, beide Optionen sind so lala.  Es gibt jedoch andere L√∂sungen: </p><br><ul><li>  F√ºgen Sie die Funktion in eine externe Funktion anstelle der Klassenmethode ein - gehen Sie zu <code>f(x, y)</code> anstelle von <code>xf(y)</code> .  Aber dann geht verallgemeinertes Verhalten verloren. </li><li>  Spit auf der Wiederverwendung von Code (und, wie ich glaube, in vielen F√§llen ist es passiert).  Kopieren Sie sich einfach eine au√üerirdische <code>RGB</code> Klasse und f√ºgen Sie hinzu, was fehlt. </li></ul><br><p>  Das Hauptmerkmal von Julia bei der Wiederverwendung von Code ist fast vollst√§ndig auf die Tatsache reduziert, dass die <em>Methode au√üerhalb des Typs definiert ist</em> .  Das ist alles.  Machen Sie dasselbe in Einzelversand-Sprachen - und Typen k√∂nnen mit der gleichen Leichtigkeit wiederverwendet werden.  Die ganze Geschichte mit ‚ÄûMachen wir Methoden zu einem Teil der Klasse‚Äú ist in der Tat eine mittelm√§√üige Idee.  Es stimmt, es gibt einen guten Punkt - die Verwendung von Klassen als Namespaces.  Wenn ich schreibe, dass <code>xf(y)</code> - <code>f()</code> nicht im aktuellen Namespace sein muss, muss es im Namespace <code>x</code> gesucht werden.  Ja, es ist eine gute Sache - aber ist es all die anderen Probleme wert?  Wei√ü nicht.  Meiner Meinung nach nein (obwohl meine Meinung, wie Sie vielleicht vermuten, leicht voreingenommen ist). </p><br><h3 id="epilog-problema-vyrazheniya">  Nachwort.  Das Problem des Ausdrucks </h3><br><p>  Es gibt ein solches Programmierproblem, das in den 70er Jahren festgestellt wurde.  Es h√§ngt weitgehend mit der statischen Typpr√ºfung zusammen, da es in solchen Sprachen vorkommt.  Es stimmt, ich denke, dass es nichts mit statischer Typpr√ºfung zu tun hat.  Das Wesentliche des Problems ist das Folgende: Ist es m√∂glich, das Datenmodell und den Satz von Operationen an den Daten gleichzeitig zu √§ndern, ohne auf zweifelhafte Techniken zur√ºckzugreifen. </p><br><p>  Das Problem kann mehr oder weniger auf Folgendes reduziert werden: </p><br><ol><li>  ist es m√∂glich, einfach und fehlerfrei <strong>neue Datentypen</strong> hinzuzuf√ºgen <strong>,</strong> auf die <strong>vorhandene Methoden anwendbar sind</strong> und </li><li>  Ist es m√∂glich, <strong>neue Operationen</strong> f√ºr <strong>vorhandene Typen</strong> <strong>hinzuzuf√ºgen</strong> <strong>?</strong> </li></ol><br><p>  (1) kann leicht in objektorientierten Sprachen durchgef√ºhrt werden, und es ist schwierig, Funktion, (2) - im Gegenteil.  In diesem Sinne k√∂nnen wir nur √ºber den Dualismus von OOP- und FP-Ans√§tzen sprechen. </p><br><p>  In Multi-Dispatch-Sprachen sind beide Vorg√§nge einfach. (1)         , (2) ‚Äî      . <em>   </em> ,    .         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Expression_problem</a> ),           .     ?  ,   ,     .   , "  ,     " ‚Äî   "    "  .  "  ,     " ,       ,   . </p><br><p>            ,   .  ,  ,   ‚Äî      . </p><br><p>  ,   Julia    (     ),      .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468609/">https://habr.com/ru/post/de468609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468597/index.html">Saturns Sechseck oder wie man zu Hause das Experiment von Wissenschaftlern der Universit√§t Oxford reproduziert</a></li>
<li><a href="../de468601/index.html">Sch√§tzung der Projektlaufzeit. Warum ist es fast immer sehr untertrieben und was tun?</a></li>
<li><a href="../de468603/index.html">Rutracker hat eSNI aufgenommen. Ende der DPI-√Ñra und Ende der Sperren</a></li>
<li><a href="../de468605/index.html">Konstante Zeiger auf Zeiger auf Zeiger ...</a></li>
<li><a href="../de468607/index.html">Android f√ºr den Funkingenieur (Teil zwei)</a></li>
<li><a href="../de468611/index.html">.NET-Multithreading: Wenn die Leistung fehlt</a></li>
<li><a href="../de468615/index.html">Die Top 10 Sprachen f√ºr die App-Lokalisierung</a></li>
<li><a href="../de468621/index.html">Wir √ºbersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich m√∂chte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>