<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 👨🏽‍🤝‍👨🏼 👩🏻‍🔬 Geiseln COBOL und Math. Teil 1 💦 👩🏿‍🚒 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seien wir ehrlich: Niemand mag Bruchzahlen - selbst Computer. 

 Wenn es um die Programmiersprache COBOL geht, sieht die erste Frage, die in jedem Kop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geiseln COBOL und Math. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467251/">  Seien wir ehrlich: Niemand mag Bruchzahlen - selbst Computer. <br><br>  Wenn es um die Programmiersprache COBOL geht, sieht die erste Frage, die in jedem Kopf auftaucht, immer so aus: „Warum verwendet die Menschheit diese Sprache immer noch in vielen wichtigen Bereichen?“  Banken verwenden immer noch COBOL.  Etwa 7% des US-BIP sind bei der Verarbeitung von Zahlungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMS</a> auf COBOL angewiesen.  Wie jeder weiß, verwendet der Internal Revenue Service (IRS) der Vereinigten Staaten immer noch COBOL.  Diese Sprache wird auch in der Luftfahrt verwendet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus habe</a> ich eine interessante Sache zu diesem Thema gelernt: Die Reservierungsnummer auf Flugtickets war früher ein üblicher Hinweis).  Es kann gesagt werden, dass viele sehr ernsthafte Organisationen, ob es sich um einen privaten oder einen öffentlichen Sektor handelt, immer noch COBOL verwenden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/q1/m_/gs/q1m_gsyxbbwdk32ng3w1foeckgc.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der zweite Teil</a> <br><br>  Der Autor des Materials, dessen erster Teil der Übersetzung wir heute veröffentlichen, wird eine Antwort auf die Frage finden, warum COBOL, die Sprache, die 1959 erschien, immer noch so verbreitet ist. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum lebt COBOL noch?</font> </h2><br>  Die traditionelle Antwort auf diese Frage ist zutiefst zynisch.  Organisationen sind Faulheit, Inkompetenz und Dummheit.  Sie sind auf der Suche nach Billigkeit und neigen nicht dazu, in das Umschreiben ihrer Softwaresysteme auf etwas Modernes zu investieren.  Im Allgemeinen kann davon ausgegangen werden, dass der Grund dafür, dass die Arbeit einer so großen Anzahl von Organisationen von COBOL abhängt, eine Kombination aus Trägheit und Kurzsichtigkeit ist.  Und darin liegt natürlich etwas Wahres.  Das Umschreiben großer Mengen verwirrenden Codes ist eine gewaltige Aufgabe.  Ist es teuer.  Das ist schwer.  Und wenn die vorhandene Software gut zu funktionieren scheint, hat die Organisation keine besonders starke Motivation, in ein Projekt zur Aktualisierung dieser Software zu investieren. <br><br>  Das alles ist so.  Aber als ich beim IRS arbeitete, sprachen COBOL-Veteranen darüber, wie sie versuchten, Code in Java neu zu schreiben, und es stellte sich heraus, dass Java die Berechnungen nicht korrekt ausführen konnte. <br><br>  Es klang für mich sehr seltsam.  Es ist so seltsam, dass ich sofort den alarmierenden Gedanken bekam: "Herr, das heißt, die IRS rundet seit 50 Jahren die Steuerzahlungen an alle ab !!!"  Ich konnte einfach nicht glauben, dass COBOL Java in Bezug auf die vom IRS benötigten mathematischen Berechnungen umgehen kann.  Am Ende haben sie keine Menschen in den Weltraum gebracht. <br><br>  Eine der interessanten Nebenwirkungen des Lernens von COBOL im Sommer ist, dass ich Folgendes zu verstehen begann.  Der Punkt ist nicht, dass Java mathematische Berechnungen nicht korrekt ausführen kann.  Der Punkt ist genau, wie Java die Berechnungen korrekt macht.  Und wenn Sie verstehen, wie Berechnungen in Java ausgeführt werden und wie dasselbe in COBOL ausgeführt wird, beginnen Sie zu verstehen, warum es vielen Unternehmen so schwer fällt, ihr Computer-Erbe loszuwerden. <br><br><h2>  <font color="#3AC1EF">Welches "i" sollte gepunktet werden?</font> </h2><br>  Ich werde mich ein wenig von der COBOL-Geschichte entfernen und darüber sprechen, wie Computer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen gespeichert haben,</a> bevor die binäre Darstellung von Daten zum De-facto-Standard wurde (aber das Material zur Verwendung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> z / OS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle</a> ; dies ist etwas Besonderes).  Ich denke, dass es bei der Betrachtung unseres Themas nützlich sein wird, in dieser Richtung vom Hauptthema abzuweichen.  Im obigen Material habe ich über verschiedene Möglichkeiten gesprochen, binäre Schalter zu verwenden, um Zahlen in binären, ternären, dezimalen Systemen zu speichern, negative Zahlen zu speichern - und so weiter.  Das einzige, worauf ich nicht genug geachtet habe, war, wie Dezimalzahlen gespeichert werden. <br><br>  Wenn Sie Ihren eigenen Binärcomputer entworfen haben, können Sie zunächst entscheiden, dass Sie das Binärzahlensystem verwenden.  Die Bits links vom Punkt stehen für ganze Zahlen - 1, 2, 4, 8. Und die Bits rechts - Bruchzahlen - 1/2, 1/4, 1/8 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/2eb/182/c872eb1825dc1d6b456ae11cbcc3325d.png"></div><br>  <i><font color="#999999">2,75 in binärer Darstellung</font></i> <br><br>  Das Problem hierbei ist, zu verstehen, wie der Dezimalpunkt selbst gespeichert wird (tatsächlich - ich sollte „Binärpunkt“ sagen -, weil es sich schließlich um Binärzahlen handelt).  Dies ist keine Art von „Computeralchemie“, Sie können also gut erraten, wovon ich spreche, von Gleitkommazahlen und Festkommazahlen.  In Gleitkommazahlen kann ein Binärpunkt an einer beliebigen Stelle platziert werden (dh er kann „schweben“).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Position des</a> Punktes wird als Exponent gespeichert.  Die Fähigkeit, einen Punkt zu verschieben, ermöglicht es, einen größeren Bereich von Zahlen zu speichern, als ohne eine solche Möglichkeit verfügbar ist.  Der Dezimalpunkt kann ganz nach hinten verschoben werden und alle Bits auswählen, um ganzzahlige Werte zu speichern, die sehr große Zahlen darstellen.  Der Punkt kann nach vorne verschoben werden und sehr kleine Werte ausdrücken.  Diese Freiheit geht jedoch zu Lasten der Genauigkeit.  Schauen wir uns noch einmal die binäre Darstellung von 2.75 aus dem vorherigen Beispiel an.  Ein Übergang von vier auf acht ist viel mehr als ein Übergang von einem Viertel auf ein Achtel.  Es kann für uns einfacher sein, sich das vorzustellen, wenn wir das Beispiel wie unten gezeigt umschreiben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/ec9/8aa/894ec98aa1715609e45d95ede3b865b1.png"></div><br>  <i><font color="#999999">Ich habe den Abstand zwischen den Zahlen mit dem Auge gewählt - nur um meine Idee zu demonstrieren</font></i> <br><br>  Der Unterschied zwischen den Zahlen lässt sich leicht selbst berechnen.  Zum Beispiel beträgt der Abstand zwischen 1/16 und 1/32 0,03125, aber der Abstand zwischen 1/2 und 1/4 beträgt bereits 0,25. <br><br>  Warum ist das wichtig?  Bei einer binären Darstellung von ganzen Zahlen spielt dies keine Rolle - der Abstand zwischen benachbarten Zahlen eines binären Datensatzes kann leicht kompensiert werden, indem sie mit den entsprechenden Kombinationen von Bits gefüllt werden, ohne an Genauigkeit zu verlieren.  Bei der Darstellung von Bruchzahlen ist dies jedoch nicht so einfach.  Wenn Sie versuchen, die "Löcher" zwischen benachbarten Zahlen zu "füllen", kann etwas in diese Löcher "fallen" (und tatsächlich durchfallen).  Dies führt dazu, dass es im Binärformat nicht möglich ist, genaue Darstellungen von Bruchzahlen zu erhalten. <br><br>  Dies zeigt das klassische Beispiel der Zahl 0.1 (ein Zehntel).  Wie kann man diese Zahl im Binärformat darstellen?  2 <sup>-1</sup> ist 1/2 oder 0,5.  Das ist zu viel.  1/16 ist 0,0635.  Das ist zu wenig.  1/16 + 1/32 ist bereits näher (0,09375), aber 1/16 + 1/32 + 1/64 ist bereits mehr als wir brauchen (0,109375). <br><br>  Wenn Sie glauben, dass diese Argumentation auf unbestimmte Zeit fortgesetzt werden kann - dann haben Sie Recht - so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie es ist</a> . <br><br>  Hier können Sie sich sagen: „Warum speichern wir nicht einfach 0,1 auf die gleiche Weise, wie wir die Nummer 1 speichern?  Wir können die Zahl 1 problemlos speichern. Entfernen Sie also einfach den Dezimalpunkt und speichern Sie alle Zahlen auf die gleiche Weise wie Ganzzahlen. " <br><br>  Dies ist eine hervorragende Lösung für dieses Problem, mit der Ausnahme, dass der Binär- / Dezimalpunkt an einer bestimmten Stelle festgelegt werden muss.  Andernfalls sehen die Nummern 10.00001 und 100000.1 genauso aus.  Wenn der Punkt jedoch so festgelegt ist, dass dem Bruchteil der Zahl beispielsweise 2 Ziffern zugewiesen werden, können wir 10.00001 auf 10.00 runden, und 100000.1 wird 100000.10. <br><br>  Wir haben nur Festkommazahlen „erfunden“. <br><br>  Mit der Darstellung verschiedener Werte unter Verwendung von Festkommazahlen haben wir es gerade herausgefunden.  Es ist einfach zu tun.  Ist es möglich, mithilfe von Festkommazahlen die Lösung einiger anderer Probleme zu erleichtern?  Erinnern wir uns hier an unsere guten Freunde - an binäre Dezimalzahlen (Binary Coded Decimal, BCD).  Übrigens, um Sie wissen zu lassen, werden diese Zahlen in den meisten wissenschaftlichen und grafischen Taschenrechnern verwendet.  Von diesen Geräten erwarten sie, was ziemlich klar ist, die korrekten Ergebnisse der Berechnungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/020/d31/102020d313c5627bb37fc6dee57954a4.jpg"></div><br>  <i><font color="#999999">TI-84 Plus Rechner</font></i> <br><br><h2>  <font color="#3AC1EF">Wiederholungsrate von Müller und Python</font> </h2><br>  Festkommazahlen werden als genauer angesehen, da die „Löcher“ zwischen den Zahlen konstant sind und nur dann gerundet wird, wenn Sie sich eine Zahl vorstellen müssen, für die einfach nicht genügend Platz vorhanden ist.  Bei Verwendung von Gleitkommazahlen können wir jedoch sehr große und sehr kleine Zahlen mit derselben Speichermenge darstellen.  Es stimmt, mit ihrer Hilfe ist es unmöglich, alle Zahlen im zugänglichen Bereich genau darzustellen, und wir sind gezwungen, auf Rundungen zurückzugreifen, um die „Löcher“ zu füllen. <br><br>  COBOL wurde als Sprache erstellt, in der standardmäßig Festkommazahlen verwendet werden.  Aber bedeutet dies, dass COBOL für mathematische Berechnungen besser ist als moderne Sprachen?  Wenn wir ein Problem wie das Ergebnis der Berechnung des Werts 0,1 + 0,2 feststellen, sollte die vorherige Frage möglicherweise mit „Ja“ beantwortet werden.  Aber es wird langweilig.  Also lasst uns weitermachen. <br><br>  Wir werden mit COBOL unter Verwendung der sogenannten Muller's Recurrence-Beziehung experimentieren.  Jean-Michel Muller ist ein französischer Wissenschaftler, der möglicherweise eine wichtige wissenschaftliche Entdeckung auf dem Gebiet der Informationstechnologie gemacht hat.  Er fand einen Weg, den korrekten Betrieb von Computern mithilfe von Mathematik zu unterbrechen.  Ich bin sicher, dass er sagen würde, dass er die Probleme der Zuverlässigkeit und Genauigkeit untersucht, aber nein und nein noch einmal: Er schafft mathematische Probleme, die Computer „kaputt machen“.  Eine dieser Aufgaben ist die Wiederholungsformel.  Es sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fa/1d8/56c/8fa1d856cfe581c272fc25a8c55e8938.png"></div><br>  <i><font color="#999999">Dieses Beispiel stammt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier.</a></font></i> <br><br>  Die Formel scheint überhaupt nicht beängstigend.  Richtig?  Diese Aufgabe ist aus folgenden Gründen für unsere Zwecke geeignet: <br><br><ul><li>  Hier werden nur einfache Regeln der Mathematik verwendet - keine komplizierten Formeln oder tiefen Ideen. </li><li>  Wir beginnen mit einer Zahl, die zwei Nachkommastellen hat.  Daher ist es leicht vorstellbar, dass wir mit Werten arbeiten, die bestimmte Geldbeträge repräsentieren. </li><li>  Der Fehler, der sich aus den Berechnungen ergibt, ist kein kleiner Rundungsfehler.  Dies ist eine Abweichung vom korrekten Ergebnis um ganze Größenordnungen. </li></ul><br>  Hier ist ein kleines Python-Skript, das die Ergebnisse von Muellers Wiederholungsrelation unter Verwendung von Gleitkomma- und Festkommazahlen berechnet: <br><br><pre><code class="plaintext hljs">from decimal import Decimal def rec(y, z):  return 108 - ((815-1500/z)/y)  def floatpt(N):  x = [4, 4.25]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x  def fixedpt(N):  x = [Decimal(4), Decimal(17)/Decimal(4)]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x N = 20 flt = floatpt(N) fxd = fixedpt(N) for i in range(N):  print str(i) + ' | '+str(flt[i])+' | '+str(fxd[i])</code> </pre> <br>  Hier ist das Ergebnis dieses Skripts: <br><br><pre> <code class="plaintext hljs">i | floating pt  | fixed pt -- | -------------- | --------------------------- 0 | 4       | 4 1 | 4.25      | 4.25 2 | 4.47058823529 | 4.4705882352941176470588235 3 | 4.64473684211 | 4.6447368421052631578947362 4 | 4.77053824363 | 4.7705382436260623229461618 5 | 4.85570071257 | 4.8557007125890736342039857 6 | 4.91084749866 | 4.9108474990827932004342938 7 | 4.94553739553 | 4.9455374041239167246519529 8 | 4.96696240804 | 4.9669625817627005962571288 9 | 4.98004220429 | 4.9800457013556311118526582 10 | 4.9879092328  | 4.9879794484783912679439415 11 | 4.99136264131 | 4.9927702880620482067468253 12 | 4.96745509555 | 4.9956558915062356478184985 13 | 4.42969049831 | 4.9973912683733697540253088 14 | -7.81723657846 | 4.9984339437852482376781601 15 | 168.939167671 | 4.9990600687785413938424188 16 | 102.039963152 | 4.9994358732880376990501184 17 | 100.099947516 | 4.9996602467866575821700634 18 | 100.004992041 | 4.9997713526716167817979714 19 | 100.000249579 | 4.9993671517118171375788238</code> </pre> <br>  Bis zur Iteration 12 sieht der Rundungsfehler mehr oder weniger unbedeutend aus, aber dann beginnt die wahre Hölle.  Gleitkommaberechnungen konvergieren zu einer Zahl, die zwanzigmal größer ist als die Ergebnisse von Festkommaberechnungen. <br><br>  Vielleicht halten Sie es für unwahrscheinlich, dass jemand so umfangreiche rekursive Berechnungen durchführen würde.  Aber genau dies verursachte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Katastrophe von</a> 1991, die zum Tod von 28 Menschen führte, als das Patriot-Raketenkontrollsystem die Zeit falsch berechnete.  Es stellte sich heraus, dass Gleitkommaberechnungen versehentlich großen Schaden anrichteten.  Hier sind einige großartige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dinge</a> , mit denen High Performance Computing möglicherweise nur schneller die falschen Antworten liefert.  Lesen Sie diese Arbeit, wenn Sie weitere Informationen zu dem hier diskutierten Problem erhalten und weitere Beispiele sehen möchten. <br><br>  Das Problem ist, dass die RAM-Größe der Computer nicht unendlich ist.  Daher ist es unmöglich, eine unendliche Anzahl von Dezimalstellen (oder Binärpositionen) zu speichern.  Festkommaberechnungen können genauer sein als Gleitkommaberechnungen, wenn die Gewissheit besteht, dass es weniger wahrscheinlich ist, dass nach dem Punkt mehr Zahlen benötigt werden als das verwendete Format.  Wenn die Zahl nicht in dieses Format passt, wird sie gerundet.  Es ist zu beachten, dass weder Festpunktberechnungen noch Gleitkommaberechnungen vor dem Problem geschützt sind, das Muellers Wiederholungsrelation zeigt.  Sowohl das als auch andere führen zu falschen Ergebnissen.  Die Frage ist, wann dies passiert.  Wenn Sie die Anzahl der Iterationen in einem Python-Skript beispielsweise von 20 auf 22 erhöhen, beträgt die endgültige Zahl, die bei Berechnungen mit einem festen Punkt erhalten wird, 0,728107.  23 Iterationen?  -501.7081261.  24?  105.8598187. <br><br>  In verschiedenen Sprachen manifestiert sich dieses Problem auf unterschiedliche Weise.  Einige, wie COBOL, ermöglichen es Ihnen, mit Zahlen zu arbeiten, deren Parameter eng eingestellt sind.  In Python gibt es beispielsweise Standardwerte, die konfiguriert werden können, wenn der Computer über genügend Speicher verfügt.  Wenn wir unserem Programm die Zeile <code>getcontext().prec = 60</code> hinzufügen und dem Python-Dezimalmodul mitteilen, dass es nach dem Punkt 60 Positionen und nicht 28 verwenden würde, wie dies standardmäßig der Fall ist, kann das Programm 40 Iterationen der Wiederholungsrelation ohne Fehler ausführen Müller. <br><br>  Fortsetzung folgt… <br><br>  <b>Liebe Leser!</b>  Sind Sie auf ernsthafte Probleme gestoßen, die sich aus der Art der Gleitkommaberechnungen ergeben? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467251/">https://habr.com/ru/post/de467251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467239/index.html">Der Unterschied zwischen Data Scientist und einem Teenager in einem Sportwagen</a></li>
<li><a href="../de467241/index.html">ROS LKW Wagen. Teil 4. Erstellen einer Robotersimulation mit den Editoren rviz und pavillon</a></li>
<li><a href="../de467245/index.html">Dmitry Matskevich, Dbrain: über Unternehmertum als geistige Behinderung, KI und emotionale Sicherheit</a></li>
<li><a href="../de467247/index.html">Eine Geschichte über V8, React und einen Leistungsabfall. Teil 1</a></li>
<li><a href="../de467249/index.html">Eine Geschichte über V8, React und einen Leistungsabfall. Teil 2</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei häufige Sicherheitsfehler, über die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
<li><a href="../de467259/index.html">DPI (SSL Inspection) widerspricht der Bedeutung von Kryptografie, wird jedoch von Unternehmen implementiert</a></li>
<li><a href="../de467261/index.html">Richtiges Einfädeln in Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>