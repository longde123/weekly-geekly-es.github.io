<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÑ üöÄ üåü Verteilte Spur: Wir haben alles falsch gemacht üêü üñêüèæ üõï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Die Autorin dieses Materials ist Cindy Sridharan, eine Ingenieurin von imgix, die an der Entwicklung von APIs und insbesondere am Tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilte Spur: Wir haben alles falsch gemacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460365/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Die Autorin dieses Materials ist Cindy Sridharan, eine Ingenieurin von imgix, die an der Entwicklung von APIs und insbesondere am Testen von Microservices beteiligt ist.</i>  <i>In diesem Artikel teilt sie ihre detaillierte Vision von tats√§chlichen Problemen im Bereich der verteilten R√ºckverfolgung, wo es ihrer Meinung nach an wirklich wirksamen Werkzeugen zur L√∂sung dringender Probleme mangelt.</i> <br><br><img src="https://habrastorage.org/webt/zu/va/og/zuvaogffo6d3gqi1mmzq5ts3zoc.png"><br>  <i>[Die Abbildung stammt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem anderen Material</a> √ºber verteilte R√ºckverfolgung.]</i> <br><br>  Es wird angenommen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verteiltes Tracing</a> schwierig zu implementieren ist und die Rendite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bestenfalls zweifelhaft ist</a> .  Das "Problem" der Ablaufverfolgung wird aus vielen Gr√ºnden erkl√§rt und bezieht sich h√§ufig auf die Komplexit√§t der Einrichtung jeder Komponente des Systems, um die entsprechenden Header zusammen mit jeder Anforderung zu √ºbertragen.  Obwohl dieses Problem auftritt, kann es nicht als un√ºberwindbar bezeichnet werden.  √úbrigens erkl√§rt es nicht, warum Entwickler Tracing nicht wirklich m√∂gen (auch wenn es bereits funktioniert). <a name="habracut"></a><br><br>  Die Hauptschwierigkeit bei der verteilten Ablaufverfolgung besteht darin, keine Daten zu sammeln, die Formate f√ºr die Verteilung und Pr√§sentation der Ergebnisse nicht zu standardisieren und nicht zu bestimmen, wann, wo und wie Stichproben erstellt werden sollen.  Ich versuche √ºberhaupt nicht, diese ‚ÄûVerdaulichkeitsprobleme‚Äú als <i>trivial darzustellen</i> - tats√§chlich gibt es ziemlich bedeutende technische und (wenn wir uns wirklich mit Open Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standards und -Protokollen</a> befassen) politische Herausforderungen, die bew√§ltigt werden m√ºssen, damit diese Probleme ber√ºcksichtigt werden k√∂nnen gel√∂st. <br><br>  Wenn Sie sich jedoch vorstellen, dass all diese Probleme behoben wurden, wird sich an der <i>Endbenutzererfahrung</i> wahrscheinlich nichts wesentlich √§ndern.  Die Ablaufverfolgung ist in den g√§ngigsten Debugging-Szenarien m√∂glicherweise immer noch nicht praktikabel - selbst nach der Bereitstellung. <br><br><h2>  So eine andere Spur </h2><br>  Die verteilte Ablaufverfolgung umfasst mehrere unterschiedliche Komponenten: <br><br><ul><li>  Ausstattung von Anwendungen und Middleware mit Steuerelementen; </li><li>  Verteilte Kontext√ºbertragung </li><li>  Spurensammlung; </li><li>  Speicherung von Spuren; </li><li>  ihre Extraktion und Visualisierung. </li></ul><br>  Bei vielen Gespr√§chen √ºber verteiltes Tracing geht es darum, es als eine Art un√§re Operation zu betrachten, deren einziger Zweck darin besteht, bei der vollst√§ndigen Diagnose des Systems zu helfen.  Dies ist haupts√§chlich auf die Art und Weise zur√ºckzuf√ºhren, in der das Konzept der verteilten Verfolgung entwickelt wurde.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Blog-Beitrag,</a> der beim √ñffnen der Zipkin-Quellen verfasst wurde, wurde erw√§hnt, dass <i>er [Zipkin] Twitter schneller macht</i> .  Die ersten kommerziellen Angebote f√ºr die R√ºckverfolgung wurden auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APM-Tools</a> beworben. <br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Damit der weitere Text besser verstanden wird, definieren wir gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation des OpenTracing-Projekts</a> zwei Grundbegriffe:</i> <br><br><ul><li>  <i><b>Span</b> - das Grundelement der verteilten Verfolgung.</i>  <i>Es ist eine Beschreibung eines bestimmten Workflows (z. B. einer Datenbankabfrage) mit einem Namen, Start- und Endzeiten, Tags, Protokollen und Kontext.</i> </li><li>  <i>Bereiche enthalten normalerweise Links zu anderen Bereichen, sodass Sie viele Bereiche in <b>Trace</b> kombinieren k√∂nnen - eine Visualisierung der Lebensdauer einer Anforderung, wenn diese sich durch ein verteiltes System bewegt.</i> </li></ul><br>  Trace'y enth√§lt unglaublich wertvolle Daten, die bei folgenden Aufgaben hilfreich sein k√∂nnen: Testen in der Produktion, Durchf√ºhren von Disaster Recovery-Tests, Testen mit Einf√ºhrung von Fehlern usw.  Tats√§chlich verwenden einige Unternehmen die R√ºckverfolgung bereits f√ºr solche Zwecke.  Zun√§chst hat die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">universelle</a> Kontext√ºbertragung neben der einfachen √úbertragung von Bereichen auf das Speichersystem noch andere Verwendungszwecke: <br><br><ul><li>  Beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet</a> Uber Trace-Ergebnisse, um zwischen Testverkehr und Produktionsverkehr zu unterscheiden. </li><li>  Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet</a> Trace-Daten, um den kritischen Pfad zu analysieren und den Datenverkehr w√§hrend regelm√§√üiger Disaster Recovery-Tests zu wechseln. </li><li>  Das soziale Netzwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet auch</a> Jupyter-Notizb√ºcher, mit denen Entwickler beliebige Abfragen zu den Ergebnissen der Ablaufverfolgung ausf√ºhren k√∂nnen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LDFI-</a> Anh√§nger (Lineage Driven Failure Injection <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwenden</a> verteilte Traces f√ºr Fehlertests. </li></ul><br>  Keine der oben genannten Optionen bezieht sich vollst√§ndig auf das <i>Debugging-</i> Szenario, in dem der Techniker versucht, das Problem durch Betrachten der Ablaufverfolgung zu l√∂sen. <br><br>  Wenn es um das Debugging-Szenario geht, bleibt das <i>Traceview-</i> Diagramm die prim√§re Schnittstelle (obwohl einige es auch als <i>"Gantt-Diagramm"</i> oder <i>"Kaskadendiagramm" bezeichnen</i> ).  Mit <i>Traceview</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine</a> ich alle <i>Bereiche</i> und zugeh√∂rigen Metadaten, die zusammen Trace bilden.  Jedes Open-Source-Trace-System sowie jede kommerzielle Trace-L√∂sung bietet eine auf <i>Traceview</i> basierende Benutzeroberfl√§che zum Visualisieren, Detaillieren und Filtern von Trace-Daten. <br><br>  Das Problem bei allen Trace-Systemen, mit denen ich im Moment vertraut bin, ist, dass die endg√ºltige <i>Visualisierung (Trace-Ansicht)</i> die Funktionen des Trace-Generierungsprozesses fast vollst√§ndig widerspiegelt.  Selbst wenn alternative Visualisierungen angeboten werden: Intensit√§tskarten (Heatmap), Servicetopologien, <i>Latenzhistogramme</i> - am Ende kommt es immer noch auf die <i>Trace-Ansicht an</i> . <br><br>  In der Vergangenheit habe ich mich dar√ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschwert,</a> dass die meisten ‚ÄûInnovationen‚Äú bei der R√ºckverfolgbarkeit in Bezug auf UI / UX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">darauf</a> beschr√§nkt zu sein scheinen, zus√§tzliche Metadaten in die Ablaufverfolgung aufzunehmen, Informationen mit <i>hoher Kardinalit√§t</i> in diese einzubetten oder die M√∂glichkeit zu bieten, einen Drilldown auf bestimmte Bereiche durchzuf√ºhren oder <i>Inter- und Intra-Trace-</i> Abfragen ausf√ºhren.  In diesem Fall bleibt die <i>Trace-Ansicht</i> das <i>Hauptvisualisierungsmittel</i> .  Solange dieser Zustand anh√§lt, wird die verteilte Ablaufverfolgung (bestenfalls) als Debugging-Tool den 4. Platz einnehmen, gefolgt von Metriken, Protokollen und Stapelverfolgungen, und im schlimmsten Fall wird es sich als Geld- und Zeitverschwendung herausstellen. <br><br><h2>  Problem mit Traceview </h2><br>  Der Zweck der <i>Ablaufverfolgungsansicht</i> besteht darin, ein vollst√§ndiges Bild der Bewegung einer einzelnen Anforderung √ºber alle Komponenten eines verteilten Systems bereitzustellen, auf das sie sich bezieht.  Mit einigen fortschrittlicheren Ablaufverfolgungssystemen k√∂nnen Sie einen Drilldown zu einzelnen Bereichen durchf√ºhren und die Zeitaufteilung <i>innerhalb eines</i> einzelnen Prozesses anzeigen (wenn Bereiche funktionale Grenzen haben). <br><br>  Die Grundvoraussetzung der Microservices-Architektur ist die Idee, dass die Organisationsstruktur mit den Anforderungen des Unternehmens w√§chst.  Bef√ºrworter von Microservices argumentieren, dass die Verteilung verschiedener Gesch√§ftsaufgaben auf separate Services es kleinen, autonomen Entwicklungsteams erm√∂glicht, den gesamten Lebenszyklus solcher Services zu steuern und diese Services unabh√§ngig zu erstellen, zu testen und bereitzustellen.  Der Nachteil dieser Verteilung ist jedoch der Verlust von Informationen dar√ºber, wie jeder Dienst mit anderen interagiert.  Unter solchen Umst√§nden sind verteilte Ablaufverfolgungsanspr√ºche ein unverzichtbares Werkzeug zum <i>Debuggen</i> komplexer Interaktionen zwischen Diensten. <br><br>  Wenn Sie ein wirklich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstaunlich komplexes verteiltes System haben</a> , kann sich niemand das <i>vollst√§ndige</i> Bild merken.  Tats√§chlich ist die Entwicklung eines Tools, das auf der Annahme basiert, dass es im Allgemeinen m√∂glich ist, ein bisschen antimuster (ineffizienter und unproduktiver Ansatz).  Im Idealfall erfordert das Debuggen ein Tool, mit dem Sie <i>Ihre Suche</i> eingrenzen k√∂nnen, damit sich die Ingenieure auf eine Teilmenge der Dimensionen (Dienste / Benutzer / Hosts usw.) konzentrieren k√∂nnen, die f√ºr das betreffende Szenario relevant sind.  Bei der Ermittlung der Fehlerursache m√ºssen die Ingenieure nicht verstehen, was in <i>allen Diensten gleichzeitig</i> passiert ist, da eine solche Anforderung der Idee einer Microservice-Architektur widersprechen w√ºrde. <br><br>  Traceview ist jedoch <i>genau</i> das.  Ja, einige Trace-Systeme bieten komprimierte Trace-Ansichten, wenn die Anzahl der Spans im Trace so gro√ü ist, dass sie nicht in einer einzigen Visualisierung angezeigt werden k√∂nnen.  Aufgrund der gro√üen Menge an Informationen, die selbst in einer derart reduzierten Visualisierung enthalten sind, sind die Ingenieure jedoch immer noch <i>gezwungen, diese zu</i> ‚Äûsichten‚Äú und die Auswahl manuell auf eine Reihe von Servicequellen f√ºr Probleme zu beschr√§nken.  Leider sind Maschinen auf diesem Gebiet viel schneller als Menschen, weniger fehleranf√§llig und ihre Ergebnisse sind wiederholbarer. <br><br>  Ein weiterer Grund, warum ich die Traceview-Methode f√ºr falsch halte, ist, dass sie nicht f√ºr das hypothetische Debuggen geeignet ist.  Das Debuggen ist im Kern ein <i>iterativer</i> Prozess, der mit einer Hypothese beginnt, gefolgt von der √úberpr√ºfung verschiedener Beobachtungen und Fakten, die vom System erhalten wurden, unter Verwendung verschiedener Vektoren, Schlussfolgerungen / Verallgemeinerungen und einer weiteren Bewertung der Wahrheit der Hypothese. <br><br>  Die F√§higkeit <i>,</i> Hypothesen <i>schnell und kosteng√ºnstig zu</i> testen und das mentale Modell entsprechend zu verbessern, ist der <i>Eckpfeiler des</i> Debuggens.  Jedes Debugging-Tool sollte <i>interaktiv sein</i> und den Suchraum einschr√§nken oder im Falle einer falschen Ablaufverfolgung dem Benutzer erm√∂glichen, zur√ºck zu gehen und sich auf einen anderen Bereich des Systems zu konzentrieren.  Ein ideales Tool erledigt dies <i>proaktiv</i> und macht den Benutzer sofort auf potenziell problematische Bereiche aufmerksam. <br><br>  <i>Leider</i> kann <i>Traceview</i> nicht als interaktives Schnittstellentool bezeichnet werden.  Das Beste, auf das Sie bei der Verwendung hoffen k√∂nnen, ist, eine bestimmte Quelle erh√∂hter Verz√∂gerungen zu erkennen und alle damit verbundenen Tags und Protokolle anzuzeigen.  Dies hilft dem Ingenieur nicht, Verkehrsmuster wie die Besonderheiten der Verteilung von Verz√∂gerungen zu identifizieren oder Korrelationen zwischen verschiedenen Messungen zu erkennen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die generische Trace-Analyse</a> kann einige dieser Probleme umgehen.  In der Tat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es Beispiele f√ºr eine</a> erfolgreiche Analyse unter Verwendung von maschinellem Lernen, um abnormale Bereiche zu identifizieren und eine Teilmenge von Tags zu identifizieren, die mit abnormalem Verhalten verbunden sein k√∂nnen.  Trotzdem bin ich noch nicht auf √ºberzeugende Visualisierungen von Funden gesto√üen, die mithilfe von maschinellem Lernen oder Datenanalyse auf Bereiche angewendet wurden, die sich erheblich von Traceview oder DAG (direktionaler azyklischer Graph) unterscheiden w√ºrden. <br><br><h3>  Die Spannweiten sind zu niedrig </h3><br>  Das grundlegende Problem bei der Trace-Ansicht besteht darin, dass <i>Spans</i> sowohl f√ºr die Latenzanalyse als auch f√ºr die Ursachenanalyse zu niedrige Grundelemente sind.  Es ist so, als w√ºrde man einzelne Prozessorbefehle analysieren, um eine Ausnahme zu beseitigen, da man wei√ü, dass es viel √ºbergeordnete Tools wie Backtrace gibt, mit denen man viel bequemer arbeiten kann. <br><br>  Dar√ºber hinaus werde ich mir erlauben, Folgendes zu behaupten: Im Idealfall ben√∂tigen wir kein <i>vollst√§ndiges Bild</i> dessen, was w√§hrend des Lebenszyklus der Anfrage passiert ist, was moderne Tools zur R√ºckverfolgung darstellen.  Stattdessen ist eine Form der Abstraktion auf h√∂herer Ebene erforderlich, die Informationen dar√ºber enth√§lt, was <i>schief gelaufen ist</i> (√§hnlich wie bei der R√ºckverfolgung), sowie einen gewissen Kontext.  Anstatt die gesamte Spur zu beobachten, sehe ich lieber einen <i>Teil</i> davon, wo etwas Interessantes oder Ungew√∂hnliches passiert.  Derzeit wird die Suche manuell durchgef√ºhrt: Der Ingenieur erh√§lt eine Ablaufverfolgung und analysiert unabh√§ngig voneinander die Spannweiten auf der Suche nach etwas Interessantem.  Der Ansatz, wenn Personen in der Hoffnung, verd√§chtige Aktivit√§ten zu erkennen, auf Bereiche in getrennten Spuren starren, ist √ºberhaupt nicht skalierbar (insbesondere, wenn sie alle in verschiedenen Bereichen codierten Metadaten wie Span-ID, RPC-Methodenname und Span-Dauer erfassen m√ºssen 'a, Protokolle, Tags usw.). <br><br><h2>  Traceview-Alternativen </h2><br>  Verfolgungsergebnisse sind am n√ºtzlichsten, wenn sie so visualisiert werden k√∂nnen, dass eine nicht triviale Vorstellung davon entsteht, was in den miteinander verbundenen Teilen des Systems geschieht.  Bis dies der Fall ist, bleibt der Debugging-Prozess weitgehend <i>inert</i> und h√§ngt von der F√§higkeit des Benutzers ab, die richtigen Korrelationen zu erkennen, die richtigen Teile des Systems zu √ºberpr√ºfen oder Teile des Mosaiks zusammenzusetzen - im Gegensatz zu dem <i>Tool</i> , mit dem der Benutzer diese Hypothesen formulieren kann. <br><br>  Ich bin kein visueller Designer oder UX-Spezialist, aber im n√§chsten Abschnitt m√∂chte ich einige Ideen dazu teilen, wie solche Visualisierungen aussehen k√∂nnten. <br><br><h3>  Konzentrieren Sie sich auf bestimmte Dienstleistungen </h3><br>  In einem Umfeld, in dem sich die Branche auf die Ideen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SLO (Service Level Objectives) und SLI (Service Level Indicators) konzentriert</a> , erscheint es sinnvoll, dass einzelne Teams zun√§chst die Relevanz ihrer Services f√ºr diese Ziele √ºberwachen.  Daraus folgt, dass eine <i>serviceorientierte</i> Visualisierung f√ºr solche Teams am besten geeignet ist. <br><br>  Spuren, insbesondere ohne Stichproben, sind ein Informationsspeicher f√ºr jede Komponente eines verteilten Systems.  Diese Informationen k√∂nnen an einen kniffligen Handler weitergeleitet werden, der den Benutzern serviceorientierte Fundst√ºcke liefert, die im Voraus erkannt werden k√∂nnen - noch bevor der Benutzer die Spuren betrachtet: <br><br><ol><li>  Verz√∂gerungsverteilungsdiagramme nur f√ºr stark differenzierte Anforderungen <i>(Ausrei√üeranforderungen)</i> ; </li><li>  Verz√∂gerungsverteilungsdiagramme f√ºr F√§lle, in denen SLO-Serviceziele nicht erreicht werden; </li><li>  Die "h√§ufigsten", "interessantesten" und "seltsamsten" Tags in Abfragen, die am h√§ufigsten <i>wiederholt werden</i> . </li><li>  Aufschl√ºsselung der Verz√∂gerungen f√ºr F√§lle, in denen Dienstabh√§ngigkeiten die festgelegten SLO-Ziele nicht erreichen; </li><li>  Aufschl√ºsselung der Verz√∂gerungen f√ºr verschiedene nachgelagerte Dienste. </li></ol><br>  Integrierte Metriken k√∂nnen einige dieser Fragen einfach nicht beantworten, sodass Benutzer die Bereiche sorgf√§ltig untersuchen m√ºssen.  Infolgedessen haben wir einen √§u√üerst feindlichen Mechanismus f√ºr den Benutzer. <br><br>  In diesem Zusammenhang stellt sich die Frage: Was ist mit den komplexen Wechselwirkungen zwischen den verschiedenen Diensten, die von verschiedenen Teams gesteuert werden?  Wird <i>Traceview</i> nicht als das am besten geeignete Tool zur Abdeckung einer solchen Situation angesehen? <br><br>  Mobile Entwickler, Eigent√ºmer von zustandslosen Diensten, Eigent√ºmer von verwalteten Stateful Services (wie Datenbanken) und Plattformbesitzer sind m√∂glicherweise an einer anderen <i>Ansicht eines</i> verteilten Systems interessiert.  <i>traceview</i> ist eine viel zu universelle L√∂sung f√ºr diese grundlegend unterschiedlichen Anforderungen.  Selbst in einer sehr komplexen Microservice-Architektur ben√∂tigen Service-Eigent√ºmer keine gr√ºndlichen Kenntnisse √ºber mehr als zwei oder drei Upstream- und Downstream-Services.  Im Wesentlichen m√ºssen Benutzer in den meisten Szenarien nur Fragen zu einem <i>begrenzten Satz von Diensten</i> beantworten. <br><br>  Es ist, als w√ºrde man eine kleine Untergruppe von Diensten durch eine Lupe betrachten, um genau zu studieren.  Auf diese Weise kann der Benutzer dringendere Fragen zur komplexen Interaktion zwischen diesen Diensten und ihren unmittelbaren Abh√§ngigkeiten stellen.  Dies √§hnelt der R√ºckverfolgung in der Welt der Dienste, in der der Ingenieur wei√ü, <i>was</i> falsch ist, und auch eine Vorstellung davon hat, was in den umliegenden Diensten geschieht, um zu verstehen, <i>warum</i> . <br><br>  Der Ansatz, den ich f√∂rdere, ist das genaue Gegenteil des Top-Down-Ansatzes basierend auf der Trace-Ansicht, wenn die Analyse mit der gesamten Trace beginnt und dann allm√§hlich auf einzelne Bereiche abf√§llt.  Im Gegenteil, der Bottom-up-Ansatz beginnt mit einer Analyse eines kleinen Bereichs in der N√§he der potenziellen Ursache des Vorfalls. Anschlie√üend wird der Suchraum bei Bedarf erweitert (unter Einbeziehung anderer Teams zur Analyse eines breiteren Leistungsspektrums).  Der zweite Ansatz ist besser geeignet, um anf√§ngliche Hypothesen schnell zu testen.  Nachdem Sie bestimmte Ergebnisse erhalten haben, k√∂nnen Sie mit einer genaueren und detaillierteren Analyse fortfahren. <br><br><h3>  Topologiegeb√§ude </h3><br>  Die mit einem bestimmten Dienst verkn√ºpften Ansichten k√∂nnen unglaublich n√ºtzlich sein, wenn der Benutzer wei√ü, <i>welcher</i> Dienst oder welche Gruppe von Diensten f√ºr zunehmende Verz√∂gerungen verantwortlich ist oder eine Fehlerquelle darstellt.  In einem komplexen System ist das Identifizieren eines Eindringlings w√§hrend eines Fehlers m√∂glicherweise keine triviale Aufgabe, insbesondere wenn keine Fehlermeldungen von den Diensten empfangen wurden. <br><br>  Das Erstellen einer Servicetopologie kann sehr hilfreich sein, um herauszufinden, welcher Service einen Anstieg der Fehlerrate oder eine Erh√∂hung der Latenz aufweist, was zu einer sp√ºrbaren Verschlechterung der Serviceleistung f√ºhrt.  Wenn ich √ºber das Erstellen einer Topologie spreche, meine ich nicht <i>eine Dienstkarte</i> , die jeden im System verf√ºgbaren <i>Dienst</i> anzeigt und f√ºr seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturkarten in Form eines Todessterns bekannt ist</a> .  Eine solche Darstellung ist nicht besser als eine Trace-Ansicht, die auf einem gerichteten azyklischen Graphen basiert.  Stattdessen m√∂chte ich eine <i>dynamisch generierte Diensttopologie sehen,</i> die auf bestimmten Attributen wie Fehlerrate, Antwortzeit oder einem benutzerdefinierten Parameter basiert, der zur Kl√§rung der Situation mit bestimmten verd√§chtigen Diensten beitr√§gt. <br><br>  Schauen wir uns ein Beispiel an.  Stellen Sie sich eine hypothetische Nachrichtenseite vor.  Der <i>Titelseitendienst</i> kommuniziert mit Redis √ºber einen Empfehlungsdienst, einen Werbedienst und einen Videodienst.  Der Videodienst nimmt Videos aus S3 und die Metadaten aus DynamoDB auf.  Der Empfehlungsdienst empf√§ngt Metadaten von DynamoDB, l√§dt Daten von Redis und MySQL herunter und schreibt Nachrichten an Kafka.  Der Werbedienst empf√§ngt Daten von MySQL und schreibt Nachrichten an Kafka. <br><br>  Das Folgende ist eine schematische Darstellung dieser Topologie (viele kommerzielle Routing-Programme bauen die Topologie auf).  Dies kann n√ºtzlich sein, wenn Sie die Abh√§ngigkeiten von Diensten verstehen m√ºssen.  W√§hrend des <i>Debuggens</i> ist eine solche Topologie jedoch nicht sehr n√ºtzlich, wenn ein bestimmter Dienst (z. B. ein Videodienst) eine l√§ngere Antwortzeit aufweist. <br><br><img src="https://habrastorage.org/webt/qr/85/y9/qr85y98gth6ybvwt5yuditlnack.png"><br>  <i>Hypothetical News Site Services Scheme</i> <br><br>  Das folgende Diagramm w√§re besser.  Darauf <i>ist</i> in der Mitte ein problematischer Dienst <i>(Video)</i> abgebildet.  Der Benutzer bemerkt ihn sofort.  Aus dieser Visualisierung wird deutlich, dass der Videodienst aufgrund der erh√∂hten Antwortzeit von S3, die sich auf die Download-Geschwindigkeit eines Teils der Hauptseite auswirkt, nicht ordnungsgem√§√ü funktioniert. <br><br><img src="https://habrastorage.org/webt/v2/w5/za/v2w5zaf_s1_r8mzo0j6r2dopyyk.png"><br>  <i>Dynamische Topologie, die nur ‚Äûinteressante‚Äú Dienste anzeigt</i> <br><br>  Dynamisch generierte topologische Schemata k√∂nnen effizienter sein als statische Service-Maps, insbesondere in flexiblen, automatisch skalierbaren Infrastrukturen.  Durch die M√∂glichkeit, Diensttopologien zu vergleichen und gegen√ºberzustellen, kann der Benutzer relevantere Fragen stellen.  Genauere Fragen zum System f√ºhren eher zu einem besseren Verst√§ndnis der Funktionsweise des Systems. <br><br><h3>  Vergleichsanzeige </h3><br>  Eine weitere n√ºtzliche Visualisierung w√§re eine vergleichende Anzeige.  Spuren sind derzeit nicht gut f√ºr Vergleiche nebeneinander geeignet, daher werden <i>Spannweiten</i> normalerweise verglichen.  Die Hauptidee dieses Artikels ist genau, dass die Spannweiten zu niedrig sind, um die wertvollsten Informationen aus den Trace-Ergebnissen zu extrahieren. <br><br>  Der Vergleich zweier trace'ov erfordert keine grundlegend neuen Visualisierungen.  In der Tat ist so etwas wie ein Histogramm ausreichend, das die gleichen Informationen wie die Trace-Ansicht darstellt.  √úberraschenderweise kann selbst diese einfache Methode viel mehr Fr√ºchte bringen als eine einfache Untersuchung von zwei Spuren getrennt.  Noch leistungsf√§higer w√§re die M√∂glichkeit, <i>den</i> Vergleich von Spuren <i>im Aggregat</i> zu <i>visualisieren</i> .  Es w√§re √§u√üerst n√ºtzlich zu sehen, wie sich eine k√ºrzlich bereitgestellte √Ñnderung der Datenbankkonfiguration unter Einbeziehung von GC (Garbage Collection) auf die Antwortzeit eines nachgeschalteten Dienstes in wenigen Stunden auswirkt.  Wenn das, was ich hier beschreibe, wie eine A / B-Analyse der Auswirkungen von Infrastruktur√§nderungen <i>in einer Vielzahl von Diensten unter</i> Verwendung von Trace-Ergebnissen erscheint, sind Sie nicht zu weit von der Wahrheit entfernt. <br><br><h2>  Fazit </h2><br>  Ich bezweifle nicht die N√ºtzlichkeit der Spur selbst.  Ich bin der festen √úberzeugung, dass es keinen anderen Weg gibt, so umfangreiche, zuf√§llige und kontextbezogene Daten zu sammeln als die in der Spur enthaltenen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich glaube jedoch auch, dass alle Tracing-L√∂sungen diese Daten √§u√üerst ineffizient verwenden. </font><font style="vertical-align: inherit;">Solange die Tools f√ºr die Ablaufverfolgung in der Ablaufverfolgungsdarstellung fixiert sind, k√∂nnen sie nur begrenzt wertvolle Informationen verwenden, die aus den in den Ablaufverfolgungen enthaltenen Daten extrahiert werden k√∂nnen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus besteht die Gefahr der Weiterentwicklung einer v√∂llig unfreundlichen und nicht intuitiven visuellen Oberfl√§che, die die F√§higkeit des Benutzers, Fehler in der Anwendung zu beheben, erheblich einschr√§nkt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Debuggen komplexer Systeme ist selbst mit den neuesten Tools unglaublich komplex. </font><font style="vertical-align: inherit;">Die Werkzeuge sollten die Entwicklern zu formulieren und zu </font><font style="vertical-align: inherit;">testen Hypothesen helfen, die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktive Bereitstellung von</font></font></b>  ,        .  ,           production   ,   ,      ,       ,     . <br><br>    ,   ,     ,    , ,      .  ,         ,      ,     trace'  span'. <br><br>           (  UI). ,         ,        .        ,           .           .      . <br><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> kubectl-debug    pod' Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:   ,     Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Kubernetes (   )</a> ¬ª. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460365/">https://habr.com/ru/post/de460365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460353/index.html">Neuronales Netz im Glas. Ben√∂tigt keinen Strom, erkennt Zahlen</a></li>
<li><a href="../de460355/index.html">Das Ertrinken zu retten ist unser Gesch√§ft: wie man mit Teamdemotivation umgeht</a></li>
<li><a href="../de460359/index.html">Young Game Designer 2 Kurs: Balance zwischen Fortschritt und Dynamik ohne Mathematik</a></li>
<li><a href="../de460361/index.html">Tolle FAQ zur Cybersicherheit von medizinischen Informationssystemen</a></li>
<li><a href="../de460363/index.html">7 fehlende Faktoren im Ansatz 12 Faktor App</a></li>
<li><a href="../de460367/index.html">Chaos Engineering: die Kunst der absichtlichen Zerst√∂rung. Teil 1</a></li>
<li><a href="../de460373/index.html">Unter der Haube Turbo-Seiten: Architektur der Webseite Fast Download-Technologie</a></li>
<li><a href="../de460375/index.html">Buch "Maschinelles Lernen f√ºr Wirtschaft und Marketing"</a></li>
<li><a href="../de460377/index.html">Verwenden von Liquibase zum Verwalten der Datenbankstruktur in einer Spring Boot-Anwendung. Teil 1</a></li>
<li><a href="../de460381/index.html">Was ist Durchsetzungsverm√∂gen und warum wird es ben√∂tigt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>