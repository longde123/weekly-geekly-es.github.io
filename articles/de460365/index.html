<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🚀 🌟 Verteilte Spur: Wir haben alles falsch gemacht 🐟 🖐🏾 🛕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Die Autorin dieses Materials ist Cindy Sridharan, eine Ingenieurin von imgix, die an der Entwicklung von APIs und insbesondere am Tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilte Spur: Wir haben alles falsch gemacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460365/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Die Autorin dieses Materials ist Cindy Sridharan, eine Ingenieurin von imgix, die an der Entwicklung von APIs und insbesondere am Testen von Microservices beteiligt ist.</i>  <i>In diesem Artikel teilt sie ihre detaillierte Vision von tatsächlichen Problemen im Bereich der verteilten Rückverfolgung, wo es ihrer Meinung nach an wirklich wirksamen Werkzeugen zur Lösung dringender Probleme mangelt.</i> <br><br><img src="https://habrastorage.org/webt/zu/va/og/zuvaogffo6d3gqi1mmzq5ts3zoc.png"><br>  <i>[Die Abbildung stammt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem anderen Material</a> über verteilte Rückverfolgung.]</i> <br><br>  Es wird angenommen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verteiltes Tracing</a> schwierig zu implementieren ist und die Rendite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bestenfalls zweifelhaft ist</a> .  Das "Problem" der Ablaufverfolgung wird aus vielen Gründen erklärt und bezieht sich häufig auf die Komplexität der Einrichtung jeder Komponente des Systems, um die entsprechenden Header zusammen mit jeder Anforderung zu übertragen.  Obwohl dieses Problem auftritt, kann es nicht als unüberwindbar bezeichnet werden.  Übrigens erklärt es nicht, warum Entwickler Tracing nicht wirklich mögen (auch wenn es bereits funktioniert). <a name="habracut"></a><br><br>  Die Hauptschwierigkeit bei der verteilten Ablaufverfolgung besteht darin, keine Daten zu sammeln, die Formate für die Verteilung und Präsentation der Ergebnisse nicht zu standardisieren und nicht zu bestimmen, wann, wo und wie Stichproben erstellt werden sollen.  Ich versuche überhaupt nicht, diese „Verdaulichkeitsprobleme“ als <i>trivial darzustellen</i> - tatsächlich gibt es ziemlich bedeutende technische und (wenn wir uns wirklich mit Open Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standards und -Protokollen</a> befassen) politische Herausforderungen, die bewältigt werden müssen, damit diese Probleme berücksichtigt werden können gelöst. <br><br>  Wenn Sie sich jedoch vorstellen, dass all diese Probleme behoben wurden, wird sich an der <i>Endbenutzererfahrung</i> wahrscheinlich nichts wesentlich ändern.  Die Ablaufverfolgung ist in den gängigsten Debugging-Szenarien möglicherweise immer noch nicht praktikabel - selbst nach der Bereitstellung. <br><br><h2>  So eine andere Spur </h2><br>  Die verteilte Ablaufverfolgung umfasst mehrere unterschiedliche Komponenten: <br><br><ul><li>  Ausstattung von Anwendungen und Middleware mit Steuerelementen; </li><li>  Verteilte Kontextübertragung </li><li>  Spurensammlung; </li><li>  Speicherung von Spuren; </li><li>  ihre Extraktion und Visualisierung. </li></ul><br>  Bei vielen Gesprächen über verteiltes Tracing geht es darum, es als eine Art unäre Operation zu betrachten, deren einziger Zweck darin besteht, bei der vollständigen Diagnose des Systems zu helfen.  Dies ist hauptsächlich auf die Art und Weise zurückzuführen, in der das Konzept der verteilten Verfolgung entwickelt wurde.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Blog-Beitrag,</a> der beim Öffnen der Zipkin-Quellen verfasst wurde, wurde erwähnt, dass <i>er [Zipkin] Twitter schneller macht</i> .  Die ersten kommerziellen Angebote für die Rückverfolgung wurden auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APM-Tools</a> beworben. <br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Damit der weitere Text besser verstanden wird, definieren wir gemäß der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation des OpenTracing-Projekts</a> zwei Grundbegriffe:</i> <br><br><ul><li>  <i><b>Span</b> - das Grundelement der verteilten Verfolgung.</i>  <i>Es ist eine Beschreibung eines bestimmten Workflows (z. B. einer Datenbankabfrage) mit einem Namen, Start- und Endzeiten, Tags, Protokollen und Kontext.</i> </li><li>  <i>Bereiche enthalten normalerweise Links zu anderen Bereichen, sodass Sie viele Bereiche in <b>Trace</b> kombinieren können - eine Visualisierung der Lebensdauer einer Anforderung, wenn diese sich durch ein verteiltes System bewegt.</i> </li></ul><br>  Trace'y enthält unglaublich wertvolle Daten, die bei folgenden Aufgaben hilfreich sein können: Testen in der Produktion, Durchführen von Disaster Recovery-Tests, Testen mit Einführung von Fehlern usw.  Tatsächlich verwenden einige Unternehmen die Rückverfolgung bereits für solche Zwecke.  Zunächst hat die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">universelle</a> Kontextübertragung neben der einfachen Übertragung von Bereichen auf das Speichersystem noch andere Verwendungszwecke: <br><br><ul><li>  Beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet</a> Uber Trace-Ergebnisse, um zwischen Testverkehr und Produktionsverkehr zu unterscheiden. </li><li>  Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet</a> Trace-Daten, um den kritischen Pfad zu analysieren und den Datenverkehr während regelmäßiger Disaster Recovery-Tests zu wechseln. </li><li>  Das soziale Netzwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet auch</a> Jupyter-Notizbücher, mit denen Entwickler beliebige Abfragen zu den Ergebnissen der Ablaufverfolgung ausführen können. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LDFI-</a> Anhänger (Lineage Driven Failure Injection <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwenden</a> verteilte Traces für Fehlertests. </li></ul><br>  Keine der oben genannten Optionen bezieht sich vollständig auf das <i>Debugging-</i> Szenario, in dem der Techniker versucht, das Problem durch Betrachten der Ablaufverfolgung zu lösen. <br><br>  Wenn es um das Debugging-Szenario geht, bleibt das <i>Traceview-</i> Diagramm die primäre Schnittstelle (obwohl einige es auch als <i>"Gantt-Diagramm"</i> oder <i>"Kaskadendiagramm" bezeichnen</i> ).  Mit <i>Traceview</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine</a> ich alle <i>Bereiche</i> und zugehörigen Metadaten, die zusammen Trace bilden.  Jedes Open-Source-Trace-System sowie jede kommerzielle Trace-Lösung bietet eine auf <i>Traceview</i> basierende Benutzeroberfläche zum Visualisieren, Detaillieren und Filtern von Trace-Daten. <br><br>  Das Problem bei allen Trace-Systemen, mit denen ich im Moment vertraut bin, ist, dass die endgültige <i>Visualisierung (Trace-Ansicht)</i> die Funktionen des Trace-Generierungsprozesses fast vollständig widerspiegelt.  Selbst wenn alternative Visualisierungen angeboten werden: Intensitätskarten (Heatmap), Servicetopologien, <i>Latenzhistogramme</i> - am Ende kommt es immer noch auf die <i>Trace-Ansicht an</i> . <br><br>  In der Vergangenheit habe ich mich darüber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschwert,</a> dass die meisten „Innovationen“ bei der Rückverfolgbarkeit in Bezug auf UI / UX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">darauf</a> beschränkt zu sein scheinen, zusätzliche Metadaten in die Ablaufverfolgung aufzunehmen, Informationen mit <i>hoher Kardinalität</i> in diese einzubetten oder die Möglichkeit zu bieten, einen Drilldown auf bestimmte Bereiche durchzuführen oder <i>Inter- und Intra-Trace-</i> Abfragen ausführen.  In diesem Fall bleibt die <i>Trace-Ansicht</i> das <i>Hauptvisualisierungsmittel</i> .  Solange dieser Zustand anhält, wird die verteilte Ablaufverfolgung (bestenfalls) als Debugging-Tool den 4. Platz einnehmen, gefolgt von Metriken, Protokollen und Stapelverfolgungen, und im schlimmsten Fall wird es sich als Geld- und Zeitverschwendung herausstellen. <br><br><h2>  Problem mit Traceview </h2><br>  Der Zweck der <i>Ablaufverfolgungsansicht</i> besteht darin, ein vollständiges Bild der Bewegung einer einzelnen Anforderung über alle Komponenten eines verteilten Systems bereitzustellen, auf das sie sich bezieht.  Mit einigen fortschrittlicheren Ablaufverfolgungssystemen können Sie einen Drilldown zu einzelnen Bereichen durchführen und die Zeitaufteilung <i>innerhalb eines</i> einzelnen Prozesses anzeigen (wenn Bereiche funktionale Grenzen haben). <br><br>  Die Grundvoraussetzung der Microservices-Architektur ist die Idee, dass die Organisationsstruktur mit den Anforderungen des Unternehmens wächst.  Befürworter von Microservices argumentieren, dass die Verteilung verschiedener Geschäftsaufgaben auf separate Services es kleinen, autonomen Entwicklungsteams ermöglicht, den gesamten Lebenszyklus solcher Services zu steuern und diese Services unabhängig zu erstellen, zu testen und bereitzustellen.  Der Nachteil dieser Verteilung ist jedoch der Verlust von Informationen darüber, wie jeder Dienst mit anderen interagiert.  Unter solchen Umständen sind verteilte Ablaufverfolgungsansprüche ein unverzichtbares Werkzeug zum <i>Debuggen</i> komplexer Interaktionen zwischen Diensten. <br><br>  Wenn Sie ein wirklich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstaunlich komplexes verteiltes System haben</a> , kann sich niemand das <i>vollständige</i> Bild merken.  Tatsächlich ist die Entwicklung eines Tools, das auf der Annahme basiert, dass es im Allgemeinen möglich ist, ein bisschen antimuster (ineffizienter und unproduktiver Ansatz).  Im Idealfall erfordert das Debuggen ein Tool, mit dem Sie <i>Ihre Suche</i> eingrenzen können, damit sich die Ingenieure auf eine Teilmenge der Dimensionen (Dienste / Benutzer / Hosts usw.) konzentrieren können, die für das betreffende Szenario relevant sind.  Bei der Ermittlung der Fehlerursache müssen die Ingenieure nicht verstehen, was in <i>allen Diensten gleichzeitig</i> passiert ist, da eine solche Anforderung der Idee einer Microservice-Architektur widersprechen würde. <br><br>  Traceview ist jedoch <i>genau</i> das.  Ja, einige Trace-Systeme bieten komprimierte Trace-Ansichten, wenn die Anzahl der Spans im Trace so groß ist, dass sie nicht in einer einzigen Visualisierung angezeigt werden können.  Aufgrund der großen Menge an Informationen, die selbst in einer derart reduzierten Visualisierung enthalten sind, sind die Ingenieure jedoch immer noch <i>gezwungen, diese zu</i> „sichten“ und die Auswahl manuell auf eine Reihe von Servicequellen für Probleme zu beschränken.  Leider sind Maschinen auf diesem Gebiet viel schneller als Menschen, weniger fehleranfällig und ihre Ergebnisse sind wiederholbarer. <br><br>  Ein weiterer Grund, warum ich die Traceview-Methode für falsch halte, ist, dass sie nicht für das hypothetische Debuggen geeignet ist.  Das Debuggen ist im Kern ein <i>iterativer</i> Prozess, der mit einer Hypothese beginnt, gefolgt von der Überprüfung verschiedener Beobachtungen und Fakten, die vom System erhalten wurden, unter Verwendung verschiedener Vektoren, Schlussfolgerungen / Verallgemeinerungen und einer weiteren Bewertung der Wahrheit der Hypothese. <br><br>  Die Fähigkeit <i>,</i> Hypothesen <i>schnell und kostengünstig zu</i> testen und das mentale Modell entsprechend zu verbessern, ist der <i>Eckpfeiler des</i> Debuggens.  Jedes Debugging-Tool sollte <i>interaktiv sein</i> und den Suchraum einschränken oder im Falle einer falschen Ablaufverfolgung dem Benutzer ermöglichen, zurück zu gehen und sich auf einen anderen Bereich des Systems zu konzentrieren.  Ein ideales Tool erledigt dies <i>proaktiv</i> und macht den Benutzer sofort auf potenziell problematische Bereiche aufmerksam. <br><br>  <i>Leider</i> kann <i>Traceview</i> nicht als interaktives Schnittstellentool bezeichnet werden.  Das Beste, auf das Sie bei der Verwendung hoffen können, ist, eine bestimmte Quelle erhöhter Verzögerungen zu erkennen und alle damit verbundenen Tags und Protokolle anzuzeigen.  Dies hilft dem Ingenieur nicht, Verkehrsmuster wie die Besonderheiten der Verteilung von Verzögerungen zu identifizieren oder Korrelationen zwischen verschiedenen Messungen zu erkennen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die generische Trace-Analyse</a> kann einige dieser Probleme umgehen.  In der Tat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es Beispiele für eine</a> erfolgreiche Analyse unter Verwendung von maschinellem Lernen, um abnormale Bereiche zu identifizieren und eine Teilmenge von Tags zu identifizieren, die mit abnormalem Verhalten verbunden sein können.  Trotzdem bin ich noch nicht auf überzeugende Visualisierungen von Funden gestoßen, die mithilfe von maschinellem Lernen oder Datenanalyse auf Bereiche angewendet wurden, die sich erheblich von Traceview oder DAG (direktionaler azyklischer Graph) unterscheiden würden. <br><br><h3>  Die Spannweiten sind zu niedrig </h3><br>  Das grundlegende Problem bei der Trace-Ansicht besteht darin, dass <i>Spans</i> sowohl für die Latenzanalyse als auch für die Ursachenanalyse zu niedrige Grundelemente sind.  Es ist so, als würde man einzelne Prozessorbefehle analysieren, um eine Ausnahme zu beseitigen, da man weiß, dass es viel übergeordnete Tools wie Backtrace gibt, mit denen man viel bequemer arbeiten kann. <br><br>  Darüber hinaus werde ich mir erlauben, Folgendes zu behaupten: Im Idealfall benötigen wir kein <i>vollständiges Bild</i> dessen, was während des Lebenszyklus der Anfrage passiert ist, was moderne Tools zur Rückverfolgung darstellen.  Stattdessen ist eine Form der Abstraktion auf höherer Ebene erforderlich, die Informationen darüber enthält, was <i>schief gelaufen ist</i> (ähnlich wie bei der Rückverfolgung), sowie einen gewissen Kontext.  Anstatt die gesamte Spur zu beobachten, sehe ich lieber einen <i>Teil</i> davon, wo etwas Interessantes oder Ungewöhnliches passiert.  Derzeit wird die Suche manuell durchgeführt: Der Ingenieur erhält eine Ablaufverfolgung und analysiert unabhängig voneinander die Spannweiten auf der Suche nach etwas Interessantem.  Der Ansatz, wenn Personen in der Hoffnung, verdächtige Aktivitäten zu erkennen, auf Bereiche in getrennten Spuren starren, ist überhaupt nicht skalierbar (insbesondere, wenn sie alle in verschiedenen Bereichen codierten Metadaten wie Span-ID, RPC-Methodenname und Span-Dauer erfassen müssen 'a, Protokolle, Tags usw.). <br><br><h2>  Traceview-Alternativen </h2><br>  Verfolgungsergebnisse sind am nützlichsten, wenn sie so visualisiert werden können, dass eine nicht triviale Vorstellung davon entsteht, was in den miteinander verbundenen Teilen des Systems geschieht.  Bis dies der Fall ist, bleibt der Debugging-Prozess weitgehend <i>inert</i> und hängt von der Fähigkeit des Benutzers ab, die richtigen Korrelationen zu erkennen, die richtigen Teile des Systems zu überprüfen oder Teile des Mosaiks zusammenzusetzen - im Gegensatz zu dem <i>Tool</i> , mit dem der Benutzer diese Hypothesen formulieren kann. <br><br>  Ich bin kein visueller Designer oder UX-Spezialist, aber im nächsten Abschnitt möchte ich einige Ideen dazu teilen, wie solche Visualisierungen aussehen könnten. <br><br><h3>  Konzentrieren Sie sich auf bestimmte Dienstleistungen </h3><br>  In einem Umfeld, in dem sich die Branche auf die Ideen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SLO (Service Level Objectives) und SLI (Service Level Indicators) konzentriert</a> , erscheint es sinnvoll, dass einzelne Teams zunächst die Relevanz ihrer Services für diese Ziele überwachen.  Daraus folgt, dass eine <i>serviceorientierte</i> Visualisierung für solche Teams am besten geeignet ist. <br><br>  Spuren, insbesondere ohne Stichproben, sind ein Informationsspeicher für jede Komponente eines verteilten Systems.  Diese Informationen können an einen kniffligen Handler weitergeleitet werden, der den Benutzern serviceorientierte Fundstücke liefert, die im Voraus erkannt werden können - noch bevor der Benutzer die Spuren betrachtet: <br><br><ol><li>  Verzögerungsverteilungsdiagramme nur für stark differenzierte Anforderungen <i>(Ausreißeranforderungen)</i> ; </li><li>  Verzögerungsverteilungsdiagramme für Fälle, in denen SLO-Serviceziele nicht erreicht werden; </li><li>  Die "häufigsten", "interessantesten" und "seltsamsten" Tags in Abfragen, die am häufigsten <i>wiederholt werden</i> . </li><li>  Aufschlüsselung der Verzögerungen für Fälle, in denen Dienstabhängigkeiten die festgelegten SLO-Ziele nicht erreichen; </li><li>  Aufschlüsselung der Verzögerungen für verschiedene nachgelagerte Dienste. </li></ol><br>  Integrierte Metriken können einige dieser Fragen einfach nicht beantworten, sodass Benutzer die Bereiche sorgfältig untersuchen müssen.  Infolgedessen haben wir einen äußerst feindlichen Mechanismus für den Benutzer. <br><br>  In diesem Zusammenhang stellt sich die Frage: Was ist mit den komplexen Wechselwirkungen zwischen den verschiedenen Diensten, die von verschiedenen Teams gesteuert werden?  Wird <i>Traceview</i> nicht als das am besten geeignete Tool zur Abdeckung einer solchen Situation angesehen? <br><br>  Mobile Entwickler, Eigentümer von zustandslosen Diensten, Eigentümer von verwalteten Stateful Services (wie Datenbanken) und Plattformbesitzer sind möglicherweise an einer anderen <i>Ansicht eines</i> verteilten Systems interessiert.  <i>traceview</i> ist eine viel zu universelle Lösung für diese grundlegend unterschiedlichen Anforderungen.  Selbst in einer sehr komplexen Microservice-Architektur benötigen Service-Eigentümer keine gründlichen Kenntnisse über mehr als zwei oder drei Upstream- und Downstream-Services.  Im Wesentlichen müssen Benutzer in den meisten Szenarien nur Fragen zu einem <i>begrenzten Satz von Diensten</i> beantworten. <br><br>  Es ist, als würde man eine kleine Untergruppe von Diensten durch eine Lupe betrachten, um genau zu studieren.  Auf diese Weise kann der Benutzer dringendere Fragen zur komplexen Interaktion zwischen diesen Diensten und ihren unmittelbaren Abhängigkeiten stellen.  Dies ähnelt der Rückverfolgung in der Welt der Dienste, in der der Ingenieur weiß, <i>was</i> falsch ist, und auch eine Vorstellung davon hat, was in den umliegenden Diensten geschieht, um zu verstehen, <i>warum</i> . <br><br>  Der Ansatz, den ich fördere, ist das genaue Gegenteil des Top-Down-Ansatzes basierend auf der Trace-Ansicht, wenn die Analyse mit der gesamten Trace beginnt und dann allmählich auf einzelne Bereiche abfällt.  Im Gegenteil, der Bottom-up-Ansatz beginnt mit einer Analyse eines kleinen Bereichs in der Nähe der potenziellen Ursache des Vorfalls. Anschließend wird der Suchraum bei Bedarf erweitert (unter Einbeziehung anderer Teams zur Analyse eines breiteren Leistungsspektrums).  Der zweite Ansatz ist besser geeignet, um anfängliche Hypothesen schnell zu testen.  Nachdem Sie bestimmte Ergebnisse erhalten haben, können Sie mit einer genaueren und detaillierteren Analyse fortfahren. <br><br><h3>  Topologiegebäude </h3><br>  Die mit einem bestimmten Dienst verknüpften Ansichten können unglaublich nützlich sein, wenn der Benutzer weiß, <i>welcher</i> Dienst oder welche Gruppe von Diensten für zunehmende Verzögerungen verantwortlich ist oder eine Fehlerquelle darstellt.  In einem komplexen System ist das Identifizieren eines Eindringlings während eines Fehlers möglicherweise keine triviale Aufgabe, insbesondere wenn keine Fehlermeldungen von den Diensten empfangen wurden. <br><br>  Das Erstellen einer Servicetopologie kann sehr hilfreich sein, um herauszufinden, welcher Service einen Anstieg der Fehlerrate oder eine Erhöhung der Latenz aufweist, was zu einer spürbaren Verschlechterung der Serviceleistung führt.  Wenn ich über das Erstellen einer Topologie spreche, meine ich nicht <i>eine Dienstkarte</i> , die jeden im System verfügbaren <i>Dienst</i> anzeigt und für seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturkarten in Form eines Todessterns bekannt ist</a> .  Eine solche Darstellung ist nicht besser als eine Trace-Ansicht, die auf einem gerichteten azyklischen Graphen basiert.  Stattdessen möchte ich eine <i>dynamisch generierte Diensttopologie sehen,</i> die auf bestimmten Attributen wie Fehlerrate, Antwortzeit oder einem benutzerdefinierten Parameter basiert, der zur Klärung der Situation mit bestimmten verdächtigen Diensten beiträgt. <br><br>  Schauen wir uns ein Beispiel an.  Stellen Sie sich eine hypothetische Nachrichtenseite vor.  Der <i>Titelseitendienst</i> kommuniziert mit Redis über einen Empfehlungsdienst, einen Werbedienst und einen Videodienst.  Der Videodienst nimmt Videos aus S3 und die Metadaten aus DynamoDB auf.  Der Empfehlungsdienst empfängt Metadaten von DynamoDB, lädt Daten von Redis und MySQL herunter und schreibt Nachrichten an Kafka.  Der Werbedienst empfängt Daten von MySQL und schreibt Nachrichten an Kafka. <br><br>  Das Folgende ist eine schematische Darstellung dieser Topologie (viele kommerzielle Routing-Programme bauen die Topologie auf).  Dies kann nützlich sein, wenn Sie die Abhängigkeiten von Diensten verstehen müssen.  Während des <i>Debuggens</i> ist eine solche Topologie jedoch nicht sehr nützlich, wenn ein bestimmter Dienst (z. B. ein Videodienst) eine längere Antwortzeit aufweist. <br><br><img src="https://habrastorage.org/webt/qr/85/y9/qr85y98gth6ybvwt5yuditlnack.png"><br>  <i>Hypothetical News Site Services Scheme</i> <br><br>  Das folgende Diagramm wäre besser.  Darauf <i>ist</i> in der Mitte ein problematischer Dienst <i>(Video)</i> abgebildet.  Der Benutzer bemerkt ihn sofort.  Aus dieser Visualisierung wird deutlich, dass der Videodienst aufgrund der erhöhten Antwortzeit von S3, die sich auf die Download-Geschwindigkeit eines Teils der Hauptseite auswirkt, nicht ordnungsgemäß funktioniert. <br><br><img src="https://habrastorage.org/webt/v2/w5/za/v2w5zaf_s1_r8mzo0j6r2dopyyk.png"><br>  <i>Dynamische Topologie, die nur „interessante“ Dienste anzeigt</i> <br><br>  Dynamisch generierte topologische Schemata können effizienter sein als statische Service-Maps, insbesondere in flexiblen, automatisch skalierbaren Infrastrukturen.  Durch die Möglichkeit, Diensttopologien zu vergleichen und gegenüberzustellen, kann der Benutzer relevantere Fragen stellen.  Genauere Fragen zum System führen eher zu einem besseren Verständnis der Funktionsweise des Systems. <br><br><h3>  Vergleichsanzeige </h3><br>  Eine weitere nützliche Visualisierung wäre eine vergleichende Anzeige.  Spuren sind derzeit nicht gut für Vergleiche nebeneinander geeignet, daher werden <i>Spannweiten</i> normalerweise verglichen.  Die Hauptidee dieses Artikels ist genau, dass die Spannweiten zu niedrig sind, um die wertvollsten Informationen aus den Trace-Ergebnissen zu extrahieren. <br><br>  Der Vergleich zweier trace'ov erfordert keine grundlegend neuen Visualisierungen.  In der Tat ist so etwas wie ein Histogramm ausreichend, das die gleichen Informationen wie die Trace-Ansicht darstellt.  Überraschenderweise kann selbst diese einfache Methode viel mehr Früchte bringen als eine einfache Untersuchung von zwei Spuren getrennt.  Noch leistungsfähiger wäre die Möglichkeit, <i>den</i> Vergleich von Spuren <i>im Aggregat</i> zu <i>visualisieren</i> .  Es wäre äußerst nützlich zu sehen, wie sich eine kürzlich bereitgestellte Änderung der Datenbankkonfiguration unter Einbeziehung von GC (Garbage Collection) auf die Antwortzeit eines nachgeschalteten Dienstes in wenigen Stunden auswirkt.  Wenn das, was ich hier beschreibe, wie eine A / B-Analyse der Auswirkungen von Infrastrukturänderungen <i>in einer Vielzahl von Diensten unter</i> Verwendung von Trace-Ergebnissen erscheint, sind Sie nicht zu weit von der Wahrheit entfernt. <br><br><h2>  Fazit </h2><br>  Ich bezweifle nicht die Nützlichkeit der Spur selbst.  Ich bin der festen Überzeugung, dass es keinen anderen Weg gibt, so umfangreiche, zufällige und kontextbezogene Daten zu sammeln als die in der Spur enthaltenen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich glaube jedoch auch, dass alle Tracing-Lösungen diese Daten äußerst ineffizient verwenden. </font><font style="vertical-align: inherit;">Solange die Tools für die Ablaufverfolgung in der Ablaufverfolgungsdarstellung fixiert sind, können sie nur begrenzt wertvolle Informationen verwenden, die aus den in den Ablaufverfolgungen enthaltenen Daten extrahiert werden können. </font><font style="vertical-align: inherit;">Darüber hinaus besteht die Gefahr der Weiterentwicklung einer völlig unfreundlichen und nicht intuitiven visuellen Oberfläche, die die Fähigkeit des Benutzers, Fehler in der Anwendung zu beheben, erheblich einschränkt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Debuggen komplexer Systeme ist selbst mit den neuesten Tools unglaublich komplex. </font><font style="vertical-align: inherit;">Die Werkzeuge sollten die Entwicklern zu formulieren und zu </font><font style="vertical-align: inherit;">testen Hypothesen helfen, die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktive Bereitstellung von</font></font></b>  ,        .  ,           production   ,   ,      ,       ,     . <br><br>    ,   ,     ,    , ,      .  ,         ,      ,     trace'  span'. <br><br>           (  UI). ,         ,        .        ,           .           .      . <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> kubectl-debug    pod' Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:   ,     Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Kubernetes (   )</a> ». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460365/">https://habr.com/ru/post/de460365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460353/index.html">Neuronales Netz im Glas. Benötigt keinen Strom, erkennt Zahlen</a></li>
<li><a href="../de460355/index.html">Das Ertrinken zu retten ist unser Geschäft: wie man mit Teamdemotivation umgeht</a></li>
<li><a href="../de460359/index.html">Young Game Designer 2 Kurs: Balance zwischen Fortschritt und Dynamik ohne Mathematik</a></li>
<li><a href="../de460361/index.html">Tolle FAQ zur Cybersicherheit von medizinischen Informationssystemen</a></li>
<li><a href="../de460363/index.html">7 fehlende Faktoren im Ansatz 12 Faktor App</a></li>
<li><a href="../de460367/index.html">Chaos Engineering: die Kunst der absichtlichen Zerstörung. Teil 1</a></li>
<li><a href="../de460373/index.html">Unter der Haube Turbo-Seiten: Architektur der Webseite Fast Download-Technologie</a></li>
<li><a href="../de460375/index.html">Buch "Maschinelles Lernen für Wirtschaft und Marketing"</a></li>
<li><a href="../de460377/index.html">Verwenden von Liquibase zum Verwalten der Datenbankstruktur in einer Spring Boot-Anwendung. Teil 1</a></li>
<li><a href="../de460381/index.html">Was ist Durchsetzungsvermögen und warum wird es benötigt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>