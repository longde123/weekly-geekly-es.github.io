<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗑️ 🚞 👩🏼‍🤝‍👨🏽 Algoritma interaksi ratusan ribu partikel unik pada GPU, dalam GLES3 dan WebGL2 🚵🏿 🙂 💒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deskripsi algoritma logika, dan analisis contoh kerja dalam bentuk game techno-demo 


 Versi webGL2 dari demo ini https://danilw.itch.io/flat-maze-we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma interaksi ratusan ribu partikel unik pada GPU, dalam GLES3 dan WebGL2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474676/"><h1 id="opisanie-algoritma-logiki-i-razbor-rabochego-primera-v-vide-tehno-demki-igry">  Deskripsi algoritma logika, dan analisis contoh kerja dalam bentuk game techno-demo </h1><br><p>  Versi webGL2 dari demo ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://danilw.itch.io/flat-maze-web untuk</a> tautan lain, lihat artikelnya. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HawWnuMn1mc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="statya-razbita-na-dve-chasti-snachala-pro-logiku-i-vtoraya-chast-pro-primenenie-v-igre-pervaya-chast">  Artikel ini dibagi menjadi dua bagian, pertama tentang logika, dan bagian kedua tentang aplikasi dalam permainan, bagian <em>pertama</em> : </h3><br><ul><li>  Fitur Utama </li><li>  Tautan dan deskripsi singkat. </li><li>  Algoritma logika. </li><li> Keterbatasan logika.  Bug / fitur, dan Bug sudut. </li><li>  Akses ke data indeks. </li></ul><br><h3 id="dalshe-opisanie-igrovoy-demki-vtoraya-chast">  Penjelasan lebih lanjut tentang demo game, bagian <em>kedua</em> : </h3><br><ul><li>  Fitur yang digunakan dari logika ini.  Dan rendering cepat satu juta partikel piksel. </li><li>  Implementasi, beberapa komentar pada kode, deskripsi tabrakan dalam dua arah.  Dan interaksi dengan pemain. </li><li>  Tautan ke grafik yang digunakan dengan opengameart, dan shader untuk bayangan.  Dan tautan artikel ke cyberleninka.ru </li></ul><a name="habracut"></a><br><h1 id="chast-1">  Bagian 1 </h1><br><h1 id="1-klyuchevye-osobennosti">  1. Fitur Utama </h1><br><p> <strong>Idenya</strong> adalah tabrakan / fisika dari ratusan ribu partikel di antara mereka, secara real time, di mana setiap partikel memiliki <code>ID</code> pengidentifikasi unik. </p><br><p>  Ketika setiap partikel diindeks, <strong>dimungkinkan untuk mengontrol parameter apa pun dari partikel apa pun</strong> , misalnya massa, kesehatannya (hp) atau kerusakan, akselerasi, perlambatan, yang menjadi objek yang ditemui dan reaksi terhadap peristiwa tersebut tergantung pada jenis / indeks partikel, juga pengatur waktu unik untuk setiap partikel. , dan seterusnya sesuai kebutuhan. </p><br><p>  <strong>Semua logika pada GLSL sepenuhnya portabel untuk mesin game</strong> dan OS apa pun yang memiliki dukungan GLES3. </p><br><p>  <em>Jumlah maksimum partikel</em> sama dengan ukuran framebuffer (fbo, semua piksel). </p><br><p>  <em>Sejumlah partikel yang nyaman</em> (ketika ada ruang bagi partikel untuk berinteraksi) adalah <code>(Resolution.x*Resolution.y/2)/2</code> adalah setiap piksel kedua dalam <code>x</code> dan setiap piksel kedua dalam <code>y</code> , itulah sebabnya deskripsi logika mengatakan demikian. </p><br><p>  Di bagian pertama artikel, logika minimal ditampilkan, di bagian kedua pada contoh permainan, logika dengan sejumlah besar kondisi interaksi. </p><br><h1 id="2-ssylki-i-kratkoe-opisanie">  2. Tautan dan deskripsi singkat </h1><br><p>  Saya membuat tiga demo pada logika ini: </p><br><p>  <strong>1. Pada GLSL fragmen-shader</strong> , pada shadertoy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.shadertoy.com/view/tstSz7</a> , lihat kode BufferC di dalamnya semua logika.  Kode ini juga memungkinkan Anda untuk menampilkan ratusan ribu partikel dengan UV-nya, dalam posisi sewenang-wenang, pada fragmen-shader tanpa menggunakan partikel yang dipasang. </p><br><p><img src="https://habrastorage.org/webt/8a/-w/l7/8a-wl7z8v954zwdyxqaph8eusao.png"></p><br><p>  <strong>2. Porting logic ke instance-partikel</strong> (digunakan oleh Godot sebagai mesin) </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fRu9PA4XHPQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi Web</a> , <a href="">exe (win)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> proyek <em>partikel_2D_self_collision</em> . </p><br><p>  Deskripsi singkat: <strong>Ini adalah demonstrasi buruk pada</strong> partikel yang dipasang, karena fakta bahwa saya membuat peningkatan maksimum di mana seluruh peta terlihat, 640x360 partikel (230k) selalu diproses, ini banyak.  <strong>Lihat di bawah dalam deskripsi permainan, di sana saya melakukannya dengan benar, tanpa partikel tambahan.</strong>  (ada kesalahan indeks partikel dalam video, ini diperbaiki dalam kode) </p><br><p>  <strong>3. Gim, tentangnya di bawah ini dalam deskripsi gim.</strong>  Tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi Web</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">exe (win)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> </p><br><h1 id="3-algoritm-raboty-logiki">  3. Algoritma logika </h1><br><p>  Secara singkat: </p><br><p>  Logikanya mirip dengan pasir jatuh, setiap piksel mempertahankan nilai fraksional dari posisi (bergeser dalam pikselnya) dan akselerasi saat ini. </p><br><p>  Logika memeriksa piksel dalam jari-jari 1, bahwa posisi mereka berikutnya ingin pergi ke piksel ini <em>(karena pembatasan ini, lihat batasan di bawah)</em> , juga piksel dalam jari-jari 2 untuk tolakan (benturan). </p><br><p>  Indeks unik disimpan dengan menerjemahkan logika ke int-float, dan mengurangi ukuran <code>pos</code> posisi dan kecepatan <code>pos</code> . </p><br><p>  Data disimpan dengan cara ini: <em>(karena bug ini, lihat batasan)</em> </p><br><pre> <code class="plaintext hljs">pixel.rgba r=[0xfffff-posx, 0xf-data] g=[0xfffff-posy, 0xf-data] b=[0xffff-velx, 0xff-data] a=[0xffff-vely, 0xff-data]</code> </pre> <br><p><img src="https://habrastorage.org/webt/46/ad/io/46adionlolw3vm5zfry5javhgxk.png"></p><br><p>  <strong>Dalam kode</strong> , nomor baris untuk BufC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.shadertoy.com/view/tstSz7</a> , 115 transisi-cek, 139 cek-tabrakan. </p><br><p>  Ini adalah loop sederhana untuk mengambil nilai yang berdekatan.  Dan kondisinya adalah, jika posisi diambil sama dengan posisi piksel saat ini, maka kami memindahkan data tersebut ke piksel ini <em>(karena batasan ini)</em> , dan nilai perubahan berubah tergantung pada piksel tetangga, jika ada. </p><br><p>  <em>Ini semua logika partikel.</em> </p><br><p>  <strong>Cara terbaik adalah menempatkan partikel pada jarak 1 pixel dari satu sama lain</strong> jika mereka lebih dekat dari 1 pixel, maka akan ada tolakan, sebagai contoh peta dengan labirin dalam permainan, partikel berdiri di tempat mereka tanpa bergerak karena jarak 1 pixel di antara mereka. </p><br><p>  Selanjutnya adalah rendering (rendering), <em>dalam kasus fragmen-shader,</em> piksel diambil dalam radius 1 untuk menampilkan area berpotongan.  <em>Dalam kasus partikel yang di-instansasikan, sebuah</em> piksel diambil pada alamat <code>INSTANCE_ID</code> diterjemahkan dari tampilan linear menjadi array dua dimensi. </p><br><h1 id="4-ogranicheniya-logiki-bagiosobennosti-i-bagi-angle">  4. Keterbatasan logika.  Bug / fitur, dan bug ANGLE </h1><br><ol><li>  <strong>Ukuran piksel</strong> , <code>BALL_SIZE</code> dalam kode, harus dalam batas perhitungan, lebih besar dari <code>sqrt(2)/2</code> dan kurang dari <code>1</code> .  Semakin dekat ke 1, semakin sedikit ruang untuk berjalan di dalam piksel (piksel itu sendiri), semakin sedikit ruang.  Ukuran seperti itu diperlukan agar piksel tidak saling jatuh, kurang dari 1 dapat diatur ketika Anda memiliki objek kecil, ilusi objek kurang dari 1 piksel (dihitung) dibuat. </li><li>  <strong>Kecepatan</strong> tidak boleh lebih dari <code>1</code> piksel jika tidak piksel akan hilang.  Tetapi untuk memiliki kecepatan lebih dari <code>1</code> per frame, Anda bisa, jika Anda membuat beberapa <em>framebuffer (fbo / viewport)</em> dan memproses beberapa langkah logika per frame-speed, itu akan meningkatkan jumlah kali sama dengan jumlah fbo tambahan.  Inilah yang saya lakukan di demo buah, dan menggunakan tautan ke shadertoy (bufC disalin ke bufD). </li><li>  <strong>Batasan tekanan</strong> (seperti gravitasi, atau peta gaya-normal lainnya).  Jika beberapa piksel tetangga mengambil posisi ini (lihat gambar di atas), maka hanya satu yang disimpan, piksel yang tersisa hilang.  <em>Ini mudah dilihat dalam demo di shadertoy,</em> atur tetikus ke Force, ubah nilai <code>MOUSE_F</code> pada <em>Common</em> menjadi <code>10</code> , dan arahkan partikel ke sudut layar, mereka akan menghilang satu sama lain.  Atau sama dengan nilai gravitasi <code>maxG</code> di <em>Common</em> . </li><li>  <strong>Bug di Sudut.</strong>  Agar logika ini bekerja di partikel-GPU (yang dipasang), yang terbaik (lebih murah, lebih cepat) untuk menghitung posisi, dan semua parameter partikel lainnya untuk tampilan, dalam <em>contoh-shader</em> .  Tetapi Angle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mengizinkan</a> penggunaan lebih dari satu fbo-tekstur untuk shader, sehingga perhitungan bagian dari logika harus ditransfer ke <em>Vertex-shader di</em> mana untuk mentransfer nomor indeks dari instance shader.  Inilah yang saya lakukan di kedua demo dengan partikel GPU. </li><li>  <strong>Bug serius</strong> di kedua demo (kecuali untuk game) nilai posisi akan hilang jika bukan kelipatan <code>1/0xfffff</code> tes bug ada di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.shadertoy.com/view/WdtSWS</a> <br>  Lebih tepatnya, ini bukan bug, dan memang seharusnya demikian, untuk kesederhanaan, sebagai bagian dari algoritma ini, saya menyebutnya bug. </li></ol><br><p>  <strong>Perbaiki bug:</strong> <br>  <em>Jangan mengonversi nilai posisi menjadi int-float</em> , karena <code>0xff</code> ini <code>0xff</code> hilang, 8 bit tersedia untuk data, tetapi nilai <code>0xffff</code> untuk data akan tetap, yang mungkin cukup untuk banyak hal. <br>  <em>Saya melakukan hal itu dalam demo game</em> , saya hanya menggunakan <code>0xffff</code> untuk data di mana jenis partikel, timer animasi, kesehatan disimpan, dan masih ada ruang kosong. </p><br><h1 id="5-dostup-k-dannym-po-indeksu">  5. Akses ke data indeks </h1><br><p>  instanced-partikel memiliki <code>INSTANCE_ID</code> sendiri, dibutuhkan piksel dari tekstur framebuffer dengan logika partikel (bufC, contoh untuk shader), jika di sana kita membongkar partikel (lihat penyimpanan data) <em>ID partikel ini</em> , dengan <em>ID ini</em> kita membaca tekstur dengan data untuk partikel (bufB , contoh pada shader). </p><br><p>  Dalam contoh shadertoy, bufB hanya menyimpan warna untuk setiap partikel, tetapi jelas bahwa ada data apa pun, seperti massa, akselerasi, deselerasi yang ditulis sebelumnya, serta tindakan logis apa pun (misalnya, Anda dapat memindahkan partikel apa pun ke posisi apa pun (teleport) jika dilakukan tindakan logis yang sesuai dalam kode), Anda juga dapat mengontrol pergerakan partikel atau grup dari keyboard ... </p><br><p>  <strong>Maksud saya, Anda dapat melakukan apa saja dengan setiap partikel seolah-olah mereka adalah partikel biasa dalam sebuah array pada prosesor, akses dua arah dari partikel GPU dapat mengubah keadaannya, tetapi juga dari CPU Anda dapat mengubah keadaan partikel dengan indeks (menggunakan tindakan dan tekstur logis) buffer data).</strong> </p><br><h1 id="chast-2">  Bagian 2 </h1><br><h1 id="1-ispolzuemye-vozmozhnosti-etoy-logiki-i-bystryy-rendering-milliona-chastic-pikseley">  1. Fitur yang digunakan dari logika ini.  Dan rendering cepat satu juta partikel piksel </h1><br><p>  Ukuran framebuffer (fbo / viewport) untuk partikel adalah 1280x720, bagian-bagiannya terletak setelah 1, ini adalah 230 ribu partikel aktif (elemen aktif dalam labirin). <br>  <em>Selalu ada tidak lebih dari 12 ribu partikel GPU di layar.</em> </p><br><p>  <strong>Logika menggunakan:</strong> </p><br><ul><li>  Logika pemain terpisah dari partikel logika, dan hanya membaca data dari buffer partikel. </li><li>  Pemain melambat saat bertabrakan dengan benda. </li><li>  Objek tipe monster memberikan damage kepada pemain. </li><li>  Pemain memiliki 2 serangan, satu mengusir semua yang ada di sekitar, yang kedua menciptakan partikel seperti <em>bola api</em> (gambarnya seperti ini) </li><li>  Jenis <em>bola api</em> memiliki massa sendiri, dan pelacakan tabrakan bilateral dengan partikel lainnya bekerja. </li><li>  partikel lain seperti <em>gips</em> dan <em>zombie</em> (satu jenis gips kebal) dihancurkan dalam tabrakan dengan <em>bola api</em> </li><li>  <em>bola api</em> padam setelah satu tabrakan </li><li>  Tingkat <em>fisika</em> - pohon dan kotak ditolak oleh pemain, partikel lain tidak berinteraksi, tidak ada akselerasi yang bekerja pada <em>bola api</em> </li><li>  timer animasi unik untuk setiap partikel </li></ul><br><p>  Dibandingkan dengan demo buah, di mana ada overhead, <strong>dalam game ini jumlah partikel yang dipasang GPU hanya 12 ribu.</strong> </p><br><p>  Ini terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/lk/kt/9-/lkkt9-59aoftj47pqbpy4q5anfk.png"></p><br><p>  Jumlahnya bergantung pada zoom saat ini ( <em>zoom</em> ) peta, dan kenaikannya terbatas pada nilai tertentu, jadi hanya yang terlihat di layar yang dipertimbangkan. <br>  Layar bergeser dengan pemain, logika untuk menghitung pergeseran agak rumit, dan sangat situasional, saya ragu bahwa dia akan menemukan aplikasi di proyek lain. </p><br><h1 id="2-realizaciya-nemnogo-kommentariev-k-kodu">  2. Implementasi, beberapa komentar pada kode. </h1><br><p>  Semua kode game ada di GPU. </p><br><p>  <strong>Logika untuk menghitung perpindahan partikel</strong> di layar dengan peningkatan fungsi <em>simpul</em> di file / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shaders/scene2/particle_logic2.shader</a> adalah file shader partikel (vertex dan fragmen), bukan shader yang di- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instal,</a> shader yang di- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instal</a> tidak melakukan apa-apa, hanya melewati indeksnya karena bug yang dijelaskan di atas. </p><br><p>  <strong>partikel berdasarkan jenis</strong> dan seluruh logika interaksi partikel dalam file, ini adalah file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frame</a> shader shader file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader / scene2 / Particles_fbo_logic.shader</a> </p><br><pre> <code class="plaintext hljs">// 1-2 ghost // 3-zombi // 4-18 blocks // +20 is on fire // 40 is bullet(right) 41 left 42 top 43 down</code> </pre> <br><p>  pixel <strong>penyimpanan data</strong> <code>[pos.x, pos.y, [0xffff-vel.x, 0xff-data1],[0xffff-vel.y, 0xff-data2]]</code> <br>  data1 adalah tipe, data2 adalah HP atau timer. </p><br><p>  <em>Timer berjalan dalam bingkai di setiap partikel</em> , nilai maksimum timer adalah 255, saya tidak perlu begitu banyak, saya hanya menggunakan maksimum 1-16 ( <code>0xf</code> ), dan <code>0xf</code> tetap tidak digunakan di mana misalnya Anda dapat menyimpan nilai HP nyata, itu tidak digunakan untuk saya.  ( <code>0xf</code> , <strong>saya menggunakan <code>0xff</code> untuk timer</strong> , tetapi sebenarnya saya hanya memiliki kurang dari 16 frame animasi, dan <code>0xf</code> cukup, tetapi saya tidak memerlukan data tambahan) <br>  Sebenarnya <code>0xff</code> digunakan hanya pada penghitung waktu pembakaran pohon, mereka berubah menjadi zombie setelah 255 frame.  Logika pengatur waktu sebagian dalam <code>type_hp_logic</code> dalam shader framebuffer partikel (tautan di atas). </p><br><h1 id="primer-raboty-kollizii-v-dve-storony-kogda-fireball-gasnet-pri-pervom-udare-i-obekt-s-kotorym-byl-udar-tozhe-vypolnyaet-svoe-deystvie">  <strong>Contoh operasi tabrakan dua arah</strong> ketika <em>bola api</em> padam pada serangan pertama, dan objek yang terkena juga melakukan aksinya. </h1><br><p>  File <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shaders / scene2 /icles_fbo_logic.shader</a> baris 438: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((real_index == <span class="hljs-number"><span class="hljs-number">40</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">41</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">42</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">43</span></span>)) &amp;&amp; (type_hp.y &gt; <span class="hljs-number"><span class="hljs-number">22</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_id = get_id(fragCoord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(x), <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(y))); ivec2 htype_hp = unpack_type_hp(h_id); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hreal_index = htype_hp.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hreal_index != <span class="hljs-number"><span class="hljs-number">40</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">41</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">42</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">43</span></span>)) type_hp.y = <span class="hljs-number"><span class="hljs-number">22</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!need_upd) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_id = get_id(fragCoord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(x), <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(y))); ivec2 htype_hp = unpack_type_hp(h_id); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hreal_index = htype_hp.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((hreal_index == <span class="hljs-number"><span class="hljs-number">40</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">41</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">42</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">43</span></span>)) &amp;&amp; (htype_hp.y &gt; <span class="hljs-number"><span class="hljs-number">22</span></span>)) { need_upd = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }</code> </pre> <br><p>  <code>real_index</code> adalah tipe, tipe tercantum di atas, 40-43 adalah <em>bola api</em> . <br>  lanjut <code>type_hp.y &gt; 22</code> adalah nilai dari timer, jika lebih besar dari 22 maka <em>bola api</em> tidak menemukan apa pun. <br>  <code>h_id = get_id(...</code> ambil nilai tipe dan HP (timer) dari partikel yang ditemukan <br>  <code>hreal_index != 40...</code> jenis yang diabaikan ( <em>bola api</em> lainnya) <br>  <code>type_hp.y = 22</code> timer diatur ke 22, ini merupakan indikator bahwa <em>bola api</em> ini bertabrakan dengan satu objek. <br>  <code>else { if (!need_upd)</code> variabel need_upd memeriksa bahwa tidak ada tabrakan berulang, karena fungsinya dalam satu lingkaran, kita menemukan satu <em>bola api</em> . <br>  <code>h_id = get_id(...</code> jika belum ada tabrakan, kami mengambil objek bertipe dan timer. <br>  <code>hreal_index == 40...htype_hp.y &gt; 22</code> bahwa objek tabrakan adalah <em>bola api</em> dan tidak padam. <br>  <code>need_upd = true</code> flag bahwa perlu memperbarui jenis karena menemukan <em>bola api</em> . </p><br><p>  baris selanjutnya 481 <br>  <code>if((need_upd)&amp;&amp;(real_index&lt;24)){</code> real_index &lt;24 berdasarkan jenis kurang dari 24 ada pohon zombie dan hantu yang tidak terbakar, dan kemudian dalam kondisi ini kami memperbarui jenisnya tergantung pada jenis saat ini. </p><br><p>  Dengan demikian, hampir semua interaksi objek dapat dilakukan. </p><br><h1 id="vzaimodeystvie-s-igrokom">  <strong>Interaksi dengan pemain:</strong> </h1><br><p>  File <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shaders / scene2 / logic.shader</a> baris 143 berfungsi <code>player_collision</code> </p><br><p>  Logika ini membaca piksel di sekitar pemain dalam radius 4x4 piksel, mengambil posisi masing-masing piksel dan membandingkannya dengan posisi pemain, jika elemen ditemukan kemudian ketik pengecekan berikutnya, jika ini monster maka kita ambil HP dari pemain. </p><br><p>  <em>Ini berfungsi sedikit tidak akurat dan saya tidak ingin memperbaikinya</em> , fungsi ini dapat dibuat lebih akurat. </p><br><p>  <strong>Partikel mendorong menjauh dari pemain dan efek tolakan selama serangan:</strong> </p><br><p>  Framebuffer (viewport) digunakan untuk menulis normal dari aksi saat ini, dan partikel ( <em>Partikel_fbo_logic.shader</em> ) mengambil tekstur ini (dari normal) di posisinya dan menerapkan nilai pada kecepatan dan posisinya.  Seluruh kode logika ini secara harfiah hanya beberapa baris, file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">force_collision.shader</a> </p><br><p>  <strong>Pada klik tombol kiri mouse, peluru</strong> <em>fireball</em> <strong>terbang,</strong> penampilan mereka <em>tidak terlalu alami</em> , mereka tidak memperbaiki dan pergi dalam bentuk ini. </p><br><p>  Anda dapat membuat zona normal (bentuk) untuk memijah partikel dengan pergeseran yang muncul relatif terhadap pemain (ini tidak dilakukan). <br>  Atau Anda dapat menjadikan <em>bola api sebagai</em> objek terpisah sebagai pemain dan menggambar normal menjadi penyangga untuk mendorong partikel menjauh dari <em>bola api</em> , yaitu, dengan analogi dengan pemain ... <br>  Siapa yang perlu berpikir mereka akan mencari tahu sendiri. </p><br><h1 id="3-ssylki-na-ispolzuemuyu-grafiku-s-opengameart-i-sheyder-teney">  3. Tautan ke grafik yang digunakan dengan opengameart, dan shadow shader </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Saya diberi tautan ke artikel di cyberleninka.ru</strong></a> <br>  Di mana deskripsi algoritma yang saya gunakan, mungkin <em>ada deskripsi yang lebih rinci dan benar</em> daripada di artikel saya ini. </p><br><p>  <strong>Shadow shader</strong> bekerja sangat sederhana, berdasarkan pada shader ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.shadertoy.com/view/XsK3RR</a> (Saya memiliki kode yang dimodifikasi) <br>  Shader Membangun <em>1D Radial Lightmap</em> </p><br><p><img src="https://habrastorage.org/webt/e2/rh/op/e2rhopezigurqa3rkvhrb44vxxw.png"></p><br><p>  dan shading di lantai lukisan kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader / scene2 / mainImage.shader</a> </p><br><p>  <strong>Tautan ke grafik yang digunakan</strong> , semua grafik dalam game dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://opengameart.org</a> <br>  <em>fireball</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://opengameart.org/content/animated-traps-and-obstacles</a> <br>  karakter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://opengameart.org/content/legend-of-faune</a> <br>  pohon dan blok <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://opengameart.org/content/lolly-set-01</a> <br>  (dan beberapa foto lagi dengan opengameart) </p><br><p>  <strong>Grafik dalam menu</strong> diperoleh oleh 2D_GI shader, sebuah utilitas untuk membuat menu seperti itu: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTuG5UOMC74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Siapa yang membaca sampai akhir - dilakukan dengan baik :) <br>  Jika Anda memiliki pertanyaan, tanyakan, saya dapat melengkapi deskripsi berdasarkan permintaan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474676/">https://habr.com/ru/post/id474676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474664/index.html">Untuk meningkatkan perhatian, otak kita tidak meningkatkan konsentrasi, tetapi menggunakan filter informasi</a></li>
<li><a href="../id474666/index.html">Bagaimana tidak menulis ulang proyek di Rust</a></li>
<li><a href="../id474668/index.html">GitHub Berfungsi sebagai CI / CD untuk situs pada generator statis dan GitHub Pages</a></li>
<li><a href="../id474672/index.html">Bereaksi, JSX, impor modul ES (termasuk dinamis) di browser tanpa Webpack</a></li>
<li><a href="../id474674/index.html">Visi mesin dan obat-obatan</a></li>
<li><a href="../id474678/index.html">Khronos Group telah membuat repositori terpadu dengan contoh-contoh Vulkan</a></li>
<li><a href="../id474680/index.html">AI dan 2048. Bagian 2: Minimax + alpha beta clipping</a></li>
<li><a href="../id474686/index.html">Kisah fantastis "Keselamatan" (10 mnt)</a></li>
<li><a href="../id474688/index.html">Kereta retro dengan lokomotif uap</a></li>
<li><a href="../id474690/index.html">Membuat konsol dengan tinggi variabel untuk pekerjaan yang lebih nyaman di komputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>