<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖ üõ´ ‚úâÔ∏è Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 3: Buffer Overflows: Exploits and Protection, Part 1 üñêüèΩ ‚úãüèø üîö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "S√©curit√© des syst√®mes informatiques." Nikolai Zeldovich, James Mickens. 2014 ann√©e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 3: Buffer Overflows: Exploits and Protection, Part 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416839/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "S√©curit√© des syst√®mes informatiques."  Nikolai Zeldovich, James Mickens.  2014 ann√©e </h3><br>  Computer Systems Security est un cours sur le d√©veloppement et la mise en ≈ìuvre de syst√®mes informatiques s√©curis√©s.  Les conf√©rences couvrent les mod√®les de menace, les attaques qui compromettent la s√©curit√© et les techniques de s√©curit√© bas√©es sur des travaux scientifiques r√©cents.  Les sujets incluent la s√©curit√© du syst√®me d'exploitation (OS), les fonctionnalit√©s, la gestion du flux d'informations, la s√©curit√© des langues, les protocoles r√©seau, la s√©curit√© mat√©rielle et la s√©curit√© des applications Web. <br><br>  Cours 1: ¬´Introduction: mod√®les de menace¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conf√©rence 2: ¬´Contr√¥le des attaques de pirates¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conf√©rence 3: ¬´D√©bordements de tampon: exploits et protection¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Bienvenue √† la conf√©rence sur les exploits pour les d√©passements de tampon.  Aujourd'hui, nous terminerons la discussion sur les <b>limites</b> de <b>Baggy</b> , puis passerons √† d'autres m√©thodes de protection contre le d√©bordement de la m√©moire tampon. <br><br><img src="https://habrastorage.org/webt/oq/lp/5p/oqlp5prpdjjnr1e7sdxhtnp_pay.jpeg"><br><br>  Ensuite, nous parlerons des documents imprim√©s de la conf√©rence d'aujourd'hui, qui sont consacr√©s √† la <b>programmation orient√©e retour aveugle (BROP)</b> - la programmation orient√©e inverse aveugle.  Il s'agit d'une technique d'exploitation qui peut √™tre effectu√©e m√™me si l'attaquant n'a pas le binaire cible.  Ces exploits visent √† d√©truire les "canaris" dans les piles de syst√®mes 64 bits.  Donc, si vous √©tiez comme moi lorsque j'ai lu ces documents pour la premi√®re fois, vous auriez d√ª avoir envie de regarder le film de Christopher Nolan.  Ce n'√©tait qu'une explosion c√©r√©brale! <br><br>  Nous allons voir comment ces gadgets fonctionnent correctement.  Par cons√©quent, j'esp√®re qu'√† la fin de la conf√©rence, vous serez en mesure de comprendre toutes ces hautes technologies d√©crites dans le mat√©riel de la conf√©rence.  Mais d'abord, comme je l'ai dit, nous terminerons la discussion sur les <b>limites</b> de <b>Baggy</b> .  Prenons un exemple tr√®s simple. <br><br>  Supposons que nous allons assigner un pointeur <b>p</b> et lui allouer une taille de 44 octets.  Supposons √©galement que la taille de l'emplacement est de 16 octets. <br><br>  Que se passe-t-il lorsque nous attribuons la fonction <b>malloc</b> ?  Vous savez d√©j√† que dans ce cas le syst√®me de <b>limites Baggy</b> va essayer de compl√©ter cette distribution avec un logarithme <b>2n</b> .  Donc pour notre pointeur de 44 octets, 64 octets de m√©moire seront allou√©s.  Mais la taille de l'emplacement est de 16 octets, nous allons donc cr√©er 64/16 = 4 tables de limites de 16 octets chacune.  Chacune de ces entr√©es sera plac√©e dans le journal de distribution de taille. <br><br>  Ensuite, affectez un autre caract√®re de pointeur <b>* q = p + 60</b> .  Nous voyons que cette valeur est hors limites car la taille de <b>p</b> est de 44 octets, et ici elle est de 60 octets.  Mais <b>Baggy bounds</b> fonctionne de telle sorte que dans ce cas, rien de <b>mauvais</b> ne se produira, bien que le programmeur n'ait pas d√ª le faire. <br><br>  Supposons maintenant que la prochaine chose que nous faisons est d'attribuer un autre pointeur, qui sera √©gal √† <b>char * r = q + 16</b> .  Maintenant, cela provoquera une erreur, car la taille du d√©calage sera 60 + 16 = 76, ce qui est 12 octets de plus que les 4 emplacements (4x16 = 64 octets) <b>allou√©s par le</b> syst√®me <b>Baggy</b> .  Et cet exc√©dent repr√©sente vraiment plus de la moiti√© de la fente. <br><br><img src="https://habrastorage.org/webt/tr/dc/6t/trdc6tmpujijucydynnv2t5ojyw.jpeg"><br><br>  Si vous vous en souvenez, dans ce cas, le syst√®me <b>Baggy bounds r√©pondra</b> imm√©diatement √† une erreur de synchronisation critique, ce qui provoquera le plantage du programme et l'arr√™tera. <br><br>  Imaginons donc que nous ayons seulement deux lignes: <br><br>  <b>char * p = malloc (44)</b> <b><br></b>  <b>char * q = p + 60</b> <br><br>  Et il n'y a pas de troisi√®me ligne avec le code.  Au lieu de cela, nous ferons ceci: <br><br>  <b>char * s = q + 8</b> <br><br>  Dans ce cas, le pointeur aura une valeur de 60 + 8 = 68 bits, ce qui correspondra √† 4 octets de plus que les limites attribu√©es par les <b>limites Baggy</b> .  En fait, cela ne provoquera pas d'erreur critique, bien que la valeur d√©passe les limites.  Ce que nous avons fait ici est de d√©finir un bit d'ordre √©lev√© pour le pointeur.  Donc, si quelqu'un essaie par la suite de le d√©r√©f√©rencer, cela entra√Ænera une erreur critique √† ce stade. <br><br><img src="https://habrastorage.org/webt/xp/i-/p-/xpi-p-rmy0hsdh3f53yw6qrtb0o.jpeg"><br><br>  Et la derni√®re chose que nous ferons est d'attribuer un autre pointeur: <br><br>  <b>char * t = s - 32</b> <br><br>  En fait, nous l'avons fait - nous avons renvoy√© le pointeur √† la fronti√®re.  Donc, si initialement <b>s</b> allait au-del√†, nous l'avons maintenant retourn√© au volume allou√© √† l'origine que nous avons cr√©√© pour le pointeur.  Par cons√©quent, maintenant <b>t</b> n'aura pas de bit d'ordre √©lev√© dans sa composition, et il peut √™tre facilement d√©r√©f√©renc√©. <br><br><img src="https://habrastorage.org/webt/27/2g/y6/272gy657iydta1tibemfmgqhcxe.jpeg"><br><br>  <b>Public:</b> comment le programme sait-il que <b>r</b> a un exc√®s sup√©rieur √† la moiti√© de la pile? <br><br>  <b>Professeur Mickens:</b> notez que lorsque nous avons cr√©√© <b>r</b> , nous avons obtenu un code d'outil qui fonctionnera dans toutes ces op√©rations avec des pointeurs.  Nous pouvons donc dire o√π <b>q</b> sera situ√©, et nous savons qu'il est dans les <b>limites de Baggy</b> .  Par cons√©quent, lorsque nous effectuons cette op√©ration <b>q + 16</b> , les outils de <b>limites Baggy</b> savent d'o√π vient cette valeur initiale.  Et puis, si un d√©calage de cette taille d'origine <b>se produit</b> , les <b>limites Baggy</b> d√©termineront facilement que le d√©calage est sup√©rieur √† la moiti√© de la taille de la fente. <br><br>  En principe, lorsque vous effectuez des op√©rations avec des pointeurs, vous devez v√©rifier s'ils d√©passent ou non la taille allou√©e.  √Ä un moment donn√©, vous avez un pointeur situ√© dans les limites des limites de <b>Baggy</b> , puis quelque chose se produit qui le fait d√©passer les limites.  Donc, juste au moment o√π cela se produit, nous d√©couvrirons qu'une sorte de crochet ¬´sort¬ª de notre code. <br><br>  J'esp√®re que c'est compr√©hensible.  C'√©tait un tr√®s bref aper√ßu des devoirs, mais j'esp√®re que vous pourrez facilement le comprendre. <br><br>  Nous avons donc un pointeur qui ressemble √† ceci: <br><br>  <b>char * p = malloc (256)</b> , puis nous ajoutons le pointeur <b>char * q = p + 256</b> , apr√®s quoi nous allons essayer de d√©r√©f√©rencer ce pointeur. <br><br>  Alors que va-t-il se passer?  Eh bien, notez que 256 est une s√©quence <b>2n</b> , donc ce sera dans les <b>limites de Baggy</b> .  Par cons√©quent, lorsque nous ajoutons 256 bits suppl√©mentaires, cela signifie que nous effectuons un autre passage √† la fin des fronti√®res des <b>limites Baggy</b> .  Comme dans l'exemple pr√©c√©dent, cette ligne est assez bonne, mais elle conduit au fait qu'un bit d'ordre sup√©rieur sera d√©fini pour <b>q</b> .  Par cons√©quent, lorsque nous essayons de le d√©r√©f√©rencer, tout explosera et devra appeler notre agent d'assurance.  Est-ce clair? <br><br><img src="https://habrastorage.org/webt/mk/oe/hn/mkoehn3hnwp9d100bt_wre7a2xg.jpeg"><br><br>  √Ä partir de ces 2 exemples, vous pouvez comprendre le fonctionnement du syst√®me de <b>limites Baggy</b> .  Comme je l'ai mentionn√© dans la derni√®re conf√©rence, vous n'avez pas vraiment besoin d'instrumenter chaque op√©ration de pointeur si vous pouvez utiliser une analyse de code statique pour d√©couvrir qu'un ensemble sp√©cifique d'op√©rations de pointeur est s√ªr.  Je vais reporter la discussion de certaines analyses statiques, mais il suffit de dire que vous n'avez pas toujours besoin d'effectuer ces actions math√©matiques, nous l'avons d√©j√† v√©rifi√© auparavant. <br><br>  Une autre question qui est mentionn√©e sur Piazza: comment garantir la compatibilit√© des <b>limites</b> de <b>Baggy</b> avec les biblioth√®ques pr√©c√©dentes non li√©es aux outils.  L'id√©e est que lorsque les <b>limites Baggy</b> initialisent les tables de bordure, elles √©tablissent que tous les enregistrements doivent √™tre dans les 31 bits.  Par cons√©quent, lorsque nous lisons la table des limites, chaque enregistrement qu'il contient repr√©sente une valeur de la forme <b>2n + 31</b> .  Ainsi, en initialisant les limites initiales de la taille 31 bits, nous supposons que chaque pointeur aura la taille maximale possible de <b>2n + 31</b> .  Permettez-moi de vous donner un exemple tr√®s simple qui le clarifiera. <br><br>  Supposons que nous ayons un espace m√©moire que nous utilisons pour un tas.  Cet espace m√©moire est compos√© de deux composants.  En haut, nous avons un tas qui a √©t√© allou√© en utilisant du code non-outil, et ci-dessous est un tas qui a √©t√© allou√© avec du code outil.  Alors, que fera <b>Baggy Bound</b> ?  Comme vous vous en souvenez, ce syst√®me a le concept d'un slot dont la taille est de 16 bits.  Par cons√©quent, la table des limites se composera de 2 sections, initi√©es √† partir de 31 bits. <br><br>  Cependant, lors de l'ex√©cution du code de l'outil, il utilisera en fait l'algorithme des <b>limites Baggy</b> pour d√©finir les valeurs appropri√©es pour cette ligne du tableau. <br><br><img src="https://habrastorage.org/webt/vu/bp/wb/vubpwbtkublhjc6ay3ytcek6j-y.jpeg"><br><br>  Lorsqu'un pointeur provient du haut de l'espace m√©moire, il est toujours d√©fini sur les limites maximales possibles de <b>2n + 31</b> .  Cela signifie que les <b>limites de Baggy</b> ne consid√©reront jamais qu'une op√©ration de pointeur qui est ¬´venue¬ª d'une biblioth√®que non-outil peut d√©passer les limites. <br><br>  L'id√©e est que dans le code de l'outil, nous effectuerons toujours ces comparaisons pour les pointeurs, mais si nous d√©finissons les limites d'√©criture du pointeur pour un code non-outil de la forme <b>2n + 31</b> , nous n'aurons jamais d'erreur de d√©r√©f√©rence.  Autrement dit, nous avons une bonne interaction entre les <b>entr√©es de</b> code de <b>limites Baggy</b> et les enregistrements non instrumentaux des biblioth√®ques pr√©c√©dentes. <br><br>  Cela signifie que nous avons ce syst√®me, ce qui est bien, car il ne plante pas le programme lors de l'utilisation de biblioth√®ques non-outils, mais il a un probl√®me.  Le probl√®me est que nous ne pouvons jamais d√©terminer les limites des pointeurs g√©n√©r√©s par du code non-outil.  Parce que nous ne d√©finirons jamais un bit d'ordre √©lev√© lorsque, par exemple, ce pointeur obtient trop ou trop peu d'espace.  Ainsi, nous ne pouvons pas r√©ellement garantir la s√©curit√© de la m√©moire pour les op√©rations qui se produisent lors de l'utilisation de code non instrumental.  Vous ne pouvez pas non plus d√©terminer quand nous passons un pointeur qui a d√©pass√© les limites de taille du code instrumental au code non instrumental.  Dans ce cas, quelque chose d'inimaginable peut se produire.  Si vous avez un tel pointeur extrait du code de l'outil, alors il a un bit de poids fort d√©fini sur 1. Il semble donc qu'il ait des dimensions gigantesques. <br><br>  Nous savons que si nous venons de placer ce code dans le code de l'outil, nous pouvons effacer ce drapeau √† certains moments lorsqu'il revient aux fronti√®res.  Mais si nous passons simplement cette √©norme adresse au code non instrumental, cela peut faire quelque chose d'inimaginable.  Il peut m√™me renvoyer ce pointeur aux limites, mais nous n'aurons jamais l'occasion d'effacer ce bit d'ordre √©lev√©.  Nous pouvons donc toujours avoir des probl√®mes m√™me lors de l'utilisation du circuit illustr√© ici. <br><br>  <b>Public:</b> si nous avons du code outil pour allouer de la m√©moire, utilise-t-il la m√™me fonction <b>malloc</b> que le code attribut utilise? <br><br>  <b>Professeur:</b> C'est une question un peu d√©licate.  Si nous consid√©rons le cas ici, cela est strictement observ√©, car nous avons deux zones de m√©moire, chacune ob√©issant aux r√®gles √©tablies pour cela.  Mais en principe, cela d√©pendra du code qui utilise le langage de programmation s√©lectionn√©.  Imaginez qu'en C ++, par exemple, vous pouvez attribuer votre propre qualificatif.  Cela d√©pend donc de certains d√©tails du code. <br><br>  <b>Public:</b> comment le qualificatif peut-il v√©rifier si la limite est fix√©e √† 31 bits ou non? <br><br>  <b>Professeur:</b> aux niveaux inf√©rieurs, les algorithmes de distribution fonctionnent de sorte que lorsque vous appelez un syst√®me inconnu, le pointeur remonte.  Donc, si vous avez plusieurs allocateurs, ils essaient tous d'allouer de la m√©moire, chacun d'eux a sa propre m√©moire, qu'ils se r√©servent, pour l'essentiel, correctement.  Donc, dans la vraie vie, il peut √™tre plus fragment√© qu'√† un niveau √©lev√©. <br><br>  Donc, tout ce que nous avons examin√© ci-dessus concernait le fonctionnement des <b>limites Baggy</b> dans les syst√®mes 32 bits.  Consid√©rez ce qui se passe lors de l'utilisation de syst√®mes 64 bits.  Dans de tels syst√®mes, vous pouvez r√©ellement vous d√©barrasser de la table des limites, car nous pouvons stocker des informations sur les limites dans le pointeur lui-m√™me. <br><br>  Consid√©rez √† quoi ressemble un pointeur normal dans les limites de Baggy.  Il se compose de 3 parties.  21 bits sont allou√©s pour la premi√®re partie z√©ro, 5 autres bits sont allou√©s pour la taille, il s'agit de la taille principale du journal et 38 autres sont les bits de l'adresse habituelle. <br><br><img src="https://habrastorage.org/webt/gb/r5/6m/gbr56manocplt3wn7ueqgoxpcne.jpeg"><br><br>  La raison pour laquelle cela ne limite pas massivement la taille de l'adresse du programme que vous utilisez est que la plupart des bits de poids fort du syst√®me d'exploitation et / ou de l'√©quipement situ√©s dans les 2 premi√®res parties du pointeur ne permettent pas d'utiliser l'application pour diverses raisons.  Ainsi, il s'est av√©r√© que nous ne r√©duisons pas consid√©rablement le nombre d'applications utilis√©es dans le syst√®me.  Voici √† quoi ressemble un pointeur normal. <br><br>  Que se passe-t-il lorsque nous n'avons qu'un seul de ces pointeurs?  Eh bien, sur un syst√®me 32 bits, tout ce que nous pouvons faire est simplement de d√©finir un bit d'ordre √©lev√© et esp√®re que cette chose n'obtiendra jamais plus de la moiti√© de la taille de l'emplacement.  Mais maintenant que nous avons tout cet espace d'adressage suppl√©mentaire, vous pouvez placer le d√©calage en dehors des bordures OOB (hors limite) directement dans ce pointeur.  Nous pouvons donc faire quelque chose comme celui montr√© dans la figure, diviser le pointeur en 4 parties et redistribuer sa taille. <br><br>  Ainsi, nous pouvons obtenir 13 bits pour les limites de d√©calage, c'est-√†-dire √©crire √† quelle distance ce pointeur OOB sera de l'endroit o√π il devrait √™tre.  L√† encore, vous pouvez d√©finir la taille r√©elle de l'objet indiqu√© ici √† 5, et le reste de la partie z√©ro, qui sera d√©sormais 21-13 = 8 bits.  Et puis suit notre partie d'adresse de 38 bits.  Dans cet exemple, vous voyez les avantages de l'utilisation de syst√®mes 64 bits. <br><br><img src="https://habrastorage.org/webt/vx/ja/mp/vxjamp6bu-jxmc5xfrslev98o-s.jpeg"><br><br>  Notez qu'ici nous avons la taille habituelle pour un pointeur r√©gulier, dans les deux cas cette taille est de 64 bits, et sa description est √©l√©mentaire.  Et c'est bien, car lors de l'utilisation de pointeurs "√©pais", nous aurions besoin de beaucoup de mots pour les d√©crire. <br>  Je note √©galement que le code non-outil peut √™tre facilement appliqu√© ici, car il fonctionne et utilise la m√™me taille que les pointeurs r√©guliers.  Nous pouvons mettre ces choses dans une <b>structure</b> , par exemple, et la taille de cette <b>structure</b> restera inchang√©e.  C'est donc tr√®s bien lorsque nous avons l'opportunit√© de travailler dans un monde 64 bits. <br><br>  <b>Public:</b> pourquoi dans le second cas l'offset se situe devant la taille, et pas comme dans le cas pr√©c√©dent, et que se passera-t-il si la taille de l'offset est importante? <br><br>  <b>Professeur:</b> Je pense que dans certains cas, nous avons certains probl√®mes limitatifs sur lesquels nous devrons travailler.  Par exemple, un probl√®me se produit s'il y a plus de bits.  Mais au fond, je ne pense pas qu'il y ait une raison pour laquelle vous ne pourriez pas lire certaines de ces choses.  Sauf si certaines conditions strictes, auxquelles je ne pense pas maintenant, auraient d√ª stipuler la taille de la pi√®ce z√©ro, sinon il pourrait y avoir des probl√®mes avec le mat√©riel. <br><br>  Ainsi, vous pouvez toujours initier un d√©bordement de tampon dans le syst√®me de <b>limites Baggy</b> , car l'application des approches ci-dessus ne r√©sout pas tous les probl√®mes, non?  Un autre probl√®me que vous pouvez rencontrer si vous avez un code non instrumental, car nous ne pourrons d√©tecter aucun probl√®me dans le code non instrumental.  Vous pouvez √©galement rencontrer des vuln√©rabilit√©s de m√©moire r√©sultant d'un syst√®me d'allocation dynamique de m√©moire.  Si vous vous souvenez, dans une conf√©rence pr√©c√©dente, nous avons examin√© cet √©trange pointeur pour <b>lib√©rer le malloc</b> , et les <b>limites de Baggy</b> ne pouvaient pas emp√™cher l'apparition de telles choses. <br><br>  Nous avons √©galement discut√© lors de la derni√®re conf√©rence du fait que les pointeurs de code n'ont pas de fronti√®res qui leur seraient associ√©es.  Supposons que nous ayons une structure dans laquelle le tampon de m√©moire est situ√© en bas, le pointeur en haut et le tampon d√©borde.  Nous supposons que le d√©bordement de tampon est toujours dans les <b>limites de Baggy</b> .  Ensuite, vous devez red√©finir ce pointeur de fonction.  Sinon, si nous essayons de l'utiliser, il peut √™tre envoy√© √† du code malveillant pour attaquer une partie contr√¥l√©e de la m√©moire.  Et dans ce cas, les fronti√®res ne nous aideront pas, car nous n'avons pas de fronti√®res associ√©es, associ√©es √† ces pointeurs de fonction. <br><br>  Alors, quel est le prix de l'utilisation des <b>bornes Baggy</b> ?  En fait, nous n'avons que 4 composants de ce prix. <br><br><img src="https://habrastorage.org/webt/2v/vo/c0/2vvoc00hrhpzj90khybubng8zsa.jpeg"><br><br>  Le premier est l'espace.  Parce que si vous utilisez un pointeur ¬´√©pais¬ª, il est √©vident que vous devez agrandir les pointeurs.  Si vous utilisez le syst√®me de <b>limites Baggy</b> dont nous venons de parler, vous devez enregistrer une table de bordure.  Et cette table a une taille de slot qui vous permet de contr√¥ler la taille de cette table jusqu'√† √©puisement des possibilit√©s de la m√©moire qui lui est allou√©e. <br><br>  De plus, vous avez √©galement augment√© la charge du processeur, qui est oblig√© de faire toutes ces op√©rations instrumentales avec des pointeurs.  √âtant donn√© que pour chaque ou presque chaque pointeur, il est n√©cessaire de v√©rifier les limites en utilisant les m√™mes modes de fonctionnement, ce qui ralentira l'ex√©cution de votre programme. <br><br>  Il y a aussi un probl√®me avec les fausses alarmes.  Nous avons d√©j√† discut√© de ce qui pourrait arriver qu'un programme g√©n√®re des pointeurs qui d√©passent les limites, mais n'essaye jamais de les d√©r√©f√©rencer.  √Ä strictement parler, ce n'est pas un probl√®me.  <b>Baggy bounds</b> signalera ces drapeaux ¬´hors <b>limites</b> ¬ª s'ils d√©passent la moiti√© de la taille de l'emplacement, au moins dans la solution 32 bits. <br><br>  Ce que vous verrez dans la plupart des outils de s√©curit√©, c'est que les fausses alarmes r√©duisent la probabilit√© que les gens utilisent ces outils.  Parce que dans la pratique, nous esp√©rons tous que nous nous soucions de la s√©curit√©, mais qu'est-ce qui excite vraiment les gens?  Ils veulent pouvoir t√©l√©charger leurs stupides photos sur Facebook, ils veulent acc√©l√©rer le processus de t√©l√©chargement et ainsi de suite.  Ainsi, si vous voulez vraiment que vos outils de s√©curit√© soient en demande, ils ne devraient avoir aucune fausse alarme.  Tenter d'attraper toutes les vuln√©rabilit√©s conduit g√©n√©ralement √† de fausses alarmes, ce qui ennuiera les d√©veloppeurs ou les utilisateurs. <br><br>  Cela entra√Æne √©galement des d√©penses improductives dont vous avez besoin du support du compilateur.  Parce que vous devez ajouter tous les outils au syst√®me, en contournant la v√©rification du pointeur, et ainsi de suite. <br><br>  Donc, pour utiliser le syst√®me <b>Baggy bounds</b> , nous devons payer un prix, qui consiste en une utilisation excessive de l'espace, une augmentation de la charge du processeur, de fausses alarmes et la n√©cessit√© d'utiliser un compilateur. <br><br>  Ceci <b>conclut la</b> discussion sur les <b>limites</b> de <b>Baggy</b> . <br><br>  Nous pouvons maintenant penser √† deux autres strat√©gies d'att√©nuation des d√©passements de tampon.  En fait, ils sont beaucoup plus faciles √† expliquer et √† comprendre. <br><br>  L'une de ces approches est appel√©e <b>m√©moire non ex√©cutable</b> .  Son id√©e principale est que le mat√©riel d'√©change indiquera 3 bits de <b>R</b> , <b>W</b> et <b>X</b> - lire, √©crire et ex√©cuter - pour chaque page que vous avez en m√©moire.       ,   ,  .  2  ,     ,  ,  ,    . <br><br>     ,     .     ,  ,      ,    ,     -   .    ,  .   ¬´ <b>W</b>  <b>X</b> ¬ª ,       ,      ,     ,       ,   .     ,       ,      .        .  ,        ,     .    ? <br><br>     -   ,         .    ,     .     ,       ,    . <br><br>    ,       ,   ,       ,      .      ,           ,      .     . <br><br>     ,        .     ‚Äì  <b>just-in-time</b> ,      . <br><br>       -,    JavaScript    .    JavaScript,      ,    -   - ¬´¬ª , - ¬´¬ª ,       x86    .    ,         . <br>      . ,  ,    <b>just-in-time</b>    <b>W</b> ,       <b>X</b> .     ,        ,    . <br><br>        ‚Äî       .  ,  ,      ,    . <br><br><img src="https://habrastorage.org/webt/f_/xj/xi/f_xjxihqdru85yadpa__ytdao-4.jpeg"><br><br> ,   ,       .     GDB,         ,        .  ,       .      ,      .       . <br><br> ,      .  ,           ,     ,   ,    ,     . <br><br>     : , ,   ‚Äî     .    ,  ,    ,    ,   , , , -   .           ,     ,  . <br><br> ,    ,           ,     GDB  ,     ,         ,       ,     .        . <br>  ,    ,    ,   ,       .    -   ,    - ,        .        ,      .       ,     ,           . <br><br>    ,      ? ,  .      ,    ,               .    ,    ,    ,  ,  -    ,          . <br><br> 27:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours MIT "S√©curit√© des syst√®mes informatiques".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 3: ¬´ :   ¬ª,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des mat√©riaux plus int√©ressants?  Soutenez-nous en passant une commande ou en le recommandant √† vos amis, une <b>r√©duction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entr√©e de gamme que nous avons invent√©s pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la v√©rit√© sur VPS (KVM) E5-2650 v4 (6 c≈ìurs) 10 Go DDR4 240 Go SSD 1 Gbps √† partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'√† 24 c≈ìurs et jusqu'√† 40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV √† partir de 249 $</a> aux Pays-Bas et aux √âtats-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr√©ation d'un b√¢timent d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 co√ªtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416839/">https://habr.com/ru/post/fr416839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416827/index.html">Conteneurs pour adultes (partie 02): un guide pratique de la terminologie</a></li>
<li><a href="../fr416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../fr416831/index.html">L'acheminement externe du trafic int√©rieur russe sera r√©duit √† 5%</a></li>
<li><a href="../fr416833/index.html">Bienvenue dans le Meetup MskDotNet # 24</a></li>
<li><a href="../fr416837/index.html"># Dashanalune 0</a></li>
<li><a href="../fr416841/index.html">Comment tester des hypoth√®ses et gagner de l'argent sur Swift √† l'aide de tests fractionn√©s</a></li>
<li><a href="../fr416843/index.html">Moteurs de fus√©es nucl√©aires et syst√®mes de propulsion √©lectrique de fus√©es nucl√©aires</a></li>
<li><a href="../fr416845/index.html">10 raisons d'utiliser itracking ou de l'abandonner pour toujours</a></li>
<li><a href="../fr416847/index.html">Le site d'administration d'Ammyy √† nouveau compromis</a></li>
<li><a href="../fr416849/index.html">Oh mon code. Comment devenir administrateur syst√®me</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>