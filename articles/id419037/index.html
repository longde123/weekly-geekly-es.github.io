<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰 🌳 👇 Implementasi PPPOS pada stm32f4-discovery 👼🏿 👩🏿‍🎨 🏇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernah, sebelum saya ada tugas untuk menyediakan akses ke Internet pada STM32 yang hanya memiliki port COM. Untuk mengatasi masalah ini, saya membutuh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi PPPOS pada stm32f4-discovery</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419037/">  Pernah, sebelum saya ada tugas untuk menyediakan akses ke Internet pada STM32 yang hanya memiliki port COM.  Untuk mengatasi masalah ini, saya membutuhkan PPP, atau, tepatnya, PPPoS (Protokol Titik-ke-Titik melalui Serial - salah satu cara untuk mengimplementasikan PPP, digunakan saat menghubungkan melalui port COM). <br><br>  Dalam proses penyelesaian tugas yang ditetapkan di depan saya, saya menghadapi beberapa kesulitan, salah satunya, menurut pendapat saya, tidak cukupnya cakupan masalah yang terkait dengan PPPoS di Internet.  Dengan posting ini saya akan mencoba untuk menutup celah yang ditentukan, sejauh pengetahuan saya akan memungkinkan. <br><br>  Artikel ini menjelaskan cara membuat proyek untuk System Workbench untuk STM32 dari awal.  Menunjukkan contoh bekerja dengan UART.  Ada contoh kode untuk mengimplementasikan PPP.  Dan tentu saja, contoh pengiriman pesan ke komputer tetangga. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  PPP (Point-to-Point Protocol) adalah protokol data-link dua poin dari model jaringan OSI.  Biasanya digunakan untuk membangun komunikasi langsung antara dua node jaringan, dan dapat memberikan otentikasi koneksi, enkripsi dan kompresi data.  Digunakan pada banyak jenis jaringan fisik: kabel null modem, saluran telepon, seluler, dll. <br><br>  Seringkali ada subspesies dari protokol PPP, seperti Point-to-Point Protocol over Ethernet (PPPoE), yang digunakan untuk terhubung melalui Ethernet, dan kadang-kadang melalui DSL;  dan Protokol Point-to-Point over ATM (PPPoA), yang digunakan untuk koneksi melalui ATM Adaptation Layer 5 (AAL5), yang merupakan alternatif PPPoE utama untuk DSL. <br><br>  PPP adalah keluarga protokol: Link Control Protocol (LCP), Network Control Protocol (NCP), Protokol Otentikasi (PAP, CHAP), Multichannel PPP (MLPPP). <br><br>  <i>Dari Wikipedia</i> . <br><br><h3>  Persiapan </h3><br>  Untuk mengatasi masalah yang kita butuhkan: <br><br><h4>  Besi: </h4><br><ol><li>  Papan debug stm32f4_discovery: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/0k/6-/u10k6-una1bkmaphl4wlazibaca.jpeg"></div></li><li>  Adaptor USB ke miniUSB untuk menghubungkan papan ke komputer. </li><li>  Dua USBtoUART FT232 adapter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/uk/mo/uhukmolq4_t-pckn8h2rjofspnu.png"></div></li><li>  Dua kabel ekstensi USB juga bermanfaat, tidak harus, tetapi hanya nyaman. </li></ol><br><h4>  Lembut: </h4><br><ol><li>  Mesin virtual VirtualBox.  Anda dapat mengunduhnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kami juga mengunduh dan menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket Ekstensi</a> untuk VirtualBox. </li><li>  Dua disk instalasi dengan sistem operasi Windows dan Linux.  Kami mengambil Windows di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , Linux di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Setelah menginstal OS, Anda perlu menginstal add-ons untuk OS tamu.  Untuk tugas yang kami miliki cukup sistem 32x, Anda tidak bisa menipu dengan dimasukkannya virtualisasi. </li><li>  Untuk Windows, kami membutuhkan program yang dapat menerima permintaan dan meresponsnya melalui TCP / IP, dan program terminal untuk bekerja dengan port COM.  Unduh PacketSender di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (klik "Tidak, terima kasih, biarkan saya unduh."), Terminal ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Selain itu, kita perlu STM32CubeMX untuk pengaturan awal proyek.  Unduh dari st.com (setelah pendaftaran, tautannya akan datang melalui email). </li><li>  Kami menempatkan System Workbench untuk STM32 di OS utama.  Unduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> (diperlukan registrasi). </li></ol><br><h3>  Tahap 1. Membuat proyek </h3><br>  Pertama-tama, buka STM32CubeMX dan buat proyek baru di sana untuk papan stm32f4-discovery kami.  Nyalakan RCC, Ethernet (ETH), SYS, USART2, USART3, lalu nyalakan FREERTOS dan LWIP. <br><br><img src="https://habrastorage.org/webt/vr/jk/ve/vrjkveavft5ry-oasa7h2e07rwe.png"><br><img src="https://habrastorage.org/webt/9c/v2/rv/9cv2rv-_8yf5w67mr7bw7ynp1vk.png"><br><br>  Untuk diagnosa, kita membutuhkan LED di papan tulis.  Untuk ini, konfigurasikan kaki-kaki PD12-PD15 sebagai GPIO_Output. <br><br><img src="https://habrastorage.org/webt/-s/bb/lk/-sbblkybmbdz1wrftiow38tq4eg.png"><br><br>  Pada tab Konfigurasi Jam, atur frekuensinya, seperti pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/sd/cc/qy/sdccqyreetba7g_m8yq_gypc-ge.png"><br><br>  Selanjutnya, pada tab Konfigurasi, konfigurasikan port USART.  Kami akan bekerja dengan mereka dalam mode DMA.  Kami memiliki dua port USART, satu akan kami gunakan untuk mengirim dan menerima data melalui PPP, yang kedua untuk logging.  Untuk membuatnya bekerja, kita perlu mengkonfigurasi DMA pada RX dan TX untuk kedua port.  Untuk semua kaki tuning DMA, atur Medium ke prioritas.  Untuk USART2 leg, RX mengatur mode ke "Circular".  Pengaturan lainnya dibiarkan secara default. <br><br><img src="https://habrastorage.org/webt/96/s8/9u/96s89uloxfrdtxd0scqvcyb-zng.png"><br><br>  Anda juga perlu mengaktifkan interupsi global untuk kedua port pada tab "Pengaturan NVIC". <br><br>  Ini menyelesaikan pengaturan awal proyek di STM32CubeMX.  Kami menyimpan file proyek dan melakukan pembuatan kode untuk System Workbench for STM32. <br><br><img src="https://habrastorage.org/webt/ss/_d/8l/ss_d8lzdxneoj5mjasvmyhhhxiu.png"><br><br><h4>  Implementasi </h4><br>  Sekarang mari kita verifikasi bahwa kode yang diunduh mengkompilasi dan berfungsi.  Untuk melakukan ini, dalam file main.c dalam fungsi "StartDefaultTask", kami mengganti badan infinite untuk loop (;;) dengan kode LED on dan off. <br><br>  Seharusnya seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* StartDefaultTask function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> MX_LWIP_Init(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Infinite loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 5 */</span></span> }</code> </pre> <br>  Kami mengkompilasi firmware dan mencari.  Keempat LED harus berkedip di papan tulis. <br><br><h3>  Tahap 2. Bekerja dengan USART </h3><br>  Tugas kita selanjutnya adalah memverifikasi operasi USART kita dengan benar. <br><br>  Hal pertama yang perlu kita lakukan adalah menghubungkan FT232 kita dengan penemuan.  Untuk melakukan ini, lihat kaki-kaki mana antarmuka USART bercerai.  Saya memilikinya masing-masing PD6 dan PD5 untuk USART2_RX dan USART2_TX. <br><br><img src="https://habrastorage.org/webt/qj/yh/yo/qjyhyoohdofxtqedphuhzq7qcac.png"><br><br>  Serta PD9 dan PD8 untuk USART3_RX dan USART3_TX, masing-masing. <br><br><img src="https://habrastorage.org/webt/37/bf/om/37bfomzqqcapediljrf14flpuiu.png"><br><br>  Selain itu, kita membutuhkan kaki GND. <br><br>  Kami menemukan pin ini di papan dan menghubungkannya ke pin FT232, sementara pin GND di papan bisa apa saja, pin RX di papan harus terhubung ke pin TX di FT232, dan pin TX di papan harus terhubung ke pin RX di FT232.  Kesimpulan yang tersisa tidak digunakan. <br><br>  Tetap menghubungkan FT232 kami ke port USB komputer, serta menghubungkan papan penemuan itu sendiri melalui konektor miniUSB ke komputer (jangan bingung dengan microUSB). <br><br>  Setelah menghubungkan FT232, OS utama akan menginstal driver untuk mereka, setelah itu perangkat ini akan perlu diteruskan ke tamu Windows di mesin virtual. <br><br>  Sekarang kami menambahkan kode program yang diperlukan untuk pengoperasian USART kami.  Untuk melakukan ini, kita akan menambahkan empat file: usart.h, usart.c, logger.h, logger.c. <br><br>  Isi File: <br><br>  <b>file usart.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> void usart_Open(void); bool usart_Send(char* bArray, int size_bArray); uint16_t usart_Recv(char* bArray, uint16_t maxLength); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _USART_ */</span></span></span></span></code> </pre><br>  <b>file usart.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmsis_os.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_USART2_SIZE 200 xQueueHandle g_qUsart; osThreadId g_usart_rxTaskHandle; extern UART_HandleTypeDef huart2; void usart_rxTask(void); uint8_t bGet[Q_USART2_SIZE] = {0}; uint16_t g_tail = 0; void usart_Open(void) { g_qUsart = xQueueCreate( Q_USART2_SIZE, sizeof( unsigned char ) ); osThreadDef(usart_rxTask_NAME, usart_rxTask, osPriorityNormal, 0, Q_USART2_SIZE/4+128); g_usart_rxTaskHandle = osThreadCreate(osThread(usart_rxTask_NAME), NULL); HAL_UART_Receive_DMA(&amp;huart2, bGet, Q_USART2_SIZE); } void usart_rxTask(void) { for(;;) { uint16_t length = Q_USART2_SIZE - huart2.hdmarx-&gt;Instance-&gt;NDTR; while(length - g_tail) { uint8_t tmp = bGet[g_tail]; xQueueSendToBack( g_qUsart, &amp;tmp, 100 ); g_tail++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (g_tail == Q_USART2_SIZE) g_tail = 0; } } } bool usart_Send(char* bArray, int size_bArray) { HAL_StatusTypeDef status; status = HAL_UART_Transmit_DMA(&amp;huart2, bArray, size_bArray); while (HAL_UART_GetState(&amp;huart2) != HAL_UART_STATE_READY) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_RX) break; osDelay(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status == HAL_OK) return true; return false; } uint16_t usart_Recv(char* bArray, uint16_t maxLength) { uint8_t tmp = 0; uint16_t length = 0; while(uxQueueMessagesWaiting(g_qUsart)) { xQueueReceive( g_qUsart, &amp;tmp, 100 ); bArray[length] = tmp; length++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length &gt;= maxLength) break; } return length; }</span></span></code> </pre><br>  <b>file logger.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _LOGGER_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _LOGGER_ void logger(const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _LOGGER_ */</span></span></span></span></code> </pre><br>  <b>file logger.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdarg.h&gt; extern UART_HandleTypeDef huart3; #define MAX_STRING_SIZE 1024 HAL_StatusTypeDef logger_Send(char* bArray, uint32_t size_bArray) { HAL_StatusTypeDef status; for(int i=0;i&lt;5;i++) { status = HAL_UART_Transmit_DMA(&amp;huart3, bArray, size_bArray); if (status == HAL_OK) break; osDelay(2); } while (HAL_UART_GetState(&amp;huart3) != HAL_UART_STATE_READY) { osDelay(1); } return status; } void logger(const char *format, ...) { char buffer[MAX_STRING_SIZE]; va_list args; va_start (args, format); vsprintf(buffer, format, args); va_end(args); buffer[MAX_STRING_SIZE-1]=0; logger_Send(buffer, strlen(buffer)); }</span></span></span></span></code> </pre><br>  Kami membutuhkan usart untuk mengirim dan menerima data di usart2.  Ini akan menjadi antarmuka utama kami untuk berkomunikasi dengan server PPP. <br><br>  Kami membutuhkan Logger untuk mengimplementasikan pencatatan dengan mengirim pesan ke terminal.  Fungsi void usart_Open (void) membentuk antrian dan memulai tugas servis antrian ini.  Fungsi ini harus diselesaikan sebelum menggunakan USART.  Kemudian semuanya sederhana, fungsi bool usart_Send (char * bArray, int size_bArray) mengirimkan data ke port, dan <br>  uint16_t usart_Recv (char * bArray, uint16_t maxLength) mendapatkannya dari antrian di mana fungsi void usart_rxTask (void) telah menambahkannya. <br><br>  Untuk logger, ini masih lebih sederhana, tidak perlu mendapatkan data, oleh karena itu, baik tugas antrian maupun tugas antrian tidak diperlukan. <br><br>  Di awal file <b>main.h</b> , <b>Anda</b> perlu menambahkan beberapa definisi yang menggambarkan tipe bool, yang tidak tersedia dalam C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> false 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span></span></code> </pre><br>  Sekarang saatnya untuk memeriksa fungsionalitas kode yang dihasilkan.  Untuk melakukan ini, dalam file <b>main.c</b> , ubah kode tugas yang sudah diketahui "StartDefaultTask" <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MESSAGE_LENGTH 100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> MX_LWIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span></span><span class="hljs-meta"> usart_Open(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> uint8_t send[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send message\r\n"</span></span></span><span class="hljs-meta">; uint8_t recv[MAX_MESSAGE_LENGTH] = {0}; uint16_t recvLength = 0; for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart_Send(send, sizeof(send)-1)) logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SEND - %s"</span></span></span><span class="hljs-meta">, send); recvLength = usart_Recv(recv, MAX_MESSAGE_LENGTH-1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (recvLength) { recv[recvLength] = 0; logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RECV - %s\r\n"</span></span></span><span class="hljs-meta">, recv); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 5 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Selain itu, kita perlu memberikan lebih banyak memori ke tumpukan tugas kita.  Untuk melakukan ini, dalam panggilan ke fungsi osThreadDef (), file main.c, Anda perlu memperbaiki 128 dengan 128 * 10 untuk mendapatkan ini: <br><br><pre> <code class="hljs lisp">osThreadDef(<span class="hljs-name"><span class="hljs-name">defaultTask</span></span>, StartDefaultTask, osPriorityNormal, <span class="hljs-number"><span class="hljs-number">0</span></span>, &lt;b&gt;128*10&lt;/b&gt;)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Kami mengkompilasi dan menginstal.  LED berkedip dengan cara yang sama seperti pada tugas sebelumnya. <br><br>  Untuk melihat hasil pekerjaan kami, Anda perlu menjalankan program Terminal di mesin virtual kami.  Satu contoh program untuk port logging, yang kedua untuk utama.  Lihat di manajer perangkat nomor port apa yang ditetapkan untuk FT232 Anda.  Jika nomor telah ditetapkan lebih dari 10, tugaskan kembali. <br><br>  Saat memulai instance kedua dari program, kesalahan dapat terjadi, tutup jendela dengan kesalahan dan terus bekerja dengan program. <br><br>  Untuk kedua port, kami membuat koneksi pada 115200 baud, bit data - 8, paritas - tidak ada, stop bit - 1, handshaking - tidak ada. <br><br>  Jika Anda melakukan semuanya dengan benar, maka di jendela terminal untuk usart2 pesan "Kirim pesan" akan dikirim.  Pesan yang sama akan digandakan di jendela terminal untuk logger hanya dengan awalan "KIRIM -" <br><br>  Jika di jendela terminal untuk usart2 Anda mengetik beberapa teks di bidang "Kirim" dan klik tombol yang sesuai di sebelah kanan bidang ini, maka di jendela logger Anda akan melihat pesan yang sama dengan awalan "RECV -" <br><br>  Pada gambar di bawah ini: di sebelah kiri adalah logger, di sebelah kanan adalah usart2. <br><br><img src="https://habrastorage.org/webt/k5/v6/hc/k5v6hcxebj6hfdgbitfwyzs1ffw.png"><br><br><h3>  Tahap 3. Memulai dengan PPP </h3><br>  Sebagai bagian dari tugas ini, kami akan meningkatkan koneksi PPP.  Pertama-tama, aktifkan penggunaan PPP, ubah nilai yang didefinisikan oleh PPP_SUPPORT dalam file ppp_opts.h menjadi 1. Kemudian kita mendefinisikan kembali definisi yang diperlukan dalam file lwipopts.h, <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMP_NUM_SYS_TIMEOUT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_IP 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_TCP 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span></span></code> </pre><br>  Pada saat yang sama, definisi lama perlu dikomentari. <br><br>  Sekarang kita memodifikasi file lwip.c, masukkan kode berikut ke dalam blok “/ * USER CEGE BEGIN 0 * /”: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pppos.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp.h"</span></span></span><span class="hljs-meta"> static ppp_pcb *ppp; struct netif pppos_netif; void PppGetTask(void const * argument) { uint8_t recv[2048]; uint16_t length = 0; for(;;) { length=usart_Recv(recv, 2048); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length) { pppos_input(ppp, recv, length); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"read - PppGetTask() len = %d\n"</span></span></span><span class="hljs-meta">, length); } osDelay(10); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ip4_addr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx) { struct netif *pppif = ppp_netif(pcb); LWIP_UNUSED_ARG(ctx); switch(err_code) { case PPPERR_NONE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No error. */</span></span></span><span class="hljs-meta"> { logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_NONE\n\r"</span></span></span><span class="hljs-meta">); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" our_ip4addr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_addr(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" his_ipaddr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_gw(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" netmask = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_netmask(pppif))); } break; case PPPERR_PARAM: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid parameter. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PARAM\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_OPEN: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to open PPP session. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_OPEN\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_DEVICE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid I/O device for PPP. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_DEVICE\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_ALLOC: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to allocate resources. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_ALLOC\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_USER: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User interrupt. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_USER\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection lost. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_AUTHFAIL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed authentication challenge. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_AUTHFAIL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PROTOCOL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed to meet protocol. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PROTOCOL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PEERDEAD: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PEERDEAD\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_IDLETIMEOUT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Idle Timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_IDLETIMEOUT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECTTIME: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PPPERR_CONNECTTIME. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECTTIME\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_LOOPBACK: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_LOOPBACK\n"</span></span></span><span class="hljs-meta">); break; default: logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: unknown errCode %d\n"</span></span></span><span class="hljs-meta">, err_code); break; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Callback used by ppp connection static u32_t ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx) { LWIP_UNUSED_ARG(pcb); LWIP_UNUSED_ARG(ctx); if (len &gt; 0) { if (!usart_Send(data, len)) return 0x05; } logger("write - ppp_output_cb() len = %d\n", len); return len; } void pppConnect(void) { ppp = pppos_create(&amp;pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL); ppp_set_default(ppp); osThreadId PppGetTaskHandle; osThreadDef(PPP_GET_TASK_NAME, PppGetTask, osPriorityNormal, 0, 128*10); PppGetTaskHandle = osThreadCreate(osThread(PPP_GET_TASK_NAME), NULL); err_t err = ppp_connect(ppp,0); if (err == ERR_ALREADY) { logger("Connected successfully"); } for(int i=0;i&lt;40;i++) { osDelay(500); if (ppp-&gt;phase &gt;= PPP_PHASE_RUNNING) break; } } /* USER CODE END 0 */</span></span></span></span></code> </pre><br>  Kemudian, dalam fungsi MX_LWIP_Init (), di blok “/ * USER CODE BEGIN 3 * /” kami menambahkan panggilan ke fungsi pppConnect (). <br><br>  Selain itu, Anda perlu meningkatkan ukuran heap, untuk ini, dalam file FreeRTOSConfig.h, Anda perlu mengomentari definisi configTOTAL_HEAP_SIZE, dan pada akhir file, di / * USER CODE BEGIN Definisikan * / blok, nyatakan dengan nilai baru. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Defines */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configTOTAL_HEAP_SIZE ((size_t)1024*30) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Defines */</span></span></span></span></code> </pre><br>  Juga, dalam file usart.c, ubah nilai definisi Q_USART2_SIZE menjadi 2048. <br><br>  Pengaturan koneksi dimulai dengan fungsi MX_LWIP_Init (); itu dibuat secara otomatis; kami baru saja menambahkan panggilan ke fungsi pppConnect () padanya.  Dalam fungsi ini, tugas yang melayani koneksi PPPOS diluncurkan.  Fungsi pppos_create () perlu diberikan alamat fungsi yang akan melayani pengiriman pesan dan output informasi tentang mengubah status koneksi.  Bagi kami, ini adalah fungsi masing-masing ppp_output_cb () dan ppp_link_status_cb ().  Selain itu, fungsi pppConnect () akan memulai tugas melayani pesan yang diterima.  Pada akhir operasinya, fungsi pppConnect () akan menunggu koneksi ke server dibuat, dan kemudian menyelesaikan operasinya. <br><br>  Bekerja dengan jaringan akan dilakukan pada tingkat yang lebih tinggi, segera setelah LWIP memutuskan bahwa perlu mengirim pesan ke jaringan, fungsi ppp_output_cb () akan dipanggil secara otomatis.  Respons dari jaringan akan diterima oleh fungsi PppGetTask (), sebagai bagian dari tugas melayani pesan yang masuk, dan ditransfer ke usus LWIP.  Jika status koneksi berubah, fungsi ppp_link_status_cb () akan dipanggil secara otomatis. <br><br>  Terakhir, kami akan memodifikasi tugas StartDefaultTask.  Sekarang akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> <span class="hljs-comment"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); } /* USER CODE END 5 */ }</span></span></code> </pre><br>  Selesai, Anda dapat mengkompilasi dan flash. <br><br>  Pada titik ini, Anda harus memulai server PPP.  Untuk melakukan ini, Anda harus terlebih dahulu menggunakan mesin virtual dengan Linux.  Saya menggunakan Ubuntu 16.04 x32.  Setelah menginstal sistem operasi, Anda perlu mengkonfigurasi penggunaan port COM. <br><br>  Pada bagian ini, kita tidak perlu mesin virtual dengan Windows, kita dapat mematikannya dengan aman.  Kami menghubungkan kedua FT232 di Linux. <br><br>  Di Linux, sebelum Anda mulai bekerja dengan port COM, Anda harus mengizinkan pengguna untuk menggunakannya.  Untuk melakukan ini, jalankan perintah berikut: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> addgroup USERNAME dialout</code> </pre> <br>  di mana USERNAME adalah nama pengguna saat ini. <br><br>  Untuk melihat port yang tersedia di sistem COM, Anda perlu menjalankan perintah: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> tty</code> </pre> <br><img src="https://habrastorage.org/webt/zc/h4/mp/zch4mpfwyybln76dl1jnhpxjt0s.png"><br><br>  Kami melihat bahwa ada dua port ttyUSB dalam sistem.  Kita tidak bisa langsung mengatakan mana yang logger dan mana yang usart2.  Anda hanya perlu memeriksanya secara bergantian. <br><br>  Pertama, jalankan perintah untuk membaca dari satu port: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB0 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB0</code> </pre> <br>  lalu dari yang lain: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB1</code> </pre> <br>  Di mana kita melihat gambar seperti itu, yaitu logger. <br><br><img src="https://habrastorage.org/webt/u0/cu/zc/u0cuzcnbhzppwdhpibm2o6zelpk.png"><br><br>  Anda dapat meninggalkan jendela ini, itu tidak akan mengganggu kami. <br><br>  Selanjutnya, Anda harus mengizinkan paket yang dikirim dari papan kami untuk meninggalkan batas subnet mereka.  Untuk melakukan ini, konfigurasikan iptables.  Kami melakukan tindakan berikut: <br><br>  1. Buka jendela konsol baru <br>  2. Anda perlu mencari tahu ip Anda dan nama antarmuka jaringan (jalankan perintah <b>ifconfig</b> ) <br><br><img src="https://habrastorage.org/webt/jy/d4/9s/jyd49satpc3erdlzeddi44gwcy4.png"><br><br>  3. Jalankan perintah konfigurasi nat <br><br><pre> <code class="hljs powershell">sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_dynaddr &gt; /dev/null sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> FORWARD sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-A</span></span> POSTROUTING <span class="hljs-literal"><span class="hljs-literal">-o</span></span> enp0s3 <span class="hljs-literal"><span class="hljs-literal">-j</span></span> SNAT -<span class="hljs-literal"><span class="hljs-literal">-to</span></span><span class="hljs-literal"><span class="hljs-literal">-source</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">10.196</span></span> sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-L</span></span></code> </pre> <br>  di mana enp0s3 adalah nama antarmuka jaringan <br>  192.168.10.196 - alamat IP Anda <br>  / proc / sys / net / ipv4 / - path ke file yang sesuai. <br><br>  Perintah-perintah ini dapat ditulis ulang menjadi file batch dan menjalankannya setiap kali sebelum memulai server PPP.  Anda dapat menambahkannya ke autorun, tetapi saya tidak. <br><br>  Sekarang kita siap untuk memulai server, tetap hanya untuk membuat file pengaturan.  Saya menyebutnya " <b>pppd.conf</b> ", saya sarankan menggunakan pengaturan berikut: <br><br><pre> <code class="hljs pgsql">nodetach noauth passive <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> lcp-echo-<span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> lcp-echo-failure <span class="hljs-number"><span class="hljs-number">1</span></span> cdtrcts</code> </pre> <br>  Kami menulis ulang pengaturan dalam file dan kemudian Anda dapat memulai server.  Ini dilakukan dengan perintah <b>sudo pppd ./pppd.conf</b> <br><br>  Server PPPD harus dimulai sebelum dimulainya penemuan, jadi setelah dimulainya PPPD Anda harus mengklik tombol "Reset" yang terletak di papan tulis. <br><br>  Jika Anda melakukan semuanya dengan benar, Anda akan melihat gambar berikut: <br><br><img src="https://habrastorage.org/webt/kv/-p/lj/kv-pljob3duk3bigzj3iazcsasa.png"><br><br>  Menjalankan pppd di sebelah kiri, logger di sebelah kanan. <br><br><h3>  Tahap 4. Kami mengirim tas </h3><br>  Pada tahap ini, kita membutuhkan kedua mesin virtual.  Linux untuk pppd dan Windows untuk menerima paket.  Untuk menyederhanakan tugas, Anda perlu kedua mesin berada di subnet yang sama, solusi yang ideal adalah menentukan koneksi Network Bridge untuk kedua mesin dalam pengaturan jaringan VirtualBox, dan menonaktifkan firewall di Windows. <br><br>  Kami memulai mesin virtual dan mengkonfigurasi koneksi ppp dari papan penemuan dengan pppd.  Di Windows, kami menemukan alamat IP mesin (perintah ipconfig), saya mendapatkannya 192.168.10.97. <br><br>  Luncurkan Pengirim Paket dan konfigurasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/k8/zt/uv/k8ztuv4eccjueyvlk8gigjbmkj0.png"><br><br>  Sekarang lagi, ubah tugas StartDefaultTask di file main.c. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sockets.h"</span></span></span><span class="hljs-meta"> typedef uint32_t SOCKET; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ uint8_t sendStr[]="Test message TCP/IP."; uint8_t resvStr[100]={0}; int resvLength = 0; struct sockaddr_in sockAddr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons( 6565 ); uint32_t addr = inet_addr("192.168.10.97"); sockAddr.sin_addr.s_addr = addr; SOCKET socket = NULL; int nError = 0; /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); socket = socket( AF_INET, SOCK_STREAM, 0 ); nError = connect( socket, (struct sockaddr*)&amp;sockAddr, sizeof(sockAddr) ); if ( nError == 0 ) { nError = send( socket, sendStr, sizeof(sendStr)-1, 0 ); if ( nError &lt; 0 ) logger("SEND ERROR %d\n", nError); else { logger("SEND - %s\n", sendStr); resvLength = 0; while(resvLength &lt; 1) resvLength = lwip_recv( socket, resvStr, sizeof(resvStr), MSG_WAITALL); resvStr[resvLength]=0; logger("GET - %s\n", resvStr); } lwip_close(socket); } else logger("CONNECT ERROR %d\n", nError); } /* USER CODE END 5 */ }</span></span></span></span></code> </pre><br>  Sebagai nilai variabel addr, kami menggunakan alamat mesin Windows, nomor port 6565. <br>  Pesan terkirim "Tes pesan TCP / IP.", Respons "Pesan diterima." <br><br>  Di sini Anda dapat melihat bahwa fungsi PPP tidak secara langsung digunakan untuk mengirim dan menerima pesan.  Semua pekerjaan terjadi di tingkat yang lebih tinggi, dan fungsi kami dipanggil secara otomatis. <br><br>  Kami mengkompilasi dan menginstal. <br><br>  Hasil menghubungkan ke pppd terlihat di mesin Linux: <br><br><img src="https://habrastorage.org/webt/il/og/h6/ilogh6wuak7zym8unedcnddcjr4.png"><br><br>  Permintaan yang diterima dan respons yang dikirim dapat dilihat dalam program Pengirim Paket pada mesin Windows: <br><br><img src="https://habrastorage.org/webt/30/yh/4m/30yh4m_l52nvlkdixrv9zmivehc.png"><br><br>  Nah, itu saja, paket yang kami kirim dari papan penemuan pergi ke port COM, sampai ke server pppd, dikirim ke port Windows 6565 dari mesin, di sana ia berhasil diterima, sebagai tanggapan terhadapnya paket lain dikirim yang melewati ini jalan di arah yang berlawanan dan berhasil diadopsi di papan tulis.  Anda mungkin dapat mengirim pesan ke mesin apa pun di Internet. <br><br>  → Kode proyek lengkap dapat diunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419037/">https://habr.com/ru/post/id419037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419025/index.html">@Pythonetc kompilasi, Juli 2018</a></li>
<li><a href="../id419027/index.html">Keamanan informasi pembayaran tanpa uang tunai bank. Bagian 6 - Analisis Kejahatan Perbankan</a></li>
<li><a href="../id419029/index.html">Fortnite telah menjadi fenomena sosial. Orang tua semakin merekrut pelatih untuk anak-anak mereka dan bermain bersama mereka</a></li>
<li><a href="../id419033/index.html">Sebuah catatan kecil tentang topik menjalankan vue.js di cluster kubernetes</a></li>
<li><a href="../id419035/index.html">Buku “Head First Agile. Manajemen proyek yang fleksibel ”</a></li>
<li><a href="../id419041/index.html">Sembilan garu Elasticsearch yang saya injak</a></li>
<li><a href="../id419043/index.html">Masalah frame timing yang sulit dipahami</a></li>
<li><a href="../id419047/index.html">Reddit meretas, membocorkan database dengan kata sandi dan email untuk 2005-2007</a></li>
<li><a href="../id419049/index.html">GeekBrains Meluncurkan marathon edukasi online “Find Yourself in Digital” gratis</a></li>
<li><a href="../id419051/index.html">Bagaimana Flant Membantu Pemula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>