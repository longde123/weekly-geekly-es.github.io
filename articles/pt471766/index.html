<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìé üöá üïò Manipula√ß√£o de erros Kotlin / Java: como fazer isso certo? üë©üèø‚Äçü§ù‚Äçüë©üèæ üßöüèæ üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fonte 


 A manipula√ß√£o de erros em qualquer desenvolvimento desempenha um papel crucial. Quase tudo pode dar errado no programa: o usu√°rio insere dad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manipula√ß√£o de erros Kotlin / Java: como fazer isso certo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fonte</a> </p><br><p>  A manipula√ß√£o de erros em qualquer desenvolvimento desempenha um papel crucial.  Quase tudo pode dar errado no programa: o usu√°rio insere dados incorretos, ou eles podem ser encontrados via http, ou cometemos um erro ao escrever serializa√ß√£o / desserializa√ß√£o e durante o processamento, o programa trava com um erro.  Sim, pode ficar sem espa√ßo em disco. </p><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text"><p>  ¬Ø_ („ÉÑ) _ / ¬Ø, n√£o existe um caminho √∫nico e, em cada situa√ß√£o espec√≠fica, voc√™ ter√° que escolher a op√ß√£o mais adequada, mas h√° recomenda√ß√µes sobre como faz√™-lo melhor. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Pref√°cio </h3><br><p>  Infelizmente (ou apenas uma vida assim?), Esta lista continua.  O desenvolvedor precisa constantemente pensar no fato de que em algum lugar pode ocorrer um erro e existem duas situa√ß√µes: </p><br><ul><li>  quando o erro esperado ocorre ao chamar a fun√ß√£o que fornecemos e podemos tentar processar; </li><li>  quando ocorrer um erro inesperado durante a opera√ß√£o que n√£o previmos. </li></ul><br><p>  E se os erros esperados forem pelo menos localizados, o resto poder√° acontecer em quase todos os lugares.  Se n√£o processarmos nada importante, podemos simplesmente travar com um erro (embora esse comportamento n√£o seja suficiente e voc√™ precise pelo menos adicionar uma mensagem ao log de erros).  Mas se, no momento, o pagamento est√° sendo processado e voc√™ simplesmente n√£o pode cair, mas pelo menos precisa retornar uma resposta sobre a opera√ß√£o malsucedida? </p><br><p>  Antes de procurarmos maneiras de lidar com erros, algumas palavras sobre Exce√ß√£o (exce√ß√µes): </p><br><h3 id="exception">  Exce√ß√£o </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fonte</a> </p><br><p> A hierarquia de exce√ß√µes √© bem descrita e voc√™ pode encontrar muitas informa√ß√µes sobre ela, portanto n√£o faz sentido pint√°-la aqui.  O que ainda causa discuss√µes acaloradas √© <code>checked</code> e erros <code>unchecked</code> verificados.  E embora a maioria aceite exce√ß√µes <code>unchecked</code> como preferidas (no Kotlin n√£o h√° exce√ß√µes <code>checked</code> ), nem todos concordam com isso. </p><br><p>  As exce√ß√µes <code>checked</code> realmente tinham uma boa inten√ß√£o de torn√°-las um mecanismo conveniente de tratamento de erros, mas a realidade fez seus ajustes, embora a id√©ia de introduzir todas as exce√ß√µes que podem ser lan√ßadas dessa fun√ß√£o na assinatura seja compreens√≠vel e l√≥gica. </p><br><p>  Vejamos um exemplo.  Suponha que tenhamos uma fun√ß√£o de <code>method</code> que possa <code>PanicException</code> uma <code>PanicException</code> verificada.  Essa fun√ß√£o ficaria assim: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  Pela descri√ß√£o dela, fica claro que ela pode lan√ßar uma exce√ß√£o e que pode haver apenas uma exce√ß√£o.  Parece bastante confort√°vel?  E enquanto temos um pequeno programa, √© isso.  Mas se o programa for um pouco maior e houver mais fun√ß√µes desse tipo, alguns problemas aparecer√£o. </p><br><p>  As exce√ß√µes verificadas exigem, por especifica√ß√£o, que <strong>todas as poss√≠veis</strong> exce√ß√µes verificadas (ou um ancestral comum para elas) sejam listadas na assinatura da fun√ß√£o.  Portanto, se tivermos uma cadeia de chamadas <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> a fun√ß√£o mais aninhada gera algum tipo de exce√ß√£o, ela deve ser descartada para todos na cadeia.  E se houver v√°rias exce√ß√µes, a fun√ß√£o superior na assinatura dever√° ter uma descri√ß√£o de todas elas. </p><br><p>  Portanto, √† medida que o programa se torna mais complexo, essa abordagem leva ao fato de que as exce√ß√µes na fun√ß√£o superior desmoronam gradualmente para ancestrais comuns e acabam se resumindo √† <code>Exception</code> .  O que neste formul√°rio se torna semelhante a uma exce√ß√£o <code>unchecked</code> e anula todas as vantagens das exce√ß√µes verificadas. </p><br><p>  E dado que o programa, como organismo vivo, est√° constantemente mudando e evoluindo, √© quase imposs√≠vel prever antecipadamente quais exce√ß√µes podem surgir nele.  E, como resultado, a situa√ß√£o √© que, quando adicionamos uma nova fun√ß√£o com uma nova exce√ß√£o, precisamos passar por toda a cadeia de uso e alterar as assinaturas de todas as fun√ß√µes.  Concordo que essa n√£o √© a tarefa mais agrad√°vel (mesmo considerando que os IDEs modernos fazem isso por n√≥s). </p><br><p>  Mas a √∫ltima e provavelmente a maior unha nas exce√ß√µes verificadas ‚Äúdirigiu‚Äù lambdas do Java 8. N√£o h√° exce√ß√µes verificadas ¬Ø_ („ÉÑ) _ / ¬Ø na assinatura (uma vez que qualquer fun√ß√£o pode ser chamada em lambda, com qualquer assinatura), portanto, qualquer chamada de fun√ß√£o com uma exce√ß√£o verificada do lambda obriga a ser agrupada em um encaminhamento de exce√ß√£o como desmarcada: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Felizmente, na especifica√ß√£o da JVM, n√£o h√° exce√ß√µes verificadas; portanto, no Kotlin, voc√™ n√£o pode agrupar nada na mesma lambda, mas simplesmente chamar a fun√ß√£o desejada. </p><br><div class="spoiler">  <b class="spoiler_title">embora √†s vezes ...</b> <div class="spoiler_text"><p>  Embora isso √†s vezes leve a consequ√™ncias inesperadas, como, por exemplo, a opera√ß√£o incorreta do <code>@Transactional</code> no <code>Spring Framework</code> , que "espera" apenas exce√ß√µes n√£o verificadas.  Mas isso √© mais um recurso do framework, e talvez esse comportamento no Spring mude no futuro pr√≥ximo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . </p></div></div><br><p>  As pr√≥prias exce√ß√µes s√£o objetos especiais.  Al√©m do fato de poderem ser "lan√ßados" por meio de m√©todos, eles tamb√©m coletam o rastreamento de pilha na cria√ß√£o.  Esse recurso ajuda na an√°lise de problemas e na busca de erros, mas tamb√©m pode levar a alguns problemas de desempenho se a l√≥gica do aplicativo ficar fortemente vinculada a exce√ß√µes geradas.  Conforme mostrado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , desabilitar o conjunto de rastreamento de pilha pode aumentar significativamente seu desempenho nesse caso, mas voc√™ deve recorrer a ele apenas em casos excepcionais quando for realmente necess√°rio! </p><br><h3 id="obrabotka-oshibok">  Tratamento de erros </h3><br><p>  A principal coisa a fazer com erros "inesperados" √© encontrar um lugar onde voc√™ possa intercept√°-los.  Nos idiomas da JVM, esse pode ser um ponto de cria√ß√£o de fluxo ou um ponto de filtro / entrada para o m√©todo http, onde voc√™ pode colocar uma tentativa de captura com o tratamento de erros <code>unchecked</code> verificados.  Se voc√™ usar qualquer estrutura, provavelmente j√° ter√° a capacidade de criar manipuladores de erro comuns, como, por exemplo, no Spring Framework, voc√™ pode usar m√©todos com a anota√ß√£o <code>@ExceptionHandler</code> . </p><br><p>  Voc√™ pode "criar" exce√ß√µes para esses pontos centrais de processamento que n√£o queremos manipular em locais espec√≠ficos, lan√ßando as mesmas exce√ß√µes n√£o verificadas (quando, por exemplo, n√£o sabemos o que fazer em um local espec√≠fico e como lidar com o erro).  Mas esse m√©todo nem sempre √© adequado, porque √†s vezes pode ser necess√°rio tratar o erro no local e voc√™ precisa verificar se todos os locais de chamadas de fun√ß√£o s√£o processados ‚Äã‚Äãcorretamente.  Considere maneiras de fazer isso. </p><br><ol><li><p>  Ainda use exce√ß√µes e o mesmo try-catch: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  A principal desvantagem √© que podemos ‚Äúesquecer‚Äù de envolv√™-lo em um try-catch no local da chamada e pular a tentativa de process√°-lo no local, por causa do qual a exce√ß√£o ser√° lan√ßada no ponto comum do processamento de erros.  Aqui, podemos acessar <code>checked</code> exce√ß√µes <code>checked</code> (para Java), mas obteremos todas as desvantagens mencionadas acima.  Essa abordagem √© conveniente, se o tratamento de erros no local nem sempre for necess√°rio, mas em casos raros, √© necess√°rio. </p><br></li><li><p>  Use a classe selada como resultado de uma chamada (Kotlin). <br>  No Kotlin, voc√™ pode limitar o n√∫mero de herdeiros de classe, torn√°-los comput√°veis ‚Äã‚Äãno est√°gio de compila√ß√£o - isso permite que o compilador verifique se todas as op√ß√µes poss√≠veis s√£o analisadas no c√≥digo.  Em Java, voc√™ pode criar uma interface comum e v√°rios descendentes, no entanto, perdendo as verifica√ß√µes no n√≠vel da compila√ß√£o. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Aqui temos algo como uma abordagem de erro <code>golang</code> quando voc√™ precisa verificar explicitamente os valores resultantes (ou ignorar explicitamente).  A abordagem √© bastante pr√°tica e especialmente conveniente quando voc√™ precisa lan√ßar muitos par√¢metros em cada situa√ß√£o.  A classe <code>Result</code> pode ser expandida com v√°rios m√©todos que facilitam a obten√ß√£o do resultado com uma exce√ß√£o lan√ßada acima, se houver (ou seja, n√£o precisamos lidar com o erro no local da chamada).  A principal desvantagem ser√° apenas a cria√ß√£o de objetos sup√©rfluos intermedi√°rios (e uma entrada um pouco mais detalhada), mas tamb√©m pode ser removida usando classes <code>inline</code> (se um argumento for suficiente para n√≥s).  e, como um exemplo espec√≠fico, h√° uma classe <code>Result</code> do Kotlin.  √â verdade que √© apenas para uso interno, pois  no futuro, sua implementa√ß√£o poder√° mudar um pouco, mas se voc√™ quiser us√°-lo, poder√° adicionar o sinalizador de compila√ß√£o <code>-Xallow-result-return-type</code> . </p><br></li><li><p>  Como um dos tipos poss√≠veis da reivindica√ß√£o 2, o uso do tipo da programa√ß√£o funcional de <code>Either</code> , que pode ser um resultado ou um erro.  O pr√≥prio tipo pode ser uma classe <code>sealed</code> ou uma classe <code>inline</code> .  Abaixo est√° um exemplo de uso da implementa√ß√£o da biblioteca de <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> deles <code>Either</code> mais adequado para quem gosta de uma abordagem funcional e gosta de criar cadeias de chamadas. </p><br></li><li><p>  Use <code>Option</code> ou tipo <code>nullable</code> do Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Essa abordagem √© adequada se a causa do erro n√£o for muito importante e quando for apenas uma.  Uma resposta vazia √© considerada um erro e √© lan√ßada mais alto.  O registro mais curto, sem criar objetos adicionais, mas essa abordagem nem sempre pode ser aplicada. </p><br></li><li><p>  Semelhante ao item 4, usa apenas um valor de c√≥digo fixo como marcador de erro: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(‚Äúerror‚Äù) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  Esta √© provavelmente a abordagem mais antiga de tratamento de erros que voltou de <code>C</code> (ou mesmo de Algol).  N√£o h√° sobrecarga, apenas um c√≥digo que n√£o √© totalmente claro (junto com restri√ß√µes na escolha do resultado), mas, ao contr√°rio da etapa 4, √© poss√≠vel criar v√°rios c√≥digos de erro se mais de uma exce√ß√£o poss√≠vel for necess√°ria. </p><br></li></ol><br><h3 id="vyvody">  Conclus√µes </h3><br><p>  Todas as abordagens podem ser combinadas, dependendo da situa√ß√£o, e nenhuma delas √© adequada em todos os casos. </p><br><p>  Assim, por exemplo, voc√™ pode obter uma abordagem <code>golang</code> para erros usando classes <code>sealed</code> e, quando isso n√£o for muito conveniente, passar para erros <code>unchecked</code> verificados. </p><br><p>  Ou, na maioria dos lugares, <code>nullable</code> tipo <code>nullable</code> como um marcador que n√£o foi poss√≠vel calcular o valor ou obt√™-lo de algum lugar (por exemplo, como um indicador de que o valor n√£o foi encontrado no banco de dados). </p><br><p>  E se voc√™ tiver um c√≥digo totalmente funcional, juntamente com a <code>arrow</code> ou alguma outra biblioteca similar, √© mais prov√°vel que voc√™ use <code>Either</code> . </p><br><p>  Quanto aos servidores http, √© mais f√°cil elevar todos os erros a pontos centrais e somente em alguns lugares combina a abordagem <code>nullable</code> com classes <code>sealed</code> . </p><br><p>  Ficarei feliz em ver nos coment√°rios que voc√™ est√° usando isso, ou talvez haja outros m√©todos convenientes de tratamento de erros? </p><br><p>  E obrigado a todos que leram at√© o fim! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471766/">https://habr.com/ru/post/pt471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471748/index.html">Otimiza√ß√£o de farm√°cia: o que fizemos com a matem√°tica</a></li>
<li><a href="../pt471750/index.html">Gerenciamento de acesso privilegiado como uma tarefa priorit√°ria em seguran√ßa da informa√ß√£o (por exemplo, Fudo PAM)</a></li>
<li><a href="../pt471756/index.html">Como o servidor inicia</a></li>
<li><a href="../pt471758/index.html">Como traduzir texto para um idioma diferente?</a></li>
<li><a href="../pt471760/index.html">Edward Snowden: O Campo de Batalha - Criptografia</a></li>
<li><a href="../pt471770/index.html">Conhe√ßa o Big Data Tools: suporte a notebook Spark e Zeppelin no IntelliJ IDEA</a></li>
<li><a href="../pt471772/index.html">Ferramentas para ativar e desenvolver aplicativos Java, compila√ß√£o, execu√ß√£o na JVM</a></li>
<li><a href="../pt471774/index.html">API Camera2 do Android do bule, parte 2, gravando um v√≠deo</a></li>
<li><a href="../pt471776/index.html">Laravel: explique os conceitos b√°sicos. Parte Dois: Pr√°tica</a></li>
<li><a href="../pt471778/index.html">Quebrando o Micosoft Lunix no HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>