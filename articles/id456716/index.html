<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è üìî üßîüèø Bukan data yang sangat besar üè∫ üë©üèæ‚Äçüåæ üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan membahas fitur yang disediakan oleh partisi deklaratif built-in atau deklaratif dalam versi 12 PostgreSQL. Demonstrasi disiapkan untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bukan data yang sangat besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/456716/">  Artikel ini akan membahas fitur yang disediakan oleh partisi deklaratif built-in atau deklaratif dalam versi 12 PostgreSQL.  Demonstrasi disiapkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceramah</a> eponymous di konferensi HighLoad ++ Siberia 2019 (upd: sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> muncul dengan ceramah). <br><br>  Semua contoh dieksekusi pada versi beta yang baru muncul: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> version();</code> </pre> <pre> <code class="plaintext hljs"> version ------------------------------------------------------------------------------------------------------------------ PostgreSQL 12beta1 on i686-pc-linux-gnu, compiled by gcc (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609, 32-bit (1 row)</code> </pre> <a name="habracut"></a><br>  Contoh-contoh menggunakan tabel pemesanan dan tiket dari database demo.  Tabel reservasi berisi entri selama tiga bulan dari Juni hingga Agustus 2017 dan memiliki struktur berikut: <br><br><pre> <code class="pgsql hljs">=&gt; \d bookings</code> </pre> <pre> <code class="plaintext hljs">Table "bookings.bookings" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | not null | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | not null | Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Reservasi dapat mencakup beberapa tiket.  Struktur meja dengan tiket: <br><br><pre> <code class="pgsql hljs">=&gt; \d tickets</code> </pre> <pre> <code class="plaintext hljs"> Table "bookings.tickets" Column | Type | Collation | Nullable | Default ----------------+-----------------------+-----------+----------+--------- ticket_no | character(13) | | not null | book_ref | character(6) | | not null | passenger_id | character varying(20) | | not null | passenger_name | text | | not null | contact_data | jsonb | | | Indexes: "tickets_pkey" PRIMARY KEY, btree (ticket_no) Foreign-key constraints: "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref) Referenced by: TABLE "ticket_flights" CONSTRAINT "ticket_flights_ticket_no_fkey" FOREIGN KEY (ticket_no) REFERENCES tickets(ticket_no)</code> </pre><br>  Informasi ini harus cukup untuk memahami contoh-contoh di mana kami akan mencoba membuat tabel dipartisi. <br><br>  ‚Üí Pelajari lebih lanjut tentang basis demo di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br><h2>  Kisaran Partisi </h2><br>  Pertama, cobalah membuat tabel pemesanan dipartisi berdasarkan rentang tanggal.  Dalam hal ini, tabel akan dibuat seperti ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY RANGE</span></span>(book_date);</code> </pre><br>  Bagian terpisah untuk setiap bulan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201706 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-06-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201707 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>);</code> </pre><br>  Untuk menunjukkan batas-batas bagian, Anda dapat menggunakan tidak hanya konstanta, tetapi juga ekspresi, misalnya, panggilan fungsi.  Nilai ekspresi dihitung pada saat bagian dibuat dan disimpan di direktori sistem: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201708 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.08.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.09.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>));</code> </pre><br>  Deskripsi tabel: <br><br><pre> <code class="pgsql hljs">=&gt; \d+ bookings_range</code> </pre> <pre> <code class="plaintext hljs">Partitioned table "bookings.bookings_range" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description --------------+--------------------------+-----------+----------+---------+----------+--------------+------------- book_ref | character(6) | | | | extended | | book_date | timestamp with time zone | | | | plain | | total_amount | numeric(10,2) | | | | main | | Partition key: RANGE (book_date) Partitions: bookings_range_201706 FOR VALUES FROM ('2017-06-01 00:00:00+03') TO ('2017-07-01 00:00:00+03'), bookings_range_201707 FOR VALUES FROM ('2017-07-01 00:00:00+03') TO ('2017-08-01 00:00:00+03'), bookings_range_201708 FOR VALUES FROM ('2017-08-01 00:00:00+03') TO ('2017-09-01 00:00:00+03')</code> </pre> <br>  Sudah cukup.  Tidak ada pemicu untuk memasukkan catatan, tidak ada kendala PERIKSA yang dibutuhkan.  Parameter CONSTRAINT_EXCLUSION juga tidak diperlukan, Anda bahkan dapat mematikannya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> constraint_exclusion = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre><br>  Mengisi dengan tata letak otomatis di bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre> <pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre> <br>  Sintaks deklaratif masih menyembunyikan tabel yang diwarisi, sehingga Anda dapat melihat distribusi baris di bagian dengan kueri: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre> <pre> <code class="plaintext hljs"> tableoid | count -----------------------+-------- bookings_range_201706 | 7303 bookings_range_201707 | 167062 bookings_range_201708 | 88423 (3 rows)</code> </pre> <br>  Tetapi tidak ada data di tabel induk: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> bookings_range;</code> </pre><pre> <code class="plaintext hljs"> book_ref | book_date | total_amount ----------+-----------+-------------- (0 rows)</code> </pre> <br>  Periksa pengecualian bagian dalam rencana kueri: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------- Seq Scan on bookings_range_201707 Filter: (book_date = '2017-07-01 00:00:00+03'::timestamp with time zone) (2 rows)</code> </pre> <br>  Memindai hanya satu bagian, seperti yang diharapkan. <br><br>  Contoh berikut menggunakan fungsi to_timestamp dengan kategori variabilitas STABLE alih-alih konstanta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Append Subplans Removed: 2 -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) (4 rows)</code> </pre> <br>  Nilai fungsi dihitung ketika rencana kueri diinisialisasi dan bagian dari bagian dikeluarkan dari tampilan (Subplans Dihapus baris). <br><br>  Tapi ini hanya berfungsi untuk SELECT.  Saat mengubah data, pengecualian bagian berdasarkan nilai fungsi STABLE belum diterapkan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Delete on bookings_range Delete on bookings_range_201706 Delete on bookings_range_201707 Delete on bookings_range_201708 -&gt; Seq Scan on bookings_range_201706 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) -&gt; Seq Scan on bookings_range_201708 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) (10 rows)</code> </pre> <br>  Karena itu, Anda harus menggunakan konstanta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Delete on bookings_range Delete on bookings_range_201707 -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = '2017-07-01 00:00:00+03'::timestamp with time zone) (4 rows)</code> </pre> <br><h2>  Penyortiran indeks </h2><br>  Untuk melakukan kueri berikut, pengurutan hasil yang diperoleh dari bagian yang berbeda diperlukan.  Oleh karena itu, dalam paket kueri, kita melihat simpul SORT dan biaya awal paket yang tinggi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_date;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------ Sort (cost=24649.77..25077.15 rows=170952 width=52) Sort Key: bookings_range_201706.book_date -&gt; Append (cost=0.00..4240.28 rows=170952 width=52) -&gt; Seq Scan on bookings_range_201706 (cost=0.00..94.94 rows=4794 width=52) -&gt; Seq Scan on bookings_range_201707 (cost=0.00..2151.30 rows=108630 width=52) -&gt; Seq Scan on bookings_range_201708 (cost=0.00..1139.28 rows=57528 width=52) (6 rows)</code> </pre> <br>  Buat indeks di book_date.  Alih-alih satu indeks global, indeks dibuat di setiap bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range(book_date);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \di bookings_range*</code> </pre> <pre> <code class="plaintext hljs"> List of relations Schema | Name | Type | Owner | Table ----------+-------------------------------------+-------+---------+----------------------- bookings | bookings_range_201706_book_date_idx | index | student | bookings_range_201706 bookings | bookings_range_201707_book_date_idx | index | student | bookings_range_201707 bookings | bookings_range_201708_book_date_idx | index | student | bookings_range_201708 (3 rows)</code> </pre> <br>  Kueri sebelumnya dengan penyortiran sekarang dapat menggunakan indeks pada kunci partisi dan segera mengembalikan hasilnya dari bagian yang berbeda dalam bentuk diurutkan.  Node SORT tidak diperlukan dan biaya minimum diperlukan untuk menghasilkan baris pertama dari hasilnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_date;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------------------- Append (cost=1.12..14880.88 rows=262788 width=52) -&gt; Index Scan using bookings_range_201706_book_date_idx on bookings_range_201706 (cost=0.28..385.83 rows=7303 width=52) -&gt; Index Scan using bookings_range_201707_book_date_idx on bookings_range_201707 (cost=0.42..8614.35 rows=167062 width=52) -&gt; Index Scan using bookings_range_201708_book_date_idx on bookings_range_201708 (cost=0.42..4566.76 rows=88423 width=52) (4 rows)</code> </pre> <br>  Indeks yang dipartisi dibuat dengan cara ini didukung secara terpusat.  Saat menambahkan bagian baru, indeks akan secara otomatis dibuat di atasnya.  Dan Anda tidak dapat menghapus indeks hanya satu bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> bookings_range_201706_book_date_idx;</code> </pre><pre> <code class="plaintext hljs">ERROR: cannot drop index bookings_range_201706_book_date_idx because index book_date_idx requires it HINT: You can drop index book_date_idx instead.</code> </pre> <br>  Hanya seluruhnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx;</code> </pre><pre> <code class="plaintext hljs">DROP INDEX</code> </pre> <br><h2>  BUAT INDEKS ... CONCURRENTLY </h2><br>  Saat membuat indeks pada tabel yang dipartisi, Anda tidak dapat menentukan secara CONCURRENTLY. <br><br>  Tetapi Anda dapat melakukan hal berikut.  Pertama, kami membuat indeks hanya di tabel utama, itu akan menerima status tidak valid: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> bookings_range(book_date);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indisvalid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">'book_date_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> indisvalid ------------ f (1 row)</code> </pre><br>  Kemudian buat indeks pada semua bagian dengan opsi CONCURRENTLY: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201706_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201706 (book_date); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201707_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201707 (book_date); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201708_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201708 (book_date);</code> </pre><br>  Sekarang kami menghubungkan indeks lokal ke global: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201706_idx; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201707_idx; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201708_idx;</code> </pre><br>  Ini mirip dengan menghubungkan tabel partisi, yang akan kita bahas nanti.  Segera setelah semua bagian indeks terhubung, indeks utama akan mengubah statusnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indisvalid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">'book_date_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> indisvalid ------------ t (1 row)</code> </pre> <br><h2>  Hubungkan dan lepaskan bagian </h2><br>  Pembuatan bagian secara otomatis tidak disediakan.  Oleh karena itu, mereka harus dibuat terlebih dahulu, sebelum catatan dengan nilai baru dari kunci partisi ditambahkan ke tabel. <br><br>  Kami akan membuat bagian baru sementara transaksi lain bekerja dengan tabel, pada saat yang sama kami akan melihat kunci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, mode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid() <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'bookings%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relation | mode -----------------------+----------------- bookings_range_201708 | AccessShareLock bookings_range_201707 | AccessShareLock bookings_range_201706 | AccessShareLock bookings_range | AccessShareLock (4 rows)</code> </pre> <br>  Kunci AccessShareLock dikenakan pada tabel utama, semua bagian dan indeks pada awal pernyataan.  Perhitungan fungsi to_timestamp dan pengecualian bagian terjadi kemudian.  Jika sebuah konstanta digunakan sebagai ganti fungsi, hanya tabel utama dan bagian booking_range_201707 yang akan dikunci.  Oleh karena itu, jika mungkin, tetapkan konstanta dalam permintaan - ini harus dilakukan, jika tidak, jumlah baris dalam pg_locks akan meningkat secara proporsional dengan jumlah bagian, yang dapat menyebabkan kebutuhan untuk meningkatkan max_locks_per_transaction. <br><br>  Tanpa menyelesaikan transaksi sebelumnya, buat bagian berikut untuk September di sesi baru: <br><br><pre> <code class="pgsql hljs"> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201709 (<span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> bookings_range); || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> bookings_range_201709 <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-10-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>); || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, mode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid() <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'bookings%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relation | mode -------------------------------------+-------------------------- bookings_range_201709_book_date_idx | AccessExclusiveLock bookings_range | ShareUpdateExclusiveLock bookings_range_201709 | ShareLock bookings_range_201709 | AccessExclusiveLock (4 rows)</code> </pre><br>  Saat membuat bagian baru, kunci ShareUpdateExclusiveLock, kompatibel dengan AccessShareLock, dikenakan di tabel utama.  Oleh karena itu, operasi penambahan partisi tidak bertentangan dengan kueri terhadap tabel yang dipartisi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><pre> <code class="pgsql hljs"> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br>  Partisi dilakukan dengan perintah ALTER TABLE ... DETACH PARTITION.  Bagian itu sendiri tidak dihapus, tetapi menjadi tabel independen.  Data dapat diunduh darinya, dapat dihapus, dan jika perlu dihubungkan kembali (ATTACH PARTITION). <br><br>  Pilihan lain untuk menonaktifkan adalah menghapus bagian dengan perintah DROP TABLE. <br><br>  Sayangnya, kedua opsi, DROP TABLE dan DETACH PARTITION, gunakan kunci AccessExclusiveLock di tabel utama. <br><br><h2>  Bagian default </h2><br>  Jika Anda mencoba untuk menambahkan catatan yang bagiannya belum dibuat, kesalahan akan terjadi.  Jika perilaku ini tidak diinginkan, Anda dapat membuat bagian default: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_default <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>;</code> </pre> <br>  Misalkan ketika menambahkan catatan, mereka mencampuradukkan tanggal tanpa menentukan milenium: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-string"><span class="hljs-string">'XX0000'</span></span>, <span class="hljs-string"><span class="hljs-string">'0017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_date | total_amount ------------------------+----------+------------------------------+-------------- bookings_range_default | XX0000 | 0017-09-01 00:00:00+02:30:17 | 0.00 (1 row) INSERT 0 1</code> </pre> <br>  Kami perhatikan bahwa frase RETURNING mengembalikan baris baru, yang jatuh ke bagian default. <br><br>  Setelah mengatur tanggal saat ini (mengubah kunci partisi), catatan secara otomatis pindah ke bagian yang diinginkan, pemicu tidak diperlukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'XX0000'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_date | total_amount -----------------------+----------+------------------------+-------------- bookings_range_201709 | XX0000 | 2017-09-01 00:00:00+03 | 0.00 (1 row) UPDATE 1</code> </pre> <br><h2>  Bagian Daftar Nilai </h2><br>  Dalam database demo, kolom book_ref harus menjadi kunci utama dari tabel pemesanan.  Namun, skema partisi yang dipilih tidak memungkinkan membuat kunci seperti itu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>(book_ref);</code> </pre><pre> <code class="plaintext hljs">ERROR: insufficient columns in PRIMARY KEY constraint definition DETAIL: PRIMARY KEY constraint on table "bookings_range" lacks column "book_date" which is part of the partition key.</code> </pre> <br>  Kunci partisi harus dimasukkan dalam kunci utama. <br><br>  Untuk memecah berdasarkan bulan dan masih memasukkan book_ref di kunci utama, mari kita coba skema lain untuk mempartisi tabel pemesanan - sesuai dengan daftar nilai.  Untuk melakukan ini, tambahkan book_month kolom redundan sebagai kunci partisi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_list ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_month <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> (book_ref, book_month) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY LIST</span></span>(book_month);</code> </pre> <br>  Kami akan membentuk bagian secara dinamis berdasarkan data tabel pemesanan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dates <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,min(book_date)) min_date, date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,max(book_date)) max_date <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings ), <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> to_char(g.month, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> book_month <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dates, generate_series(dates.min_date, dates.max_date, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(month) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> format(<span class="hljs-string"><span class="hljs-string">'CREATE TABLE %I PARTITION OF bookings_list FOR VALUES IN (%L)'</span></span>, <span class="hljs-string"><span class="hljs-string">'bookings_list_'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month, <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>\gexec</code> </pre><pre> <code class="plaintext hljs">CREATE TABLE CREATE TABLE CREATE TABLE</code> </pre> <br>  Inilah yang terjadi: <br><br><pre> <code class="pgsql hljs">=&gt; \d+ bookings_list</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.bookings_list" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description --------------+--------------------------+-----------+----------+---------+----------+--------------+------------- book_ref | character(6) | | not null | | extended | | book_month | character(6) | | not null | | extended | | book_date | timestamp with time zone | | not null | | plain | | total_amount | numeric(10,2) | | | | main | | Partition key: LIST (book_month) Indexes: "bookings_list_pkey" PRIMARY KEY, btree (book_ref, book_month) Partitions: bookings_list_201706 FOR VALUES IN ('201706'), bookings_list_201707 FOR VALUES IN ('201707'), bookings_list_201708 FOR VALUES IN ('201708')</code> </pre> <br>  Mengisi tata letak di bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list(book_ref,book_month,book_date,total_amount) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> book_ref,to_char(book_date, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>),book_date,total_amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre><br>  Sebagai retret.  Untuk mengisi book_month secara otomatis, tergoda untuk menggunakan fungsionalitas baru dari versi 12 - GENERATED SELALU.  Namun, sayangnya, mereka tidak dapat digunakan sebagai kunci partisi.  Karena itu, tugas mengisi bulan harus diselesaikan dengan cara lain. <br><br>  Batasan integritas seperti PERIKSA dan BUKAN NULL dapat dibuat pada tabel yang dipartisi.  Seperti halnya pewarisan, menentukan INHERIT / NOINHERIT menunjukkan apakah batasan harus diwarisi pada semua tabel partisi.  INHERIT Bawaan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> book_date <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d bookings_range</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.bookings_range" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | | Partition key: RANGE (book_date) Indexes: "book_date_idx" btree (book_date) Number of partitions: 5 (Use \d+ to list them.)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d bookings_range_201706</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings_range_201706" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | | Partition of: bookings_range FOR VALUES FROM ('2017-06-01 00:00:00+03') TO ('2017-07-01 00:00:00+03') Indexes: "book_date_201706_idx" btree (book_date)</code> </pre> <br>  Batasan EXCLUDE hanya dapat dibuat secara lokal di partisi. <br><br>  Pencarian di book_ref akan terlihat di semua bagian, tetapi berdasarkan indeks, berkat fakta bahwa book_ref terdaftar terlebih dahulu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'00000F'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------- Append -&gt; Index Scan using bookings_list_201706_pkey on bookings_list_201706 Index Cond: (book_ref = '00000F'::bpchar) -&gt; Index Scan using bookings_list_201707_pkey on bookings_list_201707 Index Cond: (book_ref = '00000F'::bpchar) -&gt; Index Scan using bookings_list_201708_pkey on bookings_list_201708 Index Cond: (book_ref = '00000F'::bpchar) (7 rows)</code> </pre> <br>  Pencarian di book_ref dan rentang bagian hanya akan terlihat dalam rentang yang ditentukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'00000F'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> book_month = <span class="hljs-string"><span class="hljs-string">'201707'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------- Index Scan using bookings_list_201707_pkey on bookings_list_201707 Index Cond: ((book_ref = '00000F'::bpchar) AND (book_month = '201707'::bpchar)) (2 rows)</code> </pre> <br>  Perintah INSERT ... ON CONFLICT dengan benar menemukan bagian yang diinginkan dan melakukan pembaruan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XX0001'</span></span>,<span class="hljs-string"><span class="hljs-string">'201708'</span></span>,<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_month | book_date | total_amount ----------------------+----------+------------+------------------------+-------------- bookings_list_201708 | XX0001 | 201708 | 2017-08-01 00:00:00+03 | 0.00 (1 row) INSERT 0 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XX0001'</span></span>,<span class="hljs-string"><span class="hljs-string">'201708'</span></span>,<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONFLICT</span></span>(book_ref,book_month) <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> total_amount = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_month | book_date | total_amount ----------------------+----------+------------+------------------------+-------------- bookings_list_201708 | XX0001 | 201708 | 2017-08-01 00:00:00+03 | 100.00 (1 row) INSERT 0 1</code> </pre> <br><h2>  Kunci asing </h2><br>  Dalam database demo, tabel tiket mengacu pada pemesanan. <br><br>  Untuk memungkinkan kunci asing, tambahkan kolom book_month, dan pada saat yang sama pilah menjadi beberapa bagian per bulan, seperti booking_list. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tickets_list ( ticket_no <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">13</span></span>), book_month <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, passenger_id <span class="hljs-type"><span class="hljs-type">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, passenger_name <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, contact_data <span class="hljs-type"><span class="hljs-type">jsonb</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> (ticket_no, book_month), <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN KEY</span></span> (book_ref, book_month) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> bookings_list (book_ref, book_month) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY LIST</span></span> (book_month);</code> </pre><br>  Pembatasan KUNCI ASING layak untuk dilihat lebih dekat.  Di satu sisi, ini adalah kunci asing <i>dari</i> tabel dipartisi (tickets_list), dan di sisi lain, ini adalah kunci <i>ke</i> tabel dipartisi (booking_list).  Dengan demikian, kunci asing untuk tabel dipartisi didukung di kedua arah. <br><br>  Buat bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dates <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,min(book_date)) min_date, date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,max(book_date)) max_date <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings ), <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> to_char(g.month, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> book_month <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dates, generate_series(dates.min_date, dates.max_date, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(month) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> format(<span class="hljs-string"><span class="hljs-string">'CREATE TABLE %I PARTITION OF tickets_list FOR VALUES IN (%L)'</span></span>, <span class="hljs-string"><span class="hljs-string">'tickets_list_'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month, <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>\gexec</code> </pre><pre> <code class="plaintext hljs">CREATE TABLE CREATE TABLE CREATE TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ tickets_list</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.tickets_list" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description ----------------+-----------------------+-----------+----------+---------+----------+--------------+------------- ticket_no | character(13) | | not null | | extended | | book_month | character(6) | | not null | | extended | | book_ref | character(6) | | not null | | extended | | passenger_id | character varying(20) | | not null | | extended | | passenger_name | text | | not null | | extended | | contact_data | jsonb | | | | extended | | Partition key: LIST (book_month) Indexes: "tickets_list_pkey" PRIMARY KEY, btree (ticket_no, book_month) Foreign-key constraints: "tickets_list_book_ref_book_month_fkey" FOREIGN KEY (book_ref, book_month) REFERENCES bookings_list(book_ref, book_month) Partitions: tickets_list_201706 FOR VALUES IN ('201706'), tickets_list_201707 FOR VALUES IN ('201707'), tickets_list_201708 FOR VALUES IN ('201708')</code> </pre> <br>  Kami mengisi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tickets_list (ticket_no,book_month,book_ref,passenger_id,passenger_name,contact_data) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> t.ticket_no,b.book_month,t.book_ref, t.passenger_id,t.passenger_name,t.contact_data <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref);</code> </pre><pre> <code class="plaintext hljs">INSERT 0 366733</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> tickets_list;</code> </pre><br>  Distribusi garis menjadi beberapa bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tickets_list <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre><pre> <code class="plaintext hljs"> tableoid | count ---------------------+-------- tickets_list_201706 | 10160 tickets_list_201707 | 232755 tickets_list_201708 | 123818 (3 rows)</code> </pre> <br><h2>  Permintaan koneksi dan agregasi </h2><br>  Bergabunglah dengan dua tabel yang dipartisi dengan cara yang sama: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets_list t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.book_month = t.book_month);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------- Hash Join Hash Cond: ((t.book_ref = b.book_ref) AND (t.book_month = b.book_month)) -&gt; Append -&gt; Seq Scan on tickets_list_201706 t -&gt; Seq Scan on tickets_list_201707 t_1 -&gt; Seq Scan on tickets_list_201708 t_2 -&gt; Hash -&gt; Append -&gt; Seq Scan on bookings_list_201706 b -&gt; Seq Scan on bookings_list_201707 b_1 -&gt; Seq Scan on bookings_list_201708 b_2 (11 rows)</code> </pre> <br>  Sebelum memulai koneksi, setiap tabel terlebih dahulu menggabungkan bagian yang termasuk dalam kondisi kueri. <br><br>  Tapi pertama-tama Anda bisa menggabungkan bagian bulanan yang sesuai dari kedua tabel, dan kemudian menggabungkan hasilnya.  Ini dapat dicapai dengan mengaktifkan parameter enable_partitionwise_join: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partitionwise_join = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets_list t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.book_month = t.book_month);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------ Append -&gt; Hash Join Hash Cond: ((t.book_ref = b.book_ref) AND (t.book_month = b.book_month)) -&gt; Seq Scan on tickets_list_201706 t -&gt; Hash -&gt; Seq Scan on bookings_list_201706 b -&gt; Hash Join Hash Cond: ((t_1.book_ref = b_1.book_ref) AND (t_1.book_month = b_1.book_month)) -&gt; Seq Scan on tickets_list_201707 t_1 -&gt; Hash -&gt; Seq Scan on bookings_list_201707 b_1 -&gt; Hash Join Hash Cond: ((t_2.book_ref = b_2.book_ref) AND (t_2.book_month = b_2.book_month)) -&gt; Seq Scan on tickets_list_201708 t_2 -&gt; Hash -&gt; Seq Scan on bookings_list_201708 b_2 (16 rows)</code> </pre> <br>  Sekarang, pertama, bagian yang sesuai dari dua tabel bergabung, dan kemudian hasil gabungan digabungkan. <br><br>  Situasi serupa dengan agregasi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------- Finalize Aggregate -&gt; Gather Workers Planned: 2 -&gt; Partial Aggregate -&gt; Parallel Append -&gt; Parallel Seq Scan on bookings_list_201707 -&gt; Parallel Seq Scan on bookings_list_201708 -&gt; Parallel Seq Scan on bookings_list_201706 (8 rows)</code> </pre> <br>  Perhatikan bahwa pemindaian bagian dapat dilakukan secara paralel.  Tetapi pertama-tama bagian-bagian itu bersatu, baru kemudian agregasi dimulai.  Atau, Anda dapat melakukan agregasi di setiap bagian, lalu menggabungkan hasilnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partitionwise_aggregate = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------- Finalize Aggregate -&gt; Gather Workers Planned: 2 -&gt; Parallel Append -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201707 -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201708 -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201706 (10 rows)</code> </pre> <br>  Fitur-fitur ini sangat penting jika bagian dari bagian adalah tabel eksternal.  Secara default, keduanya dinonaktifkan karena  parameter yang sesuai memengaruhi waktu rencana, tetapi mungkin tidak selalu digunakan. <br><br><h2>  Partisi Hash </h2><br>  Cara ketiga untuk mempartisi tabel adalah partisi hash. <br><br>  Membuat tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY HASH</span></span>(book_ref);</code> </pre><br>  Dalam versi book_ref ini, sebagai kunci partisi, Anda dapat segera mendeklarasikannya sebagai kunci utama. <br><br>  Membagi menjadi tiga bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p0 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">0</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p1 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p2 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Mengisi dengan tata letak otomatis di bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre> <br>  Distribusi garis dalam bagian terjadi secara merata: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre><pre> <code class="plaintext hljs"> partition | count ------------------+------- bookings_hash_p0 | 87649 bookings_hash_p1 | 87651 bookings_hash_p2 | 87488 (3 rows)</code> </pre> <br>  Perintah baru untuk melihat objek yang dipartisi: <br><br><pre> <code class="pgsql hljs">=&gt; \dP+</code> </pre><pre> <code class="plaintext hljs"> List of partitioned relations Schema | Name | Owner | Type | Table | Total size | Description ----------+--------------------+---------+-------------------+----------------+------------+------------- bookings | bookings_hash | student | partitioned table | | 13 MB | bookings | bookings_list | student | partitioned table | | 15 MB | bookings | bookings_range | student | partitioned table | | 13 MB | bookings | tickets_list | student | partitioned table | | 50 MB | bookings | book_date_idx | student | partitioned index | bookings_range | 5872 kB | bookings | bookings_hash_pkey | student | partitioned index | bookings_hash | 5800 kB | bookings | bookings_list_pkey | student | partitioned index | bookings_list | 8120 kB | bookings | tickets_list_pkey | student | partitioned index | tickets_list | 19 MB | (8 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> bookings_hash;</code> </pre><br><h2>  Subqueries dan nested loop bergabung </h2><br>  Pengecualian bagian saat runtime dimungkinkan dengan koneksi loop bersarang. <br><br>  Distribusi 10 pemesanan pertama di bagian: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> partition | count ------------------+------- bookings_hash_p0 | 3 bookings_hash_p1 | 3 bookings_hash_p2 | 4 (3 rows)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita lihat rencana eksekusi kueri dengan gabungan tabel tables_hash dan subquery sebelumnya: </font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top10.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------------------- Nested Loop (actual rows=10 loops=1) -&gt; Limit (actual rows=10 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=10 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=3) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=1 loops=3) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=1 loops=4) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.632 ms Execution Time: 0.278 ms (13 rows)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi dibuat menggunakan metode nested loop. </font><font style="vertical-align: inherit;">Lingkaran luar sesuai dengan ekspresi tabel umum dijalankan 10 kali. </font><font style="vertical-align: inherit;">Tetapi perhatikan jumlah panggilan ke bagian-tabel (loop). </font><font style="vertical-align: inherit;">Untuk setiap nilai book_ref dari loop luar, hanya bagian yang dipindai tempat nilai ini disimpan dalam tabel tables_hash. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bandingkan dengan pengecualian bagian yang dinonaktifkan:</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partition_pruning <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top10.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------------ Nested Loop (actual rows=10 loops=1) -&gt; Limit (actual rows=10 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=10 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.886 ms Execution Time: 0.771 ms (13 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> enable_partition_pruning;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda mengurangi pilihan menjadi satu reservasi, maka dua bagian tidak akan terlihat sama sekali: </font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Nested Loop (actual rows=1 loops=1) -&gt; Limit (actual rows=1 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=1 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=1) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=1) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (never executed) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (never executed) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.250 ms Execution Time: 0.090 ms (13 rows)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih subquery, Anda dapat menggunakan fungsi mengembalikan set dengan kategori variabilitas STABLE: </font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_book_ref(top <span class="hljs-type"><span class="hljs-type">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SETOF</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN QUERY</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">EXECUTE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'SELECT * FROM bookings ORDER BY book_ref LIMIT $1'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">USING</span></span></span><span class="pgsql"> top; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">;$$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">STABLE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> get_book_ref(<span class="hljs-number"><span class="hljs-number">10</span></span>) f <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = f.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------------------- Nested Loop (actual rows=10 loops=1) -&gt; Function Scan on get_book_ref f (actual rows=10 loops=1) -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=3) Index Cond: (book_ref = f.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=1 loops=3) Index Cond: (book_ref = f.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=1 loops=4) Index Cond: (book_ref = f.book_ref) Planning Time: 0.175 ms Execution Time: 0.843 ms (11 rows)</code> </pre> <br><h2>  Ringkasan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulannya, kita dapat mengatakan bahwa partisi bawaan atau deklaratif di PostgreSQL 12 telah menerima serangkaian fitur yang kaya dan dapat dengan aman direkomendasikan untuk mengganti partisi melalui pewarisan. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456716/">https://habr.com/ru/post/id456716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456702/index.html">Keamanan ponsel OAuth 2.0</a></li>
<li><a href="../id456704/index.html">Enam cara penguji bisa mendapatkan keuntungan (selain pengujian fungsional)</a></li>
<li><a href="../id456710/index.html">Apa itu platform kode rendah / tanpa kode dan CRM, CRM +, ERP</a></li>
<li><a href="../id456712/index.html">Pencatatan lalu lintas selektif untuk layanan SOAP</a></li>
<li><a href="../id456714/index.html">Memahami angka floating point (bagian 0)</a></li>
<li><a href="../id456722/index.html">Resep PostgreSQL: Penjadwal Tugas Asinkron</a></li>
<li><a href="../id456724/index.html">5 cara yang sangat sederhana untuk mempercepat aplikasi VueJS Anda secara signifikan</a></li>
<li><a href="../id456730/index.html">Pesan "{Anda Tidak Tahu JS} Jenis dan Konstruksi Grammar"</a></li>
<li><a href="../id456732/index.html">Untuk menjadi seorang mentor</a></li>
<li><a href="../id456736/index.html">Resep PostgreSQL: cURL: dapatkan, kirim dan ... email</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>