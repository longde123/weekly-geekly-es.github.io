<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏾 🖋️ 👩🏾‍🤝‍👩🏼 Menguji @ NonNull / @ Nullable annotations ⏸️ ⏮️ 🤦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alih-alih "Didedikasikan untuk ..." 
 Tugas yang dijelaskan di bawah ini tidak inovatif atau sangat berguna, perusahaan tempat saya bekerja tidak akan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji @ NonNull / @ Nullable annotations</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464939/"><h3>  Alih-alih "Didedikasikan untuk ..." </h3><br>  Tugas yang dijelaskan di bawah ini tidak inovatif atau sangat berguna, perusahaan tempat saya bekerja tidak akan menerima untung, tetapi saya akan mendapat bonus. <br><br>  Tetapi tugas ini, dan karena itu harus diselesaikan. <br><br><h3>  Intro </h3><br>  Dalam artikel Anda akan sering bertemu kata Lombok, saya meminta para pembenci untuk tidak terburu-buru mengambil kesimpulan. <br>  Saya tidak akan "tenggelam" untuk Lombok atau ketidakhadirannya, saya, seperti Geralt Sapkovsky, mencoba bersikap netral, dan saya bisa membaca kode dengan atau tanpa Lombok dengan tenang dan tanpa gemetar di abad ini. <br><br>  Tetapi pada proyek saat ini, perpustakaan yang disebutkan ada, dan sesuatu memberitahu saya bahwa proyek kami bukan satu-satunya. <br>  Jadi disini. <br><a name="habracut"></a><br>  Terakhir kali di java pasti ada kecenderungan ke arah annotashki.  Untuk kemuliaan konsep gagal cepat, parameter metode sering dijelaskan dengan penjelasan @NonNull (sehingga jika ada yang salah, maka ia pergi). <br><br>  Ada banyak opsi impor untuk ini (atau anotasi serupa dalam ideologi), tetapi, karena sudah menjadi jelas, kami akan fokus pada versi <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NonNull;</code> </pre> <cut></cut><br>  Jika Anda menggunakan anotasi ini (atau yang serupa), maka Anda memiliki kontrak yang perlu Anda periksa dengan tes dan setiap penganalisa kode statis akan memberi tahu Anda (Sonar memberi tahu Anda dengan tepat). <br><br>  Menguji anotasi ini dengan uji unit cukup sederhana, masalahnya adalah tes tersebut akan berlipat ganda dalam proyek Anda dengan kecepatan kelinci di musim semi, dan kelinci, seperti yang Anda tahu, melanggar prinsip KERING. <br><br>  Dalam artikel ini kami akan menulis kerangka uji kecil untuk menguji kontrak anotasi @NonNull (dan agar Sonar tidak bersinar di mata Anda dengan lampu merah yang tidak menyenangkan). <br><br>  <b>PS</b> Nama lagu itu terinspirasi oleh lagu dari band PowerWolf, yang dimainkan (oleh astaga) ketika saya menulis nama (dalam aslinya, namanya terdengar lebih positif) <br><br><h3>  Tubuh utama </h3><br>  Awalnya, kami menguji anotasi seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); fail(<span class="hljs-string"><span class="hljs-string">"Exception not thrown"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> NullPointerException e) { assertNotNull(e); } }</code> </pre> <br>  Mereka memanggil metode dan lulus nol sebagai parameter yang dijelaskan dengan penjelasan @NonNull. <br>  Mereka mendapat NPE dan puas (Sonar juga senang). <br><br>  Kemudian mereka mulai melakukan hal yang sama, tetapi dengan pernyataan yang lebih modis. Throw yang bekerja melalui Pemasok (kami suka lambdas): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertThrows(NullPointerException.class, () -&gt; instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); }</code> </pre> <br>  Bergaya.  Fashionable.  Pemuda <br><br>  Tampaknya mungkin untuk selesai, anotasi diuji, lalu apa lagi? <br><br>  Masalahnya (bukan itu masalahnya, tapi tetap saja) dari metode tes ini "muncul" ketika suatu hari saya menulis tes untuk suatu metode, itu berhasil, dan kemudian saya perhatikan bahwa tidak ada penjelasan pada @NonNull pada parameter. <br><br>  Dapat dimengerti: Anda memanggil metode pengujian, sambil tidak menggambarkan perilaku kelas moque, sampai kapan () / lalu ().  Utas pelaksana memasuki metode dengan aman, di suatu tempat di dalamnya menangkap NPE, pada objek yang tidak dikunci (atau dikunci, tetapi tanpa saat () / lalu ()), dan terhempas, namun dengan NPE, seperti yang Anda peringatkan, yang berarti pengujian berwarna hijau <br><br>  Ternyata kami sedang menguji dalam kasus ini, bukan anotasi, tetapi tidak jelas apa.  Dengan tes yang bekerja dengan benar, kita bahkan tidak harus masuk lebih dalam ke metode (jatuh di ambang pintu). <cut></cut><br>  @NonNull anotasi Lombok memiliki satu fitur: jika kita beralih dari NPE ke anotasi, nama parameter ditulis ke galat. <br><br>  Kami akan terlibat dalam hal ini, setelah kami jatuh dari NPE, kami juga akan memeriksa teks stacktrace, seperti ini: <br><br><pre> <code class="java hljs">exception.getCause().getMessage().equals(parameter.getName())</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Dan jika tiba-tiba ...</b> <div class="spoiler_text">  Jika Lombok tiba-tiba menyegarkan dan berhenti menulis nama parameter yang menerima null di stacktrace, maka kami akan meninjau kuliah Andrei Pangin tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM TI</a> dan menulis plug-in untuk JVM, di mana kami mentransfer nama parameter. <br></div></div><br>  Semuanya sepertinya tidak ada apa-apanya, sekarang kita benar-benar memeriksa apa yang dibutuhkan, tetapi masalah "kelinci" tidak terpecahkan. <br><br>  Saya ingin memiliki alat yang bisa dikatakan, misalnya, seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonNullAnnotationTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertNonNullAnnotation(YourPerfectClass.class); }</code> </pre> <br>  dan dia sendiri akan pergi dan memindai semua metode publik dari kelas yang ditentukan dan memeriksa semua parameter @NonNull mereka dengan tes. <br><br>  Anda akan berkata, dapatkan refleksi, dan periksa apakah metode @NonNull aktif dan apakah ada peluru di dalamnya nol. <br><br>  Semua tidak akan menjadi apa-apa, tetapi RetentionPolicy tidak sama. <br><br>  Semua anotasi memiliki parameter RetentionPolicy, yang dapat terdiri dari 3 jenis: SOURCE, CLASS dan RUNTIME, sehingga Lombok memiliki RetentionPolicy.SOURCE secara default, yang berarti bahwa anotasi ini tidak terlihat di Runtime dan Anda tidak akan menemukannya melalui refleksi. <br><br>  Dalam proyek kami, semua parameter metode publik diberi keterangan (tidak termasuk primitif), jika dipahami bahwa parameter tidak boleh nol, jika kebalikannya tersirat, maka parameter tersebut dijelaskan oleh pegas @Nullable.  Anda dapat terlibat dalam hal ini, kami akan mencari semua metode publik, dan semua parameter di dalamnya yang tidak ditandai @Nullable dan bukan primitif. <br>  Kami bermaksud bahwa untuk semua kasus lain, @NonNull anotasi harus pada parameter. <br><br>  Untuk kenyamanan, jika memungkinkan, kami akan menyebarkan logika dengan metode pribadi, untuk memulai kami akan mendapatkan semua metode publik: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); }</code> </pre> <br>  di mana METHOD_FILTER adalah predikat reguler di mana kami mengatakan bahwa: <br><br><ul><li>  Metode harus publik </li><li>  Seharusnya tidak sintetik (dan ini terjadi ketika Anda memiliki metode dengan parameter mentah) </li><li>  Seharusnya tidak abstrak (tentang kelas abstrak secara terpisah dan di bawah) </li><li>  Nama metode tidak boleh sama (dalam kasus semacam orang jahat memutuskan untuk mengisi kelas dengan yang sama dengan ditimpa () pada input kerangka kerja POJO kami) </li></ul><br>  Setelah kami mendapatkan semua metode yang kami butuhkan, kami mulai memilahnya dalam satu lingkaran, <br>  jika metode ini tidak memiliki parameter sama sekali, maka ini bukan kandidat kami: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Jika ada parameter, kita perlu memahami apakah mereka beranotasi @NonNull (harus lebih tepat, menurut <br><br><div class="spoiler">  <b class="spoiler_title">logika</b> <div class="spoiler_text"><ul><li>  metode publik </li><li>  tidak bisa dihapus </li><li>  tidak primitif </li></ul><br></div></div><br>  Untuk melakukan ini, buat peta dan letakkan parameter kami di dalamnya sesuai dengan urutan dalam metode, dan sebaliknya, kita beri tanda yang menyatakan apakah anotasi @NonNull harus di atas atau tidak: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  peta ini berguna bagi kita untuk kemudian memanggil metode dan meneruskannya nol ke semua parameter dengan penjelasan @NonNull pada gilirannya, dan bukan hanya yang pertama. <br><br>  Parameter nonNullAnnotationCount menghitung berapa banyak parameter dalam metode yang harus dianotasi @NonNull, itu akan menentukan jumlah interaksi integrasi panggilan untuk setiap metode. <br><br>  Ngomong-ngomong, jika tidak ada anotasi @NonNull (ada parameter, tetapi semuanya primitif atau @Nullable), maka tidak ada yang perlu dibicarakan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Kami memiliki peta parameter.  Kita tahu berapa kali memanggil metode dan di mana posisi nol, masalahnya kecil (seperti yang saya pikir naif tanpa memahami), kita perlu membuat instance kelas dan memanggil metode pada mereka. <br><br>  Masalah dimulai ketika Anda menyadari betapa berbedanya sebuah instance: itu bisa menjadi kelas privat, itu bisa menjadi kelas dengan satu konstruktor default, dengan satu konstruktor dengan parameter, dengan konstruktor ini dan itu, kelas abstrak, antarmuka (dengan metode default, yang juga publik dan yang juga perlu diuji). <br><br>  Dan ketika kita membangun instance dengan cara kait atau dengan penjahat, kita perlu melewatkan parameter ke metode invoke dan di sini juga membentang: bagaimana cara membuat instance dari kelas akhir?  dan Enum?  dan primitif?  dan array primitif (yang juga merupakan objek dan juga dapat dijelaskan). <br><br>  Baiklah, mari kita lakukan secara berurutan. <br><br>  Kasus pertama adalah kelas dengan satu konstruktor pribadi: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  lalu kita panggil metode invoke kita, berikan clazz yang datang dari luar ke tes dan array parameter di mana null sudah dibebankan ke posisi pertama dengan bendera untuk anotasi @NonNull (ingat, di atas kita buat peta @ NonNulls) kita mulai jalankan dalam satu lingkaran dan buat array parameter, secara bergantian ubah posisi parameter nol, dan beri tanda flag sebelum memanggil metode, sehingga pada integrasi berikutnya parameter lainnya menjadi nol. <br><br>  Dalam kode, tampilannya seperti ini: <br><br><pre> <code class="java hljs">val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } }</code> </pre> <br>  Opsi pertama instantiasi diselesaikan. <br><br>  Antarmuka lebih lanjut, Anda tidak dapat mengambil dan membuat instance antarmuka (bahkan tidak memiliki konstruktor). <br><br>  Oleh karena itu, dengan antarmuka akan seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  createInstanceByDynamicProxy memungkinkan kita membuat instance di kelas jika mengimplementasikan setidaknya satu antarmuka, atau itu sendiri antarmuka <br><br><div class="spoiler">  <b class="spoiler_title">Nuansa</b> <div class="spoiler_text">  perlu diingat bahwa di sini secara mendasar yang menghubungkan implementasi kelas, tipe antarmuka (dan bukan beberapa yang sebanding) adalah penting, di mana ada metode yang Anda implementasikan di kelas target, jika tidak contoh akan mengejutkan Anda dengan tipenya <br></div></div><br>  tapi di dalamnya seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Menyapu</b> <div class="spoiler_text">  Ngomong-ngomong, ada juga beberapa garu di sini, saya tidak ingat yang mana lagi, ada banyak, tetapi Anda perlu membuat proxy melalui Lookup.class <br></div></div><br>  Contoh berikutnya (favorit saya) adalah kelas abstrak.  Dan di sini proxy dinamis tidak akan membantu kita lagi, karena jika kelas abstrak mengimplementasikan beberapa jenis antarmuka, maka ini jelas bukan tipe yang kita inginkan.  Dan seperti itu, kita tidak bisa mengambil dan membuat newInstance () dari kelas abstrak.  Di sini CGLIB akan datang ke bantuan kami, lib pegas yang membuat proxy berdasarkan pewarisan, tetapi masalahnya adalah, kelas target harus memiliki konstruktor default (tanpa parameter) <br><br><div class="spoiler">  <b class="spoiler_title">Gosip</b> <div class="spoiler_text">  Meskipun dinilai oleh gosip di Internet sejak Musim Semi 4, CGLIB dapat bekerja tanpanya, dan karenanya: <b>Jadi itu tidak bekerja!</b> <br></div></div>  Opsi untuk membuat instance kelas abstrak adalah sebagai berikut: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); }</code> </pre> <br>  makeErrorMessage (), yang sudah terlihat dalam contoh kode, menjatuhkan tes, jika kita memanggil metode dengan parameter @NonNull beranotasi lewat nol dan tidak jatuh, maka tes tidak bekerja, maka tes tidak bekerja, Anda harus turun. <br><br>  Untuk pemetaan parameter, kami memiliki satu metode umum yang dapat memetakan dan mengunci parameter konstruktor dan metode, seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } }</code> </pre> <br>  Perhatikan pembuatan Enum (cherry on the cake), secara umum, Anda tidak bisa hanya mengambil dan membuat Enum. <br><br>  Di sini untuk parameter akhir pemetaan Anda sendiri, untuk non-final Anda sendiri, dan kemudian hanya dalam teks (kode). <br><br>  Nah, setelah kami membuat parameter untuk konstruktor dan untuk metode, kami membentuk contoh kami: <br><br><pre> <code class="java hljs">val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method);</code> </pre> <cut></cut><br>  Kita sudah tahu pasti bahwa karena kita telah mencapai tahap kode ini, itu berarti bahwa kita memiliki setidaknya satu konstruktor, kita dapat mengambil apa pun untuk membuat sebuah instance, jadi kita mengambil yang pertama yang kita lihat, melihat apakah ia memiliki parameter dalam konstruktor dan jika tidak, maka panggil seperti ini: <br><br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <br><br>  Nah, jika ada yang seperti ini: <br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <cut></cut><br>  Ini adalah logika yang terjadi dalam metode createAndInvoke () yang Anda lihat sedikit lebih tinggi. <br>  Versi lengkap dari kelas tes di bawah spoiler, saya tidak mengunggah ke git, seperti yang saya tulis di proyek kerja, tetapi sebenarnya itu hanya satu kelas yang dapat diwarisi dalam tes Anda dan digunakan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Method&gt; METHOD_FILTER = method -&gt; isPublic(method.getModifiers()) &amp;&amp; isFalse(method.isSynthetic()) &amp;&amp; isFalse(isAbstract(method.getModifiers())) &amp;&amp; isFalse(method.getName().equals(<span class="hljs-string"><span class="hljs-string">"equals"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; isFalse(clazz.isInterface()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; INTERFACE_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiPredicate&lt;Exception, Parameter&gt; LOMBOK_ERROR_FILTER = (exception, parameter) -&gt; isNull(exception.getCause().getMessage()) || isFalse(exception.getCause().getMessage().equals(parameter.getName())); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertNonNullAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val method : getPublicMethods(clazz)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; nonNullAnnotationCount; j++) { val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); } val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LOMBOK_ERROR_FILTER.test(e, parameterCurrentMethodArray[currentNullableIndex])) { makeErrorMessage(method); } } } } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndInvoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor firstFindConstructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] constructorParameterArray )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstFindConstructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance(constructorParameterArray)), invokeMethodParameterArray); } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByCGLIB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ MethodInterceptor handler = (obj, method1, args, proxy) -&gt; proxy.invoke(clazz, args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz.getConstructors().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParam.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParam, i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { val proxy = Enhancer.create(clazz, handler); method.invoke(proxy.getClass().newInstance(), invokeMethodParameterArray); } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"  @NonNull     DefaultConstructor  "</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method)</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"    "</span></span> + method.getName() + <span class="hljs-string"><span class="hljs-string">"   @NonNull"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingPrimitiveName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ val name = parameter.getType().getName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"long"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"int"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"byte"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"short"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"double"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>d; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"float"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"char"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; } } }</code> </pre> <br></div></div><br><h3>  Kesimpulan </h3><br>  Kode ini berfungsi dan menguji anotasi dalam proyek nyata, saat ini hanya ada satu opsi yang memungkinkan, ketika semua yang dikatakan dapat diciutkan. <br><br>  Nyatakan setter Lombock di kelas (jika ada spesialis yang tidak mengatur setter di kelas Pojo, meskipun itu tidak terjadi) dan bidang yang ditetapkan setter tidak akan final. <br><br>  Maka kerangka kerja akan dengan ramah mengatakan bahwa ada metode publik, dan ia memiliki parameter di mana tidak ada penjelasan @NonNull, solusinya sederhana: nyatakan setter secara eksplisit dan anotasi parameternya berdasarkan konteks logika @ NonNull / @ Nullable. <br><br>  Perhatikan bahwa jika Anda ingin saya terikat dengan nama parameter metode dalam pengujian Anda (atau sesuatu yang lain), dalam Runtime nama-nama variabel dalam metode tidak tersedia secara default, Anda akan menemukan arg [0] dan arg [1], dll. . <br>  Untuk mengaktifkan tampilan nama metode di Runtime, gunakan plugin Maven: <br><br><pre> <code class="java hljs">&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;${compile.target.source}&lt;/source/&gt; &lt;target&gt;${compile.target.source}&lt;/target&gt; &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt; &lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt;</code> </pre><br>  dan khususnya kunci ini: <br><br><pre> <code class="java hljs">&lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt;</code> </pre> <br>  Saya harap Anda tertarik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464939/">https://habr.com/ru/post/id464939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464929/index.html">Pemuatan gambar browser yang malas (memuat atribut)</a></li>
<li><a href="../id464931/index.html">Sisipan assembler ... dalam C #?</a></li>
<li><a href="../id464933/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 4. Game</a></li>
<li><a href="../id464935/index.html">DevOpsSec Nyaman: Nemesida WAF Gratis untuk NGINX dengan API dan akun pribadi</a></li>
<li><a href="../id464937/index.html">Intisari materi menarik untuk pengembang seluler # 312 (pada 19 - 25 Agustus)</a></li>
<li><a href="../id464947/index.html">Acara digital di Moskow dari 25 Agustus hingga 1 September</a></li>
<li><a href="../id464949/index.html">Sekali lagi tentang GCD, algoritma Euclidean dan sedikit tentang sejarah algoritma secara umum. Tentu saja dengan contoh Swift</a></li>
<li><a href="../id464951/index.html">Semakin sederhana tugasnya, semakin sering saya salah</a></li>
<li><a href="../id464955/index.html">Iron Mike Tyson dan proyek blockchain Fight to Fame</a></li>
<li><a href="../id464959/index.html">Mengurai kalimat bahasa Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>