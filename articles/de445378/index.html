<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 🌥️ 🏙️ Labyrinthe: Klassifizierung, Erzeugung, Suche nach Lösungen 💪🏽 💱 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser klassische Beitrag beschreibt die beliebtesten Methoden zum Erstellen und Durchlaufen von Labyrinthen. Der Artikel ist in vier Teile gegliedert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labyrinthe: Klassifizierung, Erzeugung, Suche nach Lösungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Dieser klassische Beitrag beschreibt die beliebtesten Methoden zum Erstellen und Durchlaufen von Labyrinthen.</i>  <i>Der Artikel ist in vier Teile gegliedert: Klassifizierung, Generierungsalgorithmen, Algorithmen zum Lösen von Labyrinthen und andere Operationen mit Labyrinthen.</i> <br><br><h2>  Labyrinthklassifikation </h2><br>  Die Labyrinthe als Ganzes (und damit die Algorithmen zu ihrer Erstellung) können in sieben verschiedene Klassifikationen unterteilt werden: Dimension, Hyperdimension, Topologie, Tessellation, Routing, Textur und Priorität.  Das Labyrinth kann ein Element aus jeder Klasse in einer beliebigen Kombination verwenden. <a name="habracut"></a><br>  <b>Dimension:</b> Die Dimensionsklasse bestimmt im Wesentlichen, wie viele Dimensionen im Raum das Labyrinth ausfüllt.  Folgende Typen stehen zur Verfügung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Zweidimensional</b> <b>: Die</b> meisten Labyrinthe, sowohl Papier als auch Real, haben diese Dimension. Das heißt, wir können den Plan des Labyrinths immer auf einem Blatt Papier anzeigen und uns entlang bewegen, ohne andere Korridore des Labyrinths zu überqueren. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Dreidimensional</b></a> <b>: Das</b> dreidimensionale Labyrinth hat mehrere Ebenen.  darin (zumindest in der orthogonalen Version) können Passagen zusätzlich zu den vier Himmelsrichtungen nach unten und nach oben gehen.  Ein 3D-Labyrinth wird häufig als eine Reihe von 2D-Ebenen mit Treppen nach oben und unten dargestellt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Höhere Dimensionen</b> <b>:</b> Sie können vierdimensionale und noch mehrdimensionale Labyrinthe erstellen.  Manchmal werden sie als 3D-Labyrinthe mit „Portalen“ dargestellt, die durch die vierte Dimension führen, z. B. Portale in die „Vergangenheit“ und „Zukunft“. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Verflechtung</b> <b>:</b> Labyrinthe mit Verflechtung - dies sind im Wesentlichen zweidimensionale (oder eher 2,5-dimensionale) Labyrinthe, in denen sich jedoch Passagen überlappen können.  Bei der Anzeige ist es normalerweise ziemlich offensichtlich, wo sich die Sackgassen befinden und wie sich ein Durchgang über dem anderen befindet.  Labyrinthe aus der realen Welt, in denen Brücken einen Teil des Labyrinths mit einem anderen verbinden, sind teilweise miteinander verflochten. </li></ul><br>  <b>Hyperdimension: Die</b> Klassifizierung nach <b>Hyperdimension</b> entspricht der Dimension eines Objekts, das sich durch ein Labyrinth bewegt, und nicht dem Labyrinth selbst.  Folgende Typen stehen zur Verfügung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Nicht-Hyperlabyrinthe</b> <b>:</b> Fast alle Labyrinthe, auch solche, die in hoher Dimensionalität oder mit speziellen Regeln erstellt wurden, sind normalerweise Nicht-Hyperlabyrinthe.  In ihnen arbeiten wir mit einem Punkt oder einem kleinen Objekt, zum Beispiel einem Ball oder dem Spieler selbst, der sich von Punkt zu Punkt bewegt, und die asphaltierte Route bildet eine Linie.  An jedem Punkt gibt es eine leicht zählbare Anzahl von Auswahlmöglichkeiten. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperlabyrinthe:</a></b> Hyperlabyrinthe sind Labyrinthe, in denen das zu lösende Objekt nicht nur ein Punkt ist.  Ein Standardhyperlabyrinth (oder Hyperlabyrinth erster Ordnung) besteht aus einer Linie, die eine Oberfläche bildet, wenn sie sich entlang eines Pfades bewegt.  Hyperlabyrinth kann nur in 3D oder in einem Medium mit einer größeren Dimension existieren, und der Eingang zum Hyperlabyrinth ist oft kein Punkt, sondern eine Linie.  Hyperlabyrinth ist grundlegend anders, weil es notwendig ist, mehrere Teile entlang der Linie zu berücksichtigen und gleichzeitig mit ihnen zu arbeiten, und zu jedem Zeitpunkt gibt es eine nahezu unendliche Anzahl von Zuständen und Optionen für das, was mit der Linie getan werden kann.  Die Lösungslinie ist unendlich oder ihre Endpunkte liegen außerhalb des Hyperlabyrinths, um zu vermeiden, dass die Linie zu einem Punkt komprimiert wird, da sie in diesem Fall als Nicht-Hyperlabyrinth betrachtet werden kann. </li><li>  <b>Hyperhyperlabyrinth:</b> Hyperlabyrinthe können beliebig hoch dimensioniert sein.  Hyperhyperlabyrinth (oder Hyperlabyrinth zweiter Ordnung) erhöht erneut die Dimension des zu lösenden Objekts.  Hier ist das zu lösende Objekt eine Ebene, die, wenn sie sich entlang des Pfades bewegt, eine dreidimensionale Figur bildet.  Hyperhyperlabyrinth kann nur in einer 4D- oder höherdimensionalen Umgebung existieren. </li></ul><br>  <b>Topologie: Die</b> Topologieklasse beschreibt die Geometrie des Labyrinthraums, in dem er als Ganzes existiert.  Folgende Typen stehen zur Verfügung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> Dies ist das Standardlabyrinth im euklidischen Raum. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: Der</b> Begriff „Planair“ beschreibt jedes Labyrinth mit einer ungewöhnlichen Topologie.  In der Regel bedeutet dies, dass die Ränder des Labyrinths auf interessante Weise miteinander verbunden sind.  Beispiele: Labyrinthe auf der Oberfläche eines Würfels, Labyrinthe auf der Oberfläche eines Mobius-Streifens und Labyrinthe, die denen eines Torus entsprechen, bei dem die linke und rechte, obere und untere Seite paarweise verbunden sind. </li></ul><br>  <b>Tessellation: Eine</b> Klassifizierung der Geometrie der einzelnen Zellen, aus denen das Labyrinth besteht.  Bestehende Typen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonal</b> <b>:</b> Dies ist ein rechteckiges Standardgitter, in dem Zellen Passagen haben, die sich im rechten Winkel schneiden.  Im Rahmen der Tessellation können sie auch als Gammalabyrinthe bezeichnet werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> Delta-Labyrinthe bestehen aus verbundenen Dreiecken, und an jede Zelle können bis zu drei Passagen angeschlossen werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>:</b> Sigma-Labyrinthe bestehen aus verbundenen Sechsecken.  Jede Zelle kann bis zu sechs Durchgänge haben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Theta</b> <b>:</b> Theta-Labyrinthe bestehen aus konzentrischen Kreisen von Durchgängen, bei denen der Anfang oder das Ende in der Mitte und der andere am äußeren Rand liegt.  Zellen haben normalerweise vier mögliche Verbindungspfade, aber aufgrund der größeren Anzahl von Zellen in den äußeren Ringen der Durchgänge kann es mehr geben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>:</b> Epsilon-Labyrinthe bestehen aus verbundenen Achtecken oder Quadraten. Jede Zelle in ihnen kann bis zu acht oder vier Durchgänge haben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: Das</b> Zeta-Labyrinth befindet sich in einem rechteckigen Raster. Nur neben horizontalen und vertikalen Passagen sind diagonale Passagen in einem Winkel von 45 Grad zulässig. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Omega</b> <b>: Der</b> Begriff Omega bezieht sich auf fast jedes Labyrinth mit konstanter nicht orthogonaler Tessellation.  Delta, Sigma, Theta und Ipsilon Labyrinthe sind von diesem Typ, wie viele andere Schemata, die Sie sich vorstellen können, zum Beispiel ein Labyrinth, das aus Paaren rechtwinkliger Dreiecke besteht. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Riss</b> <b>: Ein</b> Risslabyrinth ist ein amorphes Labyrinth ohne ständige Tessellation, in dem sich Wände und Gehwege in zufälligen Winkeln befinden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fraktal</b> <b>: Ein</b> fraktales Labyrinth ist ein Labyrinth aus kleineren Labyrinthen.  Ein fraktales Labyrinth aus verschachtelten Zellen ist ein Labyrinth in jeder Zelle, in dem andere Labyrinthe platziert sind, und dieser Vorgang kann mehrmals wiederholt werden.  Ein unendlich rekursives fraktales Labyrinth ist ein echtes Fraktal, in dem sich der Inhalt des Labyrinths selbst repliziert und ein im Wesentlichen unendlich großes Labyrinth erzeugt. </li></ul><br>  <b>Routing: Die</b> Klassifizierung nach Routing ist wahrscheinlich der interessanteste Aspekt bei der Erzeugung von Labyrinthen.  From ist Arten von Durchgängen innerhalb der Geometrie zugeordnet, die in den oben beschriebenen Kategorien definiert sind. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> „Ideal“ ist ein Labyrinth ohne Schleifen oder geschlossene Kreisläufe und ohne unerreichbare Bereiche.  Es wird auch ein einfach verbundenes Labyrinth genannt.  Von jedem Punkt gibt es genau einen Pfad zu einem anderen Punkt.  Labyrinth hat nur eine Lösung.  Aus programmtechnischer Sicht kann ein solches Labyrinth als Baum, als Verbindungsmenge von Zellen oder Eckpunkten beschrieben werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Geflochten</b> <b>:</b> Geflochten bedeutet, dass es im Labyrinth keine Sackgassen gibt.  Es wird auch das rein mehrfach verbundene Labyrinthlabyrinth genannt.  In einem solchen Labyrinth werden Passagen verwendet, die geschlossen sind und zueinander zurückkehren (daher der Name „Korbweide“). Dadurch verbringen sie mehr Zeit damit, im Kreis zu laufen, anstatt in Sackgassen zu geraten.  Ein hochwertiges gewebtes Labyrinth kann viel komplizierter sein als ein ideales Labyrinth derselben Größe. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single-Route (Unicursal)</b> <b>:</b> Single- <b>Route</b> bedeutet ein Labyrinth ohne Gabeln.  Das Einweg-Labyrinth enthält einen langen, gewundenen Durchgang, der die Richtung im gesamten Labyrinth ändert.  Es ist nicht sehr kompliziert, nur wenn Sie nicht versehentlich auf halber Strecke zurückkehren und nicht zum Anfang zurückkehren. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Spärlich: Ein</b> spärliches Labyrinth durchläuft nicht jede Zelle, dh einige von ihnen werden nicht erstellt.  Dies impliziert das Vorhandensein nicht erreichbarer Bereiche, dh in gewissem Sinne ist es das Gegenteil des Weidenlabyrinths.  Ein ähnliches Konzept kann beim Hinzufügen von Wänden angewendet werden, sodass Sie ein unebenes Labyrinth mit breiten Gängen und Räumen erhalten. </li><li>  <b>Teilweise Wicker:</b> Teilweise Wicker Maze ist ein gemischtes Labyrinth, das sowohl Schleifen als auch Sackgassen aufweist.  Das Wort „Korbweide“ kann zur quantitativen Beurteilung verwendet werden, dh ein „Labyrinth mit starkem Weben“ ist ein Labyrinth mit vielen entfernten Schleifen oder Wänden, und es gibt nur wenige im „Labyrinth mit schwachem Weben“. </li></ul><br>  <b>Textur: Die Texturklassifizierung</b> beschreibt den Stil von Durchläufen mit unterschiedlichem Routing und unterschiedlicher Geometrie.  Textur ist nicht nur ein Parameter, der ein- oder ausgeschaltet werden kann.  Hier einige Beispiele für Variablen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Bias</b> <b>:</b> In einem Labyrinth mit verschobenen Passagen tendieren gerade Passagen eher in eine Richtung als in andere.  In einem Labyrinth mit hoher horizontaler Verschiebung haben wir beispielsweise lange Passagen von links nach rechts und nur kurze Passagen von oben nach unten, die sie verbinden.  Ein solches Labyrinth ist normalerweise schwieriger „über die Fasern“ zu führen. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Überflug</b> <b>: Die</b> <b>Überflugmetrik</b> bestimmt, wie lange es dauert, bis erzwungene Abbiegungen auftreten.  In einem Labyrinth mit geringer Spannweite gibt es keine geraden Passagen, die länger als drei oder vier Zellen sind, und es sieht sehr zufällig aus.  In einem Labyrinth mit einer hohen Spannweite hat das Labyrinth einen großen Prozentsatz an langen Durchgängen, wodurch es wie ein Mikrochip aussieht. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elitismus: Der</b> Indikator „ <b>Elitismus</b> “ des Labyrinths bestimmt die Länge der Lösung im Verhältnis zur Größe des Labyrinths.  Elite-Labyrinthe haben normalerweise eine kurze, direkte Lösung, während in Nicht-Elite-Labyrinthen die Lösung einen großen Teil des Labyrinthbereichs durchläuft.  Ein hochwertiges Elite-Labyrinth kann viel komplizierter sein als ein Nicht-Elite-Labyrinth. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Symmetrie</b> <b>: Ein</b> symmetrisches Labyrinth hat symmetrische Passagen, beispielsweise in der Rotationssymmetrie relativ zur Mitte oder entlang der horizontalen oder vertikalen Achse.  Das Labyrinth kann teilweise oder vollständig symmetrisch sein und das Muster beliebig oft wiederholen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogenität: Ein</b> homogener Algorithmus erzeugt alle möglichen Labyrinthe mit gleicher Wahrscheinlichkeit.  Ein Labyrinth kann als homogen bezeichnet werden, wenn es wie ein typisches Labyrinth aussieht, das durch einen homogenen Algorithmus erzeugt wird.  Ein heterogener Algorithmus kann theoretisch auch alle möglichen Labyrinthe in jedem Raum erzeugen, jedoch nicht mit gleicher Wahrscheinlichkeit.  Die Heterogenität kann noch weiter gehen - es kann Labyrinthe geben, die der Algorithmus niemals erzeugen wird. </li><li>  <b>Flussfluss: Die</b> Eigenschaft „Fluss“ bedeutet, dass der Algorithmus beim Erstellen eines Labyrinths nach den benachbarten Zellen (oder Wänden) sucht und diese reinigt, dh sie fließt (daher der Begriff „Fluidität“) wie Wasser in die noch nicht erstellten Teile des Labyrinths.  In einem idealen Labyrinth mit einer geringeren Durchflussrate gibt es normalerweise viele kurze Sackgassen, und in einem „flüssigeren“ Labyrinth gibt es weniger Sackgassen, aber sie sind länger. </li></ul><br>  <b>Priorität:</b> Diese Klassifizierung zeigt, dass die Prozesse zur Erstellung von Labyrinthen in zwei Haupttypen unterteilt werden können: Hinzufügen von Wänden und Schnitzen von Passagen.  Wenn es darum geht, dies zu generieren, kommt es normalerweise nur auf den Unterschied in den Algorithmen und nicht auf merkliche Unterschiede in den Labyrinthen an, aber es ist immer noch nützlich, dies zu berücksichtigen.  Das gleiche Labyrinth wird oft auf beide Arten erzeugt: <br><br><ul><li>  <b>Hinzufügen von Wänden:</b> Algorithmen, für die Wände Priorität haben, beginnen mit einem leeren Bereich (oder einem Außenrand) und fügen dabei Wände hinzu.  In der realen Welt fügen echte Labyrinthe, die aus Hecken, Decken oder Holzwänden bestehen, definitiv Wände hinzu. </li><li>  <b>Gänge schneiden:</b> Algorithmen, deren Priorität Gänge sind, beginnen mit einem festen Block und schneiden dabei Passagen.  In der realen Welt sind solche Labyrinthe Minentunnel oder Labyrinthe in Rohren. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Vorlage:</b> Natürlich können Labyrinthe gleichzeitig Passagen schneiden und Wände hinzufügen.  Einige Computeralgorithmen machen das.  Eine Labyrinthvorlage ist ein Grafikbild, das kein Labyrinth ist, das sich in der geringsten Anzahl von Schritten in ein echtes Labyrinth verwandelt, aber dennoch die Textur der ursprünglichen Grafikvorlage beibehält.  Komplexe Labyrinthstile wie sich überschneidende Spiralen lassen sich leichter als Muster in einem Computer implementieren, als zu versuchen, das richtige Labyrinth zu erstellen und dabei seinen Stil beizubehalten. </li></ul><br>  <b>Sonstiges: Das</b> Obige ist keineswegs eine vollständige Liste aller möglichen Klassen oder Elemente innerhalb jeder Klasse.  Dies sind nur die Arten von Labyrinthen, die ich selbst geschaffen habe.  Beachten Sie, dass fast jede Art von Labyrinth, einschließlich Labyrinthen mit speziellen Regeln, als gerichteter Graph ausgedrückt werden kann, in dem es in jedem Zustand eine endliche Anzahl von Zuständen und eine endliche Anzahl von Auswahlmöglichkeiten gibt. Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Äquivalenz der Labyrinthe bezeichnet</b></a> .  Hier sind einige andere Klassifikationen und Arten von Labyrinthen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientierung</b> <b>:</b> An bestimmten Stellen können Sie sich nur in eine Richtung bewegen.  Aus programmtechnischer Sicht wird ein solches Labyrinth durch einen gerichteten Graphen beschrieben, im Gegensatz zu einem ungerichteten Graphen, der alle anderen Typen beschreibt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentierung</b> <b>: Das</b> Labyrinth kann verschiedene Teile haben, die verschiedenen Klassen entsprechen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labyrinthe von unendlicher Länge:</b> Wir können ein unendlich langes Labyrinth erstellen (eine endliche Anzahl von Spalten und eine beliebige Anzahl von Zeilen), aber gleichzeitig nur einen Teil des Labyrinths im Speicher speichern, von einem Ende zum anderen „scrollen“ und beim Erstellen der nächsten die vorherigen Zeilen zerstören.  Ein Beispiel ist eine modifizierte Version des Hunt and Kill-Algorithmus.  Man kann sich ein möglicherweise endloses Labyrinth in Form eines langen Films vorstellen, der aus einzelnen Bildern besteht.  Es werden jeweils nur zwei aufeinanderfolgende Frames gespeichert.  Lassen Sie uns den Hunt and Kill-Algorithmus ausführen, obwohl er eine Verzerrung erzeugt, die für den oberen Frame anfällig ist, sodass er zuerst endet.  Nach der Fertigstellung wird der Rahmen nicht mehr benötigt, Sie können ihn drucken oder etwas anderes damit machen.  Wie auch immer, verwerfen Sie es, machen Sie den teilweise erstellten unteren Rahmen zu einem neuen oberen Rahmen und löschen Sie den neuen unteren Rahmen.  Wiederholen Sie den Vorgang, bis wir aufhören möchten, und warten Sie dann, bis Hunt And Kill beide Frames abgeschlossen hat.  Die einzige Einschränkung besteht darin, dass das Labyrinth niemals einen Pfad hat, der sich über eine Länge von mehr als zwei Frames zum Eingang hin verzweigt.  Der einfachste Weg, ein endloses Labyrinth zu erstellen, ist der Eller-Algorithmus oder der Sidewinder-Algorithmus, da sie bereits zeilenweise Labyrinthe erstellen, sodass Sie sie einfach endlos Linien zum Labyrinth hinzufügen lassen können. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="Bild"><br><br></b>  <b>Virtuelle fraktale Labyrinthe:</b> Virtuell ist ein Labyrinth, in dem nicht das gesamte Labyrinth gleichzeitig gespeichert wird.  Beispielsweise kann nur ein Teil der 100 x 100 Durchgänge in der Nähe Ihres Standorts in einer Simulation gespeichert werden, in der Sie durch ein großes Labyrinth gehen.  Die Erweiterung verschachtelter fraktaler Labyrinthe kann verwendet werden, um riesige virtuelle Labyrinthe zu erstellen, beispielsweise eine Milliarde pro Milliarde Durchgänge.  Wenn wir eine echte Kopie des Labyrinths von einer Milliarde pro Milliarde Pässen (mit einem Abstand von sechs Fuß zwischen den Passagen) bauen würden, würde es die Erdoberfläche mehr als 6.000 Mal füllen!  Stellen Sie sich ein Labyrinth von 10 <sup>9</sup> bis 10 <sup>9</sup> Durchgängen oder ein geschlossenes Labyrinth mit nur 9 Ebenen vor.  Wenn wir mindestens ein 100x100-Teil um uns haben möchten, reicht es aus, auf der untersten Ebene ein Unterlabyrinth von 100x100 Durchgängen und sieben 10x10-Labyrinthen zu erstellen, in das es eingebettet ist, um genau zu wissen, wo sich die Wände innerhalb des 100x100-Teils befinden.  (Eigentlich ist es besser, vier benachbarte Teile mit einer Größe von 100 x 100 zu haben, die ein Quadrat bilden, falls Sie sich in der Nähe der Kante oder Ecke des Teils befinden. Hier gilt jedoch das gleiche Konzept.) Um sicherzustellen, dass das Labyrinth beim Bewegen konstant und unverändert bleibt, haben wir eine Formel: Definieren einer zufälligen Startnummer für jede Koordinate auf jeder Verschachtelungsebene.  Virtuelle fraktale Labyrinthe ähneln dem Mandelbrot-Fraktal, in dessen Bildern es virtuell existiert, und wir müssen eine bestimmte Koordinate mit einer ziemlich hohen Vergrößerung besuchen.  so dass es erscheint. </li></ul><br><h2>  Labyrinth-Algorithmen </h2><br>  Hier ist eine Liste verallgemeinerter Algorithmen zum Erstellen der verschiedenen oben beschriebenen Labyrinthklassen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> Um ein ideales Standardlabyrinth zu schaffen, muss es normalerweise „wachsen“, um sicherzustellen, dass keine Schleifen und isolierten Bereiche vorhanden sind.  Wir beginnen an der Außenwand und fügen zufällig ein Fragment der Wand hinzu, das sie berührt.  Wir fügen dem Labyrinth weiterhin zufällig Wandsegmente hinzu, stellen jedoch sicher, dass jedes neue Segment ein Ende der vorhandenen Wand berührt und sich das andere Ende im noch nicht erstellten Teil des Labyrinths befindet.  Wenn Sie ein Wandsegment hinzufügen, dessen beide Enden vom Rest des Labyrinths getrennt sind, wird eine nicht verbundene Wand mit einer Schleife erstellt. Wenn Sie ein Segment hinzufügen, dessen beide Enden das Labyrinth berühren, entsteht ein nicht erreichbarer Bereich.  Dies ist eine Methode zum Hinzufügen von Wänden.  Es ist fast analog zum Ausschneiden von Passagen, bei denen Teile der Passagen so geschnitten werden, dass nur ein Ende den vorhandenen Pass berührt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -«», (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        —   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  «»        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     «»    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  —  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     —       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Möglichkeiten, perfekte Labyrinthe zu erstellen, und jeder von ihnen hat seine eigenen Eigenschaften. </font><font style="vertical-align: inherit;">Unten finden Sie eine Liste spezifischer Algorithmen. </font><font style="vertical-align: inherit;">Alle beschreiben die Schaffung eines Labyrinths durch Ausschneiden von Passagen. Sofern nicht anders angegeben, kann jedes auch durch Hinzufügen von Wänden implementiert werden:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekursiver Backtracker </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     «»   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Prims Algorithmus (true)</b> <b>:</b> Dieser Algorithmus erstellt einen minimalen Spanning Tree, indem er eindeutig zufällige Kantengewichte verarbeitet.  Der erforderliche Speicherplatz ist proportional zur Größe des Labyrinths.  Wir beginnen an einem beliebigen Scheitelpunkt (das fertige Labyrinth ist das gleiche, egal von oben, wo wir beginnen).  Wir wählen die Kante des Durchgangs mit dem kleinsten Gewicht aus, das das Labyrinth mit einem Punkt verbindet, der sich noch nicht darin befindet, und befestigen es dann am Labyrinth.  Das Labyrinth ist fertig, wenn die fraglichen Kanten nicht mehr übrig sind.  Um die nächste Kante effizient auszuwählen, benötigen Sie eine Prioritätswarteschlange (normalerweise mithilfe eines Heaps implementiert), in der alle Kanten des Rahmens gespeichert sind.  Dieser Algorithmus ist jedoch ziemlich langsam, da die Auswahl von Elementen aus dem Heap log (n) Zeit benötigt.  Daher ist es besser, den Kraskal-Algorithmus zu bevorzugen, der auch einen minimalen Spannbaum erzeugt, da er schneller ist und Labyrinthe mit identischer Struktur erzeugt.  Tatsächlich können die Algorithmen Prima und Kraskal mit demselben zufälligen Startwert dieselben Labyrinthe erzeugen. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Prims Algorithmus (vereinfacht)</b> <b>:</b> Dieser Prims Algorithmus erstellt einen minimalen Spannbaum.  Es wird so vereinfacht, dass alle Kantengewichte gleich sind.  Es erfordert eine Speicherkapazität proportional zur Größe des Labyrinths.  Wir gehen von einem zufälligen Peak aus.  Wir wählen zufällig den Rand des Durchgangs aus, der das Labyrinth mit einem Punkt verbindet, der sich noch nicht darin befindet, und befestigen ihn dann am Labyrinth.  Das Labyrinth ist fertig, wenn die fraglichen Kanten nicht mehr übrig sind.  Da die Kanten schwerelos und nicht geordnet sind, können sie als einfache Liste gespeichert werden, dh die Auswahl der Elemente aus der Liste erfolgt sehr schnell und nimmt konstante Zeit in Anspruch.  Daher ist es viel schneller als der echte Prim-Algorithmus mit zufälligen Kantengewichten.  Die erzeugte Labyrinthtextur hat eine geringere Flussrate und eine einfachere Lösung als die echte Prim-Methode, da sie sich wie verschütteter Sirup gleichmäßig vom Startpunkt aus verteilt und keine Rippenfragmente mit höherem Gewicht umgeht, die später berücksichtigt werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Prims Algorithmus (modifiziert)</b> <b>:</b> Dieser Prims Algorithmus erstellt einen minimalen Spannbaum, der so modifiziert ist, dass alle Gewichte der Kanten gleich sind.  Es ist jedoch so implementiert, dass anstelle von Kanten Zellen betrachtet werden.  Die Speichermenge ist proportional zur Größe des Labyrinths.  Während des Erstellungsprozesses kann jede Zelle einen von drei Typen haben: (1) „intern“: Die Zelle ist Teil des Labyrinths und bereits darin ausgeschnitten. (2) „Grenze“: Die Zelle ist nicht Teil des Labyrinths und wurde noch nicht ausgeschnitten, befindet sich jedoch neben der Zelle, die bereits „intern“ ist, und (3) „extern“: Die Zelle ist noch nicht Teil des Labyrinths, und keiner ihrer Nachbarn ist auch die „interne“ Zelle.  Wir beginnen mit der Auswahl einer Zelle, machen sie "intern" und setzen für alle Nachbarn den Typ auf "Grenze".  Wir wählen zufällig die "Grenz" -Zelle aus und schneiden einen Durchgang von einer der benachbarten "internen" Zellen hinein.  Wir ändern den Status dieser "Grenzzelle" in "intern" und ändern den Typ aller Nachbarn von "extern" in "Grenze".  Das Labyrinth ist abgeschlossen, wenn keine "Grenz" -Zellen mehr vorhanden sind (dh keine "externen" Zellen mehr vorhanden sind, was bedeutet, dass jeder "intern" geworden ist).  Dieser Algorithmus erzeugt Labyrinthe mit einem sehr niedrigen Ertragsindex, hat viele kurze Deadlocks und eine ziemlich einfache Lösung.  Das resultierende Labyrinth ist dem Ergebnis des vereinfachten Prima-Algorithmus sehr ähnlich, mit einem kleinen Unterschied: Die Hohlräume im Spanning Tree werden nur gefüllt, wenn eine Grenzzelle zufällig ausgewählt wird, im Gegensatz zu der dreifachen Wahrscheinlichkeit, diese Zelle durch eine der dazu führenden Grenzzellen zu füllen.  Darüber hinaus ist der Algorithmus sehr schnell und schneller als der vereinfachte Prim-Algorithmus, da die Kantenliste nicht kompiliert und verarbeitet werden muss. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Aldous-Broder-</b> Algorithmus: Interessant an diesem Algorithmus ist, dass er homogen ist, dh mit gleicher Wahrscheinlichkeit alle möglichen Labyrinthe einer bestimmten Größe erzeugt.  Darüber hinaus ist kein zusätzlicher Speicher oder Stapel erforderlich.  Wir wählen einen Punkt aus und bewegen uns zufällig in eine benachbarte Zelle.  Wenn wir in eine ungeschnittene Zelle geraten sind, schneiden Sie den Durchgang aus der vorherigen Zelle in diese aus.  Wir bewegen uns weiter zu benachbarten Zellen, bis wir die Passagen zu allen Zellen herausgeschnitten haben.  Dieser Algorithmus erzeugt Labyrinthe mit einer geringen Durchflussrate, die nur geringfügig höher ist als der Kraskal-Algorithmus.  (Dies bedeutet, dass es für einen bestimmten Austausch mehr Labyrinthe mit einem niedrigen Ertragsindex als mit einem hohen gibt, da das Labyrinth mit einer durchschnittlichen Wahrscheinlichkeit ebenso niedrig ist.) Das Schlechte an diesem Algorithmus ist, dass er sehr langsam ist, weil er keine intellektuelle Suche nach letzterem durchführt Zellen, das heißt in der Tat, haben keine Garantien für die Fertigstellung.  Aufgrund seiner Einfachheit kann es jedoch schnell viele Zellen durchlaufen, sodass es schneller abgeschlossen wird, als Sie vielleicht denken.  Im Durchschnitt dauert die Fertigstellung siebenmal länger als bei Standardalgorithmen, obwohl es in schlechten Fällen viel länger dauern kann, wenn der Zufallszahlengenerator die letzten Zellen ständig vermeidet.  Es kann als Hinzufügen von Wänden implementiert werden, wenn die Grenzwand als einzelner Scheitelpunkt betrachtet wird, d. H. Wenn die Bewegung uns beispielsweise zur Grenzwand bewegt, teleportieren wir uns zu einem zufälligen Punkt entlang der Grenze und bewegen uns erst dann weiter.  Beim Hinzufügen von Wänden funktioniert es fast doppelt so schnell, da die Teleportation entlang der Grenzmauer einen schnelleren Zugang zu den entfernten Teilen des Labyrinths ermöglicht. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Wilsons Algorithmus</b> <b>:</b> Dies ist eine verbesserte Version des Aldous-Broder-Algorithmus. Er erzeugt Labyrinthe mit genau der gleichen Textur (die Algorithmen sind homogen, dh alle möglichen Labyrinthe werden mit gleicher Wahrscheinlichkeit erzeugt), aber der Wilson-Algorithmus ist viel schneller.  Es braucht Speicher bis zur Größe des Labyrinths.  Wir beginnen mit einer zufällig ausgewählten anfänglichen Labyrinthzelle.  Wir wählen eine zufällige Zelle aus, die noch nicht Teil des Labyrinths ist, und führen einen zufälligen Spaziergang durch, bis wir eine Zelle finden, die bereits zum Labyrinth gehört.  Sobald wir auf den bereits erstellten Teil des Labyrinths stoßen, kehren wir zur ausgewählten zufälligen Zelle zurück und schneiden den gesamten Pfad aus, indem wir diese Zellen zum Labyrinth hinzufügen.  Genauer gesagt, wenn wir auf dem Weg zurückkehren, schneiden wir jede Zelle in der Richtung ein, in der der zufällige Spaziergang beim letzten Verlassen der Zelle stattgefunden hat.  Dies vermeidet das Auftreten von Schleifen entlang des Rückweges, so dass ein langer Durchgang das Labyrinth verbindet.  Das Labyrinth ist abgeschlossen, wenn alle Zellen daran befestigt sind.  Der Algorithmus hat die gleichen Geschwindigkeitsprobleme wie Aldous-Broder, da es lange dauern kann, den ersten zufälligen Pfad zur ursprünglichen Zelle zu finden, aber nach dem Platzieren mehrerer Pfade wird der Rest des Labyrinths ziemlich schnell herausgeschnitten.  Im Durchschnitt läuft es fünfmal schneller als Aldous-Broder und weniger als zweimal langsamer als die besten Algorithmen.  Es ist zu bedenken, dass das Hinzufügen von Wänden doppelt so schnell funktioniert, da die gesamte Grenzmauer anfangs Teil des Labyrinths ist, sodass sich die ersten Wände viel schneller verbinden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  <b>Hunt and Kill-</b> Algorithmus <b>:</b> Dieser Algorithmus ist praktisch, da er keinen zusätzlichen Speicher oder Stapel benötigt und daher zum Erstellen großer Labyrinthe oder Labyrinthe auf schwachen Computern geeignet ist, da nicht genügend Speicherplatz zur Verfügung steht.  Da es keine Regeln gibt, die ständig befolgt werden müssen, ist es auch am einfachsten, Labyrinthe mit unterschiedlichen Texturen damit zu ändern und zu erstellen.  Es ähnelt fast einem rekursiven Backtracker, nur dass keine Zelle in der Nähe der aktuellen Position erstellt wurde.  Wir wechseln in den "Jagd" -Modus und scannen systematisch das Labyrinth, bis wir eine nicht erstellte Zelle neben der bereits geschnittenen Zelle finden.  In dieser Phase beginnen wir wieder mit dem Schneiden an diesem neuen Standort.  Das Labyrinth ist abgeschlossen, wenn im "Jagd" -Modus alle Zellen gescannt werden.  Dieser Algorithmus neigt dazu, Labyrinthe mit einer hohen Flussrate zu erzeugen, die jedoch nicht so hoch sind wie der rekursive Backtracker.  Sie können es zwingen, Labyrinthe mit einer niedrigeren Durchflussrate zu erzeugen, die häufiger in den "Jagd" -Modus wechseln.  Es läuft langsamer aufgrund der Zeit, die für die Jagd auf die letzten Zellen aufgewendet wurde, aber nicht viel langsamer als der Kraskal-Algorithmus.  Es kann nach dem Prinzip des Hinzufügens von Wänden implementiert werden, wenn Sie gelegentlich zufällig teleportieren, um die Probleme zu vermeiden, die einem rekursiven Backtracker inhärent sind. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Wachsender Algorithmus</b> <b><br></b>  <b>Baum (Wachsender Baum-Algorithmus)</b> <b>:</b> Dies ist ein verallgemeinerter Algorithmus, der Labyrinthe mit unterschiedlichen Texturen erstellen kann.  Der erforderliche Speicher kann die Größe des Labyrinths erreichen.  Jedes Mal, wenn eine Zelle geschnitten wird, fügen wir sie der Liste hinzu.  Wählen Sie eine Zelle aus der Liste aus und schneiden Sie den Durchgang zu der nicht erstellten Zelle daneben aus.  Wenn sich in der Nähe der aktuellen Zelle keine nicht erstellten Zellen befinden, löschen Sie die aktuelle Zelle aus der Liste.  Das Labyrinth ist abgeschlossen, wenn die Liste nichts anderes enthält.  Das Interessante am Algorithmus ist, dass Sie abhängig davon, wie Sie eine Zelle aus der Liste auswählen, viele verschiedene Texturen erstellen können.  Wenn Sie beispielsweise immer die zuletzt hinzugefügte Zelle auswählen, wird dieser Algorithmus zu einem rekursiven Backtracker.  Wenn Sie Zellen immer zufällig auswählen, verhält es sich ähnlich, jedoch nicht identisch mit dem Prim-Algorithmus.  Wenn Sie immer die ältesten Zellen auswählen, die der Liste hinzugefügt wurden, erstellen wir ein Labyrinth mit dem niedrigstmöglichen Ertragsindex, der sogar unter dem des Prim-Algorithmus liegt.  Wenn Sie normalerweise die allerletzte Zelle auswählen, aber gelegentlich eine zufällige Zelle auswählen, hat das Labyrinth eine hohe Flussrate, aber eine kurze und direkte Lösung.  Wenn eine der neuesten Zellen zufällig ausgewählt wird, hat das Labyrinth eine geringe Durchflussrate, aber eine lange und gewundene Lösung. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Wachsender Waldalgorithmus</b> <b>:</b> Dies ist ein allgemeinerer Algorithmus, der Typen basierend auf Bäumen und Mengen kombiniert.  Es ist eine Erweiterung des Baumwachstumsalgorithmus, der im Wesentlichen mehrere Instanzen umfasst, die gleichzeitig erweitert werden.  Wir beginnen mit allen Zellen, die zufällig in einer Liste von "neu" sortiert sind.  Darüber hinaus hat jede Zelle wie zu Beginn des Kruskal-Algorithmus ihren eigenen Satz.  Wählen Sie zunächst eine oder mehrere Zellen aus, indem Sie sie aus der Liste "Neu" in die Liste "Aktiv" verschieben.  Wählen Sie eine Zelle aus der Liste "aktiv" aus und schneiden Sie die Passage zur nächsten nicht erstellten Zelle aus der Liste "neu" aus. Fügen Sie der Liste "aktiv" eine neue Zelle hinzu und kombinieren Sie die Sätze von zwei Zellen.  Wenn versucht wird, in den vorhandenen Teil des Labyrinths zu schneiden, aktivieren Sie ihn, wenn sich die Zellen in verschiedenen Sätzen befinden, und kombinieren Sie die Zellen, wie im Kraskal-Algorithmus.  Wenn sich in der Nähe der aktuellen Zelle keine "neuen" Zellen befinden, verschieben Sie die aktuelle Zelle in die Liste der "fertigen".  Das Labyrinth ist abgeschlossen, wenn die Liste der "aktiven" leer wird.  Am Ende kombinieren wir alle verbleibenden Mengen wie im Kruskal-Algorithmus.  In regelmäßigen Abständen können Sie neue Bäume erstellen, indem Sie wie zu Beginn eine oder mehrere Zellen aus der Liste "Neu" in die Liste "Aktiv" verschieben.  Durch Steuern der Anzahl der ursprünglichen Bäume und der Anteile der neu erstellten Bäume können Sie viele eindeutige Texturen generieren, die mit den bereits flexiblen Parametern des Baumwachstumsalgorithmus kombiniert werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Ellers Algorithmus</b> <b>:</b> Dies ist ein spezieller Algorithmus, da er nicht nur schneller als alle anderen ist, sondern auch keine offensichtlichen Vorurteile oder Mängel aufweist.  Darüber hinaus wird der Speicher beim Erstellen am effizientesten genutzt.  Es ist nicht einmal erforderlich, dass sich das gesamte Labyrinth im Speicher befindet, sondern es wird ein Volumen verwendet, das proportional zur Größe der Zeile ist.  Es erstellt zeilenweise ein Labyrinth. Nachdem die Generierung der Zeichenfolge abgeschlossen ist, berücksichtigt der Algorithmus dies nicht mehr.  Jede Zelle in einer Reihe ist in einer Menge enthalten.  Zwei Zellen gehören zu derselben Gruppe, wenn sich zwischen ihnen entlang des bereits erstellten Labyrinths ein Pfad befindet.  Mit diesen Informationen können Sie Passagen in der aktuellen Zeile ausschneiden, ohne Schleifen oder isolierte Bereiche zu erstellen.  Tatsächlich ist es dem Kraskal-Algorithmus ziemlich ähnlich, nur dass es hier zeilenweise gebildet wird, während Kraskal durch das gesamte Labyrinth schaut.  Das Erstellen einer Zeile besteht aus zwei Teilen: Verbinden Sie benachbarte Zellen innerhalb der Zeile zufällig, d. H.  wir schneiden horizontale Passagen aus und verbinden dann zufällig die Zellen zwischen der aktuellen und der nächsten Reihe, d.h.  vertikale Passagen ausschneiden.  Beim Schneiden horizontaler Passagen verbinden wir keine Zellen, die sich bereits im selben Satz befinden (da sonst eine Schleife erstellt wird), und beim Schneiden vertikaler Passagen müssen wir eine Zelle verbinden, wenn sie eine Einheitsgröße hat (wenn Sie sie verlassen, wird ein isolierter Bereich erstellt).  Wenn wir horizontale Passagen schneiden, verbinden wir Zellen, wenn sie sich im selben Satz befinden (weil jetzt ein Pfad zwischen ihnen besteht), und wenn wir vertikale Passagen schneiden, wenn wir keine Verbindung mit der Zelle herstellen, legen wir sie in einen separaten Satz (weil sie jetzt vom Rest des Labyrinths getrennt sind )  Die Erstellung beginnt mit der Tatsache, dass vor dem Verbinden der Zellen in der ersten Zeile jede Zelle ihren eigenen Satz hat.  Die Erstellung ist abgeschlossen, nachdem die Zellen in der letzten Zeile verbunden wurden.  Es gibt eine spezielle Regel für die Fertigstellung: Zum Zeitpunkt der Fertigstellung sollte sich jede Zelle im selben Satz befinden, um isolierte Bereiche zu vermeiden.  (Die letzte Zeile wird erstellt, indem jedes der Paare benachbarter Zellen kombiniert wird, die sich noch nicht in derselben Gruppe befinden.) Es ist am besten, die Gruppe mithilfe einer zyklisch doppelt verknüpften Liste von Zellen zu implementieren (die nur ein Array sein kann, das Zellen mit Zellenpaaren auf beiden Seiten derselben Gruppe verbindet) Führen Sie das Einfügen, Löschen und Überprüfen des Vorhandenseins benachbarter Zellen in einem Satz für eine konstante Zeit durch.  Das Problem bei diesem Algorithmus ist das Ungleichgewicht bei der Verarbeitung der verschiedenen Kanten des Labyrinths.  Um Flecken in Texturen zu vermeiden, müssen Sie Verbindungszellen in den richtigen Proportionen verbinden und überspringen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Rekursive Division:</b> Dieser Algorithmus ähnelt dem rekursiven Backtracking, da beide Stapel verwenden. Nur funktioniert er nicht mit Gängen, sondern mit Wänden.  Wir beginnen mit der Erstellung einer zufälligen horizontalen oder vertikalen Wand, die einen zugänglichen Bereich in einer zufälligen Zeile oder Spalte schneidet, und platzieren zufällig leere Räume entlang dieser.  Dann wiederholen wir rekursiv den Vorgang für die beiden durch die Trennwand erzeugten Teilregionen.  Um optimale Ergebnisse zu erzielen, müssen Sie eine Abweichung bei der Auswahl von horizontal oder vertikal hinzufügen, die auf den Proportionen des Bereichs basiert. Beispielsweise sollte ein Bereich, dessen Breite doppelt so hoch ist wie die Höhe, häufiger durch vertikale Wände geteilt werden.  Dies ist der schnellste Algorithmus ohne Richtungsabweichungen und kann oft sogar mit Labyrinthen konkurrieren, die auf Binärbäumen basieren, da mehrere Zellen gleichzeitig erstellt werden, obwohl er einen offensichtlichen Nachteil in Form langer Wände aufweist, die das Innere des Labyrinths schneiden.  Dieser Algorithmus ist eine Art eingebetteter fraktaler Labyrinthe, aber anstatt ständig Labyrinthe von Zellen fester Größe mit Labyrinthen gleicher Größe in jeder Zelle zu erstellen, teilt er einen bestimmten Bereich zufällig in ein Labyrinth zufälliger Größe: 1x2 oder 2x1.  Rekursive Division kann nicht zum Ausschneiden von Passagen verwendet werden, da dies zur Schaffung einer offensichtlichen Lösung führt, die entweder entlang der Außenkante folgt oder auf andere Weise die Innenseite direkt schneidet. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labyrinthe basierend auf Binärbäumen</b> <b>:</b> Tatsächlich sind dies die einfachsten und schnellstmöglichen Algorithmen. Die erstellten Labyrinthe weisen jedoch eine Textur mit einer sehr hohen Vorspannung auf.  Für jede Zelle schneiden wir einen Durchgang entweder nach oben oder nach links, jedoch niemals in beide Richtungen.  In der Version mit zusätzlichen Wänden wird für jeden nach unten oder rechts führenden Scheitelpunkt ein Wandsegment hinzugefügt, jedoch nicht in beide Richtungen.  Jede Zelle ist unabhängig von allen anderen Zellen, da wir beim Erstellen nicht den Status einiger anderer Zellen überprüfen müssen.  Daher ist dies ein realer Algorithmus zum Erzeugen von Labyrinthen ohne Speicher, der nicht durch die Größe der erstellten Labyrinthe begrenzt ist.  Tatsächlich ist dies ein Binärbaum, wenn wir die obere linke Ecke als Wurzel betrachten und jeder Knoten oder jede Zelle einen eindeutigen übergeordneten Knoten hat, der eine Zelle darüber oder links davon ist.  Auf Binärbäumen basierende Labyrinthe unterscheiden sich von idealen Standardlabyrinthen, da mehr als die Hälfte der Zelltypen in ihnen nicht existieren können.  Zum Beispiel wird es niemals Kreuzungen in ihnen geben, und alle Sackgassen haben Passagen, die nach oben oder links und niemals nach unten oder rechts führen.  Labyrinthe haben in der Regel Passagen, die diagonal von links oben nach rechts unten führen, und es ist viel einfacher, sich von rechts unten nach links oben zu bewegen.  Sie können sich immer nach oben oder links bewegen, aber niemals gleichzeitig in beide Richtungen, sodass Sie sich immer deterministisch diagonal nach oben und links bewegen können, ohne auf Barrieren zu stoßen.  Sie haben die Möglichkeit zu wählen und in Sackgassen zu geraten, indem Sie sich nach unten und rechts bewegen. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   «    ».   ,       sidewinder —      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% Sackgassen</font></font></b> </td><td>  <b>Typ</b> </td><td>  <b>Priorität</b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Voreingenommenheit?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Homogen?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Erinnerung</font></font></b> </td><td>  <b>Zeit</b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% Lösung</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einzelne Route </font></font></td><td>  0 </td><td>  Baum </td><td>  Die Wände </td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  379 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekursiver Backtracker </font></font></td><td>  10 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehwege </font></font></td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  27 </td><td>  19.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jagen und töten </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11 (21) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehwege </font></font></td><td>  Ja </td><td>  Niemals </td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100 (143) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9,5 (3,9) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekursive Division </font></font></td><td>  23 </td><td>  Baum </td><td>  Die Wände </td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  10 </td><td>  7.2 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Binärer Baum </font></font></td><td>  25 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  10 </td><td>  2.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sidewinder </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  12 </td><td>  2.6 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eller-Algorithmus </font></font></td><td>  28 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  20 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,2 (3,2) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wilson-Algorithmus </font></font></td><td>  29 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48 (25) </font></font></td><td>  4.5 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aldous-Broder-Algorithmus </font></font></td><td>  29 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Ja </td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 279 (208) </font></font></td><td>  4.5 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kraskal-Algorithmus </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  33 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (wahr) </font></font></td><td>  30 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  160 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (vereinfacht) </font></font></td><td>  32 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  59 </td><td>  2.3 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (modifiziert) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 36 (31) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  30 </td><td>  2.3 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baum wächst </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  48 </td><td>  11.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wald wächst </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  76 </td><td>  11.0 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Tabelle fasst die Eigenschaften der oben beschriebenen Algorithmen zur Erzeugung idealer Labyrinthe zusammen. </font><font style="vertical-align: inherit;">Zum Vergleich wurde ein Einweg-Labyrinthalgorithmus hinzugefügt (theoretisch sind Einweg-Labyrinthe ideal). </font><font style="vertical-align: inherit;">Spaltenerklärung:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . «» ,    . «» ,            ,     . «» ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     «»  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Möglichkeiten, Labyrinthe zu lösen, und jede hat ihre eigenen Eigenschaften. </font><font style="vertical-align: inherit;">Hier ist eine Liste spezifischer Algorithmen:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgen entlang der Wände (Wall Follower) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        («»),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    «»    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   —  -1,    —  1.            ,      , ..     360   ,        «».  ,         «»,      ,        ,      ,      ,         .  ,             ,           .      ,    —    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      «»      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   «», ,     ,  «», ,       .  ,         ,    «»;    «»       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Trémaux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  —   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   —   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   «» ,          (      ),   «»  , ,     .      «»,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   «» ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    «» ,          (  ).   « »       (   ),       ,   .      «»,     ,       ,   ,     . ( ,    «»,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td>  <b>Priorität</b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Nein </td><td>  Ja </td><td>  Nein </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Ja </td><td>  Ja </td><td>  Ja </td></tr><tr><td>   </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Ja </td><td>  Ja </td><td>  Ja </td></tr><tr><td>   </td><td>  1 </td><td>  Ja </td><td> + </td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td> Recursive Backtracker </td><td>  1 </td><td>  Ja </td><td>  Du bist </td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tremo-Algorithmus </font></font></td><td>  1 </td><td>  Ja </td><td>  Du bist </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Innen / über </font></font></td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse Füller </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Nein </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über </font></font></td><td>  Nein </td><td>  Ja </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse Füller </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Nein </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über </font></font></td><td>  Nein </td><td>  Ja </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse Sealer </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Ja </td><td>  Labyrinth </td><td>  Nein </td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgassenfüller </font></font></td><td>  Alle </td><td>  Ja </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kollisionslöser </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles am kürzesten </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach kürzesten Wegen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles am kürzesten </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach dem kürzesten Weg </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 kürzeste </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Tabelle sind die Eigenschaften der oben beschriebenen Labyrinthlösungsalgorithmen kurz aufgeführt. </font><font style="vertical-align: inherit;">Nach diesen Kriterien ist es möglich, Algorithmen zur Lösung von Labyrinthen zu klassifizieren und zu bewerten. </font><font style="vertical-align: inherit;">Spaltenerklärungen:</font></font><br><br><ul><li> <b>:</b>       ,   .        .  ,  ()       . Dead end filler  cul-de-sac filler (  blind alley sealer     )   ,      ,        ,      «+». </li><li> <b>:</b>        .  Random mouse  «»,      ,   wall follower     «»,       ,     .  dead end filler  cul-de-sac filler  «»,           . </li><li> <b>:</b>      :   «» (  )    .    ,       (   «»)    («+»)          .    ,          . </li><li> <b> :</b>        ,     ,     .   ,   «»,    ,    (  ),  ,   ,    ,     .            . </li><li> <b>  :</b>      .   ,       ,     ,     ,         . Wall follower,             . Recursive backtracker  shortest path(s) finder     . </li><li> <b>  :</b>         .                    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnell:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wird der Entscheidungsprozess als schnell angesehen? </font><font style="vertical-align: inherit;">Die effizientesten Algorithmen reichen aus, um jede Zelle des Labyrinths nur einmal zu betrachten, oder sie können Teile davon vollständig überspringen. </font><font style="vertical-align: inherit;">Die Laufzeit sollte proportional zur Größe des Labyrinths oder O (n ^ 2) sein, wobei n die Anzahl der Zellen entlang einer Seite ist. </font><font style="vertical-align: inherit;">Zufällige Mäuse sind langsam, da ihre Fertigstellung nicht garantiert ist und der Sackgassenfüller möglicherweise das Labyrinth von jeder Gabel löst.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere Operationen mit Labyrinthen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neben dem Erstellen und Lösen von Labyrinthen können Sie mit ihnen auch andere Vorgänge ausführen: </font></font><br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br> :</b>  «  »,      ,         Fill  FloodFill.  FloodFill   ,      ,     .  ,       ,  FloodFill  ,     .  ,      ,  FloodFill  ,      ,        .          «»    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br>    (Isolation remover):</b>    ,        ,        .   ,       .    ,     .   (   ,      )    ,    .         ,        ,      .         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br>  :</b>    ,            ,               .        ,      ,  .    ,    .   (   ,       )        .         ,    ,        ,     .                ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br> <b>  </b> <b>:</b>       ,       .   ,       ,    ,        ,    .  ,      ,   .       ,        .           ,    blind alley sealer (    ,            ).   ,    ,   . </li></ul><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Daedalus</b></a> <b>:</b>           Daedalus,       Windows.    Daedalus    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445378/">https://habr.com/ru/post/de445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445362/index.html">Das Buch "Distributed Systems. Entwurfsmuster</a></li>
<li><a href="../de445366/index.html">So beschleunigen Sie die Verschlüsselung gemäß GOST 28147-89 auf dem Baikal-T1-Prozessor aufgrund des SIMD-Blocks</a></li>
<li><a href="../de445368/index.html">Laden Sie ein Spiel mit ein paar Hunderttausenden von virtuellen Benutzern</a></li>
<li><a href="../de445370/index.html">TSDB-Analyse in Prometheus 2</a></li>
<li><a href="../de445372/index.html">Bildverarbeitung vs. menschliche Intuition: Algorithmen zur Unterbrechung des Betriebs von Objekterkennungsprogrammen</a></li>
<li><a href="../de445380/index.html">Modernes PHP ist schön und produktiv</a></li>
<li><a href="../de445384/index.html">Chang'e-4 Mission - wissenschaftliche Ausrüstung auf dem Landemodul und dem Repeater-Satelliten</a></li>
<li><a href="../de445390/index.html">IDE einer normalen Person oder warum wir uns für Monaco entschieden haben</a></li>
<li><a href="../de445392/index.html">Dynamisches Remarketing von MyTarget: nicht persönliche Produktempfehlungen</a></li>
<li><a href="../de445394/index.html">Änderungen des sicheren 3D-Protokolls: Erfüllen Sie 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>