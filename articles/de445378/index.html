<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üå•Ô∏è üèôÔ∏è Labyrinthe: Klassifizierung, Erzeugung, Suche nach L√∂sungen üí™üèΩ üí± üç§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser klassische Beitrag beschreibt die beliebtesten Methoden zum Erstellen und Durchlaufen von Labyrinthen. Der Artikel ist in vier Teile gegliedert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labyrinthe: Klassifizierung, Erzeugung, Suche nach L√∂sungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Dieser klassische Beitrag beschreibt die beliebtesten Methoden zum Erstellen und Durchlaufen von Labyrinthen.</i>  <i>Der Artikel ist in vier Teile gegliedert: Klassifizierung, Generierungsalgorithmen, Algorithmen zum L√∂sen von Labyrinthen und andere Operationen mit Labyrinthen.</i> <br><br><h2>  Labyrinthklassifikation </h2><br>  Die Labyrinthe als Ganzes (und damit die Algorithmen zu ihrer Erstellung) k√∂nnen in sieben verschiedene Klassifikationen unterteilt werden: Dimension, Hyperdimension, Topologie, Tessellation, Routing, Textur und Priorit√§t.  Das Labyrinth kann ein Element aus jeder Klasse in einer beliebigen Kombination verwenden. <a name="habracut"></a><br>  <b>Dimension:</b> Die Dimensionsklasse bestimmt im Wesentlichen, wie viele Dimensionen im Raum das Labyrinth ausf√ºllt.  Folgende Typen stehen zur Verf√ºgung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Zweidimensional</b> <b>: Die</b> meisten Labyrinthe, sowohl Papier als auch Real, haben diese Dimension. Das hei√üt, wir k√∂nnen den Plan des Labyrinths immer auf einem Blatt Papier anzeigen und uns entlang bewegen, ohne andere Korridore des Labyrinths zu √ºberqueren. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Dreidimensional</b></a> <b>: Das</b> dreidimensionale Labyrinth hat mehrere Ebenen.  darin (zumindest in der orthogonalen Version) k√∂nnen Passagen zus√§tzlich zu den vier Himmelsrichtungen nach unten und nach oben gehen.  Ein 3D-Labyrinth wird h√§ufig als eine Reihe von 2D-Ebenen mit Treppen nach oben und unten dargestellt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>H√∂here Dimensionen</b> <b>:</b> Sie k√∂nnen vierdimensionale und noch mehrdimensionale Labyrinthe erstellen.  Manchmal werden sie als 3D-Labyrinthe mit ‚ÄûPortalen‚Äú dargestellt, die durch die vierte Dimension f√ºhren, z. B. Portale in die ‚ÄûVergangenheit‚Äú und ‚ÄûZukunft‚Äú. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Verflechtung</b> <b>:</b> Labyrinthe mit Verflechtung - dies sind im Wesentlichen zweidimensionale (oder eher 2,5-dimensionale) Labyrinthe, in denen sich jedoch Passagen √ºberlappen k√∂nnen.  Bei der Anzeige ist es normalerweise ziemlich offensichtlich, wo sich die Sackgassen befinden und wie sich ein Durchgang √ºber dem anderen befindet.  Labyrinthe aus der realen Welt, in denen Br√ºcken einen Teil des Labyrinths mit einem anderen verbinden, sind teilweise miteinander verflochten. </li></ul><br>  <b>Hyperdimension: Die</b> Klassifizierung nach <b>Hyperdimension</b> entspricht der Dimension eines Objekts, das sich durch ein Labyrinth bewegt, und nicht dem Labyrinth selbst.  Folgende Typen stehen zur Verf√ºgung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Nicht-Hyperlabyrinthe</b> <b>:</b> Fast alle Labyrinthe, auch solche, die in hoher Dimensionalit√§t oder mit speziellen Regeln erstellt wurden, sind normalerweise Nicht-Hyperlabyrinthe.  In ihnen arbeiten wir mit einem Punkt oder einem kleinen Objekt, zum Beispiel einem Ball oder dem Spieler selbst, der sich von Punkt zu Punkt bewegt, und die asphaltierte Route bildet eine Linie.  An jedem Punkt gibt es eine leicht z√§hlbare Anzahl von Auswahlm√∂glichkeiten. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperlabyrinthe:</a></b> Hyperlabyrinthe sind Labyrinthe, in denen das zu l√∂sende Objekt nicht nur ein Punkt ist.  Ein Standardhyperlabyrinth (oder Hyperlabyrinth erster Ordnung) besteht aus einer Linie, die eine Oberfl√§che bildet, wenn sie sich entlang eines Pfades bewegt.  Hyperlabyrinth kann nur in 3D oder in einem Medium mit einer gr√∂√üeren Dimension existieren, und der Eingang zum Hyperlabyrinth ist oft kein Punkt, sondern eine Linie.  Hyperlabyrinth ist grundlegend anders, weil es notwendig ist, mehrere Teile entlang der Linie zu ber√ºcksichtigen und gleichzeitig mit ihnen zu arbeiten, und zu jedem Zeitpunkt gibt es eine nahezu unendliche Anzahl von Zust√§nden und Optionen f√ºr das, was mit der Linie getan werden kann.  Die L√∂sungslinie ist unendlich oder ihre Endpunkte liegen au√üerhalb des Hyperlabyrinths, um zu vermeiden, dass die Linie zu einem Punkt komprimiert wird, da sie in diesem Fall als Nicht-Hyperlabyrinth betrachtet werden kann. </li><li>  <b>Hyperhyperlabyrinth:</b> Hyperlabyrinthe k√∂nnen beliebig hoch dimensioniert sein.  Hyperhyperlabyrinth (oder Hyperlabyrinth zweiter Ordnung) erh√∂ht erneut die Dimension des zu l√∂senden Objekts.  Hier ist das zu l√∂sende Objekt eine Ebene, die, wenn sie sich entlang des Pfades bewegt, eine dreidimensionale Figur bildet.  Hyperhyperlabyrinth kann nur in einer 4D- oder h√∂herdimensionalen Umgebung existieren. </li></ul><br>  <b>Topologie: Die</b> Topologieklasse beschreibt die Geometrie des Labyrinthraums, in dem er als Ganzes existiert.  Folgende Typen stehen zur Verf√ºgung: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> Dies ist das Standardlabyrinth im euklidischen Raum. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: Der</b> Begriff ‚ÄûPlanair‚Äú beschreibt jedes Labyrinth mit einer ungew√∂hnlichen Topologie.  In der Regel bedeutet dies, dass die R√§nder des Labyrinths auf interessante Weise miteinander verbunden sind.  Beispiele: Labyrinthe auf der Oberfl√§che eines W√ºrfels, Labyrinthe auf der Oberfl√§che eines Mobius-Streifens und Labyrinthe, die denen eines Torus entsprechen, bei dem die linke und rechte, obere und untere Seite paarweise verbunden sind. </li></ul><br>  <b>Tessellation: Eine</b> Klassifizierung der Geometrie der einzelnen Zellen, aus denen das Labyrinth besteht.  Bestehende Typen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonal</b> <b>:</b> Dies ist ein rechteckiges Standardgitter, in dem Zellen Passagen haben, die sich im rechten Winkel schneiden.  Im Rahmen der Tessellation k√∂nnen sie auch als Gammalabyrinthe bezeichnet werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> Delta-Labyrinthe bestehen aus verbundenen Dreiecken, und an jede Zelle k√∂nnen bis zu drei Passagen angeschlossen werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>:</b> Sigma-Labyrinthe bestehen aus verbundenen Sechsecken.  Jede Zelle kann bis zu sechs Durchg√§nge haben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Theta</b> <b>:</b> Theta-Labyrinthe bestehen aus konzentrischen Kreisen von Durchg√§ngen, bei denen der Anfang oder das Ende in der Mitte und der andere am √§u√üeren Rand liegt.  Zellen haben normalerweise vier m√∂gliche Verbindungspfade, aber aufgrund der gr√∂√üeren Anzahl von Zellen in den √§u√üeren Ringen der Durchg√§nge kann es mehr geben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>:</b> Epsilon-Labyrinthe bestehen aus verbundenen Achtecken oder Quadraten. Jede Zelle in ihnen kann bis zu acht oder vier Durchg√§nge haben. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: Das</b> Zeta-Labyrinth befindet sich in einem rechteckigen Raster. Nur neben horizontalen und vertikalen Passagen sind diagonale Passagen in einem Winkel von 45 Grad zul√§ssig. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Omega</b> <b>: Der</b> Begriff Omega bezieht sich auf fast jedes Labyrinth mit konstanter nicht orthogonaler Tessellation.  Delta, Sigma, Theta und Ipsilon Labyrinthe sind von diesem Typ, wie viele andere Schemata, die Sie sich vorstellen k√∂nnen, zum Beispiel ein Labyrinth, das aus Paaren rechtwinkliger Dreiecke besteht. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Riss</b> <b>: Ein</b> Risslabyrinth ist ein amorphes Labyrinth ohne st√§ndige Tessellation, in dem sich W√§nde und Gehwege in zuf√§lligen Winkeln befinden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fraktal</b> <b>: Ein</b> fraktales Labyrinth ist ein Labyrinth aus kleineren Labyrinthen.  Ein fraktales Labyrinth aus verschachtelten Zellen ist ein Labyrinth in jeder Zelle, in dem andere Labyrinthe platziert sind, und dieser Vorgang kann mehrmals wiederholt werden.  Ein unendlich rekursives fraktales Labyrinth ist ein echtes Fraktal, in dem sich der Inhalt des Labyrinths selbst repliziert und ein im Wesentlichen unendlich gro√ües Labyrinth erzeugt. </li></ul><br>  <b>Routing: Die</b> Klassifizierung nach Routing ist wahrscheinlich der interessanteste Aspekt bei der Erzeugung von Labyrinthen.  From ist Arten von Durchg√§ngen innerhalb der Geometrie zugeordnet, die in den oben beschriebenen Kategorien definiert sind. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> ‚ÄûIdeal‚Äú ist ein Labyrinth ohne Schleifen oder geschlossene Kreisl√§ufe und ohne unerreichbare Bereiche.  Es wird auch ein einfach verbundenes Labyrinth genannt.  Von jedem Punkt gibt es genau einen Pfad zu einem anderen Punkt.  Labyrinth hat nur eine L√∂sung.  Aus programmtechnischer Sicht kann ein solches Labyrinth als Baum, als Verbindungsmenge von Zellen oder Eckpunkten beschrieben werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Geflochten</b> <b>:</b> Geflochten bedeutet, dass es im Labyrinth keine Sackgassen gibt.  Es wird auch das rein mehrfach verbundene Labyrinthlabyrinth genannt.  In einem solchen Labyrinth werden Passagen verwendet, die geschlossen sind und zueinander zur√ºckkehren (daher der Name ‚ÄûKorbweide‚Äú). Dadurch verbringen sie mehr Zeit damit, im Kreis zu laufen, anstatt in Sackgassen zu geraten.  Ein hochwertiges gewebtes Labyrinth kann viel komplizierter sein als ein ideales Labyrinth derselben Gr√∂√üe. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single-Route (Unicursal)</b> <b>:</b> Single- <b>Route</b> bedeutet ein Labyrinth ohne Gabeln.  Das Einweg-Labyrinth enth√§lt einen langen, gewundenen Durchgang, der die Richtung im gesamten Labyrinth √§ndert.  Es ist nicht sehr kompliziert, nur wenn Sie nicht versehentlich auf halber Strecke zur√ºckkehren und nicht zum Anfang zur√ºckkehren. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Sp√§rlich: Ein</b> sp√§rliches Labyrinth durchl√§uft nicht jede Zelle, dh einige von ihnen werden nicht erstellt.  Dies impliziert das Vorhandensein nicht erreichbarer Bereiche, dh in gewissem Sinne ist es das Gegenteil des Weidenlabyrinths.  Ein √§hnliches Konzept kann beim Hinzuf√ºgen von W√§nden angewendet werden, sodass Sie ein unebenes Labyrinth mit breiten G√§ngen und R√§umen erhalten. </li><li>  <b>Teilweise Wicker:</b> Teilweise Wicker Maze ist ein gemischtes Labyrinth, das sowohl Schleifen als auch Sackgassen aufweist.  Das Wort ‚ÄûKorbweide‚Äú kann zur quantitativen Beurteilung verwendet werden, dh ein ‚ÄûLabyrinth mit starkem Weben‚Äú ist ein Labyrinth mit vielen entfernten Schleifen oder W√§nden, und es gibt nur wenige im ‚ÄûLabyrinth mit schwachem Weben‚Äú. </li></ul><br>  <b>Textur: Die Texturklassifizierung</b> beschreibt den Stil von Durchl√§ufen mit unterschiedlichem Routing und unterschiedlicher Geometrie.  Textur ist nicht nur ein Parameter, der ein- oder ausgeschaltet werden kann.  Hier einige Beispiele f√ºr Variablen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Bias</b> <b>:</b> In einem Labyrinth mit verschobenen Passagen tendieren gerade Passagen eher in eine Richtung als in andere.  In einem Labyrinth mit hoher horizontaler Verschiebung haben wir beispielsweise lange Passagen von links nach rechts und nur kurze Passagen von oben nach unten, die sie verbinden.  Ein solches Labyrinth ist normalerweise schwieriger ‚Äû√ºber die Fasern‚Äú zu f√ºhren. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>√úberflug</b> <b>: Die</b> <b>√úberflugmetrik</b> bestimmt, wie lange es dauert, bis erzwungene Abbiegungen auftreten.  In einem Labyrinth mit geringer Spannweite gibt es keine geraden Passagen, die l√§nger als drei oder vier Zellen sind, und es sieht sehr zuf√§llig aus.  In einem Labyrinth mit einer hohen Spannweite hat das Labyrinth einen gro√üen Prozentsatz an langen Durchg√§ngen, wodurch es wie ein Mikrochip aussieht. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elitismus: Der</b> Indikator ‚Äû <b>Elitismus</b> ‚Äú des Labyrinths bestimmt die L√§nge der L√∂sung im Verh√§ltnis zur Gr√∂√üe des Labyrinths.  Elite-Labyrinthe haben normalerweise eine kurze, direkte L√∂sung, w√§hrend in Nicht-Elite-Labyrinthen die L√∂sung einen gro√üen Teil des Labyrinthbereichs durchl√§uft.  Ein hochwertiges Elite-Labyrinth kann viel komplizierter sein als ein Nicht-Elite-Labyrinth. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Symmetrie</b> <b>: Ein</b> symmetrisches Labyrinth hat symmetrische Passagen, beispielsweise in der Rotationssymmetrie relativ zur Mitte oder entlang der horizontalen oder vertikalen Achse.  Das Labyrinth kann teilweise oder vollst√§ndig symmetrisch sein und das Muster beliebig oft wiederholen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogenit√§t: Ein</b> homogener Algorithmus erzeugt alle m√∂glichen Labyrinthe mit gleicher Wahrscheinlichkeit.  Ein Labyrinth kann als homogen bezeichnet werden, wenn es wie ein typisches Labyrinth aussieht, das durch einen homogenen Algorithmus erzeugt wird.  Ein heterogener Algorithmus kann theoretisch auch alle m√∂glichen Labyrinthe in jedem Raum erzeugen, jedoch nicht mit gleicher Wahrscheinlichkeit.  Die Heterogenit√§t kann noch weiter gehen - es kann Labyrinthe geben, die der Algorithmus niemals erzeugen wird. </li><li>  <b>Flussfluss: Die</b> Eigenschaft ‚ÄûFluss‚Äú bedeutet, dass der Algorithmus beim Erstellen eines Labyrinths nach den benachbarten Zellen (oder W√§nden) sucht und diese reinigt, dh sie flie√üt (daher der Begriff ‚ÄûFluidit√§t‚Äú) wie Wasser in die noch nicht erstellten Teile des Labyrinths.  In einem idealen Labyrinth mit einer geringeren Durchflussrate gibt es normalerweise viele kurze Sackgassen, und in einem ‚Äûfl√ºssigeren‚Äú Labyrinth gibt es weniger Sackgassen, aber sie sind l√§nger. </li></ul><br>  <b>Priorit√§t:</b> Diese Klassifizierung zeigt, dass die Prozesse zur Erstellung von Labyrinthen in zwei Haupttypen unterteilt werden k√∂nnen: Hinzuf√ºgen von W√§nden und Schnitzen von Passagen.  Wenn es darum geht, dies zu generieren, kommt es normalerweise nur auf den Unterschied in den Algorithmen und nicht auf merkliche Unterschiede in den Labyrinthen an, aber es ist immer noch n√ºtzlich, dies zu ber√ºcksichtigen.  Das gleiche Labyrinth wird oft auf beide Arten erzeugt: <br><br><ul><li>  <b>Hinzuf√ºgen von W√§nden:</b> Algorithmen, f√ºr die W√§nde Priorit√§t haben, beginnen mit einem leeren Bereich (oder einem Au√üenrand) und f√ºgen dabei W√§nde hinzu.  In der realen Welt f√ºgen echte Labyrinthe, die aus Hecken, Decken oder Holzw√§nden bestehen, definitiv W√§nde hinzu. </li><li>  <b>G√§nge schneiden:</b> Algorithmen, deren Priorit√§t G√§nge sind, beginnen mit einem festen Block und schneiden dabei Passagen.  In der realen Welt sind solche Labyrinthe Minentunnel oder Labyrinthe in Rohren. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Vorlage:</b> Nat√ºrlich k√∂nnen Labyrinthe gleichzeitig Passagen schneiden und W√§nde hinzuf√ºgen.  Einige Computeralgorithmen machen das.  Eine Labyrinthvorlage ist ein Grafikbild, das kein Labyrinth ist, das sich in der geringsten Anzahl von Schritten in ein echtes Labyrinth verwandelt, aber dennoch die Textur der urspr√ºnglichen Grafikvorlage beibeh√§lt.  Komplexe Labyrinthstile wie sich √ºberschneidende Spiralen lassen sich leichter als Muster in einem Computer implementieren, als zu versuchen, das richtige Labyrinth zu erstellen und dabei seinen Stil beizubehalten. </li></ul><br>  <b>Sonstiges: Das</b> Obige ist keineswegs eine vollst√§ndige Liste aller m√∂glichen Klassen oder Elemente innerhalb jeder Klasse.  Dies sind nur die Arten von Labyrinthen, die ich selbst geschaffen habe.  Beachten Sie, dass fast jede Art von Labyrinth, einschlie√ülich Labyrinthen mit speziellen Regeln, als gerichteter Graph ausgedr√ºckt werden kann, in dem es in jedem Zustand eine endliche Anzahl von Zust√§nden und eine endliche Anzahl von Auswahlm√∂glichkeiten gibt. Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>√Ñquivalenz der Labyrinthe bezeichnet</b></a> .  Hier sind einige andere Klassifikationen und Arten von Labyrinthen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientierung</b> <b>:</b> An bestimmten Stellen k√∂nnen Sie sich nur in eine Richtung bewegen.  Aus programmtechnischer Sicht wird ein solches Labyrinth durch einen gerichteten Graphen beschrieben, im Gegensatz zu einem ungerichteten Graphen, der alle anderen Typen beschreibt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentierung</b> <b>: Das</b> Labyrinth kann verschiedene Teile haben, die verschiedenen Klassen entsprechen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labyrinthe von unendlicher L√§nge:</b> Wir k√∂nnen ein unendlich langes Labyrinth erstellen (eine endliche Anzahl von Spalten und eine beliebige Anzahl von Zeilen), aber gleichzeitig nur einen Teil des Labyrinths im Speicher speichern, von einem Ende zum anderen ‚Äûscrollen‚Äú und beim Erstellen der n√§chsten die vorherigen Zeilen zerst√∂ren.  Ein Beispiel ist eine modifizierte Version des Hunt and Kill-Algorithmus.  Man kann sich ein m√∂glicherweise endloses Labyrinth in Form eines langen Films vorstellen, der aus einzelnen Bildern besteht.  Es werden jeweils nur zwei aufeinanderfolgende Frames gespeichert.  Lassen Sie uns den Hunt and Kill-Algorithmus ausf√ºhren, obwohl er eine Verzerrung erzeugt, die f√ºr den oberen Frame anf√§llig ist, sodass er zuerst endet.  Nach der Fertigstellung wird der Rahmen nicht mehr ben√∂tigt, Sie k√∂nnen ihn drucken oder etwas anderes damit machen.  Wie auch immer, verwerfen Sie es, machen Sie den teilweise erstellten unteren Rahmen zu einem neuen oberen Rahmen und l√∂schen Sie den neuen unteren Rahmen.  Wiederholen Sie den Vorgang, bis wir aufh√∂ren m√∂chten, und warten Sie dann, bis Hunt And Kill beide Frames abgeschlossen hat.  Die einzige Einschr√§nkung besteht darin, dass das Labyrinth niemals einen Pfad hat, der sich √ºber eine L√§nge von mehr als zwei Frames zum Eingang hin verzweigt.  Der einfachste Weg, ein endloses Labyrinth zu erstellen, ist der Eller-Algorithmus oder der Sidewinder-Algorithmus, da sie bereits zeilenweise Labyrinthe erstellen, sodass Sie sie einfach endlos Linien zum Labyrinth hinzuf√ºgen lassen k√∂nnen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="Bild"><br><br></b>  <b>Virtuelle fraktale Labyrinthe:</b> Virtuell ist ein Labyrinth, in dem nicht das gesamte Labyrinth gleichzeitig gespeichert wird.  Beispielsweise kann nur ein Teil der 100 x 100 Durchg√§nge in der N√§he Ihres Standorts in einer Simulation gespeichert werden, in der Sie durch ein gro√ües Labyrinth gehen.  Die Erweiterung verschachtelter fraktaler Labyrinthe kann verwendet werden, um riesige virtuelle Labyrinthe zu erstellen, beispielsweise eine Milliarde pro Milliarde Durchg√§nge.  Wenn wir eine echte Kopie des Labyrinths von einer Milliarde pro Milliarde P√§ssen (mit einem Abstand von sechs Fu√ü zwischen den Passagen) bauen w√ºrden, w√ºrde es die Erdoberfl√§che mehr als 6.000 Mal f√ºllen!  Stellen Sie sich ein Labyrinth von 10 <sup>9</sup> bis 10 <sup>9</sup> Durchg√§ngen oder ein geschlossenes Labyrinth mit nur 9 Ebenen vor.  Wenn wir mindestens ein 100x100-Teil um uns haben m√∂chten, reicht es aus, auf der untersten Ebene ein Unterlabyrinth von 100x100 Durchg√§ngen und sieben 10x10-Labyrinthen zu erstellen, in das es eingebettet ist, um genau zu wissen, wo sich die W√§nde innerhalb des 100x100-Teils befinden.  (Eigentlich ist es besser, vier benachbarte Teile mit einer Gr√∂√üe von 100 x 100 zu haben, die ein Quadrat bilden, falls Sie sich in der N√§he der Kante oder Ecke des Teils befinden. Hier gilt jedoch das gleiche Konzept.) Um sicherzustellen, dass das Labyrinth beim Bewegen konstant und unver√§ndert bleibt, haben wir eine Formel: Definieren einer zuf√§lligen Startnummer f√ºr jede Koordinate auf jeder Verschachtelungsebene.  Virtuelle fraktale Labyrinthe √§hneln dem Mandelbrot-Fraktal, in dessen Bildern es virtuell existiert, und wir m√ºssen eine bestimmte Koordinate mit einer ziemlich hohen Vergr√∂√üerung besuchen.  so dass es erscheint. </li></ul><br><h2>  Labyrinth-Algorithmen </h2><br>  Hier ist eine Liste verallgemeinerter Algorithmen zum Erstellen der verschiedenen oben beschriebenen Labyrinthklassen: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> Um ein ideales Standardlabyrinth zu schaffen, muss es normalerweise ‚Äûwachsen‚Äú, um sicherzustellen, dass keine Schleifen und isolierten Bereiche vorhanden sind.  Wir beginnen an der Au√üenwand und f√ºgen zuf√§llig ein Fragment der Wand hinzu, das sie ber√ºhrt.  Wir f√ºgen dem Labyrinth weiterhin zuf√§llig Wandsegmente hinzu, stellen jedoch sicher, dass jedes neue Segment ein Ende der vorhandenen Wand ber√ºhrt und sich das andere Ende im noch nicht erstellten Teil des Labyrinths befindet.  Wenn Sie ein Wandsegment hinzuf√ºgen, dessen beide Enden vom Rest des Labyrinths getrennt sind, wird eine nicht verbundene Wand mit einer Schleife erstellt. Wenn Sie ein Segment hinzuf√ºgen, dessen beide Enden das Labyrinth ber√ºhren, entsteht ein nicht erreichbarer Bereich.  Dies ist eine Methode zum Hinzuf√ºgen von W√§nden.  Es ist fast analog zum Ausschneiden von Passagen, bei denen Teile der Passagen so geschnitten werden, dass nur ein Ende den vorhandenen Pass ber√ºhrt. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -¬´¬ª, (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        ‚Äî   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  ¬´¬ª        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     ¬´¬ª    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  ‚Äî  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     ‚Äî       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele M√∂glichkeiten, perfekte Labyrinthe zu erstellen, und jeder von ihnen hat seine eigenen Eigenschaften. </font><font style="vertical-align: inherit;">Unten finden Sie eine Liste spezifischer Algorithmen. </font><font style="vertical-align: inherit;">Alle beschreiben die Schaffung eines Labyrinths durch Ausschneiden von Passagen. Sofern nicht anders angegeben, kann jedes auch durch Hinzuf√ºgen von W√§nden implementiert werden:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekursiver Backtracker </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     ¬´¬ª   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Prims Algorithmus (true)</b> <b>:</b> Dieser Algorithmus erstellt einen minimalen Spanning Tree, indem er eindeutig zuf√§llige Kantengewichte verarbeitet.  Der erforderliche Speicherplatz ist proportional zur Gr√∂√üe des Labyrinths.  Wir beginnen an einem beliebigen Scheitelpunkt (das fertige Labyrinth ist das gleiche, egal von oben, wo wir beginnen).  Wir w√§hlen die Kante des Durchgangs mit dem kleinsten Gewicht aus, das das Labyrinth mit einem Punkt verbindet, der sich noch nicht darin befindet, und befestigen es dann am Labyrinth.  Das Labyrinth ist fertig, wenn die fraglichen Kanten nicht mehr √ºbrig sind.  Um die n√§chste Kante effizient auszuw√§hlen, ben√∂tigen Sie eine Priorit√§tswarteschlange (normalerweise mithilfe eines Heaps implementiert), in der alle Kanten des Rahmens gespeichert sind.  Dieser Algorithmus ist jedoch ziemlich langsam, da die Auswahl von Elementen aus dem Heap log (n) Zeit ben√∂tigt.  Daher ist es besser, den Kraskal-Algorithmus zu bevorzugen, der auch einen minimalen Spannbaum erzeugt, da er schneller ist und Labyrinthe mit identischer Struktur erzeugt.  Tats√§chlich k√∂nnen die Algorithmen Prima und Kraskal mit demselben zuf√§lligen Startwert dieselben Labyrinthe erzeugen. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Prims Algorithmus (vereinfacht)</b> <b>:</b> Dieser Prims Algorithmus erstellt einen minimalen Spannbaum.  Es wird so vereinfacht, dass alle Kantengewichte gleich sind.  Es erfordert eine Speicherkapazit√§t proportional zur Gr√∂√üe des Labyrinths.  Wir gehen von einem zuf√§lligen Peak aus.  Wir w√§hlen zuf√§llig den Rand des Durchgangs aus, der das Labyrinth mit einem Punkt verbindet, der sich noch nicht darin befindet, und befestigen ihn dann am Labyrinth.  Das Labyrinth ist fertig, wenn die fraglichen Kanten nicht mehr √ºbrig sind.  Da die Kanten schwerelos und nicht geordnet sind, k√∂nnen sie als einfache Liste gespeichert werden, dh die Auswahl der Elemente aus der Liste erfolgt sehr schnell und nimmt konstante Zeit in Anspruch.  Daher ist es viel schneller als der echte Prim-Algorithmus mit zuf√§lligen Kantengewichten.  Die erzeugte Labyrinthtextur hat eine geringere Flussrate und eine einfachere L√∂sung als die echte Prim-Methode, da sie sich wie versch√ºtteter Sirup gleichm√§√üig vom Startpunkt aus verteilt und keine Rippenfragmente mit h√∂herem Gewicht umgeht, die sp√§ter ber√ºcksichtigt werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Prims Algorithmus (modifiziert)</b> <b>:</b> Dieser Prims Algorithmus erstellt einen minimalen Spannbaum, der so modifiziert ist, dass alle Gewichte der Kanten gleich sind.  Es ist jedoch so implementiert, dass anstelle von Kanten Zellen betrachtet werden.  Die Speichermenge ist proportional zur Gr√∂√üe des Labyrinths.  W√§hrend des Erstellungsprozesses kann jede Zelle einen von drei Typen haben: (1) ‚Äûintern‚Äú: Die Zelle ist Teil des Labyrinths und bereits darin ausgeschnitten. (2) ‚ÄûGrenze‚Äú: Die Zelle ist nicht Teil des Labyrinths und wurde noch nicht ausgeschnitten, befindet sich jedoch neben der Zelle, die bereits ‚Äûintern‚Äú ist, und (3) ‚Äûextern‚Äú: Die Zelle ist noch nicht Teil des Labyrinths, und keiner ihrer Nachbarn ist auch die ‚Äûinterne‚Äú Zelle.  Wir beginnen mit der Auswahl einer Zelle, machen sie "intern" und setzen f√ºr alle Nachbarn den Typ auf "Grenze".  Wir w√§hlen zuf√§llig die "Grenz" -Zelle aus und schneiden einen Durchgang von einer der benachbarten "internen" Zellen hinein.  Wir √§ndern den Status dieser "Grenzzelle" in "intern" und √§ndern den Typ aller Nachbarn von "extern" in "Grenze".  Das Labyrinth ist abgeschlossen, wenn keine "Grenz" -Zellen mehr vorhanden sind (dh keine "externen" Zellen mehr vorhanden sind, was bedeutet, dass jeder "intern" geworden ist).  Dieser Algorithmus erzeugt Labyrinthe mit einem sehr niedrigen Ertragsindex, hat viele kurze Deadlocks und eine ziemlich einfache L√∂sung.  Das resultierende Labyrinth ist dem Ergebnis des vereinfachten Prima-Algorithmus sehr √§hnlich, mit einem kleinen Unterschied: Die Hohlr√§ume im Spanning Tree werden nur gef√ºllt, wenn eine Grenzzelle zuf√§llig ausgew√§hlt wird, im Gegensatz zu der dreifachen Wahrscheinlichkeit, diese Zelle durch eine der dazu f√ºhrenden Grenzzellen zu f√ºllen.  Dar√ºber hinaus ist der Algorithmus sehr schnell und schneller als der vereinfachte Prim-Algorithmus, da die Kantenliste nicht kompiliert und verarbeitet werden muss. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Aldous-Broder-</b> Algorithmus: Interessant an diesem Algorithmus ist, dass er homogen ist, dh mit gleicher Wahrscheinlichkeit alle m√∂glichen Labyrinthe einer bestimmten Gr√∂√üe erzeugt.  Dar√ºber hinaus ist kein zus√§tzlicher Speicher oder Stapel erforderlich.  Wir w√§hlen einen Punkt aus und bewegen uns zuf√§llig in eine benachbarte Zelle.  Wenn wir in eine ungeschnittene Zelle geraten sind, schneiden Sie den Durchgang aus der vorherigen Zelle in diese aus.  Wir bewegen uns weiter zu benachbarten Zellen, bis wir die Passagen zu allen Zellen herausgeschnitten haben.  Dieser Algorithmus erzeugt Labyrinthe mit einer geringen Durchflussrate, die nur geringf√ºgig h√∂her ist als der Kraskal-Algorithmus.  (Dies bedeutet, dass es f√ºr einen bestimmten Austausch mehr Labyrinthe mit einem niedrigen Ertragsindex als mit einem hohen gibt, da das Labyrinth mit einer durchschnittlichen Wahrscheinlichkeit ebenso niedrig ist.) Das Schlechte an diesem Algorithmus ist, dass er sehr langsam ist, weil er keine intellektuelle Suche nach letzterem durchf√ºhrt Zellen, das hei√üt in der Tat, haben keine Garantien f√ºr die Fertigstellung.  Aufgrund seiner Einfachheit kann es jedoch schnell viele Zellen durchlaufen, sodass es schneller abgeschlossen wird, als Sie vielleicht denken.  Im Durchschnitt dauert die Fertigstellung siebenmal l√§nger als bei Standardalgorithmen, obwohl es in schlechten F√§llen viel l√§nger dauern kann, wenn der Zufallszahlengenerator die letzten Zellen st√§ndig vermeidet.  Es kann als Hinzuf√ºgen von W√§nden implementiert werden, wenn die Grenzwand als einzelner Scheitelpunkt betrachtet wird, d. H. Wenn die Bewegung uns beispielsweise zur Grenzwand bewegt, teleportieren wir uns zu einem zuf√§lligen Punkt entlang der Grenze und bewegen uns erst dann weiter.  Beim Hinzuf√ºgen von W√§nden funktioniert es fast doppelt so schnell, da die Teleportation entlang der Grenzmauer einen schnelleren Zugang zu den entfernten Teilen des Labyrinths erm√∂glicht. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Wilsons Algorithmus</b> <b>:</b> Dies ist eine verbesserte Version des Aldous-Broder-Algorithmus. Er erzeugt Labyrinthe mit genau der gleichen Textur (die Algorithmen sind homogen, dh alle m√∂glichen Labyrinthe werden mit gleicher Wahrscheinlichkeit erzeugt), aber der Wilson-Algorithmus ist viel schneller.  Es braucht Speicher bis zur Gr√∂√üe des Labyrinths.  Wir beginnen mit einer zuf√§llig ausgew√§hlten anf√§nglichen Labyrinthzelle.  Wir w√§hlen eine zuf√§llige Zelle aus, die noch nicht Teil des Labyrinths ist, und f√ºhren einen zuf√§lligen Spaziergang durch, bis wir eine Zelle finden, die bereits zum Labyrinth geh√∂rt.  Sobald wir auf den bereits erstellten Teil des Labyrinths sto√üen, kehren wir zur ausgew√§hlten zuf√§lligen Zelle zur√ºck und schneiden den gesamten Pfad aus, indem wir diese Zellen zum Labyrinth hinzuf√ºgen.  Genauer gesagt, wenn wir auf dem Weg zur√ºckkehren, schneiden wir jede Zelle in der Richtung ein, in der der zuf√§llige Spaziergang beim letzten Verlassen der Zelle stattgefunden hat.  Dies vermeidet das Auftreten von Schleifen entlang des R√ºckweges, so dass ein langer Durchgang das Labyrinth verbindet.  Das Labyrinth ist abgeschlossen, wenn alle Zellen daran befestigt sind.  Der Algorithmus hat die gleichen Geschwindigkeitsprobleme wie Aldous-Broder, da es lange dauern kann, den ersten zuf√§lligen Pfad zur urspr√ºnglichen Zelle zu finden, aber nach dem Platzieren mehrerer Pfade wird der Rest des Labyrinths ziemlich schnell herausgeschnitten.  Im Durchschnitt l√§uft es f√ºnfmal schneller als Aldous-Broder und weniger als zweimal langsamer als die besten Algorithmen.  Es ist zu bedenken, dass das Hinzuf√ºgen von W√§nden doppelt so schnell funktioniert, da die gesamte Grenzmauer anfangs Teil des Labyrinths ist, sodass sich die ersten W√§nde viel schneller verbinden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  <b>Hunt and Kill-</b> Algorithmus <b>:</b> Dieser Algorithmus ist praktisch, da er keinen zus√§tzlichen Speicher oder Stapel ben√∂tigt und daher zum Erstellen gro√üer Labyrinthe oder Labyrinthe auf schwachen Computern geeignet ist, da nicht gen√ºgend Speicherplatz zur Verf√ºgung steht.  Da es keine Regeln gibt, die st√§ndig befolgt werden m√ºssen, ist es auch am einfachsten, Labyrinthe mit unterschiedlichen Texturen damit zu √§ndern und zu erstellen.  Es √§hnelt fast einem rekursiven Backtracker, nur dass keine Zelle in der N√§he der aktuellen Position erstellt wurde.  Wir wechseln in den "Jagd" -Modus und scannen systematisch das Labyrinth, bis wir eine nicht erstellte Zelle neben der bereits geschnittenen Zelle finden.  In dieser Phase beginnen wir wieder mit dem Schneiden an diesem neuen Standort.  Das Labyrinth ist abgeschlossen, wenn im "Jagd" -Modus alle Zellen gescannt werden.  Dieser Algorithmus neigt dazu, Labyrinthe mit einer hohen Flussrate zu erzeugen, die jedoch nicht so hoch sind wie der rekursive Backtracker.  Sie k√∂nnen es zwingen, Labyrinthe mit einer niedrigeren Durchflussrate zu erzeugen, die h√§ufiger in den "Jagd" -Modus wechseln.  Es l√§uft langsamer aufgrund der Zeit, die f√ºr die Jagd auf die letzten Zellen aufgewendet wurde, aber nicht viel langsamer als der Kraskal-Algorithmus.  Es kann nach dem Prinzip des Hinzuf√ºgens von W√§nden implementiert werden, wenn Sie gelegentlich zuf√§llig teleportieren, um die Probleme zu vermeiden, die einem rekursiven Backtracker inh√§rent sind. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Wachsender Algorithmus</b> <b><br></b>  <b>Baum (Wachsender Baum-Algorithmus)</b> <b>:</b> Dies ist ein verallgemeinerter Algorithmus, der Labyrinthe mit unterschiedlichen Texturen erstellen kann.  Der erforderliche Speicher kann die Gr√∂√üe des Labyrinths erreichen.  Jedes Mal, wenn eine Zelle geschnitten wird, f√ºgen wir sie der Liste hinzu.  W√§hlen Sie eine Zelle aus der Liste aus und schneiden Sie den Durchgang zu der nicht erstellten Zelle daneben aus.  Wenn sich in der N√§he der aktuellen Zelle keine nicht erstellten Zellen befinden, l√∂schen Sie die aktuelle Zelle aus der Liste.  Das Labyrinth ist abgeschlossen, wenn die Liste nichts anderes enth√§lt.  Das Interessante am Algorithmus ist, dass Sie abh√§ngig davon, wie Sie eine Zelle aus der Liste ausw√§hlen, viele verschiedene Texturen erstellen k√∂nnen.  Wenn Sie beispielsweise immer die zuletzt hinzugef√ºgte Zelle ausw√§hlen, wird dieser Algorithmus zu einem rekursiven Backtracker.  Wenn Sie Zellen immer zuf√§llig ausw√§hlen, verh√§lt es sich √§hnlich, jedoch nicht identisch mit dem Prim-Algorithmus.  Wenn Sie immer die √§ltesten Zellen ausw√§hlen, die der Liste hinzugef√ºgt wurden, erstellen wir ein Labyrinth mit dem niedrigstm√∂glichen Ertragsindex, der sogar unter dem des Prim-Algorithmus liegt.  Wenn Sie normalerweise die allerletzte Zelle ausw√§hlen, aber gelegentlich eine zuf√§llige Zelle ausw√§hlen, hat das Labyrinth eine hohe Flussrate, aber eine kurze und direkte L√∂sung.  Wenn eine der neuesten Zellen zuf√§llig ausgew√§hlt wird, hat das Labyrinth eine geringe Durchflussrate, aber eine lange und gewundene L√∂sung. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Wachsender Waldalgorithmus</b> <b>:</b> Dies ist ein allgemeinerer Algorithmus, der Typen basierend auf B√§umen und Mengen kombiniert.  Es ist eine Erweiterung des Baumwachstumsalgorithmus, der im Wesentlichen mehrere Instanzen umfasst, die gleichzeitig erweitert werden.  Wir beginnen mit allen Zellen, die zuf√§llig in einer Liste von "neu" sortiert sind.  Dar√ºber hinaus hat jede Zelle wie zu Beginn des Kruskal-Algorithmus ihren eigenen Satz.  W√§hlen Sie zun√§chst eine oder mehrere Zellen aus, indem Sie sie aus der Liste "Neu" in die Liste "Aktiv" verschieben.  W√§hlen Sie eine Zelle aus der Liste "aktiv" aus und schneiden Sie die Passage zur n√§chsten nicht erstellten Zelle aus der Liste "neu" aus. F√ºgen Sie der Liste "aktiv" eine neue Zelle hinzu und kombinieren Sie die S√§tze von zwei Zellen.  Wenn versucht wird, in den vorhandenen Teil des Labyrinths zu schneiden, aktivieren Sie ihn, wenn sich die Zellen in verschiedenen S√§tzen befinden, und kombinieren Sie die Zellen, wie im Kraskal-Algorithmus.  Wenn sich in der N√§he der aktuellen Zelle keine "neuen" Zellen befinden, verschieben Sie die aktuelle Zelle in die Liste der "fertigen".  Das Labyrinth ist abgeschlossen, wenn die Liste der "aktiven" leer wird.  Am Ende kombinieren wir alle verbleibenden Mengen wie im Kruskal-Algorithmus.  In regelm√§√üigen Abst√§nden k√∂nnen Sie neue B√§ume erstellen, indem Sie wie zu Beginn eine oder mehrere Zellen aus der Liste "Neu" in die Liste "Aktiv" verschieben.  Durch Steuern der Anzahl der urspr√ºnglichen B√§ume und der Anteile der neu erstellten B√§ume k√∂nnen Sie viele eindeutige Texturen generieren, die mit den bereits flexiblen Parametern des Baumwachstumsalgorithmus kombiniert werden. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Ellers Algorithmus</b> <b>:</b> Dies ist ein spezieller Algorithmus, da er nicht nur schneller als alle anderen ist, sondern auch keine offensichtlichen Vorurteile oder M√§ngel aufweist.  Dar√ºber hinaus wird der Speicher beim Erstellen am effizientesten genutzt.  Es ist nicht einmal erforderlich, dass sich das gesamte Labyrinth im Speicher befindet, sondern es wird ein Volumen verwendet, das proportional zur Gr√∂√üe der Zeile ist.  Es erstellt zeilenweise ein Labyrinth. Nachdem die Generierung der Zeichenfolge abgeschlossen ist, ber√ºcksichtigt der Algorithmus dies nicht mehr.  Jede Zelle in einer Reihe ist in einer Menge enthalten.  Zwei Zellen geh√∂ren zu derselben Gruppe, wenn sich zwischen ihnen entlang des bereits erstellten Labyrinths ein Pfad befindet.  Mit diesen Informationen k√∂nnen Sie Passagen in der aktuellen Zeile ausschneiden, ohne Schleifen oder isolierte Bereiche zu erstellen.  Tats√§chlich ist es dem Kraskal-Algorithmus ziemlich √§hnlich, nur dass es hier zeilenweise gebildet wird, w√§hrend Kraskal durch das gesamte Labyrinth schaut.  Das Erstellen einer Zeile besteht aus zwei Teilen: Verbinden Sie benachbarte Zellen innerhalb der Zeile zuf√§llig, d. H.  wir schneiden horizontale Passagen aus und verbinden dann zuf√§llig die Zellen zwischen der aktuellen und der n√§chsten Reihe, d.h.  vertikale Passagen ausschneiden.  Beim Schneiden horizontaler Passagen verbinden wir keine Zellen, die sich bereits im selben Satz befinden (da sonst eine Schleife erstellt wird), und beim Schneiden vertikaler Passagen m√ºssen wir eine Zelle verbinden, wenn sie eine Einheitsgr√∂√üe hat (wenn Sie sie verlassen, wird ein isolierter Bereich erstellt).  Wenn wir horizontale Passagen schneiden, verbinden wir Zellen, wenn sie sich im selben Satz befinden (weil jetzt ein Pfad zwischen ihnen besteht), und wenn wir vertikale Passagen schneiden, wenn wir keine Verbindung mit der Zelle herstellen, legen wir sie in einen separaten Satz (weil sie jetzt vom Rest des Labyrinths getrennt sind )  Die Erstellung beginnt mit der Tatsache, dass vor dem Verbinden der Zellen in der ersten Zeile jede Zelle ihren eigenen Satz hat.  Die Erstellung ist abgeschlossen, nachdem die Zellen in der letzten Zeile verbunden wurden.  Es gibt eine spezielle Regel f√ºr die Fertigstellung: Zum Zeitpunkt der Fertigstellung sollte sich jede Zelle im selben Satz befinden, um isolierte Bereiche zu vermeiden.  (Die letzte Zeile wird erstellt, indem jedes der Paare benachbarter Zellen kombiniert wird, die sich noch nicht in derselben Gruppe befinden.) Es ist am besten, die Gruppe mithilfe einer zyklisch doppelt verkn√ºpften Liste von Zellen zu implementieren (die nur ein Array sein kann, das Zellen mit Zellenpaaren auf beiden Seiten derselben Gruppe verbindet) F√ºhren Sie das Einf√ºgen, L√∂schen und √úberpr√ºfen des Vorhandenseins benachbarter Zellen in einem Satz f√ºr eine konstante Zeit durch.  Das Problem bei diesem Algorithmus ist das Ungleichgewicht bei der Verarbeitung der verschiedenen Kanten des Labyrinths.  Um Flecken in Texturen zu vermeiden, m√ºssen Sie Verbindungszellen in den richtigen Proportionen verbinden und √ºberspringen. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Rekursive Division:</b> Dieser Algorithmus √§hnelt dem rekursiven Backtracking, da beide Stapel verwenden. Nur funktioniert er nicht mit G√§ngen, sondern mit W√§nden.  Wir beginnen mit der Erstellung einer zuf√§lligen horizontalen oder vertikalen Wand, die einen zug√§nglichen Bereich in einer zuf√§lligen Zeile oder Spalte schneidet, und platzieren zuf√§llig leere R√§ume entlang dieser.  Dann wiederholen wir rekursiv den Vorgang f√ºr die beiden durch die Trennwand erzeugten Teilregionen.  Um optimale Ergebnisse zu erzielen, m√ºssen Sie eine Abweichung bei der Auswahl von horizontal oder vertikal hinzuf√ºgen, die auf den Proportionen des Bereichs basiert. Beispielsweise sollte ein Bereich, dessen Breite doppelt so hoch ist wie die H√∂he, h√§ufiger durch vertikale W√§nde geteilt werden.  Dies ist der schnellste Algorithmus ohne Richtungsabweichungen und kann oft sogar mit Labyrinthen konkurrieren, die auf Bin√§rb√§umen basieren, da mehrere Zellen gleichzeitig erstellt werden, obwohl er einen offensichtlichen Nachteil in Form langer W√§nde aufweist, die das Innere des Labyrinths schneiden.  Dieser Algorithmus ist eine Art eingebetteter fraktaler Labyrinthe, aber anstatt st√§ndig Labyrinthe von Zellen fester Gr√∂√üe mit Labyrinthen gleicher Gr√∂√üe in jeder Zelle zu erstellen, teilt er einen bestimmten Bereich zuf√§llig in ein Labyrinth zuf√§lliger Gr√∂√üe: 1x2 oder 2x1.  Rekursive Division kann nicht zum Ausschneiden von Passagen verwendet werden, da dies zur Schaffung einer offensichtlichen L√∂sung f√ºhrt, die entweder entlang der Au√üenkante folgt oder auf andere Weise die Innenseite direkt schneidet. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labyrinthe basierend auf Bin√§rb√§umen</b> <b>:</b> Tats√§chlich sind dies die einfachsten und schnellstm√∂glichen Algorithmen. Die erstellten Labyrinthe weisen jedoch eine Textur mit einer sehr hohen Vorspannung auf.  F√ºr jede Zelle schneiden wir einen Durchgang entweder nach oben oder nach links, jedoch niemals in beide Richtungen.  In der Version mit zus√§tzlichen W√§nden wird f√ºr jeden nach unten oder rechts f√ºhrenden Scheitelpunkt ein Wandsegment hinzugef√ºgt, jedoch nicht in beide Richtungen.  Jede Zelle ist unabh√§ngig von allen anderen Zellen, da wir beim Erstellen nicht den Status einiger anderer Zellen √ºberpr√ºfen m√ºssen.  Daher ist dies ein realer Algorithmus zum Erzeugen von Labyrinthen ohne Speicher, der nicht durch die Gr√∂√üe der erstellten Labyrinthe begrenzt ist.  Tats√§chlich ist dies ein Bin√§rbaum, wenn wir die obere linke Ecke als Wurzel betrachten und jeder Knoten oder jede Zelle einen eindeutigen √ºbergeordneten Knoten hat, der eine Zelle dar√ºber oder links davon ist.  Auf Bin√§rb√§umen basierende Labyrinthe unterscheiden sich von idealen Standardlabyrinthen, da mehr als die H√§lfte der Zelltypen in ihnen nicht existieren k√∂nnen.  Zum Beispiel wird es niemals Kreuzungen in ihnen geben, und alle Sackgassen haben Passagen, die nach oben oder links und niemals nach unten oder rechts f√ºhren.  Labyrinthe haben in der Regel Passagen, die diagonal von links oben nach rechts unten f√ºhren, und es ist viel einfacher, sich von rechts unten nach links oben zu bewegen.  Sie k√∂nnen sich immer nach oben oder links bewegen, aber niemals gleichzeitig in beide Richtungen, sodass Sie sich immer deterministisch diagonal nach oben und links bewegen k√∂nnen, ohne auf Barrieren zu sto√üen.  Sie haben die M√∂glichkeit zu w√§hlen und in Sackgassen zu geraten, indem Sie sich nach unten und rechts bewegen. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   ¬´    ¬ª.   ,       sidewinder ‚Äî      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% Sackgassen</font></font></b> </td><td>  <b>Typ</b> </td><td>  <b>Priorit√§t</b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Voreingenommenheit?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Homogen?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Erinnerung</font></font></b> </td><td>  <b>Zeit</b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% L√∂sung</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einzelne Route </font></font></td><td>  0 </td><td>  Baum </td><td>  Die W√§nde </td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  379 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekursiver Backtracker </font></font></td><td>  10 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehwege </font></font></td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  27 </td><td>  19.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jagen und t√∂ten </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11 (21) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehwege </font></font></td><td>  Ja </td><td>  Niemals </td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100 (143) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9,5 (3,9) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekursive Division </font></font></td><td>  23 </td><td>  Baum </td><td>  Die W√§nde </td><td>  Ja </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  10 </td><td>  7.2 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bin√§rer Baum </font></font></td><td>  25 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  10 </td><td>  2.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sidewinder </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Niemals </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  12 </td><td>  2.6 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eller-Algorithmus </font></font></td><td>  28 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Nein </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  20 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,2 (3,2) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wilson-Algorithmus </font></font></td><td>  29 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48 (25) </font></font></td><td>  4.5 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aldous-Broder-Algorithmus </font></font></td><td>  29 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Ja </td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 279 (208) </font></font></td><td>  4.5 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kraskal-Algorithmus </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  33 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (wahr) </font></font></td><td>  30 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  160 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (vereinfacht) </font></font></td><td>  32 </td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  59 </td><td>  2.3 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prima-Algorithmus (modifiziert) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 36 (31) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  30 </td><td>  2.3 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baum w√§chst </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td>  Baum </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  48 </td><td>  11.0 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wald w√§chst </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beides </font></font></td><td>  Ja </td><td>  Nein </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  76 </td><td>  11.0 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Tabelle fasst die Eigenschaften der oben beschriebenen Algorithmen zur Erzeugung idealer Labyrinthe zusammen. </font><font style="vertical-align: inherit;">Zum Vergleich wurde ein Einweg-Labyrinthalgorithmus hinzugef√ºgt (theoretisch sind Einweg-Labyrinthe ideal). </font><font style="vertical-align: inherit;">Spaltenerkl√§rung:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . ¬´¬ª ,    . ¬´¬ª ,            ,     . ¬´¬ª ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     ¬´¬ª  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele M√∂glichkeiten, Labyrinthe zu l√∂sen, und jede hat ihre eigenen Eigenschaften. </font><font style="vertical-align: inherit;">Hier ist eine Liste spezifischer Algorithmen:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgen entlang der W√§nde (Wall Follower) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        (¬´¬ª),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    ¬´¬ª    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   ‚Äî  -1,    ‚Äî  1.            ,      , ..     360   ,        ¬´¬ª.  ,         ¬´¬ª,      ,        ,      ,      ,         .  ,             ,           .      ,    ‚Äî    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      ¬´¬ª      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   ¬´¬ª, ,     ,  ¬´¬ª, ,       .  ,         ,    ¬´¬ª;    ¬´¬ª       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Tr√©maux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  ‚Äî   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   ‚Äî   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   ¬´¬ª ,          (      ),   ¬´¬ª  , ,     .      ¬´¬ª,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   ¬´¬ª ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    ¬´¬ª ,          (  ).   ¬´ ¬ª       (   ),       ,   .      ¬´¬ª,     ,       ,   ,     . ( ,    ¬´¬ª,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td>  <b>Priorit√§t</b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Nein </td><td>  Ja </td><td>  Nein </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Ja </td><td>  Ja </td><td>  Ja </td></tr><tr><td>   </td><td>  1 </td><td>  Nein </td><td>  Du bist </td><td>  /  </td><td>  Ja </td><td>  Ja </td><td>  Ja </td></tr><tr><td>   </td><td>  1 </td><td>  Ja </td><td> + </td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td> Recursive Backtracker </td><td>  1 </td><td>  Ja </td><td>  Du bist </td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tremo-Algorithmus </font></font></td><td>  1 </td><td>  Ja </td><td>  Du bist </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Innen / √ºber </font></font></td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse F√ºller </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Nein </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber </font></font></td><td>  Nein </td><td>  Ja </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse F√ºller </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Nein </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber </font></font></td><td>  Nein </td><td>  Ja </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgasse Sealer </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle + </font></font></td><td>  Ja </td><td>  Labyrinth </td><td>  Nein </td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sackgassenf√ºller </font></font></td><td>  Alle </td><td>  Ja </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kollisionsl√∂ser </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles am k√ºrzesten </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Nein </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach k√ºrzesten Wegen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles am k√ºrzesten </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach dem k√ºrzesten Weg </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 k√ºrzeste </font></font></td><td>  Ja </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie + </font></font></td><td>  Nein </td><td>  Ja </td><td>  Nein </td><td>  Ja </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Tabelle sind die Eigenschaften der oben beschriebenen Labyrinthl√∂sungsalgorithmen kurz aufgef√ºhrt. </font><font style="vertical-align: inherit;">Nach diesen Kriterien ist es m√∂glich, Algorithmen zur L√∂sung von Labyrinthen zu klassifizieren und zu bewerten. </font><font style="vertical-align: inherit;">Spaltenerkl√§rungen:</font></font><br><br><ul><li> <b>:</b>       ,   .        .  ,  ()       . Dead end filler  cul-de-sac filler (  blind alley sealer     )   ,      ,        ,      ¬´+¬ª. </li><li> <b>:</b>        .  Random mouse  ¬´¬ª,      ,   wall follower     ¬´¬ª,       ,     .  dead end filler  cul-de-sac filler  ¬´¬ª,           . </li><li> <b>:</b>      :   ¬´¬ª (  )    .    ,       (   ¬´¬ª)    (¬´+¬ª)          .    ,          . </li><li> <b> :</b>        ,     ,     .   ,   ¬´¬ª,    ,    (  ),  ,   ,    ,     .            . </li><li> <b>  :</b>      .   ,       ,     ,     ,         . Wall follower,             . Recursive backtracker  shortest path(s) finder     . </li><li> <b>  :</b>         .                    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnell:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wird der Entscheidungsprozess als schnell angesehen? </font><font style="vertical-align: inherit;">Die effizientesten Algorithmen reichen aus, um jede Zelle des Labyrinths nur einmal zu betrachten, oder sie k√∂nnen Teile davon vollst√§ndig √ºberspringen. </font><font style="vertical-align: inherit;">Die Laufzeit sollte proportional zur Gr√∂√üe des Labyrinths oder O (n ^ 2) sein, wobei n die Anzahl der Zellen entlang einer Seite ist. </font><font style="vertical-align: inherit;">Zuf√§llige M√§use sind langsam, da ihre Fertigstellung nicht garantiert ist und der Sackgassenf√ºller m√∂glicherweise das Labyrinth von jeder Gabel l√∂st.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere Operationen mit Labyrinthen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neben dem Erstellen und L√∂sen von Labyrinthen k√∂nnen Sie mit ihnen auch andere Vorg√§nge ausf√ºhren: </font></font><br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br> :</b>  ¬´  ¬ª,      ,         Fill  FloodFill.  FloodFill   ,      ,     .  ,       ,  FloodFill  ,     .  ,      ,  FloodFill  ,      ,        .          ¬´¬ª    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br>    (Isolation remover):</b>    ,        ,        .   ,       .    ,     .   (   ,      )    ,    .         ,        ,      .         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br>  :</b>    ,            ,               .        ,      ,  .    ,    .   (   ,       )        .         ,    ,        ,     .                ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br> <b>  </b> <b>:</b>       ,       .   ,       ,    ,        ,    .  ,      ,   .       ,        .           ,    blind alley sealer (    ,            ).   ,    ,   . </li></ul><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Daedalus</b></a> <b>:</b>           Daedalus,       Windows.    Daedalus    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445378/">https://habr.com/ru/post/de445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445362/index.html">Das Buch "Distributed Systems. Entwurfsmuster</a></li>
<li><a href="../de445366/index.html">So beschleunigen Sie die Verschl√ºsselung gem√§√ü GOST 28147-89 auf dem Baikal-T1-Prozessor aufgrund des SIMD-Blocks</a></li>
<li><a href="../de445368/index.html">Laden Sie ein Spiel mit ein paar Hunderttausenden von virtuellen Benutzern</a></li>
<li><a href="../de445370/index.html">TSDB-Analyse in Prometheus 2</a></li>
<li><a href="../de445372/index.html">Bildverarbeitung vs. menschliche Intuition: Algorithmen zur Unterbrechung des Betriebs von Objekterkennungsprogrammen</a></li>
<li><a href="../de445380/index.html">Modernes PHP ist sch√∂n und produktiv</a></li>
<li><a href="../de445384/index.html">Chang'e-4 Mission - wissenschaftliche Ausr√ºstung auf dem Landemodul und dem Repeater-Satelliten</a></li>
<li><a href="../de445390/index.html">IDE einer normalen Person oder warum wir uns f√ºr Monaco entschieden haben</a></li>
<li><a href="../de445392/index.html">Dynamisches Remarketing von MyTarget: nicht pers√∂nliche Produktempfehlungen</a></li>
<li><a href="../de445394/index.html">√Ñnderungen des sicheren 3D-Protokolls: Erf√ºllen Sie 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>