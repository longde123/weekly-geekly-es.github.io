<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔧 🤦🏻 🙌 Buat shader air kartun untuk web. Bagian 1 🍧 👠 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam tutorial saya "Membuat Shaders", saya terutama melihat fragmen shaders, yang cukup untuk menerapkan efek 2D dan contoh di ShaderToy . Tetapi ada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat shader air kartun untuk web. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> Dalam tutorial saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Membuat Shaders",</a> saya terutama melihat fragmen shaders, yang cukup untuk menerapkan efek 2D dan contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">ShaderToy</a> .  Tetapi ada seluruh kategori teknik yang membutuhkan penggunaan vertex shaders.  Dalam tutorial ini, saya akan berbicara tentang membuat shader air kartun bergaya dan memperkenalkan Anda ke shader vertex.  Saya juga akan berbicara tentang penyangga kedalaman dan cara menggunakannya untuk mendapatkan informasi lebih lanjut tentang pemandangan dan untuk membuat garis busa laut. <br><br>  Beginilah efek akhirnya akan terlihat.  Demo interaktif dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Efek ini terdiri dari unsur-unsur berikut: <br><br><ol><li>  Jala air bening dengan poligon terbagi dan simpul offset untuk membuat gelombang. </li><li>  Garis air statis di permukaan. </li><li>  Simulasi daya apung perahu. </li><li>  Garis busa dinamis di sekitar batas benda di dalam air. </li><li>  Pasca pemrosesan untuk membuat distorsi dari segala sesuatu di bawah air </li></ol><br>  Dalam efek ini, saya menyukai kenyataan bahwa ia menyentuh banyak konsep berbeda dari grafik komputer, sehingga akan memungkinkan kita untuk menggunakan ide-ide dari tutorial sebelumnya, serta mengembangkan teknik yang dapat diterapkan dalam efek baru. <br><a name="habracut"></a><br>  Dalam tutorial ini, saya akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">PlayCanvas</a> , hanya karena itu adalah web-IDE gratis yang nyaman, tetapi semuanya dapat diterapkan ke lingkungan WebGL lainnya tanpa masalah.  Di akhir artikel, versi kode sumber untuk Three.js akan disajikan.  Kami akan menganggap bahwa Anda sudah berpengalaman dalam fragmen shader dan antarmuka PlayCanvas.  Anda dapat menyegarkan kembali pengetahuan Anda tentang shader di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan berkenalan dengan PlayCanvas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Pengaturan lingkungan </h2><br>  Tujuan dari bagian ini adalah untuk mengkonfigurasi proyek PlayCanvas kami dan memasukkan ke dalamnya beberapa objek lingkungan yang akan dipengaruhi oleh air. <br><br>  Jika Anda tidak memiliki akun PlayCanvas, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">daftarkan</a> dan buat <strong>proyek kosong</strong> baru.  Secara default, Anda harus memiliki beberapa objek dalam adegan, kamera dan sumber cahaya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Masukkan Model </h3><br>  Sumber yang bagus untuk menemukan model 3D untuk web adalah proyek Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">Poly</a> .  Saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">model kapal</a> dari sana.  Setelah mengunduh dan membongkar arsip, Anda akan menemukan file <code>.obj</code> dan <code>.png</code> di dalamnya. <br><br><ol><li>  Seret kedua file ke jendela Aset proyek PlayCanvas. </li><li>  Pilih bahan yang dihasilkan secara otomatis dan pilih file <code>.png</code> sebagai peta difusnya. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Sekarang Anda dapat menyeret <strong>Tugboat.json</strong> ke tempat kejadian dan menghapus objek Kotak dan Pesawat.  Jika kapal terlihat terlalu kecil, Anda dapat meningkatkan skalanya (saya menetapkan nilainya menjadi 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Demikian pula, Anda dapat menambahkan model lain ke TKP. <br><br><h3>  Mengorbit kamera </h3><br>  Untuk mengonfigurasi kamera yang terbang di orbit, kami akan menyalin skrip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">contoh PlayCanvas ini</a> .  Ikuti tautan dan klik <strong>Editor</strong> untuk membuka proyek. <br><br><ol><li>  Salin konten <code>mouse-input.js</code> dan <code>orbit-camera.js</code> dari proyek tutorial ini ke dalam file dengan nama yang sama dari proyek Anda. </li><li>  Tambahkan komponen <strong>Script</strong> ke kamera. </li><li>  Lampirkan dua skrip ke kamera. </li></ol><br><blockquote>  <em>Petunjuk: untuk mengatur proyek, Anda dapat membuat folder di jendela Aset.</em>  <em>Saya menempatkan dua skrip kamera ini dalam Skrip / Kamera / folder, model saya di Model /, dan materi dalam folder Bahan /.</em> </blockquote><br>  Sekarang ketika Anda memulai permainan (tombol peluncuran di bagian kanan atas jendela pemandangan) Anda akan melihat sebuah kapal yang dapat Anda periksa dengan kamera dengan menggerakkannya di orbit dengan mouse. <br><br><h2>  Divisi Polygon Permukaan Air </h2><br>  Tujuan dari bagian ini adalah untuk membuat mesh yang terbagi lagi yang akan digunakan sebagai permukaan air. <br><br>  Untuk membuat permukaan air, kami mengadaptasi bagian dari kode dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">tutorial generasi bantuan</a> .  Buat <code>Water.js</code> skrip <code>Water.js</code> baru.  Buka skrip ini untuk mengedit dan membuat fungsi <code>GeneratePlaneMesh</code> baru yang akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Sekarang kita dapat menyebutnya di fungsi <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Sekarang ketika Anda memulai permainan, Anda seharusnya hanya melihat permukaan datar.  Tapi ini bukan hanya permukaan datar, itu adalah jaring yang terdiri dari ribuan puncak.  Sebagai latihan, coba verifikasi ini sendiri (ini adalah alasan bagus untuk mempelajari kode yang baru saja disalin). <br><br><blockquote>  <em>Masalah 1: menggeser koordinat Y dari setiap simpul dengan nilai acak sehingga bidang terlihat seperti gambar di bawah ini.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Ombaknya </h2><br>  Tujuan dari bagian ini adalah untuk menentukan permukaan air dari bahan Anda sendiri dan membuat gelombang animasi. <br><br>  Untuk mendapatkan efek yang kami butuhkan, Anda perlu mengkonfigurasi materi Anda sendiri.  Sebagian besar mesin 3D memiliki seperangkat shader yang telah ditentukan sebelumnya untuk merender objek dan cara untuk mendefinisikannya.  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">tautan bagus</a> tentang cara melakukan ini di PlayCanvas. <br><br><h3>  Lampiran Shader </h3><br>  Mari kita membuat fungsi <code>CreateWaterMaterial</code> baru yang <code>CreateWaterMaterial</code> materi baru dengan shader yang diubah dan mengembalikannya: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Fungsi ini mengambil kode shader vertex dan fragmen dari atribut skrip.  Jadi mari kita mendefinisikannya di bagian atas file (setelah baris <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Sekarang kita dapat membuat file shader ini dan melampirkannya ke skrip kita.  Kembali ke editor dan buat dua file shader: <strong>Water.frag</strong> dan <strong>Water.vert</strong> .  Lampirkan shader ini ke skrip seperti yang ditunjukkan pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Jika atribut baru tidak ditampilkan di editor, maka klik tombol <strong>Parse</strong> untuk memperbarui skrip. <br><br>  Sekarang tempel shader dasar ini ke <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Dan yang ini ada di <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Akhirnya, kembalilah ke <strong>Water.js</strong> untuk menggunakan materi baru kami dan bukannya materi standar.  Artinya, alih-alih: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  masukkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Sekarang, setelah memulai permainan, pesawat seharusnya berwarna biru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Hot reboot </h3><br>  Untuk saat ini, kami hanya menyiapkan blanko shader untuk materi baru kami.  Sebelum saya mulai menulis efek nyata, saya ingin mengatur reload kode otomatis. <br><br>  Setelah membatalkan fungsi <code>swap</code> di file skrip apa pun (misalnya, di Water.js), kami akan mengaktifkan pemuatan ulang hot.  Nanti kita akan melihat bagaimana menggunakan ini untuk mempertahankan status bahkan ketika memperbarui kode secara real time.  Tapi untuk saat ini, kami hanya ingin menerapkan kembali shader setelah melakukan perubahan.  Sebelum berjalan di WebGL, shader dikompilasi, jadi untuk melakukan ini kita perlu membuat ulang materi kita. <br><br>  Kami akan memeriksa apakah konten kode shader kami telah berubah, dan jika demikian, buat materi lagi.  Pertama, simpan shader saat ini di <strong>inisialisasi</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Dan dalam <strong>pembaruan</strong> kami memeriksa apakah ada perubahan yang terjadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Sekarang, untuk memastikan ini berhasil, mulailah permainan dan ubah warna pesawat di <strong>Water.frag</strong> menjadi biru yang lebih menyenangkan.  Setelah menyimpan file, itu harus diperbarui bahkan tanpa reboot dan restart!  Ini warna yang saya pilih: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shaders </h4><br>  Untuk membuat gelombang, kita harus memindahkan setiap simpul mesh kita di setiap frame.  Tampaknya itu akan sangat tidak efisien, tetapi setiap simpul dari masing-masing model sudah ditransformasikan dalam setiap frame yang diberikan.  Inilah yang dilakukan vertex shader. <br><br>  Jika kita menganggap shader fragmen sebagai fungsi yang dieksekusi untuk setiap piksel, mendapatkan posisinya dan mengembalikan warna, maka <em>vertex shader adalah fungsi yang berjalan untuk setiap titik, mendapatkan posisinya dan mengembalikan posisinya</em> . <br><br>  Vertex shader secara default mendapatkan <em>posisi di dunia</em> model dan mengembalikan <em>posisinya di layar</em> .  Adegan 3D kami diatur dalam koordinat x, y dan z, tetapi monitor adalah bidang dua dimensi yang datar, jadi kami memproyeksikan dunia 3D ke layar 2D.  Matriks jenis, proyeksi dan model terlibat dalam proyeksi tersebut, oleh karena itu kami tidak akan mempertimbangkannya dalam tutorial ini.  Tetapi jika Anda ingin memahami apa yang sebenarnya terjadi pada setiap tahap, maka di sini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">panduan yang sangat bagus</a> . <br><br>  Yaitu, baris ini: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  menerima <code>aPosition</code> sebagai posisi di dunia 3D dari titik tertentu dan mengubahnya menjadi <code>gl_Position</code> , yaitu, ke posisi akhir di layar 2D.  Awalan "a" dalam posisi menunjukkan bahwa nilai ini adalah <em>atribut</em> .  Jangan lupa bahwa <em>seragam</em> variabel adalah nilai yang dapat kita definisikan di CPU dan meneruskannya ke shader.  Itu menyimpan nilai yang sama untuk semua piksel / simpul.  Di sisi lain, nilai atribut diperoleh dari <em>array</em> CPU yang ditentukan.  Vertex shader dipanggil untuk setiap nilai array atribut ini. <br><br>  Anda dapat melihat bahwa atribut ini dikonfigurasi dalam definisi shader yang kami atur di Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas mengatur dan mentransmisikan array posisi vertex untuk posisi saat melewati enumerasi ini, tetapi dalam kasus umum, kita dapat meneruskan array data apa pun ke vertex shader. <br><br><h3>  Gerakan verteks </h3><br>  Misalkan kita ingin mengompres seluruh bidang dengan mengalikan semua nilai <code>x</code> dengan 0,5.  Apakah kita perlu mengubah <code>aPosition</code> atau <code>gl_Position</code> ? <br><br>  Ayo coba <code>aPosition</code> dulu.  Kami tidak dapat mengubah atribut secara langsung, tetapi kami dapat membuat salinan: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Sekarang pesawat akan terlihat lebih seperti persegi panjang.  Dan tidak ada yang aneh tentang itu.  Tetapi apa yang terjadi jika kita mencoba mengubah <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Sampai Anda mulai menggerakkan kamera, mungkin terlihat sama.  Kami mengubah koordinat ruang layar, yaitu gambar akan tergantung pada <em>bagaimana kami melihatnya</em> . <br><br>  Jadi kita bisa memindahkan simpul, dan pada saat yang sama penting untuk membedakan antara pekerjaan di dunia dan ruang layar. <br><br><blockquote>  <em>Tugas 2: dapatkah Anda memindahkan seluruh permukaan pesawat beberapa unit ke atas (sepanjang sumbu Y) di vertex shader tanpa mengubah bentuknya?</em> </blockquote><br><blockquote>  <em>Tugas 3: Saya mengatakan bahwa gl_Position adalah dua dimensi, tetapi gl_Position.z juga ada.</em>  <em>Bisakah Anda memeriksa untuk melihat apakah nilai ini mempengaruhi sesuatu, dan jika demikian, untuk apa ini digunakan?</em> </blockquote><br><h3>  Menambah waktu </h3><br>  Hal terakhir yang kita butuhkan sebelum mulai membuat gelombang bergerak adalah variabel seragam yang dapat digunakan sebagai waktu.  Nyatakan seragam dalam vertex shader: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Sekarang, untuk meneruskannya ke shader, <strong>mari</strong> kembali ke <strong>Water.js</strong> dan tentukan variabel waktu dalam inisialisasi: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Sekarang, untuk mentransfer variabel ke shader, kami menggunakan <code>material.setParameter</code> .  Pertama, kami menetapkan nilai awal di akhir fungsi <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Sekarang, dalam fungsi <code>update</code> , kita dapat melakukan penambahan waktu dan mengakses materi menggunakan tautan yang dibuat untuk ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Akhirnya, dalam fungsi swap, kami menyalin nilai waktu lama sehingga bahkan setelah mengubah kode, itu terus meningkat tanpa mengatur ulang ke 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Sekarang semuanya sudah siap.  Jalankan game untuk memastikan tidak ada kesalahan.  Sekarang mari kita pindahkan pesawat kita menggunakan fungsi waktu di <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  Dan pesawat kita harus mulai bergerak naik dan turun!  Karena kita sekarang memiliki fungsi swap, kita juga dapat memperbarui Water.js tanpa harus memulai ulang.  Untuk memastikan ini berhasil, coba ubah kenaikan waktu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Tugas 4: bisakah Anda memindahkan simpul sehingga terlihat seperti gelombang pada gambar di bawah ini?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Izinkan saya memberi tahu Anda bahwa saya memeriksa secara rinci topik berbagai cara menciptakan gelombang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> .  Artikel ini terkait dengan 2D, tetapi perhitungan matematis berlaku untuk kasus kami.  Jika Anda hanya ingin melihat solusinya, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">inilah intinya</a> . <br><br><h2>  Tembus cahaya </h2><br>  Tujuan dari bagian ini adalah untuk membuat permukaan air yang tembus cahaya. <br><br>  Anda mungkin memperhatikan bahwa warna yang dikembalikan ke Water.frag memiliki nilai kanal alfa 0,5, tetapi permukaannya tetap buram.  Dalam banyak kasus, transparansi masih menjadi masalah yang tidak terselesaikan dalam grafik komputer.  Cara murah untuk mengatasinya adalah dengan menggunakan pencampuran. <br><br>  Biasanya, sebelum menggambar piksel, ia memeriksa nilai dalam <em>buffer kedalaman</em> dan membandingkannya dengan nilai kedalamannya sendiri (posisinya di sepanjang sumbu Z) untuk menentukan apakah akan menggambar ulang piksel layar saat ini atau tidak.  Inilah yang memungkinkan Anda untuk membuat adegan dengan benar tanpa harus menyortir objek kembali ke depan. <br><br>  Saat mencampur, alih-alih sekadar menolak piksel atau menimpa, kita dapat menggabungkan warna piksel (target) yang sudah dirender dengan piksel yang akan kita gambar (sumber).  Daftar semua fungsi pencampuran yang tersedia di WebGL dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> . <br><br>  Agar saluran alfa bekerja sesuai dengan harapan kami, kami ingin warna hasil gabungan menjadi sumber yang dikalikan dengan saluran alfa ditambah piksel tujuan dikalikan dengan satu alfa dikurangi.  Dengan kata lain, jika alpha = 0,4, maka warna akhir harus memiliki nilai: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  Di PlayCanvas, ini adalah operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">pc.BLEND_NORMAL melakukan</a> . <br><br>  Untuk mengaktifkannya, cukup setel properti material di dalam <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Jika Anda sekarang memulai permainan, maka air akan menjadi tembus!  Namun, itu masih belum sempurna.  Masalah muncul ketika permukaan bening ditumpangkan pada dirinya sendiri, seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Kita bisa menghilangkannya dengan menggunakan <em>alpha to coverage</em> , teknik multisampling untuk transparansi, alih-alih memadukan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Tetapi ini hanya tersedia di WebGL 2. Dalam tutorial selanjutnya, demi kesederhanaan, saya akan menggunakan pencampuran. <br><br><h2>  Untuk meringkas </h2><br>  Kami mengatur lingkungan dan menciptakan permukaan air yang tembus cahaya dengan gelombang animasi dari vertex shader.  Di bagian kedua tutorial, kita akan mempertimbangkan daya apung benda, menambahkan garis ke permukaan air dan membuat garis busa di sepanjang batas benda yang bersinggungan dengan permukaan. <br><br>  Pada bagian ketiga (terakhir), kami akan mempertimbangkan penerapan efek pasca pemrosesan dari distorsi bawah air dan mempertimbangkan gagasan untuk perbaikan lebih lanjut. <br><br><h2>  Kode sumber </h2><br>  Proyek PlayCanvas yang sudah selesai dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> .  Repositori kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">port proyek di bawah Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416953/">https://habr.com/ru/post/id416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416943/index.html">Bahan yang berguna untuk merancang antarmuka suara</a></li>
<li><a href="../id416945/index.html">Seperti yang kami lakukan BelAZ. Bagian 1 - Setrika</a></li>
<li><a href="../id416947/index.html">Mainkan game sebelum Olimpiade: eSports menjadi resmi</a></li>
<li><a href="../id416949/index.html">Peningkatan skala besar Mr. Steven untuk menginstal jaringan perburuan empat kali lipat lebih besar telah selesai</a></li>
<li><a href="../id416951/index.html">Cluster Kubernetes dalam layanan VPC</a></li>
<li><a href="../id416955/index.html">Trik kecil dengan Elasticsearch</a></li>
<li><a href="../id416957/index.html">Mesin laser mana yang harus dibeli? Ulasan Mesin Laser Raylogic 11G yang Andal</a></li>
<li><a href="../id416959/index.html">Apple Memperkenalkan Fitur Anti-Pencurian iOS Baru</a></li>
<li><a href="../id416961/index.html">Resolusi konflik otomatis menggunakan transformasi operasional</a></li>
<li><a href="../id416967/index.html">Seperti yang kami lakukan BelAZ. Bagian 3 - commissioning bagian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>