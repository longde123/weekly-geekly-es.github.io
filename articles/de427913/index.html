<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚗️ 🕺 🍙 Unterhaltsamer Prolog Nr. 2 👱🏿 💼 🧘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, Community von Entwicklern , ich muss den Job beenden. 


 In meinem vorherigen Werk gab es einen Aufruf, um zu zeigen, wie die Prolog-Sprache v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterhaltsamer Prolog Nr. 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427913/"><p>  Hallo, <em>Community von Entwicklern</em> , ich muss den Job beenden. </p><br><p>  In meinem vorherigen Werk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab</a> es einen Aufruf, um zu zeigen, wie die Prolog-Sprache verwendet werden kann, und um zu zeigen, dass es lustig wäre.  Machen Sie daraus eine Übung. </p><br><p>  Ich werde versuchen weiterzumachen <del>  vorführen </del>  zu demonstrieren. </p><br><p>  Ich erinnere mich kurz an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabe:</a> </p><br><div class="spoiler">  <b class="spoiler_title">Wildcard-Matching</b> <div class="spoiler_text"><p>  Implementieren Sie anhand einer Eingabezeichenfolge (n) und eines Musters (p) einen Platzhaltermusterabgleich mit Unterstützung für '?'  und ' <em>'.</em> <em><br></em>  <em>'?'</em>  <em>Entspricht einem einzelnen Zeichen.</em> <em><br></em>  <em>'</em> ' Entspricht einer beliebigen Zeichenfolge (einschließlich der leeren Folge). <br>  Der Abgleich sollte die gesamte Eingabezeichenfolge abdecken (nicht teilweise). </p></div></div><br><p>  Die Vollständigkeit der Lösung konnte nicht nachgewiesen werden.  Auf der Site, die die Aufgabe bereitstellt, gibt es 1808 Tests, die nicht sofort angezeigt werden. Sie müssen ein Programm schreiben und einen weiteren Test als Fehler erhalten. </p><br><p>  Hardcore, ich habe 66 von ihm bekommen und meine Entscheidung überprüft - während alles funktioniert hat.  Aber so einfach kann es nicht sein. </p><br><p>  Warum so viele Tests gemacht habe, möchte ich weiter prüfen ... </p><br><p>  Ich werde versuchen, diese Lösung in der Sprache umzuschreiben <del>  verständlich </del>  in diesem System verfügbar (sie spiegeln die Popularität moderner Programmiersprachen wider). </p><br><p>  Wählen Sie also Python. </p><a name="habracut"></a><br><p>  Die Kraft von Prolog liegt im Suchverfahren, dessen Wurzeln in den Methoden zum Beweis von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theoremen liegen</a> .  Einfach ausgedrückt, verfügt es über einen integrierten Vereinigungs- und Suchmechanismus mit Rückgabe.  Es ist noch einfacher zu sagen, Matching plus Tiefensuche im Entscheidungsbaum. </p><br><p>  Und Python ist modernes Pascal (es gibt bereits drei Sprachen mit dem Buchstaben "P"), und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schüler können</a> Programme darauf schreiben. </p><br><p>  Jetzt werde ich die in der vorherigen Implementierung festgelegte Lösung neu schreiben und schnell eine ähnliche Prologsuche mit einer Rückgabe implementieren. </p><br><p>  Als nächstes werde ich es im Testsystem starten und sehen, ob die Verschiebung (Code) korrekt war. </p><br><h1 id="prisoedinyaytes">  Jetzt mitmachen. </h1><br><p>  Am Eingang die getestete Zeichenfolge und das getestete Muster: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat==<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Es scheint der Prolog-Implementierung sehr ähnlich zu sein: </p><br><pre> <code class="hljs powershell">test_pattrn([],[]). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). test_pattrn(Str,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(Str,PatTail).</code> </pre><br><p>  Fünf Lösungen, sonst eine Lüge. </p><br><p>  Aber wie mache ich eine Rückgabesuche? Dafür verwende ich Yield, wie es dort genannt wird, unvollständige (faule) Berechnungen, Abschluss, ein Element des funktionalen Ansatzes, sag mir ... Es wird etwas zurückgeben, von dem es möglich sein wird, die folgende Lösung zu holen, aber wenn es Wenn dies nicht zur richtigen Antwort führt, gehen wir mit der nächsten Ausbeute zum Programmzweig. Dies ist der Unterschied zur Rendite. </p><br><p>  Diese Funktion akzeptiert das Ergebnis des ersten Tests (), wenn es wahr ist, dann ist alles in Ordnung, andernfalls versucht sie erneut zu iterieren, und es wird eine Tiefensuche durchgeführt, die dem Verhalten der Prologausgabe ähnelt. </p><br><p>  Hier ist hier ausdrücklich eine Rückgabe erforderlich: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(r)==bool: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r==<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> run(nr):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br><h1 id="proveryaem-1">  Überprüfen Sie 1 </h1><br><p><img src="https://habrastorage.org/webt/b_/bd/qy/b_bdqy_ehypljwck0ihcbarfwhc.png"></p><br><p>  Wow, das ist das Ergebnis: "939/1808 Testfälle bestanden."  und "Status: Zeitlimit überschritten". <br>  Genau das habe ich erwartet, eine deklarative Lösung führt nicht immer zu einer zeiteffizienten Implementierung.  Transparente Formulierungen sind keine schnellen Formulierungen. </p><br><p>  Aber hier ist das Ergebnis der Python, wir werden den geöffneten Test in der Implementierung ab dem ersten Artikel testen und die Zeit messen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(run(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>))) print(time.time()-pt)</code> </pre> <br><p>  Die Ausführungszeit für Python beträgt 11.10963249206543 Sek., Aber etwas zu viel. </p><br><p>  Erweiterte Test-Engine für Prolog: </p><br><pre> <code class="hljs ruby">%unit-tests framework assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-get_time</span></span>(St),<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Goal),!,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> get_time(St),Goal, !,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, Exp)<span class="hljs-symbol"><span class="hljs-symbol">:-writeln</span></span>(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">failed:</span></span>expected-Exp). <span class="hljs-symbol"><span class="hljs-symbol">:-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-literal"><span class="hljs-literal">true</span></span>).</code> </pre><br><p>  Und hier ist das Ergebnis des Prologs (beginnend nicht im Online-Editor, lokal, auf derselben Hardware wie die vorherige): </p><br><pre> <code class="hljs markdown">isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-emphasis"><span class="hljs-emphasis">*ab*</span></span><span class="hljs-strong"><span class="hljs-strong">**ba**</span></span>b<span class="hljs-emphasis"><span class="hljs-emphasis">*b*</span></span>aaab*b)-&gt;ok:2.208951950073242/sec</code> </pre> <br><p>  Es sieht so aus, als würde ich Python nicht gut verwenden ((ich muss es verbessern, es ist nicht mehr so ​​offensichtlich: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>)) print(time.time()-pt)</code> </pre> <br><p>  Hier ist das Ergebnis: 3.921879768371582 Sek.  (Dies ist näher am Original).  Wir kehren zum Schiedsrichter zurück: </p><br><p><img src="https://habrastorage.org/webt/js/sj/q2/jssjq2qynkpuiuxxhgkauok69e8.png"></p><br><p>  Und noch einmal. </p><br><p><img src="https://habrastorage.org/webt/ak/fa/cs/akfacs0zye38rbwjujdmtprshru.png"></p><br><p>  Ich komme zu dem Schluss, dass der gesamte Testdurchgang über den Zeitrahmen hinausgeht, da die letzten beiden Optionen sehr schnell gelöst werden. </p><br><p>  Wir brauchen eine Größenordnungsoptimierung. </p><br><h1 id="proveryaem-2-nuzhna-optimizaciya">  Check 2. Wir brauchen Optimierung. </h1><br><p>  Was sicher bittet, ist die Breitensuche. </p><br><p>  Setzen Sie die Entscheidung jedes Zweigs nicht fort, bis wir eine Lüge erhalten und zu einem anderen Zweig zurückkehren, sondern betrachten Sie die Entscheidungen nach Ebenen, gehen Sie für jede Option gleichzeitig nach unten und gehen Sie schrittweise weiter. </p><br><p>  Ich werde versuchen, daraus eine Python zu machen, und dann werde ich den Prolog demonstrieren. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> res=[] <span class="hljs-comment"><span class="hljs-comment">#     ,    if pat&gt;"" and pat[0]=='*':res+=[(st,pat[1:])] if st&gt;"" and pat&gt;"": stt=st[1:] if st[0]==pat[0] or pat[0]=='?':res+=[(stt,pat[1:])] if pat[0]=='*':res+=[(stt,pat)] return res def run(st,pat): lev=[(st,pat)] while len(lev)!=0: nxt=set() ##        for s,p in lev: one=test(s,p) if one==True:return True else:nxt.update(set(one)) lev=nxt return False</span></span></code> </pre><br><p>  Es gibt bereits das Ergebnis für den Test 939, nur 0,01585698127746582 Sek. <br>  und ... URA diese Entscheidung wird getroffen </p><br><p><img src="https://habrastorage.org/webt/uk/cl/tg/ukcltg11trpklqys9xew7kiqou8.png"></p><br><h1 id="prolog">  Prolog </h1><br><p>  Ich werde versuchen zu zeigen, wie eine Breitensuche in einer deklarativen Implementierung implementiert wird.  Zu diesem Zweck gibt es spezielle Prädikate zweiter Ordnung, die Lösungen in einer Liste sammeln können, z. B. bagof, setof, findall. </p><br><blockquote>  bagof (+ Vorlage,: Ziel, -Tasche) <br>  Vereinheitlichen Sie die Tasche mit den Alternativen der Vorlage.  Wenn Goal neben der mit Template freigegebenen Variablen auch freie Variablen hat, wird bagof / 3 die Alternativen dieser freien Variablen zurückverfolgen und Bag mit den entsprechenden Alternativen von Template vereinheitlichen.  Das Konstrukt + Var ^ Goal weist bagof / 3 an, Var in Goal nicht zu binden.  bagof / 3 schlägt fehl, wenn Goal keine Lösungen hat. <br>  setof (+ Vorlage, + Ziel, -Set) <br>  Entspricht bagof / 3, sortiert das Ergebnis jedoch mit sort / 2, um eine sortierte Liste von Alternativen ohne Duplikate zu erhalten. </blockquote><p>  Setof Prädikat funktioniert seitdem gut  Er weiß bereits, wie man Duplikate entfernt (in Python musste ich etwas über Sets lernen). </p><br><p>  Also erstelle ich ein Prädikat, das eine Lösung auf einer Ebene erhält, sammle es dann mit einem anderen Prädikat und gehe tiefer. Hier ist die vollständige Lösung: </p><br><pre> <code class="hljs powershell">atom_to_list(Str,[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">T</span></span>]) :- atom_concat(Ch,Rest,Str),atom_length(Ch,<span class="hljs-number"><span class="hljs-number">1</span></span>), atom_to_list(Rest,T). %  pattrn(X:X,true). %-      pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). pattrn(Str:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],Str:PatTail). %  true,     ,     next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-member</span></span>(true,Lev),!. next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-setof</span></span>(One,SP^(member(SP,Lev),pattrn(SP,One)),Next),!, next_level(Next). test_pattrn(Str,Pat):<span class="hljs-literal"><span class="hljs-literal">-next_level</span></span>([<span class="hljs-type"><span class="hljs-type">Str</span></span>:<span class="hljs-type"><span class="hljs-type">Pat</span></span>]). isMatch(S,P) :- atom_to_list(S,SL), atom_to_list(P,PL),!, test_pattrn(SL,PL),!. %unit<span class="hljs-literal"><span class="hljs-literal">-tests</span></span> framework assert_are_equal(Goal, false):<span class="hljs-literal"><span class="hljs-literal">-get_time</span></span>(St),not(Goal),!,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, true):- get_time(St),Goal, !,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, Exp):<span class="hljs-literal"><span class="hljs-literal">-writeln</span></span>(Goal-&gt;failed:expected<span class="hljs-literal"><span class="hljs-literal">-Exp</span></span>). %all test :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,a),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,<span class="hljs-string"><span class="hljs-string">'*'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(cb,<span class="hljs-string"><span class="hljs-string">'?a'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(adceb,<span class="hljs-string"><span class="hljs-string">'*a*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(acdcb,<span class="hljs-string"><span class="hljs-string">'a*c?b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aab,<span class="hljs-string"><span class="hljs-string">'c*a*b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(mississippi,<span class="hljs-string"><span class="hljs-string">'m??*ss*?i*pi'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abefcdgiescdfimde,<span class="hljs-string"><span class="hljs-string">'ab*cd?i*de'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(zacabz,<span class="hljs-string"><span class="hljs-string">'*a?b*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(leetcode,<span class="hljs-string"><span class="hljs-string">'*e*t?d*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaaa,<span class="hljs-string"><span class="hljs-string">'***a'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(b,<span class="hljs-string"><span class="hljs-string">'*?*?*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abbbbbbbaabbabaabaa,<span class="hljs-string"><span class="hljs-string">'*****a*ab'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab,<span class="hljs-string"><span class="hljs-string">'***bba**a*bbba**aab**b'</span></span>),false).</code> </pre> <br><p>  Hier können Sie sehen, dass die Regel, die zuvor die Suche nach der Vorlage durchgeführt hat, als ob sie einen Übergang entlang der Fläche im Diagramm vorgenommen hätte, jetzt zu einer Reihe von Faktenmustern geworden ist, die mögliche Übergänge (Beziehungen zwischen Zuständen) enthalten. Dies ist eine Beschreibung des Diagramms und kein Code, der sie implementiert. </p><br><p>  Und die Ausführung ergibt sich mit der Zeit in Sekunden: </p><br><pre> <code class="hljs erlang-repl">isMatch(aa, a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00010013580322265625</span></span>/sec isMatch(aa, *)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(cb, ?a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">3.981590270996094e-5</span></span>/sec isMatch(adceb, *a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0001399517059326172</span></span>/sec isMatch(acdcb, a*c?b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(aab, c*a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(mississippi, m??*ss*?i*pi)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003399848937988281</span></span>/sec isMatch(abefcdgiescdfimde, ab*cd?i*de)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003600120544433594</span></span>/sec isMatch(zacabz, *a?b*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(leetcode, *e*t?d*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00020003318786621094</span></span>/sec isMatch(aaaa, ***a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(b, *?*?*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">6.008148193359375e-5</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0040400028228759766</span></span>/sec isMatch(abbbbbbbaabbabaabaa, *****a*ab)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0006201267242431641</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.003679990768432617</span></span>/sec isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab, ***bba**a*bbba**aab**b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.002460002899169922</span></span>/sec</code> </pre> <br><p>  Und dies ist bereits eine erfolgreiche Lösung, nicht nur logisch, sondern auch rechtzeitig. </p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  In einem früheren Artikel wollte ich Interesse am Thema eines deklarativen Ansatzes sehen.  Das Thema "niasilil solch ein Ansatz" wurde sofort eröffnet, aber das Interesse kann immer noch gezeigt werden.  Hier habe ich gezeigt, dass es ein Leistungsproblem gibt, was klar geschrieben steht, funktioniert nicht schnell.  Versuche, einen parallelen Prolog zu erstellen, waren erfolglos.  Vielleicht ist hier die Frage der Zukunft, kann ein Quantencomputer? <br>  Insgesamt verwenden wir Rätsel auf der oben genannten Seite für einen angenehmen Zeitvertreib mit Bedacht. </p><br><p>  Nun, beim nächsten Mal wird versucht, eine weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwierige Aufgabe</a> sofort effektiv zu lösen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427913/">https://habr.com/ru/post/de427913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427901/index.html">So verwenden Sie die Node.js Stream-API nicht</a></li>
<li><a href="../de427905/index.html">Food Mining oder Crossroads mit den Augen eines Hackers</a></li>
<li><a href="../de427907/index.html">Drohnenschießen, Rechen, Life Hacks, Selbstentwicklung und Karriere eines Fotografen / Videografen: neuer GLPH-Podcast</a></li>
<li><a href="../de427909/index.html">Python: Wie kann der Speicherverbrauch um die Hälfte reduziert werden, indem nur eine Codezeile hinzugefügt wird?</a></li>
<li><a href="../de427911/index.html">Büro Leidenschaften</a></li>
<li><a href="../de427915/index.html">Vermutung der Dummheit</a></li>
<li><a href="../de427917/index.html">Antwort auf den Beitrag "Vermutung des Geistes"</a></li>
<li><a href="../de427919/index.html">COM auf Linux portieren</a></li>
<li><a href="../de427921/index.html">4 Videos über Aufschub</a></li>
<li><a href="../de427923/index.html">Wie ich dem SmartThings Hub ein neues Gerät hinzugefügt habe, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>