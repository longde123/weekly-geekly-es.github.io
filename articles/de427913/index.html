<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öóÔ∏è üï∫ üçô Unterhaltsamer Prolog Nr. 2 üë±üèø üíº üßò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, Community von Entwicklern , ich muss den Job beenden. 


 In meinem vorherigen Werk gab es einen Aufruf, um zu zeigen, wie die Prolog-Sprache v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterhaltsamer Prolog Nr. 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427913/"><p>  Hallo, <em>Community von Entwicklern</em> , ich muss den Job beenden. </p><br><p>  In meinem vorherigen Werk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab</a> es einen Aufruf, um zu zeigen, wie die Prolog-Sprache verwendet werden kann, und um zu zeigen, dass es lustig w√§re.  Machen Sie daraus eine √úbung. </p><br><p>  Ich werde versuchen weiterzumachen <del>  vorf√ºhren </del>  zu demonstrieren. </p><br><p>  Ich erinnere mich kurz an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabe:</a> </p><br><div class="spoiler">  <b class="spoiler_title">Wildcard-Matching</b> <div class="spoiler_text"><p>  Implementieren Sie anhand einer Eingabezeichenfolge (n) und eines Musters (p) einen Platzhaltermusterabgleich mit Unterst√ºtzung f√ºr '?'  und ' <em>'.</em> <em><br></em>  <em>'?'</em>  <em>Entspricht einem einzelnen Zeichen.</em> <em><br></em>  <em>'</em> ' Entspricht einer beliebigen Zeichenfolge (einschlie√ülich der leeren Folge). <br>  Der Abgleich sollte die gesamte Eingabezeichenfolge abdecken (nicht teilweise). </p></div></div><br><p>  Die Vollst√§ndigkeit der L√∂sung konnte nicht nachgewiesen werden.  Auf der Site, die die Aufgabe bereitstellt, gibt es 1808 Tests, die nicht sofort angezeigt werden. Sie m√ºssen ein Programm schreiben und einen weiteren Test als Fehler erhalten. </p><br><p>  Hardcore, ich habe 66 von ihm bekommen und meine Entscheidung √ºberpr√ºft - w√§hrend alles funktioniert hat.  Aber so einfach kann es nicht sein. </p><br><p>  Warum so viele Tests gemacht habe, m√∂chte ich weiter pr√ºfen ... </p><br><p>  Ich werde versuchen, diese L√∂sung in der Sprache umzuschreiben <del>  verst√§ndlich </del>  in diesem System verf√ºgbar (sie spiegeln die Popularit√§t moderner Programmiersprachen wider). </p><br><p>  W√§hlen Sie also Python. </p><a name="habracut"></a><br><p>  Die Kraft von Prolog liegt im Suchverfahren, dessen Wurzeln in den Methoden zum Beweis von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theoremen liegen</a> .  Einfach ausgedr√ºckt, verf√ºgt es √ºber einen integrierten Vereinigungs- und Suchmechanismus mit R√ºckgabe.  Es ist noch einfacher zu sagen, Matching plus Tiefensuche im Entscheidungsbaum. </p><br><p>  Und Python ist modernes Pascal (es gibt bereits drei Sprachen mit dem Buchstaben "P"), und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sch√ºler k√∂nnen</a> Programme darauf schreiben. </p><br><p>  Jetzt werde ich die in der vorherigen Implementierung festgelegte L√∂sung neu schreiben und schnell eine √§hnliche Prologsuche mit einer R√ºckgabe implementieren. </p><br><p>  Als n√§chstes werde ich es im Testsystem starten und sehen, ob die Verschiebung (Code) korrekt war. </p><br><h1 id="prisoedinyaytes">  Jetzt mitmachen. </h1><br><p>  Am Eingang die getestete Zeichenfolge und das getestete Muster: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat==<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Es scheint der Prolog-Implementierung sehr √§hnlich zu sein: </p><br><pre> <code class="hljs powershell">test_pattrn([],[]). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). test_pattrn(Str,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(Str,PatTail).</code> </pre><br><p>  F√ºnf L√∂sungen, sonst eine L√ºge. </p><br><p>  Aber wie mache ich eine R√ºckgabesuche? Daf√ºr verwende ich Yield, wie es dort genannt wird, unvollst√§ndige (faule) Berechnungen, Abschluss, ein Element des funktionalen Ansatzes, sag mir ... Es wird etwas zur√ºckgeben, von dem es m√∂glich sein wird, die folgende L√∂sung zu holen, aber wenn es Wenn dies nicht zur richtigen Antwort f√ºhrt, gehen wir mit der n√§chsten Ausbeute zum Programmzweig. Dies ist der Unterschied zur Rendite. </p><br><p>  Diese Funktion akzeptiert das Ergebnis des ersten Tests (), wenn es wahr ist, dann ist alles in Ordnung, andernfalls versucht sie erneut zu iterieren, und es wird eine Tiefensuche durchgef√ºhrt, die dem Verhalten der Prologausgabe √§hnelt. </p><br><p>  Hier ist hier ausdr√ºcklich eine R√ºckgabe erforderlich: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(r)==bool: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r==<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> run(nr):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br><h1 id="proveryaem-1">  √úberpr√ºfen Sie 1 </h1><br><p><img src="https://habrastorage.org/webt/b_/bd/qy/b_bdqy_ehypljwck0ihcbarfwhc.png"></p><br><p>  Wow, das ist das Ergebnis: "939/1808 Testf√§lle bestanden."  und "Status: Zeitlimit √ºberschritten". <br>  Genau das habe ich erwartet, eine deklarative L√∂sung f√ºhrt nicht immer zu einer zeiteffizienten Implementierung.  Transparente Formulierungen sind keine schnellen Formulierungen. </p><br><p>  Aber hier ist das Ergebnis der Python, wir werden den ge√∂ffneten Test in der Implementierung ab dem ersten Artikel testen und die Zeit messen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(run(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>))) print(time.time()-pt)</code> </pre> <br><p>  Die Ausf√ºhrungszeit f√ºr Python betr√§gt 11.10963249206543 Sek., Aber etwas zu viel. </p><br><p>  Erweiterte Test-Engine f√ºr Prolog: </p><br><pre> <code class="hljs ruby">%unit-tests framework assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-get_time</span></span>(St),<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Goal),!,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> get_time(St),Goal, !,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, Exp)<span class="hljs-symbol"><span class="hljs-symbol">:-writeln</span></span>(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">failed:</span></span>expected-Exp). <span class="hljs-symbol"><span class="hljs-symbol">:-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-literal"><span class="hljs-literal">true</span></span>).</code> </pre><br><p>  Und hier ist das Ergebnis des Prologs (beginnend nicht im Online-Editor, lokal, auf derselben Hardware wie die vorherige): </p><br><pre> <code class="hljs markdown">isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-emphasis"><span class="hljs-emphasis">*ab*</span></span><span class="hljs-strong"><span class="hljs-strong">**ba**</span></span>b<span class="hljs-emphasis"><span class="hljs-emphasis">*b*</span></span>aaab*b)-&gt;ok:2.208951950073242/sec</code> </pre> <br><p>  Es sieht so aus, als w√ºrde ich Python nicht gut verwenden ((ich muss es verbessern, es ist nicht mehr so ‚Äã‚Äãoffensichtlich: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>)) print(time.time()-pt)</code> </pre> <br><p>  Hier ist das Ergebnis: 3.921879768371582 Sek.  (Dies ist n√§her am Original).  Wir kehren zum Schiedsrichter zur√ºck: </p><br><p><img src="https://habrastorage.org/webt/js/sj/q2/jssjq2qynkpuiuxxhgkauok69e8.png"></p><br><p>  Und noch einmal. </p><br><p><img src="https://habrastorage.org/webt/ak/fa/cs/akfacs0zye38rbwjujdmtprshru.png"></p><br><p>  Ich komme zu dem Schluss, dass der gesamte Testdurchgang √ºber den Zeitrahmen hinausgeht, da die letzten beiden Optionen sehr schnell gel√∂st werden. </p><br><p>  Wir brauchen eine Gr√∂√üenordnungsoptimierung. </p><br><h1 id="proveryaem-2-nuzhna-optimizaciya">  Check 2. Wir brauchen Optimierung. </h1><br><p>  Was sicher bittet, ist die Breitensuche. </p><br><p>  Setzen Sie die Entscheidung jedes Zweigs nicht fort, bis wir eine L√ºge erhalten und zu einem anderen Zweig zur√ºckkehren, sondern betrachten Sie die Entscheidungen nach Ebenen, gehen Sie f√ºr jede Option gleichzeitig nach unten und gehen Sie schrittweise weiter. </p><br><p>  Ich werde versuchen, daraus eine Python zu machen, und dann werde ich den Prolog demonstrieren. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> res=[] <span class="hljs-comment"><span class="hljs-comment">#     ,    if pat&gt;"" and pat[0]=='*':res+=[(st,pat[1:])] if st&gt;"" and pat&gt;"": stt=st[1:] if st[0]==pat[0] or pat[0]=='?':res+=[(stt,pat[1:])] if pat[0]=='*':res+=[(stt,pat)] return res def run(st,pat): lev=[(st,pat)] while len(lev)!=0: nxt=set() ##        for s,p in lev: one=test(s,p) if one==True:return True else:nxt.update(set(one)) lev=nxt return False</span></span></code> </pre><br><p>  Es gibt bereits das Ergebnis f√ºr den Test 939, nur 0,01585698127746582 Sek. <br>  und ... URA diese Entscheidung wird getroffen </p><br><p><img src="https://habrastorage.org/webt/uk/cl/tg/ukcltg11trpklqys9xew7kiqou8.png"></p><br><h1 id="prolog">  Prolog </h1><br><p>  Ich werde versuchen zu zeigen, wie eine Breitensuche in einer deklarativen Implementierung implementiert wird.  Zu diesem Zweck gibt es spezielle Pr√§dikate zweiter Ordnung, die L√∂sungen in einer Liste sammeln k√∂nnen, z. B. bagof, setof, findall. </p><br><blockquote>  bagof (+ Vorlage,: Ziel, -Tasche) <br>  Vereinheitlichen Sie die Tasche mit den Alternativen der Vorlage.  Wenn Goal neben der mit Template freigegebenen Variablen auch freie Variablen hat, wird bagof / 3 die Alternativen dieser freien Variablen zur√ºckverfolgen und Bag mit den entsprechenden Alternativen von Template vereinheitlichen.  Das Konstrukt + Var ^ Goal weist bagof / 3 an, Var in Goal nicht zu binden.  bagof / 3 schl√§gt fehl, wenn Goal keine L√∂sungen hat. <br>  setof (+ Vorlage, + Ziel, -Set) <br>  Entspricht bagof / 3, sortiert das Ergebnis jedoch mit sort / 2, um eine sortierte Liste von Alternativen ohne Duplikate zu erhalten. </blockquote><p>  Setof Pr√§dikat funktioniert seitdem gut  Er wei√ü bereits, wie man Duplikate entfernt (in Python musste ich etwas √ºber Sets lernen). </p><br><p>  Also erstelle ich ein Pr√§dikat, das eine L√∂sung auf einer Ebene erh√§lt, sammle es dann mit einem anderen Pr√§dikat und gehe tiefer. Hier ist die vollst√§ndige L√∂sung: </p><br><pre> <code class="hljs powershell">atom_to_list(Str,[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">T</span></span>]) :- atom_concat(Ch,Rest,Str),atom_length(Ch,<span class="hljs-number"><span class="hljs-number">1</span></span>), atom_to_list(Rest,T). %  pattrn(X:X,true). %-      pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). pattrn(Str:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],Str:PatTail). %  true,     ,     next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-member</span></span>(true,Lev),!. next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-setof</span></span>(One,SP^(member(SP,Lev),pattrn(SP,One)),Next),!, next_level(Next). test_pattrn(Str,Pat):<span class="hljs-literal"><span class="hljs-literal">-next_level</span></span>([<span class="hljs-type"><span class="hljs-type">Str</span></span>:<span class="hljs-type"><span class="hljs-type">Pat</span></span>]). isMatch(S,P) :- atom_to_list(S,SL), atom_to_list(P,PL),!, test_pattrn(SL,PL),!. %unit<span class="hljs-literal"><span class="hljs-literal">-tests</span></span> framework assert_are_equal(Goal, false):<span class="hljs-literal"><span class="hljs-literal">-get_time</span></span>(St),not(Goal),!,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, true):- get_time(St),Goal, !,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, Exp):<span class="hljs-literal"><span class="hljs-literal">-writeln</span></span>(Goal-&gt;failed:expected<span class="hljs-literal"><span class="hljs-literal">-Exp</span></span>). %all test :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,a),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,<span class="hljs-string"><span class="hljs-string">'*'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(cb,<span class="hljs-string"><span class="hljs-string">'?a'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(adceb,<span class="hljs-string"><span class="hljs-string">'*a*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(acdcb,<span class="hljs-string"><span class="hljs-string">'a*c?b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aab,<span class="hljs-string"><span class="hljs-string">'c*a*b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(mississippi,<span class="hljs-string"><span class="hljs-string">'m??*ss*?i*pi'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abefcdgiescdfimde,<span class="hljs-string"><span class="hljs-string">'ab*cd?i*de'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(zacabz,<span class="hljs-string"><span class="hljs-string">'*a?b*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(leetcode,<span class="hljs-string"><span class="hljs-string">'*e*t?d*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaaa,<span class="hljs-string"><span class="hljs-string">'***a'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(b,<span class="hljs-string"><span class="hljs-string">'*?*?*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abbbbbbbaabbabaabaa,<span class="hljs-string"><span class="hljs-string">'*****a*ab'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab,<span class="hljs-string"><span class="hljs-string">'***bba**a*bbba**aab**b'</span></span>),false).</code> </pre> <br><p>  Hier k√∂nnen Sie sehen, dass die Regel, die zuvor die Suche nach der Vorlage durchgef√ºhrt hat, als ob sie einen √úbergang entlang der Fl√§che im Diagramm vorgenommen h√§tte, jetzt zu einer Reihe von Faktenmustern geworden ist, die m√∂gliche √úberg√§nge (Beziehungen zwischen Zust√§nden) enthalten. Dies ist eine Beschreibung des Diagramms und kein Code, der sie implementiert. </p><br><p>  Und die Ausf√ºhrung ergibt sich mit der Zeit in Sekunden: </p><br><pre> <code class="hljs erlang-repl">isMatch(aa, a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00010013580322265625</span></span>/sec isMatch(aa, *)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(cb, ?a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">3.981590270996094e-5</span></span>/sec isMatch(adceb, *a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0001399517059326172</span></span>/sec isMatch(acdcb, a*c?b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(aab, c*a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(mississippi, m??*ss*?i*pi)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003399848937988281</span></span>/sec isMatch(abefcdgiescdfimde, ab*cd?i*de)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003600120544433594</span></span>/sec isMatch(zacabz, *a?b*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(leetcode, *e*t?d*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00020003318786621094</span></span>/sec isMatch(aaaa, ***a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(b, *?*?*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">6.008148193359375e-5</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0040400028228759766</span></span>/sec isMatch(abbbbbbbaabbabaabaa, *****a*ab)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0006201267242431641</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.003679990768432617</span></span>/sec isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab, ***bba**a*bbba**aab**b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.002460002899169922</span></span>/sec</code> </pre> <br><p>  Und dies ist bereits eine erfolgreiche L√∂sung, nicht nur logisch, sondern auch rechtzeitig. </p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  In einem fr√ºheren Artikel wollte ich Interesse am Thema eines deklarativen Ansatzes sehen.  Das Thema "niasilil solch ein Ansatz" wurde sofort er√∂ffnet, aber das Interesse kann immer noch gezeigt werden.  Hier habe ich gezeigt, dass es ein Leistungsproblem gibt, was klar geschrieben steht, funktioniert nicht schnell.  Versuche, einen parallelen Prolog zu erstellen, waren erfolglos.  Vielleicht ist hier die Frage der Zukunft, kann ein Quantencomputer? <br>  Insgesamt verwenden wir R√§tsel auf der oben genannten Seite f√ºr einen angenehmen Zeitvertreib mit Bedacht. </p><br><p>  Nun, beim n√§chsten Mal wird versucht, eine weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwierige Aufgabe</a> sofort effektiv zu l√∂sen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427913/">https://habr.com/ru/post/de427913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427901/index.html">So verwenden Sie die Node.js Stream-API nicht</a></li>
<li><a href="../de427905/index.html">Food Mining oder Crossroads mit den Augen eines Hackers</a></li>
<li><a href="../de427907/index.html">Drohnenschie√üen, Rechen, Life Hacks, Selbstentwicklung und Karriere eines Fotografen / Videografen: neuer GLPH-Podcast</a></li>
<li><a href="../de427909/index.html">Python: Wie kann der Speicherverbrauch um die H√§lfte reduziert werden, indem nur eine Codezeile hinzugef√ºgt wird?</a></li>
<li><a href="../de427911/index.html">B√ºro Leidenschaften</a></li>
<li><a href="../de427915/index.html">Vermutung der Dummheit</a></li>
<li><a href="../de427917/index.html">Antwort auf den Beitrag "Vermutung des Geistes"</a></li>
<li><a href="../de427919/index.html">COM auf Linux portieren</a></li>
<li><a href="../de427921/index.html">4 Videos √ºber Aufschub</a></li>
<li><a href="../de427923/index.html">Wie ich dem SmartThings Hub ein neues Ger√§t hinzugef√ºgt habe, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>