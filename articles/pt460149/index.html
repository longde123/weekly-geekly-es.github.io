<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 👻 🕝 Digitação adequada: o aspecto subestimado do código limpo 🌿 👮 👩🏻‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá colegas. 

 Há pouco tempo, nossa atenção foi atraída pelo livro quase pronto da Manning Publishing House “Programação com tipos”, que detalha a i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Digitação adequada: o aspecto subestimado do código limpo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/460149/">  Olá colegas. <br><br>  Há pouco tempo, nossa atenção foi atraída pelo livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quase pronto</a> da Manning Publishing House “Programação com tipos”, que detalha a importância da digitação adequada e seu papel na escrita de códigos limpos e duradouros. <br><br><img src="https://habrastorage.org/webt/i9/d8/mp/i9d8mpulnbdmza0fjef3zfzutaa.png"><br><br>  Ao mesmo tempo, no blog do autor, encontramos um artigo escrito, aparentemente, nos estágios iniciais do trabalho do livro e permitindo impressionar seu material.  Sugerimos discutir como as idéias do autor são interessantes e, potencialmente, o livro inteiro <br><a name="habracut"></a><br>  <b>Mars orbiter climático</b> <br><br>  A sonda Mars Climate Orbiter caiu durante o pouso e desmoronou na atmosfera marciana, porque o componente de software da Lockheed forneceu o valor do momento, medido em libra-força s. seg <br><br>  Você pode imaginar o componente desenvolvido pela NASA aproximadamente da seguinte forma: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  &gt;= 2 N s void trajectory_correction(double momentum) { if (momentum &lt; 2 /* N s */) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Você também pode imaginar que o componente Lockheed chamou o código acima assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-number"><span class="hljs-number">1.5</span></span> <span class="hljs-comment"><span class="hljs-comment">/* lbf s */</span></span>); }</code> </pre> <br>  Libra-força-segundo (lbfs) é de aproximadamente 4.448222 newtons por segundo (Ns).  Assim, do ponto de vista de Lockheed, passar 1,5 lbfs para a <code>trajectory_correction</code> deve ser perfeitamente normal: 1,5 lbfs é aproximadamente 6,672333 Ns, bem acima do limite de 2 Ns. <br><br>  O problema é a interpretação dos dados.  Como resultado, o componente da NASA compara lbfs com Ns sem conversão e interpreta erroneamente a entrada em lbfs como entrada em Ns.  Como 1,5 é menor que 2, o orbitador entrou em colapso.  Este é um antipadrão bem conhecido chamado obsessão primitiva. <br><br>  <b>Obsessão com primitivos</b> <br><br>  Uma fixação em primitivas se manifesta quando usamos um tipo de dados primitivo para representar um valor em um domínio de problema e permitir situações como as descritas acima.  Se você representa códigos postais como números, números de telefone como sequências, Ns e lbfs como números de precisão dupla, é exatamente isso que acontece. <br><br>  Seria muito mais seguro definir um tipo simples de <code>Ns</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ns</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Da mesma forma, você pode definir um tipo simples de <code>lbfs</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Agora você pode implementar uma variante segura de tipo de <code>trajectory_correction</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   &gt;= 2 N s void trajectory_correction(Ns momentum) { if (momentum &lt; Ns{ 2 }) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Se você chamar isso com <code>lbfs</code> , como no exemplo acima, o código simplesmente não será compilado devido à incompatibilidade de tipo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> }); }</code> </pre> <br>  Observe como as informações do tipo de valor, normalmente indicadas nos comentários, ( <code>2 /*Ns */, /* lbfs */</code> ) agora são inseridas no sistema de tipos e expressas no código: ( <code>Ns{ 2 }, lbfs{ 1.5 }</code> ) . <br><br>  Obviamente, é possível fornecer uma redução de <code>lbfs</code> para <code>Ns</code> na forma de um operador explícito: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">4.448222</span></span>; } };</code> </pre> <br>  Armado com esta técnica, você pode chamar <code>trajectory_correction</code> usando uma conversão estática: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ns&gt;(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> })); }</code> </pre> <br>  Aqui, a correção do código é obtida multiplicando por um coeficiente.  Uma conversão também pode ser realizada implicitamente (usando a palavra-chave implícita); nesse caso, a conversão será aplicada automaticamente.  Como regra empírica, você pode usar um dos coans do Python aqui: <br><blockquote>  Explícito é melhor que implícito </blockquote>  A moral dessa história é que, embora hoje tenhamos mecanismos de verificação de tipo muito inteligentes, eles ainda precisam fornecer informações suficientes para detectar esse tipo de erro.  Essas informações entram no programa se declararmos tipos levando em consideração as especificidades de nossa área de assunto. <br><br>  <b>Espaço de estado</b> <br><br>  O problema ocorre quando um programa termina em um <i>estado ruim</i> .  Os tipos ajudam a restringir o campo para sua ocorrência.  Vamos tentar tratar o tipo como o conjunto de valores possíveis.  Por exemplo, bool é o conjunto <code>{true, false}</code> , no qual uma variável desse tipo pode receber um desses dois valores.  Da mesma forma, <code>uint32_t</code> é o conjunto <code>{0 ...4294967295}</code> .  Considerando os tipos dessa maneira, podemos definir o espaço de estados do nosso programa como o produto dos tipos de todas as variáveis ​​vivas em um determinado momento. <br><br>  Se tivermos uma variável do tipo <code>bool</code> e uma variável do tipo <code>uint32_t</code> , nosso espaço de estado será <code>{true, false} X {0 ...4294967295}</code> .  Significa apenas que ambas as variáveis ​​podem estar em qualquer estado possível para elas e, como temos duas variáveis, o programa pode terminar em qualquer estado combinado desses dois tipos. <br><br>  Tudo se torna muito mais interessante se considerarmos as funções que inicializam os valores: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_momentum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ns&amp; momentum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; momentum = Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  No exemplo acima, tomamos Ns por referência e inicializamos se alguma condição for atendida.  A função retorna <code>true</code> se o valor foi inicializado corretamente.  Se a função, por algum motivo, não puder definir o valor, ela retornará <code>false</code> . <br><br>  Considerando essa situação do ponto de vista do espaço de estados, podemos dizer que o espaço de estados é um produto de <code>bool X Ns</code> .  Se a função retornar verdadeira, significa que o impulso foi definido e é um dos valores possíveis de <code>Ns</code> .  O problema é este: se a função retornar <code>false</code> , significa que o impulso não foi definido.  De uma forma ou de outra, o momento pertence ao conjunto de valores possíveis de Ns, mas não é um valor válido.  Muitas vezes, existem bugs nos quais o seguinte estado inaceitável acidentalmente começa a se espalhar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momenum; get_momentum(momentum); trajectory_correction(momentum); }</code> </pre><br>  Em vez disso, basta fazer o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momentum; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (get_momentum(momentum)) { trajectory_correction(momentum); } }</code> </pre> <br>  No entanto, existe uma maneira melhor de fazer isso à força: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;Ns&gt; get_momentum() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_optional(Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }); }</code> </pre> <br>  Se você usar <code>optional</code> , o espaço de estados dessa função diminuirá significativamente: em vez de <code>bool X Ns</code> obtemos <code>Ns + 1</code> .  Esta função retornará um <code>nullopt</code> <code>Ns</code> ou <code>nullopt</code> válido para indicar nenhum valor.  Agora, simplesmente não podemos ter um <code>Ns</code> inválido que se espalharia no sistema.  Agora também é impossível esquecer o valor de retorno, pois o opcional não pode ser implicitamente convertido em <code>Ns</code> - precisaremos descompactá-lo especialmente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> maybeMomentum = get_momentum(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maybeMomentum) { trajectory_correction(*maybeMomentum); } }</code> </pre> <br>  Basicamente, nos esforçamos para que nossas funções retornem um resultado ou erro, em vez de resultado e erro.  Assim, excluímos as condições em que temos erros e também estamos seguros de resultados inaceitáveis, que poderiam vazar para cálculos adicionais. <br><br>  Desse ponto de vista, lançar exceções é normal, pois corresponde ao princípio descrito acima: uma função retornará um resultado ou lançará uma exceção. <br><br>  <b>RAII</b> <br><br>  RAII significa Aquisição de Recursos É Inicialização, mas em maior medida esse princípio está associado à liberação de recursos.  O nome apareceu pela primeira vez em C ++, no entanto, esse padrão pode ser implementado em qualquer idioma (consulte, por exemplo, <code>IDisposable</code> from .NET).  RAII fornece limpeza automática de recursos. <br><br>  O que são recursos?  Aqui estão alguns exemplos: memória dinâmica, conexões com o banco de dados, descritores do SO.  Em princípio, um recurso é algo retirado do mundo exterior e sujeito a retorno depois que não precisamos mais dele.  Retornamos o recurso usando a operação apropriada: libere-o, exclua-o, feche-o etc. <br><br>  Como esses recursos são externos, eles não são expressos explicitamente em nosso sistema de tipos.  Por exemplo, se selecionarmos um fragmento de memória dinâmica, obteremos um ponteiro pelo qual teremos que chamar <code>delete</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">/*  foo */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre><br>  Mas o que acontece se esquecermos de fazer isso ou algo nos impede de chamar <code>delete</code> ? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre> <br>  Nesse caso, não chamamos mais de <code>delete</code> e temos um vazamento de recursos.  Em princípio, essa limpeza manual de recursos é indesejável.  Para memória dinâmica, temos <code>unique_ptr</code> para nos ajudar a gerenciá-la: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Foo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); }</code> </pre> <br>  Nosso <code>unique_ptr</code> é um objeto de pilha; portanto, se ele <code>unique_ptr</code> escopo (quando a função lança uma exceção ou quando a pilha se desenrola quando uma exceção foi lançada), seu destruidor é chamado.  É esse destruidor que implementa a chamada de <code>delete</code> .  Portanto, não precisamos mais gerenciar o recurso de memória - transferimos esse trabalho para o wrapper, que é o proprietário e o responsável por seu lançamento. <br><br>  Wrappers semelhantes existem (ou podem ser criados) para quaisquer outros recursos (por exemplo, OS HANDLE do Windows podem ser agrupados em um tipo, caso em que seu destruidor chamará <code>CloseHandle</code> ). <br><br>  A principal conclusão nesse caso é nunca fazer a limpeza manual dos recursos;  Use o wrapper existente ou, se não houver um wrapper adequado para o seu cenário específico, nós o implementaremos. <br><br>  <b>Conclusão</b> <br><br>  Iniciamos este artigo com um exemplo conhecido que demonstra a importância da digitação e examinamos três aspectos importantes do uso de tipos para ajudar a escrever código mais seguro: <br><br><ul><li>  Declarar e usar tipos mais fortes (em oposição à obsessão por primitivos). </li><li>  Reduzindo o espaço de estado, retornando um resultado ou erro, não um resultado ou erro. </li><li>  RAII e gerenciamento automático de recursos. </li></ul><br>  Portanto, os tipos ajudam muito a tornar o código mais seguro e adaptá-lo para reutilização. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460149/">https://habr.com/ru/post/pt460149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460137/index.html">Revisão do Fujitsu LIFEBOOK U939X: desempenho leve e 2 em 1</a></li>
<li><a href="../pt460139/index.html">Campeonato de programação: analisando tarefas para desenvolvedores front-end</a></li>
<li><a href="../pt460141/index.html">Não é outra linguagem de programação. Parte 2: Lógica de Representação</a></li>
<li><a href="../pt460143/index.html">Módulo dis Python e convolução de constantes</a></li>
<li><a href="../pt460147/index.html">Estrutura de microsserviços PHP - Swoft 2.0.3 publicado</a></li>
<li><a href="../pt460151/index.html">Projeto orientado a modelo. Motor DC sem escova</a></li>
<li><a href="../pt460153/index.html">As aventuras de assinaturas eletrônicas na Rússia</a></li>
<li><a href="../pt460155/index.html">ReactiveX Redux</a></li>
<li><a href="../pt460157/index.html">Como as respostas "corretas" dos entrevistados podem distorcer os resultados da pesquisa além do reconhecimento</a></li>
<li><a href="../pt460159/index.html">Método para monitorar o estado atual das estradas russas pelos smartphones dos usuários</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>