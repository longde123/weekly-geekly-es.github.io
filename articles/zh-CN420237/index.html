<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉐 🤾🏾 💅 C ++中围绕gRPC框架的Qt包装器 📡 🙏🏼 👩‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 今天，我们将研究如何在C ++和Qt库中链接gRPC框架。 本文提供了总结gRPC中所有四种交互模式的用法的代码。 另外，提供了允许通过Qt信号和插槽使用gRPC的代码。 本文可能主要是对使用gRPC感兴趣的Qt开发人员感兴趣的。 尽管如此，在不使用Qt的情况下，用C ++编写了gRPC四种...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++中围绕gRPC框架的Qt包装器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p> 大家好 今天，我们将研究如何在C ++和Qt库中链接gRPC框架。 本文提供了总结gRPC中所有四种交互模式的用法的代码。 另外，提供了允许通过Qt信号和插槽使用gRPC的代码。 本文可能主要是对使用gRPC感兴趣的Qt开发人员感兴趣的。 尽管如此，在不使用Qt的情况下，用C ++编写了gRPC四种操作模式的概括，这将使与Qt无关的开发人员可以修改代码。 我问每个有兴趣的猫。 </p><a name="habracut"></a><br><h2> 背景知识 </h2><br><p> 大约六个月前，使用gRPC的客户端和服务器部分挂起了两个项目。 这两个项目都减产。 这些项目是由已经退出的开发人员编写的。 唯一的好消息是，我积极参与了编写gRPC服务器和客户端代码的工作。 但是那是大约一年前的事。 因此，像往常一样，我必须从头开始处理所有问题。 </p><br><p> 编写gRPC服务器代码时，期望它将由.proto文件进一步生成。 代码写得很好。 但是，服务器有一个很大的缺点：只有一个客户端可以连接到它。 </p><br><p>  gRPC客户端的编写非常糟糕。 </p><br><p> 几天后，我弄清楚了客户端和服务器代码gRPC。 而且我意识到，如果我花了几个星期的时间来做项目，我将不得不再次处理服务器和gRPC客户端。 </p><br><p> 那时我决定是时候编写和调试gRPC客户端和服务器了，以便： </p><br><ul><li><p> 您可以在晚上安然入睡； </p></li><li><p> 无需记住每次您需要编写客户端或gRPC服务器时它是如何工作的。 </p></li><li><p> 您可以在其他项目中使用书面的gRPC客户端和服务器。 </p></li></ul><br><p> 在编写代码时，我遵循以下要求： </p><br><ul><li><p>  gRPC客户端和服务器都可以自然地使用Qt库信号和插槽进行操作； </p></li><li><p> 更改.proto文件时，无需修复gRPC客户端和服务器代码； </p></li><li><p>  gRPC客户端应该能够告诉客户端代码与服务器的连接状态。 </p></li></ul><br><p> 本文的结构如下。 首先，将简要概述使用客户端代码的结果以及一些解释。 审查结束时，指向存储库的链接。 此外，在架构上还会有一些一般性的事情。 然后是服务器和客户端代码的说明（幕后花絮）和结论。 </p><br><h2> 简短评论 </h2><br><p> 最简单的pingproto.proto文件用作.proto文件，其中定义了所有交互类型的RPC： </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  pingpong.proto文件将有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++中异步gRPC模式</a>的文章中的helloworld.proto文件重复到确切名称。 </p><br><p> 结果，可以像下面这样使用书面服务器： </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p> 客户端调用RPC时，gRPC服务器会使用适当的信号通知客户端代码（在本例中为A类）。 </p><br><p>  gRPC客户端可以这样使用： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p> 使用gRPC客户端，您可以直接调用RPC，并使用适当的信号订阅服务器的响应。 </p><br><p>  gRPC客户端也有一个信号： <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br> 报告过去和当前服务器连接状态。 所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a>代码都在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qgrpc存储库中</a> 。 <br><br><h2> 如何运作 </h2><br><p> 图中显示了将客户端和gRPC服务器包括在项目中的原理。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p> 在.pro项目文件中，指定了.proto文件，gRPC将基于该文件工作。  grpc.pri文件包含用于生成gRPC和QgRPC文件的命令。 协议编译器生成gRPC文件[protofile] .grpc.pb.h和[protofile] .grpc.pb.cc。  [protofile]是传递给编译器输入的.proto文件的名称。 </p><br><p>  QgRPC文件[protofile] .qgrpc。[Config] .h的生成由脚本genQGrpc.py处理。  [config]是“服务器”或“客户端”。 <br><br> 生成的QgRPC文件包含围绕gRPC类的Qt包装器以及带有相应信号的调用。 在前面的示例中，分别在生成的文件pingpong.qgrpc.server.h和pingpong.qgrpc.client.h中声明了QpingServerService和QpingClientService类。 生成的QgRPC文件将添加到moc处理中。 </p><br><p> 在生成的QgRPC文件中，包括QGrpc [config] .h文件，所有主要工作都在其中进行。 在下面阅读有关此内容的更多信息。 </p><br><p> 要将所有此构造连接到项目，您需要在项目.pro文件中包括grpc.pri文件，并指定三个变量。  GRPC变量定义了.proto文件，这些文件将被传输到protoc编译器和genQGrpc.py脚本的输入中。  QGRPC_CONFIG变量定义生成的QgRPC文件的配置值，并且可以包含值“ server”或“ client”。 您还可以定义可选的GRPC_VERSION变量以指示gRPC的版本。 </p><br><p> 有关所有内容的更多信息，请阅读grpc.pri文件和.pro示例文件。 </p><br><h2> 服务器架构 </h2><br><p> 服务器类图如图所示。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p> 粗箭头显示类继承的层次结构，细箭头显示类中成员和方法的成员资格。 通常，会为服务生成Q [servicename] ServerService类，其中servicename是.proto文件中声明的服务的名称。  RPCCallData是为服务中的每个RPC生成的控制结构。 在QpingServerService类的构造函数中，基类QGrpcServerService使用gRPC pingpong :: ping :: AsyncService异步服务初始化。 要启动该服务，您需要使用该服务将在其上运行的地址和端口来调用Start（）方法。  Start（）函数实现了启动服务的标准过程。 </p><br><p> 在Start（）函数的末尾，将调用纯虚函数makeRequests（），该函数在生成的QpingServerService类中实现： </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  needAnotherCallData函数的第二个模板参数是生成的RPCCallData结构。 相同的结构是所生成的服务的Qt类中的信号参数。 </p><br><p> 生成的RPCCallData结构继承自ServerCallData类。 反过来，ServerCallData类是从ServerResponder响应器继承的。 因此，创建相干结构的对象会导致创建响应者对象。 </p><br><p>  ServerCallData类的构造函数采用两个参数：signal_func和request_func。  signal_func是生成的信号，在从队列中接收到标签后将调用该信号。  request_func是创建新响应者时应调用的函数。 例如，在这种情况下，它可能是RequestSayHello（）函数。  request_func调用发生在needAnotherCallData（）函数中。 这样做是为了在服务中进行响应者的管理（创建和删除）。 </p><br><p>  needAnotherCallData（）函数的代码包括创建响应者对象和调用将响应者连接到RPC调用的函数： </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  RequestRPC（）函数是用于四种类型的交互的模板函数。 结果，调用RequestRPC（）归结为一个调用： </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p> 其中service_是gRPC服务。 在这种情况下，它是pingpong :: ping :: AsyncService。 </p><br><p> 若要同步或异步检查事件队列，必须分别调用CheckCQ（）或AsyncCheckCQ（）函数。  CheckCQ（）函数的代码可归结为从队列中调用同步标签以及对该标签的处理： </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p> 从队列接收标签后，将检查标签的有效性和服务器启动。 如果服务器已关闭，则不再需要该标签-可以将其删除。 之后，将调用ServerCallData类中定义的cqReaction（）函数： </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  first_time_reaction_标志指示您需要为被调用的RPC创建一个新的响应器。 函数CouldBeDeleted（）和ProcessEvent（）继承自相应的ServerResponder响应器类。  CouldBeDeleted（）函数返回一个标志，表明可以删除响应程序对象。  processEvent（）函数处理标记和ok标志。 因此，例如，对于客户端流类型的响应者，该函数如下所示： </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p> 无论响应器的类型如何，ProcessEvent（）函数始终返回true。 该函数的返回值保留为可能的功能扩展，并且从理论上讲，是为了消除错误。 </p><br><p> 处理事件后，调用如下： <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p> 变量service_是所生成服务的实例，在本例中为QpingServerService。 变量signal_func_是对应于特定RPC的服务信号。 例如，SayHelloRequest（）。 变量genRpcCallData是相应类型的响应者对象。 从调用代码的角度来看，变量genRpcCallData是所生成的RPCCallData结构之一的对象。 <br></p><br><h2> 客户架构 </h2><br><p> 客户端的类和功能的名称尽可能匹配服务器的类和功能的名称。 客户端类图如图所示。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p> 粗箭头显示类继承的层次结构，细箭头显示类中成员和方法的成员资格。 通常，对于服务，将生成Q [servicename]类ClientService，其中servicename是.proto文件中声明的服务的名称。  RPCCallData是为服务中的每个RPC生成的控制结构。 要调用RPC，生成的类提供名称与.proto文件中声明的RPC完全匹配的函数。 在我们的示例中，在.proto RPC文件中，SayHello（）声明为： <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p> 在生成的QpingClientService类中，相应的RPC函数如下所示： </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p> 与服务器一样，生成的RPCCallData结构最终从ClientResponder类继承。 因此，所生成结构的对象的创建导致响应者的创建。 创建响应者后，将调用RPC，并将响应者与从服务器接收响应的事件相关联。 在客户端代码方面，RPC调用如下所示： </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p> 与生成的QpingServerService服务器类不同，QpingClientService类从两个模板类继承：ConnectivityFeatures和MonitorFeatures。 </p><br><p>  ConnectivityFeatures类负责客户端-服务器连接的状态，并提供三个使用功能：grpc_connect（），grpc_disconnect（），grpc_reconnect（）。  grpc_disconnect（）函数仅删除负责与服务器交互的所有数据结构。 对grpc_connect的调用被简化为对grpc_connect_（）函数的调用，该函数创建控制数据结构： </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  ChannelFeatures类监视与服务器的<em>channel_</em>通道通信的状态。  ConnectivityFeatures类封装ChannelFeatures类的一个对象，并使用此对象实现抽象功能channelState（），checkChannelState（）和connected（）。  channelState（）函数返回与服务器通信通道的最后观察到的状态。 实际上，checkChannelState（）函数返回通道的当前状态。  connected（）函数返回客户端连接到服务器的标志。 <br></p><br><p>  MonitorFeatures类负责从服务器接收和处理事件，并提供CheckCQ（）函数以供使用： </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p> 代码结构与服务器的情况相同。 与服务器不同，将负责处理当前状态的代码块添加到客户端。 如果通信通道的状态已更改，则会调用信号channelStateChangedSignal_（）。 在所有生成的服务中，这是一个信号： <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br> 另外，与服务器不同，此处使用AsyncNext（）函数代替Next（）。 这样做有几个原因。 首先，当使用AsyncNext（）时，客户端代码具有了解通信通道状态变化的能力。 其次，当使用AsyncNext（）时，可以在客户端代码中多次调用各种RPC。 在这种情况下，使用Next（）函数将阻塞线程，直到从队列接收到事件为止，结果将丢失所描述的两个功能。 <br><br><p> 与服务器一样，从队列接收事件后，将调用ClientCallData类中定义的cqReaction（）函数： </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p> 与服务器一样，processEvent（）函数处理标记和ok标志，并始终返回true。 与服务器的情况一样，在处理事件之后，应调用生成的服务的信号。 但是，同名服务器功能有两个重要区别。 第一个区别是没有在此功能中创建响应者。 如上所示，响应者的创建在调用RPC时发生。 第二个区别是此功能未删除响应者。 由于两个原因，没有删除响应者。 首先，客户端代码可以出于自身目的使用指向生成的RPCCallData结构的指针。 用此指针删除隐藏在客户端代码中的内容可能导致不愉快的后果。 其次，移除响应者将导致以下事实：将不会生成带有数据的信号。 因此，客户端代码将不会收到最后的服务器消息。 在解决指示问题的几种选择中，决定将响应者（生成的结构）的移除转移到客户端代码。 因此，信号处理程序功能（插槽）必须包含以下代码： </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p> 如果没有在客户端代码中删除响应者，则不仅会导致内存泄漏，还会导致通信通道出现问题。 示例代码中实现了各种RPC交互的信号处理程序。 </p><br><h2> 结论 </h2><br><p> 总之，我们提请注意两点。 第一点与调用客户端和服务器的CheckCQ（）函数有关。 如上所示，它们按照一种原理工作：如果队列中有事件，则会发出具有相应生成的RPCCallData结构的信号。 您可以手动调用此函数并检查（对于客户端）事件。 但是最初有一个想法将与gRPC相关的整个网络部分转移到另一个线程。 为此，编写了用于gRPC服务器的辅助类QGrpcSrvMonitor和用于gRPC客户端的QGrpcCliServer。 这两个类的工作原理相同：它们创建一个单独的流，将生成的服务放入此流中，并定期调用此服务的CheckCQ（）函数。 因此，当使用两个辅助类时，无需在客户端代码中调用CheckCQ（）函数。 在这种情况下，生成的服务的信号“来自”另一个流。 使用这些帮助程序类来实现客户端和服务器示例。 </p><br><p> 第二点涉及大多数在工作中不使用Qt库的开发人员。  QgRPC中的Qt类和宏仅在两个地方使用：在生成的服务文件中以及在包含辅助类的文件中：QGrpcServerMonitor.h和QGrpcClientMonitor.h。 与Qt库的其余文件没有任何关联。 计划使用cmake添加程序集，并添加一些Qt指令。 特别是QObject类和Q_OBJECT宏。 但是，人们对此一无所知。 因此，欢迎提出任何建议。 </p><br><p> 仅此而已。 谢谢大家！ </p><br><h2> 参考文献 </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带有QgRPC代码的存储库</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++中的异步gRPC</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420237/">https://habr.com/ru/post/zh-CN420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420225/index.html">基于素数的无限算法旋律</a></li>
<li><a href="../zh-CN420227/index.html">土耳其总统宣布禁止美国进口电子产品</a></li>
<li><a href="../zh-CN420229/index.html">如果附近的孩子们只教铁路工人，他们可以成为程序员吗？ 与“圈子”的对话</a></li>
<li><a href="../zh-CN420233/index.html">UE4 | 多人游戏装备＃5 | 服务器与客户端之间的信息传输</a></li>
<li><a href="../zh-CN420235/index.html">Zenject：IoC容器如何杀死项目的依赖注入</a></li>
<li><a href="../zh-CN420239/index.html">移动开发。 Swift：协议之谜</a></li>
<li><a href="../zh-CN420243/index.html">突破性慈善事业：人道主义突破性项目</a></li>
<li><a href="../zh-CN420245/index.html">使用Java集合时如何防止内存溢出</a></li>
<li><a href="../zh-CN420251/index.html">苹果称该公司总部大楼仅需200美元</a></li>
<li><a href="../zh-CN420253/index.html">开放银行API如何改变金融世界</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>