<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé§ üåµ üë∑ Robar: qui√©n roba el tiempo del procesador de las m√°quinas virtuales üê§ üë®üèø‚Äçüî¨ üèéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Quiero hablar en lenguaje sencillo sobre la mec√°nica de la aparici√≥n del robo dentro de las m√°quinas virtuales y sobre algunos artefactos no evid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Robar: qui√©n roba el tiempo del procesador de las m√°quinas virtuales</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/449316/"><img src="https://habrastorage.org/getpro/habr/post_images/af7/c70/8aa/af7c708aa619490409ed5cf46d9c96fa.jpg"><br><br>  Hola  Quiero hablar en lenguaje sencillo sobre la mec√°nica de la aparici√≥n del robo dentro de las m√°quinas virtuales y sobre algunos artefactos no evidentes que pudimos descubrir durante su investigaci√≥n, en los que tuve que sumergirme como asesor t√©cnico de la plataforma en la nube <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mail.ru Cloud Solutions</a> .  La plataforma se ejecuta en KVM. <br><br>  El tiempo de robo de la CPU es el tiempo durante el cual la m√°quina virtual no recibe recursos del procesador para su ejecuci√≥n.  Este tiempo solo se considera en los sistemas operativos invitados en entornos de virtualizaci√≥n.  Las razones por las que van estos recursos muy asignados, como en la vida, son muy vagas.  Pero decidimos resolverlo, incluso establecer una serie completa de experimentos.  No es que ahora sepamos todo sobre el robo, pero le diremos algo interesante en este momento. <br><a name="habracut"></a><br><h2>  1. ¬øQu√© es robar? </h2><br>  Por lo tanto, robar es una m√©trica que indica una falta de tiempo de procesador para los procesos dentro de una m√°quina virtual.  Como se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el parche del kernel KVM</a> , robar es el tiempo durante el cual el hipervisor ejecuta otros procesos en el sistema operativo host, aunque ha puesto en cola el proceso de la m√°quina virtual para su ejecuci√≥n.  Es decir, el robo se considera la diferencia entre el momento en que el proceso est√° listo para ejecutarse y el momento en que se asigna el tiempo de proceso al procesador. <br><br>  El n√∫cleo del n√∫cleo recibe el robo m√©trico del hipervisor.  Al mismo tiempo, el hipervisor no especifica exactamente qu√© otros procesos realiza, simplemente "mientras estoy ocupado, no puedo darle tiempo".  En KVM, se ha agregado soporte para contar robos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parches</a> .  Aqu√≠ hay dos puntos clave: <br><br><ul><li>  La m√°quina virtual aprende sobre el robo del hipervisor.  Es decir, desde el punto de vista de las p√©rdidas, para los procesos en la m√°quina virtual en s√≠, es una medici√≥n indirecta que puede estar sujeta a varias distorsiones. <br></li><li> El hipervisor no comparte informaci√≥n con la m√°quina virtual sobre lo que est√° haciendo con los dem√°s; lo principal es que no le dedica tiempo.  Debido a esto, la m√°quina virtual en s√≠ misma no puede detectar distorsiones en el √≠ndice de robo, lo que podr√≠a estimarse por la naturaleza de los procesos competitivos. <br></li></ul><br><h2>  2. Lo que afecta el robo </h2><br><h3>  2.1.  Robo de c√°lculo </h3><br>  De hecho, el robo se considera aproximadamente lo mismo que el tiempo normal de utilizaci√≥n de la CPU.  No hay mucha informaci√≥n sobre c√≥mo se considera la eliminaci√≥n.  Probablemente porque la mayor√≠a considera esta pregunta obvia.  Pero tambi√©n hay dificultades aqu√≠.  Para familiarizarse con este proceso, puede leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de Brendann Gregg</a> : aprender√° sobre un mont√≥n de matices en el c√°lculo de la utilizaci√≥n y sobre situaciones en las que este c√°lculo ser√° err√≥neo por las siguientes razones: <br><br><ul><li>  Sobrecalentamiento del procesador, durante el cual se omiten los ciclos de reloj. <br></li><li>  Active / desactive el turbo boost, como resultado de lo cual cambia la frecuencia del reloj del procesador. <br></li><li>  Un cambio en la duraci√≥n de un tiempo cu√°ntico que ocurre cuando se usan tecnolog√≠as de ahorro de energ√≠a del procesador como SpeedStep. <br></li><li>  El problema de calcular el promedio: una estimaci√≥n de la utilizaci√≥n en un minuto al 80% puede ocultar una explosi√≥n a corto plazo en el 100%. <br></li><li>  El bloqueo c√≠clico (bloqueo de giro) conduce al hecho de que el procesador se elimina, pero el proceso del usuario no ve progreso en su ejecuci√≥n.  Como resultado, la utilizaci√≥n estimada del procesador por el proceso ser√° del cien por ciento, aunque el proceso no consumir√° f√≠sicamente el tiempo del procesador. <br></li></ul><br>  No encontr√© un art√≠culo que describiera un c√°lculo similar para robar (si lo sabe, comparta en los comentarios).  Pero, a juzgar por la fuente, el mecanismo de c√°lculo es el mismo que para la eliminaci√≥n.  Es solo que se agrega otro contador al kernel, directamente para el proceso KVM (proceso de m√°quina virtual), que cuenta el tiempo que el proceso KVM est√° en el estado de espera del tiempo de procesador.  El contador toma informaci√≥n sobre el procesador de su especificaci√≥n y observa si el proceso virtual ha utilizado todos sus tics.  Si eso es todo, entonces creemos que el procesador solo particip√≥ en el proceso de la m√°quina virtual.  De lo contrario, informamos que el procesador estaba haciendo otra cosa, apareci√≥ robar. <br><br>  El proceso de conteo de robos est√° sujeto a los mismos problemas que el conteo de reciclaje regular.  No quiere decir que tales problemas aparezcan con frecuencia, pero parecen desalentadores. <br><br><h3>  2.2.  Tipos de virtualizaci√≥n en KVM </h3><br>  En t√©rminos generales, hay tres tipos de virtualizaci√≥n, y todos ellos son compatibles con KVM.  El tipo de virtualizaci√≥n puede determinar el mecanismo por el cual ocurre el robo. <br><br>  <b>Broadcast</b>  En este caso, la operaci√≥n del sistema operativo de la m√°quina virtual con los dispositivos f√≠sicos del hipervisor ocurre aproximadamente de esta manera: <br><br><ol><li>  El sistema operativo invitado env√≠a un comando a su dispositivo invitado. <br></li><li>  El controlador del dispositivo invitado acepta el comando, genera una solicitud para el BIOS del dispositivo y lo env√≠a al hipervisor. <br></li><li>  El proceso del hipervisor traduce un comando en un comando para un dispositivo f√≠sico, lo que lo hace, entre otras cosas, m√°s seguro. <br></li><li>  El controlador del dispositivo f√≠sico acepta el comando modificado y lo env√≠a al propio dispositivo f√≠sico. <br></li><li>  Los resultados de la ejecuci√≥n del comando vuelven por el mismo camino. <br></li></ol><br>  La ventaja de la traducci√≥n es que le permite emular cualquier dispositivo y no requiere una preparaci√≥n especial del n√∫cleo del sistema operativo.  Pero hay que pagarlo, antes que nada, con rapidez. <br><br>  <b>Virtualizaci√≥n de hardware</b> .  En este caso, el dispositivo a nivel de hardware comprende los comandos del sistema operativo.  Esta es la mejor y m√°s r√°pida forma.  Pero, desafortunadamente, no es compatible con todos los dispositivos f√≠sicos, hipervisores y sistemas operativos invitados.  Actualmente, los principales dispositivos que admiten la virtualizaci√≥n de hardware son los procesadores. <br><br>  <b>Paravirtualizaci√≥n (paravirtualizaci√≥n)</b> .  La versi√≥n m√°s com√∫n de virtualizaci√≥n de dispositivos en KVM y, en general, el modo de virtualizaci√≥n m√°s com√∫n para sistemas operativos invitados.  Su peculiaridad es que funciona con algunos subsistemas del hipervisor (por ejemplo, con una red o pila de discos) o la asignaci√≥n de p√°ginas de memoria se realiza utilizando la API del hipervisor, sin traducir comandos de bajo nivel.  La desventaja de este m√©todo de virtualizaci√≥n es la necesidad de modificar el n√∫cleo del sistema operativo invitado para que pueda interactuar con el hipervisor utilizando esta API.  Pero generalmente esto se resuelve instalando controladores especiales en el sistema operativo invitado.  En KVM, esta API se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">virtio API</a> . <br><br>  Con la paravirtualizaci√≥n, en comparaci√≥n con la traducci√≥n, la ruta al dispositivo f√≠sico se reduce significativamente al enviar comandos directamente desde la m√°quina virtual al proceso del hipervisor host.  Esto le permite acelerar la ejecuci√≥n de todas las instrucciones dentro de la m√°quina virtual.  En KVM, la API virtio es responsable de esto, que funciona solo para ciertos dispositivos, como una red o un adaptador de disco.  Es por eso que los controladores virtio se colocan dentro de m√°quinas virtuales. <br><br>  La otra cara de esta aceleraci√≥n es que no todos los procesos que se ejecutan dentro de una m√°quina virtual permanecen dentro de ella.  Esto crea algunos efectos especiales que pueden provocar la aparici√≥n de robos.  Recomiendo comenzar un estudio detallado de este problema con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una API para E / S virtual: virtio</a> . <br><br><h3>  2.3.  Derramamiento justo </h3><br>  La virtualizaci√≥n en un hipervisor es, de hecho, un proceso ordinario que obedece las leyes de sheduling (asignaci√≥n de recursos entre procesos) en el kernel de Linux, por lo que lo consideraremos con m√°s detalle. <br><br>  Linux usa el llamado CFS, Completely Fair Scheduler, que se ha convertido en el distribuidor predeterminado desde el kernel 2.6.23.  Para comprender este algoritmo, puede leer la arquitectura o las fuentes del kernel de Linux.  La esencia del CFS es la distribuci√≥n del tiempo del procesador entre procesos, dependiendo de la duraci√≥n de su ejecuci√≥n.  Cuanto m√°s tiempo de procesador requiere el proceso, menos tiempo recibe.  Esto garantiza la ejecuci√≥n "honesta" de todos los procesos, de modo que un proceso no ocupe constantemente todos los procesadores, y tambi√©n se puedan ejecutar otros procesos. <br><br>  A veces este paradigma conduce a artefactos interesantes.  Los usuarios de Linux de toda la vida probablemente recordar√°n el desvanecimiento de un editor de texto de escritorio normal mientras ejecutan aplicaciones exigentes tipo compilador.  Esto sucedi√≥ porque las tareas de las aplicaciones de escritorio que no requieren muchos recursos compitieron con tareas que consumen recursos activamente, como un compilador.  CFS considera que esto es deshonesto, por lo que detiene peri√≥dicamente el editor de texto y permite que el procesador procese las tareas del compilador.  Esto se corrigi√≥ utilizando el mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sched_autogroup</a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quedaron</a> muchas otras caracter√≠sticas de la distribuci√≥n del tiempo de CPU entre tareas.  En realidad, esta historia no trata sobre qu√© tan mal est√°n las cosas en el SFC, sino un intento de llamar la atenci√≥n sobre el hecho de que una distribuci√≥n "honesta" del tiempo del procesador no es la tarea m√°s trivial. <br><br>  Otro punto importante en el programador es la preferencia.  Esto es necesario para impulsar el proceso de snickering desde el procesador y dejar que otros trabajen.  El proceso de exilio se llama cambio de contexto, cambio de contexto del procesador.  En este caso, se guarda todo el contexto de la tarea: el estado de la pila, los registros, etc., despu√©s de lo cual el proceso pasa a esperar, y otro toma su lugar.  Esta es una operaci√≥n costosa para el sistema operativo, y rara vez se usa, pero de hecho no tiene nada de malo.  El cambio frecuente de contexto puede indicar un problema en el sistema operativo, pero generalmente contin√∫a de forma continua y no indica nada en particular. <br><br>  Se necesita una historia tan larga para explicar un hecho: cuantos m√°s recursos de procesador intente consumir un programador honesto de Linux, m√°s r√°pido se detendr√° para que otros procesos tambi√©n puedan funcionar.  Si esto es correcto o no es un problema complejo, que se resuelve de manera diferente bajo diferentes cargas.  En Windows, hasta hace poco, el programador se enfocaba en el procesamiento prioritario de las aplicaciones de escritorio, por lo que los procesos en segundo plano podr√≠an bloquearse.  Sun Solaris ten√≠a cinco clases diferentes de shedulers.  Cuando comenzaron la virtualizaci√≥n, agregaron el sexto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programador de reparto justo</a> , porque los cinco anteriores trabajaron con la virtualizaci√≥n de Zonas de Solaris de manera inadecuada.  Recomiendo comenzar un estudio detallado de este problema con libros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solaris Internals: Solaris 10 y OpenSolaris Kernel Architecture</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Understanding the Linux Kernel</a> . <br><br><h3>  2.4.  ¬øC√≥mo controlar el robo? </h3><br>  Monitorear el robo dentro de una m√°quina virtual, como cualquier otra m√©trica del procesador, es simple: puede usar cualquier medio para eliminar las m√©tricas del procesador.  Lo principal es que la m√°quina virtual est√° en Linux.  Por alguna raz√≥n, Windows no proporciona dicha informaci√≥n a sus usuarios.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/731/75c/80473175cd23f0ba8721ca61c65fe111.png"><br>  <i>La salida del comando superior: detalles de carga del procesador, en la columna de la derecha - robar</i> <br><br>  La dificultad surge cuando se trata de obtener esta informaci√≥n del hipervisor.  Puede intentar predecir el robo en la m√°quina host, por ejemplo, mediante el par√°metro Carga promedio (LA): el valor promedio del n√∫mero de procesos que esperan en la cola para la ejecuci√≥n.  La metodolog√≠a para calcular este par√°metro no es simple, pero en general, si LA, normalizada por el n√∫mero de subprocesos del procesador, es mayor que 1, esto indica que el servidor Linux est√° algo sobrecargado. <br><br>  ¬øQu√© est√°n esperando todos estos procesos?  La respuesta obvia es el procesador.  Pero la respuesta no es del todo correcta, porque a veces el procesador es gratuito y LA se da vuelta.  Recuerde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo se cae NFS y c√≥mo crece LA</a> .  Puede ser aproximadamente lo mismo con un disco y con otros dispositivos de entrada / salida.  Pero, de hecho, los procesos pueden esperar el final de cualquier bloqueo, tanto f√≠sico, asociado con un dispositivo de E / S, como l√≥gico, como un mutex.  Esto tambi√©n incluye bloqueos a nivel de hardware (la misma respuesta del disco) o l√≥gica (las llamadas primitivas de bloqueo, que incluye un conjunto de entidades, mutex adaptativo y spin, sem√°foros, variables de condici√≥n, bloqueos rw, bloqueos ipc ...). <br><br>  Otra caracter√≠stica de LA es que se considera como el valor promedio para el sistema operativo.  Por ejemplo, 100 procesos compiten por un archivo, y luego LA = 50.  Parece que un valor tan grande sugiere que el sistema operativo es malo.  Pero para otro c√≥digo escrito torcidamente, este puede ser un estado normal, a pesar del hecho de que es malo solo para √©l, y otros procesos en el sistema operativo no sufren. <br><br>  Debido a este promedio (y no menos de un minuto), determinar algo mediante el indicador AL no es la tarea m√°s agradecida, con resultados muy inciertos en casos espec√≠ficos.  Si intenta resolverlo, descubrir√° que solo los casos m√°s simples se describen en los art√≠culos de Wikipedia y otros recursos disponibles, sin una explicaci√≥n profunda del proceso.  Env√≠o a todos los interesados, nuevamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠, a Brendann Gregg</a> , m√°s adelante en los enlaces.  Para quien la pereza en ingl√©s es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n de su popular art√≠culo sobre Los √Ångeles</a> . <br><br><h2>  3. Efectos especiales </h2><br>  Ahora analicemos los principales casos de robo que encontramos.  Te dir√© c√≥mo se siguen de lo anterior y c√≥mo se relacionan con los indicadores en el hipervisor. <br><br>  <b>Reciclaje</b>  El m√°s simple y frecuente: el hipervisor se reutiliza.  De hecho, hay muchas m√°quinas virtuales en ejecuci√≥n, un gran consumo de procesador dentro de ellas, mucha competencia, la utilizaci√≥n de LA es m√°s de 1 (normalizada por hilos de procesador).  Dentro de todos los virtualoks todo se ralentiza.  El robo transmitido desde el hipervisor tambi√©n est√° creciendo, es necesario redistribuir la carga o apagar a alguien.  En general, todo es l√≥gico y comprensible. <br><br>  <b>Paravirtualizaci√≥n versus instancias individuales</b> .  Hay una sola m√°quina virtual en el hipervisor, consume una peque√±a parte de ella, pero genera una gran carga en la entrada / salida, por ejemplo, en un disco.  Y desde alg√∫n lugar aparece un peque√±o robo, hasta un 10% (como lo demuestran varios experimentos). <br><br>  El caso es interesante.  El robo aparece aqu√≠ solo por bloqueos en el nivel de los conductores paravirtualizados.  Se crea una interrupci√≥n dentro de la m√°quina virtual, procesada por el controlador, y va al hipervisor.  Debido al procesamiento de interrupci√≥n en el hipervisor para la m√°quina virtual, parece una solicitud enviada, est√° lista para su ejecuci√≥n y esperando al procesador, pero no le dan tiempo al procesador.  Virtualka piensa que esta vez es robado. <br><br>  Esto sucede cuando se env√≠a el b√∫fer, va al espacio del kernel del hipervisor y comenzamos a esperarlo.  Aunque, desde el punto de vista de virtualka, deber√≠a regresar de inmediato.  Por lo tanto, de acuerdo con el algoritmo de c√°lculo de robo, esta vez se considera robado.  Lo m√°s probable es que en esta situaci√≥n pueda haber otros mecanismos (por ejemplo, procesar algunas otras llamadas del sistema), pero no deber√≠an ser muy diferentes. <br><br>  <b>Sheduler contra virtualoks muy cargados</b> .  Cuando una m√°quina virtual sufre de robo m√°s que otras, est√° conectada precisamente con el programador.  Cuanto m√°s fuerte sea el proceso que cargue el procesador, m√°s r√°pido lo expulsar√° el programador, para que los dem√°s tambi√©n puedan trabajar.  Si la m√°quina virtual consume un poco, casi no ve robo: su proceso honestamente se sent√≥ y esper√≥, es necesario darle m√°s tiempo.  Si la m√°quina virtual produce la carga m√°xima en todos sus n√∫cleos, a menudo es expulsada del procesador e intenta no dar mucho tiempo. <br><br>  Peor a√∫n, cuando los procesos dentro de la m√°quina virtual intentan obtener m√°s procesador, porque no pueden hacer frente al procesamiento de datos.  Entonces, el sistema operativo en el hipervisor, debido a una optimizaci√≥n honesta, le dar√° cada vez menos tiempo de procesador.  Este proceso tiene lugar como una avalancha, y el robo salta al cielo, aunque otras m√°quinas virtuales casi no lo notan.  Y cuantos m√°s n√∫cleos, peor la m√°quina cay√≥ bajo la distribuci√≥n.  En resumen, las m√°quinas virtuales muy cargadas con muchos n√∫cleos son las que m√°s sufren. <br><br>  <b>Baja LA, pero hay un robo</b> .  Si LA es aproximadamente 0.7 (es decir, el hipervisor parece estar subcargado), pero se observa robo dentro de m√°quinas virtuales individuales: <br><br><ul><li>  La opci√≥n descrita anteriormente con paravirtualizaci√≥n.  Una m√°quina virtual puede recibir m√©tricas que apuntan a robar, aunque todo est√° bien con el hipervisor.  Seg√∫n los resultados de nuestros experimentos, dicha opci√≥n de robo no supera el 10% y no deber√≠a tener un impacto significativo en el rendimiento de la aplicaci√≥n dentro de la m√°quina virtual. <br></li><li>  El par√°metro LA se considera incorrectamente.  M√°s precisamente, en cada momento particular se considera cierto, pero cuando se promedia durante un minuto, resulta subestimado.  Por ejemplo, si una m√°quina virtual consume todos sus procesadores durante exactamente medio minuto por tercio del hipervisor, entonces LA por minuto ser√° 0.15 en el hipervisor;  cuatro de estas m√°quinas virtuales que trabajan simult√°neamente dar√°n 0.6.  Y el hecho de que durante medio minuto en cada uno de ellos hubo un robo salvaje al 25% en Los √Ångeles, ya no se puede sacar. <br></li><li>  Nuevamente, debido al planificador que decidi√≥ que alguien estaba comiendo demasiado y dej√≥ que este esperara.  Mientras tanto, estoy cambiando el contexto, procesando interrupciones y haciendo otras cosas importantes del sistema.  Como resultado, algunas m√°quinas virtuales no ven ning√∫n problema, mientras que otras experimentan una grave degradaci√≥n del rendimiento. <br></li></ul><br><h2>  4. Otras distorsiones </h2><br>  Hay otro mill√≥n de razones para distorsionar el retorno honesto del tiempo de procesador en la m√°quina virtual.  Por ejemplo, hypertreading y NUMA agregan complejidad a los c√°lculos.  Confunden completamente la elecci√≥n del n√∫cleo para ejecutar el proceso, porque el planificador utiliza coeficientes, pesos, que al cambiar de contexto hacen que el c√°lculo sea a√∫n m√°s dif√≠cil. <br><br>  Hay distorsiones debidas a tecnolog√≠as como el turbo boost o, por el contrario, el modo de ahorro de energ√≠a, que al calcular la utilizaci√≥n puede aumentar o disminuir artificialmente la frecuencia o incluso el intervalo de tiempo en el servidor.  Activar el turbo boost reduce el rendimiento de un subproceso de procesador debido al mayor rendimiento de otro.  En este momento, la informaci√≥n sobre la frecuencia actual del procesador no se transmite a la m√°quina virtual y cree que alguien est√° atando su tiempo (por ejemplo, solicit√≥ 2 GHz, pero recibi√≥ la mitad). <br><br>  En general, puede haber muchas causas de distorsi√≥n.  En un sistema particular, puede encontrar algo m√°s.  Es mejor comenzar con los libros a los que les di los enlaces anteriores y tomar estad√≠sticas del hipervisor con utilidades como perf, sysdig, systemtap, de las cuales hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docenas</a> . <br><br><h2>  5. Conclusiones </h2><br><ol><li>  Una cierta cantidad de robo puede ocurrir debido a la paravirtualizaci√≥n, y puede considerarse normal.  En Internet escriben que este valor puede ser del 5-10%.  Depende de las aplicaciones dentro de la m√°quina virtual y de qu√© tipo de carga pone en sus dispositivos f√≠sicos.  Es importante prestar atenci√≥n a c√≥mo se sienten las aplicaciones dentro de las m√°quinas virtuales. <br></li><li>  La relaci√≥n de la carga en el hipervisor y el robo dentro de la m√°quina virtual no siempre est√° interconectada sin ambig√ºedades, ambas estimaciones de robo pueden ser err√≥neas en situaciones espec√≠ficas con diferentes cargas. <br></li><li>  Al programador no le gustan los procesos que piden mucho.  Intenta dar menos a los que piden m√°s.  Las grandes m√°quinas virtuales son malvadas. <br></li><li>  Un peque√±o robo puede ser la norma sin paravirtualizaci√≥n (teniendo en cuenta la carga dentro de la m√°quina virtual, las caracter√≠sticas de la carga de los vecinos, la distribuci√≥n de la carga entre subprocesos y otros factores). <br></li><li>  Si desea descubrir el robo en un sistema espec√≠fico, debe investigar varias opciones, recopilar m√©tricas, analizarlas cuidadosamente y pensar en c√≥mo distribuir la carga de manera uniforme.  Las desviaciones son posibles de cualquier caso, que debe confirmarse experimentalmente o verse en el depurador del n√∫cleo. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449316/">https://habr.com/ru/post/449316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449306/index.html">12 palabras en ingl√©s que a menudo se escriben y se escriben incorrectamente</a></li>
<li><a href="../449308/index.html">Presentaci√≥n de Microsoft Azure DevTest Labs</a></li>
<li><a href="../449310/index.html">Citymobil: un manual para mejorar la disponibilidad en medio del crecimiento del negocio para las nuevas empresas. Parte 2</a></li>
<li><a href="../449312/index.html">RAID de hardware: caracter√≠sticas de uso</a></li>
<li><a href="../449314/index.html">Inmigraci√≥n independiente: lo que necesita saber</a></li>
<li><a href="../449318/index.html">C√≥mo el √©xito de Fortnite llev√≥ a meses de intensa crisis en Epic Games</a></li>
<li><a href="../449320/index.html">C√≥mo ha cambiado la seguridad de la informaci√≥n en los √∫ltimos 20 a√±os</a></li>
<li><a href="../449322/index.html">Redes de TV por cable para los m√°s peque√±os. Parte 1: arquitectura general de la red KTV</a></li>
<li><a href="../449324/index.html">Cargas, tel√©fonos inteligentes, compa√±√≠as gigantes: programa Piter Heisenbug 2019</a></li>
<li><a href="../449326/index.html">WebRTC y video vigilancia: c√≥mo vencimos el retraso del video de las c√°maras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>