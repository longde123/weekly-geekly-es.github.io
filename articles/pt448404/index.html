<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîï ‚òïÔ∏è üå† Como acelerar o trabalho com a API da linguagem R usando computa√ß√£o paralela, usando o exemplo da API Yandex.Direct (parte 2) üî∑ ‚óæÔ∏è üï¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo artigo, falei sobre o que √© multithreading e dei exemplos de sua implementa√ß√£o na linguagem R ao trabalhar com a API Yandex.Direct usando os...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como acelerar o trabalho com a API da linguagem R usando computa√ß√£o paralela, usando o exemplo da API Yandex.Direct (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> No √∫ltimo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo,</a> falei sobre o que √© multithreading e dei exemplos de sua implementa√ß√£o na linguagem R ao trabalhar com a API Yandex.Direct usando os <code>doParallel</code> , <code>doParallel</code> e <code>foreach</code> . </p><br><p>  Este artigo √© uma continua√ß√£o, mas pode ser considerado um guia offline para multithreading em R. Fui solicitado a escrev√™-lo pelos coment√°rios recebidos na primeira parte (aqui, um agradecimento especial a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Ananiev_Genrih</a> ), no qual recebi v√°rios pacotes que representam uma abordagem mais moderna implementa√ß√µes de multithreading em R, falaremos sobre elas mais tarde. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desafio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Prepara√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplo de solu√ß√£o de processamento serial, fun√ß√£o sapply e pacote purrr</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√£o Sapply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote Purrr</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Op√ß√µes multithread para resolver a tarefa de coletar palavras-chave do Yandex.Direct</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote paralelo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote futuro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inv√≥lucros sobre o futuro</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote Future.apply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote Furrr</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de velocidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√£o</a> </li><li>  Enquete </li></ul><br><h1 id="zadacha">  Desafio </h1><br><p>  Como exemplo, consideramos o problema considerado em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o anterior</a> , ou seja,  no modo multithread, colete uma lista de palavras-chave de 4 contas de publicidade Yandex.Direct. </p><br><p>  Para trabalhar com a API Yandex.Direct, usaremos o pacote <code>ryandexdirect</code> .  A documenta√ß√£o oficial est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> , mas para a implementa√ß√£o da tarefa descrita, precisamos de apenas 2 fun√ß√µes: </p><br><ul><li>  <code>yadirAuth</code> - autoriza√ß√£o na API Yandex.Direct; </li><li>  <code>yadirGetKeyWords</code> - fa√ßa o download de uma lista de palavras-chave de contas de an√∫ncios. </li></ul><br><p>  N√£o escolhi apenas o processo de download de palavras-chave, o fato √© que essa √© uma das opera√ß√µes mais demoradas na API Yandex.Direct.  Em segundo lugar, em todas as contas, o n√∫mero de palavras-chave √© diferente; portanto, o tempo para concluir esta opera√ß√£o para cada conta ser√° muito diferente, no nosso caso, de 1 a 20 segundos. </p><br><h1 id="podgotovka">  Prepara√ß√£o </h1><br><p>  Inicialmente, voc√™ precisa instalar todos os pacotes discutidos neste artigo, para isso voc√™ pode usar o c√≥digo abaixo. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 1: Instalando Pacotes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Para que as fun√ß√µes do pacote estejam dispon√≠veis, voc√™ deve conect√°-lo usando o comando <code>library</code> .  Por conveni√™ncia, conectarei separadamente todos os pacotes necess√°rios em cada exemplo de c√≥digo. </p><br><p>  Criamos um vetor que consiste em logins Yandex.Direct, dos quais posteriormente solicitaremos palavras-chave: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 2: Criando um vetor de logon</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Para trabalhar com a API Yandex.Direct, primeiro voc√™ precisa passar pela autoriza√ß√£o em cada conta. Para isso, voc√™ pode usar o seguinte design: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 3: autoriza√ß√£o na API Yandex.Direct</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Depois de executar o c√≥digo acima, um navegador ser√° aberto para autoriza√ß√£o em cada conta.  Voc√™ confirma a permiss√£o do <code>ryandexdirect</code> para acessar seus materiais de publicidade.  Voc√™ ser√° redirecionado para a p√°gina em que precisa copiar o c√≥digo de verifica√ß√£o.  Ao inseri-lo no console do R, conclua o processo de autoriza√ß√£o.  Esta opera√ß√£o √© repetida para cada logon especificado ao criar os logons de vetor. </p><br><p>  Alguns usu√°rios, durante o processo de autoriza√ß√£o, podem ficar confusos com o redirecionamento para um recurso de terceiros, mas n√£o h√° perigo para sua conta. Descrevi esse t√≥pico com mais detalhes no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Qu√£o seguro √© usar pacotes R para trabalhar com APIs de sistemas de publicidade"</a> . </p><br><p>  Al√©m disso, consideraremos v√°rios exemplos da implementa√ß√£o da tarefa descrita.  Cada um dos quais come√ßar√° com um c√≥digo de exemplo e sua explica√ß√£o adicional.  Eu acho que essa op√ß√£o ser√° mais conveniente para a percep√ß√£o. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Exemplo de solu√ß√£o de processamento serial, fun√ß√£o sapply e pacote purrr </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo</a> , citei uma solu√ß√£o usando o loop <code>for</code> como exemplo.  Como consideramos o multithreading usando o pacote <code>foreach</code> , cuja sintaxe se assemelha a loops, este exemplo foi apropriado l√°, embora o uso de loops n√£o seja bem-vindo pelos usu√°rios de R. </p><br><p>  Os pacotes que consideraremos neste artigo s√£o mais remanescentes das fun√ß√µes da fam√≠lia apply na sintaxe; portanto, darei um exemplo de solu√ß√£o em modo serial usando-os. </p><br><h3 id="funkciya-sapply">  Fun√ß√£o <code>sapply</code> </h3><br><blockquote>  Para estimar o tempo de execu√ß√£o dos comandos, em cada uma das abordagens consideradas, usaremos o pacote <code>tictoc</code> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 4: Exemplo de solu√ß√£o no modo seq√ºencial usando a fun√ß√£o sapply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  Tempo de <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  A princ√≠pio, a sintaxe das fun√ß√µes da fam√≠lia <code>apply</code> n√£o √© t√£o f√°cil de ler quanto a sintaxe dos loops, mas, na verdade, tudo √© bastante simples. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  Onde: </p><br><ul><li>  <em>X</em> - Um objeto cujos elementos iremos iterar e usar a cada itera√ß√£o, em um loop for, era assim: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> - Uma fun√ß√£o na qual substituiremos cada elemento do objeto <em>X</em> por sua vez, se fizermos uma analogia com <code>for</code> , ent√£o esse √© o corpo do loop. </li></ul><br><p>  No exemplo de <strong>c√≥digo 4</strong> , o vetor de <em>logons</em> criado anteriormente √© passado para o argumento <em>X.</em>  Cada elemento do vetor <em>logins</em> √© passado por sua vez, como o √∫nico argumento para a fun√ß√£o an√¥nima <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> que foi passada para o argumento <em>FUN</em> . </p><br><p>  I.e.  <code>sapply</code> executar√° a fun√ß√£o especificada no <em>FUN</em> 4 vezes, substituindo os logins nela uma a uma e retornando o resultado na forma de uma lista (objeto da <em>lista</em> de classes) composta por 4 elementos.  Cada elemento √© uma tabela com uma lista de palavras-chave recebidas da conta a cada itera√ß√£o. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  O objeto obtido usando <code>sapply</code> possui a seguinte estrutura: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  No final deste exemplo, o comando <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> combina todos os 4 elementos da lista <em>kw.sapply</em> em um quadro <em>result.sapply</em> . </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  Al√©m do <code>sapply</code> , a fam√≠lia de fun√ß√µes <code>*apply</code> inclui: <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> e outros. </p><br><h3 id="paket-purrr">  Pacote <code>purrr</code> </h3><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 5: Exemplo de solu√ß√£o usando as fun√ß√µes do pacote purrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  Tempo de <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  O pacote <code>purrr</code> faz parte do n√∫cleo da biblioteca <code>tidyverse</code> , de autoria de Headley Wickham. </p><br><p>  Em significado e sintaxe, as principais fun√ß√µes do pacote s√£o muito semelhantes ao <code>sapply</code> , sua principal vantagem √© a seguinte: </p><br><ul><li>  As fun√ß√µes s√£o divididas em fam√≠lias <code>map</code> , <code>pmap</code> , <code>pmap</code> , <code>walk</code> etc., fun√ß√µes separadas inclu√≠das na mesma fam√≠lia retornam o resultado em diferentes formatos: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> , etc; </li><li>  As fun√ß√µes da fam√≠lia <code>map2</code> sobre elementos (iterar) simultaneamente de dois objetos; </li><li>  As fun√ß√µes da fam√≠lia <code>pmap</code> simultaneamente os elementos de qualquer n√∫mero de objetos.  Voc√™ pode passar uma tabela para a entrada do argumento <em>.l</em> <em>(um an√°logo do argumento X em sapply)</em> , cada coluna contendo os valores pelos quais voc√™ iterar√° e que ser√£o substitu√≠dos por sua vez nos argumentos da mesma fun√ß√£o passada em <em>.f</em> <em>(o anal√≥gico FUN de sapply)</em> . </li></ul><br><p>  Em que situa√ß√£o precisamos iterar sobre elementos de v√°rios objetos.  Por exemplo, voc√™ trabalha com v√°rias contas de agente e as contas de publicidade das quais deseja obter uma lista de palavras-chave est√£o espalhadas entre elas.  Nesse caso, voc√™ pode criar um vetor a partir dos nomes das contas dos agentes e iter√°-lo, paralelamente √† forma como classifica os logins das contas de publicidade. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 6: Exemplo de trabalho com v√°rias contas de agente</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Agora imagine a situa√ß√£o em que, ao fazer login em contas diferentes, voc√™ salvou o arquivo com as credenciais em pastas diferentes e precisa iterar imediatamente em tr√™s objetos: logins de contas de publicidade, logon de contas de agente, o caminho no qual o arquivo com credenciais √© armazenado.  Isso pode ser feito com ajuda.  <code>pmap</code> fam√≠lia <code>pmap</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 7: exemplo de fun√ß√£o pmap</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  Assim, o resultado da execu√ß√£o das fun√ß√µes <code>map_df</code> , <code>map2_df</code> e <code>pmap_df</code> √© o per√≠odo e, ao us√°-las, a √∫ltima etapa do exemplo com <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ) n√£o √© necess√°ria. </p><br><p>  O c√≥digo tornou-se mais compacto e executado um pouco mais r√°pido, mas, no entanto, as duas abordagens descritas, <code>sapply</code> e <code>purrr</code> , coletam palavras-chave de cada conta sequencialmente.  Portanto, o tempo total de execu√ß√£o dessa opera√ß√£o √© igual √† soma das dura√ß√µes da coleta de dados das quatro contas. </p><br><p>  <strong>Tempo [total]</strong> = <em>Tempo [login1] + Tempo [login2] + Tempo [login3] + Tempo [login4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Op√ß√µes multithread para resolver a tarefa de coletar palavras-chave do Yandex.Direct </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Portanto, se voc√™ j√° leu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo</a> , sabe que o modo de opera√ß√£o multithread possui v√°rios recursos: </p><br><ul><li>  Cada encadeamento inicia em uma sess√£o R separada com um ambiente de trabalho limpo. </li><li>  Pelo mesmo motivo, em um processo em execu√ß√£o separado, os pacotes conectados anteriormente n√£o s√£o transmitidos por padr√£o. </li></ul><br><p>  A exporta√ß√£o de objetos criados em um ambiente de trabalho e a conex√£o de pacotes em cada abordagem s√£o implementadas de maneira diferente; ent√£o, n√≥s os consideraremos com mais detalhes. </p><br><h3 id="paket-parallel">  Pacote <code>parallel</code> </h3><br><p>  Este pacote foi inclu√≠do pela primeira vez no pacote R na vers√£o 2.14.0 e at√© hoje vem com o pr√≥prio R. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 8: Exemplo de solu√ß√£o para o problema atrav√©s do pacote paralelo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  Tempo de <code>16.75 sec elapsed</code> : <code>16.75 sec elapsed</code> </p><br><p>  Vamos tentar analisar o <strong>c√≥digo 8</strong> .  A fun√ß√£o <code>makeCluster</code> cria um cluster de 4 processos.  Podemos exportar objetos do nosso ambiente de trabalho principal para o cluster criado usando a fun√ß√£o <code>clusterExport</code> ; para isso, precisamos usar seus argumentos: </p><br><ul><li>  <em>cl</em> - Cluster para o qual exportaremos objetos </li><li>  <em>varlist</em> - um vetor de texto que cont√©m os nomes dos objetos a serem exportados para cada processo de cluster. </li></ul><br><p>  Uma maneira de conectar os pacotes corretos em cada n√≥ do cluster √© usar a fun√ß√£o <code>clusterEvalQ</code> .  Em nosso exemplo, n√≥s o usamos para conectar pacotes, mas voc√™ pode escrever qualquer c√≥digo R dentro de <code>clusterEvalQ</code> , e ele ser√° iniciado no in√≠cio de cada n√≥ do cluster.  Os argumentos para esta fun√ß√£o s√£o bastante √≥bvios, voc√™ precisa especificar o cluster e os comandos que ser√£o executados nele. </p><br><p>  <code>parSapplyLB</code> √© uma vers√£o paralela da fun√ß√£o <code>sapply</code> com balanceamento de carga entre os n√≥s do cluster, eles tamb√©m a usam, mas √© necess√°rio especificar o cluster com o argumento <em>cl</em> . </p><br><p>  Tamb√©m em <code>parallel</code> existem outras vers√µes paralelas das fun√ß√µes da fam√≠lia <code>*apply</code> : <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> , etc. </p><br><p>  <code>parSapply</code> difere do <code>parSapplyLB</code> apenas no fato de n√£o possuir balanceamento de carga nos n√≥s do cluster. </p><br><p>  A fun√ß√£o <code>stopCluster</code> √© usada para parar o cluster criado. </p><br><p>  O √∫ltimo comando, <code>dplyr::bind_rows(parallel.kw)</code> combinamos o objeto <em>parallel.kw</em> obtido usando <code>parSapplyLB</code> em uma tabela. </p><br><p>  Para Linux, o <code>parallel</code> possui fun√ß√µes separadas: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  Muitas vezes, neste sistema operacional, os comandos s√£o executados mais rapidamente e o c√≥digo se torna mais compacto. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 9: Solu√ß√£o usando mclapply para Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Ao usar essas fun√ß√µes, n√£o h√° necessidade de iniciar o cluster usando o <code>makeCluster</code> .  o n√∫mero de n√≥s que voc√™ <em>especifica</em> usando o argumento <em>mc.cores</em> .  Tamb√©m n√£o √© necess√°rio conectar pacotes e exportar objetos; essas opera√ß√µes s√£o executadas automaticamente. </p><br><h3 id="paket-future">  Pacote <code>future</code> </h3><br><p>  Uma das abordagens mais modernas para programa√ß√£o ass√≠ncrona em R. </p><br><p>  Um c√≥digo que, paralelamente, resolver√° nosso problema com a ajuda do <code>future</code> √© bastante complicado de entender.  Portanto, vamos analisar seu trabalho em um exemplo mais simples, solicitaremos uma lista de palavras-chave de uma conta. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 10: O exemplo mais simples de uso do pacote futuro</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Vamos tentar descobrir o exemplo do <strong>c√≥digo 10</strong> .  A fun√ß√£o de <code>plan</code> permite definir e alterar o modo de execu√ß√£o das express√µes fornecidas, eis as principais: </p><br><ul><li>  <em>sequencial</em> - Este √© o modo usual de opera√ß√£o R. Os comandos s√£o executados sequencialmente na sess√£o atual; </li><li>  <em>multisess√£o</em> - modo paralelo, os comandos ser√£o executados nas sess√µes em execu√ß√£o em segundo plano na m√°quina atual, enquanto sua sess√£o de trabalho n√£o ser√° bloqueada; </li><li>  <em>cluster</em> - modo paralelo, os comandos ser√£o executados na m√°quina atual ou remota, semelhante √† maneira como √© implementada no pacote <code>parallel</code> . </li></ul><br><p>  Todo o pacote <code>future</code> √© baseado na execu√ß√£o de comandos em processos em segundo plano sem bloquear a sess√£o atual.  Executar a execu√ß√£o dos comandos segue a fun√ß√£o com o mesmo nome <code>future</code> , portanto, quando executamos o comando: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Nossa sess√£o atual em R n√£o √© bloqueada e o comando √© executado em segundo plano, executando outra sess√£o R. </p><br><p>  Voc√™ pode verificar o estado atual do processo de execu√ß√£o de uma determinada express√£o usando a fun√ß√£o <code>resolved</code> .  Finalmente, a fun√ß√£o <code>value</code> √© usada para obter o resultado da execu√ß√£o <code>future</code> .  Se voc√™ executar a fun√ß√£o <code>value</code> mais cedo do que sua execu√ß√£o <code>future</code> em uma sess√£o paralela, a sess√£o de trabalho atual ser√° bloqueada at√© que a express√£o da sess√£o paralela seja conclu√≠da. </p><br><p>  O exemplo de trabalho mais avan√ßado √© o uso do <code>future</code> conjunto com <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 11: Exemplo de compartilhamento de pacotes de `futuro` e` promessas`</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  O pacote <code>promises</code> fornece um conjunto de operadores de pipeline que complementam perfeitamente a funcionalidade <code>future</code> . </p><br><p>  No exemplo do <strong>C√≥digo 11</strong> , em segundo plano, iniciamos o processo de download de palavras-chave de uma conta de publicidade.  Al√©m disso, o operador do pipeline <code>%...&gt;%</code> sem bloquear a sess√£o de trabalho aguarda <code>future</code> do <code>future</code> e executa as opera√ß√µes restantes.  Como resultado da execu√ß√£o do c√≥digo, ap√≥s a conclus√£o de trabalhos <code>future</code> , o n√∫mero de palavras-chave da conta especificada ser√° exibido no console: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  No final do artigo, um exemplo mais ilustrativo de um monte de <code>future</code> e <code>promises</code> ser√° demonstrado. </blockquote><p>  Por padr√£o, o pr√≥prio pacote <code>future</code> exporta todo o espa√ßo de trabalho para cada sess√£o em execu√ß√£o paralela, mas voc√™ mesmo pode especificar uma lista de objetos para exporta√ß√£o usando o argumento <em>global</em> . </p><br><p>  Para conectar pacotes ao <code>future</code> deve passar um vetor contendo seus nomes para o argumento <em>packages</em> . </p><br><p>  Agora, voltando √† nossa tarefa, o seguinte exemplo de c√≥digo no modo paralelo carregar√° uma lista de palavras-chave de 4 contas: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 12: Um exemplo de solu√ß√£o de um problema usando o pacote futuro</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  Tempo de <code>14.83 sec elapsed</code> : <code>14.83 sec elapsed</code> </p><br><p>  Para baixar uma lista de palavras-chave no modo multithread de todas as contas de publicidade listadas nos <em>logins de</em> vetores <em>,</em> √© necess√°rio executar um <code>future</code> separado em segundo plano.  No exemplo de <strong>c√≥digo 12,</strong> implementamos isso usando a fun√ß√£o <code>lapply</code> . </p><br><p>  O resultado do trabalho <code>lapply</code> √© uma lista de <code>future</code> lan√ßados.  Voc√™ pode verificar o status de cada um usando o <code>sapply(futs, resolved)</code> , que retornar√° um vetor l√≥gico em que <em>TRUE</em> significa que o <code>future</code> cumprido e <em>FALSE</em> que o <code>future</code> est√° em andamento no momento. </p><br><p>  Para obter resultados de cada <code>future</code> , ap√≥s a conclus√£o do trabalho, usamos o <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  I.e.   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> ‚Äî     <code>%&gt;%</code> ,     .  I.e.   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> ‚Äî  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% ‚Äî      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="imagem"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448404/">https://habr.com/ru/post/pt448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448392/index.html">Duas abordagens para estruturar um gr√°fico de atividades</a></li>
<li><a href="../pt448394/index.html">Vers√£o 12 lan√ßa hoje! (E √© um grande salto para a Wolfram Language e o Mathematica)</a></li>
<li><a href="../pt448396/index.html">Preparando-se para o Hardened Runtime and Notary Service no macOS Mojave</a></li>
<li><a href="../pt448400/index.html">Netplan e como cozinh√°-lo corretamente</a></li>
<li><a href="../pt448402/index.html">Falha na migra√ß√£o da Autoridade de Certifica√ß√£o (CA) do Windows 2008R para o Windows 2012 R2</a></li>
<li><a href="../pt448408/index.html">DCIM - A chave para o gerenciamento de data center</a></li>
<li><a href="../pt448410/index.html">Os rastreadores do Google s√£o incorporados a v√°rios recursos eletr√¥nicos russos oficiais</a></li>
<li><a href="../pt448414/index.html">Laborat√≥rio dom√©stico para autocontrole ou o que comprar em um kit de geeks</a></li>
<li><a href="../pt448416/index.html">A maneira mais f√°cil de conversar no aplicativo iOS</a></li>
<li><a href="../pt448420/index.html">Da vida com o Kubernetes: como o servidor HTTP espanhol n√£o se queixou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>