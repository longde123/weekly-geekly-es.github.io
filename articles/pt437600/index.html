<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏽 🛑 🧑🏼 opencv4arts: Desenhe minha cidade, Vincent ♻️ 🍪 👩🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenCV é uma biblioteca com uma história de desenvolvimento contínuo em 20 anos. A idade em que você começa a se aprofundar, procurando um destino. Ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>opencv4arts: Desenhe minha cidade, Vincent</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/437600/"><p>  OpenCV é uma biblioteca com uma história de desenvolvimento contínuo em 20 anos.  A idade em que você começa a se aprofundar, procurando um destino.  Existem projetos baseados nisso que tornaram a vida de alguém melhor, alguém mais feliz?  Você pode fazer isso sozinho?  Em busca de respostas e um desejo de descobrir módulos OpenCV anteriormente desconhecidos, quero criar aplicativos que “funcionem lindamente” - para que, a princípio, exista “uau” e só então você diga “ah, sim, é visão computacional”. </p><br><p>  O direito do primeiro artigo foi um experimento com a transferência de estilos de artistas mundiais em fotografia.  No artigo, você aprenderá qual é o coração do procedimento e sobre o relativamente novo OpenCV.js - a versão JavaScript da biblioteca OpenCV. </p><br><p><img src="https://habrastorage.org/webt/bd/gi/zx/bdgizx8meb6hqmshphkkpsonuee.jpeg"></p><a name="habracut"></a><br><h2 id="style-transfer">  Transferência de estilo </h2><br><p>  Os oponentes do aprendizado de máquina vão me perdoar, mas o principal componente do artigo de hoje será uma profunda rede convolucional.  Porque funciona.  Não há como treinar redes neurais no OpenCV, mas você pode executar modelos existentes.  Usaremos a rede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CycleGAN</a> pré- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">treinada</a> .  Os autores, pelos quais são muito gratos, oferecem redes totalmente gratuitas para baixar imagens que convertem imagens de maçãs em laranjas, cavalos em zebras, imagens de satélite em mapas, fotos de inverno em fotos de verão e muito mais.  Além disso, o procedimento de treinamento em rede permite que você tenha dois modelos de gerador trabalhando nas duas direções ao mesmo tempo.  Ou seja, ensinando a transformação do inverno no verão, você obterá um modelo para pintar paisagens de inverno em fotografias de verão.  Uma oferta única que é impossível recusar. </p><br><p>  No nosso exemplo, tomamos modelos que transformam fotos em pinturas de artistas.  Ou seja, Vincent Van Gogh, Claude Monet, Paul Cezanne ou em todo o gênero de gravuras japonesas Ukiyo-e.  Ou seja, teremos quatro redes separadas à nossa disposição.  Vale ressaltar que, para o treinamento de cada um, não foi usada uma foto do artista, mas toda uma multidão; assim, os autores tentaram treinar a rede neural para não mudar o estilo de uma obra, mas, por assim dizer, adotar o estilo de escrita. </p><br><h2 id="opencvjs">  Opencv.js </h2><br><p>  O OpenCV é uma biblioteca desenvolvida em C ++, enquanto na maior parte de sua funcionalidade existe a possibilidade de criar wrappers automáticos que chamam métodos nativos.  Oficialmente, os wrappers para as linguagens Python e Java são suportados.  Além disso, existem soluções personalizadas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP</a> .  Se você tem experiência no uso de outros idiomas, seria ótimo saber em qual e graças a quais esforços. </p><br><p> O OpenCV.js é um projeto que ganhou direito à vida graças ao programa Google Summer of Code em 2017.  A propósito, uma vez que o próprio módulo de aprendizado profundo OpenCV foi criado e melhorado significativamente em sua estrutura.  Diferentemente de outras linguagens, o OpenCV.js no momento não é um invólucro de métodos nativos em JavaScript, mas uma compilação completa usando o Emscripten usando o LLVM e o Clang.  Ele permite que você crie um arquivo a partir do aplicativo ou da biblioteca C e C ++ <code>.js</code> que pode ser executado, por exemplo, em um navegador. </p><br><p>  Por exemplo, </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main(int argc, char** argv) { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Compilando no <code>asm.js</code> </p><br><pre> <code class="plaintext hljs">emcc main.cpp -s WASM=0 -o main.js</code> </pre> <br><p>  E carregar: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote><img src="https://habrastorage.org/webt/pt/pp/bx/ptppbxsjtgxqe48qlfpxho0umaa.png"></blockquote><p>  Você pode conectar o OpenCV.js ao seu projeto da seguinte maneira (criação noturna): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/opencv.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Uma biblioteca adicional para leitura de imagens, trabalhando com a câmera e outras coisas, escrita manualmente em JavaScript, também pode ser útil: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/utils.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="zagruzka-izobrazheniy">  Carregar Imagens </h2><br><p>  As imagens no OpenCV.js podem ser lidas a partir de elementos como <code>canvas</code> ou <code>img</code> .  Isso significa que o download direto de arquivos de imagem para eles continua sendo uma tarefa do usuário.  Por conveniência, a função auxiliar <code>addFileInputHandler</code> carrega automaticamente a imagem no elemento de <code>canvas</code> desejado quando uma imagem é selecionada no disco com o clique de um botão. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> utils = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Utils(<span class="hljs-string"><span class="hljs-string">''</span></span>); utils.addFileInputHandler(<span class="hljs-string"><span class="hljs-string">'fileInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>);</code> </pre> <br><p>  onde </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fileInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">accept</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image/*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvasInput"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O ponto importante é que <code>img</code> será uma imagem RGBA de 4 canais, que difere do <code>cv::imread</code> usual, que cria uma imagem BGR.  Isso deve ser levado em consideração, por exemplo, ao transportar algoritmos de outros idiomas. </p><br><p>  Com a renderização, tudo é simples - basta chamar <code>imshow</code> com o <code>id</code> <code>canvas</code> desejada (espera RGB ou RGBA). </p><br><pre> <code class="javascript hljs">cv.imshow(<span class="hljs-string"><span class="hljs-string">"canvasOutput"</span></span>, img);</code> </pre> <br><h3 id="algoritm">  Algoritmo </h3><br><p>  Todo o algoritmo de processamento de imagem é o lançamento de uma rede neural.  Suponha que o que acontece dentro permaneça mágico, precisamos apenas preparar a entrada correta e interpretar a previsão corretamente (saída da rede). </p><br><p>  A rede considerada neste exemplo recebe um tensor quadridimensional com valores de <code>float</code> no intervalo <code>[-1, 1]</code> .  Cada uma das dimensões, em ordem de velocidade de mudança, é o índice da imagem, canais, altura e largura.  Esse estilo é chamado NCHW, e o próprio tensor é chamado de blob, objeto grande binário.  A tarefa de pré-processamento é converter uma imagem OpenCV, cujas intensidades são intercaladas, tem um intervalo de valores <code>[0, 255]</code> tipo <code>unsigned char</code> em um blob NCHW com um intervalo de valores <code>[-1, 1]</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/yi/yo/biyiyoyp35oyopnpk3zb3yzohzm.jpeg"><br>  <em>um pedaço do Kremlin de Nizhny Novgorod (como uma pessoa vê)</em> </p><br><p><img src="https://habrastorage.org/webt/qq/ju/nf/qqjunf_3hmkujx9ano4ordvwdtc.jpeg"><br>  <em>visualização intercalada (como o OpenCV armazena)</em> </p><br><p><img src="https://habrastorage.org/webt/cc/z3/ln/ccz3lnfgrpn-tju9bbtk3qvlhdg.jpeg"><br>  <em>visão plana (o que a rede precisa)</em> </p><br><p>  Como pós-processamento, será necessário executar as transformações inversas: a rede retorna um blob NCHW com valores no intervalo <code>[-1, 1]</code> , que devem ser reembalados na imagem, normalizados para <code>[0, 255]</code> e convertidos em <code>unsigned char</code> . </p><br><p>  Assim, levando em consideração todos os recursos de leitura e gravação de imagens do OpenCV.js, as seguintes etapas estão tomando forma: </p><br><pre> <code class="plaintext hljs">imread -&gt; RGBA -&gt; BGR [0, 255] -&gt; NCHW [-1, 1] -&gt; [] [] -&gt; NCHW [-1, 1] -&gt; RGB [0, 255] -&gt; imshow</code> </pre> <br><p>  Olhando para o pipeline resultante, surgem perguntas, por que a rede não pode funcionar imediatamente em RGBA intercalado e retornar RGB intercalado?  Por que são necessárias transformações extras para permutação e normalização de pixels?  A resposta é que uma rede neural é um objeto matemático que realiza transformações nos dados de entrada de uma determinada distribuição.  No nosso caso, ela foi treinada para receber dados neste formulário, portanto, para obter os resultados desejados, é necessário reproduzir o pré-processamento que os autores utilizaram no treinamento. </p><br><h3 id="realizaciya">  Implementação </h3><br><p>  A rede neural que executaremos é armazenada na forma de um arquivo binário, que deve primeiro ser carregado no sistema de arquivos local. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> net; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>; utils.createFileFromUrl(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>, url, () =&gt; { net = cv.readNet(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>); });</code> </pre> <br><p>  A propósito, <code>url</code> é um link completo para o arquivo.  Nesse caso, apenas carregamos o arquivo ao lado da página HTML atual, mas você pode substituí-lo pela <a href="">fonte original</a> (nesse caso, o tempo de download pode ser maior). </p><br><p>  Lendo uma imagem da <code>canvas</code> e convertendo de RGBA para BGR: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgRGBA = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgBGR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cv.Mat(imgRGBA.rows, imgRGBA.cols, cv.CV_8UC3); cv.cvtColor(imgRGBA, imgBGR, cv.COLOR_RGBA2BGR);</code> </pre> <br><p>  Criando um blob 4D em que a função <code>blobFromImage</code> converte em um <code>float</code> dados <code>float</code> usando constantes de normalização.  Então - inicie a rede. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = cv.blobFromImage(imgBGR, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">127.5</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  {width: imgBGR.cols, height: imgBGR.rows}, //  [127.5, 127.5, 127.5, 0]); //   net.setInput(blob); var out = net.forward();</span></span></code> </pre> <br><p>  O resultado é convertido novamente na imagem do tipo desejado e no intervalo de valores <code>[0, 255]</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     [-1, 1]  [0, 255] var outNorm = new cv.Mat(); out.convertTo(outNorm, cv.CV_8U, 127.5, 127.5); //  interleaved   planar  var outHeight = out.matSize[2]; var outWidth = out.matSize[3]; var planeSize = outHeight * outWidth; var data = outNorm.data; var b = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(0, planeSize)); var g = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(planeSize, 2 * planeSize)); var r = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(2 * planeSize, 3 * planeSize)); var vec = new cv.MatVector(); vec.push_back(r); vec.push_back(g); vec.push_back(b); var rgb = new cv.Mat(); cv.merge(vec, rgb); //   cv.imshow("canvasOutput", rgb);</span></span></code> </pre> <br><p>  No momento, o OpenCV.js está sendo construído no modo semi-automático.  No sentido em que nem todos os módulos e métodos deles recebem as assinaturas correspondentes em JavaScript.  Por exemplo, para um módulo dnn, a lista de funções válidas é definida da seguinte maneira: </p><br><pre> <code class="python hljs">dnn = {<span class="hljs-string"><span class="hljs-string">'dnn_Net'</span></span>: [<span class="hljs-string"><span class="hljs-string">'setInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'forward'</span></span>], <span class="hljs-string"><span class="hljs-string">''</span></span>: [<span class="hljs-string"><span class="hljs-string">'readNetFromCaffe'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTensorflow'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTorch'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromDarknet'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromONNX'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNet'</span></span>, <span class="hljs-string"><span class="hljs-string">'blobFromImage'</span></span>]}</code> </pre> <br><p>  A última conversão, dividindo o blob em três canais e depois misturando-os em uma imagem, pode ser realizada com a <code>imagesFromBlob</code> método <code>imagesFromBlob</code> , que simplesmente ainda não foi adicionado à lista acima.  Talvez essa seja sua primeira contribuição ao desenvolvimento do OpenCV?  ;) </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Como demonstração, preparei uma página no GitHub onde você pode testar o código resultante: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://dkurtaev.github.io/opencv4arts</a> (Cuidado! Ao fazer o download de uma rede de cerca de 22 MB, economize seu tráfego. Também é recomendável recarregar a página para cada nova imagem, caso contrário, a qualidade processamento subsequente é de alguma forma fortemente distorcido).  Esteja preparado para um longo processo de processamento ou tente redimensionar a imagem, que será o resultado, um controle deslizante. </p><br><p>  Enquanto trabalhava no artigo e escolhia a própria imagem que se tornaria o rosto dela, acidentalmente encontrei uma foto do meu amigo, que retrata o Kremlin de nossa cidade e tudo se encaixou - surgiu com o nome do artigo e só então senti que deveria ser assim.  Sugiro que você experimente o aplicativo nas fotos do seu lugar favorito e, talvez, conte algo interessante sobre isso nos comentários ou em uma carta pessoal. </p><br><p>  De mim - um fato divertido.  A maioria dos residentes de Nizhny Novgorod e da região de Nizhny Novgorod usa a palavra “sair” no sentido da palavra “encaixar-se” (encontre um local gratuito).  Por exemplo, a pergunta "Vamos limpar seu carro?"  significa "Temos espaço suficiente no seu carro?", mas não "Podemos limpar o seu carro?".  Quando estudantes de outras áreas nos procuram para estágios de verão, gostamos de contar esse fato - muitos ficam sinceramente surpresos. </p><br><h2 id="poleznye-ssylki">  Links úteis </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documentação do OpenCV.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelos CycleGAN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros modelos de transferência de estilo</a> (diferem na normalização) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437600/">https://habr.com/ru/post/pt437600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437590/index.html">Números de latência no iPhone</a></li>
<li><a href="../pt437592/index.html">Arquitetura assíncrona da camada de execução de tarefas</a></li>
<li><a href="../pt437594/index.html">Como eu erradiquei a causa da gagueira e do salto de quadros em todos os jogos e também reduzi acidentalmente a temperatura em 15 graus</a></li>
<li><a href="../pt437596/index.html">OTRS: autenticação, autorização e sincronização LDAP (FreeIPA, AD)</a></li>
<li><a href="../pt437598/index.html">Como salvar o sistema de jogo do PC doméstico por meio da virtualização</a></li>
<li><a href="../pt437602/index.html">Perfil de um projeto do Unity com o Android Studio</a></li>
<li><a href="../pt437604/index.html">Colapso da função de onda: um algoritmo inspirado na mecânica quântica</a></li>
<li><a href="../pt437606/index.html">Quem come a memória do nosso iPhone? Descascar maçãs</a></li>
<li><a href="../pt437610/index.html">20 anos de carreira em programação em uma grande cidade pequena</a></li>
<li><a href="../pt437612/index.html">A gigante de TI lidará com fotônica de silício - como isso afetará o mercado de equipamentos de rede</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>