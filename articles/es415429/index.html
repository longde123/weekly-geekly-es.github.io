<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游땗 游꼝 游녥游낕 Toda la verdad sobre RTOS de Colin Walls. Art칤culo # 5. Interacci칩n de tareas y sincronizaci칩n 游땖 游볩 游뱕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art칤culos anteriores, examinamos el modelo multitarea y descubrimos que cada tarea es un programa casi independiente. Aunque las tareas en los sist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS de Colin Walls. Art칤culo # 5. Interacci칩n de tareas y sincronizaci칩n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415429/"><img src="https://habrastorage.org/webt/b6/2h/cm/b62hcmzcfpnzqg0tz4pzveimzmw.jpeg"><br><br>  En art칤culos anteriores, examinamos el modelo multitarea y descubrimos que cada tarea es un programa casi independiente.  Aunque las tareas en los sistemas integrados tienen un cierto grado de independencia, esto no significa que no se "conozcan" entre s칤.  Algunas tareas estar치n realmente aisladas de otras, pero la interacci칩n y sincronizaci칩n entre ellas es un requisito com칰n.  Este mecanismo es una de las funciones clave del RTOS.  El rango de funciones puede variar seg칰n el RTOS, por lo tanto, en este art칤culo consideraremos las opciones disponibles p칰blicamente. <br><a name="habracut"></a><br>  Art칤culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art칤culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art칤culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci칩n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art칤culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art칤culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci칩n.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><h3>  <b>Rango de funciones</b> </h3><br>  Hay tres modelos de interacci칩n y sincronizaci칩n entre tareas: <br><br><ul><li>  Los servicios est치n vinculados a tareas: RTOS proporciona tareas con atributos que proporcionan interacci칩n entre ellos.  Considere las se침ales como un ejemplo. </li><li>  Los objetos del n칰cleo son medios aut칩nomos de comunicaci칩n o sincronizaci칩n.  Ejemplos: banderas de eventos, buzones, colas / canales, sem치foros y mutexes. </li><li>  La mensajer칤a es un esquema simplificado en el que el RTOS le permite crear objetos de mensaje y transferirlos de una tarea a otra o varias.  Esto es fundamental para la arquitectura del n칰cleo y, por lo tanto, dicho sistema se denomina "mensajes RTOS". </li></ul><br>  Los mecanismos que son ideales para diferentes procesos variar치n.  Sus capacidades pueden superponerse, por lo que vale la pena considerar la escalabilidad de estos modelos.  Por ejemplo, si una aplicaci칩n requiere varias colas, pero solo un buz칩n, puede implementar un buz칩n con una cola para un elemento.  Este objeto no ser치 completamente 칩ptimo, pero el c칩digo completo del buz칩n no se incluir치 en la aplicaci칩n y, por lo tanto, la escalabilidad reducir치 la cantidad de memoria utilizada por el RTOS. <br><br><h3>  <b>Variables comunes o 치reas de memoria</b> </h3><br>  Un enfoque simplificado para la interacci칩n entre tareas es la presencia en el sistema de variables o 치reas de memoria que est치n disponibles para todas las tareas.  Este enfoque se puede aplicar a varios procesos, a pesar de su simplicidad.  El acceso debe ser controlado.  Si la variable es solo un byte, es probable que escribir en ella o leerla sea una operaci칩n at칩mica (es decir, continua), pero se debe tener cuidado si el procesador permite otras operaciones en bytes de memoria, ya que pueden ser interrumpibles y pueden ocurrir problema de sincronizaci칩n  Una forma de implementar el bloqueo / desbloqueo es deshabilitar las interrupciones por un corto tiempo. <br><br>  Si usa un 치rea de memoria, a칰n necesita un candado.  Puede usar el primer byte como indicador de bloqueo, dado que la arquitectura de memoria proporciona acceso at칩mico a este byte.  Una tarea carga datos en un 치rea de memoria, establece un indicador y luego espera a que se restablezca.  Otra tarea es esperar a que se establezca el indicador, leer datos y restablecer el indicador.  Usar la desactivaci칩n de interrupci칩n como bloqueo es menos sensato ya que mover todo el b칰fer de datos puede llevar algo de tiempo. <br><br>  Este uso de memoria compartida es similar a la implementaci칩n de muchas comunicaciones entre procesadores en sistemas de m칰ltiples n칰cleos.  En algunos casos, el bloqueo y / o la interrupci칩n del hardware est치n integrados en la interfaz interprocesadora de la memoria compartida. <br><br><h3>  <b>Se침ales</b> </h3><br>  Las se침ales son uno de los mecanismos m치s simples para la interacci칩n entre tareas que ofrece RTOS tradicional.  Contienen un conjunto de indicadores de bits (8, 16 o 32, seg칰n la aplicaci칩n espec칤fica), que est치 asociado con una tarea espec칤fica. <br>  El indicador de se침al (o varios indicadores) se puede establecer mediante cualquier tarea utilizando la operaci칩n l칩gica "O".  Los indicadores solo pueden ser le칤dos por una tarea que contiene una se침al.  El proceso de lectura suele ser destructivo, es decir, los indicadores tambi칠n se restablecen. <br>  En algunos sistemas, las se침ales se implementan de una manera m치s compleja, de modo que una funci칩n especial asignada por el propietario de la tarea de la se침al se ejecuta autom치ticamente cuando se activa cualquier se침al de se침al.  Esto elimina la necesidad de que la tarea controle las banderas en s칤.  Esto es algo similar a un controlador de interrupciones. <br><br><h3>  <b>Grupos de banderas de eventos</b> </h3><br>  Los grupos de indicadores de eventos son similares a las se침ales en el sentido de que son una herramienta orientada a bits para la interacci칩n entre tareas.  Del mismo modo, pueden contener 8, 16 o 32 bits.  A diferencia de las se침ales, son objetos centrales independientes y no "pertenecen" a ninguna tarea en particular.  Cualquier tarea puede establecer y restablecer indicadores de evento utilizando las operaciones l칩gicas "OR" y "AND".  Del mismo modo, cualquier tarea puede verificar indicadores de eventos utilizando las mismas operaciones.  En muchos RTOS, puede realizar una llamada de API de bloqueo para una combinaci칩n de indicadores de evento.  Es decir, la tarea puede suspenderse hasta que se establezca una combinaci칩n espec칤fica de indicadores de evento.  La opci칩n "consumir" tambi칠n puede estar disponible al verificar las banderas de eventos, que restablece todas las banderas. <br><br><h3>  <b>Sem치foros</b> </h3><br>  Los sem치foros son objetos de kernel independientes utilizados para la contabilidad de recursos.  Hay dos tipos de sem치foros: binario (puede tener solo dos valores) y general (n칰mero ilimitado de valores).  Algunos procesadores admiten instrucciones (at칩micas) que facilitan la implementaci칩n r치pida de sem치foros binarios.  Los sem치foros binarios se pueden implementar como sem치foros generales con un valor de 1. <br><br>  Cualquier tarea puede intentar asignar un sem치foro para obtener acceso al recurso.  Si el valor actual del sem치foro es mayor que 0 (el sem치foro es libre), el valor del contador se reduce en 1, por lo tanto, la asignaci칩n ser치 exitosa.  En muchos sistemas operativos, se puede utilizar un mecanismo de bloqueo para asignar un sem치foro.  Esto significa que la tarea puede estar en estado de espera hasta que otra tarea libere el sem치foro.  Cualquier tarea puede liberar el sem치foro, y luego el valor del sem치foro aumentar치. <br><br><h3>  <b>Buzones</b> </h3><br>  Los buzones son objetos independientes del n칰cleo que proporcionan los medios para enviar mensajes.  El tama침o del mensaje depende de la implementaci칩n, pero generalmente es fijo.  Los tama침os de mensaje t칤picos son de uno a cuatro elementos del tama침o de un puntero.  Por lo general, se env칤a un puntero a datos m치s complejos a trav칠s del buz칩n.  Algunos n칰cleos implementan buzones de tal manera que los datos simplemente se almacenan en una variable regular y el n칰cleo controla el acceso a ellos.  Los buzones tambi칠n se pueden llamar "intercambio", aunque este nombre ahora rara vez se ve. <br><br>  Cualquier tarea puede enviar mensajes a un buz칩n, que luego se rellena.  Si una tarea intenta enviar un mensaje a un buz칩n completo, recibir치 una respuesta de error.  En muchos RTOS, puede usar un mecanismo de bloqueo para enviar al buz칩n.  Esto significa que la tarea se suspender치 hasta que se lea el mensaje en el buz칩n.  Cualquier tarea puede leer mensajes del buz칩n, despu칠s de lo cual est치 vac칤o.  Si una tarea intenta leer desde un buz칩n vac칤o, recibir치 una respuesta de error.  En muchos RTOS, puede usar una llamada de bloqueo para leer desde un buz칩n.  Esto significa que la tarea se suspender치 hasta que aparezca un nuevo mensaje en el buz칩n. <br><br>  Algunos RTOS admiten la funci칩n de "transmisi칩n".  Esto le permite enviar mensajes a todas las tareas que est치n actualmente en pausa mientras lee un buz칩n espec칤fico. <br><br>  Algunos RTOS no admiten buzones en absoluto.  En cambio, se recomienda que use una cola de un solo elemento.  Esto es funcionalmente equivalente, pero conlleva una sobrecarga adicional para la memoria y el tiempo de ejecuci칩n. <br><br><h3>  <b>Colas</b> </h3><br>  Las colas son objetos de kernel independientes que proporcionan un mecanismo para enviar mensajes.  Son un poco m치s flexibles y complejos que los buzones.  El tama침o del mensaje depende de la implementaci칩n, pero generalmente es fijo y est치 orientado a la palabra / puntero. <br><br>  Cualquier tarea puede enviar mensajes a la cola, y esto puede repetirse hasta que la cola est칠 llena, despu칠s de lo cual cualquier intento de env칤o dar치 como resultado un error.  La longitud de la cola generalmente la determina el usuario al crear o configurar el sistema.  En muchos RTOS, puede aplicar un mecanismo de bloqueo a la cola.  Es decir, si la cola est치 llena, la tarea puede suspenderse hasta que otra tarea lea el mensaje en la cola.  Cualquier tarea puede leer mensajes de la cola.  Los mensajes se leen en el mismo orden en que se enviaron (Primero en entrar - Primero en salir, FIFO).  Si una tarea intenta leer desde una cola vac칤a, recibir치 una respuesta de error.  En muchos RTOS, se puede usar un mecanismo de bloqueo para leer desde una cola vac칤a.  Es decir, si la cola est치 vac칤a, la tarea puede suspenderse hasta que otra tarea env칤e el mensaje a la cola. <br><br>  Lo m치s probable es que haya un mecanismo en el RTOS para enviar un mensaje al frente de la cola, esto se llama interferencia.  Algunos RTOS tambi칠n admiten la funci칩n de transmisi칩n.  Esto le permite enviar mensajes a todas las tareas pausadas mientras lee la cola. <br><br>  Adem치s, el RTOS puede admitir el env칤o y la lectura de mensajes de longitud variable.  Esto proporciona m치s flexibilidad, pero conlleva una sobrecarga adicional. <br><br>  Muchos RTOS admiten otro tipo de objeto de n칰cleo, las "tuber칤as".  En esencia, un canal es similar a una cola, pero procesa datos orientados a bytes. <br><br>  La funcionalidad de las colas no es de inter칠s, pero debe entenderse que tienen m치s sobrecarga de memoria y tiempo de ejecuci칩n que los buzones, principalmente porque es necesario guardar dos punteros: el comienzo y el final de la cola. <br><br><h3>  <b>Mutexes</b> </h3><br>  Los mutexes (sem치foros mutuamente excluyentes) son objetos del n칰cleo independientes que se comportan de manera muy parecida a los sem치foros binarios regulares.  Son un poco m치s complicados que los sem치foros e incluyen el concepto de propiedad temporal (un recurso para el cual se controla el acceso).  Si una tarea asigna un mutex, solo la misma tarea puede liberarlo nuevamente: el mutex (y, por lo tanto, el recurso) pertenece temporalmente a la tarea. <br><br>  Todos los RTOS no proporcionan mutexes, pero el sem치foro binario regular es bastante f치cil de adaptar.  Debe escribir una funci칩n de obtenci칩n de mutex que asigne un sem치foro y asigne un identificador de tarea.  Luego, la funci칩n adicional "liberaci칩n de mutex" verifica el identificador de la tarea de llamada y libera el sem치foro solo si coincide con el valor almacenado, de lo contrario devolver치 un error. <br><br>  <i>Cuando trabajamos en nuestro propio sistema operativo OSRV MAX en tiempo real (art칤culos publicados anteriormente sobre 칠l), nuestro equipo "encontr칩" el blog de Colin Walls, un experto en microelectr칩nica y firmware en Mentor Graphics.</i>  <i>Los art칤culos parec칤an interesantes, los tradujeron por s칤 mismos, pero para no "escribir en la mesa" decidieron publicar.</i>  <i>Espero que tambi칠n te sean 칰tiles.</i>  <i>Si es as칤, entonces planeamos publicar todos los art칤culos traducidos en la serie.</i> <i><br><br></i>  <i>Sobre el autor: Colin Walls ha trabajado en la industria electr칩nica durante m치s de treinta a침os, dedicando la mayor parte de su tiempo al firmware.</i>  <i>Ahora es ingeniero de firmware en Mentor Embedded (una divisi칩n de Mentor Graphics).</i>  <i>Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art칤culos t칠cnicos y dos libros sobre firmware.</i>  <i>Vive en el Reino Unido.</i>  <i>Blog profesional de Colin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blogs.mentor.com/colinwalls</a> , correo electr칩nico: colin_walls@mentor.com</i> <br><br>  Lea los art칤culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primero, segundo,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercero y</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuarto</a> publicados anteriormente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415429/">https://habr.com/ru/post/es415429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415415/index.html">Anuncio de una conferencia de hackathon sobre el desarrollo de juegos en la cadena de bloques GameNode</a></li>
<li><a href="../es415417/index.html">Revisi칩n de tel칠fono inteligente ASUS ZenFone Max Pro (M1) ZB602KL</a></li>
<li><a href="../es415421/index.html">Te invitamos a Gravity Co-working Space para el 칰ltimo Torneo de Contrataci칩n de la temporada.</a></li>
<li><a href="../es415423/index.html">Infraestructura de clave p칰blica: Autoridad de certificaci칩n basada en OpenSSL y SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../es415427/index.html">Toda la verdad sobre RTOS de Colin Walls. Art칤culo # 4. Tareas, cambio de contexto e interrupciones</a></li>
<li><a href="../es415431/index.html">Anuncio de Hackathon SmartMail Hack 2: Llamada de datos</a></li>
<li><a href="../es415433/index.html">Gesti칩n de lanzamientos de viviendas y servicios comunitarios de SIG: compartimos experiencia y luchamos con intuici칩n</a></li>
<li><a href="../es415435/index.html">Desarrollo de tarjetas de interfaz en Soil Xilinx Zynq 7000 para grabaci칩n de voz en formato anal칩gico y digital</a></li>
<li><a href="../es415437/index.html">C칩mo lanzar ML en prod: seis rastrillos que pisamos</a></li>
<li><a href="../es415439/index.html">쯃a comunicaci칩n corporativa te obliga a abandonar o arrastrarte a un proyecto como un juego?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>