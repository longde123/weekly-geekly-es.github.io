<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💻 🕘 🕚 MIT-Kurs "Computer Systems Security". Vorlesung 7: Native Client Sandbox Teil 2 🧖🏽 🤞🏿 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 7: Native Client Sandbox Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: „Woher kommen Sicherheitssysteme?“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: „Chancen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: „Native Client Sandbox“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  <b>Zielgruppe:</b> Warum sollte der Speicherbereich des Adressbereichs von vorne beginnen? <br><br>  <b>Professor:</b> Weil es in Bezug auf die Leistung effizienter ist, den Zielsprung zu verwenden, wenn Sie wissen, dass eine gültige Adresse ein fortlaufender Satz von Adressen ist, die bei Null beginnen.  Denn dann können Sie dies mit einer einzelnen <b>UND-</b> Maske tun, bei der alle hohen Bits eins sind und nur ein Paar niedriger Bits Null ist. <br><br>  <b>Teilnehmerin:</b> Ich dachte, die <b>UND-</b> Maske sollte für die Ausrichtung sorgen. <br><br>  <b>Professor:</b> Richtig, die Maske sorgt für Ausrichtung, aber warum fängt sie von vorne an?  Ich denke, sie verlassen sich auf <b>Segmentierungshardware,</b> segmentierte Hardware.  Im Grunde genommen könnten sie es verwenden, um den Bereich in Bezug auf den linearen Raum nach oben zu verschieben.  Oder es hängt nur damit zusammen, wie die Anwendung diesen Bereich „sieht“.  Tatsächlich können Sie es an verschiedenen Offsets in Ihrem virtuellen Adressraum platzieren.  Auf diese Weise können Sie bestimmte Tricks mit segmentierter Hardware ausführen, um mehrere Module im selben Adressraum auszuführen. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>Teilnehmerin:</b> Vielleicht liegt das daran, dass sie den Empfangspunkt des Nullzeigers „fangen“ möchten? <br><br>  <b>Professor:</b> Ja, weil sie alle Empfangspunkte erreichen wollen.  Aber Sie haben einen Weg, es zu tun.  Weil sich der Nullzeiger auf das Segment bezieht, auf das zugegriffen wird.  Wenn Sie das Segment verschieben, können Sie am Anfang jedes Segments eine nicht verwendete Nullseite anzeigen.  Dies wird also helfen, einige Module zu erstellen. <br><br>  Ich denke, einer der Gründe für diese Entscheidung - den Bereich von 0 zu starten - ist der Wunsch, das Programm auf die <b>x64-</b> Plattform zu portieren, die ein etwas anderes Design aufweist.  Aber ihr Artikel sagt das nicht.  Beim 64-Bit-Design wurde das Gerät selbst von Segmentierungshardware befreit, auf die es sich aus Effizienzgründen stützte, sodass ein softwareorientierter Ansatz erforderlich war.  Für <b>x32 ist</b> dies jedoch immer noch kein guter Grund, den Speicherplatz von vorne zu beginnen. <br><br>  Wir setzen also die Hauptfrage fort: Was möchten wir aus Sicherheitsgründen sicherstellen?  Gehen wir diese Angelegenheit etwas „naiv“ an und sehen, wie wir alles ruinieren können, und versuchen dann, sie zu beheben. <br><br>  Ich glaube, dass ein naiver Plan darin besteht, nach verbotenen Anweisungen zu suchen, indem einfach die ausführbare Datei von Anfang bis Ende gescannt wird.  Wie können Sie diese Anweisungen erkennen?  Sie können einfach den Programmcode in eine riesige Zeile einfügen, die je nach Größe Ihres Codes von null bis 256 Megabyte reicht, und dann die Suche starten. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  Diese Zeile kann zuerst das <b>NOP-</b> Befehlsmodul, dann das <b>ADD-</b> Befehlsmodul, <b>NOT</b> , <b>JUMP</b> usw. enthalten.  Sie suchen nur, und wenn Sie eine schlechte Anweisung finden, sagen Sie, dass es sich um ein schlechtes Modul handelt, und verwerfen Sie es.  Wenn für diese Anweisung kein Systemaufruf angezeigt wird, können Sie den Start dieses Moduls aktivieren und alles im Bereich von 0 bis 256 ausführen.  Glaubst du, das wird funktionieren oder nicht?  Worüber machen sie sich Sorgen?  Warum ist es so schwer? <br><br>  <b>Teilnehmerin:</b> Sind sie besorgt über die Größe der Anweisungen? <br><br>  <b>Professor:</b> Ja, Tatsache ist, dass die <b>x86-</b> Plattform Anweisungen mit variabler Länge enthält.  Dies bedeutet, dass die genaue Größe des Befehls von den ersten Bytes dieses Befehls abhängt.  Tatsächlich können Sie sich das erste Byte ansehen, um zu sagen, dass der Befehl viel größer ist, und dann müssen Sie möglicherweise ein paar weitere Bytes betrachten und dann entscheiden, welche Größe er benötigt.  Einige Architekturen wie <b>Spark</b> , <b>ARM</b> und <b>MIPS</b> verfügen über Anweisungen mit fester Länge.  <b>ARM</b> hat zwei Befehlslängen - entweder 2 oder 4 Bytes.  Auf der <b>x86-</b> Plattform <b>kann die</b> Länge der Anweisungen 1, 5 und 10 Byte betragen, und wenn Sie es versuchen, können Sie sogar eine ziemlich lange Anweisung von 15 Byte erhalten.  Dies sind jedoch komplexe Anweisungen. <br><br>  Infolgedessen kann ein Problem auftreten.  Wenn Sie diese Codezeile linear scannen, ist alles in Ordnung.  Aber vielleicht gehen Sie zur Laufzeit in die Mitte einer Anweisung, zum Beispiel <b>NICHT</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  Es ist möglich, dass dies ein Multibyte-Befehl ist. Wenn Sie ihn ab dem zweiten Byte interpretieren, sieht er völlig anders aus. <br><br>  Ein weiteres Beispiel, in dem wir mit Assembler "spielen" werden.  Angenommen, wir haben Anweisung <b>25 CD 80 00 00</b> .  Nachdem Sie sich das 2. Byte angesehen haben, interpretieren Sie es als Fünf-Byte-Befehl. Das heißt, Sie müssen 5 Byte vorwärts betrachten und feststellen, dass auf den <b>AND% EAX-</b> Befehl <b>0x00 00 80 CD</b> folgt, beginnend mit dem <b>AND-</b> Operator für das <b>EAX-</b> Register mit einigen definierte Konstanten, zum Beispiel <b>00 00 80 CD</b> .  Dies ist eine der sicheren Anweisungen, die der <b>native Client</b> einfach durch die erste Regel zum Überprüfen von binären Anweisungen zulassen sollte.  Wenn die <b>CPU jedoch</b> während der Ausführung des Programms entscheidet, dass sie mit der Ausführung des Codes von der <b>CD beginnen soll</b> , werde ich diese Stelle des Befehls mit einem Pfeil markieren, dann bedeutet der Befehl <b>% EAX, 0x00 00 80 CD</b> , der eigentlich ein 4-Byte-Befehl ist, die Ausführung von <b>INT $ 0x80</b> , mit dem Sie unter <b>Linux</b> einen Systemaufruf durchführen können. <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  Wenn Sie diese Tatsache übersehen, lassen Sie das unzuverlässige Modul in den Kernel "springen" und führen Sie Systemaufrufe durch, dh tun Sie, was Sie verhindern wollten.  Wie können wir das vermeiden? <br><br>  Vielleicht sollten wir versuchen, den Versatz jedes Bytes zu betrachten.  Weil x86 eine Anweisung nur in Byte- und nicht in Bitgrenzen interpretieren kann.  Sie müssen sich also den Versatz jedes Bytes ansehen, um zu sehen, wo der Befehl beginnt.  Halten Sie dies für einen realisierbaren Plan? <br><br>  <b>Teilnehmerin:</b> Ich denke, wenn jemand tatsächlich <b>AND verwendet</b> , springt der Prozessor nicht an diesen Ort, sondern lässt das Programm einfach laufen. <br><br>  <b>Professor:</b> Ja, weil er im Grunde nicht zu Fehlalarmen neigt.  Wenn Sie es wirklich wollen, können Sie den Code ein wenig ändern, um ihn irgendwie zu vermeiden.  Wenn Sie genau wissen, wonach das Testgerät sucht, können Sie diese Anweisungen möglicherweise ändern.  Vielleicht indem Sie <b>AND</b> zuerst für eine Anweisung setzen und dann die Maske für eine andere verwenden.  Es ist jedoch viel einfacher, diese verdächtigen Byte-Anordnungen zu vermeiden, obwohl dies eher unpraktisch erscheint. <br><br>  Es ist möglich, dass die Architektur eine Compileränderung enthält.  Grundsätzlich haben sie eine Art Komponente, die den Code tatsächlich korrekt kompilieren muss.  Sie können <b>GCC</b> nicht einfach „entfernen“ und Code für den <b>Native Client</b> kompilieren.  Im Grunde ist das also machbar.  Aber wahrscheinlich denken sie nur, dass es zu viel Ärger verursacht, keine zuverlässige oder leistungsstarke Lösung sein wird und so weiter.  Außerdem gibt es mehrere <b>x86-</b> Anweisungen, die verboten sind oder als unsicher angesehen werden sollten und daher verboten werden sollten.  Da sie jedoch größtenteils ein Byte groß sind, ist es ziemlich schwierig, sie zu finden oder herauszufiltern. <br><br>  Wenn sie nicht nur unsichere Anweisungen sammeln und sortieren können und auf das Beste hoffen, müssen sie einen anderen Plan verwenden, um ihn zuverlässig zu zerlegen.  Was unternimmt der <b>native Client</b> , um sicherzustellen, dass er nicht über diese Codierung mit variabler Länge „stolpert“? <br><br>  In gewisser Weise sind wir in guter Verfassung, wenn wir die ausführbare Datei wirklich von links nach rechts scannen und nach allen möglichen falschen Codes suchen. Wenn der Code auf diese Weise ausgeführt wird, sind wir in guter Verfassung.  Selbst wenn es einige seltsame Anweisungen und eine gewisse Verzerrung gibt, wird der Prozessor dort immer noch nicht "springen", sondern das Programm in derselben Reihenfolge ausführen, in der die Anweisungen gescannt werden, dh von links nach rechts. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Das Problem bei der zuverlässigen Demontage entsteht daher aufgrund der Tatsache, dass irgendwo in der Anwendung "Sprünge" auftreten können.  Der Prozessor kann ausfallen, wenn er zu einer Codeanweisung „springt“, die er beim Scannen von links nach rechts nicht bemerkt hat.  Dies ist also ein Problem der zuverlässigen Demontage, das sich derzeit in der Entwicklung befindet.  Und der Hauptplan ist zu überprüfen, wohin alle "Sprünge" führen.  In der Tat ist es auf einer bestimmten Ebene recht einfach.  Es gibt eine Reihe von Regeln, die wir in einer Sekunde berücksichtigen werden. Der ungefähre Plan sieht jedoch vor, dass Sie sicherstellen müssen, dass der Zweck des „Sprungs“ früher erkannt wurde, wenn Sie eine Sprunganweisung sehen.  Um dies zu tun, reicht es in der Tat aus, von links nach rechts zu scannen, dh das Verfahren, das wir in unserer naiven Herangehensweise an das Problem beschrieben haben. <br><br>  Wenn Sie in diesem Fall eine Sprunganweisung und die Adresse sehen, auf die diese Anweisung verweist, müssen Sie sicherstellen, dass dies dieselbe Adresse ist, die Sie bereits während der Demontage von links nach rechts gesehen haben. <br><br>  Wenn eine Sprunganweisung für dieses CD-Byte gefunden wird, sollten wir diesen Sprung als ungültig markieren, da wir nie gesehen haben, dass die Anweisung im CD-Byte beginnt, aber wir haben eine andere Anweisung gesehen, die mit der Nummer 25 beginnt. Aber wenn alle Sprunganweisungen befohlen, zum Anfang der Anweisung zu gehen, in diesem Fall bis 25, dann ist bei uns alles in Ordnung.  Das ist klar? <br><br>  Das einzige Problem ist, dass Sie nicht die Ziele jedes Sprungs im Programm überprüfen können, da es möglicherweise indirekte Sprünge gibt.  In <b>x86</b> könnten Sie beispielsweise so etwas wie einen Sprung zum Wert dieses <b>EAX-</b> Registers haben.  Dies ist ideal für die Implementierung von Funktionszeigern. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  Das heißt, der Funktionszeiger befindet sich irgendwo im Speicher, Sie halten ihn in einem Register und gehen dann zu einer beliebigen Adresse im Bewegungsregister. <br><br>  Wie gehen diese Jungs mit indirekten Sprüngen um?  Weil ich in der Tat keine Ahnung habe, ob dies ein "Sprung" zu Byte- <b>CD</b> oder zu Byte 25 sein wird. Was machen sie in diesem Fall? <br><br>  <b>Zielgruppe:</b> Tools verwenden? <br><br>  <b>Professor:</b> Ja, Instrumentierung ist ihr Haupttrick.  Wenn sie sehen, dass der Compiler bereit ist, die Generierung durchzuführen, ist dies ein Beweis dafür, dass dieser Sprung keine Probleme verursacht.  Dazu müssen sie sicherstellen, dass alle Sprünge mit einer Vielzahl von 32 Bytes ausgeführt werden.  Wie machen sie das?  Sie ändern alle Sprungbefehle in sogenannte "Pseudo-Befehle".  Dies sind die gleichen Anweisungen, jedoch mit dem Präfix, wodurch die 5 niedrigen Bits im <b>EAX-</b> Register gelöscht werden.  Die Tatsache, dass der Befehl 5 niedrige Bits löscht, bedeutet, dass der angegebene Wert ein Vielfaches von 32 von zwei auf fünf ist und dann bereits ein Sprung in diesen Wert ausgeführt wird. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  Wenn Sie dies während der Überprüfung betrachten, stellen Sie sicher, dass dieses Anweisungspaar nur mit einer Vielzahl von 32 Bytes "springt".  Und um sicherzustellen, dass es keine Möglichkeit gibt, in seltsame Anweisungen zu „springen“, wenden Sie eine zusätzliche Regel an.  Es besteht in der Tatsache, dass Sie während der Demontage, wenn Sie Ihre Anweisungen von links nach rechts betrachten, sicherstellen, dass der Anfang jeder gültigen Anweisung auch ein Vielfaches von 32 Bytes ist. <br><br>  Zusätzlich zu diesem Toolkit überprüfen Sie daher, ob jeder Code, der ein Vielfaches von 32 ist, die richtige Anweisung ist.  Mit einer gültigen, gültigen Anweisung meine ich eine Anweisung, die von links nach rechts zerlegt wird. <br><br>  <b>Teilnehmerin:</b> Warum wird die Nummer 32 gewählt? <br><br>  <b>Professor:</b> Ja, warum haben sie 32 statt 1000 oder 5 gewählt?  Warum ist 5 schlecht? <br><br>  <b>Teilnehmerin:</b> weil die Zahl eine Potenz von 2 sein muss. <br><br>  <b>Professor:</b> Ja, deshalb.  Andernfalls sind zusätzliche Anweisungen erforderlich, um sicherzustellen, dass ein Vielfaches von 5 verwendet wird, was zu Overhead führt.  Was ist mit acht?  Ist acht eine gute Zahl? <br><br>  <b>Zielgruppe:</b> Möglicherweise haben Sie Anweisungen, die länger als acht Bit sind. <br><br>  <b>Professor:</b> Ja, dies ist möglicherweise die längste Anweisung, die auf der x86-Plattform zulässig ist.  Wenn wir einen 10-Byte-Befehl haben und alles ein Vielfaches von 8 sein sollte, können wir ihn nirgendwo einfügen.  Die Länge sollte also für alle Fälle ausreichend sein, da der größte Befehl, den ich gesehen habe, 15 Bytes lang war.  32 Bytes reichen also aus. <br><br>  Wenn Sie die Anweisungen zum Aufrufen oder Beenden der Prozessdienstumgebung anpassen möchten, benötigen Sie möglicherweise eine nicht triviale Menge an Code in einem 32-Byte-Steckplatz.  Zum Beispiel 31 Bytes, weil 1 Byte eine Anweisung enthält.  Sollte es viel größer sein?  Sollten wir dies beispielsweise auf 1024 Bytes einstellen?  Wenn Sie viele Funktionszeiger oder viele indirekte Sprünge haben, müssen Sie jedes Mal, wenn Sie eine Stelle erstellen möchten, an der Sie springen möchten, diese unabhängig vom Wert bis zum nächsten Rand fortsetzen.  Mit 32 Bit ist es also eine ganz normale Größe.  Im schlimmsten Fall verlieren Sie nur 31 Bytes, wenn Sie schnell zum nächsten Rand gelangen müssen.  Wenn Sie jedoch eine Größe haben, die ein Vielfaches von 1024 Bytes beträgt, ist es möglich, ein ganzes Kilobyte Speicherplatz vergeblich für einen indirekten Sprung zu verschwenden.  Wenn Sie kurze Funktionen oder viele Funktionszeiger haben, führt eine so große Größe der Vielzahl der Länge des "Sprungs" zu einer erheblichen Speicherverschwendung. <br><br>  Ich denke nicht, dass die Nummer 32 ein Stolperstein für den <b>Native Client ist</b> .  Einige Blöcke könnten mit einer Vielzahl von 16 Bit arbeiten, einige 64 oder 128 Bit, es spielt keine Rolle.  Nur 32 Bit schienen ihnen der akzeptabelste und optimalste Wert zu sein. <br><br>  Machen wir also einen Plan für eine zuverlässige Demontage.  Daher sollte der Compiler beim Kompilieren von <b>C-</b> oder <b>C ++ - Code</b> in eine <b>Native Client-</b> Binärdatei etwas vorsichtig sein und die folgenden Regeln beachten. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Daher muss er bei jedem Sprung, wie in der oberen Zeile gezeigt, diese zusätzlichen Anweisungen in den unteren 2 Zeilen hinzufügen.  Und unabhängig von der Tatsache, dass er eine Funktion erstellt, zu der er "springen" wird, springt unsere Anweisung, wenn der Zusatz <b>AND $ 0xffffffe0,% eax</b> angibt.  Und es kann nicht einfach mit Nullen ergänzt werden, denn all dies muss die richtigen Codes haben.  Daher ist die Hinzufügung notwendig, um sicherzustellen, dass jede mögliche Anweisung gültig ist.  Und glücklicherweise wird auf der <b>x86-</b> Plattform keine einzelne <b>Noop-</b> Funktion durch ein einzelnes Byte beschrieben, oder zumindest gibt es kein einzelnes <b>Noop-</b> 1-Byte.  So können Sie dem Wert einer Konstante jederzeit Dinge hinzufügen. <br><br>  Was garantiert uns das?  Stellen wir sicher, dass wir immer sehen, was in der Terminologie der Anweisungen passiert, die befolgt werden.  Diese Regel gibt uns Folgendes: die Gewissheit, dass ein Systemaufruf nicht versehentlich erfolgt.  Dies gilt für Sprünge, aber was ist mit Renditen?  Wie gehen sie mit Retouren um?  Können wir zu einer Funktion im <b>Native Client zurückkehren</b> ?  Was passiert, wenn Sie den brandaktuellen Code ausführen? <br><br>  <b>Zielgruppe:</b> Der Stapel kann überlaufen. <br><br>  <b>Professor:</b> Es ist wahr, dass es ganz unerwartet auf dem Stapel auftaucht.  Tatsache ist jedoch, dass der von den <b>Native Client-</b> Modulen verwendete Stapel tatsächlich einige Daten enthält.  Daher sollten Sie sich beim Umgang mit <b>Native Client</b> keine Gedanken über einen Stapelüberlauf machen. <br><br>  <b>Teilnehmerin:</b> Warten Sie, aber Sie können alles auf den Stapel legen.  Und wenn Sie einen indirekten Sprung machen. <br><br>  <b>Professor:</b> Es ist wahr.  Die Rückkehr sieht fast aus wie ein indirekter Sprung von einer Stelle im Speicher, die sich oben im Stapel befindet.  Daher denke ich, dass eine Sache, die sie für die <b>Rückgabefunktion</b> tun könnten, darin besteht, das Präfix auf die gleiche Weise wie bei der vorherigen Prüfung festzulegen.  Und dieses Präfix prüft, was oben im Stapel angezeigt wird.  Sie überprüfen, ob dies gültig ist, und wenn Sie den <b>AND-</b> Operator schreiben oder verwenden, überprüfen Sie, was sich oben im Stapel befindet.  Dies scheint aufgrund des ständigen Datenwechsels etwas unzuverlässig zu sein.  Wenn Sie beispielsweise auf die Oberseite des Stapels schauen und sicherstellen, dass dort alles in Ordnung ist, und dann etwas schreiben, kann der Datenstrom im selben Modul etwas am oberen Rand des Stapels ändern, woraufhin Sie auf die falsche verweisen Adresse <br><br>  <b>Teilnehmerin:</b> Gilt dies nicht für das Springen in gleichem Maße? <br><br>  <b>Professor:</b> Ja, was passiert dort mit einem Sprung?  Können unsere Rennbedingungen diesen Test irgendwie ungültig machen? <br><br>  <b>Teilnehmerin:</b> Aber ist der Code nicht beschreibbar? <br><br>  <b>Professor:</b> Ja, der Code kann nicht geschrieben werden, das ist wahr.  Daher können Sie AND nicht ändern.  Aber konnte nicht ein anderer Stream den Zweck des Sprungs zwischen diesen beiden Anweisungen ändern? <br><br>  <b>Teilnehmerin:</b> Dies ist im Register, also ... <br><br>  <b>Professor:</b> Ja, das ist eine coole Sache.  Denn wenn ein Stream etwas im Speicher oder in dem, was von <b>EAX</b> geladen wird, ändert (von sich aus tun Sie dies vor dem Herunterladen), befindet sich dieser <b>EAX</b> in diesem Fall in einem schlechten Zustand, löscht dann jedoch fehlerhafte Bits.  Oder er kann den Speicher danach ändern, wenn sich der Zeiger bereits in <b>EAX befindet</b> , sodass es keine Rolle spielt, dass er den Speicherort des Speichers ändert, aus dem das <b>EAX-</b> Register geladen wurde. <br><br>  Tatsächlich teilen Threads keine Registersätze.  Wenn ein anderer Thread das <b>EAX-</b> Register ändert, hat dies keine Auswirkungen auf das <b>EAX-</b> Register dieses Threads.  Daher können andere Threads diese Befehlsfolge nicht ungültig machen. <br><br>  Es gibt noch eine andere interessante Frage.  Können wir dieses <b>UND umgehen</b> ?  Ich kann überall in diesem Adressraum springen, wohin ich will.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : «,    ,    !»,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    «» . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     «»     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 7: « Native Client»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br> ,    .  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 Monate kostenlos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bei Bezahlung eines neuen Dell R630 für einen Zeitraum von sechs Monaten - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel Deca-Core Xeon E5-2630 v4 / 128 GB DDR4 / 4 x 1 TB Festplatte oder 2 x 240 GB SSD / 1 Gbit / s 10 TB - ab 99,33 USD pro Monat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nur bis Ende August, Bestellung kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier sein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418225/">https://habr.com/ru/post/de418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418215/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 5: „Woher kommen Sicherheitssystemfehler?“, Teil 2</a></li>
<li><a href="../de418217/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: „Chancen“, Teil 1</a></li>
<li><a href="../de418219/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: Chancen, Teil 2</a></li>
<li><a href="../de418221/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: „Chancen“, Teil 3</a></li>
<li><a href="../de418223/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 7: Die Native Client Sandbox, Teil 1</a></li>
<li><a href="../de418227/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 7: Die Native Client Sandbox, Teil 3</a></li>
<li><a href="../de418229/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 8: Netzwerksicherheitsmodell, Teil 1</a></li>
<li><a href="../de418233/index.html">BMW Mnemonik zum Finden von Grenzwerten</a></li>
<li><a href="../de418235/index.html">Orchestrierte Saga oder Erstellen von Geschäftstransaktionen in Diensten mit der Datenbank nach Dienstmuster</a></li>
<li><a href="../de418237/index.html">Entwicklung mandantenfähiger Anwendungen auf der SAP Cloud Platform in Neo, Teil 2: Autorisierung und Authentifizierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>