<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöó üì® üó≥Ô∏è Schnellere Aufz√§hlung üîÄ üö£üèº üöò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr 
 github.com/QratorLabs/fastenum 


pip install fast-enum  
 Was sind Aufz√§hlungen? 
 (Wenn Sie glauben, dass Sie das wissen - scrollen Sie nac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnellere Aufz√§hlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/480600/"><h4>  tl; dr </h4><br>  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> <br><pre><code class="bash hljs">pip install fast-enum</code> </pre> <br><h3>  Was sind Aufz√§hlungen? </h3><br>  (Wenn Sie glauben, dass Sie das wissen - scrollen Sie nach unten zum Abschnitt ‚ÄûAufz√§hlungen in der Standardbibliothek‚Äú). <br><br>  Stellen Sie sich vor, Sie m√ºssen einen Satz aller m√∂glichen Zust√§nde f√ºr die Entit√§ten in Ihrem Datenbankmodell beschreiben.  Sie werden wahrscheinlich eine Reihe von Konstanten verwenden, die als Attribute auf Modulebene definiert sind: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># /path/to/package/static.py: INITIAL = 0 PROCESSING = 1 PROCESSED = 2 DECLINED = 3 RETURNED = 4 ...</span></span></code> </pre> <br>  ... oder als Attribute auf Klassenebene, die in ihrer eigenen Klasse definiert sind: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = <span class="hljs-number"><span class="hljs-number">0</span></span> PROCESSING = <span class="hljs-number"><span class="hljs-number">1</span></span> PROCESSED = <span class="hljs-number"><span class="hljs-number">2</span></span> DECLINED = <span class="hljs-number"><span class="hljs-number">3</span></span> RETURNED = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Auf diese Weise k√∂nnen Sie auf diese Zust√§nde mit ihren mnemonischen Namen verweisen, w√§hrend sie als einfache Ganzzahlen in Ihrem Speicher verbleiben.  Auf diese Weise werden Sie die in Ihrem Code verstreuten magischen Zahlen los und machen ihn lesbarer und selbsterkl√§render. <br><br>  Sowohl die Konstante auf Modulebene als auch die Klasse mit den statischen Attributen leiden unter der inh√§renten Natur von Python-Objekten: Sie sind alle ver√§nderlich.  M√∂glicherweise weisen Sie Ihrer Konstante zur Laufzeit versehentlich einen Wert zu, und das ist ein Chaos beim Debuggen und Rollback Ihrer defekten Entit√§ten.  Vielleicht m√∂chten Sie Ihre Konstantens√§tze unver√§nderlich machen, dh, sowohl die Anzahl der deklarierten Konstanten als auch die Werte, denen sie zugeordnet sind, d√ºrfen zur Laufzeit nicht ge√§ndert werden. <br><a name="habracut"></a><br>  Zu diesem Zweck k√∂nnen Sie versuchen, sie mit <code>namedtuple()</code> in benannte Tupel zu organisieren. Beispiel: <br><pre> <code class="python hljs">MyModelStates = namedtuple(<span class="hljs-string"><span class="hljs-string">'MyModelStates'</span></span>, (<span class="hljs-string"><span class="hljs-string">'INITIAL'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSING'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSED'</span></span>, <span class="hljs-string"><span class="hljs-string">'DECLINED'</span></span>, <span class="hljs-string"><span class="hljs-string">'RETURNED'</span></span>)) EntityStates = MyModelStates(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Dies sieht jedoch immer noch nicht allzu verst√§ndlich aus: Au√üerdem sind <code>namedtuple</code> Objekte nicht wirklich erweiterbar.  Angenommen, Sie haben eine Benutzeroberfl√§che, die alle diese Zust√§nde anzeigt.  Sie k√∂nnen dann Ihre modulbasierten Konstanten, Ihre Klasse mit den Attributen oder benannte Tupel verwenden, um sie zu rendern (die letzten beiden sind einfacher zu rendern, wenn wir gerade dabei sind).  Ihr Code bietet jedoch keine M√∂glichkeit, dem Benutzer eine angemessene Beschreibung f√ºr jeden von Ihnen definierten Status zu geben.  Wenn Sie mehrsprachige Unterst√ºtzung und i18n in Ihrer Benutzeroberfl√§che implementieren m√∂chten, werden Sie feststellen, dass das Ausf√ºllen aller √úbersetzungen f√ºr diese Beschreibungen zu einer unglaublich m√ºhsamen Aufgabe wird.  Die √ºbereinstimmenden <code>INITIAL</code> m√ºssen nicht unbedingt √ºbereinstimmende Beschreibungen haben, was bedeutet, dass Sie nicht alle <code>INITIAL</code> auf dieselbe Beschreibung in <code>gettext</code> <code>INITIAL</code> .  Stattdessen wird Ihre Konstante wie folgt: <br><pre> <code class="python hljs">INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'My_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Ihre Klasse wird dann zu: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Und schlie√ülich wird Ihr <code>namedtuple</code> : <br><pre> <code class="python hljs">EntityStates = MyModelStates((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>), ...)</code> </pre><br>  Gut genug, jetzt wird sichergestellt, dass sowohl der Statuswert als auch der √úbersetzungsstub den von Ihrer Benutzeroberfl√§che unterst√ºtzten Sprachen zugeordnet sind.  Aber jetzt werden Sie vielleicht bemerken, dass der Code, der diese Zuordnungen verwendet, sich in ein Chaos verwandelt hat.  Wenn Sie versuchen, Ihrer Entit√§t einen Wert zuzuweisen, m√ºssen Sie auch nicht vergessen, den Wert am Index 0 aus der verwendeten Zuordnung zu extrahieren: <br><br><pre> <code class="python hljs">my_entity.state = INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  oder <pre> <code class="python hljs">my_entity.state = MyModelStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  oder <pre> <code class="python hljs">my_entity.state = EntityStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Und so weiter.  Beachten Sie, dass die ersten beiden Ans√§tze, die Konstanten bzw. Klassenattribute verwenden, immer noch ver√§nderlich sind. <br><br><h4>  Und dann kommen Enums auf die B√ºhne </h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEntityStates</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val, description)</span></span></span><span class="hljs-function">:</span></span> self.val = val self.description = description INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>) PROCESSING = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_BEING_PROCESSED_STATE'</span></span>) PROCESSED = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_PROCESSED_STATE'</span></span>) DECLINED = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_DECLINED_STATE'</span></span>) RETURNED = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_RETURNED_STATE'</span></span>)</code> </pre> <br>  Das war's  Jetzt k√∂nnen Sie die Aufz√§hlung in Ihrem Renderer leicht wiederholen (Jinja2-Syntax): <br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyEntityState %} &lt;option value=‚Äù{{ state.val }}‚Äù&gt;{{ _(state.description) }}&lt;/option&gt; {% endfor %}</code> </pre> <br>  Enum ist sowohl f√ºr die Elementmenge (Sie k√∂nnen zur Laufzeit kein neues Element definieren, noch ein bereits definiertes Element l√∂schen) als auch f√ºr die von ihnen beibehaltenen Elementwerte (Sie k√∂nnen keine Attributwerte neu zuweisen oder ein Attribut l√∂schen) unver√§nderlich. <br><br>  In Ihrem Code weisen Sie Ihren Entit√§ten Werte wie folgt zu: <br><pre> <code class="python hljs">my_entity.state = MyEntityStates.INITIAL.val</code> </pre> <br>  Klar genug.  Selbstbeschreibend.  Ziemlich erweiterbar.  Daf√ºr verwenden wir Enums. <br><br><h3>  Warum ist es schneller? </h3><br>  Da die Standardeinstellung von ENUM jedoch ziemlich langsam ist, haben wir uns gefragt, ob wir sie schneller machen k√∂nnen. <br>  Wie sich herausstellt, k√∂nnen wir.  Es ist n√§mlich m√∂glich, es zu machen: <br><br><ul><li>  3-mal schneller auf Mitgliederzugang </li><li>  ~ 8,5-mal schneller beim Zugriff auf Attribute ( <code>name</code> , <code>value</code> ) </li><li>  3-mal schnellerer Zugriff auf Enum nach Wert (Aufruf der Klasse <code>MyEnum(value)</code> von Enum) </li><li>  1,5-mal schneller bei Enum-Zugriff nach Namen (dict-like <code>MyEnum[name]</code> ) </li></ul><br>  Typen und Objekte sind in Python dynamisch.  Aber Python hat die Werkzeuge, um die Dynamik der Objekte einzuschr√§nken.  Mit ihrer Hilfe kann man durch die Verwendung von <code>__slots__</code> einen erheblichen Leistungszuwachs <code>__slots__</code> und die Verwendung von Data Descriptors vermeiden, wenn dies ohne erhebliches Komplexit√§tswachstum m√∂glich ist oder wenn Sie die Geschwindigkeit verbessern k√∂nnen. <br><br><h4>  Spielautomaten </h4><br>  Beispielsweise k√∂nnte man eine Klassendeklaration mit <code>__slots__</code> In diesem Fall h√§tten Klasseninstanzen nur einen eingeschr√§nkten Satz von Attributen: Attribute, die in <code>__slots__</code> deklariert <code>__slots__</code> und alle <code>__slots__</code> der √ºbergeordneten Klassen. <br><br><h4>  Deskriptoren </h4><br>  Standardm√§√üig gibt der Python-Interpreter einen Attributwert eines Objekts direkt zur√ºck: <br><pre> <code class="python hljs">value = my_obj.attribute <span class="hljs-comment"><span class="hljs-comment"># this is a direct access to the attribute value by the pointer that the object holds for that attribute</span></span></code> </pre> <br>  Wenn der Attributwert eines Objekts nach dem Python-Datenmodell selbst ein Objekt ist, das das Data Descriptor Protocol implementiert, bedeutet dies, dass Sie beim Versuch, diesen Wert <code>__get__</code> zuerst das Attribut als Objekt <code>__get__</code> und dann eine spezielle Methode <code>__get__</code> Aufgerufen auf das Attribut-Objekt, wobei das Keeper-Objekt selbst als Argument √ºbergeben wird: <br><pre> <code class="python hljs">obj_attribute = my_obj.attribute obj_attribute_value = obj_attribute.__get__(my_obj)</code> </pre> <br><h4>  Aufz√§hlungen in der Standardbibliothek </h4><br>  Mindestens die Attribute <code>name</code> und <code>value</code> der Standardimplementierung von Enum werden als <code>types.DynamicClassAttribute</code> .  Das bedeutet, dass beim Versuch, den <code>name</code> (oder den <code>value</code> ) eines Mitglieds <code>value</code> der Ablauf wie folgt aussieht: <br><br><pre> <code class="python hljs">one_value = StdEnum.ONE.value <span class="hljs-comment"><span class="hljs-comment"># that is what you write in your code one_value_attribute = StdEnum.ONE.value one_value = one_value_attribute.__get__(StdEnum.ONE)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># and this is what really __get__ does (python 3.7 implementation): def __get__(self, instance, ownerclass=None): if instance is None: if self.__isabstractmethod__: return self raise AttributeError() elif self.fget is None: raise AttributeError("unreadable attribute") return self.fget(instance)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># since DynamicClassAttribute is a decorator on Enum methods `name` and `value` the final row of __get__() ends up with: @DynamicClassAttribute def name(self): """The name of the Enum member.""" return self._name_ @DynamicClassAttribute def value(self): """The value of the Enum member.""" return self._value_</span></span></code> </pre> <br>  Der gesamte Ablauf k√∂nnte also als folgender Pseudocode dargestellt werden: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(enum_member, attrname)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># this is also a __dict__ lookup so hash + hashtable scan also occur return getattr(enum_member, f'_{attrnme}_') def get_name_value(enum_member): name_descriptor = get_descriptor(enum_member, 'name') if enum_member is None: if name_descriptor.__isabstractmethod__: return name_descriptor raise AttributeError() elif name_descriptor.fget is None: raise AttributeError("unreadable attribute") return get_func(enum_member, 'name')</span></span></code> </pre> <br>  Wir haben ein einfaches Skript erstellt, das die obige Schlussfolgerung demonstriert: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Enum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StdEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, description)</span></span></span><span class="hljs-function">:</span></span> self.v = value self.description = description A = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'One'</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'Two'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StdEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'stdenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Und nachdem wir das Skript ausgef√ºhrt haben, hat es dieses Bild f√ºr uns erstellt: <br><img src="https://habrastorage.org/webt/op/ff/m7/opffm7k3v2rgako7xufgkgqtcek.png"><br><br>  Dies zeigt, dass bei jedem Zugriff auf die Attribute <code>name</code> und <code>value</code> stdlib enum ein Deskriptor aufgerufen wird.  Dieser Deskriptor endet wiederum mit einem Aufruf der mit dem Deskriptor dekorierten Eigenschaft <code>def name(self)</code> von stdlib enum. <br><br>  Nun, Sie k√∂nnen dies mit unserem FastEnum vergleichen: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fast_enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastEnum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNewEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNewEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'fastenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Was gibt dieses Bild aus: <br><img src="https://habrastorage.org/webt/le/ck/td/lecktd3dtx71oi3dmlyax7qyogu.png"><br><br>  Dies geschieht in der Standard-Enum-Implementierung jedes Mal, wenn Sie auf die <code>name</code> und Wertattribute Ihrer Enum-Mitglieder zugreifen.  Deshalb ist unsere Implementierung schneller. <br><br>  <b>Die Implementierung der Enum-Klasse in der Python Standard Library verwendet Tonnen von Deskriptorprotokollaufrufen.</b>  Als wir versuchten, Standardenzahlen in unseren Projekten zu verwenden, haben wir festgestellt, wie viele Deskriptorprotokollaufrufe f√ºr <code>name</code> und <code>Enum</code> der <code>Enum</code> Mitglieder aufgerufen wurden.  Und weil Aufz√§hlungen im gesamten Code √ºberm√§√üig verwendet wurden, war die resultierende Leistung schlecht. <br><br>  Dar√ºber hinaus enth√§lt die Standard-Enum-Klasse einige helfergesch√ºtzte Attribute: <br><ul><li>  <code>_member_names_</code> - eine Liste, die alle Namen von Enum-Mitgliedern enth√§lt; </li><li>  <code>_member_map_</code> - ein OrderedDict, das dem Mitglied selbst einen Namen eines Aufz√§hlungsmitglieds zuordnet; </li><li>  <code>_value2member_map_</code> - Ein umgekehrtes W√∂rterbuch, das die Werte der Aufz√§hlungsmitglieder den entsprechenden Aufz√§hlungsmitgliedern <code>_value2member_map_</code> . </li></ul><br>  W√∂rterbuchsuchen sind langsam, da jede Suche zu einer Hash-Berechnung und einer Hash-Tabellensuche f√ºhrt, was diese W√∂rterb√ºcher zu nicht optimalen Basisstrukturen f√ºr die Aufz√§hlungsklasse macht.  Sogar der Mitgliederabruf selbst (wie in <code>StdEnum.MEMBER</code> ) ist eine Dictionary-Suche. <br><br><h4>  Unser Weg </h4><br>  Bei der Entwicklung unserer Enum-Implementierung haben wir die h√ºbschen C-sprachigen Aufz√§hlungen und die sch√∂nen erweiterbaren Java-Enums ber√ºcksichtigt.  Die Hauptmerkmale, die wir in unserer Implementierung wollten: <br><br><ul><li>  Eine Aufz√§hlung muss so statisch wie m√∂glich sein.  Mit "statisch" meinen wir: Wenn etwas einmalig und zur Deklarationszeit berechnet werden konnte, sollte es; </li><li>  Eine Enum-Klasse kann nicht in Unterklassen unterteilt werden (muss eine ‚Äûletzte‚Äú Klasse sein), wenn eine Unterklasse neue Enum-Mitglieder definiert. Dies gilt f√ºr die Standard-Bibliotheksimplementierung, mit der Ausnahme, dass Unterklassen verboten sind, auch wenn keine neuen Mitglieder definiert wurden. </li><li>  Eine Enumeration sollte umfangreiche Erweiterungsm√∂glichkeiten haben (zus√§tzliche Attribute, Methoden usw.). </li></ul><br>  Das einzige Mal, dass wir Dictionary-Lookups verwenden, ist eine umgekehrte Zuordnung zum Enum-Member.  Alle anderen Berechnungen werden nur einmal w√§hrend der Klassendeklaration durchgef√ºhrt (wobei Metaklassen-Hooks zum Anpassen der Typerstellung verwendet werden). <br>  Im Gegensatz zur Standard-Bibliotheksimplementierung behandeln wir den ersten Wert nach dem Zeichen <code>=</code> in der Klassendeklaration als Member-Wert: <br>  <code>A = 1, 'One'</code> in der Standardbibliothek. Das gesamte Tupel <code>1, "One"</code> wird als <code>value</code> behandelt <br>  <code>A: 'MyEnum' = 1, 'One'</code> In unserer Implementierung wird nur <code>1</code> als <code>value</code> behandelt <br><br>  Weitere Beschleunigung wird durch die Verwendung von <code>__slots__</code> wann immer dies m√∂glich ist.  In den mit <code>__slots__</code> deklarierten Python-Datenmodellklassen <code>__slots__</code> es kein <code>__dict__</code> Attribut, das <code>__dict__</code> enth√§lt (Sie k√∂nnen also kein Attribut zuweisen, das nicht in <code>__slots__</code> ).  Dar√ºber hinaus werden Attribute, die in <code>__slots__</code> definiert <code>__slots__</code> mit konstanten Offsets f√ºr den <code>__slots__</code> auf C-Ebene aufgerufen.  Dies ist ein schneller Attributzugriff, da Hash-Berechnungen und Hashtable-Scans vermieden werden. <br><br><h3>  Was sind die zus√§tzlichen Vorteile? </h3><br>  FastEnum ist mit keiner Version von Python vor 3.6 kompatibel, da das in Python 3.6 eingef√ºhrte Eingabemodul √ºberm√§√üig verwendet wird.  Man k√∂nnte davon ausgehen, dass die Installation eines Backported- <code>typing</code> Moduls von PyPI helfen w√ºrde.  Die Antwort lautet: nein.  Die Implementierung verwendet PEP-484 f√ºr einige Funktions- und Methodenargumente und R√ºckgabewerttyphinweise, sodass eine Version vor Python 3.5 aufgrund von Syntaxinkompatibilit√§t nicht unterst√ºtzt wird.  <code>__new__</code> verwendet die allererste Codezeile in <code>__new__</code> der Metaklasse die PEP-526-Syntax f√ºr Variablentyphinweise.  Also wird Python 3.5 auch nicht funktionieren.  Es ist m√∂glich, die Implementierung auf √§ltere Versionen zu portieren, obwohl wir in Qrator Labs in der Regel Tipping verwenden, wenn dies m√∂glich ist, da dies die Entwicklung komplexer Projekte erheblich erleichtert.  Und hey!  Sie m√∂chten sich nicht an Pythons vor 3.6 halten, da es keine Inkompatibilit√§ten mit Ihrem vorhandenen Code gibt (vorausgesetzt, Sie verwenden Python 2 nicht), obwohl in Asyncio im Vergleich zu 3.5 viel Arbeit geleistet wurde. <br><br>  Das wiederum macht spezielle Importe wie <code>auto</code> im Gegensatz zur Standardbibliothek √ºberfl√ºssig.  Sie geben f√ºr alle Enum-Mitglieder einen Hinweis mit Ihrem Enum-Klassennamen ein und geben dabei √ºberhaupt keinen Wert an. Der Wert wird dann automatisch f√ºr Sie generiert.  Obwohl Python 3.6 f√ºr die Arbeit mit FastEnum ausreicht, wird darauf hingewiesen, dass die Standardgarantie f√ºr die Deklarationsreihenfolge f√ºr W√∂rterb√ºcher nur in Python 3.7 eingef√ºhrt wurde.  Wir kennen keine n√ºtzlichen Appliances, bei denen die Reihenfolge der automatisch generierten Werte wichtig ist (da wir davon ausgehen, dass der selbst generierte Wert nicht der Wert ist, den ein Programmierer interessiert).  Beachten Sie jedoch, dass Sie gewarnt sind, wenn Sie sich weiterhin an Python 3.6 halten. <br><br>  Diejenigen, die ihre Aufz√§hlung ab 0 (Null) anstelle von Standard 1 ben√∂tigen, k√∂nnen dies mit einem speziellen Enum-Deklarationsattribut <code>_ZERO_VALUED</code> , das aus der resultierenden Enum-Klasse "gel√∂scht" wird. <br><br>  Es gibt jedoch einige Einschr√§nkungen: Alle Namen von Aufz√§hlungsmitgliedern m√ºssen KAPITALISIERT sein. Andernfalls werden sie nicht von der Metaklasse erfasst und nicht als Aufz√§hlungsmitglieder behandelt. <br><br>  Sie k√∂nnen jedoch eine Basisklasse f√ºr Ihre Aufz√§hlungen deklarieren (bedenken Sie, dass die Basisklasse die Aufz√§hlungsmetaklasse selbst verwenden kann, sodass Sie nicht f√ºr alle Unterklassen eine Metaklasse bereitstellen m√ºssen): Sie k√∂nnen darin gemeinsame Logik (Attribute und Methoden) definieren Klasse, darf aber keine Enum-Mitglieder definieren (damit die Klasse nicht "finalisiert" wird).  Sie k√∂nnen diese Klasse dann in beliebig viele Aufz√§hlungsdeklarationen unterteilen, um die gesamte Logik zu erhalten. <br><br>  Aliase  Wir werden sie in einem separaten Thema erkl√§ren (implementiert in 1.2.5) <br><br><h3>  Aliase und wie sie helfen k√∂nnten </h3><br>  Angenommen, Sie haben Code, der Folgendes verwendet: <br><pre> <code class="python hljs">package_a.some_lib_enum.MyEnum</code> </pre> <br>  Und das MyEnum wird so deklariert: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> ONE: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span> TWO: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span></code> </pre> <br>  Nun haben Sie sich f√ºr ein Refactoring entschieden und m√∂chten Ihre Enumeration in ein anderes Paket verschieben.  Sie erstellen so etwas: <br><pre> <code class="python hljs">package_b.some_lib_enum.MyMovedEnum</code> </pre> <br>  Wo MyMovedEnum wie folgt deklariert ist: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyMovedEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MyEnum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Jetzt  Sie k√∂nnen mit der Phase "Verfall" f√ºr den gesamten Code beginnen, in dem Ihre Aufz√§hlungen verwendet werden.  Sie leiten die direkte Verwendung von <code>MyEnum</code> um, um <code>MyEnum</code> zu verwenden (letzteres hat alle seine Mitglieder in <code>MyEnum</code> ).  Sie geben in Ihren Projektdokumenten an, dass <code>MyEnum</code> veraltet ist und zu einem sp√§teren Zeitpunkt aus dem Code entfernt wird.  Zum Beispiel in der n√§chsten Version.  Stellen Sie sich vor, Ihr Code speichert Ihre Objekte mithilfe von pickle mit Aufz√§hlungsattributen.  Zu diesem Zeitpunkt verwenden Sie <code>MyMovedEnum</code> in Ihrem Code, aber intern sind alle Ihre Enum-Mitglieder weiterhin die <code>MyEnum</code> Instanzen.  Ihr n√§chster Schritt w√§re, die Deklarationen von <code>MyEnum</code> und <code>MyMovedEnum</code> sodass <code>MyMovedEnum</code> jetzt keine Unterklasse von <code>MyEnum</code> und alle ihre Mitglieder selbst deklariert.  Andererseits w√ºrde <code>MyEnum</code> keine Mitglieder deklarieren, sondern nur ein Alias ‚Äã‚Äã(eine Unterklasse) von <code>MyMovedEnum</code> . <br><br>  Und das schlie√üt es.  Beim Neustart Ihrer Laufzeiten auf der Unpickle-Stufe werden alle Ihre Enum-Werte in <code>MyMovedEnum</code> und an diese neue Klasse gebunden.  In dem Moment, in dem Sie sicher sind, dass alle Ihre gekapselten Objekte mit dieser Klassenorganisationsstruktur nicht (erneut) <code>MyEnum</code> sind, k√∂nnen Sie eine neue Version <code>MyEnum</code> , in der <code>MyEnum</code> zuvor als veraltet markiert und aus Ihrer Codebasis <code>MyEnum</code> kann. <br><br>  Wir empfehlen Ihnen, es zu versuchen!  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> , <a href="https://pypi.org/project/fast-enum/">pypi.org/project/fastenum</a> .  Alle Credits gehen an den FastEnum-Autor <a href="https://habr.com/en/users/santjagocorkez/" class="user_link">santjagocorkez</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480600/">https://habr.com/ru/post/de480600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480582/index.html">Security Week 51: Sicherheitsl√ºcken in iOS- und Intel-Prozessoren</a></li>
<li><a href="../de480584/index.html">C ++ Russland: Vergangenheit, Gegenwart und Zukunft</a></li>
<li><a href="../de480594/index.html">Vorher und Nachher: ‚Äã‚ÄãDie visuelle Entwicklung ber√ºhmter Videospiele</a></li>
<li><a href="../de480596/index.html">Was erwartet Sie in dem innovativen Netzwerkbetriebssystem ArubaOS-CX</a></li>
<li><a href="../de480598/index.html">Die Basis jeder Programmierung auf ... R√§tseln</a></li>
<li><a href="../de480606/index.html">F√ºnf weitere Ideen, wie Sie Ihre F√§higkeiten als Front-End-Entwickler verbessern k√∂nnen (Dezember 2019)</a></li>
<li><a href="../de480608/index.html">Rust √ºbertrifft C ++ mit Benchmarks</a></li>
<li><a href="../de480610/index.html">C ++ vtables. Teil 2 (Virtuelle Vererbung + Compiler-generierter Code)</a></li>
<li><a href="../de480612/index.html">Nehmen Sie diese √Ñnderungen vor, um die Barrierefreiheitsstandards f√ºr das Webdesign zu erf√ºllen.</a></li>
<li><a href="../de480614/index.html">Schnelle ENUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>