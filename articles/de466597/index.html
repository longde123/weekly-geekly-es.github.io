<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëß üë©üèΩ‚Äçüç≥ üêü Zweiter Platz in der Mini AI Cup 4: Paper IO ü§• ü§öüèº üÉè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich hei√üe Igor Volkov. Ich arbeite in einem Beratungsunternehmen als Java-Entwickler, Architekt, Teamleiter und technischer Manager. Unterschiedliche ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zweiter Platz in der Mini AI Cup 4: Paper IO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466597/"><p>  Ich hei√üe Igor Volkov.  Ich arbeite in einem Beratungsunternehmen als Java-Entwickler, Architekt, Teamleiter und technischer Manager.  Unterschiedliche Rollen je nach den aktuellen Anforderungen des Projekts.  Er machte lange Zeit auf Wettbewerbe von mail.ru aufmerksam, aber es stellte sich heraus, dass er nur bei Paper IO aktiv teilnahm. </p><br><p><img width="120" height="120" align="left" src="https://habrastorage.org/webt/nd/gt/uf/ndgtufwihri2t-l1ehiq6pbr_ce.png"></p><p>  Diesmal schlugen die Organisatoren vor, eine Bot-Management-Strategie basierend auf dem beliebten Spiel zu implementieren.  Lesen Sie hier mehr √ºber die Regeln.  Den Code meiner Strategie und Beispiele f√ºr Spiele finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website der Meisterschaft</a> . <br></p><br><a name="habracut"></a><br><hr><br><p> Zu Beginn des Wettbewerbs war, wie mir schien, die h√§ufigste Idee f√ºr die Popup-Implementierung die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCTS</a> .  Daher habe ich ein wenig Zeit damit verbracht, mit diesem Algorithmus zu experimentieren.  Und ohne herausgefunden zu haben, wie man es effektiv zur L√∂sung des Problems einsetzt, habe ich mich entschlossen, zun√§chst viele rechteckige Routen (mit zwei und dann mit drei Umdrehungen) und deren anschlie√üende Bewertung zu generieren. </p><br><h2 id="algoritm-strategii">  Strategiealgorithmus </h2><br><p>  Der √ºbergeordnete Algorithmus der Strategie kann durch die folgenden 6 Punkte dargestellt werden: </p><br><ol><li>  Lesen Sie den Zustand der Welt </li><li>  Konvertieren Sie Nachrichtenobjekte in Arbeitsobjekte </li><li>  Bilden Sie eine Reihe rechteckiger Routen </li><li>  Bewerten Sie jede der generierten Routen </li><li>  W√§hlen Sie die beste Route </li><li>  Team senden </li></ol><br><p>  Dieser Algorithmus hat sich w√§hrend des Wettbewerbs nicht ge√§ndert.  Nur die Methode zur Bildung von Bot-Routen und deren Bewertung wurden ge√§ndert. </p><br><p>  Die <a href="">SimpleStrategy-</a> Klasse enth√§lt die urspr√ºngliche Version der Strategie, und die <a href="">BestStrategy-</a> Klasse <a href="">ist</a> eine verbesserte Version, die im Wettbewerb den 2. Platz belegte. </p><br><h3 id="chtenie-sostoyaniya-mira">  Den Zustand der Welt lesen </h3><br><p>  Der Zustand der Welt wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-</a> Objekt √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STDIN √ºbertragen</a> .  Ich habe in <a href="">pom.xml gesehen,</a> dass Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gson-</a> Bibliothek verwenden k√∂nnen und die Aufgabe, den Zustand der Welt zu lesen, wurde stark vereinfacht.  Deserialisierte mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gson-</a> Bibliothek die aus dem Standardeingabestream gelesene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-</a> Zeichenfolge in eine Instanz der <a href="">Message-</a> Klasse.  Der Code befindet sich in <a href="">Main.java (Zeilen 44-49)</a> . </p><br><h3 id="sozdanie-rabochih-obektov">  Arbeitsobjekte erstellen </h3><br><p>  Die Verwendung von Transportobjekten im Hauptprogrammcode ist normalerweise nicht sehr bequem und architektonisch falsch.  Beispielsweise k√∂nnen die Organisatoren aus dem einen oder anderen Grund das Format von Nachrichten √§ndern.  Daher ist es notwendig, Transportobjekte in Worker umzuwandeln, die im Hauptprogrammcode verwendet werden.  Die <a href="">Klassen</a> <a href="">Player</a> und <a href="">PlayerState behalten</a> den Status des Bots bei, und die Dienstprogrammklasse <a href="">MessagePlayer2PlayerConverter</a> hilft beim Erstellen dieser Klassen basierend auf Daten aus der Transportnachricht.  Die <a href="">Bonusklasse</a> enth√§lt Informationen √ºber den Bonus einer Zelle im Spielfeld.  Der Code zum Erstellen von Arbeitsobjekten befindet sich in <a href="">Main.java (Zeilen 61-74)</a> . </p><br><h3 id="formirovanie-marshrutov">  Routenbildung </h3><br><p>  In den ersten Versionen der Strategie ( <a href="">SimpleStrategy</a> ) wurde der Pfad mithilfe der Klassen <a href="">MovePlanWithScore</a> und <a href="">Move festgelegt</a> .  <a href="">Move</a> legt die Bewegungsrichtung und die <a href="">Anzahl</a> der Zellen fest, die der Bot in diese Richtung bewegen soll. <a href="">MovePlanWithScore</a> enth√§lt die vom <a href="">Move-</a> Array angegebene Route und eine Sch√§tzung dieser Route.  Ein Array kann ein bis vier <a href="">Verschiebungsobjekte enthalten</a> .  Trotz der Tatsache, dass nur rechteckige Routen mit nicht mehr als drei Kurven ber√ºcksichtigt werden, wird die Route des Bots tats√§chlich in Form einer unterbrochenen Linie erhalten.  Dies wird erreicht, indem in jeder Runde eine neue beste rechteckige Route ausgew√§hlt wird.  <a href="">Die</a> <a href="">Routengenerierungsfunktion</a> , die als verschachtelte Schleifen implementiert ist, bildet eine Liste von <a href="">MovePlanWithScore</a> zur weiteren Auswertung. </p><br><p>  Eine solche Bildung der Flugbahnen des Bots war im Hinblick auf die Leistung der nachfolgenden Bewertung nicht sehr effektiv, da es notwendig war, dieselben Flugbahnen mehrmals zu berechnen, aber sie war sehr n√ºtzlich, um die Mechanik des Spiels zu verstehen. </p><br><p>  In sp√§teren Versionen der Strategie begann <a href="">BestStrategy</a> , den <a href="">Routenbaum</a> zu verwenden.  Die <a href="">MoveNode-</a> Klasse spiegelt den Knoten dieses Baums wider.  Der Baum ist zu Beginn der Strategie vollst√§ndig gebildet.  <a href="">Beachten Sie</a> die <a href="">init-</a> Methode <a href="">der MoveNode-Klasse</a> .  Es ist dem Generieren von Routen aus der <a href="">SimpleStrategy-</a> Klasse sehr √§hnlich.  Grunds√§tzlich unterscheidet sich die fragliche Route nicht wesentlich von der ersten Version. </p><br><p>  Ich denke, die Bildung von Routen h√§tte durch eine weitere Wendung etwas verbessert werden k√∂nnen.  Es blieb jedoch nicht gen√ºgend Zeit f√ºr die Optimierung. </p><br><h3 id="ocenka-marshruta">  Routenbewertung </h3><br><p>  Wo immer sich der Bot befand, wurde f√ºr ihn immer die beste Route gew√§hlt, die auf seinem Territorium endet.  Um die Route zu bewerten, habe ich zwei Indikatoren eingef√ºhrt: Punktzahl und Risiko.  Punktzahl - spiegelt ungef√§hr die Anzahl der pro Tick des Pfades erzielten Punkte und das Risiko wider - die Anzahl der Ticks, die nicht ausreichen, um den Pfad zu vervollst√§ndigen (z. B. aufgrund der Tatsache, dass der Gegner am Schwanz greifen kann).  Das Risiko trat nicht sofort auf.  Wenn der Bot in der ersten Version pl√∂tzlich in der Mitte des Pfades feststellte, dass er keine Zeit hatte, die Route abzuschlie√üen, wurde er ‚Äûverr√ºckt‚Äú, da alle gef√§hrlichen Pfade gleicherma√üen schlecht f√ºr ihn waren.  Von allen betrachteten Routen wird die ‚Äûsicherste‚Äú mit der maximalen Anzahl von Punkten pro Tick des Pfades ausgew√§hlt. </p><br><p>  Um die Sicherheit der Route zu beurteilen, berechne ich die Erreichbarkeitsmatrix: F√ºr jede Zelle des Spielfelds finde ich ein H√§kchen, auf dem der Bot des Gegners erscheinen kann.  Zuerst nur ein H√§kchen und sp√§ter eine Schwanzl√§ngenberechnung.  Boni, die auf dem Weg abgeholt werden k√∂nnen, wurden in den ersten Versionen der Strategie ebenfalls nicht ber√ºcksichtigt.  Die <a href="">TimeMatrixBuilder-</a> Klasse berechnet Matrizen von Ticks und Schwanzl√§ngen von konkurrierenden Bots.  Diese Matrizen werden dann zur Risikobewertung verwendet.  Befindet sich mein Bot zum Zeitpunkt der Berechnung des n√§chsten Zuges auf seinem Territorium - das maximale Risiko wird gef√§hrlichen Routen zugewiesen. Wenn der Bot bereits in einem fremden oder neutralen Territorium unterwegs war, wird das Risiko als Differenz zwischen den Zecken der Fertigstellung des Pfades (der Bot kam in sein Territorium) und der Zecke bewertet, wenn dies m√∂glich ist Gefahr drohen (zum Beispiel kann der Bot eines anderen auf den Schwanz treten). </p><br><p>  In den ersten Versionen der Strategie wurde die Punktzahl nur auf der Grundlage des eroberten Gebiets ber√ºcksichtigt und die Boni wurden geringf√ºgig ber√ºcksichtigt.  Um die erfassten Zellen zu finden, verwende ich einen <a href="">rekursiven Algorithmus</a> .  Viele Teilnehmer beklagten sich √ºber die Seltsamkeit und den √ºberm√§√üigen Rechenaufwand des von den Organisatoren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Local Runner</a> verwendeten Algorithmus.  Ich gehe davon aus, dass dies absichtlich gemacht wurde, um den Teilnehmern des Wettbewerbs keine vorgefertigten L√∂sungen zu geben. </p><br><p>  Seltsam, aber trotz der Primitivit√§t der ersten Versionen der Strategie zeigte es sich recht gut: 10. Platz im Sandkasten.  Zwar begann er in der Vorrunde schnell zu sinken: Andere Teilnehmer verbesserten ihre Strategien. </p><br><p>  Mein Bot ist oft gestorben.  Zuallererst aufgrund der Tatsache, dass eine Route zu dem Gebiet gebaut wurde, das von rivalisierenden Bots erobert wurde.  Der Weg verl√§ngerte sich unerwartet und mein Bot wurde vom Schwanz gefangen.  Oft gestorben aufgrund einer falschen Vorhersage der L√§nge des Schwanzes und der Geschwindigkeit des Bot des Gegners.  Zum Beispiel war es gef√§hrlich, wenn der Bot eines Gegners langsamer wurde, da die Strategie ungef√§hr voraussetzte, dass er die Zelle bereits h√§tte verlassen sollen und immer noch da war.  Um diese Probleme zu bek√§mpfen, begann ich, eine gr√∂√üere Anzahl von Indikatoren f√ºr jede Zelle des Spielfelds zu berechnen (Klassen <a href="">AnalyticsBuilder</a> und <a href="">CellDetails</a> ). </p><br><p>  <strong>Zellen des Spielfeldes z√§hlen</strong> </p><br><ol><li>  H√§kchen, bei dem der Bot des Gegners den K√§fig besetzen kann (H√§kchen am Schwanz) </li><li>  Kreuzen Sie an, bei dem der Bot des Gegners die Zelle betreten kann </li><li>  Die L√§nge des Schwanzes beim Betreten des K√§figs </li><li>  H√§kchen, bei dem der Bot des Gegners den K√§fig verlassen kann </li><li>  Schwanzl√§nge beim Verlassen des K√§figs </li><li>  H√§kchen, bei dem eine Zelle vom Bot eines Gegners erfasst werden kann </li><li>  H√§kchen, bei dem die Zelle das Ziel f√ºr die Erfassung des Territoriums sein kann </li><li>  H√§kchen, auf das die Zelle mit einer S√§ge geschlagen werden kann </li></ol><br><p>  Die Analysetiefe ist auf 10 Z√ºge begrenzt.  Ich denke, es war m√∂glich, eine gr√∂√üere Tiefe zu erreichen, indem man sich weigerte, einzelne Rivalen zu z√§hlen oder eine schwebende Tiefe einzuf√ºhren, aber es gab nicht genug Zeit f√ºr die Optimierung.  Zus√§tzlich zu <a href="">AnalyticsBuilder begann</a> er mit der Verwendung von <a href="">SimpleTickMatrixBuilder,</a> wenn es an Rendering-Tiefe f√ºr <a href="">AnalyticsBuilder</a> mangelte.  <a href="">Analyseergebnisse</a> werden von <a href="">BestStrategy verwendet</a> . </p><br><p>  Die Bewertungsfunktion hat sich ebenfalls leicht verbessert: </p><br><ol><li>  Ich fing an, Boni zu ber√ºcksichtigen: eine Strafe f√ºr einen Verz√∂gerungsbonus und einen Bonus f√ºr Beschleunigungs- und S√§geboni.  Infolgedessen begann der Bot, schlechte Boni erfolgreich zu vermeiden und sammelte dabei gute. </li><li>  Er begann das Aufeinandertreffen der K√∂pfe zu ber√ºcksichtigen.  Es wurden einige Punkte f√ºr den Sieg hinzugef√ºgt.  Je weiter eine m√∂gliche Kollision entfernt ist, desto weniger Punkte. </li><li>  Um die Wahrscheinlichkeit der Umgebung zu verringern, f√ºgte er einige Punkte hinzu, um die Grenzzellen des Gegners zu √ºbernehmen. </li><li>  Der Wert leerer Zellen am Rand wurde verringert: Je weiter von der Mitte entfernt, desto niedriger ist der Wert.  Als ich mir die K√§mpfe des Finales ansah, kam ich zu dem Schluss, dass es f√ºr die Tatsache, eine leere Zelle zu erobern, √ºberhaupt keine Notwendigkeit gab, Punkte zu sammeln.  Der Wert einer leeren Zelle sollte von der N√§he zu gro√üen Gruppen feindlicher Zellen abh√§ngen.  Leider war es im Finale nicht mehr m√∂glich, die Strategie zu bearbeiten. </li><li>  Es wurden Punkte hinzugef√ºgt, um den Bot-Kopf des Gegners zu umgeben.  Ich bin mir nicht sicher, ob das irgendwie geholfen hat.  Vielleicht mit den einfachsten Strategien. </li><li>  Er f√ºgte Punkte hinzu, selbst wenn er vergeblich am Schwanz packte (der Bot des Gegners schaffte es, das Gebiet mit demselben Tick zu erobern, in dem mein Bot auf seinen Schwanz trat).  Ich bin mir definitiv nicht sicher, aber ich denke, dass dies die Bots des Gegners daran gehindert hat, das Territorium eines anderen zu erobern, und sie mussten oft zu ihrem eigenen zur√ºckkehren. </li><li>  Im Falle der Entdeckung eines m√∂glichen Todes durch Gefangennahme erh√∂hten sich die Kosten f√ºr die Grenzzellen des gegnerischen Territoriums erheblich. </li></ol><br><h2 id="otladka-strategii">  Strategie-Debugging </h2><br><p> Die ersten Versionen der Strategie enthielten eine gro√üe Anzahl von Tippfehlern und Fehlern: anscheinend das Ergebnis n√§chtlicher Programmierung.  In der <a href="">Cell-</a> Klasse wurde der Index beispielsweise falsch ber√ºcksichtigt: Anstelle von <code>this.index = x * Game.sizeY + y</code> war <code>this.index = x * Game.width + y</code> .  Zuerst habe ich versucht, mich nur auf Tests zu verlassen, aber meine Intuition deutete darauf hin, dass es ohne Visualisierung und ohne zuvor gespielte Spiele schwierig sein w√ºrde, Fehler im Code zu finden und die Gr√ºnde f√ºr fehlerhafte Entscheidungen zu analysieren.  Als Ergebnis wurde der <a href="">DebugWindow-</a> Visualizer <a href="">angezeigt</a> , in dem Sie zuvor gespielte Spiele Schritt f√ºr Schritt anzeigen und mit dem Debuggen des gew√ºnschten H√§kchens beginnen k√∂nnen.  Der Code ist nicht sehr sch√∂n, in Eile geschrieben, aber er hat mir beim Debuggen sehr geholfen.  Beispielsweise wurde bei einer falschen Berechnung des Zellenindex sofort ein Fehler festgestellt.  Viele Teilnehmer zeigten Debugging-Informationen in der Konsole an, aber es schien mir nicht genug. </p><br><img src="https://habrastorage.org/webt/rz/ys/k3/rzysk31_gefvqcgq4vjbyosotqe.png"><br><br><h2 id="optimizaciya">  Optimierung </h2><br><p>  Um keine Zeit mit dem Erstellen von Objekten und dem Ausf√ºhren des GC zu verschwenden, habe ich versucht, einige Objekte im Voraus zu erstellen.  Dies sind die Zellen des Spielfeldes ( <a href="">Zellklasse</a> ).  Zus√§tzlich f√ºr jede Zelle identifizierte Nachbarn.  Erstellt im Voraus einen Baum m√∂glicher Pfade (Klasse <a href="">MoveNode</a> ). </p><br><p>  Ich ging davon aus, dass viele Szenarien simuliert werden m√ºssten und sich dabei der aktuelle Zustand verschlechtern und jedes Mal wiederhergestellt werden m√ºsste.  Um den Zustand der Welt zu erhalten, habe ich versucht, so viele gepackte Strukturen wie m√∂glich zu verwenden.  So speichern Sie das besetzte Gebiet - BitSet (Klasse <a href="">PlayerTerritory</a> ).  Jede Zelle des Spielfelds ist nummeriert und die Zellennummer entspricht der Bitnummer in BitSet.  Um den Schwanz zu speichern, habe ich BitSet zusammen mit ArrayDeque (Klasse <a href="">PlayerTail</a> ) verwendet. <br></p><p>  Es stimmt, ich habe aus Zeitmangel nicht verschiedene Szenarien gespielt.  Und da die Hauptfunktion der Berechnung des Pfades rekursiv wurde und der gesamte Status auf dem Stapel gespeichert werden konnte, waren die neuesten Optimierungen f√ºr mich nicht sehr n√ºtzlich. </p><br><h2 id="nerealizovannye-idei">  Nicht realisierte Ideen </h2><br><p>  Bei der Beurteilung des Routenrisikos meines Bots habe ich jeden Gegner unabh√§ngig ber√ºcksichtigt.  Tats√§chlich hat jeder der Rivalen auch Angst zu sterben.  Daher lohnt es sich, dies bei einer Risikobewertung zu ber√ºcksichtigen.  Zumindest musste dies bei den Endspielen unbedingt ber√ºcksichtigt werden. </p><br><p>  Ber√ºcksichtigung des zuk√ºnftigen Todes eines Gegners.  Manchmal kam es vor, dass der Bot das Territorium des Gegners einnimmt und der Gegner unerwartet stirbt.  Es ist eine Schande, weil Sie daher nur leere Zellen erfassen. </p><br><p>  Ber√ºcksichtigung leerer Zellen, die in naher Zukunft als Bewertungsfunktion erfasst werden. </p><br><h2 id="rekomendacii-i-blagodarnosti">  Empfehlungen und danke </h2><br><p>  Ich empfehle allen Entwicklern, aktiv an AI Cups-Wettbewerben teilzunehmen.  Dies entwickelt das Denken und hilft im Spiel, neue Algorithmen zu lernen.  Und wie meine Erfahrung gezeigt hat, reicht ein wenig Eifer aus, um einen Preisplatz einzunehmen, und selbst ein einfacher und nicht sehr optimaler Code kann Ergebnisse bringen. </p><br><p>  Vielen Dank an die Organisatoren.  Trotz einiger technischer Probleme erwies sich der Wettbewerb als interessant.  Ich freue mich auf den n√§chsten! </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466597/">https://habr.com/ru/post/de466597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466583/index.html">Eine kurze Geschichte des L√ºgendetektors</a></li>
<li><a href="../de466585/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka. Kapitel 3. Kafka</a></li>
<li><a href="../de466589/index.html">So empfangen Sie Daten von Google Analytics mit R in Microsoft SQL Server</a></li>
<li><a href="../de466591/index.html">MVC ohne C: Was √§ndert SwiftUI in der Anwendungsarchitektur?</a></li>
<li><a href="../de466593/index.html">Situation: Hybrid Cloud- und IaaS-Perspektiven</a></li>
<li><a href="../de466599/index.html">So umgehen Sie Captcha mithilfe der Tonerkennung</a></li>
<li><a href="../de466601/index.html">Psychologische Selbsthilfeb√ºcher: Machen sie √ºberhaupt Sinn und wenn ja, welche?</a></li>
<li><a href="../de466603/index.html">Tool zum Vergleichen von CSS-Frameworks</a></li>
<li><a href="../de466605/index.html">Nischni Nowgorod Funklabor und Amateurfunkkommunikation auf HF</a></li>
<li><a href="../de466607/index.html">"Alles, was Sie lesen, wird gegen Sie verwendet": Wie Rap-Musik in den Gerichtssaal kam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>