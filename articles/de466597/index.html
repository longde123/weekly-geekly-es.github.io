<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧 👩🏽‍🍳 🐟 Zweiter Platz in der Mini AI Cup 4: Paper IO 🤥 🤚🏼 🃏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich heiße Igor Volkov. Ich arbeite in einem Beratungsunternehmen als Java-Entwickler, Architekt, Teamleiter und technischer Manager. Unterschiedliche ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zweiter Platz in der Mini AI Cup 4: Paper IO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466597/"><p>  Ich heiße Igor Volkov.  Ich arbeite in einem Beratungsunternehmen als Java-Entwickler, Architekt, Teamleiter und technischer Manager.  Unterschiedliche Rollen je nach den aktuellen Anforderungen des Projekts.  Er machte lange Zeit auf Wettbewerbe von mail.ru aufmerksam, aber es stellte sich heraus, dass er nur bei Paper IO aktiv teilnahm. </p><br><p><img width="120" height="120" align="left" src="https://habrastorage.org/webt/nd/gt/uf/ndgtufwihri2t-l1ehiq6pbr_ce.png"></p><p>  Diesmal schlugen die Organisatoren vor, eine Bot-Management-Strategie basierend auf dem beliebten Spiel zu implementieren.  Lesen Sie hier mehr über die Regeln.  Den Code meiner Strategie und Beispiele für Spiele finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website der Meisterschaft</a> . <br></p><br><a name="habracut"></a><br><hr><br><p> Zu Beginn des Wettbewerbs war, wie mir schien, die häufigste Idee für die Popup-Implementierung die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCTS</a> .  Daher habe ich ein wenig Zeit damit verbracht, mit diesem Algorithmus zu experimentieren.  Und ohne herausgefunden zu haben, wie man es effektiv zur Lösung des Problems einsetzt, habe ich mich entschlossen, zunächst viele rechteckige Routen (mit zwei und dann mit drei Umdrehungen) und deren anschließende Bewertung zu generieren. </p><br><h2 id="algoritm-strategii">  Strategiealgorithmus </h2><br><p>  Der übergeordnete Algorithmus der Strategie kann durch die folgenden 6 Punkte dargestellt werden: </p><br><ol><li>  Lesen Sie den Zustand der Welt </li><li>  Konvertieren Sie Nachrichtenobjekte in Arbeitsobjekte </li><li>  Bilden Sie eine Reihe rechteckiger Routen </li><li>  Bewerten Sie jede der generierten Routen </li><li>  Wählen Sie die beste Route </li><li>  Team senden </li></ol><br><p>  Dieser Algorithmus hat sich während des Wettbewerbs nicht geändert.  Nur die Methode zur Bildung von Bot-Routen und deren Bewertung wurden geändert. </p><br><p>  Die <a href="">SimpleStrategy-</a> Klasse enthält die ursprüngliche Version der Strategie, und die <a href="">BestStrategy-</a> Klasse <a href="">ist</a> eine verbesserte Version, die im Wettbewerb den 2. Platz belegte. </p><br><h3 id="chtenie-sostoyaniya-mira">  Den Zustand der Welt lesen </h3><br><p>  Der Zustand der Welt wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-</a> Objekt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STDIN übertragen</a> .  Ich habe in <a href="">pom.xml gesehen,</a> dass Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gson-</a> Bibliothek verwenden können und die Aufgabe, den Zustand der Welt zu lesen, wurde stark vereinfacht.  Deserialisierte mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gson-</a> Bibliothek die aus dem Standardeingabestream gelesene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-</a> Zeichenfolge in eine Instanz der <a href="">Message-</a> Klasse.  Der Code befindet sich in <a href="">Main.java (Zeilen 44-49)</a> . </p><br><h3 id="sozdanie-rabochih-obektov">  Arbeitsobjekte erstellen </h3><br><p>  Die Verwendung von Transportobjekten im Hauptprogrammcode ist normalerweise nicht sehr bequem und architektonisch falsch.  Beispielsweise können die Organisatoren aus dem einen oder anderen Grund das Format von Nachrichten ändern.  Daher ist es notwendig, Transportobjekte in Worker umzuwandeln, die im Hauptprogrammcode verwendet werden.  Die <a href="">Klassen</a> <a href="">Player</a> und <a href="">PlayerState behalten</a> den Status des Bots bei, und die Dienstprogrammklasse <a href="">MessagePlayer2PlayerConverter</a> hilft beim Erstellen dieser Klassen basierend auf Daten aus der Transportnachricht.  Die <a href="">Bonusklasse</a> enthält Informationen über den Bonus einer Zelle im Spielfeld.  Der Code zum Erstellen von Arbeitsobjekten befindet sich in <a href="">Main.java (Zeilen 61-74)</a> . </p><br><h3 id="formirovanie-marshrutov">  Routenbildung </h3><br><p>  In den ersten Versionen der Strategie ( <a href="">SimpleStrategy</a> ) wurde der Pfad mithilfe der Klassen <a href="">MovePlanWithScore</a> und <a href="">Move festgelegt</a> .  <a href="">Move</a> legt die Bewegungsrichtung und die <a href="">Anzahl</a> der Zellen fest, die der Bot in diese Richtung bewegen soll. <a href="">MovePlanWithScore</a> enthält die vom <a href="">Move-</a> Array angegebene Route und eine Schätzung dieser Route.  Ein Array kann ein bis vier <a href="">Verschiebungsobjekte enthalten</a> .  Trotz der Tatsache, dass nur rechteckige Routen mit nicht mehr als drei Kurven berücksichtigt werden, wird die Route des Bots tatsächlich in Form einer unterbrochenen Linie erhalten.  Dies wird erreicht, indem in jeder Runde eine neue beste rechteckige Route ausgewählt wird.  <a href="">Die</a> <a href="">Routengenerierungsfunktion</a> , die als verschachtelte Schleifen implementiert ist, bildet eine Liste von <a href="">MovePlanWithScore</a> zur weiteren Auswertung. </p><br><p>  Eine solche Bildung der Flugbahnen des Bots war im Hinblick auf die Leistung der nachfolgenden Bewertung nicht sehr effektiv, da es notwendig war, dieselben Flugbahnen mehrmals zu berechnen, aber sie war sehr nützlich, um die Mechanik des Spiels zu verstehen. </p><br><p>  In späteren Versionen der Strategie begann <a href="">BestStrategy</a> , den <a href="">Routenbaum</a> zu verwenden.  Die <a href="">MoveNode-</a> Klasse spiegelt den Knoten dieses Baums wider.  Der Baum ist zu Beginn der Strategie vollständig gebildet.  <a href="">Beachten Sie</a> die <a href="">init-</a> Methode <a href="">der MoveNode-Klasse</a> .  Es ist dem Generieren von Routen aus der <a href="">SimpleStrategy-</a> Klasse sehr ähnlich.  Grundsätzlich unterscheidet sich die fragliche Route nicht wesentlich von der ersten Version. </p><br><p>  Ich denke, die Bildung von Routen hätte durch eine weitere Wendung etwas verbessert werden können.  Es blieb jedoch nicht genügend Zeit für die Optimierung. </p><br><h3 id="ocenka-marshruta">  Routenbewertung </h3><br><p>  Wo immer sich der Bot befand, wurde für ihn immer die beste Route gewählt, die auf seinem Territorium endet.  Um die Route zu bewerten, habe ich zwei Indikatoren eingeführt: Punktzahl und Risiko.  Punktzahl - spiegelt ungefähr die Anzahl der pro Tick des Pfades erzielten Punkte und das Risiko wider - die Anzahl der Ticks, die nicht ausreichen, um den Pfad zu vervollständigen (z. B. aufgrund der Tatsache, dass der Gegner am Schwanz greifen kann).  Das Risiko trat nicht sofort auf.  Wenn der Bot in der ersten Version plötzlich in der Mitte des Pfades feststellte, dass er keine Zeit hatte, die Route abzuschließen, wurde er „verrückt“, da alle gefährlichen Pfade gleichermaßen schlecht für ihn waren.  Von allen betrachteten Routen wird die „sicherste“ mit der maximalen Anzahl von Punkten pro Tick des Pfades ausgewählt. </p><br><p>  Um die Sicherheit der Route zu beurteilen, berechne ich die Erreichbarkeitsmatrix: Für jede Zelle des Spielfelds finde ich ein Häkchen, auf dem der Bot des Gegners erscheinen kann.  Zuerst nur ein Häkchen und später eine Schwanzlängenberechnung.  Boni, die auf dem Weg abgeholt werden können, wurden in den ersten Versionen der Strategie ebenfalls nicht berücksichtigt.  Die <a href="">TimeMatrixBuilder-</a> Klasse berechnet Matrizen von Ticks und Schwanzlängen von konkurrierenden Bots.  Diese Matrizen werden dann zur Risikobewertung verwendet.  Befindet sich mein Bot zum Zeitpunkt der Berechnung des nächsten Zuges auf seinem Territorium - das maximale Risiko wird gefährlichen Routen zugewiesen. Wenn der Bot bereits in einem fremden oder neutralen Territorium unterwegs war, wird das Risiko als Differenz zwischen den Zecken der Fertigstellung des Pfades (der Bot kam in sein Territorium) und der Zecke bewertet, wenn dies möglich ist Gefahr drohen (zum Beispiel kann der Bot eines anderen auf den Schwanz treten). </p><br><p>  In den ersten Versionen der Strategie wurde die Punktzahl nur auf der Grundlage des eroberten Gebiets berücksichtigt und die Boni wurden geringfügig berücksichtigt.  Um die erfassten Zellen zu finden, verwende ich einen <a href="">rekursiven Algorithmus</a> .  Viele Teilnehmer beklagten sich über die Seltsamkeit und den übermäßigen Rechenaufwand des von den Organisatoren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Local Runner</a> verwendeten Algorithmus.  Ich gehe davon aus, dass dies absichtlich gemacht wurde, um den Teilnehmern des Wettbewerbs keine vorgefertigten Lösungen zu geben. </p><br><p>  Seltsam, aber trotz der Primitivität der ersten Versionen der Strategie zeigte es sich recht gut: 10. Platz im Sandkasten.  Zwar begann er in der Vorrunde schnell zu sinken: Andere Teilnehmer verbesserten ihre Strategien. </p><br><p>  Mein Bot ist oft gestorben.  Zuallererst aufgrund der Tatsache, dass eine Route zu dem Gebiet gebaut wurde, das von rivalisierenden Bots erobert wurde.  Der Weg verlängerte sich unerwartet und mein Bot wurde vom Schwanz gefangen.  Oft gestorben aufgrund einer falschen Vorhersage der Länge des Schwanzes und der Geschwindigkeit des Bot des Gegners.  Zum Beispiel war es gefährlich, wenn der Bot eines Gegners langsamer wurde, da die Strategie ungefähr voraussetzte, dass er die Zelle bereits hätte verlassen sollen und immer noch da war.  Um diese Probleme zu bekämpfen, begann ich, eine größere Anzahl von Indikatoren für jede Zelle des Spielfelds zu berechnen (Klassen <a href="">AnalyticsBuilder</a> und <a href="">CellDetails</a> ). </p><br><p>  <strong>Zellen des Spielfeldes zählen</strong> </p><br><ol><li>  Häkchen, bei dem der Bot des Gegners den Käfig besetzen kann (Häkchen am Schwanz) </li><li>  Kreuzen Sie an, bei dem der Bot des Gegners die Zelle betreten kann </li><li>  Die Länge des Schwanzes beim Betreten des Käfigs </li><li>  Häkchen, bei dem der Bot des Gegners den Käfig verlassen kann </li><li>  Schwanzlänge beim Verlassen des Käfigs </li><li>  Häkchen, bei dem eine Zelle vom Bot eines Gegners erfasst werden kann </li><li>  Häkchen, bei dem die Zelle das Ziel für die Erfassung des Territoriums sein kann </li><li>  Häkchen, auf das die Zelle mit einer Säge geschlagen werden kann </li></ol><br><p>  Die Analysetiefe ist auf 10 Züge begrenzt.  Ich denke, es war möglich, eine größere Tiefe zu erreichen, indem man sich weigerte, einzelne Rivalen zu zählen oder eine schwebende Tiefe einzuführen, aber es gab nicht genug Zeit für die Optimierung.  Zusätzlich zu <a href="">AnalyticsBuilder begann</a> er mit der Verwendung von <a href="">SimpleTickMatrixBuilder,</a> wenn es an Rendering-Tiefe für <a href="">AnalyticsBuilder</a> mangelte.  <a href="">Analyseergebnisse</a> werden von <a href="">BestStrategy verwendet</a> . </p><br><p>  Die Bewertungsfunktion hat sich ebenfalls leicht verbessert: </p><br><ol><li>  Ich fing an, Boni zu berücksichtigen: eine Strafe für einen Verzögerungsbonus und einen Bonus für Beschleunigungs- und Sägeboni.  Infolgedessen begann der Bot, schlechte Boni erfolgreich zu vermeiden und sammelte dabei gute. </li><li>  Er begann das Aufeinandertreffen der Köpfe zu berücksichtigen.  Es wurden einige Punkte für den Sieg hinzugefügt.  Je weiter eine mögliche Kollision entfernt ist, desto weniger Punkte. </li><li>  Um die Wahrscheinlichkeit der Umgebung zu verringern, fügte er einige Punkte hinzu, um die Grenzzellen des Gegners zu übernehmen. </li><li>  Der Wert leerer Zellen am Rand wurde verringert: Je weiter von der Mitte entfernt, desto niedriger ist der Wert.  Als ich mir die Kämpfe des Finales ansah, kam ich zu dem Schluss, dass es für die Tatsache, eine leere Zelle zu erobern, überhaupt keine Notwendigkeit gab, Punkte zu sammeln.  Der Wert einer leeren Zelle sollte von der Nähe zu großen Gruppen feindlicher Zellen abhängen.  Leider war es im Finale nicht mehr möglich, die Strategie zu bearbeiten. </li><li>  Es wurden Punkte hinzugefügt, um den Bot-Kopf des Gegners zu umgeben.  Ich bin mir nicht sicher, ob das irgendwie geholfen hat.  Vielleicht mit den einfachsten Strategien. </li><li>  Er fügte Punkte hinzu, selbst wenn er vergeblich am Schwanz packte (der Bot des Gegners schaffte es, das Gebiet mit demselben Tick zu erobern, in dem mein Bot auf seinen Schwanz trat).  Ich bin mir definitiv nicht sicher, aber ich denke, dass dies die Bots des Gegners daran gehindert hat, das Territorium eines anderen zu erobern, und sie mussten oft zu ihrem eigenen zurückkehren. </li><li>  Im Falle der Entdeckung eines möglichen Todes durch Gefangennahme erhöhten sich die Kosten für die Grenzzellen des gegnerischen Territoriums erheblich. </li></ol><br><h2 id="otladka-strategii">  Strategie-Debugging </h2><br><p> Die ersten Versionen der Strategie enthielten eine große Anzahl von Tippfehlern und Fehlern: anscheinend das Ergebnis nächtlicher Programmierung.  In der <a href="">Cell-</a> Klasse wurde der Index beispielsweise falsch berücksichtigt: Anstelle von <code>this.index = x * Game.sizeY + y</code> war <code>this.index = x * Game.width + y</code> .  Zuerst habe ich versucht, mich nur auf Tests zu verlassen, aber meine Intuition deutete darauf hin, dass es ohne Visualisierung und ohne zuvor gespielte Spiele schwierig sein würde, Fehler im Code zu finden und die Gründe für fehlerhafte Entscheidungen zu analysieren.  Als Ergebnis wurde der <a href="">DebugWindow-</a> Visualizer <a href="">angezeigt</a> , in dem Sie zuvor gespielte Spiele Schritt für Schritt anzeigen und mit dem Debuggen des gewünschten Häkchens beginnen können.  Der Code ist nicht sehr schön, in Eile geschrieben, aber er hat mir beim Debuggen sehr geholfen.  Beispielsweise wurde bei einer falschen Berechnung des Zellenindex sofort ein Fehler festgestellt.  Viele Teilnehmer zeigten Debugging-Informationen in der Konsole an, aber es schien mir nicht genug. </p><br><img src="https://habrastorage.org/webt/rz/ys/k3/rzysk31_gefvqcgq4vjbyosotqe.png"><br><br><h2 id="optimizaciya">  Optimierung </h2><br><p>  Um keine Zeit mit dem Erstellen von Objekten und dem Ausführen des GC zu verschwenden, habe ich versucht, einige Objekte im Voraus zu erstellen.  Dies sind die Zellen des Spielfeldes ( <a href="">Zellklasse</a> ).  Zusätzlich für jede Zelle identifizierte Nachbarn.  Erstellt im Voraus einen Baum möglicher Pfade (Klasse <a href="">MoveNode</a> ). </p><br><p>  Ich ging davon aus, dass viele Szenarien simuliert werden müssten und sich dabei der aktuelle Zustand verschlechtern und jedes Mal wiederhergestellt werden müsste.  Um den Zustand der Welt zu erhalten, habe ich versucht, so viele gepackte Strukturen wie möglich zu verwenden.  So speichern Sie das besetzte Gebiet - BitSet (Klasse <a href="">PlayerTerritory</a> ).  Jede Zelle des Spielfelds ist nummeriert und die Zellennummer entspricht der Bitnummer in BitSet.  Um den Schwanz zu speichern, habe ich BitSet zusammen mit ArrayDeque (Klasse <a href="">PlayerTail</a> ) verwendet. <br></p><p>  Es stimmt, ich habe aus Zeitmangel nicht verschiedene Szenarien gespielt.  Und da die Hauptfunktion der Berechnung des Pfades rekursiv wurde und der gesamte Status auf dem Stapel gespeichert werden konnte, waren die neuesten Optimierungen für mich nicht sehr nützlich. </p><br><h2 id="nerealizovannye-idei">  Nicht realisierte Ideen </h2><br><p>  Bei der Beurteilung des Routenrisikos meines Bots habe ich jeden Gegner unabhängig berücksichtigt.  Tatsächlich hat jeder der Rivalen auch Angst zu sterben.  Daher lohnt es sich, dies bei einer Risikobewertung zu berücksichtigen.  Zumindest musste dies bei den Endspielen unbedingt berücksichtigt werden. </p><br><p>  Berücksichtigung des zukünftigen Todes eines Gegners.  Manchmal kam es vor, dass der Bot das Territorium des Gegners einnimmt und der Gegner unerwartet stirbt.  Es ist eine Schande, weil Sie daher nur leere Zellen erfassen. </p><br><p>  Berücksichtigung leerer Zellen, die in naher Zukunft als Bewertungsfunktion erfasst werden. </p><br><h2 id="rekomendacii-i-blagodarnosti">  Empfehlungen und danke </h2><br><p>  Ich empfehle allen Entwicklern, aktiv an AI Cups-Wettbewerben teilzunehmen.  Dies entwickelt das Denken und hilft im Spiel, neue Algorithmen zu lernen.  Und wie meine Erfahrung gezeigt hat, reicht ein wenig Eifer aus, um einen Preisplatz einzunehmen, und selbst ein einfacher und nicht sehr optimaler Code kann Ergebnisse bringen. </p><br><p>  Vielen Dank an die Organisatoren.  Trotz einiger technischer Probleme erwies sich der Wettbewerb als interessant.  Ich freue mich auf den nächsten! </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466597/">https://habr.com/ru/post/de466597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466583/index.html">Eine kurze Geschichte des Lügendetektors</a></li>
<li><a href="../de466585/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging über ActiveMQ und Kafka. Kapitel 3. Kafka</a></li>
<li><a href="../de466589/index.html">So empfangen Sie Daten von Google Analytics mit R in Microsoft SQL Server</a></li>
<li><a href="../de466591/index.html">MVC ohne C: Was ändert SwiftUI in der Anwendungsarchitektur?</a></li>
<li><a href="../de466593/index.html">Situation: Hybrid Cloud- und IaaS-Perspektiven</a></li>
<li><a href="../de466599/index.html">So umgehen Sie Captcha mithilfe der Tonerkennung</a></li>
<li><a href="../de466601/index.html">Psychologische Selbsthilfebücher: Machen sie überhaupt Sinn und wenn ja, welche?</a></li>
<li><a href="../de466603/index.html">Tool zum Vergleichen von CSS-Frameworks</a></li>
<li><a href="../de466605/index.html">Nischni Nowgorod Funklabor und Amateurfunkkommunikation auf HF</a></li>
<li><a href="../de466607/index.html">"Alles, was Sie lesen, wird gegen Sie verwendet": Wie Rap-Musik in den Gerichtssaal kam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>