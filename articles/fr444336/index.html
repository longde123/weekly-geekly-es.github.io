<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧 👱 🥉 Listes de capture Swift: quelle est la différence entre les liens faibles, forts et non possédés? 🤙🏽 ⚫️ 👨‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Joseph Wright, le prisonnier - Illustration d'une capture forte 

 La liste des valeurs «capturées» se trouve devant la liste des paramètres de fermet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listes de capture Swift: quelle est la différence entre les liens faibles, forts et non possédés?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444336/"><img src="https://habrastorage.org/webt/ol/xa/zo/olxazojaea9ikajugulkcm6c-24.jpeg"><br>  <i>Joseph Wright, le prisonnier</i> - Illustration d'une capture forte <br><br>  La liste des valeurs «capturées» se trouve devant la liste des paramètres de fermeture et peut «capturer» les valeurs du périmètre de trois manières différentes: en utilisant les liens «fort», «faible» ou «sans propriétaire».  Nous l'utilisons souvent, principalement pour éviter les cycles de référence forts («cycles de référence forts» ou «conserver les cycles»). <br>  Il peut être difficile pour un développeur novice de décider quelle méthode utiliser, vous pouvez donc passer beaucoup de temps à choisir entre «fort» et «faible» ou entre «faible» et «sans propriétaire», mais avec le temps, vous vous rendrez compte que le bon choix - un seul. <br><a name="habracut"></a><br>  Créez d'abord une classe simple: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">playSong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Shake it off!"</span></span>) } }</code> </pre> <br>  Ensuite, nous écrivons une fonction qui crée une instance de la classe <b>Singer</b> et renvoie une fermeture qui appelle la méthode <b>playSong ()</b> de la classe <b>Singer</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Enfin, nous pouvons appeler <b>sing ()</b> n'importe où pour obtenir le résultat de la <b>lecture de playSong ()</b> <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singFunction = sing() singFunction()</code> </pre> <br><br>  En conséquence, la ligne «Secouez-le!» Sera affichée. <br><br><h2>  Capture forte </h2><br>  Sauf si vous spécifiez explicitement une méthode de capture, Swift utilise une capture «forte».  Cela signifie que la fermeture capture les valeurs externes utilisées et ne les laissera jamais libres. <br><br>  Jetons à nouveau un œil à la fonction <b>sing ()</b> <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  La <b>constante de Taylor est</b> définie à l'intérieur d'une fonction, donc dans des circonstances normales, sa place serait libérée une fois que la fonction a terminé son travail.  Cependant, cette constante est utilisée à l'intérieur de la fermeture, ce qui signifie que Swift assurera automatiquement sa présence tant que la fermeture elle-même existera, même après la fin de la fonction. <br>  Il s'agit d'une capture "forte" en action.  Si Swift autorisait la libération de <b>taylor</b> , appeler la fermeture serait dangereux - sa méthode <b>taylor.playSong ()</b> n'est plus valide. <br><br><h2>  Capture "faible" (capture faible) </h2><br>  Swift nous permet de créer une « <u>liste de capture</u> » pour déterminer comment les valeurs utilisées sont capturées.  Une alternative à la capture «forte» est «faible» et son application entraîne les conséquences suivantes: <br><br>  1. Les valeurs capturées «faiblement» ne sont pas conservées par la fermeture et peuvent donc être libérées et réglées sur <b>zéro</b> . <br><br>  2. En conséquence du premier paragraphe, les valeurs capturées «faiblement» dans Swift sont toujours <b>facultatives</b> . <br>  Nous modifions notre exemple en utilisant une capture «faible» et voyons immédiatement la différence. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> taylor] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor?.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  <b>[taylor faible]</b> - c'est notre " <u>liste de capture</u> ", une partie spéciale de la syntaxe de fermeture dans laquelle nous donnons des instructions sur la façon dont les valeurs doivent être capturées.  Ici, nous disons que <b>taylor</b> doit être capturé "faiblement", nous devons donc utiliser <b>taylor? .PlaySong ()</b> - maintenant, il est <b>facultatif</b> , car il peut être défini sur <b>nil</b> à tout moment. <br><br>  Si vous exécutez maintenant ce code, vous verrez que l'appel à <b>singFunction ()</b> n'entraîne plus de message.  La raison en est que <b>taylor</b> n'existe qu'à l'intérieur de <b>sing ()</b> , et la fermeture retournée par cette fonction ne maintient pas <b>taylor</b> «fortement» à l'intérieur de lui-même. <br><br>  Essayez maintenant de changer <b>taylor? .PlaySong ()</b> en <b>taylor! .PlaySong ()</b> .  Cela entraînera un déballage forcé du <b>taylor</b> à l'intérieur de la fermeture et, par conséquent, une erreur fatale (déballage du contenu contenant <b>zéro</b> ) <br><br><h2>  Capture "sans propriétaire" (capture sans propriétaire) </h2><br>  Une alternative à la capture «faible» est «sans propriétaire». <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Ce code se terminera anormalement de la même manière avec l'option facultative déployée illustrée ci-dessus - un <b>taylor sans</b> propriétaire dit: "Je sais avec certitude que <b>taylor</b> existera pendant la durée de la fermeture, donc je n'ai pas besoin de le garder en mémoire."  En fait, <b>taylor</b> sera publié presque immédiatement et ce code plantera. <br><br>  Alors, utilisez <b>-le</b> très soigneusement sans <b>propriétaire</b> . <br><br><h2>  Problèmes courants </h2><br>  Les développeurs sont confrontés à quatre problèmes lorsqu'ils utilisent la capture de valeur dans les fermetures: <br><br><h3>  1. Difficultés avec l'emplacement de la liste de capture dans le cas où la fermeture prend des paramètres </h3><br>  Il s'agit d'un problème courant que vous pouvez rencontrer au début de l'étude des fermetures, mais, heureusement, Swift nous aidera dans ce cas. <br><br>  Lorsque vous utilisez la liste de capture et les paramètres de fermeture ensemble, la liste de capture est d'abord entre crochets, puis les paramètres de fermeture, puis le mot clé in, marquant le début du «corps» de fermeture. <br><br><pre> <code class="swift hljs">writeToLog { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] user, message <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.addToLog(<span class="hljs-string"><span class="hljs-string">"\(user) triggered event: \(message)"</span></span>) }</code> </pre> <br>  Tenter de mettre une liste de capture après les paramètres de fermeture entraînera une erreur de compilation. <br><br><h3>  2. L'émergence d'un cycle de liens forts, conduisant à une fuite de mémoire </h3><br>  Lorsqu'une entité A a une entité B, et vice versa, vous avez une situation appelée «cycle de rétention». <br><br>  À titre d'exemple, considérons le code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">House</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ownerDetails: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"This is a great house."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I'm being demolished!"</span></span>) } }</code> </pre> <br>  Nous avons défini la classe <b>House</b> , qui contient une propriété (fermeture), une méthode et un désinitialiseur qui affichera un message lorsqu'une instance de la classe est détruite. <br><br>  Créez maintenant une classe <b>Owner</b> similaire à la précédente, sauf que sa propriété de fermeture contient des informations sur la maison. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Owner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> houseDetails: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I own a house."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I'm dying!"</span></span>) } }</code> </pre> <br>  Créez maintenant des instances de ces classes dans le bloc <b>do</b> .  Nous n'avons pas besoin d'un bloc catch, mais l'utilisation d'un bloc <b>do</b> détruira les instances juste après} <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  En conséquence, des messages seront affichés: «Création d'une maison et d'un propriétaire», «Je meurs!», «Je suis en train d'être démoli!», Puis «Terminé» - tout fonctionne comme il se doit. <br><br>  Créez maintenant une boucle de liens solides. <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() house.ownerDetails = owner.printDetails owner.houseDetails = house.printDetails } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  Maintenant, le message «Création d'une maison et d'un propriétaire» apparaît, puis «Terminé».  Les désinitialiseurs ne seront pas appelés. <br><br>  Cela est dû au fait que la maison a une propriété qui pointe vers le propriétaire et que le propriétaire a une propriété qui pointe vers la maison.  Par conséquent, aucun d'entre eux ne peut être libéré en toute sécurité.  Dans une situation réelle, cela conduit à des fuites de mémoire, ce qui entraîne des performances médiocres et même un crash de l'application. <br><br>  Pour corriger la situation, nous devons créer une nouvelle fermeture et utiliser une capture «faible» dans un ou deux cas, comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Creating a house and an owner"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> house = <span class="hljs-type"><span class="hljs-type">House</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owner = <span class="hljs-type"><span class="hljs-type">Owner</span></span>() house.ownerDetails = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> owner] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> owner?.printDetails() } owner.houseDetails = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> house] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> house?.printDetails() } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>)</code> </pre> <br>  Il n'est pas nécessaire de déclarer les deux valeurs capturées, il suffit de le faire en un seul endroit - cela permettra à Swift de détruire les deux classes si nécessaire. <br><br>  Dans les projets réels, la situation d'un cycle aussi évident de liens forts se pose rarement, mais cela souligne d'autant plus l'importance d'utiliser la capture «faible» avec un développement compétent. <br><br><h3>  3. L'utilisation par inadvertance de liens solides, généralement lors de la capture de plusieurs valeurs </h3><br>  Swift utilise une forte adhérence par défaut, ce qui peut entraîner un comportement inattendu. <br>  Considérez le code suivant: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; () -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> taylor = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adele = <span class="hljs-type"><span class="hljs-type">Singer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> singing = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor, adele] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taylor.playSong() adele.playSong() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singing }</code> </pre> <br>  Maintenant, nous avons deux valeurs capturées par la fermeture, et nous utilisons les deux de la même manière.  Cependant, seul <b>Taylor est</b> capturé comme non possédé - Adele <b>est</b> capturé fortement car le mot-clé <b>Unowned</b> doit être utilisé pour chaque valeur capturée. <br><br>  Si vous l'avez fait exprès, alors tout va bien, mais si vous voulez que les deux valeurs soient capturées "sans <b>propriétaire</b> ", vous avez besoin des éléments suivants: <br><br><pre> <code class="swift hljs">[<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> taylor, <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> adele]</code> </pre> <br><h3>  4. Copiez les fermetures et partagez les valeurs capturées </h3><br>  Le dernier cas sur lequel les développeurs tombent est la façon dont les erreurs sont copiées car les données qu'elles capturent deviennent disponibles pour toutes les copies de l'erreur. <br>  Prenons un exemple de fermeture simple qui capture la variable entière <b>numberOfLinesLogged</b> déclarée en dehors de la fermeture, afin que nous puissions augmenter sa valeur et l'imprimer chaque fois que la fermeture est appelée: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfLinesLogged = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger1 = { numberOfLinesLogged += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Lines logged: \(numberOfLinesLogged)"</span></span>) } logger1()</code> </pre> <br>  Cela affichera le message «Lignes enregistrées: 1». <br>  Nous allons maintenant créer une copie de la fermeture qui partagera les valeurs capturées avec la première fermeture.  Ainsi, si nous appelons la fermeture originale ou sa copie, nous verrons la valeur croissante de la variable. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger2 = logger1 logger2() logger1() logger2()</code> </pre><br>  Cela affichera les messages "Lignes enregistrées: 1" ... "Lignes enregistrées: 4" car <b>logger1</b> et <b>logger2</b> pointent vers la même variable <b>numberOfLinesLogged</b> capturée. <br><br><h2>  Quand utiliser une capture "forte", "faible" et "sans propriétaire" </h2><br>  Maintenant que nous comprenons comment tout fonctionne, essayons de résumer: <br><br>  1. Si vous êtes sûr que la valeur capturée ne deviendra jamais <b>nulle</b> lors de la fermeture, vous pouvez utiliser la <b>«capture sans propriétaire»</b> .  Il s'agit d'une situation peu fréquente où l'utilisation de la capture «faible» peut entraîner des difficultés supplémentaires, même lors de l'utilisation d'une garde laissée à une valeur faiblement capturée à l'intérieur de la fermeture. <br><br>  2. Si vous avez un cas de cycle de liens forts (l'entité A possède l'entité B et l'entité B possède l'entité A), alors dans l'un des cas, vous devez utiliser la <b>«capture faible»</b> .  Il est nécessaire de prendre en compte laquelle des deux entités sera libérée en premier, donc si le contrôleur de vue A représente le contrôleur de vue B, alors le contrôleur de vue B peut contenir un lien «faible» vers «A». <br><br>  3. Si la possibilité d'un cycle de liens forts est exclue, vous pouvez utiliser la capture "forte" ( <b>"capture forte"</b> ).  Par exemple, l'exécution d'une animation ne se bloque pas à l'intérieur de la fermeture contenant l'animation, vous pouvez donc utiliser une liaison forte. <br><br>  4. Si vous n'êtes pas sûr, commencez par une reliure «faible» et ne la changez que si nécessaire. <br><br>  Facultatif - Guide Swift officiel: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Court-circuits</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comptage automatique des liens</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444336/">https://habr.com/ru/post/fr444336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444324/index.html">Suivre les traces des calculatrices: SpeedCrunch</a></li>
<li><a href="../fr444326/index.html">Surveillance par SMS du poids de trois ruches pour 30 $</a></li>
<li><a href="../fr444328/index.html">La refonte de l'interface utilisateur est souvent une perte de temps</a></li>
<li><a href="../fr444330/index.html">Le CMS sans serveur est enfin un concurrent digne de Wordpress</a></li>
<li><a href="../fr444332/index.html">Sécurité de l'information et restauration: comment les managers pensent les produits informatiques</a></li>
<li><a href="../fr444338/index.html">Encapsulation dans Python 3</a></li>
<li><a href="../fr444340/index.html">Caractéristiques de l'utilisation du type de données Symbol en JavaScript</a></li>
<li><a href="../fr444342/index.html">Développement d'applications JavaScript simples et modernes à l'aide de Webpack et de technologies Web avancées</a></li>
<li><a href="../fr444344/index.html">10 étapes pour réussir un projet Python</a></li>
<li><a href="../fr444346/index.html">GraphQL et Golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>