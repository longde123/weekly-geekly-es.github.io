<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏭 🍾 🙋🏻 Go Compiler: SSA-Optimierungsregeln Beschreibung Sprache 🧓🏿 👃 👩🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der gc Compiler verwendet eine spezielle Lisp-ähnliche objektorientierte Sprache ( DSL ), um die SSA-Optimierungsregeln ( Static Single Assignment ) z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go Compiler: SSA-Optimierungsregeln Beschreibung Sprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415771/"><p><img src="https://habrastorage.org/webt/0b/vq/ua/0bvquazri632jnibzwkywt7hfim.png"></p><br><p> Der <code>gc</code> Compiler verwendet eine spezielle Lisp-ähnliche objektorientierte Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DSL</a> ), um die SSA-Optimierungsregeln ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Static Single Assignment</a> ) zu beschreiben. </p><br><p>  Ich schlage vor, die Hauptelemente dieser Sprache, ihre Merkmale und Einschränkungen zu analysieren. <br>  Als Übung fügen wir dem Go-Compiler die Generierung einer Anweisung hinzu, die zuvor nicht generiert wurde, und optimieren den Ausdruck <code>a*b+c</code> . </p><br><p>  Dies ist der erste Artikel in einer Reihe über die Interna des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go SSA-Compiler-Backends.</a> Daher werden wir nicht nur die Beschreibung der DSL-Regeln selbst überprüfen, sondern auch verwandte Komponenten untersuchen, um die erforderliche Basis für unsere nächste Sitzung zu schaffen. </p><a name="habracut"></a><br><h1 id="vvedenie">  Einführung </h1><br><p>  Der Frontend-Go-Compiler endet zum Zeitpunkt der Generierung der SSA-Ansicht aus dem mit Anmerkungen versehenen AST.  Die für die Konvertierung verantwortlichen Funktionen finden Sie in <a href="">cmd / compile / internal / gc / ssa.go.</a>  Der Einstiegspunkt in das SSA-Backend ist die Funktion <code>ssa.Compile</code> , die in <a href="">cmd / compile / internal / ssa / compile.go definiert ist</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><table><thead><tr><th>  DE </th><th>  RU </th><th>  Wert </th></tr></thead><tbody><tr><td>  Compiler-Frontend </td><td>  Compiler-Frontend </td><td>  Parsing und lexikalische Analyse, manchmal Typauflösung, Zwischendarstellung liegt in der Nähe des Quellcodes, normalerweise einige kommentierte AST. </td></tr><tr><td>  Compiler-Backend </td><td>  Compiler-Backend </td><td>  Optimierungen auf niedrigerer Ebene und Zwischendarstellung, Codegenerierung. </td></tr><tr><td>  Formular </td><td>  Formular </td><td>  Fast ein Synonym für das Wort "Ausdruck" (Ausdruck).  Normalerweise ist <code>form</code> in Lisp eine gebräuchliche Methode, um ein Programmelement zu benennen, sei es eine Liste oder ein Atom. </td></tr><tr><td>  Optimierungsdurchlauf </td><td>  Optimierungsphase </td><td>  Ausführung eines bestimmten Algorithmus in einem Programm.  Das Wort "Durchlauf" ist etwas mehrdeutig, da eine Phase mehrere Durchgänge ausführen und / oder einen Code verwenden kann, der anderen Phasen gemeinsam ist. </td></tr></tbody></table><br><p>  Wenn Sie beim Lesen des Artikels einen Begriff finden, der für Sie völlig unverständlich ist, sollten Sie dies melden. Er kann dieser Tabelle hinzugefügt werden. </p></div></div><br><p>  Der SSA Go-Optimierer besteht aus mehreren Phasen, von denen jede die kompilierte Funktion durchläuft.  Einige Phasen verwenden die sogenannten "Umschreiberegeln", die Regeln zum Konvertieren einer SSA-Sequenz in eine andere, möglicherweise optimaler. </p><br><p>  Transformationsregeln werden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">S-Ausdrücken beschrieben</a> .  Die Elemente dieser Ausdrücke sind <a href="">ssa.Value</a> .  Im einfachsten Fall können Sie mit diesen Regeln einen <code>ssa.Value</code> durch einen anderen ersetzen. </p><br><p>  Der folgende Code reduziert beispielsweise die Multiplikation von 8-Bit-Konstanten: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">Mul8</span></span> (<span class="hljs-name"><span class="hljs-name">Const8</span></span> [c]) (<span class="hljs-name"><span class="hljs-name">Const8</span></span> [d])) -&gt; (<span class="hljs-name"><span class="hljs-name">Const8</span></span> [int64(<span class="hljs-name"><span class="hljs-name">int8</span></span>(<span class="hljs-name"><span class="hljs-name">c*d</span></span>))])</code> </pre> <br><p>  Es gibt zwei Hauptkategorien von SSA-Werten: High-Level, fast unabhängig vom Zielcomputer, und solche, die architekturspezifisch sind (normalerweise 1-in-1-Maschinenanweisungen zugeordnet). </p><br><p>  Optimierungen werden anhand dieser beiden Kategorien beschrieben.  Zuerst auf hoher Ebene und allen Architekturen gemeinsam, dann plattformorientiert. </p><br><p>  Der gesamte mit den Regeln verknüpfte Code befindet sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmd / compile / internal / ssa / gen</a> .  Wir werden zwei Sätze betrachten: </p><br><ol><li>  <a href="">genericOps.go</a> - maschinenunabhängige Operationen. </li><li>  <a href="">AMD64Ops.go</a> - Vorgänge, die für <code>GOARCH=AMD64</code> (64-Bit x86) spezifisch sind. </li></ol><br><p>  Nach den ersten Phasen, die auf der abstrakten Maschine arbeiten, wird das sogenannte Absenken durchgeführt, was zu einem Übergang von <code>genericOps</code> zu einer Reihe spezifischer Architekturen führt.  In unserem Beispiel ist dies <code>AMD64Ops</code> .  Nach diesem Punkt bearbeiten alle nachfolgenden Phasen die Präsentation aus der zweiten Kategorie. </p><br><p>  Nach dem Optimierer kommt ein Codegenerator ins Spiel.  Für AMD64 befindet sich die Implementierung der Codegenerierung im Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmd / compile / internal / amd64</a> .  Die Aufgabe des Codegenerators besteht darin, <code>ssa.Block</code> und <code>ssa.Value</code> durch die an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler übergebene</a> Sequenz <a href="">obj.Prog</a> zu ersetzen.  Der Assembler sammelt den Maschinencode, der nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verknüpfen</a> zur Ausführung bereit ist. </p><br><h1 id="pravila-optimizaciy">  Optimierungsregeln </h1><br><p>  Wenn Dateien mit Operationsdefinitionen den Namen " <code>${ARCH}Ops.go</code> " haben, werden Optimierungsregeln in " <code>${ARCH}.Rules</code> " platziert. </p><br><p>  Übergeordnete Regeln führen einfache Transformationen durch, wobei die meisten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">konstanten Ausdrücke gefaltet werden</a> , sowie einige Transformationen, die die nachfolgende Verarbeitung vereinfachen. </p><br><p>  Jede Datei mit Regeln auf niedriger Ebene besteht aus zwei Teilen: </p><br><ol><li>  Absenken - Ersetzen abstrakter Operationen durch Maschinenäquivalente. </li><li>  Die Optimierungen selbst. </li></ol><br><p>  Ein Beispiel für die Reduzierung eines Vorgangs auf eine Maschine: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">Const32</span></span> [val]) -&gt; (<span class="hljs-name"><span class="hljs-name">MOVLconst</span></span> [val]) // L - long, <span class="hljs-number"><span class="hljs-number">32</span></span>- (<span class="hljs-name"><span class="hljs-name">Const64</span></span> [val]) -&gt; (<span class="hljs-name"><span class="hljs-name">MOVQconst</span></span> [val]) // Q - quad, <span class="hljs-number"><span class="hljs-number">64</span></span>- | | generic op | AMD64 op</code> </pre> <br><p>  Bei Optimierungen auf niedriger Ebene wird die Hauptanzahl wichtiger Optimierungen durchgeführt, z. B. die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reduzierung der Betriebskosten</a> , die teilweise Einbettung und Nutzung der Funktionen der im Prozessor verfügbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicheradressierungsmodi</a> . </p><br><p>  Operationen haben einen mnemonischen Namen, der normalerweise als Opcode bezeichnet wird.  Die Opcodes von architekturabhängigen Operationen spiegeln normalerweise die Namen der tatsächlichen Anweisungen wider. </p><br><h1 id="sintaksis-yazyka-opisaniya-pravil">  Regel Beschreibung Sprachsyntax </h1><br><p>  Die grundlegende Grammatik ist in <a href="">rulegen.go beschrieben</a> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// rule syntax: // sexpr [&amp;&amp; extra conditions] -&gt; [@block] sexpr // // sexpr are s-expressions (lisp-like parenthesized groupings) // sexpr ::= [variable:](opcode sexpr*) // | variable // | &lt;type&gt; // | [auxint] // | {aux} // // aux ::= variable | {code} // type ::= variable | {code} // variable ::= some token // opcode ::= one of the opcodes from the *Ops.go files</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Snippet-Übersetzung oben</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  : // sexpr [&amp;&amp;  ] -&gt; [@block] sexpr // // sexpr -  S- (   ) // sexpr ::= [variable:](opcode sexpr*) // | variable // | &lt;type&gt; // | [auxint] // | {aux} // // aux ::= variable | {code} // type ::= variable | {code} // variable ::= Go  ( ) // opcode ::=   *Ops.go </span></span></code> </pre> <br></div></div><br><p>  Erwähnenswert ist auch, dass " <code>//</code> " -Kommentare in <code>.Rules</code> Dateien zulässig sind. </p><br><p>  Schauen wir uns ein einfaches Beispiel an, das all diese Elemente enthält: </p><br><pre> <code class="lisp hljs"> Opcode=ADDLconst -    <span class="hljs-number"><span class="hljs-number">32</span></span>-  : AuxInt=c - ,    `x` : : (<span class="hljs-name"><span class="hljs-name">ADDLconst</span></span> [c] x) &amp;&amp; int32(<span class="hljs-name"><span class="hljs-name">c</span></span>)==0 -&gt; x | / | / | | / | / | | / | /    | /   ( `<span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span>`    ) ,    </code> </pre> <br><blockquote>  Alle diese erklärenden Signaturen sind nicht Teil eines gültigen Regeldatensatzes. </blockquote><p>  Diese Regel konvertiert <code>x+0</code> in <code>x</code> .  Alles im Bedingungsabschnitt ist ein normaler Go-Code. <br>  sofern nicht auf Ausdrücke beschränkt, deren Ergebnis ein <code>bool</code> . <br>  Sie können in <a href="">rewrite.go</a> definierte Prädikate <a href="">aufrufen</a> . </p><br><p>  Zusätzlich zu den üblichen Opcodes können Kombinationen verwendet werden, die zu mehreren Regeln führen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ADD</span></span>(<span class="hljs-name"><span class="hljs-name">Q</span></span><span class="hljs-name"><span class="hljs-name">|L)const [off] x:(SP)) -&gt; (LEA(Q|</span></span><span class="hljs-name"><span class="hljs-name">L</span></span>) [off] x) //  Q|L alternation: (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> [off] x:(<span class="hljs-name"><span class="hljs-name">SP</span></span>)) -&gt; (<span class="hljs-name"><span class="hljs-name">LEAQ</span></span> [off] x) (<span class="hljs-name"><span class="hljs-name">ADDLconst</span></span> [off] x:(<span class="hljs-name"><span class="hljs-name">SP</span></span>)) -&gt; (<span class="hljs-name"><span class="hljs-name">LEAL</span></span> [off] x) //    `x`: (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> [off] (<span class="hljs-name"><span class="hljs-name">SP</span></span>)) -&gt; (<span class="hljs-name"><span class="hljs-name">LEAQ</span></span> [off] (<span class="hljs-name"><span class="hljs-name">SP</span></span>)) (<span class="hljs-name"><span class="hljs-name">ADDLconst</span></span> [off] (<span class="hljs-name"><span class="hljs-name">SP</span></span>)) -&gt; (<span class="hljs-name"><span class="hljs-name">LEAL</span></span> [off] (<span class="hljs-name"><span class="hljs-name">SP</span></span>))</code> </pre> <br><blockquote>  <code>(SP)</code> ist eine der Operationen in genericOps.go und drückt das Laden eines Zeigers auf den Hardware-Stack aus.  Für Architekturen ohne Hardware- <code>SP</code> wird es emuliert. </blockquote><p>  Funktionen von Variablen in Vorlagen (S-Ausdrücke links von <code>-&gt;</code> ): </p><br><ul><li>  Variablen wie <code>x</code> ohne Ausdruck durch <code>:</code> erfassen alles </li><li>  Wie eine reguläre Variable erfasst <code>_</code> beliebigen Wert, das Ergebnis kann jedoch ignoriert werden </li></ul><br><pre> <code class="lisp hljs">//       :    ADDQconst, //          : (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> _) -&gt; v (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> x) -&gt; (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> x)</code> </pre> <br><p>  Wenn <code>AuxInt</code> nicht angegeben ist (Ausdruck in eckigen Klammern), wird die Regel für jeden <code>AuxInt</code> Wert <code>AuxInt</code> .  Ähnliches gilt für <code>{}</code> -Parameter (dazu unten). </p><br><p>  Der Name <code>v</code> bedeutet die äußerste erfasste Form. <br>  Für den Ausdruck <code>(ADDQconst (SUBQconst x))</code> lautet <code>(ADDQconst (SUBQconst x))</code> externe Form beispielsweise <code>ADDQconst</code> . </p><br><p>  Variablen können mehrmals verwendet werden. Auf diese Weise können Sie festlegen, dass mehrere Teile des S-Ausdrucks miteinander übereinstimmen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> [v] (<span class="hljs-name"><span class="hljs-name">ADDQconst</span></span> [v] x)) // , ,  <span class="hljs-string"><span class="hljs-string">"x+2+2"</span></span> (<span class="hljs-name"><span class="hljs-name">x+v+v</span></span>).</code> </pre> <br><h1 id="tipy-v-pravilah">  Typen in Regeln </h1><br><p>  In einigen Fällen muss der Typ des generierten und / oder übereinstimmenden Formulars explizit angegeben werden. <br>  Der Typ wird in "dreieckigen Klammern" als Typargument in C ++ - Vorlagen angegeben: </p><br><pre> <code class="lisp hljs">// typ.UInt32 -   BTSLconst. // BSFL    typ.UInt32,    //    . (<span class="hljs-name"><span class="hljs-name">Ctz16</span></span> x) -&gt; (<span class="hljs-name"><span class="hljs-name">BSFL</span></span> (<span class="hljs-name"><span class="hljs-name">BTSLconst</span></span> &lt;typ.UInt32&gt; [<span class="hljs-number"><span class="hljs-number">16</span></span>] x))</code> </pre> <br><p>  Zusätzlich zu den Typen gibt es "Zeichen" (oder allgemeiner - <code>Aux</code> Eigenschaften). </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">StaticCall</span></span> [argsWidth] {target} mem) -&gt; (<span class="hljs-name"><span class="hljs-name">CALLstatic</span></span> [argsWidth] {target} mem)</code> </pre> <br><ul><li>  <code>[argsWidth]</code> - <code>Value.AuxInt</code> .  Für <code>StaticCall</code> - die Gesamtgröße der übergebenen Argumente </li><li>  <code>{target}</code> - <code>Value.Aux</code> .  Für <code>StaticCall</code> - aufgerufene Funktion </li><li>  <code>&lt;typ.UInt32&gt;</code> - <code>Value.Type</code> .  Werttyp </li></ul><br><p>  Die Semantik von <code>Aux</code> und <code>AuxInt</code> von Operation zu Operation sehr unterschiedlich.  Die beste Dokumentationsquelle in diesem Fall sind <code>*Ops.go</code> Dateien.  Jede opData-Opcode- <code>opData</code> verfügt über ein Hilfsfeld, in dem die Interpretation dieser Felder beschrieben wird. </p><br><p>  Für die Beschreibung der Typen wird das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmd / compile / internal / types verwendet</a> .  Einige Typen sind spezifisch für das SSA-Backend, z. B. <code>types.TypeFlags</code> , der Rest ist zwischen <code>cmd/compile/internal/gc</code> und <code>cmd/compile/internal/ssa</code> . </p><br><h1 id="osobye-tipy">  Spezielle Typen </h1><br><p>  Es gibt einen speziellen Typ von <code>types.TypeMem</code> , der mehrere Funktionen gleichzeitig ausführt: </p><br><ol><li>  Ermöglicht das Sortieren und Gruppieren von <code>ssa.Value</code> nach Speicherzugriffsmustern.  Dies garantiert insbesondere die korrekte Ausführungsreihenfolge im Rahmen der Basisblöcke (dazu unten). </li><li>  Bestimmt den Status des Speicherstroms im Programm.  Wenn der Befehl den Speicher <code>types.TypeMem</code> wird als Ergebnis dieser Operation ein neuer SSA-Wert vom Typ <code>types.TypeMem</code> generiert. </li></ol><br><p>  Wie die spezielle Bedeutung von <code>OpPhi</code> wird der Speicher in vielen Phasen des Optimierers außergewöhnlich interpretiert. </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen über Phi</b> <div class="spoiler_text"><p>  <code>Phi</code> hat eine Rolle, die von Phase zu Phase leicht variiert. </p><br><p>  Zu Beginn der SSA-Arbeit des Compilers <code>Phi</code> seinen klassischen Zweck und drückt die Wahl des Werts in Abhängigkeit vom Ausführungspfad aus, der uns zu diesem Wert geführt hat. </p><br><p>  Wenn ein Block beispielsweise zwei Sprünge enthält und beide den Speicher ändern, <code>(Phi mem1 mem2)</code> einen Speicher von <code>(Phi mem1 mem2)</code> .  Zyklen ziehen auch den <code>Phi</code> Wert. </p></div></div><br><p>  Ein weiterer spezieller Typ sind die <code>types.TypeFlags</code> genannten <code>types.TypeFlags</code> .  Dieser Typ beschreibt den Befehl, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CPU-Flags</a> generiert. </p><br><p>  In diesem Fall sind Anweisungen wie <code>ADDQ</code> , obwohl sie Flags generieren, nicht vom Typ <code>types.Flags</code> , sondern mit dem Attribut <code>clobberFlags</code> . </p><br><p>  <code>types.Flags</code> verwendet, um das Ergebnis von Anweisungen wie <code>CMPQ</code> , die das Ergebnis nicht in einen ihrer expliziten Operanden schreiben, sondern nur den internen Status des Prozessors aktualisieren, der von der nächsten Anweisung verwendet werden kann. </p><br><p>  Mit Anweisungen wie <code>SETL</code> können Sie Flags „lesen“ und als <code>ssa.Value</code> , der in ein Register gestellt werden kann. </p><br><pre> <code class="lisp hljs"> L-less than G-greater than | | (<span class="hljs-name"><span class="hljs-name">SETL</span></span> (<span class="hljs-name"><span class="hljs-name">InvertFlags</span></span> x)) -&gt; (<span class="hljs-name"><span class="hljs-name">SETG</span></span> x) | ,  </code> </pre> <br><h1 id="inspekciya-ssa-programmy">  SSA-Inspektionsprogramm </h1><br><p>  Nehmen wir an, wir haben ein Programm wie dieses ( <code>example.go</code> ): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fusedMulAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*c + b }</code> </pre> <br><p>  Wir können uns den SSA-Code ansehen, der für die Funktion <code>fusedMulAdd</code> generiert wird: </p><br><pre> <code class="bash hljs">$ GOSSAFUNC=fusedMulAdd go tool compile example.go &gt; ssa.txt</code> </pre> <br><p>  Überprüfen Sie nun das Arbeitsverzeichnis (aktuell): </p><br><ul><li>  <code>ssa.txt</code> enthält einen Tekt-Dump. </li><li>  <code>ssa.html</code> , das automatisch generiert wird, enthält dieselben Informationen, jedoch in einem interaktiveren und bequem lesbaren Format.  Versuchen Sie, in einem Browser zu öffnen. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Maschinencode für fusedMulAdd</b> <div class="spoiler_text"><p>  Das Zeichen <code>~r3</code> <code>ret</code> Ausdruckskraft in <code>ret</code> umbenannt. </p><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v7</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> MOVSD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function">, X0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v11</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> MOVSD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">+16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function">, X1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v12</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> MULSD X1, X0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v6</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> MOVSD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">+8</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function">, X1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v13</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ADDSD X1, X0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v15</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> MOVSD X0, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">+24</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> RET</span></span></code> </pre> </div></div><br><p>  So sieht das SSA-Programm für <code>fusedMulAdd</code> nach der <code>lower</code> Phase aus (ssa.html): </p><br><p><img src="https://habrastorage.org/webt/zs/yb/ax/zsybaxjcr1s0_u1csmhgkt3d1za.png"></p><br><div class="spoiler">  <b class="spoiler_title">Textformat SSA-Programm</b> <div class="spoiler_text"><p>  Wenn Sie dies aus irgendeinem Grund kopieren wollten: </p><br><pre> <code class="hljs xml">lower [77667 ns] b1: v1 (?) = InitMem <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> v2 (?) = SP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uintptr</span></span></span><span class="hljs-tag">&gt;</span></span> v7 (?) = LEAQ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">*float64</span></span></span><span class="hljs-tag">&gt;</span></span> {~r3} v2 v8 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {a} v9 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {b} v10 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {c} v12 (+4) = MULSD <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v8 v10 v13 (4) = ADDSD <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v12 v9 v14 (4) = VarDef <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> {~r3} v1 v15 (4) = MOVSDstore <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> {~r3} v2 v13 v14 Ret v15 (line +4)</code> </pre> </div></div><br><p>  Dies in S-Ausdrücke übersetzen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">MOVQstore</span></span> {~r3} (<span class="hljs-name"><span class="hljs-name">SP</span></span>) (<span class="hljs-name"><span class="hljs-name">ADDSD</span></span> (<span class="hljs-name"><span class="hljs-name">MULSD</span></span> (<span class="hljs-name"><span class="hljs-name">Arg</span></span> {a}) (<span class="hljs-name"><span class="hljs-name">Arg</span></span> {c})) (<span class="hljs-name"><span class="hljs-name">Arg</span></span> {b})))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">SSA nach der Regalloc-Phase</b> <div class="spoiler_text"><p>  Dies ist die Ausgabe von <code>ssa.html</code> für die <code>regalloc</code> Phase. </p><br><p><img src="https://habrastorage.org/webt/ef/kx/u5/efkxu5pdwqvs14c9xwblajxoywo.png"></p><br><pre> <code class="hljs xml">regalloc [87237 ns] b1: v1 (?) = InitMem <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> v14 (4) = VarDef <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> {~r3} v1 v2 (?) = SP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uintptr</span></span></span><span class="hljs-tag">&gt;</span></span> : SP v8 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {a} : a[float64] v9 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {b} : b[float64] v10 (3) = Arg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> {c} : c[float64] v7 (4) = LoadReg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v8 : X0 v11 (4) = LoadReg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v10 : X1 v12 (+4) = MULSD <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v7 v11 : X0 v6 (4) = LoadReg <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v9 : X1 v13 (4) = ADDSD <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float64</span></span></span><span class="hljs-tag">&gt;</span></span> v12 v6 : X0 v15 (4) = MOVSDstore <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mem</span></span></span><span class="hljs-tag">&gt;</span></span> {~r3} v2 v13 v14 Ret v15 (line +4)</code> </pre> </div></div><br><h1 id="dobavlenie-novyh-pravil-optimizaciy">  Hinzufügen neuer Optimierungsregeln </h1><br><p>  Auf Prozessoren mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FMA können</a> wir <code>a*c + b</code> in einem Befehl anstelle von zwei berechnen. </p><br><p>  Nehmen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL117295</a> als Grundlage für die Urheberschaft von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ilya Tokar</a> . </p><br><p>  Für Ihre Bequemlichkeit habe ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> diff</code> Patch</a> vorbereitet. <br></p><br><h3 id="1-dobavlenie-novoy-operacii---fmasd">  1. Hinzufügen einer neuen Operation - FMASD </h3><br><p>  <code>compile/internal/ssa/gen/AMD64Ops.go</code> Sie in der Datei <code>compile/internal/ssa/gen/AMD64Ops.go</code> die Slice- <code>AMD64ops</code> und fügen Sie ein neues Element hinzu (irgendwo): </p><br><pre> <code class="go hljs">{ <span class="hljs-comment"><span class="hljs-comment">// fp64 fma name: "FMASD", //   SSA argLength: 3, reg: fp31, //   regalloc,   resultInArg0: true, //     source,  destination asm: "VFMADD231SD", //   },</span></span></code> </pre> <br><p>  Da zuvor keine Operationen <code>(fp,fp,fp -&gt; fp)</code> waren, müssen Sie ein neues Qualifikationsmerkmal definieren: </p><br><pre> <code class="diff hljs"> fp01 = regInfo{inputs: nil, outputs: fponly} fp21 = regInfo{inputs: []regMask{fp, fp}, outputs: fponly} + fp31 = regInfo{inputs: []regMask{fp, fp, fp}, outputs: fponly}</code> </pre> <br><h3 id="2-dobavlenie-pravila-optimizacii">  2. Hinzufügen einer Optimierungsregel </h3><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ADDSD</span></span> (<span class="hljs-name"><span class="hljs-name">MULSD</span></span> xy) z) -&gt; (<span class="hljs-name"><span class="hljs-name">FMASD</span></span> zxy)</code> </pre> <br><p>  Eine korrektere Implementierung wäre nicht unbedingt erforderlich und würde die Verfügbarkeit von FMA prüfen.  Wir gehen davon aus, dass auf unserer Zielmaschine definitiv eine FMA vorhanden ist. </p><br><p>  Der Compiler verwendet <code>config</code> für solche Überprüfungen: </p><br><pre> <code class="lisp hljs">//  config.useFMA=false,    . (<span class="hljs-name"><span class="hljs-name">ADDSD</span></span> (<span class="hljs-name"><span class="hljs-name">MULSD</span></span> xy) z) &amp;&amp; config.useFMA-&gt; (<span class="hljs-name"><span class="hljs-name">FMASD</span></span> zxy)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie überprüfe ich die FMA-Unterstützung?</b> <div class="spoiler_text"><p>  Wenn <code>lscpu</code> auf dem System verfügbar ist, gehen Sie beispielsweise folgendermaßen vor: </p><br><pre> <code class="bash hljs">$ lscpu | grep fma</code> </pre> </div></div><br><h3 id="3-realizaciya-kodogeneracii">  3. Implementierung der Codegenerierung </h3><br><p>  In der Funktion <code>ssaGenValue</code> , die in der <code>compile/internal/amd64/ssa.go</code> , müssen Sie nun die Codegenerierung für <code>FMASD</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssaGenValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *gc.SSAGenState, v *ssa.Value)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> v.Op { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ssa.OpAMD64FMASD: p := s.Prog(v.Op.Asm()) <span class="hljs-comment"><span class="hljs-comment">//   obj.Prog    // From:  source . p.From = obj.Addr{Type: obj.TYPE_REG, Reg: v.Args[2].Reg()} // To: destination . // v.Reg()  ,      FMASD. p.To = obj.Addr{Type: obj.TYPE_REG, Reg: v.Reg()} // From3:  source . //  From3 .     //  RestArgs,    source ,  . p.SetFrom3(obj.Addr{ Type: obj.TYPE_REG, Reg: v.Args[1].Reg(), }) if v.Reg() != v.Args[0].Reg() { //   resultInArg0 s := v.LongString() v.Fatalf("input[0] and output not in same register %s", s) } //    ,     case. } }</span></span></code> </pre> <br><p>  Jetzt ist alles bereit, um die Arbeit unserer neuen Optimierung zu testen.  Es ist sehr selten, dass neue Anweisungen hinzugefügt werden. In der Regel werden neue Optimierungen basierend auf bereits definierten SSA-Vorgängen durchgeführt. </p><br><h1 id="proverka-rezultatov">  Ergebnisse überprüfen </h1><br><p>  Der erste Schritt besteht darin, Go-Code aus den aktualisierten <code>gen/AMD64Ops.go</code> und <code>gen/AMD64.Rules</code> . </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GOROOT  ,   ,   `go env GOROOT`. cd $GOROOT/src/cmd/compile/internal/ssa/gen &amp;&amp; go run *.go</span></span></code> </pre> <br><p>  Als nächstes müssen wir unseren neuen Compiler erstellen: </p><br><pre> <code class="bash hljs">go install cmd/compile</code> </pre> <br><p>  Wenn wir nun dasselbe Beispiel kompilieren, erhalten wir einen anderen Maschinencode: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- v7 (4) MOVSD a(SP), X0 - v11 (4) MOVSD c+16(SP), X1 - v12 (4) MULSD X1, X0 - v6 (4) MOVSD b+8(SP), X1 - v13 (4) ADDSD X1, X0 - v15 (4) MOVSD X0, ret+24(SP) - b1 (4) RET + v12 (4) MOVSD b+8(SP), X0 + v7 (4) MOVSD a(SP), X1 + v11 (4) MOVSD c+16(SP), X2 + v13 (4) VFMADD231SD X2, X1, X0 + v15 (4) MOVSD X0, ret+24(SP) + b1 (4) RET</span></span></code> </pre> <br><h1 id="bazovye-bloki-basic-blocks">  Grundblöcke </h1><br><p>  Nachdem die schwierigste Arbeit erledigt wurde, sprechen wir über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisblöcke</a> . </p><br><p>  Die oben optimierten Werte sind in Blöcken angegeben, und die Blöcke sind in Funktion. </p><br><p>  Blöcke sind wie <code>ssa.Value</code> abstrakt und maschinenabhängig.  Alle Blöcke haben genau einen Einstiegspunkt und 0 bis 2 Zielblöcke (je nach Blocktyp). </p><br><p>  Die einfachsten Blöcke sind <code>If</code> , <code>Exit</code> und <code>Plain</code> : </p><br><ul><li>  <code>Exit</code> hat 0 Zuweisungsblöcke.  Dies sind Blattblöcke, die beispielsweise mit <code>panic</code> einen nicht lokalen Sprung <code>panic</code> . </li><li>  <code>Plain</code> Block hat 1 Zuweisungsblöcke.  Es kann als bedingungsloser Sprung betrachtet werden, nachdem alle Anweisungen des Blocks zu einem anderen Block ausgeführt wurden. </li><li>  <code>If</code> Block 2 Zielblöcke hat.  Der Übergang erfolgt je nach Bedingung ( <code>Block.Control</code> ). </li></ul><br><p>  Hier sind einfache Beispiele für das Umschreiben abstrakter Blöcke in <code>AMD64</code> Blöcke: </p><br><pre> <code class="lisp hljs">  <span class="hljs-string"><span class="hljs-string">"then"</span></span> ( ) |  <span class="hljs-string"><span class="hljs-string">"else"</span></span> ( ) | | (<span class="hljs-name"><span class="hljs-name">If</span></span> (<span class="hljs-name"><span class="hljs-name">SETL</span></span> cmp) yes no) -&gt; (<span class="hljs-name"><span class="hljs-name">LT</span></span> cmp yes no) (<span class="hljs-name"><span class="hljs-name">If</span></span> (<span class="hljs-name"><span class="hljs-name">SETLE</span></span> cmp) yes no) -&gt; (<span class="hljs-name"><span class="hljs-name">LE</span></span> cmp yes no)</code> </pre> <br><p>  Das Thema Blöcke wird im Zusammenhang mit anderen Optimierungsphasen im SSA-Teil des Compilers näher betrachtet. </p><br><h1 id="ogranicheniya-pravil-optimizaciy">  Einschränkungen der Optimierungsregeln </h1><br><p>  Das SSA-Backend hat seine Vorteile.  Einige Optimierungen sind in <code>O(1)</code> .  Es gibt jedoch auch Nachteile, aufgrund derer die SSA des Optimierers allein nicht ausreicht, zumindest bis sich einige Aspekte seiner Implementierung ändern. </p><br><p>  Angenommen, Sie möchten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>  append</code></a> : </p><br><pre> <code class="go hljs">xs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(xs, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) xs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(xs, <span class="hljs-string"><span class="hljs-string">'b'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; xs = append(xs, 'a', 'b')</span></span></code> </pre> <br><p>  Zum Zeitpunkt der Generierung des SSA geht die übergeordnete Struktur des Codes verloren und das <code>append</code> , da es keine gewöhnliche Funktion ist, bereits in den Hauptteil des enthaltenen Blocks integriert.  Sie müssen eine umständliche Regel schreiben, die die gesamte Abfolge der zum <code>append</code> generierten Vorgänge erfasst. </p><br><p>  Apropos <code>.Rules</code> , dann hat dieses DSL eher schwache Arbeit mit Blöcken ( <code>ssa.Block</code> ).  Eine nicht triviale Optimierung, die mit Blöcken verbunden ist, kann in dieser Sprache nicht ausgedrückt werden.  Eine teilweise Blockaktualisierung ist nicht möglich.  Es ist auch unmöglich, Blöcke wegzuwerfen (aber es gibt einen Hack in Form des <code>First</code> Blocks, mit dem toter Code gelöscht wird). </p><br><blockquote>  Selbst wenn einige der Mängel behoben werden können, stimmen die meisten Compiler darin überein, dass es keine einzige und bessere Zwischenform für die Darstellung des Codes gibt. </blockquote><br><h1 id="go-that-goes-faster">  Geh das geht schneller </h1><br><p>  Wenn Sie coole Optimierungsregeln haben, senden Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bitte</a> an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-review.googlesource.com</a> .  Ich würde gerne eine Bewertung <code>iskander.sharipov@intel.com</code> (zu <code>iskander.sharipov@intel.com</code> in CC hinzufügen). </p><br><p>  Viel Spaß beim Hacking Compiler! </p><br><p><img src="https://habrastorage.org/webt/op/wr/50/opwr50a-n6imbex_ykcxpia5_ny.gif"></p><br><h2 id="bonusnyy-material">  Bonusmaterial </h2><br><p>  Beispiele für gute Patches in Go, die SSA-Regeln hinzugefügt oder geändert haben: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL99656: cmd / compile / internal / ssa: IMUL3 {L / Q} für MUL {L / Q} const auf x86 ausgeben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL102277: cmd / compile / internal / ssa: Optimiere das doppelte NEG auf amd64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL54410: cmd / compile / internal / ssa: Verwenden Sie sse auf amd64 auf Null</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL58090: cmd / compile / internal / ssa: Entfernen Sie redundante Null-Erweiterungen auf amd64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL95475: cmd / compile / internal / ssa: Bytespeicher auf amd64 kombinieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL97175: cmd / compile / internal / ssa: Kombinieren Sie aufeinanderfolgende LittleEndian-Speicher auf arm64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL115617: cmd / compile / internal / ssa: Entfernen Sie die nutzlose Null-Erweiterung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL101275: cmd / compile: füge amd64 LEAL {1,2,4,8} ops hinzu</a> </li></ul><br><p>  Vor nicht allzu langer Zeit erschien ein <a href="">README-</a> Dokument, das den SSA-Teil des Compilers beschreibt. <br>  Empfohlene Lektüre. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415771/">https://habr.com/ru/post/de415771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415761/index.html">Was, wie und warum bei abspielbaren Anzeigen</a></li>
<li><a href="../de415763/index.html">Die US-Regierung diskutiert die Möglichkeit, die Kontrolle über die IANA wiederzugewinnen [dies ist jedoch unwahrscheinlich]</a></li>
<li><a href="../de415765/index.html">Warum VMware beschlossen hat, eine Plattform für die Entwicklung von Unternehmensblockchains zu schaffen</a></li>
<li><a href="../de415767/index.html">Tesla Inc hat die Möglichkeit eröffnet, ein Tesla Model 3 für Einwohner Kanadas und der USA zu bestellen</a></li>
<li><a href="../de415769/index.html">Richten Sie den automatischen Start von UI-Tests für Android-Anwendungen über TeamCity ein</a></li>
<li><a href="../de415773/index.html">Nichtfunktionale Anforderungen: Skalierbarkeit</a></li>
<li><a href="../de415775/index.html">Einfache, aber nicht offensichtliche Tipps zur Erstellung eines Berichts für eine coole Konferenz</a></li>
<li><a href="../de415777/index.html">Die erste Meisterschaft für maschinelles Lernen in der Entwicklung</a></li>
<li><a href="../de415779/index.html">Implementierung einer sicheren NAS-Softwareplattform</a></li>
<li><a href="../de415781/index.html">Warum glauben Physiker, dass sich die Stringtheorie als "Theorie von allem" herausstellen könnte?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>