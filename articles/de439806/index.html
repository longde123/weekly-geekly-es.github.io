<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☯️ 🧚🏽 🤜🏿 Gültige SSL-Domänennamen für lokale Docker-Container 🔌 👩🏻‍🤝‍👨🏿 🐖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Verwendung von Docker während des Entwicklungsprozesses ist zum De-facto-Standard geworden. Das Starten einer Anwendung mit all ihren Abhängigkeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gültige SSL-Domänennamen für lokale Docker-Container</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439806/"><p><img src="https://habrastorage.org/webt/0f/nk/vl/0fnkvlzglxdtf2dwegxn-atkobs.png" alt="Vorschau"></p><br><p>  Die Verwendung von Docker während des Entwicklungsprozesses ist zum De-facto-Standard geworden.  Das Starten einer Anwendung mit all ihren Abhängigkeiten mit nur einem Befehl wird immer häufiger.  Wenn die Anwendung über die Webschnittstelle oder eine HTTP-API Zugriff bietet, leitet der Front-Line-Container höchstwahrscheinlich seinen eindeutigen Port (unter anderen Anwendungen, die Sie parallel entwickeln) an den Host weiter, indem er darauf klickt, dass wir mit der Anwendung im Container interagieren können . </p><br><p>  Und dies funktioniert einwandfrei, bis Sie einen ganzen Zoo von Anwendungen haben, zwischen denen das Wechseln einige Unannehmlichkeiten verursacht, da Sie sich das Schema und den Port merken müssen und irgendwo festlegen müssen, welche Ports für welche Anwendung Sie einmal zugewiesen haben, um dies nicht zu tun Kollisionen entstanden im Laufe der Zeit. </p><br><p> Und dann möchten Sie auch die Arbeit an https überprüfen - und Sie müssen entweder Ihr <code>curl --insecure ...</code> oder immer <code>curl --insecure ...</code> , und wenn verschiedene Befehle für Anwendungen funktionieren, beginnt die Anzahl der Paare exponentiell zu wachsen. </p><br><p>  Wieder einmal mit einem solchen Problem konfrontiert - der Gedanke schoss mir durch den Kopf: „Hör auf!“, Und das Ergebnis der Arbeit an einigen Wochenenden war ein Dienst, der dieses Problem im Keim löst, der weiter unten beschrieben wird.  Für die Ungeduldigen traditionell - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenz</a> . </p><a name="habracut"></a><br><h3 id="mir-nas-spasyot-revers-proksi"><del>  Die Welt </del>  Wir werden den Reverse Proxy speichern </h3><br><p>  In guter Weise benötigen wir eine Art Domänenzone, alle Unterdomänen, aus denen der lokale Host immer auflöst (127.0.0.1).  Eine schnelle Suche zeigte auf Domänen wie <code>*.localho.st</code> , <code>*.lvh.me</code> , <code>*.vcap.me</code> und andere, aber wie kann man ihnen ein gültiges SSL-Zertifikat <code>*.vcap.me</code> ?  Nachdem ich an meinem Stammzertifikat herumgebastelt hatte, gelang es mir, <code>curl</code> ohne Fehler zu erhalten, aber nicht alle Browser akzeptierten es korrekt und gaben weiterhin einen Fehler aus.  Außerdem - ich wollte wirklich nicht mit SSL "herumspielen". </p><br><p>  "Nun, lass uns auf die andere Seite gehen!"  - und dann wurde eine Domain mit dem Namen <code>localhost.tools</code> gekauft, an CloudFlare delegiert, die erforderliche Auflösung wurde konfiguriert (alle Subdomains werden aufgelöst <code>127.0.0.1</code> ): </p><br><pre> <code class="bash hljs">$ dig foo.localhost.tools | grep -v <span class="hljs-string"><span class="hljs-string">'^;\|^$'</span></span> foo.localhost.tools. 190 IN A 127.0.0.1</code> </pre> <br><p>  Danach wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">certbot</a> im Container gestartet, der beim Empfang der KEY-API von CF unter Verwendung des DNS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eintrags</a> den Domänenbesitz bestätigt und ein gültiges SSL-Zertifikat für die Ausgabe ausstellt: </p><br><pre> <code class="bash hljs">$ docker run \ --entrypoint=<span class="hljs-string"><span class="hljs-string">""</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(pwd)</span></span></span><span class="hljs-string">/cf-config.conf:/cf-credentials:ro"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(pwd)</span></span></span><span class="hljs-string">/cert:/out:rw"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"/etc/passwd:/etc/passwd:ro"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"/etc/group:/etc/group:ro"</span></span> \ certbot/dns-cloudflare:latest sh -c \ <span class="hljs-string"><span class="hljs-string">"certbot certonly \ --dns-cloudflare \ --dns-cloudflare-credentials '/cf-credentials' \ -d '*.localhost.tools' \ --non-interactive \ --agree-tos \ --email '</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$CF_EMAIL</span></span></span><span class="hljs-string">' \ --server 'https://acme-v02.api.letsencrypt.org/directory' \ &amp;&amp; cp -f /etc/letsencrypt/live/localhost.tools/* /out \ &amp;&amp; chown '</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -u)</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -g)</span></span></span><span class="hljs-string">' /out/*"</span></span></code> </pre> <br><blockquote>  Die Datei <code>./cf-config.conf</code> enthält die Autorisierungsdaten für CF. Weitere Informationen finden Sie in der Dokumentation zu certbot, <code>$CF_EMAIL</code> - Umgebungsvariable mit Ihrer E-Mail </blockquote><p>  Ok, jetzt haben wir ein gültiges SSL-Zertifikat (auch für 3 Monate und nur für Subdomains derselben Stufe).  Es bleibt irgendwie zu lernen, wie man alle Anfragen, die an den lokalen Host kommen, im <strong>richtigen</strong> Container vertritt. </p><br><p>  Und hier kommt uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Traefik</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfe</a> (Spoiler - es ist wunderschön).  Durch lokales Starten und Weiterleiten eines Docker-Sockets an seinen Container über das Volume können Anforderungen an den Container mit der erforderlichen <code>docker label</code> .  Daher benötigen wir keine zusätzliche Konfiguration, außer wenn wir beginnen, die gewünschte Bezeichnung für den Container (und das Docker-Netzwerk) anzugeben, aber wenn wir <em>ohne</em> Docker-Compose starten, ist auch dies nicht erforderlich, obwohl dies sehr wünschenswert ist), für die wir möchten <strong>Zugriff über Domainname und mit gültigem SSL</strong> ! </p><br><p>  Nachdem dies alles geschehen war, sah die Welt einen Docker-Container mit diesem sehr vorkonfigurierten Traefik- und Wildcard-SSL-Zertifikat (ja, es ist öffentlich). </p><br><h2 id="privatnyy-klyuch-ot-ssl-v-publichnom-konteynere">  Privater Schlüssel von SSL in einem öffentlichen Container? </h2><br><p>  Ja, aber ich denke, dass dies nicht beängstigend ist, da es sich in der Domänenzone befindet, die immer den lokalen Host auflöst.  MitM macht in diesem Fall prinzipiell wenig Sinn. </p><br><h2 id="chto-delat-kogda-sertifikat-protuhnet">  Was tun, wenn das Zertifikat fehlerhaft ist? </h2><br><p>  Ziehen Sie einfach das frische Bild ab, indem Sie den Container neu starten.  Für das Projekt ist CI konfiguriert, das das Zertifikat (derzeit) automatisch einmal im Monat aktualisiert und ein neues Image veröffentlicht. </p><br><h2 id="hochu-poprobovat">  Ich möchte es versuchen! </h2><br><p>  Einfacher geht es nicht.  Stellen Sie zunächst sicher, dass Ihre lokalen Ports <code>80</code> und <code>443</code> frei sind, und gehen Sie wie folgt vor: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  docker-   - $ docker network create localhost-tools-network #   - $ docker run -d --rm \ -v /var/run/docker.sock:/var/run/docker.sock \ --network localhost-tools-network \ --name localhost.tools \ -p 80:80 -p 443:443 \ tarampampam/localhost #  nginx,     "my-nginx.localhost.tools" $ docker run -d --rm \ --network localhost-tools-network \ --label "traefik.frontend.rule=Host:my-nginx.localhost.tools" \ --label "traefik.port=80" \ nginx:latest</span></span></code> </pre> <br><p>  Und jetzt können wir testen: </p><br><pre> <code class="bash hljs">$ curl -sS http://my-nginx.localhost.tools | grep Welcome &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt; $ curl -sS https://my-nginx.localhost.tools | grep Welcome &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</code> </pre> <br><p>  Wie Sie sehen können, funktioniert es :) </p><br><h2 id="gde-zhivyot-dokumentaciya-opisanie">  Wo lebt die Dokumentation, Beschreibung? </h2><br><p>  Es ist nicht schwer zu erraten, dass alles unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://localhost.tools verfügbar ist</a> .  Darüber hinaus reagiert die Mündung und kann feststellen, ob der Reverse-Proxy-Daemon lokal ausgeführt wird, und eine Liste der Container anzeigen, die ausgeführt werden und für die Interaktion verfügbar sind (falls vorhanden). </p><br><h2 id="skolko-stoit">  Wie viel es kostet? </h2><br><p>  Überhaupt nicht.  Absolut.  Nachdem ich dies für mich und mein Team getan hatte, wurde mir klar, dass es für andere Entwickler / Ops nützlich sein kann.  Außerdem kostet nur der Domainname Geld, alles andere wird ohne Bezahlung verwendet. </p><br><blockquote>  PS Der Dienst befindet sich daher noch in der Beta-Phase - wenn Mängel, Tippfehler usw. festgestellt werden  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kritzeln Sie</a> einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in PM</a> .  Die Hubs "Programmierung" und "Website-Entwicklung" sind angegeben, da dieser Ansatz vor allem in diesen Branchen nützlich sein kann. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439806/">https://habr.com/ru/post/de439806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439790/index.html">Testen Sie JaCarta WebClient oder bewahren Sie Token in einem Safe auf</a></li>
<li><a href="../de439792/index.html">Die NASA sucht nach Partnern in der amerikanischen Industrie, um eine teilweise wiederverwendbare bemannte Landung zu schaffen</a></li>
<li><a href="../de439794/index.html">Rückenschmerzen - Verständnis aus Sicht der modernen Medizin</a></li>
<li><a href="../de439796/index.html">Spring Boot 2: Was sie nicht in Versionshinweisen schreiben</a></li>
<li><a href="../de439804/index.html">Zen des Unit Testing</a></li>
<li><a href="../de439808/index.html">Die größten Teleskope. Von Notebook und Augen bis hin zu 340-Megapixel-Kameras und Rechenzentren. Teil 1</a></li>
<li><a href="../de439810/index.html">Lernen Sie das Moleculer Microservice Framework kennen</a></li>
<li><a href="../de439812/index.html">Kaggle-Ansätze für CV in Prod: Sie können nicht implementieren, um zu schneiden</a></li>
<li><a href="../de439818/index.html">Merkmale von Designansätzen im realen Fertigungssektor</a></li>
<li><a href="../de439822/index.html">Erstellen einer alternativen Anzeige für den Ensoniq EPS16 + und ASR10 Synthesizer / Sampler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>