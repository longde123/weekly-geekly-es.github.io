<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèåÔ∏è üì∞ üêæ Como funciona o Flutter üò∂ ü§ûüèæ üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como o Flutter realmente funciona? 


 O que s√£o Widgets, Elementos, BuildContext, RenderOject, Bindings? .. 


 Dificuldade: Iniciante 
 Entrada 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como funciona o Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Como o Flutter realmente funciona? </p><br><p>  O que s√£o Widgets, Elementos, BuildContext, RenderOject, Bindings? .. </p><br><p>  Dificuldade: <em>Iniciante</em> </p><br><h1 id="vstuplenie">  Entrada </h1><br><p>  No ano passado ( <em>nota: em 2018</em> ), quando iniciei minha jornada no fabuloso mundo de Flutter, havia muito pouca informa√ß√£o na Internet em compara√ß√£o com o que √© hoje.  Agora, apesar de muitos materiais j√° terem sido escritos, apenas uma pequena parte deles fala sobre como o Flutter realmente funciona. </p><br><p>  O que s√£o Widgets ( <em>widgets</em> ), Elementos ( <em>elementos</em> ), BuildContext?  Por que o Flutter √© r√°pido?  Por que √†s vezes n√£o funciona como esperado?  O que s√£o √°rvores e por que s√£o necess√°rias? </p><br><p>  Em 95% dos casos, ao escrever um aplicativo, voc√™ s√≥ lida com widgets para exibir algo ou interagir com ele.  Mas voc√™ nunca se perguntou como toda essa m√°gica funciona por dentro?  Como o sistema sabe quando atualizar a tela e quais partes devem ser atualizadas? </p><br><p>  <strong>Conte√∫do:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entrada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Antecedentes</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um pouco sobre o dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interface entre c√≥digo e dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciar a renderiza√ß√£o do Flutter Framework Flutter Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RenderView e RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Liga√ß√µes de Inicializa√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Liga√ß√£o por gestos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Liga√ß√£o do renderizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vincula√ß√£o de widgets</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. De widgets para pixels</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Configura√ß√£o imut√°vel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A estrutura hier√°rquica dos widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Floresta atr√°s das √°rvores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entendendo o elemento em uma √°rvore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3 categorias de widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de itens</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como widgets e elementos funcionam juntos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Manuseando gestos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: Anima√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Imagem completa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qual a utilidade de um BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por divers√£o</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√£o</a> </li></ul><br><h1 id="chast-1-predystoriya">  Parte 1: Antecedentes </h1><br><p>  A primeira parte do artigo apresenta alguns conceitos-chave que ser√£o usados ‚Äã‚Äãna segunda parte do material e ajudam a entender melhor o Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Um pouco sobre o dispositivo </h2><br><p>  Vamos come√ßar do final e voltar ao b√°sico. </p><br><p>  Quando voc√™ olha para o seu dispositivo ou, mais precisamente, para o aplicativo em execu√ß√£o no seu dispositivo, voc√™ v√™ apenas a tela. </p><br><p>  Na verdade, tudo o que voc√™ v√™ s√£o os pixels, que juntos formam uma imagem bidimensional e, quando voc√™ toca a tela com o dedo, o dispositivo reconhece apenas a posi√ß√£o do dedo no vidro. </p><br><p>  Toda a m√°gica do aplicativo (do ponto de vista visual) na maioria dos casos √© atualizar essa imagem com base nas seguintes intera√ß√µes: </p><br><ul><li>  com a tela do dispositivo ( <em>por exemplo, um dedo no vidro</em> ) </li><li>  com a rede ( <em>por exemplo, comunica√ß√£o com o servidor</em> ) </li><li>  ao longo do tempo ( <em>por exemplo, anima√ß√£o</em> ) </li><li>  com outros sensores externos </li></ul><br><p>  A visualiza√ß√£o da imagem na tela √© fornecida pelo hardware (tela), que regularmente (normalmente 60 vezes por segundo) atualiza a tela.  Isso √© chamado de "taxa de atualiza√ß√£o" e √© expresso em Hz (Hertz). </p><br><p>  O monitor recebe informa√ß√µes para exibi√ß√£o da GPU (Unidade de processamento gr√°fico), que √© um circuito eletr√¥nico especializado otimizado e projetado para formar rapidamente imagens de alguns dados (pol√≠gonos e texturas).  O n√∫mero de vezes por segundo que o processador gr√°fico pode gerar uma "imagem" (= buffer de quadro) a ser exibida e envi√°-la ao hardware √© chamada de taxa de quadros ( <em>nota: taxa de quadros</em> ).  Isso √© medido usando um bloco de quadros por segundo ( <em>por exemplo, 60 quadros por segundo ou 60 fps</em> ). </p><br><p>  Voc√™ pode me perguntar por que comecei este artigo com os conceitos de uma imagem bidimensional exibida por uma GPU / hardware e um sensor f√≠sico de vidro, e qual √© a conex√£o com os widgets regulares do Flutter? </p><br><p>  Acho que ser√° mais f√°cil entender como o Flutter realmente funciona se olharmos para esse ponto de vista, pois um dos principais objetivos do aplicativo Flutter √© criar essa imagem bidimensional e permitir que ela interaja com ela.  Tamb√©m porque no Flutter, acredite ou n√£o, quase tudo se deve √† necessidade de atualizar a tela rapidamente e no momento certo! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Interface entre c√≥digo e dispositivo </h2><br><p>  De qualquer forma, todos os interessados ‚Äã‚Äãem Flutter j√° viram a seguinte imagem que descreve a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">arquitetura de alto n√≠vel de</a> Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Quando escrevemos um aplicativo Flutter usando o Dart, permanecemos no n√≠vel do <em>Flutter Framework</em> (destacado em verde). </p><br><p>  <em>O Flutter Framework</em> interage com o <em>Flutter Engine</em> (em azul) atrav√©s de uma camada de abstra√ß√£o chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Window</a> .  Esse n√≠vel de abstra√ß√£o fornece v√°rias APIs para intera√ß√£o indireta com o dispositivo. </p><br><p>  Tamb√©m atrav√©s desse n√≠vel de abstra√ß√£o, o <em>Flutter Engine</em> notifica o <em>Flutter Framework</em> quando: </p><br><ul><li>  um evento de interesse ocorre no n√≠vel do dispositivo (altera√ß√£o de orienta√ß√£o, altera√ß√£o de configura√ß√µes, problema de mem√≥ria, estado operacional do aplicativo ...) </li><li>  algum evento ocorre no n√≠vel do vidro (= gesto) </li><li>  canal de plataforma envia alguns dados </li><li>  mas tamb√©m principalmente quando o <strong>Flutter Engine est√° pronto para renderizar um novo quadro</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Gerenciar a renderiza√ß√£o do Flutter Framework Flutter Engine </h2><br><p>  √â dif√≠cil de acreditar, mas √© verdade.  Exceto em alguns casos ( <em>veja abaixo</em> ), nenhum c√≥digo do <em>Flutter Framework</em> √© executado sem iniciar a renderiza√ß√£o do <em>Flutter Engine</em> . </p><br><p>  Exce√ß√µes: </p><br><ul><li>  Gesto / Gesto (= evento no copo) </li><li>  Mensagens da plataforma (= mensagens geradas por um dispositivo, como GPS) </li><li>  Mensagens do dispositivo (= mensagens relacionadas a uma altera√ß√£o no status do dispositivo, por exemplo, orienta√ß√£o, aplicativo enviado em segundo plano, alertas de mem√≥ria, configura√ß√µes do dispositivo ...) </li><li>  Respostas futuras ou http </li></ul><br><p>  <em>(Entre n√≥s, √© poss√≠vel aplicar uma altera√ß√£o visual sem chamar o Flutter Engine, mas isso <strong>n√£o</strong> √© <strong>recomendado</strong> )</em> </p><br><p>  Voc√™ me pergunta: "Se algum tipo de c√≥digo relacionado ao <em>gesto</em> √© executado e causa uma altera√ß√£o visual, ou se eu uso um <em>cron√¥metro</em> para definir a frequ√™ncia da tarefa que leva a altera√ß√µes visuais (por exemplo, anima√ß√£o), como funciona?" </p><br><p>  Se voc√™ deseja que uma altera√ß√£o visual ocorra ou que algum c√≥digo seja executado com base em um cron√¥metro, √© necess√°rio informar ao <em>Flutter Engine</em> que algo precisa ser desenhado. </p><br><p>  Geralmente, na pr√≥xima vez em que o <em>Flutter Engine √©</em> atualizado, ele solicita que o <em>Flutter Framework</em> execute algum c√≥digo e, finalmente, forne√ßa uma nova cena para renderiza√ß√£o. </p><br><p>  Portanto, uma pergunta importante √© como o mecanismo Flutter organiza todo o comportamento do aplicativo com base na renderiza√ß√£o. </p><br><p>  Para ter uma id√©ia dos mecanismos internos, observe a seguinte anima√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Uma breve explica√ß√£o (mais detalhes vir√£o mais tarde): </p><br><ul><li>  Alguns eventos externos (gesto, respostas http, etc.) ou at√© futuros podem disparar tarefas que tornam necess√°rio atualizar a exibi√ß√£o.  A mensagem correspondente √© enviada ao <em>Flutter Engine</em> (= <em>Quadro de programa√ß√£o</em> ) </li><li>  Quando o <em>Flutter Engine est√°</em> pronto para come√ßar a atualizar a renderiza√ß√£o, ele cria uma solicita√ß√£o <em>Begin Frame</em> </li><li>  Essa solicita√ß√£o <em>Begin Frame</em> √© interceptada pelo <em>Flutter Framework</em> , que executa tarefas relacionadas principalmente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Tickers</a> (por exemplo, anima√ß√£o) </li><li>  Essas tarefas podem recriar a solicita√ß√£o para renderiza√ß√£o posterior (exemplo: a anima√ß√£o n√£o concluiu sua execu√ß√£o e, para conclu√≠-la, ser√° necess√°rio obter outro <em>quadro</em> inicial mais tarde) </li><li>  Em seguida, o <em>Flutter Engine</em> envia um <em>quadro de desenho</em> , que √© interceptado pelo <em>Flutter Framework</em> , que procurar√° todas as tarefas relacionadas √† atualiza√ß√£o do layout em termos de estrutura e tamanho </li><li>  Depois que todas essas tarefas s√£o conclu√≠das, ele prossegue para as tarefas associadas √† atualiza√ß√£o do layout em termos de renderiza√ß√£o </li><li>  Se houver algo na tela que precise ser desenhado, uma nova cena ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Cena</a> ) para visualiza√ß√£o ser√° enviada ao <em>Flutter Engine</em> , que atualizar√° a tela. </li><li>  O <em>Flutter Framework, em seguida,</em> executa todas as tarefas que ser√£o executadas ap√≥s a renderiza√ß√£o (= retornos de chamada PostFrame) e quaisquer outras tarefas subseq√ºentes que n√£o estejam relacionadas √† renderiza√ß√£o </li><li>  ... e esse processo come√ßa tudo de novo </li></ul><br><h2 id="renderview-i-renderobject">  RenderView e RenderObject </h2><br><p>  Antes de mergulhar nos detalhes do fluxo de trabalho, √© hora de apresentar o conceito da <em>√Årvore de renderiza√ß√£o</em> . </p><br><p>  Como mencionado anteriormente, tudo ser√° convertido em pixels que ser√£o exibidos na tela, e o <em>Flutter Framework</em> converter√° os <em>Widgets</em> que usamos para desenvolver o aplicativo em blocos visuais que ser√£o exibidos na tela. </p><br><p>  Essas partes visuais correspondem a objetos chamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">RenderObject</a> , que s√£o usados ‚Äã‚Äãpara: </p><br><ul><li>  definindo uma determinada √°rea da tela em termos de tamanho, posi√ß√£o, geometria e tamb√©m em termos de <em>"conte√∫do renderizado"</em> </li><li>  identifica√ß√£o de √°reas da tela que podem ser afetadas por gestos (= toque do dedo) </li></ul><br><p>  Um conjunto de todos os <em>RenderObjects</em> forma uma √°rvore chamada <em>√Årvore de Renderiza√ß√£o</em> .  No topo desta √°rvore (= <em>raiz</em> ), encontramos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> fornece uma superf√≠cie comum para objetos <em>Render Tree</em> e √© uma vers√£o especial do <em>RenderObject</em> . </p><br><p>  Visualmente, poder√≠amos representar tudo isso da seguinte maneira: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  A rela√ß√£o entre <em>Widget</em> e <em>RenderObject</em> ser√° discutida mais adiante.  Enquanto isso, √© hora de ir um pouco mais fundo ... </p><br><h2 id="inicializaciya-bindings">  Liga√ß√µes de Inicializa√ß√£o </h2><br><p> Quando o aplicativo Flutter √© iniciado, a fun√ß√£o <code>main()</code> √© chamada primeiro, que finalmente chama o <code>runApp(Widget app)</code> . </p><br><p>  Quando o m√©todo <code>runApp()</code> √© <code>runApp()</code> <em>Flutter Framework</em> inicializa as interfaces entre ele e o <em>Mecanismo de Flutter</em> .  Essas interfaces s√£o chamadas de <strong>liga√ß√µes</strong> ( <em>nota: liga√ß√µes</em> ). </p><br><p>  <strong>Introdu√ß√£o √†s liga√ß√µes</strong> </p><br><p>  As liga√ß√µes foram projetadas para serem o elo entre a estrutura e o mecanismo Flutter.  Somente atrav√©s de liga√ß√µes os dados podem ser trocados entre o <em>Flutter Framework</em> e o <em>Flutter Engine</em> . <br>  <em>(H√° apenas uma exce√ß√£o a essa regra -</em> RenderView <em>, mas discutiremos isso mais tarde).</em> </p><br><p>  Cada liga√ß√£o √© respons√°vel pelo processamento de um conjunto de tarefas, a√ß√µes, eventos espec√≠ficos, agrupados por √°rea de atividade. </p><br><p>  No momento da reda√ß√£o deste artigo, o <em>Flutter Framework</em> tinha 8 liga√ß√µes. </p><br><p>  Abaixo est√£o 4 deles que ser√£o considerados neste artigo: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Liga√ß√£o por gestos</em> </li><li>  <em>Liga√ß√£o do renderizador</em> </li><li>  <em>Vincula√ß√£o de widgets</em> </li></ul><br><p>  Para completar, vou mencionar os 4 restantes: </p><br><ul><li>  <em>ServicesBinding</em> : respons√°vel pelo processamento de mensagens enviadas pelo <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">canal da plataforma</a></em> </li><li>  <em>PaintingBinding</em> : respons√°vel pelo processamento do cache de imagens </li><li>  <em>SemanticsBinding</em> : reservado para a implementa√ß√£o subsequente de tudo relacionado √† sem√¢ntica </li><li>  <em>TestWidgetsFlutterBinding</em> : usado pela biblioteca de teste do widget </li></ul><br><p>  Voc√™ tamb√©m pode mencionar <em>WidgetsFlutterBinding</em> , mas isso n√£o √© realmente uma liga√ß√£o, mas um tipo de <em>"inicializador de liga√ß√µes"</em> . </p><br><p>  O diagrama a seguir mostra a intera√ß√£o entre as liga√ß√µes, que vou considerar a seguir, e o <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Vejamos cada uma dessas liga√ß√µes "principais". </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Essa liga√ß√£o tem duas responsabilidades principais: </p><br><ul><li>  Diga o <em>Flutter Engine</em> : <em>"Ei! Da pr√≥xima vez que n√£o estiver ocupado, acorde-me para que eu possa trabalhar um pouco e lhe dizer o que renderizar, ou se eu precisar que voc√™ me ligue mais tarde ..."</em> </li><li>  Ou√ßa e responda a esses <em>"despertares perturbadores"</em> (veja abaixo) </li></ul><br><p>  Quando <em>o SchedulerBinding</em> solicita uma <em>chamada de ativa√ß√£o</em> ? </p><br><ul><li><p>  Quando o <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ticker</a></em> deve <em>elaborar um</em> novo <em>tick</em> </p><br><p>  Por exemplo, voc√™ tem uma anima√ß√£o, voc√™ a inicia.  A anima√ß√£o √© cortada usando o <em>Ticker</em> , que √© chamado em intervalos regulares (= <em>tick</em> ) para executar um <em>retorno de chamada</em> .  Para iniciar um <em>retorno de chamada</em> , precisamos informar ao <em>Flutter Engine</em> para que ele nos acorde durante a pr√≥xima atualiza√ß√£o (= <em>Begin Frame</em> ).  Isso iniciar√° o retorno de chamada do <em>ticker</em> para concluir sua tarefa.  Se o <em>ticker</em> ainda precisar continuar a execu√ß√£o, no final de sua tarefa, ele chamar√° <em>SchedulerBinding</em> para agendar outro quadro. </p><br></li><li><p>  Quando atualizar a exibi√ß√£o </p><br><p>  Por exemplo, precisamos elaborar um evento que leve a uma altera√ß√£o visual (exemplo: atualizar a cor de uma parte da tela, rolar, adicionar / remover algo da tela); para isso, precisamos tomar as medidas necess√°rias para finalmente exibir a imagem atualizada na tela.  Nesse caso, quando ocorre essa altera√ß√£o, o <em>Flutter Framework</em> chama <em>SchedulerBinding</em> para agendar outro quadro usando o <em>Flutter Engine</em> .  <em>(Mais tarde, veremos como isso realmente funciona)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Liga√ß√£o por gestos </h3><br><p>  Essa liga√ß√£o ouve a intera√ß√£o com o mecanismo em termos do <em>"dedo"</em> (= <em>gesto</em> ). </p><br><p>  Em particular, ele √© respons√°vel por receber dados relacionados aos <em>dedos</em> e por determinar com que parte da tela os gestos trabalham.  Ele ent√£o notifica adequadamente / dessas partes. </p><br><h3 id="rendererbinding">  Liga√ß√£o do renderizador </h3><br><p>  Essa liga√ß√£o √© o link entre o <em>Flutter Engine</em> e a <em>Render Tree</em> .  Ela √© respons√°vel por: </p><br><ul><li>  ouvindo eventos gerados pelo mecanismo para informar sobre altera√ß√µes aplicadas pelo usu√°rio por meio de configura√ß√µes do dispositivo que afetam efeitos visuais e / ou sem√¢nticas </li><li>  mensagem ao mecanismo sobre altera√ß√µes que ser√£o aplicadas √† exibi√ß√£o </li></ul><br><p>  Para fornecer as altera√ß√µes que ser√£o exibidas na tela, o <em>RendererBinding</em> √© respons√°vel por gerenciar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">PipelineOwner</a> e inicializar o <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> √© um tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">orquestra</a> que sabe o que precisa ser feito com o <em>RenderObject</em> de acordo com o <em>componente</em> e coordena essas a√ß√µes. </p><br><h3 id="widgetsbinding">  Vincula√ß√£o de widgets </h3><br><p>  Essa liga√ß√£o escuta as altera√ß√µes aplicadas pelo usu√°rio por meio das configura√ß√µes do dispositivo que afetam o idioma (= <em>localidade</em> ) e a <em>sem√¢ntica</em> . </p><br><blockquote>  <em>Pequena nota</em> <br><br>  <em>Suponho que, numa fase posterior do desenvolvimento do</em> Flutter, <em>todos os eventos relacionados √† sem√¢ntica sejam transferidos para o</em> SemanticsBinding <em>, mas no momento da reda√ß√£o deste artigo, esse n√£o √© o caso.</em> </blockquote><p>  Al√©m disso, <em>WidgetsBinding</em> √© o link entre os widgets e o <em>Flutter Engine</em> .  Ela √© respons√°vel por: </p><br><ul><li>  gerenciamento do processo de processamento de altera√ß√µes na estrutura de widgets </li><li>  renderizar chamada </li></ul><br><p>  O processamento de altera√ß√µes na estrutura dos widgets √© realizado usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>O BuildOwner</em> controla quais widgets precisam ser reconstru√≠dos e lida com outras tarefas que se aplicam √† estrutura do widget como um todo. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Parte 2. De widgets para pixels </h1><br><p>  Agora que aprendemos o b√°sico do trabalho interno de <em>Flutter</em> , √© hora de falar sobre widgets. </p><br><p>  Em toda a documenta√ß√£o do Flutter, voc√™ ler√° todos os <em>widgets</em> (widgets). </p><br><p>  Isso est√° quase correto.  Mas, para ser um pouco mais preciso, prefiro dizer: </p><br><blockquote>  Do lado do desenvolvedor, tudo relacionado √† interface do usu√°rio em termos de layout e intera√ß√£o √© feito usando widgets. </blockquote><p>  Por que tanta precis√£o?  Al√©m do fato de o <em>Widget</em> permitir que o desenvolvedor determine parte da tela em termos de tamanho, conte√∫do, layout e intera√ß√£o, <strong>MAS</strong> h√° muito mais.  Ent√£o, o que √© realmente o <em>Widget</em> ? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Configura√ß√£o imut√°vel </h2><br><p>  Se voc√™ olhar o c√≥digo fonte do <em>Flutter</em> , notar√° a seguinte defini√ß√£o da classe <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  O que isso significa? </p><br><p>  A anota√ß√£o <strong>"@ imut√°vel" √©</strong> muito importante e nos diz que <strong>qualquer vari√°vel na classe Widget deve ser FINAL</strong> , ou seja, "definida e designada <strong>UMA VEZ PARA TODOS</strong> ".  Assim, depois de criar uma inst√¢ncia, o Widget n√£o poder√° mais alterar suas vari√°veis ‚Äã‚Äãinternas. </p><br><blockquote>  <em>Como o Widget √© imut√°vel, ele pode ser considerado uma configura√ß√£o est√°tica.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  A estrutura hier√°rquica dos widgets </h2><br><p>  Ao projetar com o Flutter, voc√™ define a estrutura de suas telas usando widgets como este: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Este exemplo usa 7 widgets que juntos formam uma estrutura hier√°rquica.  Um esquema muito simplificado baseado neste c√≥digo √© o seguinte: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Como voc√™ pode ver, o diagrama apresentado se parece com uma √°rvore, onde <em>SafeArea</em> √© sua raiz. </p><br><h2 id="les-za-derevyami">  Floresta atr√°s das √°rvores </h2><br><p>  Como voc√™ j√° sabe, um widget em si pode ser uma agrega√ß√£o de outros widgets.  Como exemplo, voc√™ pode modificar o c√≥digo anterior da seguinte maneira: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Esta op√ß√£o assume que o pr√≥prio widget <em>"MyOwnWidget"</em> exibir√° <em>SafeArea</em> , <em>Scaffold</em> .  Mas a coisa mais importante neste exemplo √© que </p><br><blockquote>  <em>Um widget</em> pode representar uma folha, um n√≥ em uma √°rvore, at√© a pr√≥pria √°rvore ou, por que n√£o, uma floresta de √°rvores ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Entendendo o <em>elemento</em> em uma √°rvore </h2><br><p>  O que isso tem a ver com isso? </p><br><p>  Como ser√° mostrado mais adiante, para poder gerar pixels que comp√µem a imagem exibida no dispositivo, o <em>Flutter</em> deve conhecer em detalhes todas as pequenas partes que comp√µem a tela e, para determinar todas as partes, precisa conhecer a <strong>expans√£o de</strong> todos os widgets. </p><br><p>  Para ilustrar esse ponto, considere o princ√≠pio de uma boneca aninhada: quando fechada, voc√™ v√™ apenas 1 boneca, mas ela cont√©m outra, que por sua vez cont√©m outra e assim por diante ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Quando o <em>Flutter</em> expande todos os widgets <em>(parte da tela)</em> , ser√° como obter todos os bonecos <em>(parte do todo)</em> . </p><br><p>  A figura abaixo mostra parte da estrutura hier√°rquica final dos widgets correspondentes ao c√≥digo anterior.  Em amarelo, destaquei os widgets mencionados no c√≥digo anteriormente, para que voc√™ possa defini-los na √°rvore final. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Esclarecimentos importantes</em></strong> <br><br>  <em>A linguagem "√Årvore de widgets" existe apenas para facilitar o entendimento, pois os programadores usam widgets, mas N√ÉO existe nenhuma √°rvore de widgets no Flutter!</em> <br><br>  <em>De fato, seria mais correto dizer "√°rvore dos elementos"</em> </blockquote><p>  √â hora de introduzir o conceito de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">elemento</a> . </p><br><blockquote>  <em><strong>Cada</strong> widget possui <strong>um</strong> elemento.</em>  <em>Os elementos s√£o conectados um ao outro e formam uma √°rvore.</em>  <em>Portanto, <strong>um elemento</strong> √© uma refer√™ncia a algo na √°rvore.</em> </blockquote><p>  Para come√ßar, pense em um elemento como um n√≥ que possui um pai e possivelmente um filho.  Ao vincul√°-los atrav√©s de um relacionamento <em>pai-filho</em> , obtemos uma estrutura em √°rvore. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Como voc√™ pode ver, o elemento aponta para um widget e tamb√©m <strong>pode</strong> apontar para um <em>RenderObject</em> . </p><br><blockquote>  <em>Melhor ainda ... O elemento aponta para o Widget que <strong>criou</strong> este elemento!</em> </blockquote><p>  Vamos resumir: </p><br><ul><li>  N√£o existe uma √°rvore de widgets, mas h√° uma √°rvore de elementos </li><li>  Os elementos s√£o criados por widgets. </li><li>  O item refere-se ao widget que o criou. </li><li>  Elementos vinculados aos relacionamentos pai </li><li>  Um item pode ter um "beb√™". </li><li>  Os elementos tamb√©m podem apontar para um <em>RenderObject.</em> </li></ul><br><blockquote>  <em><strong>Os elementos</strong> determinam como as partes dos blocos exibidos s√£o relacionadas entre si.</em> </blockquote><p>  Para melhor imaginar onde o conceito de <em>um elemento</em> se encaixa, vejamos a seguinte representa√ß√£o visual: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Como voc√™ pode ver, a √°rvore de elementos √© o relacionamento real entre widgets e <em>RenderObjects</em> . </p><br><p>  Mas por que o <em>Widget</em> cria um <em>elemento</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 categorias de widgets </h2><br><p>  No Flutter, os widgets s√£o divididos em 3 categorias, pessoalmente os chamo da seguinte forma <em>(mas essa √© apenas a minha maneira de classific√°-los)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  O principal objetivo desses widgets √© armazenar algumas informa√ß√µes (que devem estar acess√≠veis aos widgets), parte da estrutura da √°rvore com base no Proxy.  Um exemplo desses widgets √© <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">InheritedWidget</a></strong> ou <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Esses widgets n√£o participam diretamente da forma√ß√£o da interface do usu√°rio, mas s√£o usados ‚Äã‚Äãpara obter as informa√ß√µes que eles podem fornecer. </p><br></li><li><p>  Renderer </p><br><p>  Esses widgets est√£o diretamente relacionados ao layout da tela, porque determinam (ou s√£o usados ‚Äã‚Äãpara determinar) o <em>tamanho</em> , <em>posi√ß√£o</em> , <em>renderiza√ß√£o</em> .  Exemplos t√≠picos s√£o: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Linha</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Coluna</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pilha</a></strong> e <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Preenchimento</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Alinhamento</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Opacidade</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Componente </p><br><p>  Esses s√£o outros widgets que fornecem diretamente n√£o as informa√ß√µes finais relacionadas aos tamanhos, posi√ß√µes, apar√™ncia, mas os dados (ou dicas) que ser√£o usados ‚Äã‚Äãpara obter as informa√ß√µes finais.  Esses widgets s√£o comumente referidos como componentes. </p><br><p>  Exemplos: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Andaime</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Texto</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Este arquivo PDF</a> lista a maioria dos widgets agrupados por categoria. </p><br><p>  Por que essa separa√ß√£o √© importante?  Porque, dependendo da categoria do widget, o tipo de elemento correspondente est√° associado a ... </p><br><h2 id="tipy-elementov">  Tipos de itens </h2><br><p>  Existem v√°rios tipos de elementos: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Como voc√™ pode ver na figura acima, os elementos s√£o divididos em 2 tipos principais: </p><br><ul><li><p>  Componententlement </p><br><p>  Esses elementos n√£o <strong>s√£o diretamente</strong> respons√°veis ‚Äã‚Äãpor renderizar qualquer parte da exibi√ß√£o. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Esses elementos s√£o respons√°veis ‚Äã‚Äãpor partes da imagem exibida na tela. </p><br></li></ul><br><p>  √ìtimo!  Tanta informa√ß√£o, mas como tudo isso est√° relacionado um ao outro e por que √© interessante falar sobre isso? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Como widgets e elementos funcionam juntos </h2><br><blockquote>  <em>No Flutter, todas as mec√¢nicas s√£o baseadas na invalida√ß√£o de um elemento ou renderObject.</em> </blockquote><p>  A invalida√ß√£o do elemento pode ser feita das seguintes maneiras: </p><br><ul><li>  usando <code>setState</code> , que invalida todo o <strong>StatefulElement</strong> (observe que eu n√£o intencionalmente digo <em>StatefulWidget</em> ) </li><li>  por meio de notifica√ß√µes processadas por <strong>proxyElement</strong> (por exemplo, InheritedWidget), que invalida qualquer <em>elemento</em> que dependa desse <em>proxyElement</em> </li></ul><br><p>  O resultado da <em>invalida√ß√£o</em> √© que um link para o <em>elemento</em> correspondente aparece na lista de elementos <strong>sujos</strong> . </p><br><p>  A <em>invalida√ß√£o de renderObject</em> significa que a estrutura dos elementos n√£o muda, mas h√° uma altera√ß√£o no n√≠vel de <em>renderObject</em> , por exemplo: </p><br><ul><li>  alterando seu tamanho, posi√ß√£o, geometria ... </li><li>  algo precisa ser repintado, por exemplo, quando voc√™ altera a cor do plano de fundo, o estilo da fonte ... </li></ul><br><p>  O resultado dessa <em>invalida√ß√£o</em> √© um link para o <em>renderObject</em> correspondente na lista de objetos de renderiza√ß√£o <em>(renderObjects)</em> que precisam ser reconstru√≠dos ou redesenhados. </p><br><p>  Independentemente do tipo de invalida√ß√£o, <strong>SchedulerBinding</strong> √© chamado (lembra-se disso?) Para solicitar ao <strong>Flutter Engine</strong> que agende um novo quadro. </p><br><p>  Este √© exatamente o momento em que o <em>Flutter Engine</em> "acorda" o <em>SchedulerBinding</em> e toda a m√°gica acontece ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  No in√≠cio deste artigo, observamos que o <em>SchedulerBinding tem</em> duas responsabilidades principais, uma das quais √© a disposi√ß√£o de lidar com solicita√ß√µes feitas pelo <em>Flutter Engine</em> relacionadas √† reconstru√ß√£o de quadros.  Este √© o momento perfeito para focar nisso. </p><br><p>  O diagrama de sequ√™ncia parcial abaixo mostra o que acontece quando o <em>SchedulerBinding</em> recebe uma solicita√ß√£o <em>onDrawFrame ()</em> do <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Etapa 1. Elementos</strong> </p><br><p>  <em>WidgetsBinding</em> √© <em>chamado</em> e essa liga√ß√£o primeiro considera as altera√ß√µes associadas aos elementos.  <em>WidgetsBinding</em> chama o m√©todo <em>buildScope do</em> objeto <em>buildOwner</em> , pois o <strong>BuildOwner</strong> √© respons√°vel pelo processamento da √°rvore de itens.  Este m√©todo percorre a lista de elementos <em>sujos</em> e solicita sua <strong>reconstru√ß√£o</strong> . </p><br><p>  Os principais princ√≠pios desse m√©todo de <code>rebuild()</code> ) s√£o: </p><br><ol><li>  H√° uma solicita√ß√£o para reconstruir o elemento (isso levar√° a maior parte do tempo), chamando o m√©todo <code>build()</code> do widget ao qual esse elemento se refere (m√©todo = <code>Widget build (BuildContext context) {...}</code> ).  Este m√©todo <code>build()</code> retornar√° um novo widget </li><li>  Se o elemento n√£o tiver "filhos", um elemento ser√° criado para o novo widget (veja abaixo) ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">inflateWidget</a></em> ), caso contr√°rio </li><li>  o novo widget √© comparado ao referenciado pelo filho do elemento <br><ul><li>  Se eles forem intercambi√°veis ‚Äã‚Äã(= <em>o mesmo tipo e chave de widget</em> ), a atualiza√ß√£o ocorrer√° e o filho ser√° salvo. </li><li>  Se eles n√£o forem intercambi√°veis, o filho ser√° descartado ( <em>~ descartado</em> ) e um elemento ser√° criado para o novo widget </li></ul></li><li>  Este novo item √© montado como filho do item.  ( <em>montado)</em> = inserido na √°rvore de elementos) </li></ol><br><p>  A anima√ß√£o a seguir tentar√° tornar essa explica√ß√£o um pouco mais clara. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Nota sobre widgets e elementos</strong> </p><br><p>  Para um novo widget, √© criado um elemento de um <em>tipo espec√≠fico</em> que corresponde √† <em>categoria do</em> widget, a saber: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Cada um desses tipos de elementos tem seu pr√≥prio comportamento.  Por exemplo: </p><br><ul><li>  <em>StatefulElement</em> chamar√° o m√©todo <code>widget.createState()</code> na inicializa√ß√£o, que criar√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">State</a> e o associar√° ao elemento </li><li>  Quando um elemento do tipo <em>RenderObjectElement √©</em> montado, ele cria um <em>RenderObject</em> .  Esse <em>renderObject</em> ser√° adicionado √† <em>Render Tree</em> e associado ao elemento. </li></ul><br><p>  <strong>Etapa 2. renderObjects</strong> </p><br><p>  Agora, depois de concluir todas as a√ß√µes associadas aos elementos <em>sujos</em> , a <em>√Årvore de elementos</em> fica est√°vel.  Portanto, √© hora de considerar o processo de visualiza√ß√£o. </p><br><p>  Como <em>RendererBinding</em> √© respons√°vel por renderizar a <em>Render Tree</em> , o <em>WidgetsBinding</em> chama o m√©todo <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  O diagrama parcial abaixo mostra a sequ√™ncia de a√ß√µes executadas durante a solicita√ß√£o <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  Nesta etapa, as seguintes a√ß√µes s√£o executadas: </p><br><ul><li>  Cada <em>renderObject</em> marcado como <em>sujo</em> √© solicitado para compor (ou seja, calcular seu tamanho e geometria) </li><li>  Cada <em>renderObject</em> marcado como "necessitando de redesenho" √© redesenhado usando seu pr√≥prio m√©todo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">camada</a> </li><li>  A cena resultante √© formada e enviada ao <em>Flutter Engine</em> , para que este √∫ltimo a transfira para a tela do dispositivo </li><li>  Por fim, a sem√¢ntica tamb√©m √© atualizada e enviada ao <em>Flutter Engine</em> </li></ul><br><p>  No final deste fluxo de trabalho, a tela do dispositivo √© atualizada. </p><br><h1 id="chast-3-obrabotka-zhestov">  Parte 3: Manuseando gestos </h1><br><p>  Gestos (= <em>eventos relacionados a a√ß√µes dos dedos no vidro</em> ) s√£o processados ‚Äã‚Äãusando <em>GestureBinding</em> . </p><br><p>  Quando o <em>Mecanismo de Flutter</em> envia informa√ß√µes sobre um evento de gesto pela API <em>window.onPointerDataPacket</em> , o <strong>GestureBinding o</strong> intercepta, executa alguns buffers e: </p><br><ol><li>  converte as coordenadas fornecidas pelo <em>Flutter Engine</em> para corresponder √† <strong>propor√ß√£o de pixels</strong> do <strong>dispositivo</strong> e, em seguida, </li><li>  recupera do <em>renderView uma</em> lista de todos os <em>RenderObjects</em> que est√£o na parte da tela relacionada √†s coordenadas do evento </li><li>  <em>itera</em> pela lista resultante de <em>renderObjects</em> e envia um evento relacionado a cada um deles </li><li>  se <em>renderObject</em> "escuta" eventos desse tipo, ele o processa </li></ol><br><p>  Espero que agora eu entenda a import√¢ncia do <em>renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Parte 4: Anima√ß√µes </h1><br><p>  Esta parte do artigo √© sobre o conceito de <strong>anima√ß√£o</strong> e uma profunda compreens√£o do <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Quando voc√™ trabalha com anima√ß√µes, geralmente usa um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">AnimationController</a> ou qualquer widget para anima√ß√µes ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  No <em>Flutter,</em> tudo relacionado √†s anima√ß√µes refere-se ao <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ticker</a></em> .  <em>O ticker</em> , quando est√° ativo, tem apenas uma tarefa: "solicita <em>ao SchedulerBinding que</em> registre um retorno de chamada e diga ao <em>Flutter Engine</em> para ativ√°-lo quando um novo retorno de chamada aparecer".  Quando o <em>Flutter Engine est√°</em> pronto, ele chama <em>SchedulerBinding</em> por meio de uma solicita√ß√£o: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> acessa a lista de retorno de chamada e executa cada uma delas. </p><br><p>  Cada <em>tick √©</em> interceptado por um controlador "interessado" para process√°-lo.  Se a anima√ß√£o estiver conclu√≠da, o <em>ticker ser√°</em> "desativado"; caso contr√°rio, o <em>ticker</em> solicitar√° um <em>SchedulerBinding</em> para agendar um novo retorno de chamada.  E assim por diante ... </p><br><h1 id="polnaya-kartina">  Imagem completa </h1><br><p>  Agora aprendemos como o <em>Flutter</em> funciona: </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Por fim, retorne ao diagrama que mostra os diferentes tipos de elementos e considere a assinatura do <em>elemento</em> raiz: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Vemos o muito famoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">BuildContext</a> !  Mas o que √© isso? </p><br><p>  <strong>BuildContext</strong> √© uma interface que define v√°rios getters e m√©todos que podem ser implementados por um elemento.  <em>BuildContext √©</em> usado principalmente no m√©todo <code>build()</code> de <em>StatelessWidget</em> ou <em>State</em> for <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> nada mais √© do que o pr√≥prio <strong>elemento</strong> , que corresponde</em> <br><ul><li>  <em>widget sendo atualizado (dentro dos m√©todos de <code>build</code> ou <code>builder</code> )</em> </li><li>  <em>StatefulWidget associado a <strong>State</strong> em que voc√™ faz refer√™ncia √† vari√°vel de contexto.</em> </li></ul><br></blockquote><p>  Isso significa que a maioria dos desenvolvedores trabalha constantemente com elementos sem sequer saber sobre isso. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  Qual a utilidade de um BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> ‚Ä¶) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> ‚Äì  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    ‚Äì ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476018/">https://habr.com/ru/post/pt476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476000/index.html">Atualiza√ß√µes do ML.NET Model Builder</a></li>
<li><a href="../pt476002/index.html">Experi√™ncia em encontrar uma posi√ß√£o de estudante de doutorado na Alemanha</a></li>
<li><a href="../pt476004/index.html">Gerente de projetos - mito ou realidade? Ou por que √© necess√°rio no campo dos efeitos visuais?</a></li>
<li><a href="../pt476006/index.html">Mitos e lendas dos construtores de SOC, ou 3 conceitos errados sobre os centros de monitoramento e resposta a ataques cibern√©ticos</a></li>
<li><a href="../pt476008/index.html">MOSDROID Meetup: Conecte-se √† transmiss√£o</a></li>
<li><a href="../pt476022/index.html">Vue Storefront: aumentando o back-end</a></li>
<li><a href="../pt476024/index.html">Melhor arquitetura para MVP: mon√≥lito, SOA, microsservi√ßos ou sem servidor? .. Parte 1</a></li>
<li><a href="../pt476026/index.html">Cool Hacks de vida para trabalhar com WSL (Windows Subsystem for Linux)</a></li>
<li><a href="../pt476032/index.html">Brunner Elektronik - Do sistema CAD ao cockpit</a></li>
<li><a href="../pt476034/index.html">O mais indefeso √© o Falc√£o Peregrino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>