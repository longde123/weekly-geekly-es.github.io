<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåΩ üî© üñêüèΩ Criamos um jogo de plataforma port√°til no microcontrolador Cortex M0 + üéõÔ∏è üíÉüèø üôåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 (Links para o c√≥digo-fonte e o projeto KiCAD s√£o fornecidos no final do artigo.) 

 Embora tenhamos nascido na era dos 8 bits, nosso p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criamos um jogo de plataforma port√°til no microcontrolador Cortex M0 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br><h2>  1. Introdu√ß√£o </h2><br>  <em>(Links para o c√≥digo-fonte e o projeto KiCAD s√£o fornecidos no final do artigo.)</em> <br><br>  Embora tenhamos nascido na era dos 8 bits, nosso primeiro computador foi o Amiga 500. Esta √© uma √≥tima m√°quina de 16 bits com gr√°ficos e sons incr√≠veis, o que o torna ideal para jogos.  A plataforma se tornou um g√™nero de jogo muito popular neste computador.  Muitos deles eram muito coloridos e tinham rolagem de paralaxe muito suave.  Isso foi poss√≠vel gra√ßas a programadores talentosos que usaram engenhosamente os coprocessadores Amiga para aumentar o n√∫mero de cores da tela.  D√™ uma olhada no LionHeart, por exemplo! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>  <i>Cora√ß√£o de le√£o em Amiga.</i>  <i>Esta imagem est√°tica n√£o transmite a beleza dos gr√°ficos.</i> <br><br>  Desde os anos 90, a eletr√¥nica mudou muito e agora existem muitos microcontroladores pequenos que permitem criar coisas incr√≠veis. <br><br>  Sempre gostamos de jogos de plataforma e, hoje, por apenas alguns d√≥lares, voc√™ pode comprar o Raspberry Zero, instalar o Linux e, "muito f√°cil", escrever um jogo de plataforma colorido. <br><br>  Mas essa tarefa n√£o √© para n√≥s - n√£o queremos atirar pardais de um canh√£o! <br><br>  Queremos usar microcontroladores com mem√≥ria limitada, e n√£o um sistema poderoso em um chip com uma GPU integrada!  Em outras palavras, queremos dificuldades! <br><a name="habracut"></a><br>  A prop√≥sito, sobre as possibilidades do v√≠deo: algumas pessoas conseguem extrair todos os sucos do microcontrolador AVR em seus projetos (por exemplo, no projeto Uzebox ou Craft do desenvolvedor de lft).  No entanto, para conseguir isso, os microcontroladores AVR nos for√ßam a escrever em assembler, e mesmo que alguns jogos sejam muito bons, voc√™ encontrar√° s√©rias limita√ß√µes que n√£o permitem criar um jogo no estilo de 16 bits. <br><br>  Portanto, decidimos usar um microcontrolador / placa mais equilibrado, o que nos permite escrever c√≥digo completamente em C. <br><br>  Ele n√£o √© t√£o poderoso quanto o Arduino Due, mas n√£o t√£o fraco quanto o Arduino Uno.  Curiosamente, "Due" significa "dois" e "Uno" significa "um".  A Microsoft nos ensinou a contar corretamente (1, 2, 3, 95, 98, ME, 2000, XP, Vista, 7, 8, 10) e o Arduino tamb√©m seguiu esse caminho!  Vamos usar o Arduino Zero, que fica no meio entre 1 e 2! <br><br>  Sim, de acordo com o Arduino, 1 &lt;0 &lt;2. <br><br>  Em particular, n√£o estamos interessados ‚Äã‚Äãno pr√≥prio quadro, mas em sua s√©rie de processadores.  O Arduino Zero possui um microcontrolador da s√©rie ATSAMD21 com Cortex M0 + (48 MHz), mem√≥ria flash de 256 KB e RAM de 32 KB. <br><br>  Embora o Cortex M0 + de 48 MHz supere significativamente o desempenho do antigo MC68000 de 7 MHz, o Amiga 500 tinha 512 KB de RAM, sprites de hardware, um tabuleiro de jogo duplo integrado, Blitter (um mecanismo de transfer√™ncia de bloco de imagem baseado em DMA com um sistema de reconhecimento de colis√£o preciso com pixel) e transpar√™ncia) e Copper (um coprocessador raster que permite executar opera√ß√µes com registros com base na posi√ß√£o de varredura para criar muitos efeitos muito bonitos).  O SAMD21 n√£o possui todo esse hardware (com exce√ß√£o de um hardware bastante simples em compara√ß√£o com o Blitter DMA); portanto, muito ser√° renderizado programaticamente. <br><br>  Queremos alcan√ßar os seguintes par√¢metros: <br><br><ul><li>  Resolu√ß√£o 160 x 128 pixels em uma tela SPI de 1,8 polegadas. </li><li>  Gr√°ficos com 16 bits por pixel; </li><li>  A maior taxa de quadros.  Pelo menos 25 qps a 12 MHz SPI ou 40 qps a 24 MHz; </li><li>  campo de jogo duplo com rolagem de paralaxe; </li><li>  tudo est√° escrito em C. Nenhum c√≥digo assembler; </li><li>  Reconhecimento de colis√µes com precis√£o de pixels; </li><li>  sobreposi√ß√£o de tela. </li></ul><br>  Parece que alcan√ßar esses objetivos √© bastante dif√≠cil.  √â, especialmente se recusarmos o c√≥digo no asm! <br><br>  Por exemplo, com cores de 16 bits, um tamanho de tela de 160 √ó 128 pixels exigir√° 40 KB para o buffer de tela, mas temos apenas 32 KB de RAM!  E ainda precisamos de rolagem de paralaxe em um campo de jogo duplo e muito mais, com uma frequ√™ncia de pelo menos 25/40 fps! <br><br>  Mas nada √© imposs√≠vel para n√≥s, certo? <br><br>  Usamos truques e fun√ß√µes internas do ATSAMD21!  Como "hardware", levamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uChip</a> , que pode ser comprado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Itaca Store</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>  <i>uChip: o cora√ß√£o do nosso projeto!</i> <br><br>  Tem as mesmas caracter√≠sticas do Arduino Zero, mas √© muito menor e tamb√©m mais barato que o Arduino Zero original (sim, voc√™ pode comprar um Arduino Zero falso por US $ 10 no AliExpress ... mas queremos aproveitar o original).  Isso nos permitir√° criar um pequeno console port√°til.  Voc√™ pode adaptar esse projeto para o Arduino Zero quase sem esfor√ßo, apenas o resultado ter√° um tamanho bastante complicado. <br><br>  Tamb√©m criamos uma pequena placa de teste que implementa um console port√°til para os pobres.  Detalhes abaixo! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br>  N√£o usaremos a estrutura do Arduino.  N√£o √© adequado quando se trata de otimizar e gerenciar equipamentos.  (E n√£o vamos falar sobre o IDE!) <br><br>  Neste artigo, descreveremos como chegamos √† vers√£o final do jogo, descreveremos todas as otimiza√ß√µes e crit√©rios usados.  O jogo em si ainda n√£o est√° completo, n√£o possui som, n√≠veis, etc.  No entanto, pode ser usado como ponto de partida para muitos tipos diferentes de jogos! <br><br>  Al√©m disso, existem muito mais op√ß√µes de otimiza√ß√£o, mesmo sem o assembler! <br><br>  Ent√£o, vamos come√ßar nossa jornada! <br><br><h2>  Dificuldades </h2><br>  De fato, o projeto tem dois aspectos complexos: tempos e mem√≥ria (RAM e armazenamento). <br><br><h3>  A mem√≥ria </h3><br>  Vamos come√ßar com a mem√≥ria.  Primeiro, em vez de armazenar uma imagem de grande n√≠vel, usamos blocos.  De fato, se voc√™ analisar cuidadosamente a maioria das plataformas, ver√° que elas s√£o criadas a partir de um pequeno n√∫mero de elementos gr√°ficos (blocos) que s√£o repetidos v√°rias vezes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>  <i>Turrican 2 em Amiga.</i>  <i>Um dos melhores jogos de plataforma de todos os tempos.</i>  <i>Voc√™ pode ver facilmente as pe√ßas nele!</i> <br><br>  O mundo / n√≠vel parece diverso gra√ßas a v√°rias combina√ß√µes de pe√ßas.  Isso economiza muita mem√≥ria na unidade, mas n√£o resolve o problema de um enorme buffer de quadro. <br><br>  O segundo truque que usamos √© poss√≠vel devido ao grande poder computacional do uC e √† presen√ßa de DMA!  Em vez de armazenar todos os dados do quadro na RAM (e por que isso √© necess√°rio?) Criaremos uma cena em todos os quadros do zero.  Em particular, continuaremos a usar buffers, mas de forma que eles se encaixem em um bloco horizontal de gr√°ficos de dados com uma altura de 16 pixels. <br><br><h3>  Tempos - CPU </h3><br>  Quando um engenheiro precisa criar algo, ele primeiro verifica se isso √© poss√≠vel.  √â claro que, no in√≠cio, realizamos esse teste! <br><br>  Portanto, precisamos de pelo menos 25 qps em uma tela de 160 √ó 128 pixels.  Isso √© 512.000 pixels / s.  Como o microcontrolador opera com uma frequ√™ncia de 48 MHz, temos pelo menos 93 ciclos de clock por pixel.  Esse valor cai para 58 ciclos se apontarmos para 40 fps. <br><br>  De fato, nosso microcontrolador √© capaz de processar at√© 2 pixels por vez, porque cada pixel ocupa 16 bits e o ATSAMD21 possui um barramento interno de 32 bits, ou seja, o desempenho ser√° ainda melhor! <br><br>  Um valor de 93 ciclos de rel√≥gio nos diz que a tarefa √© completamente vi√°vel!  De fato, podemos concluir que a CPU sozinha pode lidar com todas as tarefas de renderiza√ß√£o sem DMA.  Provavelmente, isso √© verdade, especialmente quando se trabalha com assembler.  No entanto, o c√≥digo ser√° muito dif√≠cil de manipular.  E em C tem que ser muito otimizado!  Na verdade, o Cortex M0 + n√£o √© t√£o amig√°vel para C quanto o Cortex M3 e n√£o possui muitas instru√ß√µes (nem carrega / salva com subsequente / preliminar incremento / decr√©scimo!), Que deve ser implementado com duas ou mais instru√ß√µes simples. <br><br>  Vamos ver o que precisamos fazer para desenhar dois campos de jogo (supondo que j√° conhe√ßamos as coordenadas xey, etc.). <br><br><ul><li>  Calcule a localiza√ß√£o do pixel em primeiro plano na mem√≥ria flash. </li><li>  Obtenha o valor do pixel. </li><li>  Se for transparente, calcule a posi√ß√£o do pixel de fundo no flash. </li><li>  Obtenha o valor do pixel. </li><li>  Calcule o local de destino. </li><li>  Salve o pixel no buffer. </li></ul><br>  Al√©m disso, para cada sprite que possa entrar no buffer, as seguintes opera√ß√µes devem ser executadas: <br><br><ul><li>  Calcule a posi√ß√£o de um pixel sprite na mem√≥ria flash. </li><li>  Obtendo o valor do pixel. </li><li>  Se n√£o for transparente, calcule o local do buffer de destino. </li><li>  Salvando um pixel no buffer. </li></ul><br>  Todas essas opera√ß√µes n√£o s√£o implementadas n√£o apenas como uma √∫nica instru√ß√£o ASM, mas cada instru√ß√£o ASM requer dois ciclos ao acessar a RAM / mem√≥ria flash. <br><br>  Al√©m disso, ainda n√£o temos l√≥gica de jogo (que, felizmente, leva uma pequena quantidade de tempo, porque √© calculada uma vez por quadro), reconhecimento de colis√£o, processamento de buffer e instru√ß√µes necess√°rias para o envio de dados via SPI. <br><br>  Por exemplo, aqui est√° o pseudoc√≥digo do que temos que fazer (por enquanto, assumimos que o jogo n√£o tem rolagem e o campo de jogo tem um fundo de cor constante!) Somente para o primeiro plano. <br><br>  Deixe cameraY e cameraX serem as coordenadas do canto superior esquerdo da tela no mundo do jogo. <br><br>  Deixe xTilepos e yTilepos serem a posi√ß√£o do bloco atual no mapa. <br><br><pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is a rightward shift of 4 bits. yTilepos = cameraY / 16; destBufferAddress = &amp;buffer[0][0]; for tile = 0...9 nTile = gameMap[yTilepos][xTilepos]; tileDataAddress = &amp;tileData[nTile]; xTilepos = xTilepos + 1; for y = 0‚Ä¶15 for x = 0‚Ä¶15 pixel = *tileDataAddress; tileDataAddress = tileDataAddress + 1; *destBufferAddress = pixel; destBufferAddress = destBufferAddress + 1; next destBufferAddress = destBufferAddress + 144; // point to next row next destBufferAddress = destBufferAddress ‚Äì ( 160 * 16 - 16); // now point to the position where the next tile will be saved. next</span></span></code> </pre> <br>  O n√∫mero de instru√ß√µes para 2560 pixels (160 x 16) √© aproximadamente 16k, ou seja,  6 por pixel.  De fato, voc√™ pode desenhar dois pixels por vez.  Isso reduz pela metade o n√∫mero real de instru√ß√µes por pixel, ou seja, o n√∫mero de instru√ß√µes de alto n√≠vel por pixel √© de aproximadamente 3. No entanto, algumas dessas instru√ß√µes de alto n√≠vel ser√£o divididas em duas ou mais instru√ß√µes de montagem ou requerem pelo menos dois ciclos para serem conclu√≠das porque eles acessam para a mem√≥ria.  Al√©m disso, n√£o consideramos redefinir o pipeline da CPU devido a saltos e estados de espera pela mem√≥ria flash.  Sim, ainda estamos longe dos ciclos 58-93 √† nossa disposi√ß√£o, mas ainda precisamos levar em considera√ß√£o o contexto do campo de jogo e dos sprites. <br><br>  Embora vejamos que o problema pode ser resolvido em uma CPU, o DMA ser√° muito mais r√°pido.  O acesso direto √† mem√≥ria deixa ainda mais espa√ßo para sprites de tela ou melhores efeitos gr√°ficos (por exemplo, podemos implementar a mistura alfa). <br><br>  Veremos que, para configurar o DMA para cada bloco, precisamos de instru√ß√µes inferiores a 100 C, ou seja, inferiores a 0,5 por pixel!  Obviamente, o DMA ainda precisar√° executar o mesmo n√∫mero de transfer√™ncias na mem√≥ria, mas o incremento e a transmiss√£o de endere√ßos s√£o realizados sem a interven√ß√£o da CPU, o que pode fazer outra coisa (por exemplo, calcular e renderizar sprites). <br><br>  Usando o temporizador SysTick, descobrimos que o tempo necess√°rio para preparar o DMA para todo o bloco e depois para completar o DMA √© de aproximadamente 12k ciclos de clock.  Nota: ciclos de rel√≥gio!  Instru√ß√µes n√£o de alto n√≠vel!  O n√∫mero de ciclos √© bastante alto para apenas 2560 pixels, ou seja,  1.280 palavras de 32 bits.  De fato, temos cerca de 10 ciclos por palavra de 32 bits.  No entanto, √© necess√°rio considerar o tempo necess√°rio para preparar o DMA, bem como o tempo necess√°rio para o DMA carregar descritores de transfer√™ncia da RAM (que cont√™m essencialmente ponteiros e o n√∫mero de bytes transferidos).  Al√©m disso, sempre h√° algum tipo de altera√ß√£o no barramento de mem√≥ria (para que a CPU n√£o fique ociosa sem dados) e a mem√≥ria flash requer pelo menos um estado de espera. <br><br><h3>  Hor√°rios - SPI </h3><br>  Outro gargalo √© o SPI.  12 MHz √© suficiente para 25 qps?  A resposta √© sim: 12 MHz corresponde a cerca de 36 quadros por segundo.  Se usarmos 24 MHz, o limite dobrar√°! <br><br>  A prop√≥sito, as especifica√ß√µes da tela e do microcontrolador dizem que a velocidade m√°xima do SPI √© respectivamente 15 e 12 MHz.  Testamos e garantimos que ele possa ser aumentado para 24 MHz sem problemas, pelo menos na "dire√ß√£o" necess√°ria (o microcontrolador grava no visor). <br><br>  Usaremos o popular monitor SPI de 1,8 polegadas.  Garantimos que o ILI9163 e o ST7735 operem normalmente com uma frequ√™ncia de 12 MHz (pelo menos com 12 MHz. Verifica-se que o ST7735 opera com uma frequ√™ncia de at√© 24 MHz).  Se voc√™ deseja usar a mesma tela do tutorial ‚ÄúComo reproduzir v√≠deos no Arduino Uno‚Äù, recomendamos que voc√™ a modifique caso queira adicionar suporte SD no futuro.  Estamos usando a vers√£o do cart√£o SD para ter muito espa√ßo para outros elementos, como som ou n√≠veis adicionais. <br><br><h2>  Gr√°ficos </h2><br>  Como j√° mencionado, o jogo usa pe√ßas.  Cada n√≠vel consistir√° em blocos repetidos de acordo com a tabela, que chamamos de "gameMap".  Qual ser√° o tamanho de cada pe√ßa?  O tamanho de cada bloco afeta muito o consumo de mem√≥ria, detalhes e flexibilidade (e, como veremos mais adiante, tamb√©m a velocidade).  Ladrilhos muito grandes exigir√£o a cria√ß√£o de um novo ladrilho para cada pequena varia√ß√£o necess√°ria.  Isso ocupar√° muito espa√ßo na unidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>  <i>Dois blocos de 32 √ó 32 pixels de tamanho (esquerdo e central), que diferem em uma pequena parte (a parte superior direita do pixel √© 16 √ó 16).</i>  <i>Portanto, precisamos armazenar dois blocos diferentes com um tamanho de 32 √ó 32 pixels.</i>  <i>Se usarmos um bloco de 16 √ó 16 pixels (√† direita), precisamos armazenar apenas dois blocos de 16 √ó 16 (um bloco completamente branco e um bloco √† direita).</i>  <i>No entanto, ao usar blocos 16 √ó 16, obtemos 4 elementos do mapa.</i> <br><br>  No entanto, s√£o necess√°rios menos blocos por tela, o que aumenta a velocidade (veja abaixo) e reduz o tamanho do mapa (ou seja, o n√∫mero de linhas e colunas na tabela) de cada n√≠vel.  Ladrilhos muito pequenos criam o problema oposto.  As tabelas de mapas est√£o ficando maiores e a velocidade est√° ficando mais lenta.  Obviamente, n√£o tomaremos decis√µes est√∫pidas.  por exemplo, selecione blocos com um tamanho de 17 √ó 31 pixels.  Nosso amigo fiel - graus dois!  O tamanho 16 √ó 16 √© quase a ‚Äúregra de ouro‚Äù, √© usado em muitos jogos, e n√≥s o escolhemos! <br><br>  Nossa tela tem um tamanho de 160 √ó 128.  Em outras palavras, precisamos de 10 √ó 8 blocos por tela, ou seja,  80 entradas na tabela.  Para um grande n√≠vel de telas 10 √ó 10 (ou telas 100 √ó 1), apenas 8.000 registros ser√£o necess√°rios (16 KB se usarmos 16 bits para grava√ß√£o. Mais tarde, mostraremos por que decidimos escolher 16 bits para grava√ß√£o). <br><br>  Compare isso com a quantidade de mem√≥ria que provavelmente ser√° ocupada por uma foto grande em toda a tela: 40 KB * 100 = 4 MB!  Isso √© loucura! <br><br>  Vamos falar sobre o sistema de renderiza√ß√£o. <br><br>  Cada quadro deve conter (em ordem de desenho): <br><br><ul><li>  gr√°ficos de fundo (campo de jogo de volta) </li><li>  o pr√≥prio gr√°fico de n√≠vel (primeiro plano). </li><li>  sprites </li><li>  sobreposi√ß√£o de texto / parte superior. </li></ul><br>  Em particular, executaremos sequencialmente as seguintes opera√ß√µes: <br><br><ol><li>  Desenho de fundo + primeiro plano (blocos) </li><li>  desenho de pe√ßas transl√∫cidas + sprites + sobreposi√ß√£o superior </li><li>  enviando dados por SPI. </li></ol><br>  Ladrilhos de fundo e totalmente opacos ser√£o desenhados pelo DMA.  Um bloco totalmente opaco √© um bloco no qual n√£o h√° pixels transparentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>  <i>Ladrilho parcialmente transparente (esquerda) e completamente opaco (direita).</i>  <i>Em um bloco parcialmente transparente, alguns pixels (no canto inferior esquerdo) s√£o transparentes e, portanto, um plano de fundo √© vis√≠vel nessa √°rea.</i> <br><br>  Ladrilhos, sprites e sobreposi√ß√µes parcialmente transparentes n√£o podem ser renderizados com efici√™ncia pelo DMA.  De fato, o sistema DMA do chip ATSAMD21 simplesmente copia os dados e, ao contr√°rio do Blitter do computador Amiga, ele n√£o verifica a transpar√™ncia (definida pelo valor da cor).  Todos os elementos parcialmente transparentes s√£o desenhados pela CPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br>  Os dados s√£o ent√£o transmitidos para o display usando DMA. <br><br><h3>  Criando um pipeline </h3><br>  Como voc√™ pode ver, se executarmos essas opera√ß√µes sequencialmente em um buffer, levar√° muito tempo.  De fato, enquanto o DMA estiver em execu√ß√£o, a CPU n√£o estar√° ocupada, exceto aguardando a conclus√£o do DMA!  Essa √© uma maneira ruim de implementar um mecanismo gr√°fico.  Al√©m disso, quando o DMA envia dados para um dispositivo SPI, ele n√£o usa toda a largura de banda.  De fato, mesmo quando o SPI opera com uma frequ√™ncia de 24 MHz, os dados s√£o transmitidos apenas com uma frequ√™ncia de 3 MHz, o que √© bastante pequeno.  Em outras palavras, o DMA n√£o est√° acostumado a todo o seu potencial: o DMA pode executar outras tarefas sem realmente perder o desempenho. <br><br>  Por isso, implementamos o pipeline, que √© o desenvolvimento da id√©ia de buffer duplo (usamos tr√™s buffers!).  Obviamente, no final, as opera√ß√µes s√£o sempre executadas seq√ºencialmente.  Mas a CPU e o DMA simultaneamente executam tarefas diferentes, sem (especialmente) se afetando. <br><br>  Aqui est√° o que acontece ao mesmo tempo: <br><br><ul><li>  O buffer √© usado para desenhar dados de segundo plano usando o canal DMA 1; </li><li>  Em outro buffer (anteriormente preenchido com dados de segundo plano), a CPU desenha sprites e blocos parcialmente transparentes; </li><li>  Em seguida, outro buffer (que cont√©m o bloco de dados horizontal completo) √© usado para enviar dados para o display via SPI usando o canal DMA 0. Obviamente, o buffer usado para enviar dados via SPI foi preenchido anteriormente com sprites enquanto o SPI enviava o bloco anterior e outro buffer preenchido com azulejos. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br><h3>  DMA </h3><br>  O sistema DMA do chip ATSAMD21 n√£o √© compar√°vel ao Blitter, mas, no entanto, possui seus pr√≥prios recursos √∫teis.  Gra√ßas ao DMA, podemos fornecer uma taxa de atualiza√ß√£o muito alta, apesar de ter um campo de jogo duplo. <br><br>  A configura√ß√£o da transfer√™ncia do DMA √© armazenada na RAM, em ‚ÄúDescritores do DMA‚Äù, informando ao DMA como e onde deve ser realizada a transfer√™ncia atual.  Esses descritores podem ser unidos: se houver uma conex√£o (ou seja, n√£o houver ponteiro nulo), depois que a transfer√™ncia for conclu√≠da, o DMA receber√° automaticamente o pr√≥ximo descritor.  Com o uso de v√°rios descritores, o DMA pode executar "transfer√™ncias complexas", que s√£o √∫teis quando, por exemplo, o buffer de origem √© uma sequ√™ncia de segmentos n√£o cont√≠guos de bytes cont√≠guos.  No entanto, leva tempo para obter e escrever descritores, porque voc√™ precisa salvar / carregar 16 bytes de descritor da RAM. <br><br>  O DMA pode trabalhar com dados de diferentes comprimentos: bytes, meias palavras (16 bits) e palavras (32 bits).  Na especifica√ß√£o, esse comprimento √© chamado de "tamanho da batida".  Para o SPI, somos for√ßados a usar a transfer√™ncia de bytes (embora a especifica√ß√£o REVD atual afirme que os chips ATSAMD21 SERCOM t√™m FIFO, que, de acordo com a Microchip, podem aceitar dados de 32 bits, de fato, parece que eles n√£o t√™m FIFO. A especifica√ß√£o REVD tamb√©m menciona O registro SERCOM CTRLC, que est√° ausente nos arquivos de cabe√ßalho e na se√ß√£o de descri√ß√£o do registro. Felizmente, ao contr√°rio do AVR, o ATSAMD21 pelo menos possui um registro de dados de transmiss√£o em buffer, portanto, n√£o haver√° pausas na transmiss√£o!).  Para desenhar pe√ßas, √© claro que usamos 32 bits.  Isso permite que voc√™ copie dois pixels por batida.  O chip ATSAMD21 DMA tamb√©m permite que cada batida de origem aumente o endere√ßo de origem ou destino em um n√∫mero fixo de tamanhos de batida. <br><br>  Esses dois aspectos s√£o muito importantes e determinam a maneira como desenhamos pe√ßas. <br><br>  Primeiro, se renderizamos um pixel por batida (16 bits), reduziremos pela metade a taxa de transfer√™ncia do nosso sistema.  N√£o podemos recusar largura de banda completa! <br><br>  No entanto, se desenharmos dois pixels por batida, o campo do jogo poder√° rolar apenas um n√∫mero par de pixels, o que causar√° movimentos suaves.  Para lidar com isso, voc√™ pode usar um buffer que seja dois ou mais pixels maior.  Ao enviar dados para a tela, usaremos o deslocamento correto (0 ou 1 pixel), dependendo se precisamos mover a ‚Äúc√¢mera‚Äù por um n√∫mero par ou √≠mpar de pixels. <br><br>  No entanto, por uma quest√£o de simplicidade, reservamos espa√ßo para 11 blocos completos (160 + 16 pixels) e n√£o para 160 + 2 pixels.  Essa abordagem tem uma grande vantagem: n√£o precisamos calcular e atualizar o endere√ßo do destinat√°rio de cada descritor de DMA (isso exigiria v√°rias instru√ß√µes, o que poderia resultar em muitos c√°lculos por bloco).  Obviamente, desenharemos apenas o n√∫mero m√≠nimo de pixels, ou seja, n√£o mais que 162. Sim, no final, gastaremos um pouco de mem√≥ria extra (levando em considera√ß√£o tr√™s buffers, s√£o cerca de 1500 bytes) para velocidade e simplicidade.  Voc√™ tamb√©m pode executar outras otimiza√ß√µes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br>  Todos os buffers de bloco de 16 linhas (sem descritores) s√£o vis√≠veis nesta anima√ß√£o GIF.  √Ä direita est√° o que √© realmente exibido.  Os primeiros 32 quadros s√£o mostrados em GIF, nos quais movemos 1 pixel para a direita em cada quadro.  A √°rea preta do buffer √© a parte que n√£o √© atualizada e seu conte√∫do simplesmente permanece das opera√ß√µes anteriores.  Quando a tela rola um n√∫mero √≠mpar de quadros, uma √°rea de 162 pixels de largura √© desenhada no buffer.  No entanto, a primeira e a √∫ltima coluna delas (destacadas na anima√ß√£o) s√£o descartadas.  Quando o valor de rolagem √© m√∫ltiplo de 16 pixels, as opera√ß√µes de desenho no buffer come√ßam na primeira coluna (x = 0). <br><br>  E a rolagem vertical? <br><br>  N√≥s vamos lidar com isso depois que mostrarmos um m√©todo de armazenamento de blocos na mem√≥ria flash. <br><br><h3>  Como armazenar pe√ßas </h3><br>  Uma abordagem ing√™nua (que nos serviria apenas se renderiz√°ssemos atrav√©s da CPU) seria armazenar os blocos na mem√≥ria flash como uma sequ√™ncia de cores de pixels.  O primeiro pixel da primeira linha, a segunda e assim por diante, at√© a d√©cima sexta.  Em seguida, salvamos o primeiro pixel da segunda linha, a segunda e assim por diante. <br><br>  Por que essa decis√£o √© ing√™nua?  Como nesse caso, o DMA pode renderizar apenas 16 pixels por descritor de DMA!  Portanto, precisaremos de 16 descritores, cada um dos quais precisa de 4 + 4 opera√ß√µes de acesso √† mem√≥ria (ou seja, para transferir 32 bytes - 8 opera√ß√µes de leitura na mem√≥ria + 8 opera√ß√µes de grava√ß√£o na mem√≥ria - o DMA deve executar mais 4 leituras + 4 grava√ß√µes).  Isso √© bastante ineficiente! <br><br>  De fato, para cada descritor, o DMA pode incrementar apenas os endere√ßos de origem e destino em um n√∫mero fixo de palavras.  Ap√≥s copiar a primeira linha do bloco para o buffer, o endere√ßo do destinat√°rio n√£o deve ser aumentado em 1 palavra, mas em um valor que aponte para a pr√≥xima linha do buffer.  Isso n√£o √© poss√≠vel porque cada descritor de transmiss√£o indica apenas o incremento da transmiss√£o por batida, que n√£o pode ser alterado. <br><br>  Ser√° muito mais inteligente enviar os dois primeiros pixels de cada linha do bloco sequencialmente, ou seja, pixels 0 e 1 da linha 0, pixels 0 e 1 da linha 1, etc., para os pixels 0 e 1 da linha 15. Em seguida, enviamos os pixels 2 e 3 da linha 0 e assim por diante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>  <i>Como um bloco √© armazenado?</i> <br><br>  Na figura acima, cada n√∫mero indica a ordem em que o pixel de 16 bits √© armazenado na matriz de blocos. <br><br>  Isso pode ser feito com um descritor, mas precisamos de duas coisas: <br><br><ul><li>  Os ladrilhos devem ser armazenados para que, ao incrementar a fonte em uma palavra, sempre apontemos para as posi√ß√µes de pixel corretas.  Em outras palavras, se (r, c) √© um pixel na linha r e na coluna c, precisamos salvar os pixels (0,0) (0,1) (1,0) (1,1) (2,0) sequencialmente (2,1) ... (15,0) (15,1) (0,2) (0,3) (1,2) (1,3) ... </li><li>  O buffer deve ter 256 pixels de largura (n√£o 160) </li></ul><br>  O primeiro objetivo √© muito f√°cil de alcan√ßar: basta alterar a ordem dos dados, voc√™ pode fazer isso ao exportar gr√°ficos para um arquivo c (veja a imagem acima). <br><br>  O segundo problema pode ser resolvido porque o DMA permite aumentar o endere√ßo do destinat√°rio ap√≥s cada batida em 512 bytes.  Isso tem duas consequ√™ncias: <br><br><ul><li>  N√£o podemos enviar dados usando um √∫nico descritor sobre um bloco SPI.  Este n√£o √© um problema muito s√©rio, porque no final lemos um descritor atrav√©s de 160 pixels.  O impacto no desempenho ser√° m√≠nimo. </li><li>  O bloco deve ter um tamanho de 256 * 2 * 16 bytes = 8 KB e haver√° muito "espa√ßo n√£o utilizado" nele. </li></ul><br>  No entanto, esse espa√ßo ainda pode ser usado, por exemplo, para descritores. <br><br>  De fato, cada descritor tem 16 bytes de tamanho.  Precisamos de pelo menos 10 * 8 (e na verdade 11 * 8!) Descritores para blocos e 16 descritores para SPI. <br><br>  Por isso, quanto mais pe√ßas, maior a velocidade.  De fato, se us√°ssemos, por exemplo, um bloco de 32 x 32, precisar√≠amos de menos descritores por tela (320 em vez de 640).  Isso reduziria o desperd√≠cio de recursos. <br><br><h3>  Exibir bloco de dados </h3><br>  O buffer do bloco, os descritores e outros dados s√£o armazenados em um tipo de estrutura, que chamamos de displayBlock_t. <br><br>  displayBlock √© uma matriz de 16 elementos displayLineData_t.  Os dados do DisplayLine cont√™m 176 pixels mais 80 palavras.  Nessas 80 palavras, armazenamos descritores de exibi√ß√£o ou outros dados √∫teis de exibi√ß√£o (usando uni√£o). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br>  Como temos 16 linhas, cada bloco na posi√ß√£o X usa os 8 primeiros descritores de DMA (0 a 7) das linhas X. Como temos um m√°ximo de 11 blocos (a linha de exibi√ß√£o tem 176 pixels de largura), os blocos usam apenas os primeiros descritores de DMA 11 linhas de dados.  Os descritores 8 a 9 de todas as linhas e os descritores 0 a 9 das linhas 11 a 15 s√£o gratuitos. <br><br>  Desses, os descritores 8 e 9 das linhas 0..7 ser√£o utilizados para o SPI. <br><br>  Os descritores 0..9 linhas 11 a 15 (at√© 50 descritores, embora usaremos apenas 48 deles) ser√£o usados ‚Äã‚Äãpara o campo de jogo em segundo plano. <br><br>  A figura abaixo mostra sua estrutura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br><h3>  Campo de jogo em segundo plano </h3><br>  O campo de jogo em segundo plano √© tratado de maneira diferente.  Primeiro, se precisarmos de rolagem suave, teremos que retornar ao formato de dois pixels, porque o primeiro plano e o plano de fundo ser√£o rolados em velocidades diferentes.  Portanto, a batida ser√° no meio.  Embora isso seja uma desvantagem em termos de velocidade, essa abordagem facilita a integra√ß√£o.  Temos apenas um pequeno n√∫mero de descritores, portanto, pequenos blocos n√£o podem ser usados.  Al√©m disso, para simplificar o trabalho e adicionar rapidamente paralaxe, usaremos longos "setores". <br><br>  O plano de fundo √© desenhado apenas se houver pelo menos um pixel parcialmente transparente.  Isso significa que, se houver apenas um bloco transparente, o plano de fundo ser√° desenhado.  Obviamente, isso √© um desperd√≠cio de largura de banda, mas simplifica tudo. <br><br>  Compare o fundo e os campos de jogo da frente: <br><br><ul><li>  Em segundo plano, s√£o usados ‚Äã‚Äãsetores, que s√£o blocos longos armazenados de maneira "ing√™nua". </li><li>  O plano de fundo tem seu pr√≥prio mapa, mas horizontalmente ele se repete.  Gra√ßas a isso, menos mem√≥ria √© usada. </li><li>  O plano de fundo possui paralaxe para cada setor. </li></ul><br><h3>  Campo de jogo dianteiro </h3><br>  Como foi dito, em cada bloco temos at√© 11 pe√ßas (10 pe√ßas completas ou 9 pe√ßas completas e 2 limas parciais).  Cada um desses blocos, se n√£o estiver marcado como transparente, √© desenhado DMA.  Se n√£o for completamente opaco, ser√° adicionado √† lista, que ser√° analisada posteriormente, ao renderizar sprites. <br><br><h3>  Conectamos dois campos de jogo </h3><br>  Os descritores do campo de jogo em segundo plano (que sempre s√£o calculados) e do campo de jogo da frente formam uma lista vinculada muito longa.  A primeira parte desenha um campo de jogo em segundo plano.  A segunda parte desenha blocos sobre o fundo.  O comprimento da segunda parte pode ser vari√°vel, porque os descritores de DMA de blocos parcialmente transparentes s√£o exclu√≠dos da lista.  Se o bloco contiver apenas blocos opacos, o DMA ser√° configurado da seguinte maneira.  para iniciar diretamente a partir do primeiro descritor do primeiro bloco. <br><br><h3>  Sprites e azulejos com transpar√™ncia </h3><br>  Azulejos com transpar√™ncia e sprites s√£o processados ‚Äã‚Äãquase da mesma forma.  A an√°lise de pixel lado a lado / sprite √© realizada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se for preto, ser√° transparente e, portanto, o bloco de plano de fundo n√£o ser√° alterado. </font><font style="vertical-align: inherit;">Se n√£o for preto, o pixel do plano de fundo ser√° substitu√≠do por um pixel de sprite / lado a lado.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rolagem vertical </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar com rolagem horizontal, desenhamos at√© 11 blocos, mesmo que ao desenhar 11 blocos, o primeiro e o √∫ltimo sejam apenas parcialmente desenhados. </font><font style="vertical-align: inherit;">Essa renderiza√ß√£o parcial √© poss√≠vel devido ao fato de que cada descritor desenha duas colunas do bloco, para que possamos definir facilmente o in√≠cio e o fim da lista vinculada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar com rolagem vertical, precisamos calcular o registro do receptor e o volume de transmiss√£o. </font><font style="vertical-align: inherit;">Eles devem ser definidos v√°rias vezes por quadro. </font><font style="vertical-align: inherit;">Para evitar esse barulho, podemos simplesmente desenhar at√© 9 blocos completos por quadro (8 se a rolagem for um m√∫ltiplo de 16).</font></font><br><br><h2>  Equipamento </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como dissemos, o cora√ß√£o do sistema √© o uChip. </font><font style="vertical-align: inherit;">E o resto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um diagrama! </font><font style="vertical-align: inherit;">Alguns aspectos merecem ser mencionados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaves </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para otimizar o uso de E / S, usamos um pequeno truque. </font><font style="vertical-align: inherit;">Teremos 4 barramentos sensores L1-L4 e um fio LC comum. </font><font style="vertical-align: inherit;">1 e 0. s√£o aplicados alternadamente ao fio comum, de modo que os barramentos dos sensores ser√£o alternadamente puxados para baixo ou para cima com a ajuda de resistores de tra√ß√£o internos. </font><font style="vertical-align: inherit;">Duas chaves s√£o conectadas entre cada um dos barramentos principais e um barramento comum. </font><font style="vertical-align: inherit;">Um diodo √© inserido em s√©rie com essas duas teclas. </font><font style="vertical-align: inherit;">Cada um desses diodos √© alternado na dire√ß√£o oposta, para que cada vez que apenas uma tecla seja "lida".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como n√£o existe um controlador de teclado interno (e nenhum controlador de teclado interno usa esse m√©todo interessante), oito teclas s√£o pesquisadas rapidamente no in√≠cio de cada quadro. Como as entradas devem ser puxadas para cima e para baixo, n√£o podemos (e n√£o queremos) usar resistores externos; portanto, precisamos usar resistores integrados, que podem ter uma resist√™ncia bastante alta (60 kOhm). Isso significa que quando o barramento comum muda de estado e os barramentos de dados alteram seu estado de ativa√ß√£o / desativa√ß√£o, √© necess√°rio inserir algum atraso para que o resistor de ativa√ß√£o / desativa√ß√£o interno altere o contrato e defina a capacit√¢ncia perdida para o n√≠vel desejado. Mas n√£o queremos esperar! Portanto, colocamos o barramento comum em um estado de alta imped√¢ncia (para que n√£o haja discord√¢ncia) e primeiro alteramos os barramentos do sensor para os valores l√≥gicos 1 ou 0,configurando-os temporariamente como sa√≠da. Mais tarde, eles s√£o configurados como entrada puxando para cima ou para baixo. Como a resist√™ncia de sa√≠da √© da ordem de dezenas de Ohms, o estado muda em alguns nanossegundos, ou seja, quando o barramento do sensor retorna √† entrada, ele j√° estar√° no estado desejado. Depois disso, o barramento comum muda para a sa√≠da com a polaridade oposta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso melhora muito a velocidade da digitaliza√ß√£o e elimina a necessidade de n√£o atrasos / instru√ß√µes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conex√£o SPI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectamos o SD e a tela para que eles se comuniquem sem transferir dados para o ATSAMD21. </font><font style="vertical-align: inherit;">Isso pode ser √∫til se voc√™ quiser reproduzir o v√≠deo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os resistores que conectam o MISO e o MOSI devem estar baixos. </font><font style="vertical-align: inherit;">Se eles forem muito grandes, o SPI n√£o funcionar√°, porque o sinal ser√° muito fraco.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otimiza√ß√£o e desenvolvimento adicional </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dos maiores problemas √© o uso de RAM. Tr√™s blocos ocupam 8 KB cada, deixando apenas 8 KB por pilha e outras vari√°veis. No momento, temos apenas 1,3 KB de RAM livre + 4 KB de pilha (4 KB por pilha - isso √© muito, talvez reduzamos). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, voc√™ pode usar blocos com uma altura de n√£o 16, mas 8 pixels. Isso aumentar√° o desperd√≠cio de recursos nos descritores de DMA, mas quase reduzir√° pela metade a quantidade de mem√≥ria ocupada pelo buffer do bloco (observe que o n√∫mero de descritores n√£o ser√° alterado se continuarmos a usar blocos 16 √ó 16, portanto, teremos que alterar a estrutura do bloco). Isso pode liberar aproximadamente 7,5 KB de RAM, o que ser√° muito √∫til para implementar fun√ß√µes como uma placa modific√°vel com segredos ou adicionar som (embora o som possa ser adicionado mesmo com 1 KB de RAM).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro problema √© o sprite, mas essa modifica√ß√£o √© muito mais simples de executar e voc√™ s√≥ precisa da fun√ß√£o createNextFrameScene (). De fato, estamos criando na RAM uma enorme variedade com o estado de todos os sprites. Em seguida, para cada sprite, calculamos se sua posi√ß√£o est√° dentro da √°rea da tela e, em seguida, a animamos e a adicionamos √† lista de renderiza√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez disso, voc√™ pode executar a otimiza√ß√£o. Por exemplo, no gameMap, voc√™ pode armazenar n√£o apenas o valor do bloco, mas tamb√©m um sinalizador indicando a transpar√™ncia do bloco, definido no editor. Isso nos permitir√° verificar rapidamente se o bloco deve ser renderizado: DMA ou CPU. Por isso, usamos registros de 16 bits para o cart√£o lado a lado. Se assumirmos que temos um conjunto de 256 blocos (no momento, temos menos de 128 blocos, mas h√° espa√ßo suficiente na mem√≥ria flash para adicionar novos), existem 7 bits livres que podem ser usados ‚Äã‚Äãpara outros fins. Tr√™s desses sete bits podem ser usados ‚Äã‚Äãpara indicar se um sprite / objeto est√° sendo armazenado.</font></font> Por exemplo: <br><br> <code>0b000 =    <br> 0b001 =  <br> 0b010 =  <br> 0b011 =  <br> 0b100 =  <br> 0b101 =  <br> 0b110 =  <br> 0b111 =    , ,   .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois, voc√™ pode criar uma tabela de bits na RAM, na qual cada bit significa se (por exemplo, um inimigo) √© detectado / se (por exemplo, um b√¥nus) √© captado / se um determinado objeto √© ativado (alternar). </font><font style="vertical-align: inherit;">Em um n√≠vel de telas 10 √ó 10, isso exigir√° 8000 bits, ou seja, </font><font style="vertical-align: inherit;">1 KB de RAM. </font><font style="vertical-align: inherit;">O bit √© redefinido quando um inimigo √© detectado ou um b√¥nus √© recebido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em createNextFrameScene (), devemos verificar os bits correspondentes aos blocos na √°rea vis√≠vel atual. </font><font style="vertical-align: inherit;">Se eles tiverem o valor 1:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se isso √© um b√¥nus, basta adicion√°-lo √† lista de sprites para renderiza√ß√£o. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se este for um inimigo, crie um sprite din√¢mico e redefina a bandeira. </font><font style="vertical-align: inherit;">No pr√≥ximo quadro, a cena conter√° um sprite din√¢mico at√© que o inimigo saia da tela ou seja morto.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa abordagem tem desvantagens. </font></font><br><br><ol><li> -,           (       ).      . </li><li> -,       80  ,  ,    .      ,            32 .          ,   ¬´/¬ª (      ¬´¬ª, ..        0!).           ¬´¬ª,          ¬´¬ª (           ). </li><li> -,      .       (    ),     .  ,      . </li><li> -,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   ! </li><li>     ,          (,    Unreal Tournament   ,        ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, dessa maneira, podemos armazenar e processar sprites em um n√≠vel muito mais eficiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, essa t√©cnica √© mais relevante para a "l√≥gica do jogo" do que para o mecanismo gr√°fico do jogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez no futuro implementemos esta fun√ß√£o.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resumir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperamos que voc√™ tenha gostado deste artigo introdut√≥rio. Precisamos explicar muitos outros aspectos que ser√£o os t√≥picos de futuros artigos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto isso, voc√™ pode baixar o c√≥digo fonte completo do jogo! Se voc√™ gosta, pode apoiar financeiramente o artista </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que desenhou todos os gr√°ficos e deu ao mundo gratuitamente. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m aceitamos doa√ß√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O jogo ainda n√£o terminou. Queremos adicionar som, muitos n√≠veis, objetos com os quais voc√™ pode interagir e coisas do g√™nero. Voc√™ pode criar suas pr√≥prias modifica√ß√µes! Esperamos ver novos jogos com novos gr√°ficos e n√≠veis! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em breve lan√ßaremos um editor de mapas, mas por enquanto √© muito rudimentar mostr√°-lo √† comunidade!</font></font><br><br><h2>  V√≠deo </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Nota: devido √† pouca ilumina√ß√£o, o v√≠deo foi gravado com uma taxa de quadros muito mais baixa! Em breve atualizaremos o v√≠deo para que voc√™ possa estimar a velocidade total em 40 fps!) </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gratid√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os gr√°ficos do jogo (e os blocos mostrados em algumas imagens) s√£o retirados do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ativo gratuito "Sunny Land" criado por ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiais para download </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo fonte do projeto √© de dom√≠nio p√∫blico, ou seja, √© fornecido gratuitamente. </font><font style="vertical-align: inherit;">Compartilhamos isso na esperan√ßa de que seja √∫til para algu√©m. </font><font style="vertical-align: inherit;">N√£o garantimos que, devido a algum bug / erro no c√≥digo, n√£o haver√° problemas! </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagrama esquem√°tico do </font></font></a> <font style="vertical-align: inherit;"><a href=""><font style="vertical-align: inherit;">projeto </font></a></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KiCad </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projeto Atmel Studio 7 (fonte)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466323/">https://habr.com/ru/post/pt466323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466307/index.html">Como fa√ßo para projetar o SCS</a></li>
<li><a href="../pt466311/index.html">Workshop SLS 6 de setembro</a></li>
<li><a href="../pt466315/index.html">@Pythonetc compila√ß√£o, agosto 2019</a></li>
<li><a href="../pt466317/index.html">Dicas e truques do meu canal de telegrama @pythonetc, agosto de 2019</a></li>
<li><a href="../pt466319/index.html">Acordo: VMware compra startup baseada na nuvem</a></li>
<li><a href="../pt466329/index.html">Mapa eletr√¥nico de vinifica√ß√£o na R√∫ssia. Design e conte√∫do</a></li>
<li><a href="../pt466333/index.html">Como organizar um local de trabalho para si mesmo</a></li>
<li><a href="../pt466335/index.html">Criando um aplicativo Slack usando os recursos do 8base</a></li>
<li><a href="../pt466337/index.html">Qual a cor da sua fun√ß√£o?</a></li>
<li><a href="../pt466339/index.html">Como no Microsoft SQL Server para obter dados do Google Analytics usando R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>