<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏾 👼 🤾🏼 Windows Notification Facility: permukaan serangan paling tidak berdokumen 📙 🙏🏽 🗂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bawah cut adalah terjemahan dari presentasi "Fasilitas Notifikasi Windows: Permukaan Serangan Kernel yang Paling Tidak Terdokumentasi" disajikan ol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: permukaan serangan paling tidak berdokumen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Di bawah cut adalah terjemahan dari <strong>presentasi</strong> "Fasilitas Notifikasi Windows: Permukaan Serangan Kernel yang Paling Tidak Terdokumentasi" disajikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alex Ionescu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabrielle Viala</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi BlackHat 2018</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Apa yang akan dibahas dalam publikasi</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu Fasilitas Pemberitahuan Windows (WNF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa WNF muncul</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nama Negara WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panggilan Sistem untuk Bekerja dengan WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Mode Pengguna Tingkat Tinggi (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Level Kernel Tingkat Tinggi (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utilitas Analisis WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permukaan serangan WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nama negara WNF yang menarik dan sensitif</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses injeksi menggunakan WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk untuk Penelitian Lebih Lanjut</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  Apa itu Fasilitas Pemberitahuan Windows (WNF) </h3><br><p>  Windows Notification Facility adalah mekanisme pemberitahuan (tersedia baik dalam kernel dan dalam mode pengguna), yang dibangun di atas model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerbit-pelanggan</a> ( <em>pubsub</em> , Penerbit / Pelanggan).  Mekanisme ini ditambahkan di Windows 8: sebagian untuk mengatasi beberapa keterbatasan desain lama di OS, tetapi juga seharusnya berfungsi sebagai dasar untuk penerapan pemberitahuan push mirip dengan iOS / Android. </p><br><p>  Fitur utamanya adalah model <em>blind</em> (kebanyakan tanpa registrasi) yang memungkinkan untuk berlangganan dan publikasi yang tidak teratur.  Ini menyiratkan bahwa konsumen dapat berlangganan notifikasi bahkan sebelum notifikasi diterbitkan oleh sumbernya.  Dan orang yang membuat acara tidak diharuskan untuk "mendaftarkan" pemberitahuan sebelumnya. </p><br><p>  Selain itu, mekanisme ini mendukung: </p><br><ul><li>  pemberitahuan permanen dan sementara </li><li>  pengidentifikasi unik yang meningkat secara monoton </li><li>  buffer muatan (hingga 4 kilobyte) untuk setiap acara </li><li>  model pemberitahuan thread-pool dengan serialisasi berbasis grup </li><li>  model keamanan berbasis lingkup yang mengimplementasikan deskriptor keamanan melalui mekanisme <abbr title="Daftar Kontrol Akses Discretionary">DACL</abbr> / <abbr title="Daftar kontrol akses sistem">SACL</abbr> standar </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  Mengapa WNF muncul </h3><br><p>  Pertimbangkan contoh kanonik: ada driver yang ingin tahu bahwa volume dengan akses baca dan tulis telah terhubung.  Untuk memberi tahu Anda tentang hal ini, Autochk (analog dari <abbr title="pemeriksaan konsistensi sistem file">fsck</abbr> pada Windows) melaporkan peristiwa yang disebut VolumesSafeForWriteAccess.  Tetapi untuk melaporkan suatu peristiwa, Anda harus terlebih dahulu membuat objek acara itu sendiri. </p><br><p>  Kita juga perlu tahu bahwa Autochk sudah bekerja pada volume, tetapi belum memberi sinyal acara yang kita tunggu.  Solusi buruk: duduk dalam lingkaran dengan sleep (), memeriksa keberadaan acara, dan ketika acara dibuat - tunggu. </p><br><p>  Tetapi setelah keluar dari aplikasi Windows, semua deskriptornya ditutup.  Dan ketika objek tidak memiliki deskriptor, itu dihancurkan.  Jadi siapa yang akan mengadakan acara ini? </p><br><p>  Tanpa WNF, solusinya adalah kernel OS untuk membuat suatu peristiwa sebelum driver memuat, dan bagi Autochk untuk membukanya seperti yang dilakukan konsumen, tetapi alih-alih menunggu, itu harus memberi sinyal peristiwa ini. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Nama Negara WNF </h3><br><p>  Di dunia WNF, nama negara adalah angka 64-bit.  Tetapi ada trik - sebenarnya itu adalah struktur kode.  Nama negara memiliki <em>versi</em> , <em>seumur hidup</em> , ruang <em>lingkup</em> , <em>bendera kegigihan data,</em> dan <em>nomor seri unik</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Tetapi data ini hanya akan tersedia jika kita memberikan nomor 64-bit dengan konstanta ajaib: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Seumur hidup dari nama negara </h4><br><p>  Nama negara WNF dapat berupa (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  terkenal </li><li>  permanen </li><li>  gigih </li><li>  sementara </li></ul><br><p>  Tiga yang pertama dikaitkan dengan kunci yang sesuai dalam registri, tempat informasi status akan disimpan: </p><br><ul><li>  nama-nama terkenal tinggal di HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notifications </li><li>  nama persisten hidup di HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Pemberitahuan </li><li>  nama persisten hidup di HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Nama-nama terkenal memiliki kekhasan sendiri: mereka tidak dapat didaftarkan.  Nama seperti itu harus sudah disajikan dalam registri pada saat boot sistem.  Nama gigih dan persisten membutuhkan hak istimewa SeCreatePermanentPrivilege yang disertakan (seperti objek global lainnya) untuk membuatnya.  Nama gigih hidup di luar proses registrar, sementara nama gigih bertahan sistem reboot. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Lingkup data </h4><br><p>  Cakupan data menentukan batas keamanan pertama di sekitar nama status WNF, menentukan siapa yang melihatnya dan memiliki akses ke sana.  Lingkup nama negara dapat: </p><br><ul><li>  sistem </li><li>  mobil </li><li>  sesi pengguna </li><li>  pengguna </li><li>  prosesnya </li></ul><br><p>  Selain memberikan batasan keamanan, cakupan WNF dapat digunakan untuk memberikan contoh data yang berbeda untuk nama yang sama.  Kernel (seperti halnya mekanisme keamanan lainnya) melewati pemeriksaan akses negara.  Hak istimewa TCB memungkinkan akses lintas-lingkup ke nama negara WNF. </p><br><p>  Lingkup "sistem" dan lingkup "mesin" adalah cakupan global.  Mereka tidak memiliki pengidentifikasi sendiri (mereka menggunakan wadah global yang berbeda).  Ruang lingkup sesi pengguna menggunakan pengidentifikasi sesi (ID sesi) sebagai ID.  Ruang lingkup pengguna tertentu menggunakan SID pengguna ini sebagai pengidentifikasi.  Alamat objek EPROCESS adalah pengidentifikasi ruang lingkup proses. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  Nomor Urutan </h4><br><p>  Untuk memastikan keunikan, setiap nama negara memiliki nomor urut 51-bit yang unik.  Nama-nama terkenal termasuk tag keluarga 4-karakter dalam nomor seri mereka, dan 21 bit sisanya digunakan sebagai pengidentifikasi unik.  Nama permanen menyimpan nomor mereka yang bertambah dengan nilai registri "SequenceNumber".  Nama persisten dan sementara menggunakan penghitung kenaikan umum, yang terletak di variabel global.  Data ini disimpan dan diproses secara terpisah untuk setiap wadah (per-silo) dan tersedia di PspHostSiloGlobals-&gt; WnfSiloState. </p><br><p>  Di dalam Microsoft, setiap nama WNF memiliki pengenal "ramah" yang digunakan dalam kode, kadang-kadang disimpan dalam ruang nama global dengan nama yang sama.  Misalnya, simbol nt! WNF_BOOT_DIRTY_SHUTDOWN, yang memiliki nilai 0x1589012fa3bc0875.  Setelah XOR dengan konstanta ajaib <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY</abbr> kita mendapatkan nilai 0x544f4f4200000801, yang dapat ditafsirkan sebagai: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Panggilan Sistem untuk Bekerja dengan WNF </h3><br><p>  Panggilan sistem kernel memungkinkan Anda untuk mendaftar dan menghapus nama negara WNF, menerbitkan dan menerima data nama negara WNF, dan juga menerima berbagai pemberitahuan dari WNF. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Daftarkan Nama Status WNF </h4><br><p>  Dengan pengecualian nama-nama terkenal (seperti disebutkan sebelumnya), nama status WNF dapat didaftarkan saat OS sedang berjalan: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Ada panggilan sistem simetris ZwDeleteWnfStateName yang dengannya Anda dapat menghapus nama negara terdaftar (sekali lagi, kecuali yang terkenal). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Publikasikan Data Status WNF </h4><br><p>  Untuk mengatur atau mengubah data nama status WNF, Anda dapat menggunakan panggilan sistem ZwUpdateWnfStateData: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Ada sistem panggilan simetris ZwDeleteWnfStateData untuk menghapus (membersihkan) data nama negara WNF. </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Mendapatkan Data Status WNF </h4><br><p>  Untuk meminta data nama status WNF, panggilan sistem berikut dapat digunakan (sebagian besar parameter mirip dengan fungsi Pembaruan): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  Kekuatan sebenarnya terletak pada kenyataan bahwa fungsi API Pembaruan dan Permintaan sebenarnya tidak memerlukan nama negara WNF <u>terdaftar</u> .  Dan jika nama itu tidak sementara (dan kode panggilan memiliki hak istimewa yang cukup), sebuah instance dari nama tersebut dapat didaftarkan secara real time! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  Pemberitahuan WNF </h4><br><p>  Sejauh ini, kami mengasumsikan bahwa konsumen tahu kapan harus memanggil fungsi akuisisi data.  Tetapi ada juga <em>pemblokiran pembacaan</em> , yang berfungsi menggunakan sistem notifikasi (yang lebih dekat dengan model penerbit-pelanggan sejati). </p><br><p>  Pertama, proses harus mendaftarkan acara dengan memanggil fungsi ZwSetWnfProcessNotificationEvent.  Maka Anda perlu memanggil fungsi ZwSubscribeWnfStateChange, menentukan topeng acara untuk mendapatkan pengidentifikasi berlangganan pada output.  Acara dapat terdiri dari dua jenis: </p><br><ul><li>  Pemberitahuan data: <br><ul><li>  0x01 - tampilan data </li><li>  0x10 - penghancuran nama </li></ul></li><li>  Metanotifikasi Meta <br><ul><li>  0x02 - tampilan pelanggan yang menerima pemberitahuan data (Pelanggan Data) </li><li>  0x04 - penampilan pelanggan yang menerima notifikasi meta (Pelanggan Meta) </li><li>  0x08 - penampilan pelanggan yang menerima pemberitahuan data dan meta-notifikasi (Pelanggan Umum) </li></ul></li></ul><br><p>  Maka Anda harus menunggu acara yang direkam.  Dan setiap kali acara menjadi sinyal, Anda perlu memanggil fungsi ZwGetCompleteWnfStateSubscription, yang mengembalikan WNF_DELIVERY_DESCRIPTOR. </p><br><p>  Tetapi fungsi-fungsi API tingkat rendah ini memiliki masalah (terima kasih kepada Gabi untuk menyelidikinya): setiap proses hanya dapat memiliki satu peristiwa yang terdaftar. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  API Mode Pengguna Tingkat Tinggi (ntdll) </h3><br><p>  Ketika datang ke notifikasi, hal menjadi rumit, sehingga lapisan rtl dari ntdll.dll menyediakan antarmuka yang lebih sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  Bahkan, tidak perlu memanggil layanan sistem secara langsung: cukup gunakan satu antrian kejadian yang didorong ntdll.dll. </p><br><p>  Di belakang layar, konten WNF_DELIVERY_DESCRIPTOR dikonversi menjadi parameter panggilan balik: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Untuk setiap langganan baru, sebuah entri dibuat, yang ditempatkan dalam daftar yang ditunjukkan oleh variabel global RtlpWnfProcessSubscription.  Daftar ini dibangun di salah satu bidang WNF_NAME_SUBSCRIPTION, yang bertipe LIST_ENTRY.  Setiap WNF_NAME_SUBSCRIPTION, pada gilirannya, memiliki bidang LIST_ENTRY lain untuk mengatur daftar WNF_USER_SUBSCRIPTION dengan panggilan balik dan konteks. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  API Level Kernel Tingkat Tinggi (Ex) </h3><br><p>  WNF juga menyediakan fungsi yang hampir identik untuk kode mode kernel (yang dapat digunakan dari driver): baik melalui panggilan sistem yang diekspor dan melalui fungsi API tingkat tinggi di runtime (Ex layer). </p><br><p>  Fungsi ExSubscribeWnfStateChange menerima nama negara, mengetikkan topeng dan alamat fungsi panggil balik + konteks sebagai input, dan mengembalikan deskriptor berlangganan.  Fungsi panggilan balik menerima nama target, mask acara, ganti label, tetapi bukan buffer atau ukurannya. </p><br><p>  Fungsi ExQueryWnfStateData, berdasarkan keterangan langganan yang diteruskan, membaca data status saat ini.  Bahkan, setiap panggilan balik akhirnya memanggil fungsi ExQueryWnfStateData untuk mendapatkan data yang terkait dengan pemberitahuan. </p><br><p>  Untuk langganan mode kernel dan langganan mode pengguna, WNF (untuk melacak langganan) membuat instance dari struktur WNF_SUBSCRIPTION.  Tetapi untuk mode pengguna, beberapa bidang tidak akan diisi, misalnya Callback dan Konteks, karena untuk mode pengguna, alamat penangan disimpan dan diproses oleh ntdll.dll. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  Struktur Data WNF </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>Dari penerjemah</em></u> : lihat bagian selanjutnya. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  Utilitas Analisis WNF </h3><br><p>  <u><em>Dari seorang penerjemah</em></u> : di sini perlu diingat kembali bahwa presentasi dilakukan tidak hanya oleh Alex, tetapi juga oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabrielle Viala</a> .  Secara khusus, kepengarangannya termasuk dalam modul WnfCom yang dijelaskan di bawah ini.  Selain itu, Gabrielle menggambarkan struktur internal WNF dalam detail yang cukup (lihat ilustrasi di bagian sebelumnya).  Sebagian besar slide-nya, sayangnya, tidak ada dalam pdf presentasi (ditunjukkan sebagai aslinya) atau diindikasikan secara eksklusif oleh judul.  Tapi: </p><br><ul><li>  Ini adalah kesempatan yang bagus untuk menonton rekaman kinerja bersama mereka: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows Notification Facility: Mengupas Bawang dari Permukaan Serangan Kernel yang Paling Tidak Terdokumentasi</a> (awal Gabrielle ~ 19:27).  Di sana (selain struktur data) akan ada cerita tentang bagaimana mereka memperbaiki ekstensi debugger! Wnf (spoiler - menggunakan metode yang dijelaskan dalam The NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperbaiki Ekstensi Debugger yang Rusak</a> ) </li><li>  Gabrielle memiliki artikel bagus yang terpisah (terperinci, bukan sebagai presentasi) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bermain dengan Windows Notification Facility (WNF)</a> , yang juga sangat dianjurkan untuk dibaca oleh semua yang tertarik. </li></ul><br><p>  <u><em>Dan dari penerjemah</em></u> : Jika seseorang ingin melengkapi terjemahan saat ini dengan isi slide Gabrielle atau memperluas terjemahan steno dari bagian mana pun dari video pidato - selamat datang.  Untuk kenyamanan menambahkan / mengubah potongan besar, saya dapat menerbitkan sumber terjemahan di github (atau server kontrol versi lain). </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom adalah modul python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber github</a> ) yang menunjukkan interoperabilitas melalui WNF.  Fitur utama: </p><br><ul><li>  memungkinkan Anda membaca / menulis data dari instance instance yang ada </li><li>  memungkinkan Anda membuat nama negara sementara (sebagai <em>server</em> ) </li><li>  memungkinkan Anda mendapatkan instance objek sisi <em>klien</em> yang akan memproses notifikasi tentang mengubah instance spesifik nama </li></ul><br><p>  Contoh penggunaan: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump adalah utilitas baris perintah yang ditulis dalam C. File yang dapat dieksekusi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ionescu007/wnfun</a> dengan memilih subdirektori dari kedalaman bit yang diperlukan.  Utilitas dapat digunakan untuk mencari informasi tentang nama negara WNF: </p><br><ul><li>  -d ( <u>D</u> ump) Dump semua nama negara WNF menggunakan enumerasi berbasis registri.  Itu dapat dilengkapi dengan opsi: <br><ul><li>  -v ( <u>V</u> erbose) Output verbose yang mencakup dump heksadesimal data status WNF; </li><li>  -s ( <u>S</u> ecurity) Deskriptor keamanan - string izin SDDL untuk nama status WNF. </li></ul></li><li>  -b ( <u>B</u> rute-force) Penghitungan langsung nama negara WNF sementara (lebih lanjut tentang ini di bawah ini) </li><li>  -i ( <u>I</u> nformation) Menampilkan informasi tentang satu nama negara WNF yang ditentukan </li><li>  -r ( <u>R</u> ead) Membaca data dari nama status WNF yang ditentukan </li><li>  -w (Ritus) Tulis data ke nama status WNF yang ditentukan </li><li>  -n ( <u>N</u> otifikasi) Daftarkan pelanggan pemberitahuan untuk nama status WNF yang ditentukan (selanjutnya kami akan memberikan kasus penggunaan yang lebih spesifik dengan Edge) </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  Permukaan serangan WNF </h3><br><p>  Bagian ini (lebih tepatnya, subbagiannya) akan membahas kemungkinan serangan dan data WNF sensitif yang menarik. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Pengungkapan Data Privileged </h4><br><p>  Membaca ribuan nama negara WNF yang ada dalam sistem, beberapa dapat dicatat, data yang terlihat sangat menarik.  Di antara mereka ada beberapa yang datanya mencurigakan mirip dengan pointer atau data istimewa lainnya. </p><br><p>  Setelah bermain di beberapa mesin, dalam beberapa kasus dimungkinkan untuk menemukan banyak, tumpukan, dan informasi istimewa lainnya yang diungkapkan melintasi batas-batas hak istimewa.  Laporan bug / kerentanan dikirim ke MSRC pada bulan Juli, tetapi diperbaiki pada bulan November (setelah presentasi).  Misalnya: 4 kilobyte tumpukan bocor melalui acara WNF_AUDC *! </p><br><p>  Masalah utama adalah sama seperti yang kita lihat dalam penelitian sebelumnya dari j00ro, taviso, dan lainnya.  Nama negara WNF tertentu berisi struktur data yang disandikan dengan berbagai masalah bantalan dan / atau perataan.  Dalam beberapa kasus, kebocoran memori yang tidak diinisialisasi. <br>  <u><em>Dari penerjemah</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan bagian pendahuluan dari dokumen Mendeteksi Pengungkapan Memori Kernel dengan x86 Emulation dan Taint Tracking dari Mateusz Jurczyk alias j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Penemuan nama negara dan izin </h4><br><p>  Pendekatan pertama adalah menemukan semua nama negara yang mungkin dapat dimanipulasi secara jahat.  Untuk nama-nama terkenal, permanen, dan persisten, enumerasi layak dilakukan dengan menyebutkan kunci registri.  Kemudian nilai yang ditemukan dapat dibandingkan dengan pengidentifikasi ramah (ada beberapa tempat di mana Anda dapat menemukannya :)) </p><br><p>  Kemudian kita juga dapat melihat deskriptor keamanan dalam registri (ini adalah hal pertama dalam buffer data).  Deskriptor keamanan bukan kanonik: itu tidak memiliki pemilik dan grup, sehingga secara teknis tidak valid.  Tetapi tidak ada masalah mengganti pemilik dan grup palsu untuk <em>memperbaiki</em> deskriptor keamanan. </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Deteksi nama negara sementara dan izin mereka </h4><br><p>  Tetapi dengan nama sementara, trik yang dijelaskan di atas tidak akan berfungsi: mereka tidak ada dalam registri.  Dan hanya kernel yang menyimpan struktur data untuk mereka (! Wnf) dalam memori.  Tapi nama sementara sebenarnya tidak terlalu sulit untuk di paksa: </p><br><ul><li>  Versi selalu penting 1 </li><li>  Seumur hidup selalu berarti WnfT TemporaryStateName </li><li>  Bendera permanen selalu dihapus (nama negara sementara tidak dapat memiliki data permanen) </li><li>  Lingkup (lingkup) dapat mengambil salah satu dari 4 nilai </li></ul><br><p>  Ya, tetapi nomor urut yang tersisa adalah 51 bit!  Memang ... tapi jangan lupa bahwa nomor seri tumbuh secara monoton.  Dan untuk nama sementara, urutan diatur ulang ke 0 pada setiap boot.  Secara konvensional, Anda dapat mengambil jendela sejuta nomor seri: dalam satu lingkaran, periksa keberadaan setiap nama (mulai dari 0) dengan menghubungi ZwQueryWnfStateNameInformation dengan kelas informasi yang diminta WnfInfoStateNameExist (mengingat bahwa kesalahan akses juga menunjukkan keberadaan nama).  Jika satu juta nama lain tidak ada, maka Anda dapat menghentikan pencarian. </p><br><p>  Deskriptor keamanan nama sementara (seperti data nama sementara lainnya) disimpan di kernel.  Oleh karena itu, satu-satunya cara untuk meminta mereka adalah ekstensi! Wnf ketika men-debug mode kernel.  Tapi kita bisa: </p><br><ul><li>  Buat kesimpulan tentang izin baca saat mencoba membaca data. </li><li>  Untuk menyimpulkan bahwa perekaman diperbolehkan dengan mencoba menulis data.  Tetapi perlu dipertimbangkan bahwa penulisan yang berhasil bahkan 0 byte menghancurkan data yang belum berhasil diperoleh konsumen nyata.  Dan lagi, ada trik: kita bisa menerapkan stempel perubahan yang sesuai.  Kami mencoba menulis dengan label 0xFFFFFFFF: label diperiksa setelah pemeriksaan akses, oleh karena itu, nilai kesalahan menghasilkan kebocoran izin menulis. </li></ul><br><p>  Ini tidak memberi kami deskriptor keamanan yang lengkap, tetapi dengan menjalankan kode dengan hak istimewa yang berbeda, kami bisa mendapatkan beberapa gagasan tentang pembatasan untuk akun sistem yang berbeda (Low IL / User / Admin / SYSTEM). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Daftar Pelanggan </h4><br><p>  Dalam struktur WNF_PROCESS_CONTEXT, salah satu bidang adalah kepala daftar (LIST_ENTRY) dari semua langganan proses ini.  Setiap langganan adalah turunan terpisah dari WNF_SUBSCRIPTION. </p><br><p>  Pelanggan mode-kernel terutama dimiliki oleh proses Sistem.  Kita dapat menggunakan perintah! Daftar debugger untuk membuang penangan dan parameternya terdaftar dalam proses Sistem WNF_SUBSCRIPTION.  Perlu dicatat bahwa dalam beberapa kasus, event aggregator (CEA.SYS) digunakan, yang menyembunyikan alamat panggilan balik yang sebenarnya dalam struktur konteksnya. </p><br><p>  Kami dapat mengulangi pendekatan ini untuk proses mode pengguna, tetapi alamat Callback akan menjadi NULL, karena ini adalah pelanggan mode pengguna.  Oleh karena itu, kita harus bergabung dengan ruang pengguna proses, mendapatkan tabel RtlpWnfProcessSubscription, dan kemudian membuang daftar instance WNF_USER_SUBSCRIPTION, yang masing-masing sudah berisi alamat Callback.  Sayangnya, karakter ini statis, yang berarti tidak ada dalam karakter terbuka, tetapi dapat ditemukan dengan membongkar.  Dan sekali lagi perlu diperhatikan (dengan analogi dengan mode kernel CEA.SYS) bahwa banyak penangan mode pengguna menggunakan agregator acara (EventAggregation.dll), yang menyimpan panggilan balik dalam konteksnya. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Nama negara WNF yang menarik dan sensitif </h3><br><p>  Bagian ini akan memberikan beberapa contoh menarik tentang bagaimana beberapa nama negara WNF mengungkapkan informasi sistem. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Menentukan status sistem dan perilaku pengguna menggunakan WNF </h4><br><p>  Beberapa pengidentifikasi WNF dapat digunakan untuk mendapatkan informasi tentang keadaan mesin yang menarik minat Anda: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Status Nirkabel </li><li>  WNF_BLTH_BLUETOOTH_STATUS - sama, tetapi untuk Bluetooth (juga WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE - menunjukkan sumber daya (baterai atau adaptor daya) </li><li>  WNF_SEB_BATTERY_LEVEL - berisi level baterai </li><li>  WNF_CELL_ * - pada Windows Phone berisi informasi tentang: jaringan, jumlah, kekuatan sinyal, EDGE atau 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER —   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT —    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED —    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      —       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE —     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST —   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK — ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND –   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory —    </li><li>   ( ) —               </li><li>   (Atom) —            </li><li>    —  ,   WM_COPYDATA  DDE,       </li><li> GUI  —    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Panggilan prosedur tidak sinkron">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " —  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Kontrol pelindung aliran">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> github</a> )   explorer (  —  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li>     WNF_USER_SUBSCRIPTION     </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459626/">https://habr.com/ru/post/id459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459616/index.html">MIPT membuka program master lanjutan pertama Rusia dalam Ilmu Komputer dan Rekayasa Perangkat Lunak</a></li>
<li><a href="../id459618/index.html">Beberapa fitur komposisi buruh pelabuhan yang kurang dikenal</a></li>
<li><a href="../id459620/index.html">TDDx2, BDD, DDD, FDD, MDD, dan PDD, atau apa pun yang ingin Anda ketahui tentang Pengembangan Didorong</a></li>
<li><a href="../id459622/index.html">Karena game untuk Sega Saturn ditulis pada tahun 1995</a></li>
<li><a href="../id459624/index.html">Drone militer</a></li>
<li><a href="../id459628/index.html">Open Invention Network memiliki lebih dari tiga ribu pemegang lisensi - apa artinya untuk perangkat lunak open source</a></li>
<li><a href="../id459630/index.html">Tic Tac Toe Bagian 2: Stateless Undo / Redo</a></li>
<li><a href="../id459638/index.html">Menciptakan basis pengetahuan global tentang baterai</a></li>
<li><a href="../id459640/index.html">Dokumen sebagai Kode. Bagian 1: mengotomatiskan pembaruan</a></li>
<li><a href="../id459642/index.html">Akses aman untuk mendaftarkan bidang dalam C ++ tanpa mengorbankan efisiensi (menggunakan CortexM sebagai contoh)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>