<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📸 🌘 📙 إعادة تحميل قوام OpenGLESv2 عبر DMABUF 🎅🏻 🏾 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في هذه المقالة ، أود التحدث عن مدى سهولة تحديث قوام OpenGLES من خلال DMABUF. نظرت إلى هبر ، ولمفاجأتي ، لم أجد مقالاً واحداً حول هذا الموضوع. في هبر س...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إعادة تحميل قوام OpenGLESv2 عبر DMABUF</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/" style=";text-align:right;direction:rtl"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  في هذه المقالة ، أود التحدث عن مدى سهولة تحديث قوام OpenGLES من خلال DMABUF.  نظرت إلى هبر ، ولمفاجأتي ، لم أجد مقالاً واحداً حول هذا الموضوع.  في هبر سؤال وجواب أيضا لم تجد أي شيء من هذا.  وهذا غريب بعض الشيء بالنسبة لي.  ظهرت هذه التقنية منذ فترة ، رغم أنه لا توجد معلومات كثيرة عنها على الشبكة ، إلا أنها غامضة ومتناقضة. <br><br>  لقد جمعت كل هذه المعلومات شيئًا فشيئًا من مصادر مختلفة قبل أن أتمكن من كتابة مشغل فيديو مثل هذا على العرض التوضيحي أعلاه.  هنا ، في عرض توضيحي ، يقوم مشغل الفيديو الخاص بي القائم على مكتبة gstreamer بتحميل إطارات الفيديو في نسيج OpenGLESv2 في كل مرة قبل التقديم.  مدعوم من التوت Pi4.  يتم نسخ الإطارات ببساطة إلى ذاكرة مخصصة بشكل خاص - ويقوم DMA بنقلها إلى ذاكرة GPU ، إلى النسيج.  بعد ذلك ، سوف أخبرك كيف فعلت ذلك. <br><a name="habracut"></a><br>  عادةً ما يقوم مبرمج يستخدم OpenGLESv2 بإنشاء نسيج مرة واحدة فقط ثم يعرضه على كائنات المشهد.  يحدث هذا ، لأن أزياء الشخصيات نادراً ما تتغير وتعيد في بعض الأحيان إعادة تحميل النسيج باستخدام glTexSubImage2D () ليست صعبة.  ومع ذلك ، تبدأ المشاكل الحقيقية عندما يكون النسيج ديناميكيًا ، عندما تحتاج إلى تحديثه كل إطار تقريبًا أثناء التقديم.  وظيفة glTexSubImage2D () بطيئة للغاية.  حسنًا ، كم هي بطيئة - بالطبع ، كل هذا يتوقف على الكمبيوتر وعلى بطاقة الرسومات.  كنت أرغب في إيجاد حل نجح حتى في وضع البطاقات الفردية الضعيفة مثل توت العليق. <br><br>  بنية العديد من أجهزة الكمبيوتر الحديثة ، بما في ذلك أجهزة الكمبيوتر ذات اللوحة المفردة SoC ، هي أن ذاكرة المعالج منفصلة عن ذاكرة GPU.  عادة ، لا تتمتع برامج المستخدم بوصول مباشر إلى ذاكرة GPU وتحتاج إلى استخدام وظائف API المختلفة مثل glTexSubImage2D () نفسه.  علاوة على ذلك ، قرأت في مكان ما أن التمثيل الداخلي للنسيج قد يختلف عن التمثيل التقليدي للصور كسلسلة بكسل.  لا أعرف مدى صحة ذلك.  ربما. <br><br>  إذن ما الذي تعطيني تكنولوجيا DMABUF؟  يتم تخصيص الذاكرة بشكل خاص ويمكن لعملية من أي مؤشر ترابط فقط كتابة بكسل هناك وقتما تشاء.  سوف DMA نفسها نقل جميع التغييرات على الملمس في ذاكرة GPU.  أليس هذا جميل؟ <br><br>  يجب أن أقول على الفور أنني أعلم عن PBO - Pixel Buffer Object ، وعادة ما يتم ذلك بمساعدة تحديث مادة PBO الديناميكية ، يبدو أن DMA يتم استخدامه هناك أيضًا ، لكن PBO ظهر فقط في OpenGLESv3 وليس في جميع التطبيقات.  لذلك لا - للأسف ، هذا ليس طريقي. <br><br>  قد تكون المقالة ذات أهمية لكل من مبرمجي Raspberry ومطوري الألعاب ، وربما حتى مبرمجي Android ، نظرًا لاستخدام OpenGLES هناك أيضًا ، وأنا متأكد من أن تقنية DMABUF هذه موجودة أيضًا هناك (على الأقل ، أنا متأكد من أنه يمكنك استخدامها من Android NDK). <br><br>  سأكتب برنامجًا يستخدم DMABUF على Raspberry Pi4.  يجب أن يعمل البرنامج أيضًا (وسيعمل) على أجهزة كمبيوتر Intel x86 / x86_64 العادية ، وفقًا لأوبونتو. <br><br>  في هذه المقالة ، افترض أنك تعرف بالفعل كيفية برمجة الرسومات باستخدام OpenGLESv2 API.  ومع ذلك ، لن يكون هناك الكثير من هذه التحديات.  في الغالب سيكون لدينا ioctl السحر. <br><br>  لذا ، فإن أول ما يجب فعله هو التأكد من أن واجهة برمجة التطبيقات (API) المتوفرة على النظام الأساسي يجب أن تدعم DMABUF.  للقيام بذلك ، تحقق من قائمة امتدادات EGL: <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br>  لذلك سوف نفهم على الفور ما إذا كان هناك أي أمل في استخدام DMABUF أو إذا لم يكن هناك أمل.  على سبيل المثال ، في Raspberry Pi3 وجميع اللوحات السابقة ، لا يوجد أمل.  هناك ، بشكل عام ، حتى OpenGLESv2 يتم تجريده بطريقة أو بأخرى ، من خلال مكتبات خاصة مع بروش BRCM.  والآن على Raspberry Pi4 ، يوجد OpenGLES حقيقي ، بينما التمديد EGL_EXT_image_dma_buf_import هو ، hooray. <br><br>  سألاحظ على الفور نظام التشغيل الذي أمتلكه على لوحة واحدة Pi4 ، وإلا فقد تكون هناك أيضًا مشكلات في هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br>  وألاحظ أيضًا أن امتداد EGL_EXT_image_dma_buf_import موجود على Orange Pi PC (Mali-400) / PC2 (Mali-450) ، ما لم يكن بالطبع يمكنك تشغيل GPU Mali على هذه اللوحات (في التجميعات الرسمية ، لم تكن هناك ، لقد قمت بتثبيته على Armbian ، بالإضافة إلى أنني قمت بذلك بنفسي الجمعية سائق النواة).  وهذا هو ، DMABUF هو في كل مكان تقريبا.  من الضروري فقط أن تأخذ واستخدامها. <br><br>  بعد ذلك ، تحتاج إلى فتح الملف / dev / dri / card0 أو / dev / dri / card1 - أحدهما يعتمد على النظام الأساسي ، ويحدث بشكل مختلف ، وتحتاج إلى البحث عن الملف الذي يدعم DRM_CAP_DUMB_BUFFER: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br>  هنا بالمناسبة هناك دقة لا يمكن تفسيره بالنسبة لي.  لا تحتوي بعض الأنظمة الأساسية على مكتبات توفر وظيفة DRI2Authenticate ().  على سبيل المثال ، ليست في الكراك وفي الإصدار 32 بت لأجهزة Orange Pi PC.  كل هذا غريب.  لكنني وجدت هذا المستودع على GITHUB: github.com/robclark/libdri2 يمكن أخذه وتجميعه وتثبيته ، ثم كل شيء على ما يرام.  من الغريب أنه في بلدي Ubuntu 18 (64 بت) على جهاز كمبيوتر محمول لا توجد مشكلة. <br><br>  إذا تمكنت من العثور وفتح / dev / dri / cardX ، يمكنك الانتقال.  تحتاج إلى الوصول إلى الوظائف الثلاث الضرورية جدًا لـ KHR (Khronos): <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br>  نحتاج الآن إلى وظيفة تنشئ منطقة ذاكرة لـ DMABUF.  تأخذ الدالة المعلمات مثل عرض الصورة النقطية والارتفاع ، وكذلك المؤشرات التي سيتم إرجاع معالج واصف ملف DmaFd ومؤشر إلى الذاكرة النقطية Plane. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br>  نحتاج الآن إلى إنشاء صورة EGL مرتبطة بمعالج DmaFd: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  وأخيرًا ، انتهت محنتنا تقريبًا ، ويجب علينا ربط صورة EGL وصورة OpenGLESv2.  تقوم الدالة بإرجاع مؤشر إلى الذاكرة في مساحة عنوان العملية.  هناك يمكنك ببساطة الكتابة من أي مؤشر ترابط المعالج وكل التغييرات التي تظهر بمرور الوقت تظهر تلقائيًا في نسيج GPU من خلال DMABUF. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  تقوم وظيفة GlEGLImageTargetTexture2DOES (..) بهذا الربط فقط.  ويستخدم إنشاء معرف النسيج الطبيعي glGenTextures (..) ويربطه مع esContext-&gt; ImageKHR EGL الذي تم إنشاؤه مسبقًا.  بعد ذلك ، يمكن استخدام userData-&gt; textureV الملمس في تظليل العادية.  والمؤشر esContext-&gt; Plane هو مؤشر إلى المنطقة في الذاكرة حيث تحتاج إلى الكتابة لتحديث النسيج. <br><br>  فيما يلي مقتطف الشفرة الذي ينسخ إطار فيديو: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  تسمى هذه الوظيفة بواسطة gstreamer نفسها في كل مرة يظهر فيها إطار فيديو جديد.  نسترجعه باستخدام gst_app_sink_pull_sample ().  تحتوي هذه الوظيفة على memcpy () ، الذي يقوم بنسخ الإطار في ذاكرة DMABUF.  ثم يتم تعيين إشارة frame_ready ومن خلال std :: condition_variable update_cv.notify_one () ، يتم إيقاظ الدفق الذي يتم عرضه. <br><br>  هذا ربما كل شيء ... <br><br>  على الرغم من لا ، أنا يكذب.  لا تزال هناك مشاكل التزامن. <br><br>  الأول هو أن المعالج يكتب إلى الذاكرة ، ولكن قد تنتهي هذه السجلات في ذاكرة التخزين المؤقت للمعالج وتحتفظ بها هناك ، تحتاج إلى إنشاء ذاكرة تخزين مؤقت مخبأ بعد التسجيل.  الثاني - لن يكون من السيئ معرفة بالضبط متى تم إعداد DMA بالفعل ويمكنك البدء في العرض.  بصراحة ، إذا كان الأول ما زلت أتخيل كيفية القيام به ، ثم الثاني - لا.  إذا كان لديك أفكار ، فاكتب في التعليقات. <br><br>  وأكثر شيء واحد.  أنا أستخدم gstreamer ، الذي يلعب ملف فيديو.  أضفت appinkink عام إلى خط الأنابيب ، الذي يستقبل إطارات الفيديو.  آخذ البيكسلات من إطارات الفيديو وقم ببساطة بنسخها memcpy () إلى منطقة ذاكرة DMABUF.  التقديم في موضوع منفصل ، رئيسي ().  لكن أود التخلص من هذه النسخة.  كل نسخة شريرة.  هناك حتى مثل هذا المصطلح صفر نسخة.  واستنادا إلى الوثائق ، يبدو أن gstreamer نفسها يمكن أن تجعل الإطارات على الفور في DMABUF.  لسوء الحظ ، لم أجد مثالًا حقيقيًا واحدًا.  نظرت إلى مصادر gstreamer - هناك شيء حيال ذلك ، ولكن كيفية استخدامه بالضبط غير واضح.  إذا كنت تعرف كيفية إنشاء إطارات ذات نسخ صفرية حقيقية باستخدام gstreamer في نسيج OpenGLESv2 - اكتب. <br><br>  ربما النقطة الأخيرة: في مشروعي أستخدم الصور النقطية 32 بت ، وهي ليست جيدة في حالتي.  سيكون من المعقول أن تأخذ YUV من gstreamer ، ثم يكون حجم إطار الفيديو أصغر بكثير ، ولكن المنطق معقد - يجب أن أقوم بـ 3 DMABUF لثلاثة مواد منفصلة بشكل منفصل Y ، U ، V. حسنًا ، التظليل معقد أيضًا ، تحتاج إلى تحويل YUV إلى ARGB الحق في تظليل. <br><br>  يمكنك عرض المشروع بأكمله <a href="https://github.com/random-prj/video-cube">على جيثب</a> .  ومع ذلك ، أعتذر مقدماً لعشاق الكود / النمط النظيف والصحيح.  أعترف أنه تمت كتابته بلا مبالاة بمساعدة Google-mine-لصق. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar481540/">https://habr.com/ru/post/ar481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar481530/index.html">نيفنجر: تغذية للسرعة</a></li>
<li><a href="../ar481532/index.html">الطب الشرعي الذاكرة ، بطة المطاط وكلمات مرور GPO. حل المشكلات باستخدام r0ot-mi. الجزء 2</a></li>
<li><a href="../ar481534/index.html">هل دلفي الموت - خطأ</a></li>
<li><a href="../ar481536/index.html">تاريخ نظام أسماء النطاقات: بروتوكولات "الحرب"</a></li>
<li><a href="../ar481538/index.html">20 من كبار المسئولين الاقتصاديين الخرافات للموت في عام 2020</a></li>
<li><a href="../ar481542/index.html">التحقق من الدوائر الرقمية. نظرة عامة</a></li>
<li><a href="../ar481544/index.html">استخدام شبكة عصبية تلافيفية للعب الحياة (على Keras)</a></li>
<li><a href="../ar481546/index.html">تاريخ المعالج الدقيق والكمبيوتر الشخصي: 1947-1974</a></li>
<li><a href="../ar481548/index.html">Symbol.iterator في جافا سكريبت</a></li>
<li><a href="../ar481550/index.html">إنمارسات: استقبال وفك تشفير إشارة القمر الصناعي في المنزل</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>