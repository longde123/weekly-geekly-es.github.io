<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù£Ô∏è üö¨ üè∑Ô∏è Interface STL de Berkeley DB üõê üëãüèΩ üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr. H√° pouco tempo, para um dos meus projetos, eu precisava de um banco de dados incorporado que armazenasse elementos de valor-chave, forne√ßa su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interface STL de Berkeley DB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459862/"><p>  Oi Habr.  H√° pouco tempo, para um dos meus projetos, eu precisava de um banco de dados incorporado que armazenasse elementos de valor-chave, forne√ßa suporte a transa√ß√µes e, opcionalmente, dados criptografados.  Ap√≥s uma breve pesquisa, me deparei com um projeto do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Berkeley DB</a> .  Al√©m dos recursos de que preciso, esse banco de dados fornece uma interface compat√≠vel com STL que permite trabalhar com o banco de dados como em um cont√™iner STL regular (quase comum).  Na verdade, essa interface ser√° discutida abaixo. </p><a name="habracut"></a><br><h2 id="berkeley-db">  Berkeley db </h2><br><p>  <strong>O Berkeley DB</strong> √© um banco de dados de c√≥digo aberto incorporado, escal√°vel e de alto desempenho.  Est√° dispon√≠vel gratuitamente para uso em projetos de <strong>c√≥digo aberto</strong> , mas para os propriet√°rios h√° limita√ß√µes significativas.  Recursos suportados: </p><br><ul><li>  transa√ß√µes </li><li>  log de failover antecipado para failover </li><li>  <strong>Criptografia de</strong> dados <strong>AES</strong> </li><li>  replica√ß√£o </li><li>  √≠ndices </li><li>  ferramentas de sincroniza√ß√£o para aplicativos multithread </li><li>  pol√≠tica de acesso - um escritor, muitos leitores </li><li>  cache </li></ul><br><p>  Assim como muitos outros. </p><br><p>  Quando o sistema √© inicializado, o usu√°rio pode especificar quais subsistemas usar.  Isso elimina o desperd√≠cio de recursos em opera√ß√µes como transa√ß√µes, log, bloqueios quando n√£o s√£o necess√°rios. </p><br><p>  A op√ß√£o de estrutura de armazenamento e acesso a dados est√° dispon√≠vel: </p><br><ul><li>  <strong>Btree</strong> - implementa√ß√£o de √°rvore balanceada classificada </li><li>  <strong>Hash</strong> - implementa√ß√£o linear de hash </li><li>  <strong>Pilha</strong> - usa um <em>arquivo de pilha</em> paginada logicamente para armazenamento.  Cada entrada √© identificada por uma p√°gina e um deslocamento dentro dela.  O armazenamento √© organizado de forma que a exclus√£o de um registro n√£o exija compacta√ß√£o.  Isso permite que voc√™ o use com falta de espa√ßo f√≠sico. </li><li>  <strong>Fila</strong> - uma fila que armazena registros de comprimento fixo com um n√∫mero l√≥gico como chave.  Ele foi projetado para inser√ß√£o r√°pida no final e suporta uma opera√ß√£o especial que remove e retorna uma entrada do in√≠cio da fila em uma √∫nica chamada. </li><li>  <strong>Recno</strong> - permite salvar registros de comprimentos fixos e vari√°veis ‚Äã‚Äãcom um n√∫mero l√≥gico como chave.  Fornece acesso a um elemento por seu √≠ndice. </li></ul><br><p>  Para evitar ambiguidade, √© necess√°rio definir v√°rios conceitos que s√£o usados ‚Äã‚Äãpara descrever o trabalho do <strong>Berkeley DB</strong> . </p><br><p>  <em>Banco de dados</em> √© um armazenamento de <em>dados de</em> valor-chave.  Um an√°logo do <strong>banco de</strong> dados <strong>Berkeley DB</strong> em outros DBMSs pode ser uma tabela. </p><br><p>  <em>Um ambiente de banco de dados</em> √© um inv√≥lucro para um ou mais <em>bancos de dados</em> .  Define configura√ß√µes gerais para todos os <em>bancos de dados</em> , como tamanho do cache, caminhos de armazenamento de arquivos, uso e configura√ß√£o de subsistemas de bloqueio, transa√ß√£o e log. </p><br><p>  Em um caso de uso t√≠pico, um <em>ambiente</em> √© criado e configurado e possui um ou mais <em>bancos de dados</em> . </p><br><h2 id="stl-interfeys">  Interface STL </h2><br><p>  <strong>Berkeley DB</strong> √© uma biblioteca escrita em <strong>C.</strong>  Possui ligantes para linguagens como <strong>Perl</strong> , <strong>Java</strong> , <strong>PHP</strong> e outros.  A interface para <strong>C ++</strong> √© um inv√≥lucro sobre c√≥digo <strong>C</strong> com objetos e heran√ßa.  Para tornar poss√≠vel acessar o banco de dados de maneira semelhante √†s opera√ß√µes com cont√™ineres <strong>STL</strong> , existe uma interface <strong>STL</strong> como um complemento sobre <strong>C ++</strong> .  Em uma forma gr√°fica, as camadas da interface s√£o assim: </p><br><p><img src="https://habrastorage.org/webt/k9/0u/gw/k90ugwajcb5xsts9zxn7e6urjew.png"></p><br><p> Portanto, a interface <strong>STL</strong> permite recuperar um elemento do banco de dados por chave (para <strong>Btree</strong> ou <strong>Hash</strong> ) ou por √≠ndice (para <strong>Recno</strong> ), semelhante aos <strong>cont√™ineres</strong> <code>std::map</code> ou <code>std::vector</code> ; encontre um elemento no banco de dados atrav√©s do <code>std::find_if</code> padr√£o <code>std::find_if</code> , itere sobre todo o banco de dados atrav√©s do <code>foreach</code> .  Todas as classes e fun√ß√µes da interface <strong>STL</strong> do <strong>Berkeley DB</strong> est√£o no espa√ßo de nomes <strong>dbstl</strong> ; em resumo, <strong>dbstl</strong> tamb√©m significa a interface <strong>STL</strong> . </p><br><h2 id="ustanovka">  Instala√ß√£o </h2><br><p>  O banco de dados suporta a maioria <strong>das</strong> <strong>plataformas</strong> <strong>Linux</strong> , <strong>Windows</strong> , <strong>Android</strong> , <strong>Apple iOS</strong> , etc. </p><br><p>  Para o <strong>Ubuntu 18.04,</strong> basta instalar os pacotes: </p><br><ul><li>  libdb5.3-stl-dev </li><li>  libdb5.3 ++ - dev </li></ul><br><p>  Para construir a partir de fontes <strong>Linux</strong> , voc√™ precisa instalar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">autoconf</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libtool</a> .  O c√≥digo-fonte mais recente pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Por exemplo, baixei o arquivo com a vers√£o <strong>18.1.32</strong> - db-18.1.32.zip.  Voc√™ precisa descompactar o arquivo morto e ir para a pasta de origem: </p><br><pre> <code class="plaintext hljs">unzip db-18.1.32.zip cd db-18.1.32</code> </pre> <br><p>  Em seguida, passamos para o diret√≥rio <strong>build_unix</strong> e executamos a montagem e instala√ß√£o: </p><br><pre> <code class="plaintext hljs">cd build_unix ../dist/configure --enable-stl --prefix=/home/user/libraries/berkeley-db make make install</code> </pre> <br><h2 id="dobavlenie-v-cmake-proekt">  Adicionando ao projeto cmake </h2><br><p>  O projeto <strong>BerkeleyDBSamples</strong> √© usado para ilustrar exemplos com o <strong>Berkeley DB</strong> . </p><br><p>  A estrutura do projeto √© a seguinte: </p><br><pre> <code class="plaintext hljs">+-- CMakeLists.txt +-- sample-usage | +-- CMakeLists.txt | +-- sample-map-usage.cpp | +-- submodules | +-- cmake | | +-- FindBerkeleyDB</code> </pre> <br><p>  A raiz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMakeLists.txt</a> descreve os par√¢metros gerais do projeto.  Os arquivos de origem de amostra est√£o em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso de amostra</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample-use / CMakeLists.txt</a> procura bibliotecas, define a montagem de exemplos. </p><br><p>  Em exemplos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FindBerkeleyDB</a> √© usado para conectar a biblioteca ao projeto <strong>cmake</strong> .  √â adicionado como um subm√≥dulo <strong>git</strong> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subm√≥dulos / cmake</a> .  Durante a montagem, pode ser necess√°rio especificar <code>BerkeleyDB_ROOT_DIR</code> .  Por exemplo, para a biblioteca acima instalada a partir das fontes, voc√™ deve especificar o sinalizador <strong>cmake</strong> <code>-DBerkeleyDB_ROOT_DIR=/home/user/libraries/berkeley-db</code> . </p><br><p>  No arquivo raiz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMakeLists.txt</a> , adicione o caminho ao m√≥dulo <strong>FindBerkeleyDB</strong> em <strong>CMAKE_MODULE_PATH</strong> : </p><br><pre> <code class="plaintext hljs">list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/submodules/cmake/FindBerkeleyDB")</code> </pre> <br><p>  Depois disso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample-use / CMakeLists.txt</a> realiza uma pesquisa de biblioteca da maneira padr√£o: </p><br><pre> <code class="plaintext hljs">find_package(BerkeleyDB REQUIRED)</code> </pre> <br><p>  Em seguida, adicione o arquivo execut√°vel e vincule-o √† biblioteca <strong>Oracle :: BerkeleyDB</strong> : </p><br><pre> <code class="plaintext hljs">add_executable(sample-map-usage "sample-map-usage.cpp") target_link_libraries(sample-map-usage PRIVATE Oracle::BerkeleyDB ${CMAKE_THREAD_LIBS_INIT} stdc++fs)</code> </pre> <br><h2 id="prakticheskiy-primer">  Exemplo pr√°tico </h2><br><p>  Para demonstrar o uso do <strong>dbstl, vamos</strong> examinar um exemplo simples do arquivo <a href="">sample-map-use.cpp</a> .  Este aplicativo demonstra o trabalho com o <code>dbstl::db_map</code> em um programa de thread √∫nico.  O cont√™iner em si √© semelhante ao <code>std::map</code> e armazena dados como um par de chave / valor.  A estrutura do banco de dados subjacente pode ser <strong>Btree</strong> ou <strong>Hash</strong> .  Diferentemente de <code>std::map</code> , para o <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> tipo de valor real √© <code>dbstl::ElementRef&lt;TestElement&gt;</code> .  Este tipo √© retornado, por exemplo, para <code>dbstl::db_map&lt;std::string, TestElement&gt;::operator[]</code> .  Ele define m√©todos para armazenar um objeto do tipo <code>TestElement</code> no banco de dados.  Um desses m√©todos √© <code>operator=</code> . </p><br><p>  No exemplo, o trabalho com o banco de dados √© o seguinte: </p><br><ul><li>  aplicativo chama m√©todos <strong>Berkeley DB</strong> para acessar dados </li><li>  esses m√©todos acessam o cache para leitura ou grava√ß√£o </li><li>  se necess√°rio, o acesso √© diretamente ao arquivo de dados </li></ul><br><p>  Graficamente, esse processo √© mostrado na figura: </p><br><p><img src="https://habrastorage.org/webt/xm/em/or/xmemorwh73yw9mnue-h1lp0gmbo.png"></p><br><p>  Para reduzir a complexidade do exemplo, ele n√£o usa o tratamento de exce√ß√µes.  Alguns <strong>m√©todos de</strong> cont√™iner <strong>dbstl</strong> podem lan√ßar exce√ß√µes quando ocorrem erros. </p><br><h2 id="razbor-koda">  An√°lise de c√≥digo </h2><br><p>  Para trabalhar com o <strong>Berkeley DB,</strong> voc√™ precisa conectar dois arquivos de cabe√ßalho: </p><br><pre> <code class="plaintext hljs">#include &lt;db_cxx.h&gt; #include &lt;dbstl_map.h&gt;</code> </pre> <br><p>  O primeiro adiciona primitivas da interface <strong>C ++</strong> e o segundo define classes e fun√ß√µes para trabalhar com o banco de dados, como em um cont√™iner associativo, bem como em muitos m√©todos utilit√°rios.  <strong>A</strong> interface <strong>STL</strong> est√° localizada no espa√ßo <strong>para</strong> nome <strong>dbstl</strong> . </p><br><p>  Para armazenamento, a estrutura <strong>Btree</strong> √© <strong>usada</strong> , <code>std::string</code> atua como a chave e o valor √© a estrutura do usu√°rio <code>TestElement</code> : </p><br><pre> <code class="plaintext hljs">struct TestElement{ std::string id; std::string name; };</code> </pre> <br><p>  Na fun√ß√£o <code>main</code> , inicialize a biblioteca chamando <code>dbstl::dbstl_startup()</code> .  Ele deve estar localizado antes do primeiro uso das primitivas da interface <strong>STL</strong> . </p><br><p>  Depois disso, inicializamos e abrimos <em>o ambiente do banco de dados</em> no diret√≥rio definido pela vari√°vel <code>ENV_FOLDER</code> : </p><br><pre> <code class="plaintext hljs">auto penv = dbstl::open_env(ENV_FOLDER, 0u, DB_INIT_MPOOL | DB_CREATE);</code> </pre> <br><p>  O sinalizador <code>DB_INIT_MPOOL</code> respons√°vel pela inicializa√ß√£o do subsistema de armazenamento em cache, <code>DB_CREATE</code> - pela cria√ß√£o de todos os arquivos necess√°rios para o ambiente.  A equipe tamb√©m registra esse objeto no gerenciador de recursos.  Ele √© respons√°vel por fechar todos os objetos registrados (objetos de banco de dados, cursores, transa√ß√µes etc. tamb√©m est√£o registrados nele) e limpar a mem√≥ria din√¢mica.  Se voc√™ j√° possui um objeto de <em>ambiente de banco de dados</em> e precisa registr√°-lo apenas no gerenciador de recursos, poder√° usar a fun√ß√£o <code>dbstl::register_db_env</code> . </p><br><p>  Uma opera√ß√£o semelhante √© realizada com <em>o banco de dados</em> : </p><br><pre> <code class="plaintext hljs">auto db = dbstl::open_db(penv, "sample-map-usage.db", DB_BTREE, DB_CREATE, 0u);</code> </pre> <br><p>  Os dados no disco ser√£o gravados no <strong>arquivo sample-map-use.db</strong> , que ser√° criado na aus√™ncia (gra√ßas ao sinalizador <code>DB_CREATE</code> ) no diret√≥rio <code>ENV_FOLDER</code> .  Uma √°rvore √© usada para armazenamento (par√¢metro <code>DB_BTREE</code> ). </p><br><p>  No <strong>Berkeley DB,</strong> chaves e valores s√£o armazenados como uma matriz de bytes.  Para usar um tipo personalizado (no nosso caso <code>TestElement</code> ), voc√™ deve definir fun√ß√µes para: </p><br><ul><li>  receber o n√∫mero de bytes para armazenar o objeto; </li><li>  organizar um objeto em uma matriz de bytes; </li><li>  desembara√ßar. </li></ul><br><p>  No exemplo, essa funcionalidade √© executada pelos m√©todos est√°ticos da classe <code>TestMarshaller</code> .  Ele <code>TestElement</code> objetos <code>TestElement</code> na mem√≥ria da seguinte maneira: </p><br><ul><li>  o comprimento do campo <code>id</code> √© copiado para o in√≠cio do buffer </li><li>  pr√≥ximo byte, o conte√∫do do campo <code>id</code> √© colocado </li><li>  depois, o tamanho do campo de <code>name</code> √© copiado </li><li>  ent√£o o conte√∫do em si √© colocado no campo de <code>name</code> </li></ul><br><p><img src="https://habrastorage.org/webt/ko/ad/ul/koaduleknjbnfvapxlo6wff4qvm.png"></p><br><p>  N√≥s descrevemos as fun√ß√µes do <code>TestMarshaller</code> : </p><br><ul><li>  <code>TestMarshaller::restore</code> - preenche o objeto <code>TestElement</code> com dados do buffer </li><li>  <code>TestMarshaller::size</code> - retorna o tamanho do buffer necess√°rio para salvar o objeto especificado. </li><li>  <code>TestMarshaller::store</code> - salva o objeto no buffer. </li></ul><br><p>  Para registrar fun√ß√µes de empacotamento / <code>dbstl::DbstlElemTraits</code> , use <code>dbstl::DbstlElemTraits</code> : </p><br><pre> <code class="plaintext hljs">dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_size_function(&amp;TestMarshaller::size); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_copy_function(&amp;TestMarshaller::store); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_restore_function( &amp;TestMarshaller::restore );</code> </pre> <br><p>  Inicialize o cont√™iner: </p><br><pre> <code class="plaintext hljs">dbstl::db_map&lt;std::string, TestElement&gt; elementsMap(db, penv);</code> </pre> <br><p>  √â assim que a c√≥pia de elementos do <code>std::map</code> para o cont√™iner criado se parece: </p><br><pre> <code class="plaintext hljs">std::copy( std::cbegin(inputValues), std::cend(inputValues), std::inserter(elementsMap, elementsMap.begin()) );</code> </pre> <br><p>  Mas, dessa maneira, voc√™ pode imprimir o conte√∫do do banco de dados na sa√≠da padr√£o: </p><br><pre> <code class="plaintext hljs">std::transform( elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true), elementsMap.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), [](const auto data) -&gt; std::string { return data.first + "=&gt; { id: " + data.second.id + ", name: " + data.second.name + "}"; });</code> </pre> <br><p>  Chamar o m√©todo <code>begin</code> no exemplo acima parece um pouco incomum: <code>elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true)</code> . <br>  Esse design √© usado para obter <em>um</em> iterador <em>somente leitura</em> .  <strong>O dbstl</strong> n√£o define o m√©todo <code>cbegin</code> ; em vez disso, o par√¢metro <code>readonly</code> (o segundo) no m√©todo <code>begin</code> √© usado.  Voc√™ tamb√©m pode usar uma <em>refer√™ncia constante</em> ao cont√™iner para obter <em>um</em> iterador <em>somente leitura</em> .  Esse iterador permite apenas uma opera√ß√£o de leitura; ao escrever, gera uma exce√ß√£o. </p><br><p>  Por que o iterador <em>somente leitura</em> √© usado no c√≥digo acima?  Primeiramente, ele <em>apenas</em> executa uma opera√ß√£o de leitura atrav√©s de um iterador.  Em segundo lugar, a documenta√ß√£o diz que tem <em>melhor</em> desempenho em compara√ß√£o com a vers√£o regular. </p><br><p>  Adicionar um novo par de chave / valor ou, se a chave j√° existir, atualizar o valor √© t√£o simples quanto em <code>std::map</code> : </p><br><pre> <code class="plaintext hljs">elementsMap["added key 1"] = {"added id 1", "added name 1"};</code> </pre> <br><p>  Como mencionado acima, a instru√ß√£o <code>elementsMap["added key 1"]</code> retorna uma classe de wrapper com <code>operator=</code> redefined, cuja chamada subsequente armazena diretamente o objeto no banco de dados. </p><br><p>  Se voc√™ precisar inserir um item em um cont√™iner: </p><br><pre> <code class="plaintext hljs">auto [iter, res] = elementsMap.insert( std::make_pair(std::string("added key 2"), TestElement{"added id 2", "added name 2"}) );</code> </pre> <br><p>  A chamada para <code>elementsMap.insert</code> retorna <code>std::pair&lt;,  &gt;</code> .  Se o objeto n√£o puder ser inserido, o <em>sinalizador de sucesso</em> ser√° <strong>falso</strong> .  Caso contr√°rio, <em>o sinalizador de sucesso</em> cont√©m <strong>true</strong> e o <em>iterador</em> aponta para o objeto inserido. </p><br><p>  Outra maneira de encontrar o valor pela chave √© usar o <code>dbstl::db_map::find</code> , semelhante ao <code>std::map::find</code> : </p><br><pre> <code class="plaintext hljs">auto findIter = elementsMap.find("test key 1");</code> </pre> <br><p>  Por meio do iterador obtido, √© poss√≠vel acessar a chave - <code>findIter-&gt;first</code> , nos campos do elemento <code>findIter-&gt;second.id</code> - <code>findIter-&gt;second.id</code> e <code>findIter-&gt;second.name</code> .  Para extrair um par de <em>chave</em> / <em>valor</em> , o operador de desrefer√™ncia √© usado - <code>auto iterPair = *findIter;</code>  . </p><br><p>  Quando o operador de desreferenciamento ( <strong>*</strong> ) ou o acesso a um membro da classe ( <strong>-&gt;</strong> ) √© aplicado ao iterador, o banco de dados √© acessado e os dados s√£o extra√≠dos.  Al√©m disso, os dados extra√≠dos anteriormente, mesmo que tenham sido modificados, s√£o apagados.  Isso significa que, no exemplo abaixo, as altera√ß√µes feitas no iterador ser√£o descartadas e o valor armazenado no banco de dados ser√° exibido no console. </p><br><pre> <code class="plaintext hljs">findIter-&gt;second.id = "skipped id"; findIter-&gt;second.name = "skipped name"; std::cout &lt;&lt; "Found elem for key " &lt;&lt; "test key 1" &lt;&lt; ": id: " &lt;&lt; findIter-&gt;second.id &lt;&lt; ", name: " &lt;&lt; findIter-&gt;second.name &lt;&lt; std::endl;</code> </pre> <br><p>  Para evitar isso, voc√™ precisa obter o wrapper do objeto armazenado do iterador chamando <code>findIter-&gt;second</code> e salv√°-lo em uma vari√°vel.  Em seguida, fa√ßa todas as altera√ß√µes nesse wrapper e <code>_DB_STL_StoreElement</code> o resultado no banco de dados chamando o m√©todo de wrapper <code>_DB_STL_StoreElement</code> : </p><br><pre> <code class="plaintext hljs">auto ref = findIter-&gt;second; ref.id = "new test id 1"; ref.name = "new test name 1"; ref._DB_STL_StoreElement();</code> </pre> <br><p>  A atualiza√ß√£o dos dados pode ser ainda mais f√°cil - basta obter o wrapper com a <code>findIter-&gt;second</code> e atribuir o objeto <code>TestElement</code> desejado, como no exemplo: </p><br><pre> <code class="plaintext hljs">if(auto findIter = elementsMap.find("test key 2"); findIter != elementsMap.end()){ findIter-&gt;second = {"new test id 2", "new test name 2"}; }</code> </pre> <br><p>  Antes de finalizar o programa, voc√™ deve chamar <code>dbstl::dbstl_exit();</code>  fechar e excluir todos os objetos registrados no gerenciador de recursos. </p><br><h2 id="v-zaklyuchenii">  Em conclus√£o </h2><br><p>  Este artigo fornece uma breve vis√£o geral dos principais recursos dos cont√™ineres <code>dbstl::db_map</code> <strong>usando</strong> <code>dbstl::db_map</code> como um <code>dbstl::db_map</code> em um programa simples de thread √∫nico.  Esta √© apenas uma pequena introdu√ß√£o e n√£o abordou recursos como transacionalidade, bloqueio, gerenciamento de recursos, tratamento de exce√ß√µes e execu√ß√£o multithread. </p><br><p>  N√£o pretendi descrever detalhadamente os m√©todos e seus par√¢metros; para isso, √© melhor consultar a documenta√ß√£o correspondente na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface C ++</a> e na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface STL</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459862/">https://habr.com/ru/post/pt459862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459844/index.html">Pinguim na janela: sobre o potencial e as perspectivas do WSL2</a></li>
<li><a href="../pt459850/index.html">Tecnologia de r√°dio amador: como eu pedi a instala√ß√£o de uma placa de circuito impresso em uma f√°brica chinesa</a></li>
<li><a href="../pt459852/index.html">A pr√°tica de usar a biblioteca lottie no aplicativo m√≥vel do banco</a></li>
<li><a href="../pt459858/index.html">Explorando o Malware Moderno Cerberus para Android</a></li>
<li><a href="../pt459860/index.html">Configurando o ClickHouse para teste de integra√ß√£o no gitlab-ci</a></li>
<li><a href="../pt459866/index.html">Solu√ß√£o de problemas com pwnable.kr 02 - colis√£o. Colis√£o de Hash</a></li>
<li><a href="../pt459870/index.html">Exemplo de arquitetura Model-View-Update em F #</a></li>
<li><a href="../pt459872/index.html">Patton Jeff. Hist√≥rias personalizadas. A arte do desenvolvimento √°gil de software</a></li>
<li><a href="../pt459874/index.html">Voc√™ tem algo a esconder</a></li>
<li><a href="../pt459878/index.html">7 dicas de otimiza√ß√£o de CSS para acelerar o carregamento da p√°gina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>