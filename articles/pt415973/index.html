<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 🎱 👨‍🎨 Como não quebrar o cluster do Apache Ignite desde o início 🧝 👩🏾‍🏫 👨🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Abaixo está uma transcrição do vídeo do discurso no comício da comunidade Apache Ignite em São Petersburgo, em 20 de junho. Você pode baixar os sli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como não quebrar o cluster do Apache Ignite desde o início</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/415973/"><p>  Oi  Abaixo está uma transcrição do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeo do</a> discurso no comício da comunidade Apache Ignite em São Petersburgo, em 20 de junho.  Você pode baixar os slides <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zrMWgNyvQVI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Há toda uma classe de problemas que os usuários iniciantes enfrentam.  Eles acabaram de baixar o Apache Ignite, executam as duas, três, dez primeiras e chegam até nós com perguntas que são resolvidas de maneira semelhante.  Portanto, proponho a criação de uma lista de verificação que poupará muito tempo e nervos quando você criar seus primeiros aplicativos Apache Ignite.  Falaremos sobre os preparativos para o lançamento;  como fazer o cluster montar;  como iniciar alguns cálculos na grade de computação;  Como preparar um modelo e código de dados para que você possa gravar seus dados no Ignite e depois lê-los com sucesso.  E o mais importante: como não quebrar nada desde o início. </p><a name="habracut"></a><br><h2>  Preparação para o lançamento - configurar o log </h2><br><p>  Precisamos de logs.  Se você já fez uma pergunta na lista de correspondência do Apache Ignite ou no StackOverflow, como "por que tudo desligou", provavelmente a primeira coisa que você foi solicitado a enviar foi todos os logs de todos os nós. </p><br><p> Naturalmente, o registro do Apache Ignite é ativado por padrão.  Mas existem nuances.  Primeiro, o Apache Ignite escreve um pouco no <code>stdout</code> .  Por padrão, ele inicia no chamado modo silencioso.  No <code>stdout</code> você verá apenas os erros mais terríveis e tudo o mais será salvo em um arquivo, o caminho no qual o Apache Ignite exibe no início (por padrão - <code>${IGNITE_HOME}/work/log</code> ).  Você não apaga e mantém os logs mais longos, pode ser muito útil. </p><br><p>  <b><code>stdout</code> inflama na inicialização padrão</b> </p><br><p><img src="https://habrastorage.org/webt/dg/wf/4r/dgwf4rf9on5vckayvxqzcbtr5tk.png"></p><br><p>  Para facilitar a descoberta de problemas sem entrar em arquivos separados e configurar o monitoramento separado para o Apache Ignite, você pode executá-lo no modo detalhado com o comando </p><br><pre> <code class="bash hljs">ignite.sh -v</code> </pre> <br><p>  e o sistema começará a escrever sobre todos os eventos no <code>stdout</code> junto com o restante do log do aplicativo. </p><br><p>  Verifique os logs!  Muitas vezes, você pode encontrar soluções para seus problemas.  Se o cluster entrou em colapso, muitas vezes no log, você pode ver mensagens como “Aumente esse tempo limite em tal configuração.  Caímos por causa dele.  Ele é muito pequeno.  A rede não é boa o suficiente. ” </p><br><h2>  Montagem de cluster </h2><br><h3>  Convidados não convidados </h3><br><p>  O primeiro problema que muitos enfrentam são os convidados não convidados no seu cluster.  Ou você acaba sendo um convidado não convidado: inicie um novo cluster e, de repente, verá que, na primeira captura instantânea de topologia, em vez de um nó, você tem dois servidores desde o início.  Como assim?  Você lançou apenas um. </p><br><p>  <b>Uma mensagem indicando que o cluster possui dois nós</b> </p><br><p><img src="https://habrastorage.org/webt/l9/fd/kd/l9fdkdt9vvoaryo1fk84agizhvi.png"></p><br><p>  O fato é que, por padrão, o Apache Ignite usa Multicast e, na inicialização, ele procura todos os outros Apache Ignite que estão na mesma sub-rede, no mesmo grupo Multicast.  E se isso acontecer, ele tentará se conectar.  E, no caso de uma conexão malsucedida, ela não será iniciada.  Portanto, no cluster do meu laptop de trabalho, nós extras do cluster no laptop do colega aparecem regularmente regularmente, o que obviamente não é muito conveniente. </p><br><p>  Como se proteger disso?  A maneira mais fácil de configurar o IP estático.  Em vez de <code>TcpDiscoveryMulticastIpFinder</code> , que é usado por padrão, existe <code>TcpDiscoveryVmIpFinder</code> .  Lá, anote todos os IP e portas às quais você está se conectando.  Isso é muito mais conveniente e o protegerá de um grande número de problemas, especialmente em ambientes de desenvolvimento e teste. </p><br><h3>  Muitos endereços </h3><br><p>  O próximo problema.  Você desabilitou o Multicast, inicia o cluster, em uma única configuração, define uma quantidade decente de IP de diferentes ambientes.  E acontece que você inicia o primeiro nó em um cluster novo por 5 a 10 minutos, embora todos os subseqüentes se conectem a ele em 5 a 10 segundos. </p><br><p>  Faça uma lista de três endereços IP.  Para cada um, prescrevemos intervalos de 10 portas.  No total, 30 endereços TCP são obtidos.  Como o Apache Ignite deve tentar se conectar a um cluster existente antes de criar um novo cluster, ele verificará cada IP sucessivamente.  Pode não causar danos ao seu laptop, mas a proteção de varredura de portas geralmente está incluída em alguns ambientes nublados.  Ou seja, ao acessar uma porta privada em algum endereço IP, você não receberá nenhuma resposta até que o tempo limite termine.  Por padrão, são 10 segundos.  E se você tiver 3 endereços de 10 portas, terá 3 * 10 * 10 = 300 segundos de espera - os mesmos 5 minutos para se conectar. </p><br><p>  A solução é óbvia: não registre portas desnecessárias.  Se você possui três IPs, dificilmente precisará de um intervalo padrão de 10 portas.  Isso é conveniente quando você testa algo na máquina local e executa 10 nós.  Mas em sistemas reais, uma única porta geralmente é suficiente.  Ou desative a proteção contra a varredura de portas na rede interna, se você tiver essa oportunidade. </p><br><p>  O terceiro problema comum é o IPv6.  Você pode ver mensagens de erro de rede estranhas: não foi possível conectar, não foi possível enviar uma mensagem, nó segmentado.  Isso significa que você caiu do cluster.  Muitas vezes, esses problemas são causados ​​por ambientes mistos do IPv4 e IPv6.  Isso não quer dizer que o Apache Ignite não suporte IPv6, mas no momento existem alguns problemas. </p><br><p>  A solução mais fácil é passar a opção para a máquina Java </p><br><pre> <code class="hljs objectivec">-Djava.net.preferIPv4Stack=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  O Java e o Apache Ignite não usarão o IPv6.  Isso resolve uma parte significativa dos problemas com agrupamentos em colapso. </p><br><h2>  Preparação da base de código - serializamos corretamente </h2><br><p>  O cluster se reuniu, é necessário iniciar algo nele.  Um dos elementos mais importantes na interação do seu código com o código Apache Ignite é o Marshaller, ou serialização.  Para escrever algo na memória, persistência e enviar pela rede, o Apache Ignite primeiro serializa seus objetos.  Você pode ver as mensagens que começam com as palavras: "não pode ser escrito em formato binário" ou "não pode ser serializado usando o BinaryMarshaller".  Haverá apenas um aviso no log, mas perceptível.  Isso significa que você precisa ajustar um pouco mais o seu código para fazer amizade com o Apache Ignite. </p><br><p>  O Apache Ignite usa três mecanismos para serialização: </p><br><ul><li>  <code>JdkMarshaller</code> - serialização Java regular; </li><li>  <code>OptimizedMarshaller</code> - serialização Java ligeiramente otimizada, mas os mecanismos são os mesmos; </li><li>  <code>BinaryMarshaller</code> é uma serialização escrita especificamente para o Apache Ignite, usada em todos os lugares.  Ela tem várias vantagens.  Em algum lugar, podemos evitar serialização e desserialização adicionais e, em algum lugar, podemos até obter um objeto não desserializado na API, trabalhar com ele diretamente em formato binário, como em algo como JSON. </li></ul><br><p>  <code>BinaryMarshaller</code> poderá serializar e desserializar seus POJOs que não possuem nada além de campos e métodos simples.  Mas se você tiver serialização personalizada via <code>readObject()</code> e <code>writeObject()</code> , se você usar <code>Externalizable</code> , o <code>BinaryMarshaller</code> não suportará.  Ele verá que seu objeto não pode ser serializado pela gravação usual de campos não transitórios e desistirá - ele reverterá para o <code>OptimizedMarshaller</code> . </p><br><p>  Para fazer amizade com esses objetos com o Apache Ignite, você precisa implementar a interface <code>Binarylizable</code> .  Ele é muito simples. </p><br><p>  Por exemplo, existe um <code>TreeMap</code> padrão de Java.  Possui serialização e desserialização personalizadas via objeto de leitura e gravação.  Primeiro descreve alguns campos e, em seguida, grava o comprimento e os próprios dados no <code>OutputStream</code> . </p><br><p>  <b>Implementação de <code>TreeMap.writeObject()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> java.io.IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } }</span></span></code> </pre> <br><p>  <code>writeBinary()</code> e <code>readBinary()</code> de <code>Binarylizable</code> funcionam exatamente da mesma maneira: <code>BinaryTreeMap</code> envolve em um <code>BinaryTreeMap</code> regular e grava-o em <code>OutputStream</code> .  Esse método é fácil de escrever e aumentará bastante a produtividade. </p><br><p>  <b><code>BinaryTreeMap.writeBinary()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBinary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryWriter writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BinaryObjectException </span></span>{ BinaryRawWriter rewriter = writer. rewrite (); rawWriter.writeObject(map.comparator()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = map.size(); rawWriter.writeInt(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;Object, Object&gt; entry : ((TreeMap&lt;Object, Object&gt;)map).entrySet()) { rawWriter.writeObject(entry.getKey()); rawWriter.writeObject(entry.getValue()); } }</code> </pre> <br><h2>  Iniciar na grade de computação </h2><br><p>  O Ignite não apenas permite armazenar dados, mas também executar computação distribuída.  Como executamos algum tipo de lambda para dispersar todos os servidores e executar? <br>  Para iniciantes, qual é o problema com esses exemplos de código? </p><br><p>  <b>Qual é o problema?</b> </p><br><pre> <code class="java hljs">Foo foo = …; Bar bar = ...; ignite.compute().broadcast( () -&gt; doStuffWithFooAndBar(foo, bar) );</code> </pre> <br><p>  <b>E se sim?</b> </p><br><pre> <code class="java hljs">Foo foo = …; Bar bar = ...; ignite.compute().broadcast(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IgniteRunnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ doStuffWithFooAndBar(foo, bar); } });</code> </pre> <br><p>  Como você pode imaginar, muitos familiarizados com as armadilhas de lambdas e classes anônimas, o problema está em capturar variáveis ​​de fora.  Por exemplo, enviamos lambda.  Ele usa algumas variáveis ​​declaradas fora do lambda.  Isso significa que essas variáveis ​​viajam com ela e voam pela rede para todos os servidores.  E então surgem as mesmas perguntas: esses objetos são amigáveis ​​com o <code>BinaryMarshaller</code> ?  Qual o tamanho deles?  Em geral, queremos que eles sejam transferidos para algum lugar ou esses objetos são tão grandes que é melhor passar algum tipo de ID e recriar os objetos dentro do lambda que já estão do outro lado? </p><br><p>  A classe anônima é ainda pior.  Se o lambda não puder levar isso com você, jogue-o fora, se não for usado, a classe anônima o levará com certeza, e isso geralmente não leva a nada de bom. </p><br><p>  O exemplo a seguir.  Lambda novamente, mas que usa a API Apache Ignite um pouco. </p><br><p>  <b>Usar ignição no fechamento da computação está <em>errado</em></b> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = ignite.cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre> <br><p>  Na versão original, ele pega o cache e faz localmente algum tipo de consulta SQL.  Esse é um padrão quando você precisa enviar uma tarefa que funciona apenas com dados locais em nós remotos. </p><br><p>  Qual é o problema aqui?  O lambda novamente captura o link, mas agora não para o objeto, mas para o Ignite local no nó com o qual o enviamos.  E até funciona, porque o objeto Ignite possui um método <code>readResolve()</code> , que permite que a desserialização substitua o Ignite que veio pela rede pelo local no nó para onde o enviamos.  Mas isso também às vezes leva a consequências indesejáveis. </p><br><p>  Basicamente, você está simplesmente transferindo mais dados pela rede do que gostaria.  Se você precisar obter algum código que não controla a inicialização no Apache Ignite ou algumas de suas interfaces, o mais simples é usar o método <code>Ignintion.localIgnite()</code> .  Você pode chamá-lo a partir de qualquer thread que o Apache Ignite criou e obter um link para um objeto local.  Se você tem lambdas, serviços, qualquer coisa e entende que precisa do Ignite aqui, recomendo este método. </p><br><p>  <strong>Usamos Ignite corretamente no fechamento da computação - através de <code>localIgnite()</code></strong> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = Ignition.localIgnite().cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre><br><p>  E o último exemplo nesta parte.  O Apache Ignite possui uma Service Grid que pode ser usada para implantar microsserviços diretamente em um cluster, e o Apache Ignite ajudará a manter on-line o número certo de instâncias.  Digamos que neste serviço também precisamos de um link para o Apache Ignite.  Como conseguir isso?  Poderíamos usar <code>localIgnite()</code> , mas esse link deverá ser salvo manualmente no campo. </p><br><p>  <strong>O serviço armazena Ignite em um campo <em>incorretamente</em> - leva isso como argumento para o construtor</strong> </p><br><pre> <code class="java hljs">MyService s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(ignite) ignite.services().deployClusterSingleton(<span class="hljs-string"><span class="hljs-string">"svc"</span></span>, s); ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ignite ignite)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ignite = ignite; } ... }</code> </pre> <br><p>  Existe uma maneira mais simples.  Ainda temos classes completas, e não lambda, para que possamos anotar o campo como <code>@IgniteInstanceResource</code> .  Quando o serviço é criado, o Apache Ignite se coloca lá e você pode usá-lo com segurança.  Eu recomendo fortemente que você faça exatamente isso, e não tente passar o Apache Ignite e seus filhos para o construtor. </p><br><p>  <strong>O serviço usa <code>@IgniteInstanceResource</code></strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IgniteInstanceResource</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } ... }</code> </pre> <br><h2>  Escrevendo e lendo dados </h2><br><h3>  Observando a linha de base </h3><br><p>  Agora temos um cluster Apache Ignite e um código preparado. </p><br><p>  Vamos imaginar este cenário: </p><br><ul><li>  Um cache <code>REPLICATED</code> - cópias de dados estão disponíveis em todos os nós; </li><li>  A persistência nativa está ativada - escreve no disco. </li></ul><br><p>  Começamos um nó.  Como a persistência nativa está ativada, precisamos ativar o cluster antes de trabalhar com ele.  Ative.  Em seguida, lançamos mais alguns nós. <br>  Tudo parece estar funcionando: escrever e ler estão bem.  Todos os nós têm cópias dos dados; você pode parar com segurança um nó.  Mas se você parar o primeiro nó a partir do qual você iniciou o lançamento, tudo será interrompido: os dados desaparecem e as operações param de passar. </p><br><p>  O motivo disso é a topologia de linha de base - os muitos nós que armazenam dados de persistência neles.  Todos os outros nós não terão dados persistentes. </p><br><p>  Este conjunto de nós pela primeira vez é determinado no momento da ativação.  E os nós que você adicionou posteriormente não são mais incluídos no número de nós da linha de base.  Ou seja, muita topologia de linha de base consiste em apenas um, o primeiro nó, quando para, tudo quebra.  Para impedir que isso aconteça, inicie todos os nós primeiro e, em seguida, ative o cluster.  Se você precisar adicionar ou remover um nó usando o comando </p><br><pre> <code class="bash hljs">control.sh --baseline</code> </pre> <br><p>  Você pode ver quais nós estão listados lá.  O mesmo script pode atualizar a linha de base para seu estado atual. </p><br><p>  <b>Exemplo <code>control.sh</code></b> </p><br><p><img src="https://habrastorage.org/webt/nw/6d/fy/nw6dfy5onsssvkwsw1vmwaxczm4.png"></p><br><h3>  Colocação de dados </h3><br><p>  Agora sabemos que os dados são salvos, tente lê-los.  Temos suporte SQL, você pode fazer o <code>SELECT</code> - quase como no Oracle.  Mas, ao mesmo tempo, podemos escalar e executar em qualquer número de nós, os dados são armazenados de maneira distribuída.  Vejamos esse modelo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long orgId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Organization</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p>  Pedido </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Organization</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.orgId = o.id</code> </pre> <br><p>  não retornará todos os dados.  O que está errado? </p><br><p>  Pessoa ( <code>Person</code> ) refere-se à organização ( <code>Organization</code> ) por ID.  Esta é uma chave estrangeira clássica.  Mas se tentarmos combinar as duas tabelas e enviar essa consulta SQL, com vários nós no cluster, não receberemos todos os dados. </p><br><p>  O fato é que, por padrão, o SQL <code>JOIN</code> funciona apenas em um único nó.  Se o SQL constantemente percorresse todo o cluster para coletar dados e retornar o resultado completo, seria incrivelmente lento.  Perderíamos todos os benefícios de um sistema distribuído.  Portanto, o Apache Ignite analisa apenas os dados locais. </p><br><p>  Para obter os resultados corretos, precisamos colocar os dados juntos (colocation).  Ou seja, para a combinação correta de Pessoa e Organização, os dados de ambas as tabelas devem ser armazenados no mesmo nó. </p><br><p>  Como fazer isso?  A solução mais fácil é declarar uma chave de afinidade.  Este é um valor que determina em qual nó, em qual partição, em qual grupo de registros esse ou aquele valor será localizado.  Se declararmos o ID da organização em <code>Person</code> como uma chave de afinidade, isso significa que as pessoas com esse ID da organização devem estar no mesmo nó que a organização com o mesmo ID. </p><br><p>  Se, por algum motivo, você não puder fazer isso, existe outra solução menos eficaz - habilite as junções distribuídas.  Isso é feito por meio da API e o procedimento depende do que você usa - Java, JDBC ou qualquer outra coisa.  <code>JOIN</code> serão executados mais lentamente, mas retornarão os resultados corretos. </p><br><p>  Vamos considerar como trabalhar com chaves de afinidade.  Como entendemos que tal e tal ID, tal e tal campo são adequados para determinar a afinidade?  Se dissermos que todas as pessoas com o mesmo <code>orgId</code> serão armazenadas juntas, o <code>orgId</code> é um grupo indivisível.  Não podemos distribuí-lo entre vários nós.  Se o banco de dados contiver 10 organizações, haverá 10 grupos indivisíveis que podem ser colocados em 10 nós.  Se houver mais nós no cluster, todos os nós "extras" permanecerão sem grupos.  Isso é muito difícil de definir em tempo de execução, então pense nisso antes. </p><br><p>  Se você tem uma organização grande e 9 pequenas, o tamanho dos grupos será diferente.  Mas o Apache Ignite não analisa o número de registros nos grupos de afinidade quando os distribui pelos nós.  Portanto, ele não colocará um grupo em um nó, mas outros 9 em outro para, de alguma forma, nivelar a distribuição.  Em vez disso, ele os colocará 5 e 5 (ou 6 e 4, ou mesmo 7 e 3). </p><br><p>  Como tornar os dados distribuídos uniformemente?  Que possamos ter </p><br><ul><li>  Teclas K; </li><li>  Uma variedade de chaves de afinidade; </li><li>  Partições P, ou seja, grandes grupos de dados que o Apache Ignite distribuirá entre nós; </li><li>  N nós. </li></ul><br><p>  Então é necessário que a condição </p><br><pre> <code class="hljs ruby">K <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>A &gt;&gt; P &gt;&gt; N</code> </pre> <br><p>  onde <code>&gt;&gt;</code> é "muito mais" e os dados serão distribuídos de maneira relativamente uniforme. </p><br><p>  A propósito, o padrão é P = 1024. </p><br><p>  Muito provavelmente você não terá sucesso em uma distribuição uniforme.  Este foi o caso no Apache Ignite 1.x a 1.9.  Isso foi chamado <code>FairAffinityFunction</code> e não funcionou muito bem - resultou em muito tráfego entre os nós.  Agora, o algoritmo é chamado <code>RendezvousAffinityFunction</code> .  Ele não fornece uma distribuição absolutamente honesta, o erro entre os nós será mais ou menos 5-10%. </p><br><h2>  Lista de verificação para novos usuários do Apache Ignite </h2><br><ol><li>  Configurar, ler, armazenar logs </li><li>  Desative o multicast, anote apenas os endereços e portas que você usa </li><li>  Desativar IPv6 </li><li>  Prepare suas aulas para o <code>BinaryMarshaller</code> </li><li>  Acompanhe sua linha de base </li><li>  Configurar disposição de afinidade </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415973/">https://habr.com/ru/post/pt415973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415961/index.html">Armazenamento distribuído russo. Como funciona</a></li>
<li><a href="../pt415963/index.html">Naive Bayes, ou como a matemática permite filtrar spam</a></li>
<li><a href="../pt415965/index.html">O que ler em julho: 19 novos livros para profissionais digitais</a></li>
<li><a href="../pt415967/index.html">SolidFire - Armazenamento para aqueles ** que odeiam armazenamento</a></li>
<li><a href="../pt415969/index.html">HyperX Pulsefire Surge RGB - um assassino natural</a></li>
<li><a href="../pt415975/index.html">Os chineses introduziram uma arma laser com alcance de quase um quilômetro</a></li>
<li><a href="../pt415977/index.html">Túneis e VPNs resistentes a DPI</a></li>
<li><a href="../pt415979/index.html">Semana de Segurança 24: Rowhammer no Android e a complexidade das vulnerabilidades de hardware</a></li>
<li><a href="../pt415981/index.html">Google e HTTP</a></li>
<li><a href="../pt415983/index.html">Universo primitivo 5. Redshift cosmológico e dinâmica de um universo em expansão uniforme, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>