<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏼 👨‍🚀 👍 Lösen japanischer Kreuzworträtsel mit P̶y̶t̶h̶o̶̶n̶ Rust und WebAssembly 🦀 🐿️ 👨🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um einen Nicht-Programm-Solver für Python zu erstellen, schreiben Sie ihn in Rust um, um ihn über WebAssembly direkt im Browser auszuführen. 


 TL; D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lösen japanischer Kreuzworträtsel mit P̶y̶t̶h̶o̶̶n̶ Rust und WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Rostlogo als Nonogramm"></p><br><p>  Um einen Nicht-Programm-Solver für Python zu erstellen, schreiben Sie ihn in Rust um, um ihn über WebAssembly direkt im Browser auszuführen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Starten Sie </h2><br><p>  Über japanische Kreuzworträtsel (Nonogramme) auf dem Habré gab es bereits mehrere Beiträge.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> <br>  und noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> . </p><br><blockquote>  Bilder werden mit Zahlen verschlüsselt, die sich links neben den Zeilen sowie über den Spalten befinden.  Die Anzahl der Zahlen gibt an, wie viele Gruppen schwarzer Zellen (oder deren Farbe für Farbkreuzworträtsel) in der entsprechenden Zeile oder Spalte enthalten sind, und die Zahlen selbst - wie viele zusammengeführte Zellen jede dieser Gruppen enthält (z. B. eine Reihe von drei Zahlen - 4, 1 und 3) bedeutet, dass es in dieser Zeile drei Gruppen gibt: die erste - von vier, die zweite - von einer, die dritte - von drei schwarzen Zellen).  In einem Schwarz-Weiß-Kreuzworträtsel müssen die Gruppen durch mindestens eine leere Zelle getrennt sein. Im Farbkreuzworträtsel gilt diese Regel nur für einfarbige Gruppen, und mehrfarbige Gruppen können eng beieinander liegen (leere Zellen können sich auch entlang der Ränder der Zeilen befinden).  Es ist notwendig, den Ort der Zellgruppen zu bestimmen. </blockquote><p>  Eine der am weitesten verbreiteten Gesichtspunkte ist, dass nur diejenigen, die auf "logische" Weise gelöst werden, als "richtige" Kreuzworträtsel bezeichnet werden können.  Dies wird normalerweise als Lösungsmethode bezeichnet, bei der Abhängigkeiten zwischen verschiedenen Zeilen und / oder Spalten nicht berücksichtigt werden.  Mit anderen Worten, eine Lösung ist eine Folge <strong>unabhängiger</strong> Entscheidungen einzelner Zeilen oder Spalten, bis alle Zellen gefüllt sind (mehr zum Algorithmus unten).  Beispielsweise finden Sie auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://nonograms.org/</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://nonograms.ru/</a> ) nur solche Nichtogramme.  Nonogramme von dieser Site wurden bereits als Beispiel im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lösen japanischer Farbkreuzworträtsel mit Lichtgeschwindigkeit</a> angeführt.  Zu Vergleichs- und Überprüfungszwecken hat mein Solver auch Unterstützung für das Herunterladen und Parsen von Kreuzworträtseln von dieser Site hinzugefügt (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">KyberPrizrak</a> für die Erlaubnis, Materialien von seiner Site zu verwenden). </p><br><p>  Das Konzept der Nichtogramme kann jedoch auf ein allgemeineres Problem erweitert werden, wenn die übliche "logische" Methode zu einer Sackgasse führt.  In solchen Fällen muss man eine Annahme über die Farbe einer Zelle machen und nach dem Nachweis, dass diese Farbe zu einem Widerspruch führt, die entgegengesetzte Farbe für diese Zelle markieren.  Die Abfolge solcher Schritte kann (wenn Sie die Geduld haben) uns alle Lösungen geben.  In diesem Artikel geht es hauptsächlich um die Lösung eines solchen allgemeineren Falles von Kreuzworträtseln. </p><br><h2 id="python">  Python </h2><br><p>  Vor ungefähr anderthalb Jahren bin ich versehentlich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> gestoßen, in dem eine Methode zum Lösen einer einzelnen Zeile beschrieben wurde (wie sich später herausstellte, war die Methode ziemlich langsam). </p><br><p>  Als ich diese Methode in Python (meiner Hauptarbeitssprache) implementierte und eine sequentielle Aktualisierung aller Zeilen hinzufügte, stellte ich fest, dass all dies nicht sehr schnell gelöst wurde.  Nach dem Studium des Materials stellte sich heraus, dass es zu diesem Thema viele Arbeiten und Implementierungen gibt, die unterschiedliche Ansätze für diese Aufgabe bieten. </p><br><p>  Es schien mir, dass die ehrgeizigste Arbeit an der Analyse verschiedener Solver-Implementierungen von Jan Wolter durchgeführt wurde, der auf seiner Website (die meines Wissens das größte öffentliche Repository für Nonogramme im Internet bleibt) eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">detaillierte Studie</a> mit einer Fülle von Informationen und Links veröffentlichte, die helfen können Erstellen Sie Ihren eigenen Löser. </p><br><p>  Durch das Studium zahlreicher Quellen (sie werden am Ende des Artikels erscheinen) habe ich die Geschwindigkeit und Funktionalität meines Lösers schrittweise verbessert.  Infolgedessen war ich süchtig und beschäftigte mich etwa 10 Monate lang in meiner Freizeit mit der Implementierung, dem Refactoring und dem Debuggen von Algorithmen. </p><br><h3 id="osnovnye-algoritmy">  Kernalgorithmen </h3><br><p>  Der resultierende Löser kann in Form von vier Entscheidungsebenen dargestellt werden: </p><br><ul><li><p>  ( <strong>Linie</strong> ) linearer Löser: am Eingang eine Linie von Zellen und eine Beschreibungszeile (Hinweise), am Ausgang eine teilweise aufgelöste Linie.  In der Python-Lösung habe ich 4 verschiedene Algorithmen implementiert (3 davon sind für Farbkreuzworträtsel angepasst).  Der schnellste war der BguSolver-Algorithmus, der nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ursprünglichen Quelle benannt wurde</a> .  Dies ist eine sehr effektive und praktisch standardmäßige Methode zum Lösen von Nicht-Programmzeichenfolgen mithilfe dynamischer Programmierung.  Den Pseudocode dieser Methode finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel</a> . </p><br></li><li><p>  ( <strong>Weitergabe</strong> ) Wir stellen alle Zeilen und Spalten in eine Warteschlange, gehen sie mit einem linearen Löser durch. Wenn wir beim Lösen einer Zeile (Spalte) neue Informationen erhalten, aktualisieren wir die Warteschlange jeweils mit neuen Spalten (Zeilen).  Fahren Sie fort, bis die Zeile leer ist. </p><br><div class="spoiler">  <b class="spoiler_title">Beispiel und Code</b> <div class="spoiler_text"><p> Wir übernehmen die nächste zu lösende Aufgabe aus der Warteschlange.  Es sei eine leere (ungelöste) Zeichenkette der Länge 7 (wir bezeichnen sie als <code>???????</code> ) mit einer Beschreibung der Blöcke <code>[2, 3]</code> .  Der lineare Löser erzeugt eine teilweise aufgelöste Zeichenfolge <code>?X??XX?</code>  Dabei ist <code>X</code> die gefüllte Zelle.  Beim Aktualisieren der Zeile sehen wir, dass sich die Spalten mit den Nummern 1, 4, 5 geändert haben (die Indizierung beginnt bei 0).  Dies bedeutet, dass neue Informationen in den angegebenen Spalten angezeigt wurden und an den „linearen“ Löser zurückgegeben werden können.  Wir stellen diese Spalten in die Warteschlange der Aufgaben mit höherer Priorität (um sie als nächstes dem linearen Löser zu geben). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  Für jede ungelöste Zelle sortieren wir alle Farboptionen und versuchen, sie mit diesen neuen Informationen zu verbreiten.  Wenn wir einen Widerspruch bekommen, werfen wir diese Farbe aus den Farboptionen für die Zelle und versuchen, sie mithilfe der Ausbreitung erneut zu nutzen.  Wenn es bis zum Ende gelöst ist, fügen wir die Lösung zur Liste der Lösungen hinzu, experimentieren jedoch weiterhin mit anderen Farben (es kann mehrere Lösungen geben).  Wenn wir zu einer Situation kommen, in der es unmöglich ist, weiter zu lösen, ignorieren wir den Vorgang einfach und wiederholen ihn mit einer anderen Farbe / Zelle. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Gibt True zurück, wenn aufgrund der Stichprobe ein Widerspruch eingeht. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>Backtracking</strong> ) Wenn Sie während der Prüfung ein teilweise gelöstes Rätsel nicht ignorieren, sondern weiterhin rekursiv dasselbe Verfahren aufrufen, erhalten wir ein Backtracking (mit anderen Worten, einen vollständigen Spaziergang in die Tiefe des potenziellen Entscheidungsbaums).  Hier beginnt eine große Rolle zu spielen, welche der Zellen als nächste Erweiterung der möglichen Lösung ausgewählt wird.  Gute Recherchen zu diesem Thema finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in dieser Publikation</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Das Zurückverfolgen ist für mich ziemlich chaotisch, aber diese beiden Funktionen beschreiben ungefähr, was während einer rekursiven Suche passiert </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  Also beginnen wir, unser Kreuzworträtsel ab der zweiten Ebene zu lösen (das erste ist nur für den entarteten Fall geeignet, wenn es im gesamten Kreuzworträtsel nur eine Zeile oder Spalte gibt) und bewegen uns schrittweise nach oben.  Wie Sie vielleicht erraten haben, verursacht jedes Level mehrmals das zugrunde liegende Level. Für eine effektive Lösung ist es daher unerlässlich, schnelle erste und zweite Level zu haben, die für komplexe Rätsel millionenfach aufgerufen werden können. </p><br><p>  In diesem Stadium stellt sich (eher erwartet) heraus, dass Python überhaupt nicht das Werkzeug ist, das für eine maximale Leistung bei einer derart CPU-intensiven Aufgabe geeignet ist: Alle darin enthaltenen Berechnungen sind im Vergleich zu Sprachen niedrigerer Ebenen äußerst ineffizient.  Beispielsweise stellte sich heraus, dass der am meisten algorithmisch geschlossene BGU-Löser (in Java) laut Messergebnissen bei einer Vielzahl von Aufgaben 7-17 (manchmal bis zu 27) Mal schneller war. </p><br><div class="spoiler">  <b class="spoiler_title">Weitere Details</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my Beschleunigung
 Tänzer 0,976 0,141 6,921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Dollar 1.116 0.118 9.457627      
 Kante 1,208 0,094 12,851064     
 Rauch 1.464 0.120 12.200000     
 Knoten 1,332 0,140 9,514286      
 Swing 1.784 0.138 12.927536     
 Mutter 2.108 0.147 14.340136     
 DiCap 2.076 0.176 11.795455     
 Tragisch 2,368 0,265 8,935849      
 Merka 2,084 0,196 10,632653     
 Petro 2.948 0.219 13.461187     
 M &amp; M 3,588 0,375 9,568000      
 Signiert 4.068 0.242 16.809917     
 Licht 3,848 0,488 7,885246      
 Für immer 111.000 13.570 8.179808  
 Center 5.700 0.327 17.431193     
 Hot 3.150 0.278 11.330935     
 Karate 2.500 0.219 11.415525     
 9-Dom 510.000 70.416 7.242672      
 Flagge 149.000 5.628 26.474769     
 Löwe 71.000 2.895 24.525043     
 Marley 12.108 4.405 2.748695      
 Sache 321.000 46.166 6.953169      
 Nature inf 433.138 inf     
 Sierp inf inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  Die Messungen wurden an meinem Auto durchgeführt. Die Rätsel stammen aus dem Standard-Set, das Jan Wolter für seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich verwendet hat</a> </p></div></div><br><p>  Und das ist bereits, nachdem ich angefangen habe, PyPy zu verwenden, und auf Standard-CPython war die Berechnungszeit 4-5 Mal länger als auf PyPy!  Wir können sagen, dass die Leistung eines ähnlichen Java-Solvers 28-85-mal höher war als die des CPython-Codes. </p><br><p>  Versuche, die Leistung meines Lösers mithilfe der Profilerstellung (cProfile, SnakeViz, line_profiler) zu verbessern, führten zu einer gewissen Beschleunigung, führten jedoch natürlich nicht zu einem unheimlichen Ergebnis. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> : </h3><br><p>  <strong>+</strong> Solver kann alle Rätsel auf den Websites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://webpbn.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://nonograms.org</a> und in seinem eigenen (ini-basierten) Format lösen </p><br><p>  <strong>+</strong> löst Schwarzweiß- und Farb-Nonogramme mit einer beliebigen Anzahl von Farben (die maximale Anzahl von Farben, die erfüllt wurden, beträgt 10). </p><br><p>  <strong>+</strong> löst Rätsel mit fehlenden Blockgrößen (getupft).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel für ein solches Rätsel</a> . </p><br><p>  <strong>+</strong> kann Rätsel zur Konsole / zu den Flüchen / zum Fenster im Browser rendern (bei der Installation der zusätzlichen <em>Pynogram-Web-</em> Option).  In allen Modi wird die Anzeige des Fortschritts der Lösung in Echtzeit unterstützt. </p><br><p>  <strong>-</strong> langsame Berechnungen (im Vergleich zu den im Artikelvergleich der Löser beschriebenen Implementierungen siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tabelle</a> ). </p><br><p>  <strong>-</strong> Ineffizientes Backtracking: Einige Rätsel können stundenlang gelöst werden (wenn der Entscheidungsbaum sehr groß ist). </p><br><h2 id="rust">  Rost </h2><br><p>  Anfang des Jahres begann ich Rust zu studieren.  Ich begann wie üblich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Book</a> , lernte WASM kennen und ging das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgeschlagene Tutorial durch</a> .  Ich wollte jedoch eine echte Aufgabe, bei der Sie sich auf die Stärken der Sprache einlassen können (vor allem ihre Superleistung), und nicht einige Beispiele, die von jemandem erfunden wurden.  Also kehrte ich zu den Nonogrammen zurück.  Aber jetzt hatte ich bereits eine funktionierende Version aller Algorithmen in Python, die "nur" neu geschrieben werden musste. </p><br><p>  Die gute Nachricht erwartete mich von Anfang an: Es stellte sich heraus, dass Rust mit seinem Typsystem die Datenstrukturen für meine Aufgabe perfekt beschreibt.  Mit einer der grundlegenden Entsprechungen von <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColouredBlock</em> können <em>Sie beispielsweise</em> Schwarzweiß- und Farb-Nonogramme dauerhaft trennen.  Wenn wir irgendwo im Code versuchen, eine farbige Zeichenfolge mit gewöhnlichen binären Beschreibungsblöcken zu lösen, wird ein Kompilierungsfehler bezüglich der Nichtübereinstimmung des Typs angezeigt. </p><br><div class="spoiler">  <b class="spoiler_title">Grundtypen sehen ungefähr so ​​aus</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  Bei der Portierung des Codes zeigten einige Punkte deutlich, dass eine statisch typisierte Sprache wie Rust (gut oder beispielsweise C ++) für diese Aufgabe besser geeignet ist.  Genauer gesagt beschreiben Generika und Merkmale eine Domäne besser als Klassenhierarchien.  Im Python-Code hatte ich zwei Klassen für einen linearen <code>BguSolver</code> , <code>BguSolver</code> und <code>BguColoredSolver</code> die eine Schwarzweiß- bzw. eine Farblinie lösten.  Im Rust-Code habe ich immer noch die einzige generische <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> , die beide Arten von Aufgaben lösen kann, abhängig vom Typ, der während der Erstellung übergeben wurde ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  Dies bedeutet natürlich nicht, dass etwas Ähnliches in Python nicht möglich ist, nur in Rust hat mir das Typsystem klar gezeigt, dass Sie eine Menge sich wiederholenden Codes schreiben müssten, wenn Sie diesen Weg nicht gehen würden. </p><br><p>  Darüber hinaus bemerkte jeder, der versuchte, in Rust zu schreiben, zweifellos den Effekt des "Vertrauens" in den Compiler, wenn der Prozess des Schreibens von Code auf den folgenden Pseudo-Meta-Algorithmus hinausläuft: </p><br><pre> write_initial_code
 while (compiler_hints = $ (Frachtprüfung))! = 0;  tun
     fix_errors (compiler_hints)
 Ende
</pre><br><p>  Wenn der Compiler keine Fehler und Warnungen mehr ausgibt, stimmt Ihr Code mit dem Typsystem und dem Ausleihprüfer überein und Sie warnen vor dem Auftreten einer Reihe potenzieller Fehler (natürlich vorbehaltlich einer sorgfältigen Gestaltung der Datentypen). </p><br><p>  Ich werde einige Beispiele für Funktionen geben, die zeigen, wie präzise Rust-Code sein kann (im Vergleich zu Python-Gegenstücken). </p><br><div class="spoiler">  <b class="spoiler_title">ungelöste Nachbarn</b> <div class="spoiler_text"><p>  Gibt eine Liste ungelöster "Nachbarn" für einen bestimmten Punkt an (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Teilsummen</b> <div class="spoiler_text"><p>  Geben Sie für eine Reihe von Blöcken, die eine Zeile beschreiben, Teilsummen an (unter Berücksichtigung der erforderlichen Lücken zwischen den Blöcken). Die resultierenden Indizes geben die Mindestposition an, an der der Block enden kann (diese Informationen werden später für einen linearen Löser verwendet). </p><br><p>  Zum Beispiel haben wir für einen solchen Satz von Blöcken <code>[2, 3, 1]</code> am Ausgang <code>[2, 6, 8]</code> , was bedeutet, dass der erste Block maximal nach links verschoben werden kann, so dass sein rechter Rand die zweite Zelle einnimmt, ähnlich wie für den Rest Blöcke: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^^^
               |  |  |
 Ende von 1 Block |  |  | 
 Ende von Block 2 -------- |
 Ende von Block 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  Beim Portieren habe ich einige Änderungen vorgenommen </p><br><ul><li>  Der Solver-Kern (Algorithmen) wurde geringfügig geändert (hauptsächlich zur Unterstützung generischer Typen für Zellen und Blöcke). </li><li>  links der einzige (schnellste) Algorithmus für den linearen Löser </li><li>  Anstelle des INI-Formats wurde ein leicht modifiziertes TOML-Format eingeführt </li><li>  Unterstützung für geblottete Kreuzworträtsel wurde nicht hinzugefügt, da dies streng genommen eine andere Klasse von Aufgaben ist </li><li><p>  Die einzige Möglichkeit zur Ausgabe blieb - nur zur Konsole, aber jetzt sind die farbigen Zellen in der Konsole wirklich farbig gezeichnet (dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Kiste</a> ). </p><br><div class="spoiler">  <b class="spoiler_title">so</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack Spatz"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Nützliche Werkzeuge </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">clippy</a> ist ein standardmäßiger statischer Analysator, der manchmal sogar Tipps geben kann, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeleistung</a> leicht steigern. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">valgrind</a> ist ein Tool zur dynamischen Anwendungsanalyse.  Ich habe es als Profiler verwendet, um nach Botneks ( <code>valrgind --tool=callgrind</code> ) und besonders nach speicherhungrigen Codeabschnitten ( <code>valrgind --tool=massif</code> ) zu <code>valrgind --tool=massif</code> .  Tipp: Setzen Sie <em>[profile.release] debug = true</em> auf Cargo.toml, bevor Sie den Profiler starten.  Dadurch bleiben Debug-Zeichen in der ausführbaren Datei. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kcachegrind</a> zum Anzeigen von Callgrind-Dateien.  Ein sehr nützliches Werkzeug, um die problematischsten Stellen in Bezug auf die Leistung zu finden. </li></ul><br><h3 id="proizvoditelnost">  Leistung </h3><br><p>  Das für das, was auf Rust umgeschrieben wurde, wurde begonnen.  Wir nehmen die Kreuzworträtsel aus der bereits erwähnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleichstabelle</a> und führen sie durch die besten im Originalartikel beschriebenen Löser.  Ergebnisse und Beschreibung der Läufe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Wir nehmen die resultierende <a href="">Datei</a> und erstellen ein paar Diagramme darauf. Da die Lösungszeit von Millisekunden bis zu zehn Minuten variiert, wird das Diagramm mit einer logarithmischen Skala erstellt. </p><br><div class="spoiler">  <b class="spoiler_title">laufen in jupyter Laptop</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  Python-Löser </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="Pynogramm-Leistung"><br></a> <br>  (das <em>Bild ist anklickbar</em> ) </p><br><p>  Wir sehen, dass das <em>Pynogramm</em> hier langsamer ist als alle vorgestellten Löser.  Die einzige Ausnahme von dieser Regel ist der auf SAT basierende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tamura / Copris-</a> Löser, der die einfachsten Rätsel (der linke Teil des Diagramms) länger löst als unsere.  Dies ist jedoch ein Merkmal von SAT-Solvern: Sie sind für superkomplexe Kreuzworträtsel konzipiert, bei denen ein regulärer Solver lange Zeit im Backtracking stecken bleibt.  Dies ist auf der rechten Seite des Diagramms deutlich sichtbar, wo <em>Tamura / Copris</em> die schwierigsten Rätsel zehn- und hunderte Male schneller löst als alle anderen. </p><br><h5 id="rust-solver">  Rostlöser </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="Nonogrid-Leistung"><br></a> <br>  (das <em>Bild ist anklickbar</em> ) </p><br><p>  Diese Grafik zeigt, dass <em>Nonogrid</em> bei einfachen Aufgaben auch mit Hochleistungslösern in C und C ++ ( <em>Wolter</em> und <em>Syromolotov</em> ) <em>zurechtkommt</em> oder etwas schlechter ist als <em>diese</em> .  Mit der Komplikation von Aufgaben wiederholt unser Löser ungefähr die Flugbahn des <em>BGU-</em> Lösers (Java), aber fast immer um eine Größenordnung voraus.  Bei den schwierigsten Aufgaben ist <em>Tamura / Copris</em> immer allen voraus. </p><br><h5 id="rust-vs-python">  Rost gegen Python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-leistung"><br></a> <br>  (das <em>Bild ist anklickbar</em> ) </p><br><p>  Und schließlich ein Vergleich unserer beiden hier beschriebenen Löser.  Es ist ersichtlich, dass der Rostlöser fast immer 1-3 Größenordnungen vor dem Pythonlöser liegt. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> : </h3><br><p>  <strong>+</strong> Solver kann alle Rätsel auf den Websites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://webpbn.com</a> (außer geblottet - mit teilweise ausgeblendeten Blockgrößen), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://nonograms.org</a> und seinem eigenen (TOML-basierten) Format lösen </p><br><p>  <strong>+</strong> löst Schwarzweiß- und Farb-Nonogramme mit einer beliebigen Anzahl von Farben </p><br><p>  <strong>+</strong> kann Rätsel auf der Konsole rendern (Farbe c webpbn.com zeichnet echte Farbe) </p><br><p>  <strong>+</strong> arbeitet schnell (im Vergleich zu den im Artikelvergleich der Löser beschriebenen Implementierungen siehe Tabelle). </p><br><p>  <strong>- Das</strong> Backtracking ist wie in der Python-Lösung ineffektiv geblieben: Einige Rätsel (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein harmloses 20x20</a> ) können stundenlang gelöst werden (wenn der Entscheidungsbaum sehr groß ist).  Vielleicht lohnt es sich, anstelle des Zurückverfolgens die bereits auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Hub</a> erwähnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAT-Löser zu verwenden</a>  Der einzige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAT-Löser, den</a> ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf den</a> ersten Blick <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei Rust</a> gefunden habe, scheint zwar unvollendet und verlassen zu sein. </p><br><h2 id="webassembly">  Webassembly </h2><br><p>  Das Umschreiben des Codes in Rust hat sich also ausgezahlt: Der Solver ist viel schneller geworden.  Rust bietet uns jedoch eine weitere unglaublich coole Funktion: die Kompilierung in WebAssembly und die Möglichkeit, Ihren Code direkt im Browser auszuführen. </p><br><p>  Um diese Funktion zu implementieren, gibt es ein spezielles Tool für Rust, das die erforderlichen Bindemittel bereitstellt und eine Boilerplate generiert, mit der Sie Rust-Funktionen in JS-Code <em>problemlos</em> ausführen können - dieses <em>Wasm-Pack</em> (+ <em>wasm-bindgen</em> ).  Der größte Teil der Arbeit damit und mit anderen wichtigen Tools ist bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial zu Rust und WebAssembly beschrieben</a> .  Es gibt jedoch einige Punkte, die ich selbst herausfinden musste: </p><br><ul><li><p>  Beim Lesen entsteht das Gefühl, dass das Tutorial hauptsächlich für einen JS-Entwickler geschrieben wurde, der seinen Code mit Rust beschleunigen möchte.  Na ja, oder zumindest für jemanden, der mit <em>npm</em> vertraut ist.  Für mich als Person, die weit vom Frontend entfernt ist, war es überraschend, dass selbst das Standardbeispiel aus dem Buch nicht mit einem Webserver eines Drittanbieters arbeiten möchte, der sich vom <code>npm run start</code> von <code>npm run start</code> . </p><br><p>  Glücklicherweise verfügt wasm-pack über einen Modus, mit dem Sie regulären JS-Code generieren können (der kein npm-Modul ist).  <code>wasm-pack build --target no-modules --no-typescript</code> gibt nur zwei Dateien in der Ausgabe aus: <em>project-name.wasm</em> - die Binärdatei des Rust-Codes, der in WebAssembly und <em>project-name.js kompiliert wurde</em> .  Die letzte Datei kann zu jeder HTML-Seite <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> hinzugefügt werden und verwendet WASM-Funktionen, ohne sich um npm, Webpack, ES6, Module und andere Freuden des modernen JS-Entwicklers zu kümmern.  Der Modus <code>no-modules</code> ist ideal für Nicht-Front-End-Entwickler während der Entwicklung einer WASM-Anwendung sowie für Beispiele und Demos, da keine zusätzliche Front-End-Infrastruktur erforderlich ist. </p><br></li><li><p>  WebAssembly eignet sich für Aufgaben, die für JavaScript zu schwer sind.  Zuallererst sind dies Aufgaben, die viele Berechnungen durchführen.  Und wenn ja, kann eine solche Aufgabe auch mit WebAssembly lange ausgeführt werden und damit das asynchrone Prinzip des modernen Web verletzen.  Ich spreche von allen möglichen <em>Warnungen: Nicht reagierendes Skript</em> , das ich zufällig beobachtet habe, als mein Solver arbeitete.  Um dieses Problem zu lösen, können Sie den <em>Web Worker-</em> Mechanismus verwenden.  In diesem Fall kann das Schema für die Arbeit mit "schweren" WASM-Funktionen folgendermaßen aussehen: </p><br><ol><li>  Senden Sie über das Hauptskript für ein Ereignis (z. B. Klicken auf eine Schaltfläche) eine Nachricht an den Worker mit der Aufgabe, eine umfangreiche Funktion zu starten. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th>  id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td> 5.4 </td><td>  7.4 </td><td>  9.2 </td></tr><tr><td> 8098 </td><td>  21.5 </td><td> 28.4 </td><td>  29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo">  Todo </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  Zusammenfassung </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454586/">https://habr.com/ru/post/de454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454574/index.html">Maschinelles Lernen in der Mikrofinanzierung: Aufbau eines Bewertungsmodells für Kunden mit einer leeren Bonitätshistorie</a></li>
<li><a href="../de454576/index.html">GandCrab-Autoren hören auf zu arbeiten: Sie behaupten, genug gestohlen zu haben</a></li>
<li><a href="../de454578/index.html">So verbinden Sie die PhotoSwipe-Galerie in der Android-Webansicht</a></li>
<li><a href="../de454582/index.html">Sollte die Arraylänge in einer lokalen Variablen in C # gespeichert werden?</a></li>
<li><a href="../de454584/index.html">Schule für Schnittstellenentwicklung: Analyse der Aufgaben für Minsk und ein neues Set in Moskau</a></li>
<li><a href="../de454588/index.html">Gazprom Neft lädt Sie ein: GPN Data Science Meetup</a></li>
<li><a href="../de454590/index.html">Zimbra Collaboration Suite und Mobile Control mit ABQ</a></li>
<li><a href="../de454592/index.html">WAF durch die Augen von Hackern</a></li>
<li><a href="../de454596/index.html">Mentale Modelle in der Informationssicherheit</a></li>
<li><a href="../de454598/index.html">Serverlose Architektur und Microservices: die perfekte Ergänzung?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>