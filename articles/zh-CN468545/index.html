<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏭 👨🏽‍⚖️ 🤲🏻 “爱丽丝，我们去前端吧！” 🧚🏽 🔘 🐲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="语音助手不是遥不可及的未来，而是现实。 Alexa，Siri，Google Now和Alice内置在智能扬声器，手表和电话中。 他们正在逐步改变我们与应用程序和设备进行交互的方式。 通过助手，您可以找到天气预报，购买机票，订购出租车，听音乐并打开厨房的水壶，躺在另一个房间的沙发上。 



 Sir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“爱丽丝，我们去前端吧！”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468545/"> 语音助手不是遥不可及的未来，而是现实。  Alexa，Siri，Google Now和Alice内置在智能扬声器，手表和电话中。 他们正在逐步改变我们与应用程序和设备进行交互的方式。 通过助手，您可以找到天气预报，购买机票，订购出租车，听音乐并打开厨房的水壶，躺在另一个房间的沙发上。 <br><br><img src="https://habrastorage.org/webt/mr/sw/35/mrsw35dh1qjeefkk8eb1f1ffvj0.jpeg"><br><br>  Siri或Alexa对用户说的大多是英语，因此在俄罗斯，它们不如Yandex的Alice受欢迎。 对于开发人员来说，爱丽丝也更方便：她的创建者拥有一个博客，在GitHub上发布方便的工具，并帮助在新设备中构建助手。 <br><br>  <b>Nikita Dubko</b> （Twitter上的@dark_mefody）是Yandex界面开发人员，MinskCSS和MinskJS会议的组织者以及Web标准的新闻编辑器。  Nikita在Yandex.Dialogs中不起作用，并且与Yandex.Alisa无关。 但是他对了解Alice的工作方式很感兴趣，因此他尝试将其技能应用到Web上，并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FrontendConf</a> RIT ++上准备了一份有关该报告的报告。 在解读Nikita的报告时，我们考虑了语音助手可以在阅读本材料的过程中带来哪些帮助和技能。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yjTH8-O3CMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 机器人 </h2><br> 让我们从机器人的历史开始。  1966年， <b>伊丽莎（Eliza）</b>机器人出现，假装是一名治疗师。 可以与他交流，甚至有人相信一个活人会回答他们。  1995年， <b>ALICE</b>机器人问世。  -不要与爱丽丝混淆。 该机器人能够模仿一个真实的人。 直到今天，它仍在开源中并正在定稿。 不幸的是，驴友没有通过图灵测试，但这并不能阻止他误导人们。 <br><br> 在2006年，IBM在该机器人程序中建立了庞大的知识库和先进的智能，这就是<b>IBM Watson</b>诞生的方式。 这是一个庞大的计算集群，可以处理英语语音并提供一些事实。 <br><br>  2016年，微软进行了一项实验。 她创建了<b>Tay</b>机器人，并在Twitter上启动了该机器人。 在那里，该机器人学会了根据实时订户与之互动的方式来微博。 结果，Tay成为了种族主义者和厌恶妇女的人。 现在这是一个已关闭的帐户。 道德：不要让孩子在Twitter上，他可以教坏。 <br><br> 但是，这些都是您自己无法与自己交流的漫游器。  2015年，“有用”出现在Telegram上。  Bots在其他程序中也存在，但是Telegram引起了轰动。 可以创建一个有用的机器人来提供信息，生成内容，管理公众-可能性很大，API也很简单。 机器人添加了图片，按钮，工具提示-出现了一个交互界面。 <br><br> 逐渐地，这个想法传播到了几乎所有即时通讯工具：Facebook，Viber，VKontakte，WhatsApp和其他应用程序。 现在，机器人已成为一种趋势，它们无处不在。 有些服务可让您立即为所有平台编写API。 <br><br><h2> 语音助手 </h2><br> 开发与机器人同时进行，但我们将假定助手时代来了。 <br><br>  2011年8月9日， <b>Siri</b>出现。 最初，这是一个独立的项目，苹果公司看到了一些有趣的东西，所以我买了它。 这是操作系统中内置的最古老的流行语音助手。 一年后，Google通过将<b>Google即时</b>语音助手集成到其操作系统中，迅速赶上了苹果。 <br><br>  2年后，微软发布了<b>Microsoft Cortana</b> 。 但是尚不清楚原因-语音助手的移动市场似乎已经错过了。 该公司试图将语音助手集成到台式机系统中，而当时已经在争夺不同设备的市场。  <b>亚马逊Alexa</b>于当年晚些时候问世。 <br><br><img src="https://habrastorage.org/webt/un/cw/eh/uncwehkki7vgcfyeh7148omczd4.jpeg"><br><br> 助手已经进化。 除了知道如何使用语音的软件系统之外，发言人还与助手一起出现。 据统计，到2019年初，美国每三个家庭都有一个聪明的专栏。 这是您可以投资的巨大市场。 <br><br> 但是有一个问题-外籍助手的俄语说得不好。 助手被用英语监禁，并且很懂英语，但是当用俄语交流时，翻译会出现困难。 语言是不同的，需要不同的自然语言处理方法。 <br><br><h2> 爱丽丝 </h2><br> 爱丽丝于2017年10月10日以公开测试版发布。 它被监禁为俄语，这是它的巨大优势。 爱丽丝懂英语，但是更糟。 <br><br><blockquote> 爱丽丝的任务是帮助说俄语的用户。 </blockquote><br>  Yandex是一家大型公司，可以负担得起将Alice嵌入其所有可以以某种方式交谈的应用程序的能力。 <br><br><ul><li>  Yandex浏览器。 <br></li><li>  Yandex.Navigator。 <br></li><li>  Yandex站。 <br></li><li>  Yandex.Phone。 <br></li><li>  Yandex自动 <br></li><li>  Yandex驱动器。 <br></li></ul><br> 整合进行得如此之好，以至于第三方制造商也决定建造Alice。 <br><br><img src="https://habrastorage.org/webt/tc/na/aa/tcnaaauucjom0ojuvb6jpgdjzge.jpeg"><br><br> 在助理的2年发展中，她被集成到许多服务中，并增加了新技能。 她知道如何播放音乐，识别图片，在Yandex中搜索信息以及如何与智能家居一起工作。 <br><br><h3> 为什么这么受欢迎？ </h3><br>  <b>忙碌时很方便</b> 。 我正在准备晚餐，想打开音乐。 转到水龙头，洗手，擦干，打开应用程序，找到所需的曲目-很长一段时间。 发出语音命令更快，更容易。 <br><br>  <b>懒惰</b> 。 我躺在格子毯子下的沙发上，不想起身去某个地方打开扬声器。 如果你很懒，那就全力以赴。 <br><br>  <b>最大的市场是儿童应用程序</b> 。 幼儿尚不知道如何阅读，书写和打印，但是他们会说和理解语音。 因此，孩子们爱慕爱丽丝，并喜欢与她交流。 父母也很满意-无需寻找如何对待孩子。 有趣的是，由于训练有素的神经网络，爱丽丝能够理解孩子。 <br><br>  <b>有空</b> 视力障碍的人很喜欢与语音助手一起工作-当界面不可见时，您可以听到并发出命令。 <br><br>  <b>声音更快</b> 。 一个普通的人，而不是开发人员，每分钟平均打印30个单词，说出120个单词。每分钟，通过语音传输的信息更多4倍。 <br><br>  <b>未来</b> 。 奇幻电影和未来派的预测表明，语音接口将成为未来。 脚本编写者认为，语音控制可能是与图片不太重要的界面进行交互的主要方式。 <br><br> 据统计，每月有3500万人使用Alisa。 顺便说一句，白俄罗斯的人口是9,475,600人。 也就是说，约有3.5白俄罗斯每月使用Alice。 <br><br> 语音助手占领了市场。 根据预测，到2021年它将增长约2倍。 今天的流行不会停止，但是会继续增长。 越来越多的开发商意识到他们需要在这一领域进行投资。 <br><br><h3> 开发人员技能 </h3><br> 当公司投资语音助手时，这很棒。 他们了解如何将其与服务集成。 但是开发人员也想以某种方式参与其中，并且公司本身就是盈利的。 <br><br>  Alexa具有Alexa技能。 根据记录的交互方法，她了解开发人员为她编写的内容。  Google推出了Actions-将自己的某些功能集成到语音助手中的功能。 <br><br> 爱丽丝还具有技能-开发人员能够实现第三方功能。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/682/cba/758/682cba758b31f41d75d55aca324645b1.jpg"><br><br> 同时，社区还提供了另一种技能列表，而不是Yandex的技能。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/c87/9a5/445c879a5d44b7da9f49f185826cbdbe.jpg"><br><br> 关于如何制作语音应用程序，有很好的报告。 例如， <b>帕维尔·盖伊</b> （ <b>Pavel Guy</b> ）在AppsConf 2018上的主题是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“使用Google Assistance示例创建语音应用程序”</a> 。 热心者积极参与语音应用程序的开发。 一个示例是Ivan Golubev编写的可视语音激活游戏。 <br><br> 爱丽丝很受欢迎，尽管她所做的一切基本上都在语音和文字之间。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/0fb/c3e/8040fbc3e31afcbee27651b7a77a2426.jpg"><br><br> 爱丽丝（Alice）知道如何听声音，并根据自己的算法将其转换为文本，创建答案并将其语音化。 看起来这还不够，但这是一项极其困难的任务。 许多人正在努力确保Alice听起来自然，正确识别，理解口音和儿童的语音。  Yandex提供了类似代理的功能，可以通过自身传递所有内容。 出色的头脑工作，使您可以利用他们的工作成果。 <br><br> 爱丽丝的技能-Yandex.Dialogs-有一个局限性。  API响应所用的时间不得超过1.5秒。 这是合乎逻辑的，因为如果答案悬而未决-为什么要等待？ <br><br><blockquote> 询问您是否仍然没有答案真的很重要吗？ </blockquote><br> 当我们用耳朵接收信息时，大脑感知到的停顿要比视觉界面中的类似停顿更长。 例如，装载程序，微调程序-我们想要添加到界面的所有内容都会分散用户的等待时间。 考虑一切正常。 <br><br><h2> 演示时间 </h2><br>  Yandex.Dialog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>中详细描述了所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> ，并且始终是最新的。 我不会重复自己。 我将告诉您对我来说有趣的事情，并展示如何快速创建一个演示，这个演示只花了一个晚上。 <br><br> 让我们从想法开始。 有很多技能，有很多目录，但是我没有发现对我重要的东西-这是前端事件的日历。 想象一下早上醒来：“我今天去开会。 爱丽丝！ 那里有什么有趣的东西吗？”，而且爱丽丝会根据您的位置正确回答您。 <br><br> 如果您参与组织会议，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加入GitHub</a> 。 您可以在那里举行活动和会议，从一个日历中了解世界上前端的许多活动。 <br><br> 我采用了手头的著名技术：Node.js和Express。 还是Heroku，因为它是免费的。 该应用程序本身很简单：它是Express应用程序Node.js上的服务器。 只需在某个端口上抬起服务器并侦听请求即可。 <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routes'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, router); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.listen(port, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server started on :${port}'</span></span>); });</code> </pre> <br> 我利用了以下事实：Web标准日历中已经配置了所有内容，并且从大量的小文件中可以下载一个ICS文件。 我为什么要收集自己的东西？ <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// services/vendors/web-standards.js import axios from 'axios'; const axioslnstance = axios.create({ baseURL: 'https://web-standards.ru/' , }); export function getRemoteCal() { return axioslnstance.get('calendar.ics'); }</span></span></code> </pre> <br> 确保一切正常。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wst <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'services/vendors/web-standards'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ wst .getRemoteCal() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vendorResponse</span></span></span><span class="hljs-function"> =&gt;</span></span> parseCalendar(vendorResponse.data)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.json({ events }); }) .catch(next); });</code> </pre> <br> 使用GET方法进行测试。 技能与POST方法一起使用，因此GET方法可以专门用于调试。 我已经实现了这种方法。 他所做的全部就是下载相同的ICS，解析并以JSON形式发布。 <br><br> 我快速构建了演示，因此使用了现成的节点库： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ical <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-ical'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseCalendar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ical.parseICS(str, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { reject(err); } resolve(data); }); }); }</code> </pre> <br> 她知道如何解析ICS格式。 在输出中产生这样的一张纸： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"VEVENT"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"uid"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequence"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"dtstamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-25T21:23:50.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"datetype"</span></span>: <span class="hljs-string"><span class="hljs-string">"date"</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-06T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-CDO-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-MSNCALENDAR-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"FrontendConf"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://frontendconf.ru/moscow/2018"</span></span> } }</code> </pre> <br> 为了解析该技能并向技能用户提供必要的信息，只需知道事件开始和结束的时间，事件的名称，链接以及重要的城市。 我想要这项技术来搜索城市中的事件。 <br><br><h3> 输入格式 </h3><br>  Yandex.Dialogs如何返回信息？ 移动应用程序中内置的专栏或语音助手会听您的意见，Yandex服务器会处理听到的内容并发送对象以作为响应： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { … }, <span class="hljs-string"><span class="hljs-string">"request”: { … }, "</span></span>session<span class="hljs-string"><span class="hljs-string">": { … }, "</span></span>version<span class="hljs-string"><span class="hljs-string">": "</span></span><span class="hljs-number"><span class="hljs-number">1.0</span></span><span class="hljs-string"><span class="hljs-string">" }</span></span></code> </pre> <br> 该对象包含元信息，有关该请求的信息，当前会话以及该API的版本，以防其突然更新-技能不应中断。 <br><br>  <b>元信息中</b>有很多有用的<b>信息</b> 。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"locale"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru-RU"</span></span>, <span class="hljs-string"><span class="hljs-string">"timezone"</span></span>: <span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>, <span class="hljs-string"><span class="hljs-string">"client_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.yandex.searchplugin/5.80…”, "</span></span>interfaces<span class="hljs-string"><span class="hljs-string">": { "</span></span>screen<span class="hljs-string"><span class="hljs-string">": {} } } }</span></span></code> </pre> <br>  “ <b>语言环境</b> ”-用于了解用户所在的区域。 <br><br>  “ <b>时区</b> ”可用来胜任时间并更准确地确定用户的位置。 <br><br>  “ <b>接口</b> ”-有关屏幕可用性的信息。 如果没有屏幕，则应考虑如果在答案中提供图片，用户将如何查看图片。 如果有屏幕，我们将取出有关的信息。 <br><br> 请求格式很<b>简单</b> ： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"      16"</span></span>, <span class="hljs-string"><span class="hljs-string">"original_utterance"</span></span>: <span class="hljs-string"><span class="hljs-string">"     , 16"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleUtterance"</span></span>, <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: [ <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"16"</span></span>], <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [...] } } }</code> </pre> <br> 它给出了用户所说的内容，请求类型和<b>NLU-自然语言单位</b> 。 这正是Yandex.Dialog平台所具有的魔力。 她将识别出的整个句子分解为单词-单词。 还有一些实体，我们稍后再讨论。 使用令牌就足够了。 <br><br> 我们明白了这些话，该怎么办？ 用户说了些什么，但是他可以以不同的顺序说出这些单词，使用“ not”粒子，这会极大地改变一切，甚至说“ morning”而不是“ morning”。 如果用户也讲白俄罗斯语，那么将有一个“书包”，而不是早晨。 大型项目将需要语言学家的帮助，以发展一种能够理解一切的技能。 但是我做了一个简单的任务，所以我没有外界的帮助。 <br><br><h2> 计算机可以像人一样说话吗？ </h2><br> 这是图灵测试试图回答的一个哲学问题。 该测试可以一定的可能性确定人工智能可以模仿人。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">勒布纳奖是</a>用来接受哪些程序在通过图灵测试中竞争的。 该决定由一个法官小组做出。 要获得奖项，您需要欺骗33％或更多的评委。 仅在2014年，来自圣彼得堡的机器人<b>Zhenya Gustman</b>最终欺骗了委员会。 <br><br><pre> <code class="plaintext hljs">[15:46:05] Dudge: My favourite music is contemporary Dazz, what do you prefer? [15:46:14] Eugene: To be short I'll only say that I HATE Britnie [sic] Spears. All other music is OK compared to her. [15:47:06] Dudge: do you like to play any musical instruments [15:47:23] Eugene: I'm tone deaf, but my guinea pig likes to squeal Beethoven's Ode to Doy every morning. I suspect our neighbors want to cut his throat ... Could you tell me about your job, by the way? [15:48:02] Dudge: Guinea pig? Are you an animal lover [15:48:08] Eugene: Yeah. A nice little guinea pig. Not some annoying chatter bot.</code> </pre> <br> 在2019年，什么都没有真正改变-仍然很难欺骗一个人。 但是我们正在逐步朝着这个方向发展。 <br><br><h2> 脚本工作 </h2><br> 一项好的技能需要一个有趣的用例。 我建议一本书值得一读-“设计语音用户界面：对话体验的原理”。 编写用于语音界面的脚本并吸引用户的关注真是太棒了。 我没看过这本书的英文书，但很容易阅读。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/3e1/222/8713e12220b6ce7a65563775dc2b49f2.jpg"><br><br> 开始发展技能的第一件事是问候。 <br><br><blockquote>  “尽管您想说些什么，但要礼貌行事！ 这样可以节省时间。” </blockquote><br> 启用该技能后，您需要从第一秒起就以某种方式抓住用户，为此您需要解释如何使用该技能。 想象一下，用户启动了该技能，并且保持沉默。 您怎么知道一项技能是否有效？ 向用户提供指示，例如屏幕上的按钮。 <br><br><h3> 轻松对话 </h3><br> 轻松对话的迹象。 该清单是由Ivan Golubev发明的，我真的很喜欢这样的措辞。 <br><br><ul><li>  <b>我</b>个人 <br></li><li> 自然的 <br></li><li> 灵活。 <br></li><li>  Ontext。 <br></li><li>  <b>和</b>叙事。 <br></li><li> 简介<b>J.</b> <br></li></ul><br>  <b>个人</b>意味着机器人必须具有角色。 如果您与Alice交谈，您将理解她有一个角色-开发人员会照顾这个。 因此，您的有机机器人必须具有“个性”。 用至少一种声音发出短语，并使用相同的语言结构。 这有助于保留用户。 <br><br>  <b>自然的</b> 。 如果用户请求很简单，那么答案应该是相同的。 与机器人通信期间，用户必须了解下一步要做什么。 <br><br>  <b>灵活的</b> 。 为任何事情做好准备。 俄语有很多同义词。 用户可以从专栏转移注意力，并将对话转移给对话者，然后返回专栏。 所有这些都很难处理。 但是，如果您想使机器人更好，那么就必须这样做。 请记住，某些情况下仍然无法识别。 为此做好准备-建议选项。 <br><br>  <b>内容相关</b> -机器人最好应该记住以前发生的事情。 然后，对话将变得活跃。 <br><br>  <i>-爱丽丝，今天的天气如何？</i> <br>  <i>-今天在该地区，多云至+11至+20，有空地。</i> <br>  <i>-明天？</i> <br>  <i>-明天该地区从+14到+27，多云，有空地。</i> <br><br> 想象一下，您的机器人不知道如何存储上下文。 那么对他来说意味着“明天”的请求呢？ 如果您知道如何保持像Alice这样的上下文，那么您可以使用以前的结果来提高技能的答案。 <br><br>  <b>积极主动</b> 。 如果用户无聊，则机器人应提示他：“单击此按钮！”，“看，我有照片给你！”，“跟随链接”。 该机器人应该告诉您如何使用它。 <br><br> 机器人应该很<b>短</b> 。 一个人长时间讲话时，很难引起听众的注意。 这个漫游器更加复杂-它可惜，没有生命。 要引起注意，您需要有趣或简短，简洁地进行对话。 这将有助于“写。 剪下来。” 当您开始开发机器人时，请阅读本书。 <br><br><h3> 资料库 </h3><br> 开发复杂的漫游器时，离不开数据库。 我的演示不使用数据库，这很简单。 但是，如果您拧紧了一些数据库，则可以使用有关用户会话的信息，至少可以存储上下文。 <br><br> 有一个细微差别：Yandex.Dialog不会泄露用户的私人信息，例如姓名，位置。 但是可以从用户询问此信息，将其保存并链接到特定的会话ID，Yandex.Dialogs在请求中发送该特定会话ID。 <br><br><h3> 状态机 </h3><br> 提到复杂的场景，人们只能回忆起状态机。 这种机制由来已久，并且非常适合用于微控制器（有时是前端）的编程。 在这种情况下，状态机很方便：有些状态我们可以将某些短语传递给其他状态。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/914/9bb/e4d/9149bbe4d192a9d9e4ee0a42dc315044.jpg"><br><br> 不要过度使用它。 您可能会迷失方向，并创建一个庞大的状态机，这将很难弄清楚-维护此类代码很困难。 编写一个由小的子脚本组成的脚本会更容易。 <br><br><h3> 不清楚 指定 </h3><br> 永远不要说：“请重复。” 一个人被要求重复时会做什么？ 他大声说话。 如果用户大吼大叫您的技能，识别度将不会提高。 提出一个澄清的问题。 如果识别出用户对话的一部分，并且缺少某些内容，请检查缺少的区域。 <br><br> 文本识别是开发机器人程序中最困难的任务，因此有时进行澄清无济于事。 在任何无法理解的情况下，最好的解决方案是将所有内容收集到一个地方，进行记录，然后在将来进行分析和使用。 例如，如果用户坦率地说奇怪而难以理解的事情。 <br><br>  <i>“它在沸腾。</i>  <i>奶油海岸</i> <i><br></i>  <i>戳入导航。</i> <i><br></i>  <i>和咕gr咕gr。</i> <i><br></i>  <i>就像木乃伊一样。”</i> <br><br> 用户可能会意外地使用一些新词，这意味着某些东西，并且需要以某种方式进行处理。 结果，识别率下降。 不用担心-登录，研究和改进您的机器人。 <br><br><h3> 停用词 </h3><br> 当您想摆脱该技能时，一定有一些东西可以阻止它。 爱丽丝知道如何在短语后面停下来：“爱丽丝，这就足够了！” 或“爱丽丝，停下！” 但是用户通常不阅读说明。 因此，至少应响应“停止”一词，并将控制权返回给爱丽丝。 <br><br> 现在让我们看一下代码。 <br><br><h2> 演示时间 </h2><br> 我要实现以下短语。 <br><br><ul><li> 城市即将发生的事件。 <br></li><li> 城市名称：“莫斯科活动”，“明斯克活动”，“圣彼得堡”，以显示在那里发现的活动。 <br></li><li> 停用词：“停止”，“足够”。 如果用户使用此单词结束对话，则表示“谢谢”。 但理想情况下，这里需要语言学家。 <br></li></ul><br> 对于“即将发生的事件”，任何短语都适用。 我创建了一个懒惰的机器人，当他不明白他们在说什么时，他给出了有关接下来三个事件的信息。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: { <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"YANDEX.GEO"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: { <span class="hljs-string"><span class="hljs-string">"house_number"</span></span>: <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">"street"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"city"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } ] } } }</code> </pre> <br>  Yandex逐渐改进了Yandex.Dialogs平台，并发布了它已经能够识别的实体。 例如，他知道如何从文本中获取地址，并将其按部分排序：城市，国家，街道，房屋。 他还知道如何识别绝对和相对的数字和日期。 他将理解“明天”一词是今天的日期，并加上了该日期。 <br><br><h3> 回覆使用者 </h3><br> 您需要以某种方式响应您的用户。 整个技能为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">209行</a> ，最后一行为空。 没什么复杂的-晚上工作。 <br><br> 您要做的就是处理POST请求并获得一个“请求”。 <br><br><pre> <code class="javascript hljs">router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req/ res, next) ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = req.body;</code> </pre> <br> 此外，我并没有使状态机复杂化，而是根据优先级来进行。 如果用户想学习如何使用该机器人，则这是首次启动或寻求帮助。 因此，只为他准备一个“ EmptyResponse”-这就是我所说的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needHelp(request.request)) { res.json(prepareEmptyResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  needHelp函数很简单。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needHelp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; req.nlu.tokens.includes(<span class="hljs-string"><span class="hljs-string">''</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length = <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; req.type ≠ <span class="hljs-string"><span class="hljs-string">'ButtonPressed'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 当我们有零个令牌时，我们就在请求的开始。 用户只是刚开始使用该技能或没有要求。 您需要检查令牌是否为零，并且这不是一个按钮-单击该按钮时，用户也不会说什么。 当用户寻求帮助时，我们会通过令牌查找“ Help”一词。 逻辑很简单。 <br><br> 用户是否要停止。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needToStop(request.request)) { res.json(prepareStopResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br> 因此，我们正在内部寻找某种停用词。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needStop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stopWords = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; stopWords.some(w ⇒ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.includes(w)); }</code> </pre> <br> 在所有答案中，您必须返回Yandex.Dialogs发送的有关会话的信息。 他需要以某种方式匹配您的答案和用户的请求。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { session, version } = req; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">response</span></span>: { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">' .  !'</span></span>, <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, session, version, }; }</code> </pre> <br> 因此，将变量“ session”和“ version”中的内容返回，一切都会好起来的。 在答案中，您可以提供一些文本让爱丽丝发音，然后传递“结束会话：true”。 这意味着我们结束了技能训练并将控制权转移给了爱丽丝。 <br><br> 当您调用一项技能时，爱丽丝会关闭。 她所听到的只是她的停用词，您可以完全控制使用该技能的过程。 因此，您需要返回控制。 <br><br> 用空的请求更有趣。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-string"><span class="hljs-string">"tts"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttons</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: {} hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, } hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, ], <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, session, version, };</code> </pre> <br> 有一个<b>TTS</b> （ <b>文本到语音</b> ）字段<b>语音控制</b> 。 这是一种简单的格式，可让您以不同的方式阅读文本。 例如，“ multidisciplinary”一词在俄语中有两个重音，一个是重音，第二是重音。 任务是爱丽丝能够正确发音这个单词。 您可以使用空格将其断开： <br><br><pre> <code class="plaintext hljs">+ +</code> </pre> <br> 她会把他理解为两个。 加重音。 <br><br> 语音中有些停顿-您放置了标点符号，并用空格分隔。 因此，您可以创建戏剧性的暂停： <br><br><pre> <code class="plaintext hljs"> — - - - - - - - - + </code> </pre> <br> 我已经讲过<b>按钮</b> 。 例如，如果您不与列进行通信，而是与Yandex移动应用程序进行通信，则它们非常重要。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"buttons"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Frontend Conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://frontendconf.ru/moscow-rit/2019"</span></span> , <span class="hljs-string"><span class="hljs-string">"hide"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] } }</code> </pre> <br> 按钮也是提示，您可以根据自己的技能理解短语。 技能在Yandex应用程序中起作用-您可以与界面进行交流。 如果您想提供一些信息-提供链接，则用户单击它。 您也可以为此添加按钮。 <br><br> 有一个“有效负载”字段，您可以在其中添加数据。 然后，他们将返回“请求”-例如，您将知道如何标记此按钮。 <br><br> 您可以选择技能会说的<b>声音</b> 。 <br><br><ul><li>  <b>爱丽丝</b>是<b>爱丽丝</b>的标准声音。 针对短时间互动进行了优化。 <br></li><li>  Oksana-Yandex.Navigator的声音。 <br></li><li> 简 <br></li><li> 扎哈尔。 <br></li><li> 埃尔米尔。 <br></li><li>  <b>Erkan Yavas-</b>长文本。 最初是为了阅读新闻而创建的。 <br></li></ul><br> 要<b>完成该技能</b> ，只需返回“ end_session：true”。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"end_session"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h3> 演示发生了什么 </h3><br> 首先，我按日期过滤。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> events.filter(event ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.start).getTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (start &gt; current) || (event.end &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.end).getTime() &gt; current &amp;&amp; start ≤ current); }); }</code> </pre> <br> 逻辑很简单：在我从日历中解析的所有事件中，我都会考虑将来会发生的事情，或者它们正在发生。 询问过去发生的事情可能很奇怪-技能与之无关。 <br><br> 接下来，进行适当的过滤就是它的全部目的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByPlace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events, req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cities = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoEntities = req.nlu.entities.filter(e ⇒ e.type = <span class="hljs-string"><span class="hljs-string">'YANDEX.GEO'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.payload &amp;&amp; req.payload.city) cities.add(req.payload.city); geoEntities.forEach(e ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = e.value.city &amp;&amp; e.value.city.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (city &amp;&amp; !cities.has(city)) { cities.add(city); } });</code> </pre> <br> 在“实体”中，您可以找到YANDEX.GEO实体，该实体可以优化位置。 如果实体有城市，请添加到我们的集合中。 接下来，逻辑也很简单。 我们正在寻找代币中的这座城市，如果在那里，我们正在寻找用户想要的东西。 如果没有，我们将查看我们拥有的所有“位置”和“事件”。 <br><br> 假设Yandex不能识别出它是YANDEX.GEO，但是用户给城市起了名字-他确定那里有事。 我们在“事件”中遍历所有城市，并在代币中寻找相同的城市。 结果是数组的交叉比较。 当然，不是最有效的方式，而是什么。 这就是全部技能！ <br><br> 请不要责骂我的代码-我写的很快。 那里的一切都是原始的，但是请尝试使用它或只是玩耍。 <br><br><h3> 发布技能 </h3><br> 转到Yandex.Dialogs页面。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38e/4d1/ca6/38e4d1ca6e2f548fea625649f85c834f.jpg"><br><br> 在爱丽丝中选择一项技能。 按下“创建对话”按钮，您将进入需要填写数据的表格。 <br><br><ul><li>  <b>名称</b>就是对话中的名称。 <br></li><li>  <b>激活名称</b> 。 如果您通过连字符选择激活名称“ Web Standards Calendar”，则Alice无法识别它-她不会听到连字符。 我们说的单词没有连字符，激活将不起作用。 为了赚钱，将名称设置为“ Web Standards Calendar”。 <br></li><li>  <b>激活短语</b>以启动技能。 如果这是一个游戏，则“让我们玩些游戏”，“问某人”。 集合是有限的，但这是因为这样的短语对爱丽丝来说是激活的。 她必须了解是该学习技巧的时候了。 <br></li><li>  <b>Webhook URL</b> -Alice将POST请求发送到的地址。 <br></li><li>  <b>声音</b> 。 默认值为Oksana。 因此，在目录中许多她的声音，而不是爱丽丝。 <br></li><li>  <b>是否需要带屏幕的设备？</b> 如果有图片，则该技能的使用将仅限于您-在该列上，用户将无法启动它。 <br></li><li>  <b>私人技能</b>是开发人员的重要领域。 如果您不准备公开发布该技能，仅仅是因为它是原始技能，那么我们就不会在目录中显示它，从而限制了隐私。 私人技能可以在几个小时内迅速掌握。 这些技能不需要经过全面测试-足以与激活名称匹配。 由于用户不会在目录中找到它们，因此他们更忠于他们。 <br></li><li>  <b>主持人注意事项</b> 。 我请主持人提供帮助：“我真的很需要会议演示的技能！”  -我设法很快地通过了审核。 <br></li><li>  <b>版权</b> 。 如果您不是在条件银行工作，而是决定为其创建技能，则需要证明您有权这样做。 突然他们会来找你吗？ 他们肯定会来，并通过分销商，即Yandex来，不需要额外的问题。 </li></ul><br> 完成-发送进行审核的技能，即可进行测试。 <br><br><h2> 测试中 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我写了一个普通的Express服务器。</font><font style="vertical-align: inherit;">这是常规测试涵盖的简单API。</font><font style="vertical-align: inherit;">有专门的实用程序，例如alice-tester-它知道如何使用Alice提供的确切格式。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> assert = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'assert'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'alice-tester'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should show help'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.enter(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.say(<span class="hljs-string"><span class="hljs-string">'  ?'</span></span>); assert.equal(user.response.text, <span class="hljs-string"><span class="hljs-string">'    .'</span></span>); assert.equal(user.response.tts, <span class="hljs-string"><span class="hljs-string">'    +.'</span></span>); assert.deepEqual(user.response.buttons, [{<span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">hide</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]); }]);</code> </pre><br>       .,     «». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ee/4ea/71f/2ee4ea71f971a916074c47ffc3434ef0.jpg"><br><br>  ,   ,      .   ,     : , ,     .   ,   —    ,    .    Postman —  . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> .</a> .   Just AI.   ,   ,          . <br><br>  <b> </b> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dialogs.home.popstas.ru</a>  URL, ,  localhost.    ,     debug.    ,      localhost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/2d0/706/d8a2d07069f511e397d6a77f8bf4fd0b.jpg"><br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b> </b></a> .  —    .    URL  ,    -       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/243/89a/f0b/24389af0bfe571fc85a0b937e0a64406.jpg"><br><br><blockquote>     —     . </blockquote><br> ,    , ,  . <br><br>  —    <b> </b> .  ,    ,    ,   ,  ,    . - -           . <br><br><h2>    </h2><br>         <b>Dialogflow</b> ,     Google Now. ,    —  ,     — . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/471/fe9/b76/471fe9b76fd59e898ed4dae0a455733a.jpg"><br><br>    ,      .      .   ,         .     ,    . <br><br>   Google Dialogflow  .,  <b>Dialogflower</b> .          Alexa,   Google Now,   . —   API,      . <br><br>   ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Aimyloqic</a> —    .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zenbot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tortu</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alfa.Bot</a> —  ,   . ! <br><br><h2>     </h2><br> <b>   FAQ</b> .    ,     .    ,      ,  . <br><br> <b></b> .   ,  ,     ,     .    —   ,    .     ,      .    ,    . <br><br>    <b>IFTTT</b> ,      —     Trello.    —    API.         ,  ,     .        , IFTT —     . <br><br>    <b>  </b> .      ,  .   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a25/418/1b4a25418eaaf223dfb8e0744404b7a0.jpg"><br><br> ,  «»     . <br><br>         .     Xiaomi    .  .       . ,    Arduino - --- ,  ,   : «,  -  2000!»       — ! <br><br>     ,     : «,  !» —   !        . ,       . <br><br><h2>      </h2><br> <b>  </b> . ,    ,   :  ,   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> .</a> .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    .</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub-</a>     .,   .     —   . <br><br> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Telegram- .</a></b> .    —    .    ,        .        .    . <br><br> <b>  </b> .       ,      .  - ,        .          , .   .   ,     . ,    : , -,    ,        .  , ,        .   : « ,    ?» ,      ,  ,       . <br><br> <b></b> —    ,       .     . <br><br> .   —  .     ,   ,      . ,       . <br><br><blockquote>     ,     ,   - ,      ! <br></blockquote><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> —     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> —   .     .   —   — ! <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FrontendConf 2019</a>      « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS —  </a> ».      —      .  ,     FrontendConf 2019  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . ,     ,     ,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>  . <br><br>      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468545/">https://habr.com/ru/post/zh-CN468545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468533/index.html">使用Express 42在DevOps上搭便车</a></li>
<li><a href="../zh-CN468535/index.html">不需要日志？</a></li>
<li><a href="../zh-CN468537/index.html">DevOps的基础知识。 从头开始进入项目</a></li>
<li><a href="../zh-CN468541/index.html">拖放-和-拖放组件供盲人使用？ 你在开玩笑吗</a></li>
<li><a href="../zh-CN468543/index.html">平日程序委员会FrontendConf。 谢尔盖·波波夫专访</a></li>
<li><a href="../zh-CN468547/index.html">FrontendConf的英语，CSS，网格和可访问性</a></li>
<li><a href="../zh-CN468549/index.html">GPU绑定。 如何将所有内容传输到视频卡等等。 动画制作</a></li>
<li><a href="../zh-CN468553/index.html">与版本控制系统类似的业务应用程序中的参数管理</a></li>
<li><a href="../zh-CN468555/index.html">C / C ++中的确定性程序集简介。 第二部分</a></li>
<li><a href="../zh-CN468557/index.html">WEB 3.0-射弹的第二种方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>