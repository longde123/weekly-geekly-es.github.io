<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 🏇🏿 🆒 Développement de programmes pour le processeur central Redd utilisant l'accès au FPGA 🤵🏼 👋🏻 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, j'ai dit qu'il était temps pour nous de passer aux protocoles de streaming. Mais après avoir commencé à préparer une histoi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de programmes pour le processeur central Redd utilisant l'accès au FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456008/">  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> j'ai dit qu'il était temps pour nous de passer aux protocoles de streaming.  Mais après avoir commencé à préparer une histoire à leur sujet, j'ai réalisé que je nage moi-même dans un sujet très important.  Comme déjà noté, ma relation avec Linux est assez particulière.  En général, je me suis rendu compte que je ne pouvais pas moi-même créer à partir de zéro une application C ++ qui satisferait tous les principes de programmation pour Redd.  Vous pouvez demander à quelqu'un de le faire, puis utiliser simplement le modèle prêt à l'emploi, mais la série d'articles est conçue pour enseigner à tout le monde comment développer sous Redd à partir de zéro.  Par conséquent, j'ai demandé à mon patron (un grand spécialiste de Linux), et il m'a expliqué sur quoi cliquer.  Puis j'ai légèrement repensé ses paroles et maintenant je considère qu'il est nécessaire de fixer toutes les connaissances par écrit.  Cela sauvera des gens comme moi de pensées douloureuses: "Alors ... Ce qu'il a fait est compréhensible, mais comment puis-je répéter cela?"  En général, toute personne travaillant sous Linux peut exécuter les deux sections suivantes en diagonale.  Il est peu probable que vous y trouviez quelque chose de nouveau (vous trouverez plus loin).  Et pour le reste, je propose un choix de deux méthodes de développement qui correspondent aux principes déclarés de travailler sous Redd: des coûts de main d'œuvre bas pour le développement et le débogage à distance. <br><br><img src="https://habrastorage.org/webt/kb/sk/5c/kbsk5cbh98eftndkgneifjnzgao.jpeg"><br><a name="habracut"></a><br>  Tous les articles du cycle: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développement du «firmware» le plus simple pour les FPGA installés dans Redd, et débogage en utilisant le test de mémoire comme exemple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développement du «firmware» le plus simple pour les FPGA installés dans Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Code de programme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développement de son propre noyau pour l'intégration dans un système de processeur basé sur FPGA</a> </li></ol><br><h2>  Travailler avec Visual Studio Tools </h2><br>  Il s'avère que vous pouvez effectuer le développement pour Linux distant, sans l'avoir du tout sur votre machine locale et sans installer d'outils logiciels non Microsoft.  Ici, il est montré comment il est mis sur Visual Studio (je l'ai installé dans la version 2019, mais il semble qu'il soit apparu en 2015) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.microsoft.com/ru-ru/cpp/linux/download-install-and-setup- the-linux-development-workload? view = vs-2019</a> <br><br>  Et voici la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">théorie du travail</a> . <br><br>  Eh bien, là, vous pouvez vous promener dans les onglets, beaucoup de théorie et tout en russe. <br><br>  Super!  Essayons d'utiliser les connaissances acquises pour accéder à la puce FT2232H, à travers laquelle le processeur central Redd est connecté au FPGA.  C'est cette chaîne à l'avenir qui constituera la base de notre travail de streaming.  Ouvrez Visual Studio, sélectionnez «Créer un projet».  Dans les filtres, sélectionnez "Langage - C ++", "Plateforme - Linux", "Type de projet - Console".  Je montrerai où cela se trouve déjà pour le type de projet.  A partir de ce que nous avons filtré, nous sélectionnons «Application console»: <br><br><img src="https://habrastorage.org/webt/ao/5x/h4/ao5xh4h5fwoldpjdn_-rpx8ay2a.png"><br><br>  Appelons-le, disons, SimpleConsole.  Nous avons créé un tel code source Spartan: <br><br><pre><code class="plaintext hljs">#include &lt;cstdio&gt; int main() { printf("hello from SimpleConsole!\n"); return 0; }</code> </pre> <br>  Essayons de le collecter.  Et on nous pose une question très intéressante sur l'établissement d'une connexion.  Il s'agit d'une fonctionnalité de développement dans Visual Studio.  L'environnement ne contient pas de compilateur croisé et aucune bibliothèque.  Il crée simplement un répertoire source sur la machine distante, après quoi, pour chaque compilation, il y copie les fichiers mis à jour et y démarre la compilation.  C'est pourquoi la connexion avec la machine distante ne doit pas être établie pour démarrer, mais déjà pour l'assemblage normal du projet. <br><br>  Nous remplissons les paramètres pour l'utilisateur Redd, pour le compte duquel les travaux seront effectués sur le projet. <br><br><img src="https://habrastorage.org/webt/jd/sx/hk/jdsxhkvvklw29zjoecvrr1svvda.png"><br><br>  Si quelque chose - les paramètres peuvent être modifiés ici dans cet endroit secret (n'essayez pas de changer les propriétés du projet, cela ne mènera à rien de bon): <br><br><img src="https://habrastorage.org/webt/dn/xe/yd/dnxeydmzx11e50rtxzjayuleto0.png"><br><br><img src="https://habrastorage.org/webt/ow/k-/le/owk-leapmriognn1l-kk4tavvyc.png"><br><br>  En fait, vous pouvez mettre un point d'arrêt sur une seule ligne et vérifier que le projet démarre et fonctionne.  Mais c'est trivial.  Par conséquent, nous passons à une tâche plus intéressante - travailler avec FT2232.  La question se pose: où trouver les bibliothèques nécessaires?  Pour Linux, tout est inclus dans le package de pilotes.  Il y a le pilote lui-même, et les bibliothèques, et des exemples d'applications pour travailler avec eux, et même une brève instruction.  En général, nous entrons dans le moteur de recherche: <br><br><pre> <code class="plaintext hljs">FTDI D2XX drivers</code> </pre> <br>  Il montrera où ils peuvent être téléchargés.  Certes, tout était mauvais pour moi.  Mon fournisseur bloque le site Web FTDI (ainsi que reprap, 7zip et même osronline), se référant à RosKomNadzor.  ILV, en réponse aux déclarations, envoie des désabonnements, disant que nous ne bloquons rien, mais traitons avec le fournisseur vous-même.  Où seulement dans ces désabonnements ne m'ont-ils pas proposé de me tourner, même à la police.  Ils sont très désabonnés.  Les tentatives de se plaindre de l'inaction d'ILV finissent par être transmises à ILV, d'où proviennent les prochains désabonnements.  En général, il se peut que votre fournisseur bloque également l'accès.  Ne vous inquiétez pas, recherchez simplement d'autres moyens de télécharger, en y consacrant du temps.  Et puis ils sont surpris que les dates de développement des missiles soient retardées de plusieurs dizaines d'années ... J'ai commencé la correspondance avec ILV en novembre dernier, maintenant c'est en juin, sauf pour les désabonnements - aucune action ... Mais j'ai été distrait. <br><br>  Comment utiliser les pilotes peut être trouvé dans le fichier readme, dans le package lui-même.  Vous pouvez également trouver le document <b>Guide d'installation des pilotes FTDI AN_220 pour Linux</b> .  Enfin, vous pouvez trouver sur YouTube une vidéo du <b>Guide d'installation du pilote Linux d2xx</b> par FTDI Chips.  Un lien vers celui-ci se trouve également sur la page de téléchargement du pilote.  En général, FTDI n'a pas hésité sur les options d'information des utilisateurs.  En fait, si vous avez reçu un package Redd prêt à l'emploi, les pilotes eux-mêmes sont déjà installés et configurés dessus.  Et nous serons intéressés par des fichiers d'en-tête et des exemples. <br><br>  Insérons un exemple de tranche <b>\ release \ examples \ EEPROM \ read</b> .  Le tout début de la fonction <b>principale</b> , où l'appareil s'ouvre et son type est pris.  Ce sera suffisant pour vous assurer que tout fonctionne.  Je déteste les étiquettes, mais comme nous glissons et déposons rapidement le code qui dure 10 minutes, je vais faire glisser l'étiquette qui était dans l'exemple d'origine pour gagner du temps.  Il se présente comme ceci: <br><br><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include "ftd2xx.h" int main(int argc, char* argv[]) { printf("hello from ConsoleApplication1!\n"); FT_STATUS ftStatus; FT_HANDLE ftHandle0; int iport; static FT_PROGRAM_DATA Data; static FT_DEVICE ftDevice; DWORD libraryVersion = 0; int retCode = 0; ftStatus = FT_GetLibraryVersion(&amp;libraryVersion); if (ftStatus == FT_OK) { printf("Library version = 0x%x\n", (unsigned int)libraryVersion); } else { printf("Error reading library version.\n"); return 1; } if (argc &gt; 1) { sscanf(argv[1], "%d", &amp;iport); } else { iport = 0; } printf("Opening port %d\n", iport); ftStatus = FT_Open(iport, &amp;ftHandle0); if (ftStatus != FT_OK) { /* This can fail if the ftdi_sio driver is loaded use lsmod to check this and rmmod ftdi_sio to remove also rmmod usbserial */ printf("FT_Open(%d) failed\n", iport); return 1; } printf("FT_Open succeeded. Handle is %p\n", ftHandle0); ftStatus = FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL); if (ftStatus != FT_OK) { printf("FT_GetDeviceType FAILED!\n"); retCode = 1; goto exit; } printf("FT_GetDeviceInfo succeeded. Device is type %d.\n", (int)ftDevice); exit: return 0; }</code> </pre><br>  Essayer de collecter - ne va pas.  Pas assez de fichiers d'en-tête. <br><br><pre> <code class="plaintext hljs">1&gt;main.cpp 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : ftd2xx.h:      1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : #include "ftd2xx.h" 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : ^ 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : compilation terminated.</code> </pre><br>  Mais je les mets ensuite!  Tout est simple.  Localement, ils sont à proximité, mais le montage se fait à distance.  Pour que le Studio les transfère sur une machine distante, vous devez les ajouter au projet.  De plus, à partir du fichier <b>main.cpp</b> , j'ajoute uniquement <b>ftd2xx.h</b> , mais il <b>tire</b> toujours <b>WinTypes.h en transit</b> .  Vous devez ajouter les deux. <br><br><img src="https://habrastorage.org/webt/gy/-2/-j/gy-2-jt8ej_mbavcpupdsphb5g8.png"><br><br><img src="https://habrastorage.org/webt/kp/ye/l1/kpyel11pdcxgnd5ojt39rhkkslk.png"><br><br>  Maintenant, l'éditeur de liens jure. <br><br><pre> <code class="plaintext hljs">1&gt;  1&gt;D:\Work\SimpleConsole\SimpleConsole\obj\x64\Debug\main.o : error : In function `main': 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(18): error : undefined reference to `FT_GetLibraryVersion' 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(37): error : undefined reference to `FT_Open' 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(55): error : undefined reference to `FT_GetDeviceInfo' 1&gt;collect2 : error : ld returned 1 exit status</code> </pre><br>  Il est clair qu'il n'y a pas assez de bibliothèque.  En inspectant les <b>makefiles de l'</b> exemple, j'ai réalisé que je devais ajouter quelques paramètres aux paramètres de l'éditeur de liens: <br><br><img src="https://habrastorage.org/webt/xy/zm/2i/xyzm2igciaxlmevvppuug4vk2go.png"><br><br><img src="https://habrastorage.org/webt/xd/p2/f1/xdp2f1nxqd3bue69dqx8m-dgabc.png"><br><br>  Maintenant, le projet se déroule avec succès.  Nous avons mis un point d'arrêt sur la dernière ligne, essayons de courir.  Nous voyons le texte suivant: <br><br><pre> <code class="plaintext hljs">hello from ConsoleApplication1! Library version = 0x10408 Opening port 0 FT_Open succeeded. Handle is 0x555555768540 FT_GetDeviceInfo succeeded. Device is type 10.</code> </pre><br>  Dans l'ensemble - pas mal.  Quelque chose s'est ouvert, même un appareil a été trouvé.  Qu'est-ce que le type 10?  Dans le fichier d'en-tête de FTDI, nous trouvons: <br><br><pre> <code class="plaintext hljs">enum { FT_DEVICE_BM, FT_DEVICE_AM, FT_DEVICE_100AX, FT_DEVICE_UNKNOWN, FT_DEVICE_2232C, FT_DEVICE_232R, FT_DEVICE_2232H, FT_DEVICE_4232H, FT_DEVICE_232H, FT_DEVICE_X_SERIES, FT_DEVICE_4222H_0, FT_DEVICE_4222H_1_2, FT_DEVICE_4222H_3, FT_DEVICE_4222_PROG, };</code> </pre><br>  Nous comptons le doigt de haut en bas - devant nous est le FT4222H.  Oui, Redd a beaucoup d'appareils FTDI.  Maintenant, je vais simplement dire brièvement que nous devons trier le numéro du périphérique passé à la fonction <b>FT_Open ()</b> , ce nombre est passé à la fonction <b>main ()</b> comme argument.  Il peut être défini dans les propriétés de débogage du projet. <br><br>  Il est utile de placer une plaque présentant des problèmes typiques.  Généralement, il est indiqué «configurer Redd» partout sans détails.  Le fait est que les complexes seront distribués sur mesure, donc tous les lecteurs n'ont pas besoin de règles de configuration.  En cas de problème, les administrateurs s'occupent généralement de la configuration.  Il s'avère donc que vous pouvez, bien sûr, décrire les règles de configuration, mais cela prendra beaucoup de place.  Il est logique de consacrer de l'énergie à cela uniquement si quelqu'un en a vraiment besoin.  Alors ici, je me limiterai à indiquer les problèmes et comment les résoudre, je décrirai s'il y a des applications dans les commentaires. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Symptôme </th><th>  Raison </th></tr><tr><td>  Pas un seul appareil ne s'ouvre. </td><td>  Par défaut, Linux nécessite des droits d'administrateur pour ouvrir des périphériques USB, mais l'utilisateur qui se connecte pour le débogage ne les possède pas.  Vous devez configurer les ports afin qu'ils puissent être utilisés par un utilisateur normal. </td></tr><tr><td>  Seuls quelques appareils s'ouvrent, les deux FT4222H. </td><td>  Par défaut, un pilote de port COM virtuel standard est installé sur le contrôleur FT2232H.  Vous devez dire au système d'exploitation de ne pas le faire. </td></tr><tr><td>  Aucune bibliothèque trouvée. </td><td>  Les pilotes D2XX ne sont pas installés sur le système d'exploitation du périphérique Redd. </td></tr></tbody></table></div><br>  Super.  Nous sommes prêts pour des réalisations utilisant exclusivement des outils Microsoft.  En général, cela peut être suffisant, mais juste au cas où, je vais vous parler d'une alternative que mon patron m'a apprise. <br><br><h2>  Travailler avec Linux exécuté sur une machine virtuelle </h2><br>  Le principal inconvénient de la méthode précédente est l'assemblage à distance.  Vous pouvez penser à mille et une raisons pour lesquelles l'assemblage doit être fait localement, et seul le fichier binaire terminé sera transféré vers la machine distante.  Ce sont toutes sortes de restrictions paranoïaques (bien que les fichiers soient transférés à l'aide d'un protocole sécurisé, et vous pouvez séparer leur stockage des autres utilisateurs avec des politiques de sécurité), c'est juste le soin que le lecteur Redd ne déborde pas de toutes sortes de bibliothèques, c'est aussi la réticence à enregistrer chaque fichier d'en-tête, s'il y en a des milliers ... Eh bien, et bien plus encore.  En général, la technique d'assemblage local peut être utile, alors pensez-y. <br><br>  Tout d'abord, nous avons placé le programme VirtualBox d'Oracle sur la machine locale.  S'il y a des problèmes de licence (je l'utilise gratuitement, en tant qu'individu, mais je ne sais pas exactement ce qui se passe avec les entités juridiques), sélectionnez une machine physique distincte et mettez Linux à cet endroit.  Lequel?  C’est plus facile pour moi, je les comprends tous de la même façon.  Je veux dire, je ne comprends presque pas un.  Par conséquent, le patron m'a dit que vous devez utiliser Debian, j'ai installé Debian.  Vous pouvez suivre le même chemin (utilisez le principe «Pourquoi pas?»).  Au moins à l'avenir, je compterai sur ma collaboration avec lui. <br><br>  Lorsque vous travaillez avec Linux, vous devez respecter deux règles qui facilitent grandement la vie: <br><br><ol><li>  Si, en réponse à une commande, ils nous disent qu'il n'y a pas assez de droits, cela vaut la peine de le répéter, en ajoutant au début le sort magique <b>sudo</b> . </li><li>  Si en réponse à une commande, on nous dit qu'il n'en existe pas, cela vaut la peine d'essayer de l'installer en lançant le sort magique <b>apt-get install &lt;chose manquante&gt;</b> . </li></ol><br>  Alors.  Nous venons d'installer le système d'exploitation.  Ajoutez immédiatement la prise en charge C ++ en installant le compilateur g ++, ainsi que le débogueur gdb.  Comment?  Donc, en utilisant la règle 2: <br><br>  <b>apt-get install g ++</b> <b><br></b>  <b>apt-get install gdb</b> <br><br>  Ne donnez pas?  Super!  Répétez en utilisant la règle 1: <br><br>  <b>sudo apt-get install g ++</b> <b><br></b>  <b>sudo apt-get install gdb</b> <br><br>  Maintenant on va sur Internet, dans le moteur de recherche on tape: <br><br>  <b>IDE Eclipse</b> <br><br>  Nous trouvons un lien vers eclipse.org, où les premières options sont pour Java, nous trouvons et téléchargeons une option pour C / C ++: <br><br><img src="https://habrastorage.org/webt/96/qw/qk/96qwqkb0litad1r1tujou2a9bae.png"><br><br>  Téléchargez et déballez, disons, à la maison. <br><br>  En fait, aucune installation n'est requise.  Accédez simplement au répertoire où tout vient d'être décompressé et exécutez le fichier eclipse: <br><br><img src="https://habrastorage.org/webt/ir/70/5r/ir705r0y6iwxnnixuxatl8ajg5m.png"><br><br>  Nous sommes dans un environnement de développement.  Eh bien, si vous avez déjà travaillé avec des microcontrôleurs et même des cœurs de processeur pour FPGA, vous savez probablement déjà ce qu'est Eclipse.  Les choses inconnues sont donc presque terminées.  Nous commençons à regarder autour de choses plus ou moins familières.  Nous créons le projet C ++.  Je dois dire tout de suite qu'il y a deux façons.  L'un mènera au succès, le second à une impasse.  Par conséquent, suivez attentivement le chemin que je parcours: <br><br><img src="https://habrastorage.org/webt/pn/p2/am/pnp2amrhevvek40jz7nqsocol5g.png"><br><br><img src="https://habrastorage.org/webt/a_/ge/sx/a_gesxu9d6u_hhbocj0mqah5xik.png"><br><br><img src="https://habrastorage.org/webt/14/zg/b0/14zgb0day-st8r8cyejyvxahtsk.png"><br><br>  Nous avons créé un projet qui va bien.  Pour configurer son débogage, accédez aux propriétés GDB: <br><br><img src="https://habrastorage.org/webt/zd/zf/tz/zdzftzvpbfwkbs1mphkqdyrfv1a.png"><br><br>  Créez une configuration de type Application distante C / C ++, dans le groupe Connexion, cliquez sur Nouveau: <br><br><img src="https://habrastorage.org/webt/u1/dy/wb/u1dywbnrislxi82tujf7k3crbks.png"><br><br>  Choisissez une connexion comme SSH: <br><br><img src="https://habrastorage.org/webt/j8/nt/td/j8nttddgczes40njsbis01oamzi.png"><br><br>  Nous remplissons les propriétés de connexion en basculant le bouton radio du type d'autorisation sur l'autorisation de mot de passe: <br><br><img src="https://habrastorage.org/webt/i_/we/l1/i_wel1jpfgrjiale5pgsh7un8mg.png"><br><br>  En fait, le système est prêt pour le débogage.  Après avoir vérifié que le texte de bienvenue est réellement affiché, nous essayons de transférer le code de l'exemple précédent (qui était dans Visual Studio) ici.  Pour enregistrer des bibliothèques supplémentaires, sélectionnez les propriétés du projet: <br><br><img src="https://habrastorage.org/webt/9i/b0/7r/9ib07rvhf55tqf7hvkewqsqbqau.png"><br><br>  De plus, comme l'assembly se déroule localement, les bibliothèques doivent également se trouver dans le répertoire local usr / local / lib.  Je vous rappelle que les bibliothèques sont téléchargées avec le pilote, et comment les installer est lisez-moi, ainsi que les vidéos AN220 et YouTube, pour plus de détails, voir la section sur Visual Studio. <br><br>  Après toute cette préparation, nous obtenons les lignes familières.  C'est-à-dire que le code complètement identique à celui considéré dans la section précédente est exécuté de la même manière. <br><br>  C’est tout.  Maintenant, selon la situation, nous pouvons exécuter le code à la fois via Visual Studio et via une machine virtuelle.  Comme vous pouvez le voir, purement en termes de paramètres, Visual Studio est plus simple, donc, ceteris paribus, je vais le choisir.  Mais il vaut mieux posséder les deux technologies, car travailler à travers le Studio a ses inconvénients liés au fait que non seulement le débogage, mais aussi l'assemblage y sont distants. <br><br><h2>  Mesure de vitesse d'écriture FPGA via FT2232H </h2><br>  Eh bien quoi.  Fixons les compétences acquises sur un projet plus ou moins réel.  Bien sûr, commencer quelque chose de très sérieux n'est plus possible, tout le monde est déjà fatigué.  Mais nous obtenons un résultat plus ou moins pratique.  Par exemple, nous mesurons à quelle vitesse maximale nous pouvons transférer des données vers le FPGA via la puce FT2232H.  Le protocole n’est pas le plus simple, donc nous ne le transmettrons pas des deux côtés, mais nous nous limiterons à transmettre de nous au canal, à l’autre extrémité où le FPGA est installé.  Le document <b>AN_130 FT2232H utilisé dans un mode FIFO synchrone de style FT245</b> nous y aidera, car dans le complexe le contrôleur est activé précisément dans ce mode (FIFO synchrone).  Ce document contient également une description des conclusions, sous la forme dans laquelle elles sont utilisées dans ce mode, et des chronogrammes, et même des exemples de code, dont nous nous inspirerons. <br><br>  Alors.  Nous voulons enregistrer en FIFO en utilisant le contrôleur.  Qu'adviendra-t-il de nous?  J'ai essayé, je sais.  Cela prendra 1 kilo-octet de données, après quoi le contrôleur se bloquera.  Il refusera d'accepter des données supplémentaires.  Le fait est qu'un kilo-octet est la taille de son tampon interne.  Bien que cela soit possible, les données seront prises à partir de l'USB et stockées dans cet espace.  Mais pour qu'ils se rendent sur le canal synchrone, il doit informer de leur disponibilité à les recevoir.  Nous regardons le fortune de fortune correspondant. <br><br><img src="https://habrastorage.org/webt/qq/9x/lj/qq9xljp4ma4jlpcprp5emofdraa.png"><br><br>  Alors.  Lorsque le contrôleur a des données en FIFO, il supprime le signal RXF.  En réponse à cela, nous devons d'abord supprimer le signal OE et le maintenir à zéro pendant au moins un cycle d'horloge (cela découle plus de la description du diagramme que du diagramme lui-même).  Nous recevrons des données sur le bus, nous devons confirmer leur réception avec un faible niveau de signal RD.  Et donc - pour l'ensemble du cadre.  Lorsque le contrôleur soulève la ligne RXF, nous devons supprimer l'OE et le RD.  Nous n'utiliserons pas les données aujourd'hui.  Pour mesurer la vitesse, simulez simplement la réception de données sur le FPGA du FT2232H.  Eh bien.  Pour une opération aussi simple, aucun système de processeur n'est nécessaire.  Il suffit de faire un automate dégénéré, dont le développement prendra beaucoup moins de temps que de s'occuper de la préparation du processeur et du programme.  Par conséquent, nous créons un projet contenant un seul fichier SystemVerilog avec le contenu suivant: <br><br><pre> <code class="plaintext hljs">module JustRead( input logic clk, input logic rxf_n, output logic oe_n, output logic rd_n ); enum {IDLE,TRANSFER} state = IDLE; always @ (posedge clk) begin oe_n &lt;= 1; rd_n &lt;= 1; case (state) IDLE: begin if (rxf_n == 0) begin oe_n &lt;= 0; state &lt;= TRANSFER; end end TRANSFER: begin if (rxf_n == 0) begin oe_n &lt;= 0; rd_n &lt;= 0; end else begin state &lt;= IDLE; end end endcase end endmodule</code> </pre><br>  La machine a deux états.  Dans ce cas, la durée du signal OE est déterminée par le fait qu'il est armé immédiatement après l'impulsion d'horloge et est maintenu jusqu'à la suivante.  Cela peut être vérifié en utilisant le modèle suivant: <br><br><pre> <code class="plaintext hljs">module JustReadTB( output logic clk, output logic rxf_n, input logic oe_n, input logic rd_n ); JustRead dut ( .clk, .rxf_n, .oe_n, .rd_n ); always begin clk = 1; #16; clk = 0; #16; end initial begin rxf_n = 1; #120; rxf_n = 0; #120; rxf_n = 1; end endmodule</code> </pre><br>  Le temps que j'ai pris est le premier disponible, c'est la séquence de commutation qui est attachée au signal d'horloge qui est importante.  Nous obtenons le chronogramme suivant: <br><br> <a href=""><img src="https://habrastorage.org/webt/ps/kw/jw/pskwjww-komvozbyogvdndsukq8.png"></a> <br><br>  En première approximation, cela correspond à ce que requiert le document.  Mais nous ne traiterons pas les données réelles de toute façon. <br><br>  L'affectation des jambes FPGA dans ce projet ne pose pas non plus de difficultés, même pour l'édition via une table (il faudra plus de temps pour transférer les affectations à partir du fichier * .QSF, et je souligne constamment que lors du développement de systèmes d'un jour sous Redd, gagner du temps est une priorité). <br><br><img src="https://habrastorage.org/webt/kp/8s/wq/kp8swq3ni8n0x02znmnexvjpfsk.png"><br><br>  Nous collectons, remplissons, avant de couper l'alimentation du complexe, vous pouvez travailler avec le programme, il ne se bloquera plus après un débordement de tampon. <br><br>  Dans le programme, j'ai fait deux fonctions.  Le premier recherche et ouvre l'appareil.  J'ai pris quelque chose du dernier test, j'ai emprunté quelque chose à <b>AN130</b> : <br><br><pre> <code class="plaintext hljs">FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, maxBlockSize, maxBlockSize); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } }</code> </pre><br>  En tant que fan de Windows, j'ai dû écrire la fonction de mesure de vitesse, en vérifiant constamment Internet, car j'utilise généralement les minuteries haute résolution classiques de l'API WIN32.  Vous pouvez peut-être écrire plus efficacement, mais il s'agit d'un programme d'une journée. <br><br><pre> <code class="plaintext hljs">const int maxBlockSize = 0x100000; uint8_t buf[maxBlockSize]; … //   BlockSize ,  1 double TestSpeed(FT_HANDLE ftHandle0,int totalSize, int blockSize) { if (blockSize &gt; maxBlockSize) { return -1; } DWORD dwWrittenTotal = 0; timespec before; clock_gettime(CLOCK_REALTIME, &amp;before); for (int i = 0; i &lt; totalSize; i += blockSize) { DWORD dwWritten; FT_Write(ftHandle0, buf, blockSize, &amp;dwWritten); //     dwWrittenTotal += dwWritten; } timespec after; clock_gettime(CLOCK_REALTIME, &amp;after); if (dwWrittenTotal &lt; (DWORD)totalSize) { return -2; } //     uint64_t nsBefore = before.tv_nsec; uint64_t nsAfter = after.tv_nsec; //      nsAfter += (after.tv_sec - before.tv_sec) * 1000000000; //   nsAfter -= nsBefore; //      double res = ((double)nsAfter)/((double)1000000000); //   -    return ((double)dwWrittenTotal) / res; }</code> </pre><br>  Eh bien, le code qui exécute la fonctionnalité de base s'est avéré comme ceci: <br><br><pre> <code class="plaintext hljs">int main(int argc, char* argv[]) { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } const int totalSize = 0x100000; static const int blockSizes[] = { 0x10,0x20,0x40,0x80,0x100,0x200,0x400,0x800,0x1000,0x2000, 0x4000,0x8000,0x10000,0x20000,0x40000,0x80000,0 }; for (int i = 0; blockSizes[i] != 0; i++) { double speed = TestSpeed(ftHandle0, totalSize, blockSizes[i]); printf("%d,%d\n", blockSizes[i], (int)(speed/1000.)); int stop = 0; } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br>  Je sais qu'en USB, la vitesse dépend fortement de la taille du bloc envoyé, donc je vérifie la vitesse pour différentes options.  L'énumération linéaire n'est guère nécessaire.  Je viens de vous présenter une liste de tailles typiques.  Je produis les données en kilo-octets par seconde.  Les octets sont inconfortables pour les yeux, les mégaoctets ont une faible résolution avec une petite taille de bloc.  Les kilo-octets par seconde sont un compromis raisonnable.  Nous obtenons les résultats suivants: <br><pre> <code class="plaintext hljs">16,59 32,110 64,237 128,490 256,932 512,1974 1024,3760 2048,5594 4096,10729 8192,16109 16384,20170 32768,24248 65536,26664 131072,28583 262144,29370 524288,29832</code> </pre><br>  Nous les enregistrons dans un fichier * .csv, les chargeons dans Excel, construisons un graphique de la vitesse en fonction de la taille du bloc. <br><br><img src="https://habrastorage.org/webt/_o/ep/xe/_oepxe_wz65g7otcfeo3qete8xa.png"><br><br>  La limite est de 30 mégaoctets par seconde.  Jusqu'à un maximum théorique de 52 Mo / s.  Peut-être pouvez-vous accélérer d'une manière ou d'une autre, mais laissez-le aux lecteurs sous forme de travaux pratiques.  L'essentiel est que nous maîtrisions toutes les étapes de l'utilisation du canal et sommes prêts à connecter le FPGA au processeur central en un seul système. <br><br>  Pendant la <b>compilation de</b> l'article, le document <b>AN_165 a</b> été trouvé, indiquant que la vitesse maximale en mode FIFO synchrone était de 35 Mo / s.  Autrement dit, l'espace pour la croissance - jusqu'à une taille donnée.  Mais il est toujours là. <br><br><h2>  Conclusion </h2><br>  Nous nous sommes familiarisés avec deux stratégies de développement et de débogage de code programme exécutées sur le processeur central du complexe Redd (à l'aide des outils Microsoft Visual Studio et sur une machine virtuelle avec Linux OS).  Nous avons également acquis des compétences pratiques en travaillant avec le canal par lequel le processeur central du complexe communique avec le FPGA. <br><br>  Apparemment, maintenant rien ne nous empêche de transmettre des données significatives du CPU au FPGA et vice versa (bien que dans le dernier article j'ai écrit ces mots). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple contenant le «firmware» le plus simple pour les FPGA et un programme qui mesure la vitesse d'écriture sur USB peut être </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">téléchargé ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456008/">https://habr.com/ru/post/fr456008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455996/index.html">Transformation numérique de la publicité dans le réseau de vente au détail. Sur les traces de l'analytique vidéo dans le commerce de détail</a></li>
<li><a href="../fr456000/index.html">Création d'un jeu Tic-Tac-Toe avec TypeScript, React et Mocha</a></li>
<li><a href="../fr456002/index.html">Mémoire dédiée au foyer et intervention OOM Killer</a></li>
<li><a href="../fr456004/index.html">Nous vous invitons à une réunion de développement front-end dans des services très chargés</a></li>
<li><a href="../fr456006/index.html">Augmentez vos revenus grâce aux achats intégrés</a></li>
<li><a href="../fr456010/index.html">Comment Java 10 change la façon dont vous utilisez les classes internes anonymes</a></li>
<li><a href="../fr456016/index.html">Protocole de communication entre iframe et la fenêtre principale</a></li>
<li><a href="../fr456020/index.html">Se préparer à conquérir le monde</a></li>
<li><a href="../fr456024/index.html">PHP 2019: mieux que vous ne le pensez</a></li>
<li><a href="../fr456026/index.html">Face à face NeoQUEST-2019: abattez des drones et créez un VirusTotal de poche</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>