<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 👩🏻‍🎤 🧒🏽 Mencari bug di Amazon Web Services SDK untuk kode sumber .NET 👨‍🌾 ⚜️ 🙍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salam semua penggemar mengkritik kode orang lain. :) Hari ini, di laboratorium kami, bahan penelitian baru adalah kode sumber proyek AWS SDK untuk .NE...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencari bug di Amazon Web Services SDK untuk kode sumber .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437516/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="Gambar 1"></p><br>  Salam semua penggemar mengkritik kode orang lain.  :) Hari ini, di laboratorium kami, bahan penelitian baru adalah kode sumber proyek AWS SDK untuk .NET.  Pada suatu waktu, kami menulis artikel tentang memeriksa AWS SDK untuk C ++.  Kemudian tidak ada yang menarik.  Mari kita lihat bagaimana versi .NET dari AWS SDK akan menyenangkan kita.  Peluang yang baik untuk sekali lagi menunjukkan kemampuan penganalisa PVS-Studio, serta membuat dunia sedikit lebih sempurna. <br><a name="habracut"></a><br>  Amazon Web Services (AWS) .NET SDK adalah toolkit pengembang yang dirancang untuk membuat aplikasi berbasis .NET di infrastruktur AWS dan sangat menyederhanakan proses penulisan kode.  SDK termasuk suite .NET API untuk berbagai layanan AWS seperti Amazon S3, Amazon EC2, DynamoDB, dan lainnya.  Kode sumber untuk SDK di-host di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Seperti yang saya katakan, pada suatu waktu kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang memeriksa AWS SDK untuk C ++.  Artikel itu ternyata kecil - hanya ada beberapa kesalahan pada 512 ribu baris kode.  Kali ini kita berurusan dengan jumlah kode yang jauh lebih besar, termasuk sekitar 34 ribu file cs, dan jumlah total baris kode (tidak termasuk kosong) adalah 5 juta yang mengesankan.  Sebagian kecil dari kode (200 ribu baris dalam 664 file cs) jatuh pada tes, saya tidak menganggapnya. <br><br>  Jika kualitas kode .NET dari versi SDK kurang lebih sama dengan C ++ (dua kesalahan per 512 KLOC), maka kita akan mendapatkan kesalahan 10 kali lebih banyak.  Ini, tentu saja, adalah metode perhitungan yang sangat tidak akurat yang tidak mempertimbangkan fitur bahasa akun dan banyak faktor lainnya, tetapi saya tidak berpikir bahwa pembaca sekarang ingin mempelajari diskusi yang membosankan.  Sebagai gantinya, saya mengusulkan untuk langsung menuju hasil. <br><br>  Verifikasi dilakukan menggunakan PVS-Studio versi 6.27.  Luar biasanya, penganalisa mampu mendeteksi sekitar 40 kesalahan dalam AWS SDK untuk .NET code yang layak disebut.  Ini menunjukkan tidak hanya kualitas tinggi dari kode SDK (sekitar 4 kesalahan per 512 KLOC), tetapi juga kualitas yang sebanding dari karya C # dari analisa PVS-Studio dibandingkan dengan C ++.  Hasil yang bagus! <br><br>  Penulis AWS SDK untuk .NET sangat bagus.  Dari proyek ke proyek, mereka menunjukkan kualitas kode yang luar biasa.  Ini bisa menjadi contoh yang baik untuk tim lain.  Tapi, tentu saja, saya tidak akan menjadi pengembang penganalisa statis jika saya belum memasukkan 5 kopecks saya.  :) Kami sudah bekerja dengan tim Amazon Lumberyard untuk menggunakan PVS-Studio.  Tetapi karena ini adalah perusahaan yang sangat besar dengan banyak divisi di seluruh dunia, sangat mungkin bahwa AWS SDK untuk tim .NET tidak pernah mendengar tentang PVS-Studio sama sekali.  Bagaimanapun, dalam kode SDK saya tidak menemukan tanda-tanda menggunakan penganalisa kami, meskipun ini tidak berarti apa-apa.  Namun, tim, setidaknya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> alat analisa yang dibangun ke dalam Visual Studio.  Ini bagus, tetapi pemeriksaan kode dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditingkatkan</a> :). <br><br>  Akibatnya, saya masih berhasil menemukan beberapa kesalahan dalam kode SDK, dan akhirnya, saatnya untuk membaginya. <br><br>  <b>Kesalahan dalam logika</b> <br><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3008</a> [CWE-563] Variabel 'this.linker.s3.region' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 116, 114. AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  Penganalisa memperingatkan penugasan kembali nilai variabel yang sama.  Dari kode itu menjadi jelas bahwa ini disebabkan oleh kesalahan yang melanggar logika kerja: nilai variabel <i>this.linker.s3.region</i> akan selalu sama dengan <i>nilai</i> , terlepas dari kondisi <i>if (String.IsNullOrEmpty (value))</i> .  Di badan blok <i>if</i> , <i>return</i> dilewati.  Kode perlu diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>Rekursi tak terbatas</b> <br><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3110</a> [CWE-674] Kemungkinan rekursi tak terbatas di dalam properti 'OnFailure'.  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br>  Contoh kesalahan ketik klasik yang menyebabkan rekursi tak terbatas di <i>dapatkan</i> <i>accessor dari</i> properti <i>OnFailure</i> .  Alih-alih mengembalikan nilai bidang pribadi, <i>onFailure</i> merujuk ke properti <i>OnFailure</i> .  Opsi yang diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br>  Anda bertanya: "Bagaimana cara kerjanya?"  Sejauh ini, tidak mungkin.  Properti tidak digunakan di mana pun, tetapi bersifat sementara.  Pada satu titik, seseorang akan mulai menggunakannya dan pasti akan mendapatkan hasil yang tidak terduga.  Untuk mencegah kesalahan ketik seperti itu, disarankan untuk tidak menggunakan pengidentifikasi yang hanya berbeda dalam huruf pertama. <br><br>  Catatan lain untuk desain ini adalah penggunaan pengenal yang sepenuhnya cocok dengan nama tipe <i>OnFailure</i> .  Dari sudut pandang kompiler, ini cukup dapat diterima, tetapi itu membuat persepsi manusia tentang kode lebih sulit. <br><br>  Kesalahan serupa lainnya: <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3110</a> [CWE-674] Kemungkinan rekursi tak terbatas di dalam properti 'SSES3'.  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br>  Situasinya identik dengan yang dijelaskan di atas.  Hanya di sini, rekursi tak terbatas akan terjadi ketika mengakses properti <i>SSES3 untuk</i> membaca dan menulis.  Opsi yang diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>Tes kesadaran</b> <br><br>  Berikut ini adalah tugas dari seorang programmer yang tertarik menggunakan teknik Copy-Paste.  Lihat bagaimana kode terlihat di editor Visual Studio dan coba temukan kesalahannya. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="Gambar 3"></p><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3029</a> Ekspresi kondisional dari pernyataan 'jika' yang terletak bersebelahan adalah identik.  Periksa baris: 91, 95. AWSSDK.AppSync.Net45 BuatApiKeyResponseUnmarshaller.cs 91 <br><br>  Saya mengurangi tubuh metode <i>UnmarshallException</i> , menghapus semua yang tidak perlu.  Sekarang Anda dapat melihat bahwa pemeriksaan identik mengikuti satu demi satu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br>  Tampaknya kesalahan itu tidak kotor - hanya pemeriksaan tambahan.  Namun seringkali, pola seperti itu dapat mengindikasikan masalah yang lebih serius dalam kode ketika beberapa pemeriksaan yang diperlukan tidak dilakukan. <br><br>  Ada beberapa kesalahan serupa dalam kode. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 75, 79. AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 105, 109. AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 201, 205. AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 101, 105. AWSSDK.CognitoIdentityProvider.Net45 VerifikasiSoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 72, 76. Pembaruan AWSSDK.Glue.Net45ResponseUnmarshaller.cs 72 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 123, 127. AWSSDK.Neptune.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 167, 171. AWSSDK.Neptune.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 127, 131. AWSSDK.RDS.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 171, 175. AWSSDK.RDS.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 99, 103. AWSSDK.Rekognition.Net45 Kenali SelebrasiResponseUnmarshaller.cs 99 </li></ul><br>  <b>Apa kamu</b> <br><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3062</a> Objek 'attributeName' digunakan sebagai argumen untuk metode sendiri.  Pertimbangkan untuk memeriksa argumen aktual pertama dari metode 'Berisi'.  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br>  Penganalisis mendeteksi kesalahan dalam metode <i>GetAttribute</i> : string diperiksa untuk fakta bahwa itu berisi dirinya sendiri.  Dari uraian metode, berikut bahwa jika nama atribut (kunci <i>atributName</i> ) ditemukan (dalam kamus <i>_attributes</i> ), maka nilai atribut harus dikembalikan, jika tidak, <i>null</i> .  Pada kenyataannya, karena kondisi <i>attributeName.Contains (atributName)</i> selalu benar, upaya dilakukan untuk mengembalikan nilai dengan kunci yang mungkin tidak ditemukan dalam kamus.  Kemudian, alih-alih mengembalikan <i>nol,</i> <i>KeyNotFoundException</i> akan dibuang. <br><br>  Mari kita coba perbaiki kode ini.  Untuk lebih memahami bagaimana melakukan ini, lihat metode lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br>  Metode ini memeriksa apakah nama <i>atribut</i> (kunci <i>atributName</i> ) <i>ada</i> di kamus <i>_attributes</i> .  <i>Mari kita</i> kembali ke metode <i>GetAttribute</i> dan memperbaiki kesalahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Sekarang metode melakukan apa yang dinyatakan dalam deskripsi. <br><br>  Dan satu lagi komentar kecil untuk fragmen kode ini.  Saya perhatikan bahwa penulis menggunakan <i>kunci</i> ketika bekerja dengan kamus <i>_attributes</i> .  Jelas, ini diperlukan dengan akses multi-utas, tetapi konstruk <i>kunci</i> agak lambat dan rumit.  Alih-alih <i>Kamus</i> dalam hal ini, mungkin lebih nyaman untuk menggunakan versi kamus yang aman - <i>ConcurrentDictionary</i> .  Maka kebutuhan akan <i>kunci</i> hilang.  Meskipun, mungkin saya tidak tahu tentang fitur dari proyek ini. <br><br>  <b>Perilaku mencurigakan</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3063</a> [CWE-571] Bagian dari ekspresi kondisional selalu benar jika dievaluasi: string.IsNullOrEmpty (inferredIndexName).  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br>  Penganalisa memberi tanda pada <i>string.IsNullOrEmpty (inferredIndexName)</i> memeriksa.  Memang, string <i>inferredIndexName</i> ditugaskan <i>nol</i> , maka nilai variabel ini tidak berubah di mana pun, dan kemudian karena alasan tertentu diperiksa untuk <i>null</i> atau string kosong.  Itu terlihat mencurigakan.  Mari kita perhatikan potongan kode yang diberikan.  Saya sengaja tidak menguranginya untuk lebih memahami situasi.  Jadi, dalam <i>pernyataan if</i> pertama (dan juga yang berikutnya), variabel yang <i>ditentukanIndexName</i> diperiksa dengan cara tertentu.  Bergantung pada hasil pemeriksaan, variabel <i>inferredIndexName</i> menerima nilai baru.  Sekarang mari kita perhatikan <i>pernyataan if</i> ketiga.  Badan pernyataan ini (melempar pengecualian) akan dieksekusi jika <i>indexNames.Count&gt; 0</i> , karena bagian pertama dari kondisinya adalah <i>string.IsNullOrEmpty (inferredIndexName)</i> selalu benar.  Mungkin variabel yang <i>ditentukanIndexName</i> dan <i>inferredIndexName</i> hanya bingung.  Atau cek ketiga harus tanpa yang <i>lain</i> , mewakili pernyataan yang berdiri sendiri <i>jika</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br>  Dalam hal ini, sulit untuk memberikan jawaban yang pasti tentang opsi untuk memperbaiki kode ini.  Tetapi sangat penting bagi penulis untuk memeriksanya. <br><br>  <b>NullReferenceException</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095</a> [CWE-476] Objek 'conditionValues' digunakan sebelum diverifikasi dengan null.  Periksa baris: 228, 238. AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br>  Klasik genre.  Variabel <i>conditionValues</i> digunakan tanpa terlebih dahulu memeriksa <i>nol</i> .  Selain itu, lebih lanjut dalam kode verifikasi seperti itu dilakukan, tetapi sudah terlambat.  :) <br><br>  Kode dapat diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br>  Beberapa kesalahan serupa ditemukan dalam kode. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3095 [CWE-476] Objek 'ts.Listeners' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 140, 143. AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476] Objek 'obj' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 743, 745. AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476] Objek 'multipartUploadMultipartUploadpartsList' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 65, 67. AWSSDK.S3.Net45 LengkapMultipartUploadRequestMarshaller.cs 65 </li></ul><br>  Peringatan berikut sangat mirip artinya, tetapi situasinya adalah kebalikan dari yang dibahas di atas. <br><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125</a> [CWE-476] Objek 'state' digunakan setelah diverifikasi terhadap null.  Periksa baris: 139, 127. AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Salah satu fragmen kode berisi cek variabel <i>keadaan</i> untuk <i>null</i> .  Lebih jauh di sepanjang kode, variabel <i>keadaan</i> digunakan untuk berhenti berlangganan dari acara <i>PreemptExpiryTime</i> , sementara pemeriksaan untuk <i>null</i> tidak lagi dilakukan, dan <i>NullReferenceException dimungkinkan</i> .  Opsi kode yang lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br>  Ada kesalahan serupa lainnya dalam kode. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3125 [CWE-476] Objek 'wrapRequest.Content' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 395, 383. AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476] Objek 'datasetUpdates' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 477, 437. AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476] Objek 'cORSConfigurationCORSConfigurationcORSRulesListValue' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 125, 111. AWSSDK.S3.Net45 PutCORSKonfigurasi KonfigurasiRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476] Objek 'lifecycleConfigurationLifecycleConfigurationrulesListValue' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 157, 68. AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476] Objek 'this.Key' digunakan setelah diverifikasi terhadap null.  Periksa baris: 199, 183. AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>Realitas yang tidak terbantahkan</b> <br><br>  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'true'.  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode ini selalu mengembalikan <i>true</i> .  Mari kita lihat betapa pentingnya ini untuk kode panggilan.  Saya melacak penggunaan metode <i>State19</i> .  Dia berpartisipasi dalam mengisi array dari penangan <i>fsm_handler_table</i> bersama dengan metode serupa lainnya (masing-masing ada 28 dari mereka dengan nama, dari <i>State1</i> ke <i>State28</i> ).  Penting untuk dicatat di sini bahwa selain <i>State19</i> , peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] juga dikeluarkan untuk beberapa penangan lainnya.  Ini adalah penangannya: <i>State23, State26, State27, State28</i> .  Lansiran yang dikeluarkan oleh analis untuk mereka: <br><br><ul><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br>  Berikut ini deklarasi dan inisialisasi array handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br>  Untuk kelengkapan, mari kita lihat kode salah satu penangan, yang tidak ada keluhan penganalisa, misalnya, <i>State2</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Dan ini adalah bagaimana penangan dipanggil: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br>  Seperti yang Anda lihat, pengecualian akan dilemparkan jika <i>false</i> dikembalikan.  Dalam kasus kami, untuk penangan <i>State19, State23, State26, State27</i> dan <i>State28</i> ini tidak akan pernah terjadi.  Itu terlihat mencurigakan.  Di sisi lain, sebanyak lima penangan memiliki perilaku yang sama (selalu kembali <i>benar</i> ), jadi mungkin ini dimaksudkan dan bukan hasil kesalahan ketik. <br><br>  Mengapa saya memikirkan semua ini dengan sangat detail?  Situasi ini sangat indikatif dalam arti bahwa analisa statis sering hanya mampu menunjukkan desain yang mencurigakan.  Dan bahkan seseorang (bukan mesin) yang tidak memiliki pengetahuan yang cukup tentang proyek, setelah menghabiskan waktu mempelajari kode, masih tidak dapat memberikan jawaban yang lengkap tentang adanya kesalahan.  Kode harus dipelajari oleh pengembang. <br><br>  <b>Cek tidak berarti</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> [CWE-571] Ekspresi 'doLog' selalu benar.  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br>  Perhatikan variabel <i>doLog</i> .  Setelah inisialisasi dengan <i>false</i> , maka dalam kode variabel ini akan menjadi <i>benar</i> dalam semua kasus.  Jadi pemeriksaan <i>if (doLog)</i> selalu benar.  Mungkin, sebelumnya dalam metode ini ada cabang di mana variabel <i>doLog</i> tidak diberi nilai apa pun, maka pada saat verifikasi itu bisa berisi nilai <i>palsu yang</i> diperoleh selama inisialisasi.  Tetapi sekarang tidak ada cabang seperti itu. <br><br>  Kesalahan serupa lainnya: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringatan</a> <b>PVS-Studio:</b> Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> '! Hasil' selalu salah.  AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br>  Penganalisa mengklaim bahwa nilai variabel <i>hasil</i> selalu <i>benar</i> .  Ini hanya mungkin jika metode <i>PutValueHelper</i> akan selalu mengembalikan <i>true</i> .  Lihatlah metode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  Memang, metode ini akan mengembalikan <i>true</i> dalam kondisi apa pun.  Selain itu, penganalisa mengeluarkan peringatan untuk metode ini.  <b>PVS-Studio Warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'true'.  SQLiteLocalStorage.cs 1016 <br><br>  Saya sengaja tidak mengutip peringatan ini sebelumnya ketika saya mempertimbangkan kesalahan lain dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> , tetapi saya menyimpannya untuk kasus ini.  Dengan demikian, penganalisis itu benar untuk menunjukkan kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> dalam kode panggilan. <br><br>  <b>Salin-tempel.</b>  <b>Lagi</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3001</a> Ada sub-ekspresi yang identik 'this.token == JsonToken.String' di sebelah kiri dan di sebelah kanan '||'  operator.  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br>  Bandingkan dua <i>kali</i> bidang <i>this.token</i> dengan nilai <i>JsonToken.String</i> dari enumerasi <i>JsonToken</i> .  Mungkin salah satu perbandingan harus berisi nilai enumerasi yang berbeda.  Jika demikian, maka kesalahan serius telah dibuat. <br><br>  <b>Refactoring + kecerobohan?</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3025</a> [CWE-685] Format salah.  Jumlah item format yang berbeda diharapkan saat memanggil fungsi 'Format'.  Argumen tidak digunakan: AWSConfigs.AWSRegionKey.  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br>  Mungkin, string format untuk metode <i>string.Format</i> sebelumnya berisi specifier output <i>{0}</i> , yang argumennya <i>AWSConfigs.AWSRegionKey</i> ditetapkan.  Kemudian baris diubah, specifier hilang, tetapi mereka lupa menghapus argumen.  Fragmen kode di atas bekerja tanpa kesalahan (pengecualian akan dilemparkan dalam kasus sebaliknya - specifier tanpa argumen), tetapi terlihat jelek.  Kode harus diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>Tidak aman</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3083</a> [CWE-367] Doa yang tidak aman dari acara 'mOnSyncSuccess', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br>  Situasi yang cukup umum dari panggilan tidak aman ke pengendali acara.  Antara memeriksa variabel <i>mOnSyncSuccess</i> untuk <i>null</i> dan memanggil handler, suatu peristiwa dapat berhenti berlangganan, dan nilainya akan menjadi nol.  Kemungkinan skenario seperti itu kecil, tetapi masih lebih baik untuk membuat kode lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br>  Ada kesalahan serupa lainnya dalam kode. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'mOnSyncFailure', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'mExceptionEvent', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 366 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'OnRead', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>Kelas yang belum selesai</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringatan</a> <b>PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3126</a> Ketik 'JsonData' yang mengimplementasikan antarmuka &lt;qu&gt; IEquatable tidak menggantikan metode 'GetHashCode'.  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  Kelas <i>JsonData</i> berisi banyak kode, jadi saya tidak memberikannya secara keseluruhan, membatasi diri saya untuk hanya mendeklarasikannya.  Kelas ini benar-benar tidak mengandung metode <i>GetHashCode yang</i> ditimpa, yang tidak aman karena dapat menyebabkan perilaku yang salah ketika menggunakan tipe <i>JsonData</i> untuk bekerja, misalnya, dengan koleksi.  Mungkin tidak ada masalah saat ini, tetapi strategi untuk menggunakan tipe ini dapat berubah di masa depan.  Kesalahan ini dijelaskan lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  <b>Kesimpulan</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu semua kesalahan menarik yang berhasil saya deteksi di AWS SDK untuk .NET code menggunakan analisa statis PVS-Studio. </font><font style="vertical-align: inherit;">Sekali lagi, saya menekankan kualitas proyek. </font><font style="vertical-align: inherit;">Saya menemukan sejumlah kecil kesalahan untuk 5 juta baris kode. </font><font style="vertical-align: inherit;">Meskipun, mungkin, analisis yang lebih menyeluruh dari peringatan yang dikeluarkan akan memungkinkan saya untuk menambahkan beberapa kesalahan lagi ke daftar ini. </font><font style="vertical-align: inherit;">Tetapi juga sangat mungkin bahwa saya sia-sia mengaitkan beberapa peringatan yang dijelaskan sebagai kesalahan. </font><font style="vertical-align: inherit;">Dalam hal ini, kesimpulan pasti selalu dibuat hanya oleh pengembang, yang berada dalam konteks kode yang sedang diperiksa.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Khrenov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencari kesalahan dalam kode sumber SDK Layanan Web Amazon untuk .NET</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437516/">https://habr.com/ru/post/id437516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437504/index.html">Komponen kecil: apa yang bisa salah? Kami menggunakan prinsip tanggung jawab tunggal</a></li>
<li><a href="../id437508/index.html">CVE-2019-6111 dan kerentanan scp lainnya</a></li>
<li><a href="../id437510/index.html">Apa yang terjadi ketika Anda mengirim SMS</a></li>
<li><a href="../id437512/index.html">Apa fungsi murni dalam JavaScript?</a></li>
<li><a href="../id437514/index.html">Mencari kesalahan dalam kode sumber SDK Layanan Web Amazon untuk .NET</a></li>
<li><a href="../id437518/index.html">Serangan kumbang</a></li>
<li><a href="../id437520/index.html">“Cahaya saya adalah cermin! - katakan, tunjukkan dualis saya ... ": desain satu kerangka kerja yang bagus dan dapatkan yang kedua sebagai hadiah</a></li>
<li><a href="../id437522/index.html">Koloni. Bab 22: Keputusan Akhir</a></li>
<li><a href="../id437524/index.html">Buat Catur AI Sederhana: 5 Langkah Mudah</a></li>
<li><a href="../id437526/index.html">Rendering volumetrik di WebGL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>