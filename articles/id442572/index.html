<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∑ üìê üç¨ Menggunakan Alat Konfigurasi Datapath üõÄüèª üö∂üèæ üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita harus mengambil langkah kedua dari belakang dalam pengembangan praktis bekerja dengan UDB. Hari ini kita tidak akan mengembangkan menggunakan Edi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan Alat Konfigurasi Datapath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442572/"><img src="https://habrastorage.org/webt/fu/yo/23/fuyo230rbfhla_li8ryzzngttlw.jpeg"><br><br>  Kita harus mengambil langkah kedua dari belakang dalam pengembangan praktis bekerja dengan UDB.  Hari ini kita tidak akan mengembangkan menggunakan Editor UDB otomatis, tetapi dalam mode semi-manual menggunakan Datapath Config Tool.  Bantuan yang sangat baik dalam menguasai alat ini adalah AN82156 - PSoC 3, PSoC 4, dan PSoC 5LP - Merancang Komponen Pencipta PSoC dengan Datapaths UDB.  Sebenarnya, saya mempelajarinya sendiri. <br><a name="habracut"></a><br>  Mungkin, saat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan dokumentasi kami tentang UDB</a> , seseorang mencoba mereproduksi pengetahuan dari sana menjadi praktik dan memperhatikan bahwa tidak semua fungsi yang dijelaskan dalam publikasi tersedia di Editor UDB.  Ini disebabkan oleh fakta bahwa pengembang tidak mulai menempatkan beberapa mekanisme yang sangat rumit di Editor UDB.  Para penulis AN82156 berpendapat bahwa melalui Editor UDB Anda tidak dapat melakukan hal-hal berikut: <br><br><ul><li>  mengatur input dan output data paralel; </li><li>  mengatur manajemen FIFO yang dinamis; </li><li>  menerapkan kebalikan dari sinyal jam FIFO; </li><li>  mengimplementasikan fungsi CRC; </li><li>  mengimplementasikan fungsi PRS; </li><li>  menerapkan pilihan transfer masuk; </li><li>  menerapkan migrasi masuk dinamis. </li></ul><br>  Dari saya sendiri, saya akan menambahkan bahwa saya tidak menemukan cara menerapkan permutasi camilan di Editor UDB. <br><br>  Jika fungsi-fungsi ini diperlukan dalam proyek, Anda harus membuat kode Verilog Anda sendiri.  Saya secara khusus menggunakan kata "buat" daripada "tulis."  Mengetahui bahasa pemrograman ini sudah cukup di tingkat membaca.  Maksud saya, Anda perlu memahami desain apa yang dibutuhkan untuk apa.  Dan untuk dapat menulis dari awal selalu berguna, tetapi keterampilan ini tidak diperlukan untuk apa yang disajikan dalam artikel ini. <br><br>  Sebagai masalah yang dapat dipecahkan, saya memilih kasing semi sintetis.  Secara umum, saya memutuskan untuk menampilkan beberapa data ke port paralel, dan khususnya, dari apa yang ada, teks LCD memiliki port paralel.  Saya mengeluarkannya dari printer 3D MZ3D tiga tahun lalu ketika saya memindahkan yang terakhir ke STM32.  Oleh karena itu, kasing semi-sintetik: saat ini, indikator tersebut biasanya memiliki input I2C, dan mereka tidak perlu terhubung melalui tumpukan kabel di kehidupan nyata.  Namun, LCD modern juga memiliki port paralel, sehingga semua orang dapat menggunakannya untuk mengulangi percobaan. <br><br>  Pertimbangkan skema alih tampilan yang diambil dari reprap.org (ini tidak mudah, penyedia saya memblokir situs ini, serta sejumlah teknis lainnya, memotivasi dengan fakta bahwa ia hidup pada IP yang sama dengan seseorang diblokir). <br><br><img src="https://habrastorage.org/webt/0x/th/ry/0xthryzxadx_9guzmhdyhrxnzty.png"><br><br>  Tata letak yang bagus!  Pertama, saya tidak perlu berpikir tentang membaca: data dalam LCD hanya dapat ditulis (garis R / W di-ground dan tidak tersedia pada konektor).  Kedua, data datang dalam format 4-bit, yang berarti bahwa kita tidak hanya dapat bekerja pada output paralel, tetapi juga memeriksa operasi fungsi permutasi menggigit. <br><br><h2>  Pembuatan proyek </h2><br>  Jadi, luncurkan PSoC Creator dan pilih <b>File-&gt; New-&gt; Project</b> : <br><br><img src="https://habrastorage.org/webt/pv/ma/tv/pvmatvfviveyo4fa822osy45p2c.png"><br><br>  Selanjutnya, saya memilih papan tempat memotong roti saya: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Berikutnya adalah diagram kosong: <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Saya akan memanggil proyek <b>LCDTest2</b> : <br><br><img src="https://habrastorage.org/webt/qs/3f/rl/qs3frlgxrnzqzqrzzfryptvjfqq.png"><br><br>  Sekarang, seperti sebelumnya, buka tab <b>Komponen</b> : <br><br><img src="https://habrastorage.org/webt/wq/nb/bo/wqnbboubijieyovk7akrat6piik.png"><br><br>  Dan, setelah memilih proyek, tekan tombol mouse kanan, lalu pilih <b>Tambahkan Komponen</b> . <br><br><img src="https://habrastorage.org/webt/hi/fu/hv/hifuhvearnltnfz2dvmhwtzgw4o.png"><br><br>  Dan di sini Anda harus memilih <b>Wisaya Simbol</b> .  Beri nama ... Baiklah, katakanlah <b>LCD4bit</b> . <br><br><img src="https://habrastorage.org/webt/59/f0/g3/59f0g3lya8ado4kcxgj6lcsxggk.png"><br><br>  Saya menetapkan port berikut ke simbol: <br><br><img src="https://habrastorage.org/webt/6a/jr/uo/6ajruo1io2jusjunhameiumtb20.png"><br><br>  <b>CLK</b> adalah input jam.  Port dengan awalan LCD adalah port LCD standar.  <b>lapar</b> - output memberitahu unit DMA bahwa ada ruang kosong di FIFO, ide itu dibahas dalam artikel tentang cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengendalikan LED RGB</a> .  Klik OK untuk mendapatkan karakter. <br><br><img src="https://habrastorage.org/webt/ze/fq/5z/zefq5z65eq0i4mq21y2d3jip7t4.png"><br><br>  Sekarang, berdasarkan simbol ini, templat Verilog harus dibuat.  Klik tombol kanan mouse di sekitar simbol dan pilih <b>Generate Verilog</b> di menu konteks. <br><br><img src="https://habrastorage.org/webt/h9/k7/oo/h9k7oogp_wqsdfugdg-8bdr_hru.png"><br><br>  Kami mendapat templat yang ditunjukkan pada gambar di bawah ini (dalam bentuk teks belum masuk akal): <br><br><img src="https://habrastorage.org/webt/ax/t9/k-/axt9k-s-zfi2kfd7qdz9pe-zlqq.png"><br><br>  Kami telah membuat modul dan beberapa bagian.  Tetapi mereka belum menciptakan Datapath.  Untuk menambahkannya, pergi ke pohon proyek, pilih file <b>LCD4bit.v</b> , tekan tombol kanan mouse dan pilih <b>Datapath Config Tool</b> di menu konteks yang muncul: <br><br><img src="https://habrastorage.org/webt/z2/1g/5w/z21g5wom4_-yq_nmcjlhvb3irg0.png"><br><br>  Sebuah jendela terbuka di hadapan kami, yang untuk saat ini saya hanya akan menampilkan sebagian: <br><br><img src="https://habrastorage.org/webt/m0/fz/9i/m0fz9idl6xt5rimcittxpme2iea.png"><br><br>  Tolong cintai dan nikmatilah, editor Datapath.  Ini berisi semua bit yang dijelaskan dalam terjemahan dokumentasi hak milik.  Tetapi ada begitu banyak bagian ini sehingga pada hari-hari awal saya memandangnya, tetapi takut untuk melakukan apa pun.  Lihat, lihat dan pergi.  Dan hanya setelah beberapa waktu, setelah terbiasa, ia mulai mencoba melakukan sesuatu.  Sebenarnya, itu sebabnya saya hanya membawa sebagian jendela.  Mengapa menakuti semua orang sebelumnya?  Sementara itu, kita hanya perlu membuat Datapath, jadi kita pilih item menu <b>Edit-&gt; Datapath Baru</b> : <br><br><img src="https://habrastorage.org/webt/-n/dx/vj/-ndxvjk_wrpdjucuq0_c3jcqfai.png"><br><br>  Opsi mana yang harus dipilih dalam dialog yang muncul? <br><br><img src="https://habrastorage.org/webt/wf/ma/kf/wfmakfepho5l4h4nxffpua7wgok.png"><br><br>  Pertanyaannya sedikit lebih serius daripada kelihatannya.  Izinkan saya menyoroti paragraf berikutnya sehingga tidak ada yang tertangkap (saya menangkap diri saya sendiri, dan kemudian saya melihat pertanyaan di jaringan dari yang saya dapatkan, dan tidak ada yang benar-benar menjawabnya, dan jawabannya ada di <b>AN82156</b> , Anda hanya perlu membacanya secara diagonal, seperti yang tertulis di sana. frasa singkat yang tidak mencolok). <br><blockquote>  Jika Anda berencana untuk bekerja dengan data paralel, Anda harus memilih opsi CY_PSOC3_DP.  Tidak ada opsi lain yang akan berisi port untuk menghubungkan data paralel. </blockquote>  Jadi  Biarkan instance disebut LCD_DP: <br><br><img src="https://habrastorage.org/webt/tf/a3/hs/tfa3hsi-mu2ljvyeukwmprwlm_4.png"><br><br>  Klik OK dan tutup <b>Alat Konfigurasi Datapath untuk saat ini</b> , setuju untuk menyimpan hasilnya.  Kami akan kembali ke sini nanti. <br><br>  Kode Verilog kami telah diperluas.  Sekarang memiliki Datapath.  Permulaannya benar-benar tidak dapat dibaca.  Itu tidak menakutkan, itu dikonfigurasikan oleh <b>Datapath Config Tool</b> . <br><br><img src="https://habrastorage.org/webt/tz/d9/ur/tzd9urfa66hsfic2w9gsn6tkysu.png"><br><br>  Dan kita akan menentukan akhir dari deskripsi Datapath.  Situs kami terlihat seperti ini <div class="spoiler">  <b class="spoiler_title">(dari titik ini masuk akal untuk membawa semuanya dalam bentuk teks).</b> <div class="spoiler_text"><pre><code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(), /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre> <br></div></div><br>  Menakutkan  Sekarang kita akan mencari tahu apa itu - itu akan berhenti menakutkan.  Sebenarnya, ada tiga kelompok berbeda dalam teks ini.  Mari kita ingat terjemahan dokumentasinya.  Seperti apa datapath dalam gambar?  Saya akan segera mencatat pada gambar tempat kelompok "1", "2" dan "3" berada. <br><br><img src="https://habrastorage.org/webt/ji/xe/5x/jixe5x_fxqpx6kgybrjmakagpw4.png"><br><br>  Sebenarnya, kelompok port pertama dalam kode Verilog adalah input.  Bandingkan nama-nama pada output multiplexer input ("1" pada gambar) dan nama-nama sinyal dalam kode. <br><br>  Sekarang semua input nol.  Kami harus menghubungkan input jam dan kami dapat meneruskan hingga enam jalur input, seperti yang dilakukan di Editor UDB.  Input-input ini adalah: <br><br><pre> <code class="plaintext hljs"> /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0),</code> </pre><br>  Kelompok kedua adalah pintu keluar.  Nama-nama dalam kode juga bertepatan dengan nama-nama input dari multiplexer output "2": <br><br><pre> <code class="plaintext hljs"> /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(),</code> </pre><br>  Hanya spesies Datapath yang diberikan memiliki kelompok ketiga (yang lain tidak memiliki, oleh karena itu, tidak ada data paralel).  Ini adalah sinyal internal Datapath yang melaluinya Anda dapat secara independen menyatukan atau melakukan tindakan bermanfaat lainnya.  Nama-nama dalam kode juga bertepatan dengan nama-nama sinyal internal yang tersebar dalam gambar.  Kami melalui salah satu dari mereka (yang terakhir dalam daftar, namanya <b>po</b> ) akan menampilkan data paralel langsung ke kaki chip. <br><br><pre> <code class="plaintext hljs"> /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre><br>  Jadi  Saat kita bekerja, kita harus menghubungkan beberapa input dan output ini ke entitas kita sendiri, dan sisanya - biarkan saja dalam bentuk di mana kita membuatnya. <br><br><h2>  Menggunakan Editor UDB sebagai referensi </h2><br>  Dan sekarang kita memiliki blank, kita tahu di mana dan apa yang harus kita tulis.  Masih memahami apa yang akan kita masukkan di sana.  Kebetulan saya menggunakan bahasa Verilog tidak setiap hari, jadi secara umum saya mengingat semuanya, dan menulis dari awal bagi saya selalu merupakan situasi yang penuh tekanan.  Ketika proyek sudah berjalan, itu semua diingat, tetapi jika setelah beberapa bulan tidak aktif saya memulai sesuatu dari awal, tentu saja, saya tidak lagi ingat rincian sintaks dari bahasa khusus ini.  Oleh karena itu, saya sarankan meminta lingkungan pengembangan untuk membantu kami. <br><br>  Editor UDB untuk swa-monitor membangun kode Verilog.  Kami mengambil keuntungan dari fakta bahwa komponen yang tidak terlibat dalam sirkuit utama tidak dikompilasi, sehingga kami dapat membuat komponen tambahan di Editor UDB, dan itu tidak akan masuk ke dalam kode output.  Kami akan menggambar otomat di sana, kami akan melakukan penyesuaian kasar input dan output Datapath, dan kemudian cukup mentransfer teks yang dihasilkan secara otomatis ke modul Verilog kami dan memodifikasi semuanya secara kreatif.  Ini jauh lebih sederhana daripada mengingat detail sintaksis Verilog dan menulis semuanya dari awal (walaupun siapa pun yang menggunakan Verilog terus-menerus, tentu saja, akan lebih mudah untuk menulis dari awal: penyelesaian kreatif, seperti yang akan kita lihat segera, sederhana, tetapi membutuhkan waktu). <br><br>  Jadi, kami mulai membuat komponen tambahan.  Dengan gerakan tangan yang biasa kami tambahkan elemen baru ke proyek: <br><br><img src="https://habrastorage.org/webt/to/d2/fg/tod2fgx1opcdho2edizges-vr3q.png"><br><br>  Ini akan menjadi dokumen UDB, sebut saja <b>UDBhelper</b> : <br><br><img src="https://habrastorage.org/webt/j3/wt/iu/j3wtiuj2htdr-ct4f7m_3z497oi.png"><br><br>  Sudah waktunya untuk memikirkan mesin, yang akan kita tempatkan pada lembar yang dibuat.  Untuk melakukan ini, kita perlu mempertimbangkan diagram waktu apa yang harus kita bentuk dengannya: <br><br><img src="https://habrastorage.org/webt/rh/zj/da/rhzjdasl8ioia8n8okjuuaieft4.png"><br><br><img src="https://habrastorage.org/webt/dy/3a/0z/dy3a0zmkacoa4tvgaugebovdhqy.png"><br><br>  Jadi  Pertama, Anda perlu mengatur sinyal RS (karena R / W disolder ke nol pada perangkat keras).  Selanjutnya, tunggu tAS, lalu naikkan sinyal E dan atur data (pengaturan data berkenaan dengan tepi positif E tidak terbatas).  Data harus berada di bus tidak kurang dari tDSW, setelah itu sinyal E harus dijatuhkan. Data harus tetap di bus setidaknya untuk tDHW, dan RS untuk setidaknya tAH. <br><br>  RS adalah perintah atau flag data.  Jika RS nol, maka perintah ditulis, jika itu satu, data ditulis. <br><br>  Saya sarankan mengirim perintah melalui <b>FIFO0</b> , dan data melalui <b>FIFO1</b> .  Dalam kerangka tugas saat ini, ini tidak bertentangan dengan apa pun.  Maka mesin keadaan terbatas yang saya usulkan akan memiliki bentuk berikut: <br><br><img src="https://habrastorage.org/webt/jn/6y/6j/jn6y6jnzllwbwgmslak7nif1xmu.png"><br><br>  Dalam kondisi <b>Idle</b> , mesin masih tidak memiliki data FIFO.  Jika data muncul di <b>FIFO0</b> , ia pergi ke <b>LoadF0</b> , di mana di masa depan ia akan menerima data dari <b>FIFO0</b> ke A0. <br><br>  Ketika perintah sedang dikirim, data tidak boleh dikirim.  Oleh karena itu, kondisi untuk menerima data akan lebih rendah dalam prioritas daripada kondisi untuk menerima perintah. <br><br><img src="https://habrastorage.org/webt/og/gn/fl/oggnfl3tcjcxa8pzu64qcj3yzpa.png"><br><br>  Data diterima dalam A1 di negara <b>LoadF1</b> (dari <b>FIFO1</b> mereka hanya bisa pergi untuk mendaftar A1 dan tidak bisa mendaftar A0), dan kemudian mereka disalin dari A1 ke A0 di negara <b>A1toA0</b> . <br><br>  Apa pun cara kita menuju titik konvergensi panah, kita memiliki data dalam A0.  Mereka sudah output ke port paralel.  Kami memiringkan E (dalam keadaan <b>E_UP1</b> ), menjatuhkan E (dalam keadaan <b>E_DOWN1</b> ).  Selanjutnya, kita akan memiliki status untuk swapping nibbles ( <b>SWAP</b> ), setelah itu E naik lagi ( <b>E_UP2</b> ).  Tentang ini, saya telah kehabisan delapan negara yang dapat dikodekan dalam tiga bit.  Dan kita ingat bahwa konfigurasi dinamis Datapath RAM hanya memiliki tiga input alamat.  Beberapa trik bisa diterapkan, tetapi artikelnya sudah besar.  Oleh karena itu, hanya kedua kalinya kami akan menjatuhkan E dalam kondisi <b>Idle</b> .  Maka delapan negara bagian sudah cukup bagi kita. <br><br>  Kami juga menempatkan Datapath pada lembar dan menetapkan input dan output dengan cara yang akrab di artikel sebelumnya.  Berikut inputnya: <br><br><img src="https://habrastorage.org/webt/ct/fn/0j/ctfn0jvexwfycfrdovbnatwv7ze.png"><br><br>  Berikut ini hasilnya: <br><br><img src="https://habrastorage.org/webt/ct/mj/gd/ctmjgdzfvx-mz8qnzwbp6undlau.png"><br><br>  Tidak ada yang baru, semuanya sudah dijelaskan dalam artikel siklus sebelumnya.  Jadi, kita punya tempat kosong, atas dasar itu kita bisa melakukan sesuatu sendiri.  Benar, untuk memastikan semuanya berjalan, kita perlu membawa sistem kita ke tingkat atas proyek, jika tidak, tidak ada kesalahan akan ditemukan.  Dan dalam percobaan awal tanpa kesalahan tidak akan berhasil.  Karena itu, kami akan membuat satu tindakan tambahan lagi. <br><br>  Deskripsi tentang bagaimana sirkuit dibuat melampaui deskripsi bekerja dengan UDB.  Saya hanya akan menunjukkan kepada Anda sirkuit mana yang saya dapatkan.  Hanya ada satu unit DMA: saat mengirim perintah ke LCD, perlu untuk menahan jeda besar, sehingga masih lebih mudah untuk melakukan ini secara terprogram.  Untuk aplikasi lain, Anda cukup meletakkan blok DMA kedua dengan analogi menggunakan sinyal <b>lapar0</b> . <br><br><img src="https://habrastorage.org/webt/mz/zd/g8/mzzdg80tinx_ffjjigxypmehj0w.png"><br><br>  Untuk secara akurat memenuhi kerangka waktu, saya memilih frekuensi clock yang sama dengan satu megahertz.  Akan mungkin untuk mengambil frekuensi dan lebih tinggi, tetapi data ditransmisikan melalui kabel panjang dalam kondisi gangguan tinggi, sehingga lebih baik meluangkan waktu untuk mengatur data sebelum dan sesudah gerbang dengan margin.  Jika seseorang akan mengulangi percobaan saya di papan tempat memotong roti yang sama - jangan gunakan port P3.2: kapasitor disolder ke kaki ini di papan.  Saya membunuh selama setengah jam, sampai saya menemukan mengapa saya tidak membentuk impuls E, yang pertama kali saya hubungkan di sana.  Saya melemparkannya ke P3.1 - semuanya langsung bekerja.  Bus data saya pergi ke P3.7-P3.4, RS pergi ke P3.3, jadi E awalnya pergi ke P3.2 ... <br><br>  Baik di sini.  Sekarang, jika Anda mencoba mengkompilasi proyek, kami mendapatkan kesalahan yang dapat diprediksi sepenuhnya <br><br><img src="https://habrastorage.org/webt/az/tm/fb/aztmfbvzsl52ghanjovqpva5_7o.png"><br><br>  Jadi sistem mencoba mengumpulkan sesuatu.  Tapi dia masih belum mengumpulkan apa pun.  Kami melanjutkan untuk menyalin kode.  Untuk melakukan ini, di Editor UDB, beralih ke tab Verilog (tab ini terletak di bawah jendela dengan lembar Editor UDB): <br><br><img src="https://habrastorage.org/webt/kg/tk/fy/kgtkfyn1tssdt4-cjydawzl7vnw.png"><br><br>  Apa yang akrab di sana?  Di bagian paling akhir teks adalah badan otomat.  Mari kita mulai migrasi dari sana. <br><br><div class="spoiler">  <b class="spoiler_title">Juga tempatkan di bawah Datapath:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== State Machine: SM ==================== */ always @ (posedge clock) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end E_Up1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Down1 ; end end E_Down1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= SWAP ; end end SWAP : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_UP2 ; end end E_UP2 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= Idle ; end end LoadF1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= A1toA0 ; end end A1toA0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Ada deklarasi di bagian atas untuk kode ini (nama untuk negara, rantai untuk Datapath, register yang mengkode keadaan otomat).  Kami mentransfernya ke yang sesuai <div class="spoiler">  <b class="spoiler_title">bagian dari kode kami:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire hungry0; wire F0empty; wire hungry1; wire F1empty; wire Datapath_1_d0_load; wire Datapath_1_d1_load; wire Datapath_1_f0_load; wire Datapath_1_f1_load; wire Datapath_1_route_si; wire Datapath_1_route_ci; wire [2:0] Datapath_1_select; reg [2:0] SM;</code> </pre><br></div></div><br>  Baik, dan <br><br><div class="spoiler">  <b class="spoiler_title">situs pengikatan sinyal dapat ditransfer:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Assignment of Combinatorial Variables ==================== */ assign Datapath_1_d0_load = (1'b0); assign Datapath_1_d1_load = (1'b0); assign Datapath_1_f0_load = (1'b0); assign Datapath_1_f1_load = (1'b0); assign Datapath_1_route_si = (1'b0); assign Datapath_1_route_ci = (1'b0); assign Datapath_1_select[0] = (SM[0]); assign Datapath_1_select[1] = (SM[1]); assign Datapath_1_select[2] = (SM[2]);</code> </pre><br></div></div><br>  Sudah waktunya untuk menyambungkan Datapath.  Kode yang diangkut dari Editor UDB baik untuk pengeditan mesin, tetapi tidak terlalu baik untuk pengeditan manual.  Di sana, rantai dibuat yang terhubung ke input Datapath di satu ujung dan ke konstanta di sisi lain.  Tetapi dalam kode yang dibuat oleh <b>Alat Konfigurasi Datapath</b> (yang melakukan segalanya untuk pekerjaan manual), semua input sudah langsung terhubung ke konstanta nol.  Jadi saya akan menghubungkan hanya garis-garis yang bukan konstanta, tetapi saya akan memotong semua yang terkait dengan penerusan konstanta dari teks yang ditransfer.  Koneksi berubah menjadi seperti ini (warnanya menyoroti tempat-tempat yang saya sunting sehubungan dengan yang secara otomatis dibuat di Alat Konfigurasi Datapath): <br><br><img src="https://habrastorage.org/webt/-3/gk/fd/-3gkfd3bhnnc7wygbr6wpqoscyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(clk), /* input [02:00] */ .cs_addr(SM), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(hungry0), /* output */ .f0_blk_stat(F0empty), /* output */ .f1_bus_stat(hungry1), /* output */ .f1_blk_stat(F1empty),</code> </pre><br></div></div><br>  Data paralel sedikit lebih rumit.  Datapath memiliki port delapan-bit, dan hanya empat di antaranya yang perlu dibawa keluar.  Oleh karena itu, kami memulai sirkuit bantu dan menghubungkan hanya setengahnya ke output: <br><br><pre> <code class="plaintext hljs">wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Dan hubungkan seperti ini: <br><br><img src="https://habrastorage.org/webt/km/aq/_a/kmaq_abi2kkprp406kne413j5u0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po( tempBus) // Parallel data port );</code> </pre><br></div></div><br>  Kami mencoba merakit (Shift + F6 atau melalui item menu <b>Build-&gt; Generate Application</b> ).  Kami mendapatkan kesalahan: <br><br><img src="https://habrastorage.org/webt/kw/ox/as/kwoxasreij4-snkxyvc63iqozxq.png"><br><br>  Kami memiliki port <b>lapar0</b> dan <b>lapar1</b> (muncul saat membuat komponen), serta rantai dengan nama yang sama (muncul saat menyeret dari sampel).  Hapus saja rantai ini (meninggalkan port).  Dan di suatu tempat sinyal <b>jam</b> bocor, dan kami memiliki sirkuit ini disebut <b>CLK</b> . <br><br>  Setelah menghapus semua sirkuit yang tidak perlu (yang awalnya melemparkan nol konstanta ke input Datapath, serta <b>lapar0</b> dan <b>lapar1</b> ), kami mendapatkan kode berikut untuk awal file kami: <br><br><pre> <code class="plaintext hljs">// Your code goes here /* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire F0empty; wire F1empty; reg [2:0] SM; /* ==================== Assignment of Combinatorial Variables ==================== */ wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Dan ketika mengganti <b>jam</b> dengan <b>clk</b> di tubuh mesin, pada saat yang sama saya akan membuang semua baris yang bagus untuk pembuatan otomatis, tetapi dengan pengeditan manual hanya membuat kebingungan (semua perbandingan yang memberikan hasil tanpa syarat <b>BENAR</b> dan sebagainya).  Secara khusus, dalam contoh di bawah ini, Anda dapat mencoret sekitar setengah dari garis (dan beberapa <b>mulai / akhir</b> adalah opsional, kadang-kadang akan diperlukan, karena kami akan menambahkan tindakan, saya menyoroti mereka): <br><br><img src="https://habrastorage.org/webt/9s/e9/t1/9se9t15zkc1hux1qrpga3jbh7cm.png"><br><br>  Setelah menyisir sesuai dengan prinsip di atas (dan mengganti <b>jam</b> dengan <b>clk</b> ), tubuh seperti itu tetap ada <br><br><div class="spoiler">  <b class="spoiler_title">(menjadi lebih pendek, yang berarti lebih mudah dibaca):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; end E_Down1 : begin SM &lt;= SWAP ; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Sekarang, selama kompilasi, kita diberitahu bahwa <b>sirkuit</b> <b>LCD_E</b> dan <b>LCD_RS</b> tidak terhubung. <br><br>  Sebenarnya ini benar: <br><br><img src="https://habrastorage.org/webt/cz/da/h7/czdah7nfkzmou2mr8-omzs_-hby.png"><br><br>  Waktunya telah tiba untuk menambahkan tindakan ke mesin negara.  Kami akan mengganti deklarasi port yang terkait dengan rantai tidak terhubung dengan <b>reg</b> , karena kami akan menuliskannya di badan mesin (ini adalah sintaks dari bahasa Verilog, jika kami menulis, data harus klik, untuk ini kami memerlukan pemicu, dan diberikan oleh <b>reg</b> kata kunci): <br><br><img src="https://habrastorage.org/webt/l5/vq/uj/l5vqujn7yirpf4dkorxzevy9ij4.png"><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module LCD4bit ( output hungry0, output hungry1, output [3:0] LCD_D, output reg LCD_E, output reg LCD_RS, input clk );</code> </pre><br></div></div><br>  Dan isi mesin dengan tindakan.  Saya sudah mengatakan logika di atas ketika saya sedang mempertimbangkan grafik transisi automaton, jadi saya hanya akan menunjukkan hasilnya: <br><br><img src="https://habrastorage.org/webt/ij/t1/5i/ijt15itzdfznooyvlgz0sjlk5t4.png"><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; LCD_E &lt;= 1'b1; end E_Down1 : begin SM &lt;= SWAP ; LCD_E &lt;= 1'b0; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; LCD_E &lt;= 1; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Mulai saat ini, proyek mulai berkumpul.  Tapi dia belum akan bekerja.  Sejauh ini saya terkenal mengatakan: "Dalam keadaan ini, kami akan memuat register dari FIFO", "Dalam hal ini, A1 akan disalin ke A0", "Nibbles akan diatur ulang dalam hal ini".  Secara umum, saya banyak berbicara, tetapi sejauh ini belum ada tindakan.  Waktunya telah tiba untuk memenuhi mereka.  Kami melihat bagaimana negara dikodekan: <br><br><pre> <code class="plaintext hljs">localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111;</code> </pre><br>  <b>Buka kembali Alat Konfigurasi Datapath</b> : <br><br><img src="https://habrastorage.org/webt/eh/oh/sz/ehohszogw7vzyiup9cjumf4b3ii.png"><br><br>  Dan mulai <b>mengedit</b> garis <b>CFGRAM</b> .  Saat mengedit, Anda harus mengingat skema Datapath, yaitu: <br><br><img src="https://habrastorage.org/webt/cz/xr/vu/czxrvuaul7vkqilrqinrgzpu1fy.png"><br><br>  Bingkai merah pada gambar di bawah ini (dan panah pada gambar di atas) Saya menyoroti area yang diperbaiki (dan jalur data) untuk keadaan <b>LoadF0</b> (kode 001, yaitu, <b>Reg1</b> ).  Saya juga memasukkan komentar secara manual.  Isi F0 harus masuk ke A0. <br><br><img src="https://habrastorage.org/webt/4z/zv/kh/4zzvkhchg55gnp-39oag_d-bkt8.png"><br><br>  Dengan bingkai dan panah hijau, saya menandai pengaturan dan jalur untuk status LoadF1 (kode 010 - <b>Reg2</b> ). <br><br>  Dengan bingkai dan panah biru, saya menandai pengaturan dan jalur untuk status A1toA0 (kode 011 - <b>Reg3</b> ). <br><br>  Bingkai dan panah ungu saya menandai pengaturan dan jalur untuk keadaan SWAP (kode 110 - <b>Reg6</b> ). <br><br>  Akhirnya, panah oranye menunjukkan jalur data paralel.  Dan tidak ada tindakan yang diambil untuk mereka.  Mereka selalu keluar dari <b>SRCA</b> .  Kami hampir selalu memiliki A0 dipilih sebagai <b>SRCA</b> : data keluar dari A0.  Jadi, untuk mengarahkan ulang data input, kami harus melakukan banyak tindakan tambahan, tetapi kami tidak menerima data apa pun, jadi di sini kami tidak memerlukan tindakan ini, dan semua orang akan menemukan daftar mereka di <b>AN82156</b> .  Kami juga tidak perlu mengedit pengaturan Datapath statis, jadi tutup <b>Alat Konfigurasi Datapath</b> . <br><br>  Itu saja.  Perangkat keras yang dikonsep selesai.  Mulai mengembangkan kode C.  Untuk melakukan ini, buka tab <b>Sumber</b> dan edit file <b>main.c.</b> <br><br><img src="https://habrastorage.org/webt/fp/ia/7s/fpia7s4zyzaxy8mzmqxktib-obw.png"><br><br>  Inisialisasi LCD reguler dan output karakter "ABC" terlihat seperti ini (saya ingatkan Anda bahwa perintahnya masuk ke <b>FIFO0</b> , dokumentasi perlu memasukkan jeda antar tim, dan data masuk ke <b>FIFO1</b> , saya tidak menemukan apa pun tentang jeda di antara data): <br><br><pre> <code class="plaintext hljs"> volatile uint8_t* pFIFO0 = (uint8_t*) LCD4bit_1_LCD_DP__F0_REG; volatile uint8_t* pFIFO1 = (uint8_t*) LCD4bit_1_LCD_DP__F1_REG; pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x33; CyDelay (100); pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x20; CyDelay (5); pFIFO0[0] = 0x0C; //   CyDelay (50); pFIFO0[0] = 0x01; //   CyDelay (50); pFIFO1[0] = 'A'; pFIFO1[0] = 'B'; pFIFO1[0] = 'C';</code> </pre><br>  Apa itu  Mengapa hanya ada karakter pertama di layar? <br><br><img src="https://habrastorage.org/webt/3g/tq/sr/3gtqsrr050bqbhaqi2ke9g1pg0w.png"><br><br>  Dan jika Anda menambahkan penundaan antara output data - semuanya baik-baik saja: <br><br><img src="https://habrastorage.org/webt/3b/he/2a/3bhe2a1_ioou2gktkqfzydumrne.png"><br><br>  Osiloskop tidak memiliki saluran yang cukup untuk pekerjaan seperti itu.  Kami memeriksa pekerjaan pada penganalisis logis.  Proses perekaman data adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/yr/y_/_j/yry__jhgasihbzmmrrr2cnsylaq.png"><br><br>  Semua data ada di tempat (tiga pasang paket).  Waktu untuk pemasangan dan pengambilan data dialokasikan dalam volume yang cukup.  Secara umum, dari sudut pandang diagram waktu - semuanya dilakukan dengan benar.  Masalah ilmiah terpecahkan, diagram waktu yang diinginkan terbentuk.  Ini rekayasa - tidak.  Alasannya adalah lambatnya prosesor yang dipasang di LCD.  Di antara byte, tambahkan penundaan. <br><br>  Kami akan membentuk penundaan menggunakan penghitung tujuh-bit, pada saat yang sama kami akan melatih untuk menambahkannya ke sistem seperti itu.  Mari kita berada dalam keadaan Idle tidak kurang dari waktu tertentu, dan penghitung tujuh-bit akan mengukur waktu ini untuk kita.  Dan lagi, kita tidak akan menulis, tetapi membuat kode.  Oleh karena itu, sekali lagi kita pergi ke komponen tambahan Editor UDB dan menambahkan penghitung ke lembar kerja, mengatur parameternya sebagai berikut: <br><br><img src="https://habrastorage.org/webt/gq/8c/qw/gq8cqwl0liu7mv9gpgm8-wngom0.png"><br><br>  Penghitung ini akan selalu berfungsi ( <b>Enable diatur</b> ke 1).  Tapi itu akan memuat ketika mesin berada dalam keadaan <b>E_UP2</b> (setelah itu kita segera jatuh ke keadaan <b>menganggur</b> ).  Baris <b>Count7_1_tc akan</b> dinaikkan menjadi 1 saat penghitung dihitung menjadi nol, yang akan kami buat kondisi tambahan untuk keluar dari kondisi <b>Idle</b> .  Angka tersebut juga mengandung nilai periode, tetapi kami tidak akan menemukannya dalam kode Verilog.  Itu harus dimasukkan ke dalam kode C.  Tetapi pertama-tama, kami mentransfer kode Verilog yang dibuat secara otomatis dengan beralih ke tab Verilog.  Pertama-tama, penghitung harus terhubung (kita melihat kode ini di awal file dan memindahkannya ke awal juga): <br><br><pre> <code class="plaintext hljs">`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0" `include "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0\Count7_v1_0.v"</code> </pre><br>  Bagaimana penyempurnaan garis dan konstanta yang kreatif dilakukan telah dijelaskan, jadi saya hanya akan menunjukkan hasilnya.  Inilah rantai dan tugas yang ditambahkan sebagai hasilnya (sisanya mengatur konstanta, jadi saya membuangnya): <br><br><pre> <code class="plaintext hljs">wire Count7_1_load; wire Count7_1_tc; assign Count7_1_load = (SM==E_UP2);</code> </pre><br>  Dan di sini adalah penghitung itu sendiri, ditempatkan di akhir file.  Semua konstanta ditugaskan ke port secara langsung dalam deklarasi ini: <br><br><pre> <code class="plaintext hljs"> Count7_v1_0 Count7_1 ( .en(1'b1), .load(Count7_1_load), .clock(clk), .reset(1'b0), .cnt(), .tc(Count7_1_tc)); defparam Count7_1.EnableSignal = 1; defparam Count7_1.LoadSignal = 1;</code> </pre><br>  Agar penghitung ini berfungsi, kami secara otomatis menambahkan kondisi tambahan untuk keluar dari status <b>Idle</b> : <br><br><img src="https://habrastorage.org/webt/pc/it/pd/pcitpdmqenlvq8pblarf3uh5h84.png"><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty &amp;Count7_1_tc ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end</code> </pre><br></div></div><br>  API untuk penghitung yang ditambahkan dengan cara ini tidak dibuat, jadi kami menambahkan dua garis ajaib ke fungsi <b>utama</b> , yang saya bentuk dalam gambar dan rupa dari apa yang saya lihat di API dari proyek sebelumnya (baris pertama menetapkan nilai yang dimuat dari akun, Beban yang sama, yang kedua memulai penghitung): <br><br><pre> <code class="plaintext hljs"> *((uint8_t*)LCD4bit_1_Count7_1_Counter7__PERIOD_REG) = 0x20; *((uint8_t*)LCD4bit_1_Count7_1_Counter7__CONTROL_AUX_CTL_REG) |= 0x20; // Start</code> </pre><br>  Alat analisis menunjukkan bahwa dalam kasus yang dimodifikasi, penundaannya jelas: <br><br><img src="https://habrastorage.org/webt/ui/ey/ax/uieyax5yt3f0kpkhyyoikiishmq.png"><br><br>  LCD juga memiliki ketiga karakter. <br><br>  Tetapi keluaran karakter terprogram dalam kehidupan nyata tidak dapat diterima.  Dengan menambahkannya ke FIFO akan meluap.  Tunggu hingga FIFO kosong - ini berarti membuat penundaan besar untuk inti prosesor.     72 ,     7-8    1 .         DMA.      ¬´  ¬ª.        UDB,   FIFO        DMA.            DMA,       ,       . <br><br><div class="spoiler"> <b class="spoiler_title">  :</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> static const char line[] = "This is a line"; /* Defines for DMA_D */ #define DMA_D_BYTES_PER_BURST 1 #define DMA_D_REQUEST_PER_BURST 1 /* Variable declarations for DMA_D */ /* Move these variable declarations to the top of the function */ uint8 DMA_D_Chan; uint8 DMA_D_TD[1]; /* DMA Configuration for DMA_D */ DMA_D_Chan = DMA_D_DmaInitialize(DMA_D_BYTES_PER_BURST, DMA_D_REQUEST_PER_BURST, HI16(line), HI16(LCD4bit_1_LCD_DP__F1_REG)); DMA_D_TD[0] = CyDmaTdAllocate(); CyDmaTdSetConfiguration(DMA_D_TD[0], sizeof(line)-1, CY_DMA_DISABLE_TD, CY_DMA_TD_INC_SRC_ADR); CyDmaTdSetAddress(DMA_D_TD[0], LO16((uint32)line), LO16((uint32)LCD4bit_1_LCD_DP__F1_REG)); CyDmaChSetInitialTd(DMA_D_Chan, DMA_D_TD[0]); CyDmaChEnable(DMA_D_Chan, 1);</code> </pre><br></div></div><br>   : <br><br><img src="https://habrastorage.org/webt/i7/ny/vi/i7nyvipk7tg8w_jdflryw2s39uk.png"><br><br><h2>  Kesimpulan </h2><br>  ,     ,        UDB     ‚Äî Datapath Config Tool.  ,    UDB Editor,        UDB,     ,   UDB Editor.             ,    ,    ,     UDB Editor. <br><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442572/">https://habr.com/ru/post/id442572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442560/index.html">Hancurkan: multithreading, coroutine, async & tunggu</a></li>
<li><a href="../id442562/index.html">Cara mendinginkan peralatan di pusat data - tiga teknologi baru</a></li>
<li><a href="../id442566/index.html">Sama seperti di bulan: rekayasa terbalik dari modul op amp hybrid</a></li>
<li><a href="../id442568/index.html">Security Week 10: Kerentanan Driver NVIDIA</a></li>
<li><a href="../id442570/index.html">Aturan Sigma. Kerajinan atau standar baru untuk SOC</a></li>
<li><a href="../id442574/index.html">Dasar untuk teori umum jaringan saraf dibuat</a></li>
<li><a href="../id442576/index.html">Overclocker lama: bagaimana cairan pendingin mulai mendominasi di pusat data</a></li>
<li><a href="../id442578/index.html">Linux 5.0 rilis</a></li>
<li><a href="../id442580/index.html">Binary format reverse engineering menggunakan Korg .SNG file sebagai contoh</a></li>
<li><a href="../id442582/index.html">Bagaimana kami mencoba mobbing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>