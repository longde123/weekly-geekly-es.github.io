<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏽 🚝 👨🏿‍🎨 Aide-mémoire sur les structures de données Go 👦🏽 🧖🏻 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Certaines entreprises interrogent l'écriture de code en ligne. Il est nécessaire pour résoudre le problème de l'olympiade pour la vitesse. Dans de tel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aide-mémoire sur les structures de données Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456194/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/ec/q7/mbecq74rttiedgg0jjosbjzsaua.jpeg" width="300"></div><br>  Certaines entreprises interrogent l'écriture de code en ligne.  Il est nécessaire pour résoudre le problème de l'olympiade pour la vitesse.  Dans de telles circonstances, il n'y a pas de temps pour voir les détails de la mise en œuvre des structures de données - vous devez réaliser immédiatement l'idée.  Mais les cours sur les algorithmes et les structures de données fournissent des exemples en pseudo-code ou en C ++.  D'autres solutions de référence aux problèmes sont souvent écrites en C ++.  En me préparant pour une interview, j'ai fait un berceau de bibliothèques - analogues de conteneurs STL, afin de ne pas perdre un temps précieux à chercher. <br><a name="habracut"></a><br>  Commençons par l'évidence. <br><br><h3>  Réseau continu dynamique </h3><br>  <code>std::vector</code> analogique <code>std::vector</code> . <br>  Prend en charge l'accès à un élément par index pendant un temps constant de plusieurs cycles de processeur.  Vous pouvez augmenter ou diminuer la capacité.  Voici la tranche intégrée: <br><br><pre> <code class="go hljs">vector := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{}</code> </pre><br>  Idéalement, les concepts de base sont intégrés dans le langage. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pile</a> </h3><br>  Analogue de <code>std::stack</code> . <br><br>  Un ensemble ordonné dans lequel l'ajout de nouveaux éléments et la suppression de ceux existants se fait d'un bout à l'autre.  L'élément qui a été placé en dernier (dernier entré, premier sorti - LIFO) est supprimé en premier de la pile.  C'est encore une tranche fortifiée.  Les extraits sont copiés d'un projet à l'autre: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Push stack = append(stack, value)</span></span></code> </pre><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Pop // ,  len(stack) &gt; 0 stack, value = a[:len(stack)-1], a[len(stack)-1]</span></span></code> </pre><br>  L'opération de tranche n'alloue pas de nouvelle mémoire. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">File d'attente</a> </h3><br>  Analogue de <code>std::queue</code> et <code>std::deque</code> . <br><br>  Les files d'attente implémentent des opérations de récupération et d'ajout pour le début et la fin en temps constant.  L'élément qui a été placé en premier (premier entré, premier sorti - FIFO) est supprimé en premier de la file d'attente.  Un canal tamponné est une file d'attente sur un tampon en anneau, vous pouvez l'utiliser lorsque le lecteur et l'écrivain sont des goroutines différents.  Mais il n'y a pas d'implémentation de file d'attente séparée dans la bibliothèque standard.  La liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">awesome-go</a> conseille la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/gammazero/deque</a> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gammazero/deque"</span></span></code> </pre><br>  Opérations en cours: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">At</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br><h3>  Liste doublement liée </h3><br>  Analogue à <code>std::list</code> . <br>  Il se compose d'éléments contenant, en plus de leurs propres données, des liens vers l'élément de liste suivant et précédent.  C'est dans la bibliothèque standard: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"container/list"</span></span></code> </pre><br>  Comme prévu, il prend en charge les opérations d'insertion (au début, à la fin, avant et après l'élément dont le pointeur est passé) et la suppression. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertAfter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, mark *Element)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertBefore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, mark *Element)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br>  Go ne fournit pas de syntaxe spécifique pour les itérateurs.  Par conséquent, l'élément suivant / précédent peut être obtenu à partir d'un pointeur vers n'importe quel nœud.  Ces méthodes ne vont pas mal après l'ajout / la suppression d'un élément à la liste, sans surprise. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Prev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span></span></code> </pre><br><h3>  File d'attente prioritaire </h3><br>  Analog <code>std::priority_queue</code> <br>  Vous permet d'empiler des éléments dans n'importe quel ordre et d'obtenir à tout moment la priorité la plus élevée des autres.  Il est utilisé, par exemple, dans l'algorithme de construction d'un arbre couvrant minimal, lorsque, à l'étape suivante, l'algorithme sélectionne le bord le plus court de tous en commençant par les sommets déjà couverts à une extrémité. <br><br>  La bibliothèque standard possède un adaptateur qui transforme n'importe quel conteneur triable (qui implémente <code>sort.Interface</code> ) en file d'attente prioritaire. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></code> </pre><br>  Il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas binaire</a> classique.  Implémente l'insertion et la suppression dans O (log n). <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface, x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Table de hachage</a> </h3><br>  Il s'agit d'un dictionnaire et d'un tableau associatif. <br><br>  Analog <code>std::unordered_map</code> . <br><br>  Vous permet d'ajouter une valeur-clé, de supprimer la valeur par clé et de vérifier la présence d'un élément pour O (1) en moyenne.  De toute évidence, la carte est intégrée dans le langage: <br><br><pre> <code class="go hljs">unorderedMap := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Le résultat de make (map) est un pointeur, et son fonctionnement est légèrement différent des conteneurs standard: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  : _, ok := unorderedMap["route"] //  : delete(unorderedMap, "route") //  : n := len(unorderedMap)</span></span></code> </pre><br>  "Runtime / map", contrairement à std :: unordered_map, prend soin du programmeur - il est sûr de supprimer des valeurs pendant l'itération. <br><br><h3>  Beaucoup </h3><br>  Analog <code>std::unordered_set</code> . <br>  Presque la même chose qu'une table de hachage, mais sans enregistrer la valeur. <br>  Si nous n'avons besoin que d'une vérification d'entrée rapide, nous pouvons à nouveau utiliser la carte intégrée.  Il suffit de spécifier une valeur vide pour indiquer que seule la clé est importante. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) m[<span class="hljs-string"><span class="hljs-string">"!"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} _, ok := m[<span class="hljs-string"><span class="hljs-string">"!"</span></span>] <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  Mais cette implémentation ne prend pas en charge les opérateurs complexes.  Pour fusionner, recouper, la différence de la boîte, vous avez besoin de bibliothèques tierces.  Le plus utilisé, à en juger par le nombre d'étoiles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/deckarep/golang-set</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/deckarep/golang-set"</span></span></code> </pre><br>  La partie la plus nécessaire de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> : <br><br><pre> <code class="go hljs">Add(i <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Remove(i <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Cardinality() <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// len() Contains(i ...interface{}) bool IsSubset(other Set) bool Intersect(other Set) Set Union(other Set) Set Difference(other Set) Set SymmetricDifference(other Set) Set</span></span></code> </pre><br><h3>  Définir int </h3><br>  Dans la partie expérimentale de la bibliothèque standard, il y a un ensemble optimisé int qui enregistre chaque bit. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/tools/container/intsets"</span></span></code> </pre><br>  Il prend également en charge l'union, l'intersection, la différence d'ensembles. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arbres de recherche binaires</a> </h3><br>  Analogues <code>std::set</code> et <code>std::map</code> . <br>  Cela peut sembler un novice de mauvais analogues des tables de hachage: <br>  prend également en charge l'ajout, la suppression et la vérification des occurrences, mais au-delà de O (log n). <br>  Mais les arbres stockent des nœuds triés par clé. <br><br>  Il n'y a pas d'arbres dans la bibliothèque go standard, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> contenant les arbres AVL, rouge-noir et B est largement utilisé. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/emirpasic/gods/trees/avltree"</span></span></code> </pre><br>  Méthodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API les</a> plus couramment utilisées: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Keys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Left</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Right</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre><br>  Il existe deux méthodes d'arborescence particulièrement importantes: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ceiling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ceiling *Node, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  renvoie le plus petit élément existant plus grand que la clé. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(floor *Node, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  renvoie le plus grand élément existant inférieur à une clé. <br><br>  Les tâches pour cela se trouvent relativement souvent dans les entretiens.  Dans la vraie vie, il est utilisé dans les index de base de données: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x &lt;= $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  S'il y a un index, il fonctionnera pour O (log n), pour 1 recherche de la bordure dans l'arborescence B. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filtre Bloom</a> </h3><br>  Mais cette structure de données dans stl ne l'est pas. <br>  Comme une table de hachage, elle vous permet de vérifier si un élément appartient à un ensemble.  Mais le filtre ne stocke pas de clés lors de l'ajout et prend une quantité constante de mémoire.  Il est possible de recevoir une fausse réponse positive (il n'y a pas d'élément dans l'ensemble, mais la structure de données signale que c'est le cas), mais pas de faux négatif.  Il est utilisé comme filtre pour couper rapidement presque toutes les clés non existantes, ce qui permet d'économiser une vérification plus coûteuse, par exemple, la lecture d'un disque ou l'envoi d'une demande à la base de données. <br>  Il existe une bibliothèque tierce: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/willf/bloom</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/willf/bloom"</span></span></code> </pre><br>  Peu utilisé, vous pouvez jeter un œil à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> . <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HyperLogLog</a> </h3><br>  Il n'y a rien de tel dans la bibliothèque C ++ standard. <br><br>  Structure de données probabiliste.  Avec une petite erreur (≈ 0,4%), il considère le nombre d'éléments uniques sans stocker les clés elles-mêmes.  Il offre d'énormes économies de mémoire.  Si la tâche consiste à calculer rapidement le nombre de visiteurs ou de demandes - HyperLogLog est idéal. <br><br>  La bibliothèque la plus populaire pour cela maintenant. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/axiomhq/hyperloglog</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/axiomhq/hyperloglog"</span></span></code> </pre><br><h3>  Tri </h3><br>  Analogues <code>std::sort</code> et <code>std::stable_sort</code> . <br>  Du point de vue du consommateur, il n'y a que 2 types fondamentalement différents: <br>  Stable (ne changez pas l'ordre des éléments égaux [[4, 0], [1, 2], [1, 1], [5, 6]] -&gt; [[1, 2], [1, 1], [4 , 0], [5, 6]]) <br>  et non stable, ne garantissant pas la cohérence des champs restants. <br>  Les deux sont dans la bibliothèque standard: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data Interface)</span></span></span></span></code> </pre><br>  Il s'agit d'une implémentation de tri rapide Hoar, instable.  Mais pour les sections de longueur &lt;12, le tri par tas est utilisé comme optimisation. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data Interface)</span></span></span></span></code> </pre><br>  À l'intérieur, il s'agit d'un tri par fusion, mais pour plus d'efficacité, lorsque l'algorithme récursif atteint des blocs de moins de 20 éléments, le tri par insertion est utilisé. <br><br>  Ce sont les algorithmes classiques fonctionnant pour O (n log n). <br><br>  Si vous le lisez, félicitations.  La connaissance d'API spécifiques aide à résoudre les problèmes de test.  (Si vous avez travaillé avec quelque chose et connaissez les meilleures alternatives - écrivez dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456194/">https://habr.com/ru/post/fr456194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456182/index.html">Audio via Bluetooth: informations les plus détaillées sur les profils, les codecs et les appareils</a></li>
<li><a href="../fr456184/index.html">Radio définie par logiciel - comment ça marche? Partie 8</a></li>
<li><a href="../fr456186/index.html">CS231n: Réseaux de neurones convolutifs pour la reconnaissance de formes</a></li>
<li><a href="../fr456188/index.html">Jeton, jeton d'actualisation et création d'un wrapper asynchrone pour une demande REST</a></li>
<li><a href="../fr456192/index.html">Des monolithes aux microservices: l'expérience de M.Video-Eldorado et MegaFon</a></li>
<li><a href="../fr456196/index.html">Idées fausses sur SCRUM</a></li>
<li><a href="../fr456200/index.html">Histoire d'Internet: ARPANET - L'Origine</a></li>
<li><a href="../fr456202/index.html">WSL 2 est désormais disponible dans Windows Insiders</a></li>
<li><a href="../fr456204/index.html">WSL 2 est désormais disponible pour Windows Insiders</a></li>
<li><a href="../fr456206/index.html">Comment Moovit a amélioré son application pour aider les personnes handicapées à voyager en toute confiance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>