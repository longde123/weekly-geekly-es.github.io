<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝 🤘🏻 🥌 Ingeniería inversa industrial 🤴🏻 🤳🏻 👇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia del proceso de préstamo en el desarrollo de la electrónica en un buen ejemplo. 



 Grabar el registro del elevador del sniffer casero 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingeniería inversa industrial</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459492/"><p>  La historia del proceso de préstamo en el desarrollo de la electrónica en un buen ejemplo. </p><br><p><img src="https://habrastorage.org/webt/r4/4r/gn/r44rgn9ckwjsxn3aqhznjl6yopg.png"><br>  <em>Grabar el registro del elevador del sniffer casero</em> </p><a name="habracut"></a><br><p>  Una vez que necesitaba copiar un dispositivo bastante simple.  La empresa de fabricación dejó de existir, pero en todo el país todavía existía una demanda de reemplazo de dispositivos rotos o usados. </p><br><p>  El dispositivo en sí es el botón de llamada del ascensor en la foto de la izquierda.  Para los experimentos, me dieron dos copias, una de las cuales podría desmontarse por completo. </p><br><p>  El plan de trabajo general se parecía a esto: </p><br><ol><li>  Estudiar la placa de circuito; </li><li>  Estudiar la base del elemento del tablero mismo; </li><li>  Dibujando su circuito eléctrico; </li><li>  Intente leer el archivo de firmware del microcontrolador; </li><li>  Desmontaje del firmware; </li><li>  Extracción del algoritmo de operación; </li><li>  Desarrollo de una nueva junta; </li><li>  Escribir un nuevo firmware. </li></ol><br><p>  Si el párrafo 4 falla, el plan adicional habría sido más complicado, pero tuve suerte. </p><br><h3 id="izuchaem-podopytnogo">  Estudiamos el experimental </h3><br><p><img src="https://habrastorage.org/webt/_i/ys/gk/_iysgkygkocn9mdncbzolz0u9q4.jpeg"><br>  <em>Microcontrolador principal</em> </p><br><p><img src="https://habrastorage.org/webt/cn/eh/fj/cnehfjp5bvviohtimlndliklm9i.png"><br>  <em>Una parte del circuito eléctrico del elevador, en el cual nuestras tablas están rodeadas en rojo</em> </p><br><p>  La placa se ensambla en un microcontrolador de 1997, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AT89C2051</a> , que se basa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura Intel MCS-51</a> .  En 2020, celebra su 40 aniversario en el mercado de sistemas integrados. </p><br><blockquote>  Una pequeña explicación: un microcontrolador es un microcircuito que contiene un núcleo informático y un conjunto de periféricos para controlar dispositivos externos.  Por ejemplo, en una lavadora moderna, el microcontrolador sondea los botones de control, los sensores, muestra información en la pantalla y controla las bombas, el calentador, las válvulas y la unidad de tambor.  Para la mayoría de estas funciones, no requiere dispositivos intermedios, solo un conjunto de componentes electrónicos pasivos. </blockquote><p><img src="https://habrastorage.org/webt/rk/o2/uf/rko2ufxrcsmtjghptrilwcpx3fq.jpeg"><br>  <em>Desmontamos la placa de circuito</em> <em><br></em> <br>  Dibujar el diagrama de circuito original de la placa en el futuro ayudará a descubrir el propósito de los pines del microcontrolador, que es necesario para analizar el código del firmware. </p><br><p>  El dispositivo original fue desarrollado por una empresa china y, por lo tanto, su circuito es extremadamente confuso y tiene muchos componentes innecesarios.  Por ejemplo, el relé se encendió a través de una triple cascada de un transistor bipolar, un optoacoplador y un controlador de campo (en ese orden). </p><br><p>  Un conocido que trabajaba con fabricantes chinos me dijo que los chinos están involucrados en complicaciones similares de esquemas para aumentar el costo de desarrollo y producción, si solo una persona lo hace.  Después de esto, me inclino a creerle: </p><br><p><img src="https://habrastorage.org/webt/fs/ku/lh/fskulhqa3cjeb4v9ilr7bncg9y8.png"><br>  <em>El mismo lugar en el tablero chino de dos capas en ambos lados.</em>  <em>Tres enormes resistencias no están conectadas a nada.</em>  <em>Incluso hice brillar el tablero con una potente linterna para asegurarme.</em> </p><br><p>  El esquema se copia, los lugares misteriosos se modelan en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multisim</a> , tomamos el firmware. </p><br><h3 id="pytaemsya-schitat-proshivku">  Intentando leer el firmware </h3><br><p>  Tuve mucha suerte de que la protección contra lectura no estuviera habilitada en ambas placas en los controladores, por lo que fusioné con éxito las dos opciones de firmware con pornografía similar: </p><br><p><img src="https://habrastorage.org/webt/re/9i/ep/re9iepb510h1ylxdfsc29sfre80.jpeg"><br>  <em>Foto del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog personal de</a> un entusiasta estadounidense.</em> </p><br><h3 id="dizassemblirovanie-proshivki">  Desmontaje del firmware </h3><br><p>  El siguiente paso que necesitamos para convertir este código de máquina en algo más legible: </p><br><p><img src="https://habrastorage.org/webt/kp/te/gn/kptegnvznij68y49jd7y15vpwsi.png"></p><br><p>  Tomamos la conocida herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDA Pro</a> , que ya tiene nuestro controlador con todos los registros periféricos, y abrimos el archivo de firmware HEX: </p><br><p><img src="https://habrastorage.org/webt/yx/g_/zj/yxg_zjqxt1nqg3f_jkvuwhhknqy.png"><br>  <em>Procesamiento de datos recibidos por la placa en lenguaje ensamblador</em> </p><br><p>  Después de eso, hay un proceso bastante tedioso de estudiar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de instrucciones de</a> nuestro núcleo informático, comentando y decodificando el código del ensamblador. </p><br><p>  Los mismos controladores de interrupción se encontraron en las direcciones de la tabla de vectores de interrupción; las entradas en los registros periféricos proporcionaron información sobre la configuración de la interfaz de comunicación.  Paso a paso, el código de ensamblador sin nombre se ha convertido en algo que se puede leer. </p><br><h3 id="izvlechenie-algoritma-raboty">  Extracción del algoritmo de trabajo. </h3><br><p>  Como necesitaba desarrollar un nuevo dispositivo en una base de elementos diferente, era necesario extraer un algoritmo del código.  Algún tiempo después, nació un pseudocódigo de este tipo: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UartISR</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ counter500ms = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ClearFlag(isrFlags, ISR_FLAG_3); ProcessUart(recievedByte); } void ProcessUart(uint8_t recievedData) { static uint8_t uartPacketsToRxLeft, uartRecievedCmd, uartCurrPacketCRC; static uint8_t i, carryFlag; static uint16_t uartIsrPointer; static uint8_t uartBuffer1[8], uartBuffer2[6]; static uint8_t uartBuffer1Pos, uartBuffer2Pos; // 0 - // 1 - // 2 - // 3 - led state, 0x0F // 4 - // 5 - // 6 - // 7 - // 8 - buttons time static uint8_t dataRegisters[9]; // RAM:0050 uint8_t tmpVal, i; uint8_t dataToSend; if (GetFlag(UartISRFlags, UART_RECIEVED_FLAG)) { ClearFlag(UartISRFlags, UART_RECIEVED_FLAG); if (recieved9thBit) { switch (recievedData) { case 0xC1: uartPacketsToRxLeft = 8; uartRecievedCmd = 1; uartBuffer1Pos = 0; uartBuffer1[uartBuffer1Pos] = recievedData; //uartIsrPointer = 0x0037; //tmpVal_0037 = recievedData; uartCurrPacketCRC = recievedData; UartRxOn(); return; break; case 0xC2: uartPacketsToRxLeft = 3; uartRecievedCmd = 2;</span></span></code> </pre> <br><p>  El mismo procesamiento de datos recibidos en C </p><br><p>  A quién le importa el protocolo de transferencia: </p><br><blockquote>  La estación de control del elevador se comunicaba con los paneles de botones de llamada a través de una interfaz dúplex completa de 24 voltios.  En modo normal, las tarjetas de botón escuchaban la línea, esperando un paquete de datos de 9 bits.  Si la dirección de nuestra placa vino en este paquete (fue establecida por el interruptor DIP en la placa), entonces la placa cambió al modo de recepción de 8 bits, y todos los paquetes posteriores fueron ignorados por el resto de las placas en el hardware. <br><br>  El primero después de la dirección fue un paquete con un código de comando de control.  Específicamente, este tablero solo tomó 3 equipos: <br><ol><li>  Escribir en registros de datos.  Por ejemplo, la frecuencia y duración del botón parpadeante en una llamada; </li><li>  Encender la luz de fondo del botón; </li><li>  Consulta el estado de los botones (presionados o no). </li></ol><br><br>  El último byte fue la suma de comprobación, que es un XOR simple de todos los bytes después de la dirección. <br>  Después de la suma de verificación, el tablero volvió a entrar en modo de espera para su dirección. </blockquote><br><h3 id="razrabotka-novoy-platy">  Desarrollo de nueva junta </h3><br><p>  Para la etapa de desarrollar un nuevo diagrama de cableado y una placa de circuito impreso, no tengo imágenes, pero fue algo como esto: <br><img src="https://habrastorage.org/webt/qo/o1/ib/qoo1ib5i-46roxxqoea1tw9sshq.jpeg"></p><br><p>  El cableado y el cableado se realizaron en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Altium Designer</a> .  La fabricación de la placa de circuito impreso se ordenó en Zelenograd " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resonite</a> ". </p><br><h3 id="napisanie-novoy-proshivki">  Escribir un nuevo firmware </h3><br><p>  Mientras nuestra nueva placa está en producción, vamos al objeto donde están instalados dichos botones de llamada y verificamos la corrección del protocolo de transferencia desmontado utilizando el sniffer montado en el arduino: <br><img src="https://habrastorage.org/webt/aa/wl/0e/aawl0ep77fnv2gz_txeorxjzkls.png"><br>  Una pieza de circuito transmisor que es eléctricamente equivalente al original.  El receptor es solo un optoacoplador. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//UART1 initialize // desired baud rate:19200 // actual baud rate:19231 (0,2%) // char size: 9 bit // parity: Disabled void uart1_init(void) { UCSR1B = 0x00; //disable while setting baud rate UCSR1A = 0x00; UCSR1C = 0x06; UBRR1L = 0x33; //set baud rate lo UBRR1H = 0x00; //set baud rate hi UCSR1B = 0x94; } #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC void uart1_rx_isr(void) { unsigned char tmp; unsigned int rcv = 0; if (UCSR1B &amp; 0x02) { rcv = 0x100; } rcv |= UDR1; tmp = (rcv &gt;&gt; 4) &amp; 0x0F; if (rcv &amp; 0x100) { tmp |= 0xC0; } else { tmp |= 0x80; } txBuf12 = (rcv &amp; 0x0F); txBuf11 = tmp; txState1 = 0; TX_ON(); msCounter0 = 5000; }</span></span></code> </pre> <br><p>  Hable acerca de nuestro sniffer en ICC AVR </p><br><p>  Luego, era necesario actuar con mucho cuidado para no quemar nada en el elevador y evitar que se detuviera. </p><br><p><img src="https://habrastorage.org/webt/ji/fm/g3/jifmg3osv9g5dxwr_4sq90ela6g.jpeg"><br>  Subimos al botón de llamada.  Cables amarillos gruesos: interfaz de alimentación y transmisión de la placa.  Blanco en el conector de 4 pines: conecta el botón y su luz de fondo. </p><br><p>  Verificamos que todo funcione como debería, arreglamos las jambas y escribimos un nuevo firmware para nuestro dispositivo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//ICC-AVR application builder : 11.02.2015 12:25:51 // Target : M328p // Crystal: 16.000Mhz #include &lt;macros.h&gt; #include &lt;iccioavr.h&gt; #include &lt;avrdef.h&gt; #include "types.h" #include "gpio.h" #define TX_OFF() UCSR0B &amp;= 0b11011111; #define TX_ON() UCSR0B |= 0b00100000; #define TX_STATE() (UCSR0B &amp; 0b00100000) #define MAX_TIMEOUT 3000 //#define SNIFFER_MODE 1 //#define MASTER_MODE 1 // #pragma avr_fuse (fuses0, fuses1, fuses2, fuses3, fuses4, fuses5) #pragma avr_fuse (0xFF, 0xD1, 0xFC) #pragma avr_lockbits (0xFC) // AVR signature is always three bytes. Signature0 is always the Atmel // manufacturer code of 0x1E. The other two bytes are device dependent. #pragma avr_signature (0x1E, 0x95, 0x0F) // atmega32 static GPIOx errorLed, rcvLed, butUp, butDn, ledUp, ledDn, butLedUp, butLedDn, ledButUp, ledButDn; static uint8_t msFlag = 0; static uint8_t ledState = 0, buttonsState = 0; static uint16_t rcvLedLitTime = 0, butMaskCalcTime = 0, timeoutTimer = 0; typedef struct { uint16_t buffer[10]; uint8_t dataLength; } UartPacket; static UartPacket txPacket, rxPacket; #ifdef SNIFFER_MODE static uint8_t txBuffer[64], txBufferLength = 0, bufferMutex = 0; #endif static uint8_t GetPacketCRC(UartPacket* packet); static void SendLedState(void); uint8_t GetAddress(void) { return (PINC &amp; 0x3F); }</span></span></code> </pre> <br><p>  Código C para la nueva placa basada en el microcontrolador AVR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ATmega328P</a> </p><br><p>  La simplicidad del dispositivo y el firmware se puede estimar por la cantidad de código, contiene solo alrededor de 600 líneas en lenguaje C. </p><br><p>  El proceso de compilación se veía así: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UIF7QEQrbh8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La tarifa es diferente, pero el principio es el mismo. </p><br><p>  No puedo adjuntar una foto del dispositivo terminado, solo creo que todavía se está produciendo y vendiendo. </p><br><h3 id="liricheskoe-zaklyuchenie">  Conclusión lírica </h3><br><p>  Con respecto a los botones del elevador "arriba" y "abajo" en el piso.  Noté que muchas personas no entienden completamente su propósito y sacuden ambos a la vez. </p><br><p><img src="https://habrastorage.org/webt/r2/6r/e7/r26re7kjkj8dhppaxmbkdcedvt8.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desde aqui</a> </p><br><p>  El elevador tiene dos juegos de botones: en la cabina hay un panel de pedidos y en el piso hay un panel de llamadas.  Ya puede adivinar por el nombre que el panel de pedidos tiene una mayor prioridad de control. </p><br><p>  Todos los ascensores con paneles de llamada con botones arriba y abajo funcionan con una de las opciones para el algoritmo de optimización de viaje, cuyo propósito es transportar el número máximo de pasajeros en el tiempo mínimo y una condición separada para el tiempo de espera máximo en el piso (regulado por la norma estatal). </p><br><p>  Tal algoritmo generalmente implica la selección de pasajeros en los pisos si viajan en la misma dirección que se indica presionando el botón de llamada "arriba" o "abajo". </p><br><p>  Imagine una situación en la que un ascensor con pasajeros viaja hacia abajo y recibe una llamada de "bajada" desde el piso de abajo.  El elevador se detendrá para recoger al pasajero (sí, todavía se tiene en cuenta la carga de la cabina por el sensor de peso, pero lo bajaremos). </p><br><p>  El elevador continúa y recibe una llamada "arriba" desde el piso de abajo.  Es lógico que el ascensor no se detenga para recoger a un pasajero, ya que no cambiará la dirección de viaje (esto también está regulado por la norma), pero recoger a un pasajero para bajar y luego subir es un desperdicio de energía y espacio en el elevador. </p><br><p>  El elevador continúa y recibe dos llamadas "arriba y abajo" desde el piso de abajo, que fueron presionadas por un pasajero impaciente que necesita subir.  Es lógico que el elevador se detenga en este piso, pero el pasajero no ingresará, pero tomará el tiempo de las personas en la cabina para reducir la velocidad y detener el elevador, abrir las puertas, esperar, cerrar las puertas y acelerar a la velocidad nominal. </p><br><p>  Si el elevador tiene solo un botón en el piso, entonces en el 99% de los casos funciona de acuerdo con el algoritmo de "descenso colectivo", y si hay órdenes en la cabina, se detiene solo cuando se baja. </p><br><p>  Si tienes habilidades de programación en JS, entonces puedes intentar implementar un algoritmo de control similar en el juego en línea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elevator Saga</a> .  Tiene todos los aspectos de optimizar los viajes sin profundizar en el hardcore, como la operación de los circuitos de seguridad de los ascensores. </p><br><p><img src="https://habrastorage.org/webt/pi/kj/ig/pikjigdf2mqsd2ptmjbtot-yd34.png"></p><br><p>  En mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas publico</a> materiales similares.  Ahora mismo puedes seguir el desarrollo del próximo dispositivo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459492/">https://habr.com/ru/post/459492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459480/index.html">Vivaldi: ¿Cómo gana dinero el navegador?</a></li>
<li><a href="../459482/index.html">Cómo derrotamos al árbol de categorías</a></li>
<li><a href="../459484/index.html">Generación Arduino. Lo que inventan los estudiantes modernos</a></li>
<li><a href="../459488/index.html">Modos de juego especiales en el contexto de Roguelike</a></li>
<li><a href="../459490/index.html">Trucos sucios de vendedores de CRM: ¿comprarías un auto sin ruedas?</a></li>
<li><a href="../459494/index.html">Cómo lanzar una creciente startup b2c después de un hackathon</a></li>
<li><a href="../459498/index.html">Slurm - Una manera fácil de entrar en un tema de Kubernetes</a></li>
<li><a href="../459500/index.html">HTML es la web</a></li>
<li><a href="../459502/index.html">Continuamos desarrollando una plataforma de aventura para los rusos: características de interfaz y preferencias de verano.</a></li>
<li><a href="../459504/index.html">Curso para jóvenes diseñadores de juegos: cómo contar el equilibrio de personajes y equipos sin matemáticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>