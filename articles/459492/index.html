<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Ingenier铆a inversa industrial ご こ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia del proceso de pr茅stamo en el desarrollo de la electr贸nica en un buen ejemplo. 



 Grabar el registro del elevador del sniffer casero 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingenier铆a inversa industrial</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459492/"><p>  La historia del proceso de pr茅stamo en el desarrollo de la electr贸nica en un buen ejemplo. </p><br><p><img src="https://habrastorage.org/webt/r4/4r/gn/r44rgn9ckwjsxn3aqhznjl6yopg.png"><br>  <em>Grabar el registro del elevador del sniffer casero</em> </p><a name="habracut"></a><br><p>  Una vez que necesitaba copiar un dispositivo bastante simple.  La empresa de fabricaci贸n dej贸 de existir, pero en todo el pa铆s todav铆a exist铆a una demanda de reemplazo de dispositivos rotos o usados. </p><br><p>  El dispositivo en s铆 es el bot贸n de llamada del ascensor en la foto de la izquierda.  Para los experimentos, me dieron dos copias, una de las cuales podr铆a desmontarse por completo. </p><br><p>  El plan de trabajo general se parec铆a a esto: </p><br><ol><li>  Estudiar la placa de circuito; </li><li>  Estudiar la base del elemento del tablero mismo; </li><li>  Dibujando su circuito el茅ctrico; </li><li>  Intente leer el archivo de firmware del microcontrolador; </li><li>  Desmontaje del firmware; </li><li>  Extracci贸n del algoritmo de operaci贸n; </li><li>  Desarrollo de una nueva junta; </li><li>  Escribir un nuevo firmware. </li></ol><br><p>  Si el p谩rrafo 4 falla, el plan adicional habr铆a sido m谩s complicado, pero tuve suerte. </p><br><h3 id="izuchaem-podopytnogo">  Estudiamos el experimental </h3><br><p><img src="https://habrastorage.org/webt/_i/ys/gk/_iysgkygkocn9mdncbzolz0u9q4.jpeg"><br>  <em>Microcontrolador principal</em> </p><br><p><img src="https://habrastorage.org/webt/cn/eh/fj/cnehfjp5bvviohtimlndliklm9i.png"><br>  <em>Una parte del circuito el茅ctrico del elevador, en el cual nuestras tablas est谩n rodeadas en rojo</em> </p><br><p>  La placa se ensambla en un microcontrolador de 1997, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AT89C2051</a> , que se basa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura Intel MCS-51</a> .  En 2020, celebra su 40 aniversario en el mercado de sistemas integrados. </p><br><blockquote>  Una peque帽a explicaci贸n: un microcontrolador es un microcircuito que contiene un n煤cleo inform谩tico y un conjunto de perif茅ricos para controlar dispositivos externos.  Por ejemplo, en una lavadora moderna, el microcontrolador sondea los botones de control, los sensores, muestra informaci贸n en la pantalla y controla las bombas, el calentador, las v谩lvulas y la unidad de tambor.  Para la mayor铆a de estas funciones, no requiere dispositivos intermedios, solo un conjunto de componentes electr贸nicos pasivos. </blockquote><p><img src="https://habrastorage.org/webt/rk/o2/uf/rko2ufxrcsmtjghptrilwcpx3fq.jpeg"><br>  <em>Desmontamos la placa de circuito</em> <em><br></em> <br>  Dibujar el diagrama de circuito original de la placa en el futuro ayudar谩 a descubrir el prop贸sito de los pines del microcontrolador, que es necesario para analizar el c贸digo del firmware. </p><br><p>  El dispositivo original fue desarrollado por una empresa china y, por lo tanto, su circuito es extremadamente confuso y tiene muchos componentes innecesarios.  Por ejemplo, el rel茅 se encendi贸 a trav茅s de una triple cascada de un transistor bipolar, un optoacoplador y un controlador de campo (en ese orden). </p><br><p>  Un conocido que trabajaba con fabricantes chinos me dijo que los chinos est谩n involucrados en complicaciones similares de esquemas para aumentar el costo de desarrollo y producci贸n, si solo una persona lo hace.  Despu茅s de esto, me inclino a creerle: </p><br><p><img src="https://habrastorage.org/webt/fs/ku/lh/fskulhqa3cjeb4v9ilr7bncg9y8.png"><br>  <em>El mismo lugar en el tablero chino de dos capas en ambos lados.</em>  <em>Tres enormes resistencias no est谩n conectadas a nada.</em>  <em>Incluso hice brillar el tablero con una potente linterna para asegurarme.</em> </p><br><p>  El esquema se copia, los lugares misteriosos se modelan en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multisim</a> , tomamos el firmware. </p><br><h3 id="pytaemsya-schitat-proshivku">  Intentando leer el firmware </h3><br><p>  Tuve mucha suerte de que la protecci贸n contra lectura no estuviera habilitada en ambas placas en los controladores, por lo que fusion茅 con 茅xito las dos opciones de firmware con pornograf铆a similar: </p><br><p><img src="https://habrastorage.org/webt/re/9i/ep/re9iepb510h1ylxdfsc29sfre80.jpeg"><br>  <em>Foto del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog personal de</a> un entusiasta estadounidense.</em> </p><br><h3 id="dizassemblirovanie-proshivki">  Desmontaje del firmware </h3><br><p>  El siguiente paso que necesitamos para convertir este c贸digo de m谩quina en algo m谩s legible: </p><br><p><img src="https://habrastorage.org/webt/kp/te/gn/kptegnvznij68y49jd7y15vpwsi.png"></p><br><p>  Tomamos la conocida herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDA Pro</a> , que ya tiene nuestro controlador con todos los registros perif茅ricos, y abrimos el archivo de firmware HEX: </p><br><p><img src="https://habrastorage.org/webt/yx/g_/zj/yxg_zjqxt1nqg3f_jkvuwhhknqy.png"><br>  <em>Procesamiento de datos recibidos por la placa en lenguaje ensamblador</em> </p><br><p>  Despu茅s de eso, hay un proceso bastante tedioso de estudiar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de instrucciones de</a> nuestro n煤cleo inform谩tico, comentando y decodificando el c贸digo del ensamblador. </p><br><p>  Los mismos controladores de interrupci贸n se encontraron en las direcciones de la tabla de vectores de interrupci贸n; las entradas en los registros perif茅ricos proporcionaron informaci贸n sobre la configuraci贸n de la interfaz de comunicaci贸n.  Paso a paso, el c贸digo de ensamblador sin nombre se ha convertido en algo que se puede leer. </p><br><h3 id="izvlechenie-algoritma-raboty">  Extracci贸n del algoritmo de trabajo. </h3><br><p>  Como necesitaba desarrollar un nuevo dispositivo en una base de elementos diferente, era necesario extraer un algoritmo del c贸digo.  Alg煤n tiempo despu茅s, naci贸 un pseudoc贸digo de este tipo: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UartISR</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ counter500ms = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ClearFlag(isrFlags, ISR_FLAG_3); ProcessUart(recievedByte); } void ProcessUart(uint8_t recievedData) { static uint8_t uartPacketsToRxLeft, uartRecievedCmd, uartCurrPacketCRC; static uint8_t i, carryFlag; static uint16_t uartIsrPointer; static uint8_t uartBuffer1[8], uartBuffer2[6]; static uint8_t uartBuffer1Pos, uartBuffer2Pos; // 0 - // 1 - // 2 - // 3 - led state, 0x0F // 4 - // 5 - // 6 - // 7 - // 8 - buttons time static uint8_t dataRegisters[9]; // RAM:0050 uint8_t tmpVal, i; uint8_t dataToSend; if (GetFlag(UartISRFlags, UART_RECIEVED_FLAG)) { ClearFlag(UartISRFlags, UART_RECIEVED_FLAG); if (recieved9thBit) { switch (recievedData) { case 0xC1: uartPacketsToRxLeft = 8; uartRecievedCmd = 1; uartBuffer1Pos = 0; uartBuffer1[uartBuffer1Pos] = recievedData; //uartIsrPointer = 0x0037; //tmpVal_0037 = recievedData; uartCurrPacketCRC = recievedData; UartRxOn(); return; break; case 0xC2: uartPacketsToRxLeft = 3; uartRecievedCmd = 2;</span></span></code> </pre> <br><p>  El mismo procesamiento de datos recibidos en C </p><br><p>  A qui茅n le importa el protocolo de transferencia: </p><br><blockquote>  La estaci贸n de control del elevador se comunicaba con los paneles de botones de llamada a trav茅s de una interfaz d煤plex completa de 24 voltios.  En modo normal, las tarjetas de bot贸n escuchaban la l铆nea, esperando un paquete de datos de 9 bits.  Si la direcci贸n de nuestra placa vino en este paquete (fue establecida por el interruptor DIP en la placa), entonces la placa cambi贸 al modo de recepci贸n de 8 bits, y todos los paquetes posteriores fueron ignorados por el resto de las placas en el hardware. <br><br>  El primero despu茅s de la direcci贸n fue un paquete con un c贸digo de comando de control.  Espec铆ficamente, este tablero solo tom贸 3 equipos: <br><ol><li>  Escribir en registros de datos.  Por ejemplo, la frecuencia y duraci贸n del bot贸n parpadeante en una llamada; </li><li>  Encender la luz de fondo del bot贸n; </li><li>  Consulta el estado de los botones (presionados o no). </li></ol><br><br>  El 煤ltimo byte fue la suma de comprobaci贸n, que es un XOR simple de todos los bytes despu茅s de la direcci贸n. <br>  Despu茅s de la suma de verificaci贸n, el tablero volvi贸 a entrar en modo de espera para su direcci贸n. </blockquote><br><h3 id="razrabotka-novoy-platy">  Desarrollo de nueva junta </h3><br><p>  Para la etapa de desarrollar un nuevo diagrama de cableado y una placa de circuito impreso, no tengo im谩genes, pero fue algo como esto: <br><img src="https://habrastorage.org/webt/qo/o1/ib/qoo1ib5i-46roxxqoea1tw9sshq.jpeg"></p><br><p>  El cableado y el cableado se realizaron en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Altium Designer</a> .  La fabricaci贸n de la placa de circuito impreso se orden贸 en Zelenograd " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resonite</a> ". </p><br><h3 id="napisanie-novoy-proshivki">  Escribir un nuevo firmware </h3><br><p>  Mientras nuestra nueva placa est谩 en producci贸n, vamos al objeto donde est谩n instalados dichos botones de llamada y verificamos la correcci贸n del protocolo de transferencia desmontado utilizando el sniffer montado en el arduino: <br><img src="https://habrastorage.org/webt/aa/wl/0e/aawl0ep77fnv2gz_txeorxjzkls.png"><br>  Una pieza de circuito transmisor que es el茅ctricamente equivalente al original.  El receptor es solo un optoacoplador. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//UART1 initialize // desired baud rate:19200 // actual baud rate:19231 (0,2%) // char size: 9 bit // parity: Disabled void uart1_init(void) { UCSR1B = 0x00; //disable while setting baud rate UCSR1A = 0x00; UCSR1C = 0x06; UBRR1L = 0x33; //set baud rate lo UBRR1H = 0x00; //set baud rate hi UCSR1B = 0x94; } #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC void uart1_rx_isr(void) { unsigned char tmp; unsigned int rcv = 0; if (UCSR1B &amp; 0x02) { rcv = 0x100; } rcv |= UDR1; tmp = (rcv &gt;&gt; 4) &amp; 0x0F; if (rcv &amp; 0x100) { tmp |= 0xC0; } else { tmp |= 0x80; } txBuf12 = (rcv &amp; 0x0F); txBuf11 = tmp; txState1 = 0; TX_ON(); msCounter0 = 5000; }</span></span></code> </pre> <br><p>  Hable acerca de nuestro sniffer en ICC AVR </p><br><p>  Luego, era necesario actuar con mucho cuidado para no quemar nada en el elevador y evitar que se detuviera. </p><br><p><img src="https://habrastorage.org/webt/ji/fm/g3/jifmg3osv9g5dxwr_4sq90ela6g.jpeg"><br>  Subimos al bot贸n de llamada.  Cables amarillos gruesos: interfaz de alimentaci贸n y transmisi贸n de la placa.  Blanco en el conector de 4 pines: conecta el bot贸n y su luz de fondo. </p><br><p>  Verificamos que todo funcione como deber铆a, arreglamos las jambas y escribimos un nuevo firmware para nuestro dispositivo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//ICC-AVR application builder : 11.02.2015 12:25:51 // Target : M328p // Crystal: 16.000Mhz #include &lt;macros.h&gt; #include &lt;iccioavr.h&gt; #include &lt;avrdef.h&gt; #include "types.h" #include "gpio.h" #define TX_OFF() UCSR0B &amp;= 0b11011111; #define TX_ON() UCSR0B |= 0b00100000; #define TX_STATE() (UCSR0B &amp; 0b00100000) #define MAX_TIMEOUT 3000 //#define SNIFFER_MODE 1 //#define MASTER_MODE 1 // #pragma avr_fuse (fuses0, fuses1, fuses2, fuses3, fuses4, fuses5) #pragma avr_fuse (0xFF, 0xD1, 0xFC) #pragma avr_lockbits (0xFC) // AVR signature is always three bytes. Signature0 is always the Atmel // manufacturer code of 0x1E. The other two bytes are device dependent. #pragma avr_signature (0x1E, 0x95, 0x0F) // atmega32 static GPIOx errorLed, rcvLed, butUp, butDn, ledUp, ledDn, butLedUp, butLedDn, ledButUp, ledButDn; static uint8_t msFlag = 0; static uint8_t ledState = 0, buttonsState = 0; static uint16_t rcvLedLitTime = 0, butMaskCalcTime = 0, timeoutTimer = 0; typedef struct { uint16_t buffer[10]; uint8_t dataLength; } UartPacket; static UartPacket txPacket, rxPacket; #ifdef SNIFFER_MODE static uint8_t txBuffer[64], txBufferLength = 0, bufferMutex = 0; #endif static uint8_t GetPacketCRC(UartPacket* packet); static void SendLedState(void); uint8_t GetAddress(void) { return (PINC &amp; 0x3F); }</span></span></code> </pre> <br><p>  C贸digo C para la nueva placa basada en el microcontrolador AVR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ATmega328P</a> </p><br><p>  La simplicidad del dispositivo y el firmware se puede estimar por la cantidad de c贸digo, contiene solo alrededor de 600 l铆neas en lenguaje C. </p><br><p>  El proceso de compilaci贸n se ve铆a as铆: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UIF7QEQrbh8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La tarifa es diferente, pero el principio es el mismo. </p><br><p>  No puedo adjuntar una foto del dispositivo terminado, solo creo que todav铆a se est谩 produciendo y vendiendo. </p><br><h3 id="liricheskoe-zaklyuchenie">  Conclusi贸n l铆rica </h3><br><p>  Con respecto a los botones del elevador "arriba" y "abajo" en el piso.  Not茅 que muchas personas no entienden completamente su prop贸sito y sacuden ambos a la vez. </p><br><p><img src="https://habrastorage.org/webt/r2/6r/e7/r26re7kjkj8dhppaxmbkdcedvt8.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desde aqui</a> </p><br><p>  El elevador tiene dos juegos de botones: en la cabina hay un panel de pedidos y en el piso hay un panel de llamadas.  Ya puede adivinar por el nombre que el panel de pedidos tiene una mayor prioridad de control. </p><br><p>  Todos los ascensores con paneles de llamada con botones arriba y abajo funcionan con una de las opciones para el algoritmo de optimizaci贸n de viaje, cuyo prop贸sito es transportar el n煤mero m谩ximo de pasajeros en el tiempo m铆nimo y una condici贸n separada para el tiempo de espera m谩ximo en el piso (regulado por la norma estatal). </p><br><p>  Tal algoritmo generalmente implica la selecci贸n de pasajeros en los pisos si viajan en la misma direcci贸n que se indica presionando el bot贸n de llamada "arriba" o "abajo". </p><br><p>  Imagine una situaci贸n en la que un ascensor con pasajeros viaja hacia abajo y recibe una llamada de "bajada" desde el piso de abajo.  El elevador se detendr谩 para recoger al pasajero (s铆, todav铆a se tiene en cuenta la carga de la cabina por el sensor de peso, pero lo bajaremos). </p><br><p>  El elevador contin煤a y recibe una llamada "arriba" desde el piso de abajo.  Es l贸gico que el ascensor no se detenga para recoger a un pasajero, ya que no cambiar谩 la direcci贸n de viaje (esto tambi茅n est谩 regulado por la norma), pero recoger a un pasajero para bajar y luego subir es un desperdicio de energ铆a y espacio en el elevador. </p><br><p>  El elevador contin煤a y recibe dos llamadas "arriba y abajo" desde el piso de abajo, que fueron presionadas por un pasajero impaciente que necesita subir.  Es l贸gico que el elevador se detenga en este piso, pero el pasajero no ingresar谩, pero tomar谩 el tiempo de las personas en la cabina para reducir la velocidad y detener el elevador, abrir las puertas, esperar, cerrar las puertas y acelerar a la velocidad nominal. </p><br><p>  Si el elevador tiene solo un bot贸n en el piso, entonces en el 99% de los casos funciona de acuerdo con el algoritmo de "descenso colectivo", y si hay 贸rdenes en la cabina, se detiene solo cuando se baja. </p><br><p>  Si tienes habilidades de programaci贸n en JS, entonces puedes intentar implementar un algoritmo de control similar en el juego en l铆nea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elevator Saga</a> .  Tiene todos los aspectos de optimizar los viajes sin profundizar en el hardcore, como la operaci贸n de los circuitos de seguridad de los ascensores. </p><br><p><img src="https://habrastorage.org/webt/pi/kj/ig/pikjigdf2mqsd2ptmjbtot-yd34.png"></p><br><p>  En mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas publico</a> materiales similares.  Ahora mismo puedes seguir el desarrollo del pr贸ximo dispositivo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459492/">https://habr.com/ru/post/459492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459480/index.html">Vivaldi: 驴C贸mo gana dinero el navegador?</a></li>
<li><a href="../459482/index.html">C贸mo derrotamos al 谩rbol de categor铆as</a></li>
<li><a href="../459484/index.html">Generaci贸n Arduino. Lo que inventan los estudiantes modernos</a></li>
<li><a href="../459488/index.html">Modos de juego especiales en el contexto de Roguelike</a></li>
<li><a href="../459490/index.html">Trucos sucios de vendedores de CRM: 驴comprar铆as un auto sin ruedas?</a></li>
<li><a href="../459494/index.html">C贸mo lanzar una creciente startup b2c despu茅s de un hackathon</a></li>
<li><a href="../459498/index.html">Slurm - Una manera f谩cil de entrar en un tema de Kubernetes</a></li>
<li><a href="../459500/index.html">HTML es la web</a></li>
<li><a href="../459502/index.html">Continuamos desarrollando una plataforma de aventura para los rusos: caracter铆sticas de interfaz y preferencias de verano.</a></li>
<li><a href="../459504/index.html">Curso para j贸venes dise帽adores de juegos: c贸mo contar el equilibrio de personajes y equipos sin matem谩ticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>