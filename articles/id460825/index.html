<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥ ğŸ„ ğŸ’Š Pengantar Screen Capture API - Memindai kode QR di browser ğŸ‘²ğŸ¾ ğŸ‘©ğŸ½â€ğŸ’» ğŸ˜‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Di artikel ini, kami menduga bahwa kami akan berbicara tentang Screen Capture API. API ini lahir pada tahun 2014, dan sulit untuk meny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Screen Capture API - Memindai kode QR di browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460825/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Di artikel ini, kami menduga bahwa kami akan berbicara tentang Screen Capture API.  API ini lahir pada tahun 2014, dan sulit untuk menyebutnya baru, tetapi dukungan browser masih sangat lemah.  Namun demikian, dapat digunakan untuk proyek pribadi atau di mana dukungan ini tidak begitu penting. </p><br><p>  Beberapa tautan untuk membantu Anda memulai: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi Screen Capture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Penggunaan MDN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demo</a> </li></ul><br><p>  Jika tautan dengan demo jatuh (atau jika Anda terlalu malas untuk pergi ke sana) - ini adalah bagaimana demo yang sudah selesai terlihat: </p><br><p><img src="https://habrastorage.org/webt/7i/3e/ue/7i3eueyergc9kkrarhti7oat5au.gif"></p><br><p>  Mari kita mulai. </p><a name="habracut"></a><br><h2 id="motivaciya">  Motivasi </h2><br><p> Baru-baru ini saya muncul dengan ide aplikasi web yang menggunakan kode QR dalam pekerjaannya.  Dan meskipun mereka biasanya nyaman untuk ditransmisikan, misalnya, tautan panjang di dunia nyata tempat Anda dapat mengarahkan telepon kepada mereka, di desktop itu sedikit lebih rumit.  Jika kode QR ada di layar perangkat yang sama dengan yang Anda butuhkan untuk membacanya, Anda perlu mengacaukan layanan untuk pengakuan atau mengenalinya dari telepon dan mentransfer data kembali ke PC.  Nyaman </p><br><p>  Beberapa produk, seperti <strong>1Password</strong> , menyertakan solusi menarik untuk situasi ini.  Jika Anda perlu mengatur akun dari kode QR, mereka membuka jendela transparan yang dapat Anda seret gambar dengan kode, dan itu dikenali secara otomatis.  Begini tampilannya: </p><br><p><img src="https://habrastorage.org/webt/we/m9/ty/wem9tytbuf_zm5kt4d8tlnyowga.png"></p><br><p>  Akan ideal jika kita dapat mengimplementasikan sesuatu yang serupa untuk aplikasi kita.  Tapi mungkin itu tidak akan berhasil di browser ... </p><br><h2 id="vstrechayte----getdisplaymedia">  Bertemu - getDisplayMedia </h2><br><p> Yah, hampir.  Di sini, Screen Capture API dengan satu-satunya metode <code>getDisplayMedia</code> akan <code>getDisplayMedia</code> .  <code>getDisplayMedia</code> seperti <code>getUserMedia</code> , hanya untuk layar perangkat, bukan kameranya.  Sayangnya, dukungan browser, seperti yang disebutkan di atas, jauh dari luasnya akses ke kamera.  Menurut MDN, ini dapat digunakan di Firefox, Chrome, Edge (meskipun ada di tempat yang salah - tepat di <code>navigator</code> , dan bukan di <code>navigator.mediaDevices</code> ) + Edge Mobile dan ... Opera untuk Android. </p><br><p>  Pilihan browser seluler yang cukup aneh di sebelah Big Two yang diharapkan. </p><br><p>  API itu sendiri sangat sederhana.  Ini berfungsi sama dengan <code>getUserMedia</code> , tetapi memungkinkan Anda untuk menangkap aliran video dari salah satu <strong>permukaan tampilan yang</strong> ditentukan: </p><br><ul><li>  dari <strong>monitor</strong> (seluruh layar), </li><li>  dari <strong>jendela</strong> atau semua jendela aplikasi tertentu, </li><li>  dari <strong>browser</strong> , atau lebih tepatnya dari dokumen tertentu.  Di Chrome, dokumen ini adalah tab terpisah, tetapi di FF tidak ada opsi seperti itu. </li></ul><br><p>  API Browser, yang memungkinkan Anda melihat di luar browser ... Kedengarannya biasa dan biasanya menjadi pertanda beberapa masalah, tetapi dalam hal ini bisa sangat nyaman.  Anda dapat mengambil gambar dari jendela lain dan, misalnya, mengenali dan menerjemahkan teks secara real time, seperti Google Translate Camera.  Yah, dan mungkin ada banyak kegunaan yang lebih menarik. </p><br><h2 id="sobiraem">  Kami mengumpulkan </h2><br><p>  Jadi, kami menemukan kemampuan yang diberikan API kepada kami.  Apa selanjutnya </p><br><p>  Dan kemudian kita perlu menyalip aliran video ini menjadi gambar yang bisa kita kerjakan.  Untuk melakukan ini, kami menggunakan elemen <code>&lt;video&gt;</code> , <code>&lt;canvas&gt;</code> dan beberapa JS lainnya. </p><br><p>  Tampilan dekat dari proses ini terlihat seperti ini: </p><br><ul><li>  Aliran langsung ke <code>&lt;video&gt;</code> ; </li><li>  Dengan frekuensi tertentu, gambarkan konten <code>&lt;video&gt;</code> di <code>&lt;canvas&gt;</code> ; </li><li>  Kumpulkan objek ImageData dari <code>&lt;canvas&gt;</code> menggunakan metode konteks <code>getImageData</code> 2D. </li></ul><br><p>  Keseluruhan prosedur ini mungkin terdengar sedikit aneh karena pipa yang begitu panjang, tetapi metode ini cukup populer dan digunakan untuk mengambil data dari webcam di <code>getUserMedia</code> . </p><br><p>  Menghilangkan semua yang tidak relevan, untuk memulai aliran dan mengeluarkan bingkai darinya, kita perlu tentang kode berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> video = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'video'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> displayMediaOptions = { <span class="hljs-attr"><span class="hljs-attr">video</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cursor</span></span>: <span class="hljs-string"><span class="hljs-string">"never"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">audio</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } video.srcObject = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> navigator.mediaDevices.getDisplayMedia(displayMediaOptions); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> videoTrack = video.srcObject.getVideoTracks()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { height, width } = videoTrack.getSettings(); context.drawImage(video, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.getImageData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); } <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> run();</code> </pre> <br><p>  Seperti yang disebutkan di atas: pertama-tama kita membuat elemen <code>&lt;video&gt;</code> dan <code>&lt;canvas&gt;</code> dan meminta kanvas untuk konteks 2D ( <code>CanvasRenderingContext2D</code> ). </p><br><p>  Kemudian kami mendefinisikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batasan / kondisi</a> aliran.  Tidak seperti stream dari kamera, ada beberapa di antaranya.  Kami mengatakan bahwa kami tidak ingin melihat kursor, dan bahwa kami tidak perlu audio.  Meskipun pada saat penulisan ini, pengambilan audio masih belum didukung oleh siapa pun. </p><br><p>  Setelah itu, kami menghubungkan aliran yang diterima dari tipe <code>MediaStream</code> ke elemen <code>&lt;video&gt;</code> .  Perhatikan bahwa <code>getDisplayMedia</code> mengembalikan Janji. </p><br><p>  Akhirnya, dari data yang diterima tentang aliran, kita ingat resolusi video untuk menggambarnya dengan benar di kanvas, menggambar bingkai dan menarik keluar objek ImageData dari <code>ImageData</code> . </p><br><p>  Untuk penggunaan penuh, Anda kemungkinan besar ingin memproses frame dalam satu lingkaran daripada satu kali.  Misalnya, saat Anda menunggu ketika gambar yang diinginkan muncul di bingkai.  Dan di sini beberapa kata perlu diucapkan. </p><br><p>  Ketika datang ke "menangani sesuatu di DOM dalam loop konstan," hal pertama yang terlintas dalam pikiran kemungkinan besar adalah <code>requestAnimationFrame</code> .  Namun, dalam kasus kami, menggunakannya tidak akan berhasil.  Masalahnya adalah bahwa ketika tab berhenti menjadi aktif - browser berhenti memproses loop rAF.  Dalam kasus kami, saat ini kami ingin memproses gambar. </p><br><p>  Dalam hal ini, alih-alih rAF, kami akan menggunakan <code>setInterval</code> lama yang baik.  Tetapi hal-hal yang tidak begitu mulus dengannya.  Dalam tab tidak aktif, interval antara operasi panggilan balik <em>setidaknya 1 detik</em> .  Namun demikian, ini cukup bagi kami. </p><br><p>  Akhirnya, ketika kita sampai ke frame, kita dapat memprosesnya sesuka kita.  Untuk keperluan demo ini, kami akan menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsQR</a> .  Ini sangat sederhana: input menerima <code>ImageData</code> , lebar dan tinggi gambar.  Jika gambar yang diterima memiliki kode QR, Anda akan mendapatkan objek JS dengan data yang dikenali kembali. <br>  Mari kita melengkapi contoh kita sebelumnya dengan hanya beberapa baris kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageData = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> run(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = jsQR(imageData.data, streamWidth, streamHeight);</code> </pre> <br><p>  Selesai! </p><br><h2 id="npm">  NPM </h2><br><p>  Saya berpikir bahwa kode utama di belakang contoh ini dapat dikemas ke dalam pustaka npm dan menghemat waktu dalam penggunaan awal untuk digunakan nanti.  Pustaka sangat sederhana, pada tahap ini ia hanya menerima panggilan balik ke mana <code>ImageData</code> akan dikirim, dan satu parameter tambahan adalah frekuensi pengiriman data.  Semua pemrosesan Anda perlu membawa sendiri.  Saya akan memikirkan apakah masuk akal untuk memperluas fungsinya. </p><br><p>  Perpustakaan disebut <code>stream-display</code> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NPM</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> . </p><br><p>  Penggunaannya dikurangi menjadi tiga baris kode dan panggilan balik: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callback = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">imageData</span></span></span><span class="hljs-function"> =&gt;</span></span> {...} <span class="hljs-comment"><span class="hljs-comment">// do whatever with those images const capture = new StreamDisplay(callback); // specify where the ImageData will go await capture.startCapture(); // when ready capture.stopCapture(); // when done</span></span></code> </pre> <br><p>  Demo dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ada juga versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodePen</a> untuk eksperimen cepat.  Kedua contoh menggunakan paket NPM di atas. </p><br><h2 id="nemnogo-o-testirovanii">  Sedikit tentang pengujian </h2><br><p>  Mengemas kode ini ke perpustakaan, saya harus memikirkan cara mengujinya.  Saya benar-benar tidak ingin menyeret 50MB Chrome tanpa kepala untuk menjalankan beberapa tes kecil di dalamnya.  Dan meskipun gagasan menulis bertopik untuk semua komponen tampak terlalu menyakitkan, pada akhirnya saya melakukannya. <br>  Sebagai pelari uji, <code>tape</code> dipilih.  Inilah yang akhirnya harus saya simulasikan: </p><br><ul><li>  objek <code>document</code> dan elemen DOM.  Untuk ini, saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsdom</a> ; </li><li>  beberapa metode jsdom yang kurang implementasi: <code>HTMLMediaElement#play</code> , <code>HTMLCanvasElement#getContext</code> dan <code>navigator.mediaDevices#getDisplayMedia</code> ; </li><li>  waktu.  Untuk melakukan ini, saya menggunakan <code>useFakeTimers</code> perpustakaan <code>useFakeTimers</code> , yang di bawah tenda memanggil <code>lolex</code> .  Ini mengatur penggantiannya ke <code>setInterval</code> , <code>requestAnimationFrame</code> dan banyak fungsi lain yang bekerja dengan waktu, dan juga memungkinkan Anda untuk mengontrol aliran waktu palsu ini.  Tapi hati-hati: Jsdom menggunakan berlalunya waktu di satu tempat proses inisialisasi, dan jika Anda menyalakan sinon pertama, semuanya akan membeku. </li></ul><br><p>  Saya juga menggunakan sinon untuk semua fungsi bertopik yang perlu dipantau.  Sisanya diimplementasikan oleh fungsi JS kosong. </p><br><p>  Tentu saja, Anda bebas memilih alat yang sudah Anda kenal.  Tapi, saya harap daftar ini memungkinkan Anda untuk mempersiapkannya terlebih dahulu, karena sekarang Anda tahu apa yang harus Anda tangani. </p><br><p>  Hasil akhirnya dapat dilihat di repositori perpustakaan.  Itu tidak terlihat terlalu cantik, tetapi berhasil. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Solusinya ternyata tidak seanggun jendela transparan yang disebutkan di awal artikel, tetapi mungkin web akan datang ke suatu hari nanti.  Orang hanya bisa berharap bahwa ketika browser belajar melihat melalui windows mereka - kemampuan ini akan dikontrol ketat oleh kami.  Sementara itu, ingatlah bahwa ketika Anda meraba-raba layar di Chrome - itu dapat diuraikan, direkam, dll.  Jadi jangan mencari-cari lebih dari yang diperlukan! </p><br><p>  Saya harap seseorang setelah artikel ini mempelajari trik baru untuk diri mereka sendiri.  Jika Anda memiliki ide untuk hal apa lagi ini dapat digunakan, tulis di komentar.  Dan sampai ketemu lagi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460825/">https://habr.com/ru/post/id460825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460813/index.html">Cara menggunakan diagram Voronoi untuk mengontrol AI</a></li>
<li><a href="../id460815/index.html">Menemukan perpustakaan vusb</a></li>
<li><a href="../id460819/index.html">WorldSkills: Ulasan dari peserta Olympiad</a></li>
<li><a href="../id460821/index.html">Intisari materi menarik untuk pengembang seluler # 307 (15-21 Juli)</a></li>
<li><a href="../id460823/index.html">Acara digital di Moskow dari 22 Juli hingga 28 Juli</a></li>
<li><a href="../id460827/index.html">Masalah PGP</a></li>
<li><a href="../id460831/index.html">Bahaya desainer</a></li>
<li><a href="../id460833/index.html">Fisika dan Ekonomi. Perbedaan gnoseologis dan manifestasinya dalam IT</a></li>
<li><a href="../id460837/index.html">Buku Pegangan Podcast Pemula</a></li>
<li><a href="../id460839/index.html">Peluncuran Predator - Repositori Data Terkompilasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>