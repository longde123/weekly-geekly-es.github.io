<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üë¥üèæ üë©üèº‚Äçüè´ Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 3: Desbordamientos del b√∫fer: exploits y protecci√≥n, parte 1 üôÅ üéÑ üë©üèø‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnolog√≠a de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas inform√°ticos". Nikolai Zeldovich, James Mickens. A√±o 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 3: Desbordamientos del b√∫fer: exploits y protecci√≥n, parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416839/"><h3>  Instituto de Tecnolog√≠a de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas inform√°ticos".  Nikolai Zeldovich, James Mickens.  A√±o 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementaci√≥n de sistemas inform√°ticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y t√©cnicas de seguridad basadas en trabajos cient√≠ficos recientes.  Los temas incluyen seguridad del sistema operativo (SO), caracter√≠sticas, gesti√≥n del flujo de informaci√≥n, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lecci√≥n 1: "Introducci√≥n: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 3: ‚ÄúDesbordamientos del b√∫fer: exploits y protecci√≥n‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Bienvenido a la conferencia sobre exploits para desbordamientos de b√∫fer.  Hoy terminaremos la discusi√≥n sobre los <b>l√≠mites</b> de <b>Baggy</b> y luego pasaremos a otros m√©todos de protecci√≥n de desbordamiento de b√∫fer. <br><br><img src="https://habrastorage.org/webt/oq/lp/5p/oqlp5prpdjjnr1e7sdxhtnp_pay.jpeg"><br><br>  A continuaci√≥n, hablaremos sobre los materiales impresos de la conferencia de hoy, que est√°n dedicados a la <b>Programaci√≥n orientada al retorno</b> a <b>ciegas (BROP)</b> : programaci√≥n orientada hacia atr√°s y ciega.  Esta es una t√©cnica de explotaci√≥n que puede llevarse a cabo incluso si el atacante no tiene el binario objetivo.  Estas haza√±as est√°n destinadas a destruir "canarios" en las pilas de sistemas de 64 bits.  Entonces, si eras como yo cuando le√≠ estos materiales por primera vez, deber√≠as haber sentido la pel√≠cula de Christopher Nolan.  ¬°Fue solo una explosi√≥n cerebral! <br><br>  Vamos a considerar c√≥mo funcionan estos gadgets correctamente.  Por lo tanto, espero que al final de la conferencia pueda comprender todas estas altas tecnolog√≠as descritas en los materiales de la conferencia.  Pero primero, como dije, terminaremos la discusi√≥n sobre los <b>l√≠mites</b> de <b>Baggy</b> .  Considere un ejemplo muy simple. <br><br>  Supongamos que vamos a asignar un puntero <b>p</b> y le asignaremos un tama√±o de 44 bytes.  Suponga tambi√©n que el tama√±o de la ranura es de 16 bytes. <br><br>  ¬øQu√© sucede cuando asignamos la funci√≥n <b>malloc</b> ?  Ya sabe que en este caso el sistema de <b>l√≠mites Baggy</b> intentar√° complementar esta distribuci√≥n con un logaritmo <b>2n</b> .  Entonces, para nuestro puntero de 44 bytes, se asignar√°n 64 bytes de memoria.  Pero el tama√±o de la ranura es de 16 bytes, por lo que crearemos 64/16 = 4 tablas de l√≠mites de 16 bytes cada una.  Cada una de estas entradas se colocar√° en el registro de distribuci√≥n de tama√±os. <br><br>  A continuaci√≥n, asigne otro puntero <b>char * q = p + 60</b> .  Vemos que este valor est√° fuera de l√≠mites porque el tama√±o de <b>p</b> es de 44 bytes, y aqu√≠ es de 60 bytes.  Pero <b>Baggy Limites</b> funciona para que en este caso no pase nada <b>malo</b> , aunque el programador no deber√≠a haberlo hecho. <br><br>  Ahora supongamos que lo siguiente que hacemos es asignar otro puntero, que ser√° igual a <b>char * r = q + 16</b> .  Ahora, esto realmente causar√° un error, porque el tama√±o de desplazamiento ser√° 60 + 16 = 76, que es 12 bytes m√°s grande que las 4 ranuras (4x16 = 64 bytes) que <b>asign√≥ el</b> sistema de <b>l√≠mites de Baggy</b> .  Y este exceso es realmente m√°s de la mitad de la ranura. <br><br><img src="https://habrastorage.org/webt/tr/dc/6t/trdc6tmpujijucydynnv2t5ojyw.jpeg"><br><br>  Si recuerda, en este caso, el sistema de <b>l√≠mites de Baggy</b> responder√° inmediatamente a un error cr√≠tico de sincronizaci√≥n, lo que har√° que el programa se bloquee y, de hecho, lo detenga. <br><br>  As√≠ que imaginemos que solo tenemos dos l√≠neas: <br><br>  <b>char * p = malloc (44)</b> <b><br></b>  <b>char * q = p + 60</b> <br><br>  Y no hay una tercera l√≠nea con el c√≥digo.  En cambio, haremos esto: <br><br>  <b>char * s = q + 8</b> <br><br>  En este caso, el puntero tendr√° un valor de 60 + 8 = 68 bits, que ser√°n 4 bytes m√°s que los l√≠mites asignados por los l√≠mites de <b>Baggy</b> .  De hecho, esto no causar√° un error cr√≠tico, aunque el valor va m√°s all√° de los l√≠mites.  Lo que hicimos aqu√≠ es establecer un bit de orden superior para el puntero.  Entonces, si alguien intenta desreferenciarlo posteriormente, esto conducir√° a un error cr√≠tico en este punto. <br><br><img src="https://habrastorage.org/webt/xp/i-/p-/xpi-p-rmy0hsdh3f53yw6qrtb0o.jpeg"><br><br>  Y lo √∫ltimo que haremos es asignar otro puntero: <br><br>  <b>char * t = s - 32</b> <br><br>  De hecho, hicimos esto: devolvimos el puntero al borde.  Entonces, si inicialmente <b>s</b> fue m√°s all√°, ahora lo hemos devuelto al volumen originalmente asignado que creamos para el puntero.  Por lo tanto, ahora <b>t</b> no tendr√° un bit de orden superior en su composici√≥n, y puede desreferenciarse f√°cilmente. <br><br><img src="https://habrastorage.org/webt/27/2g/y6/272gy657iydta1tibemfmgqhcxe.jpeg"><br><br>  <b>Audiencia:</b> ¬øc√≥mo sabe el programa que <b>r</b> tiene un exceso mayor que la mitad de la pila? <br><br>  <b>Profesor Mickens:</b> tenga en cuenta que cuando creamos <b>r</b> , obtuvimos un c√≥digo de herramienta que funcionar√° en todas estas operaciones con punteros.  Entonces podemos decir d√≥nde se ubicar√° <b>q</b> , y sabemos que est√° dentro de los <b>l√≠mites de Baggy</b> .  Por lo tanto, cuando realizamos esta operaci√≥n <b>q + 16</b> , las herramientas de <b>l√≠mites de Baggy</b> saben de d√≥nde proviene este valor inicial.  Y luego, si se <b>produce</b> un desplazamiento de este tama√±o original, los <b>l√≠mites holgados</b> determinar√°n f√°cilmente que el desplazamiento es mayor que la mitad del tama√±o de la ranura. <br><br>  En principio, cuando realiza operaciones con punteros, debe observar si exceden el tama√±o asignado o no.  En alg√∫n momento, tiene un puntero ubicado dentro de los l√≠mites de los l√≠mites de <b>Baggy</b> , y luego sucede algo que lo hace ir m√°s all√° de los l√≠mites.  Entonces, justo cuando esto sucede, descubriremos que alg√∫n tipo de crochet "sali√≥" de nuestro c√≥digo. <br><br>  Espero que esto sea comprensible.  Fue una descripci√≥n muy breve de la tarea, pero espero que puedan entenderla f√°cilmente. <br><br>  Entonces, tenemos un puntero que se ve as√≠: <br><br>  <b>char * p = malloc (256)</b> , luego agregamos el puntero <b>char * q = p + 256</b> , despu√©s de lo cual intentaremos desreferenciar este puntero. <br><br>  Entonces, ¬øqu√© pasar√°?  Bueno, tenga en cuenta que 256 es una secuencia <b>2n</b> , por lo que estar√° dentro de los <b>l√≠mites de Baggy</b> .  Por lo tanto, cuando agregamos otros 256 bits, esto significa que hacemos otro pase al final de los <b>l√≠mites</b> de los <b>l√≠mites de Baggy</b> .  Como en el ejemplo anterior, esta l√≠nea es lo suficientemente buena, pero lleva al hecho de que se establecer√° un bit de orden superior para <b>q</b> .  Por lo tanto, cuando tratamos de desreferenciarlo, todo explotar√° y tendr√° que llamar a nuestro agente de seguros.  ¬øEso est√° claro? <br><br><img src="https://habrastorage.org/webt/mk/oe/hn/mkoehn3hnwp9d100bt_wre7a2xg.jpeg"><br><br>  A partir de estos 2 ejemplos, puede comprender c√≥mo funciona el sistema de <b>l√≠mites Baggy</b> .  Como mencion√© en la √∫ltima conferencia, realmente no necesita instrumentar cada operaci√≥n de puntero si puede usar el an√°lisis de c√≥digo est√°tico para descubrir que un conjunto espec√≠fico de operaciones de puntero es seguro.  Pospondr√© m√°s discusiones sobre algunos an√°lisis est√°ticos, pero basta con decir que no siempre es necesario realizar estas acciones matem√°ticas, ya lo hemos verificado antes. <br><br>  Otra pregunta que se menciona en Piazza: c√≥mo garantizar la compatibilidad de los <b>l√≠mites</b> de <b>Baggy</b> con bibliotecas anteriores sin herramientas.  La idea es que cuando los <b>l√≠mites de Baggy</b> inicializan las tablas de borde, establecen que todos los registros deben estar dentro de los 31 bits.  Por lo tanto, cuando leemos la tabla de l√≠mites, cada registro en ella representa un valor de la forma <b>2n + 31</b> .  Por lo tanto, al inicializar los l√≠mites iniciales de tama√±o de 31 bits, suponemos que cada puntero tendr√° el tama√±o m√°ximo posible de <b>2n + 31</b> .  D√©jame darte un ejemplo muy simple que aclarar√° esto. <br><br>  Supongamos que tenemos un espacio de memoria que usamos para un mont√≥n.  Este espacio de memoria est√° formado por dos componentes.  En la parte superior, tenemos un mont√≥n que se ha asignado utilizando un c√≥digo que no es de herramientas, y debajo hay un mont√≥n que se ha asignado con un c√≥digo de herramienta.  Entonces, ¬øqu√© har√°n los <b>l√≠mites de Baggy</b> ?  Como recordar√°, este sistema tiene el concepto de una ranura, cuyo tama√±o es de 16 bits.  Por lo tanto, la tabla de l√≠mites constar√° de 2 secciones, iniciadas desde 31 bits. <br><br>  Sin embargo, al ejecutar el c√≥digo de la herramienta, en realidad usar√° el algoritmo de <b>l√≠mites de Baggy</b> para establecer los valores apropiados para esta fila de la tabla. <br><br><img src="https://habrastorage.org/webt/vu/bp/wb/vubpwbtkublhjc6ay3ytcek6j-y.jpeg"><br><br>  Cuando un puntero proviene de la parte superior del espacio de memoria, siempre se establece en los l√≠mites m√°ximos posibles de <b>2n + 31</b> .  Esto significa que los <b>l√≠mites de Baggy</b> nunca considerar√°n que una operaci√≥n de puntero que ha "venido" de una biblioteca sin herramientas puede ir m√°s all√° de los l√≠mites. <br><br>  La idea es que en el c√≥digo de la herramienta, siempre realizaremos estas comparaciones para los punteros, pero si establecemos los l√≠mites de escritura del puntero para un c√≥digo que no sea una herramienta de la forma <b>2n + 31</b> , entonces nunca tendremos un error de desreferencia.  Es decir, tenemos una buena interacci√≥n entre las <b>entradas de</b> c√≥digo de <b>l√≠mites de Baggy</b> y los registros no instrumentales de bibliotecas anteriores. <br><br>  Esto significa que tenemos este sistema, lo cual es bueno, porque no bloquea el programa cuando se usan bibliotecas que no son herramientas, pero tiene un problema.  El problema es que nunca podemos determinar los l√≠mites de los punteros generados por c√≥digo que no es una herramienta.  Debido a que nunca estableceremos un bit de orden superior cuando, por ejemplo, este puntero tenga demasiado o muy poco espacio.  Por lo tanto, en realidad no podemos garantizar la seguridad de la memoria para las operaciones que se producen al usar c√≥digo no instrumental.  Tampoco puede determinar cu√°ndo pasamos un puntero que ha ido m√°s all√° de los l√≠mites de tama√±o del c√≥digo instrumental al c√≥digo no instrumental.  En este caso, algo inimaginable puede suceder.  Si tiene un puntero extra√≠do del c√≥digo de la herramienta, entonces tiene un bit de alto orden establecido en 1. Por lo tanto, parece que tiene dimensiones gigantescas. <br><br>  Sabemos que si acabamos de colocar este c√≥digo en el c√≥digo de la herramienta, podemos borrar esta bandera en algunos puntos cuando vuelva a los bordes.  Pero si solo pasamos esta gran direcci√≥n al c√≥digo no instrumental, entonces puede hacer algo inimaginable.  Incluso puede devolver este puntero a los l√≠mites, pero nunca tendremos la oportunidad de borrar este bit de orden superior.  Entonces todav√≠a podemos tener problemas incluso cuando usamos el circuito que se muestra aqu√≠. <br><br>  <b>P√∫blico:</b> si tenemos c√≥digo de herramienta para asignar memoria, ¬øutiliza la misma funci√≥n <b>malloc</b> que usa el c√≥digo de atributo? <br><br>  <b>Profesor:</b> Esta es una pregunta un poco delicada.  Si consideramos el caso aqu√≠, esto se observa estrictamente, ya que tenemos dos √°reas de memoria, cada una de las cuales obedece las reglas establecidas para ello.  Pero, en principio, depender√° del c√≥digo que use el lenguaje de programaci√≥n seleccionado.  Imagine que en C ++, por ejemplo, puede asignar su propio calificador.  Por lo tanto, depende de ciertos detalles del c√≥digo. <br><br>  <b>Audiencia:</b> ¬øc√≥mo puede verificar el calificador si el l√≠mite est√° establecido en 31 bits o no? <br><br>  <b>Profesor:</b> en los niveles inferiores, los algoritmos de distribuci√≥n funcionan de modo que cuando se llama a un sistema desconocido, el puntero se mueve hacia arriba.  Entonces, si tiene varios asignadores, entonces todos tratan de asignar memoria, cada uno de ellos tiene su propia pieza de memoria, que se reservan para ellos, b√°sicamente, correctamente.  Por lo tanto, en la vida real puede estar m√°s fragmentado que a un alto nivel. <br><br>  Entonces, todo lo que examinamos anteriormente se relacion√≥ con la operaci√≥n de los <b>l√≠mites</b> de <b>Baggy</b> en sistemas de 32 bits.  Considere lo que sucede cuando se usan sistemas de 64 bits.  En tales sistemas, puede deshacerse de la tabla de l√≠mites, porque podemos almacenar informaci√≥n sobre los l√≠mites en el puntero. <br><br>  Considere c√≥mo se ve un puntero regular en los l√≠mites holgados.  Consta de 3 partes.  Se asignan 21 bits para la primera parte, cero, se asignan otros 5 bits para el tama√±o, este es el tama√±o principal del registro, y otros 38 son los bits de la direcci√≥n habitual. <br><br><img src="https://habrastorage.org/webt/gb/r5/6m/gbr56manocplt3wn7ueqgoxpcne.jpeg"><br><br>  La raz√≥n por la cual esto no limita masivamente el tama√±o de la direcci√≥n del programa que est√° utilizando es que la mayor√≠a de los bits de alto orden del sistema operativo y / o equipo ubicados en las primeras 2 partes del puntero no permiten que la aplicaci√≥n se use por varias razones.  Entonces, result√≥ que no estamos reduciendo en gran medida el n√∫mero de aplicaciones utilizadas en el sistema.  As√≠ es como se ve un puntero regular. <br><br>  ¬øQu√© sucede cuando solo tenemos uno de estos punteros?  Bueno, en un sistema de 32 bits, todo lo que podemos hacer es establecer un bit de alto orden y esperamos que esto nunca tenga m√°s de la mitad del tama√±o de la ranura.  Pero ahora que tenemos todo este espacio de direcciones adicional, puede colocar el desplazamiento fuera de los bordes OOB (fuera del l√≠mite) directamente en este puntero.  Entonces podemos hacer algo como lo que se muestra en la figura, dividiendo el puntero en 4 partes y redistribuyendo su tama√±o. <br><br>  Por lo tanto, podemos obtener 13 bits para los l√≠mites de desplazamiento, es decir, escribir qu√© tan lejos estar√° este puntero OOB de donde deber√≠a estar.  Por otra parte, puede establecer el tama√±o real del objeto indicado aqu√≠ como 5, y el resto de la parte cero, que ahora ser√° 21-13 = 8 bits.  Y luego sigue nuestra direcci√≥n parte de 38 bits.  En este ejemplo, ver√° las ventajas de usar sistemas de 64 bits. <br><br><img src="https://habrastorage.org/webt/vx/ja/mp/vxjamp6bu-jxmc5xfrslev98o-s.jpeg"><br><br>  Tenga en cuenta que aqu√≠ tenemos el tama√±o habitual para un puntero regular, en ambos casos este tama√±o es de 64 bits y su descripci√≥n es elemental.  Y esto es bueno, porque al usar punteros "gruesos", necesitar√≠amos muchas palabras para describirlos. <br>  Tambi√©n noto que el c√≥digo que no es herramienta se puede aplicar f√°cilmente aqu√≠, porque funciona y usa el mismo tama√±o que los punteros regulares.  Podemos poner estas cosas en una <b>estructura</b> , por ejemplo, y el tama√±o de esta <b>estructura no</b> cambiar√°.  Esto es muy bueno cuando tenemos la oportunidad de trabajar en un mundo de 64 bits. <br><br>  <b>P√∫blico:</b> ¬øpor qu√© en el segundo caso el desplazamiento se ubica delante del tama√±o, y no como en el caso anterior, y qu√© suceder√° si el tama√±o del desplazamiento es grande? <br><br>  <b>Profesor:</b> Creo que en algunos casos tenemos ciertos problemas limitantes en los que tendremos que trabajar.  Por ejemplo, se producir√° un problema si hay m√°s bits.  Pero b√°sicamente, no creo que haya una raz√≥n por la que no puedas leer algunas de estas cosas.  A menos que ciertas condiciones estrictas, en las que no pienso ahora, deber√≠an haber estipulado el tama√±o de la parte cero, de lo contrario podr√≠a haber problemas con el hardware. <br><br>  Entonces, a√∫n puede iniciar un desbordamiento de b√∫fer en el sistema de <b>l√≠mites Baggy</b> , ya que la aplicaci√≥n de los enfoques anteriores no resuelve todos los problemas, ¬øverdad?  Otro problema que puede encontrar si tiene un c√≥digo no instrumental, porque no podremos detectar ning√∫n problema en el c√≥digo no instrumental.  Tambi√©n puede encontrar vulnerabilidades de memoria que surgen de un sistema din√°mico de asignaci√≥n de memoria.  Si recuerdas, en una conferencia anterior vimos este extra√±o puntero para <b>liberar malloc</b> , y los <b>l√≠mites holgados</b> no pudieron evitar la ocurrencia de tales cosas. <br><br>  Tambi√©n discutimos en la √∫ltima conferencia el hecho de que los punteros de c√≥digo no tienen l√≠mites asociados con ellos.  Supongamos que tenemos una estructura en la que el b√∫fer de memoria se encuentra en la parte inferior y el puntero en la parte superior, y el b√∫fer se desborda.  Suponemos que el desbordamiento del b√∫fer todav√≠a est√° dentro de los <b>l√≠mites de Baggy</b> .  Entonces debe redefinir este puntero de funci√≥n.  De lo contrario, si intentamos usarlo, puede enviarse a un c√≥digo malicioso para atacar una parte controlada de la memoria.  Y en este caso, los l√≠mites no nos ayudar√°n, porque no tenemos bordes asociados, asociados con estos punteros de funci√≥n. <br><br>  Entonces, ¬øcu√°l es el precio de usar <b>l√≠mites holgados</b> ?  De hecho, solo tenemos 4 componentes de este precio. <br><br><img src="https://habrastorage.org/webt/2v/vo/c0/2vvoc00hrhpzj90khybubng8zsa.jpeg"><br><br>  El primero es el espacio.  Porque si usa un puntero "grueso", entonces es obvio que debe agrandar los punteros.  Si est√° utilizando el sistema de <b>l√≠mites holgados del</b> que acabamos de hablar, debe guardar una tabla de borde.  Y esta tabla tiene un tama√±o de ranura que le permite controlar qu√© tan grande ser√° esta tabla hasta que agote las posibilidades de la memoria asignada para ella. <br><br>  Adem√°s, tambi√©n aument√≥ la carga en la CPU, que se ve obligada a realizar todas estas operaciones instrumentales con punteros.  Dado que para cada uno o casi todos los punteros es necesario verificar los l√≠mites utilizando los mismos modos de operaci√≥n, lo que ralentizar√° la ejecuci√≥n de su programa. <br><br>  Tambi√©n hay un problema con las falsas alarmas.  Ya hemos discutido lo que podr√≠a pasar si un programa genera punteros que van m√°s all√° de los l√≠mites, pero nunca intenta desreferenciarlos.  Estrictamente hablando, esto no es un problema.  <b>Los l√≠mites holgados</b> marcar√°n estos indicadores "fuera de <b>l√≠mites</b> " si van m√°s all√° de la mitad del tama√±o de la ranura, al menos en la soluci√≥n de 32 bits. <br><br>  Lo que ver√° en la mayor√≠a de las herramientas de seguridad es que las falsas alarmas reducen la probabilidad de que las personas usen estas herramientas.  Porque en la pr√°ctica, todos esperamos que nos preocupemos por la seguridad, pero ¬øqu√© es lo que realmente emociona a las personas?  Quieren poder subir sus est√∫pidas fotos a Facebook, quieren acelerar el proceso de carga, etc.  Por lo tanto, si realmente desea que sus herramientas de seguridad tengan demanda, deber√≠an tener cero falsas alarmas.  Intentar capturar todas las vulnerabilidades generalmente conduce a falsas alarmas, lo que molestar√° a los desarrolladores o usuarios. <br><br>  Tambi√©n genera gastos improductivos que necesita soporte del compilador.  Debido a que debe agregar todas las herramientas al sistema, omitiendo la verificaci√≥n del puntero, y as√≠ sucesivamente. <br><br>  Entonces, para usar el sistema de <b>l√≠mites Baggy</b> tenemos que pagar un precio, que consiste en un uso excesivo de espacio, un aumento en la carga de la CPU, falsas alarmas y la necesidad de usar un compilador. <br><br>  Esto <b>concluye la</b> discusi√≥n de los <b>l√≠mites</b> de <b>Baggy</b> . <br><br>  Ahora podemos pensar en otras dos estrategias de mitigaci√≥n de desbordamiento de b√∫fer.  De hecho, son mucho m√°s f√°ciles de explicar y comprender. <br><br>  Uno de estos enfoques se llama <b>memoria no ejecutable</b> .  Su idea principal es que el hardware de intercambio indicar√° 3 bits de <b>R</b> , <b>W</b> y <b>X</b> (lectura, escritura y ejecuci√≥n) para cada p√°gina que tenga en la memoria.       ,   ,  .  2  ,     ,  ,  ,    . <br><br>     ,     .     ,  ,      ,    ,     -   .    ,  .   ¬´ <b>W</b>  <b>X</b> ¬ª ,       ,      ,     ,       ,   .     ,       ,      .        .  ,        ,     .    ? <br><br>     -   ,         .    ,     .     ,       ,    . <br><br>    ,       ,   ,       ,      .      ,           ,      .     . <br><br>     ,        .     ‚Äì  <b>just-in-time</b> ,      . <br><br>       -,    JavaScript    .    JavaScript,      ,    -   - ¬´¬ª , - ¬´¬ª ,       x86    .    ,         . <br>      . ,  ,    <b>just-in-time</b>    <b>W</b> ,       <b>X</b> .     ,        ,    . <br><br>        ‚Äî       .  ,  ,      ,    . <br><br><img src="https://habrastorage.org/webt/f_/xj/xi/f_xjxihqdru85yadpa__ytdao-4.jpeg"><br><br> ,   ,       .     GDB,         ,        .  ,       .      ,      .       . <br><br> ,      .  ,           ,     ,   ,    ,     . <br><br>     : , ,   ‚Äî     .    ,  ,    ,    ,   , , , -   .           ,     ,  . <br><br> ,    ,           ,     GDB  ,     ,         ,       ,     .        . <br>  ,    ,    ,   ,       .    -   ,    - ,        .        ,      .       ,     ,           . <br><br>    ,      ? ,  .      ,    ,               .    ,    ,    ,  ,  -    ,          . <br><br> 27:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Curso MIT "Seguridad de sistemas inform√°ticos".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 3: ¬´ :   ¬ª,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>  Gracias por quedarte con nosotros.  ¬øTe gustan nuestros art√≠culos?  ¬øQuieres ver m√°s materiales interesantes?  <b>Ap√≥yenos</b> haciendo un pedido o recomend√°ndolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un an√°logo √∫nico de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o c√≥mo dividir el servidor?</a>  (las opciones est√°n disponibles con RAID1 y RAID10, hasta 24 n√∫cleos y hasta 40GB DDR4). <br><br>  <b>Dell R730xd 2 veces m√°s barato?</b>  ¬°Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Pa√≠ses Bajos y los Estados Unidos!</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416839/">https://habr.com/ru/post/es416839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416827/index.html">Contenedores para adultos (Parte 02): una gu√≠a pr√°ctica de terminolog√≠a</a></li>
<li><a href="../es416829/index.html">Modelo de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../es416831/index.html">El enrutamiento externo del tr√°fico dom√©stico ruso se reducir√° al 5%</a></li>
<li><a href="../es416833/index.html">Bienvenido a MskDotNet Meetup # 24</a></li>
<li><a href="../es416837/index.html"># Dashanalune 0</a></li>
<li><a href="../es416841/index.html">C√≥mo probar hip√≥tesis y ganar dinero en Swift usando pruebas divididas</a></li>
<li><a href="../es416843/index.html">Motores de cohetes nucleares y sistemas de propulsi√≥n el√©ctrica de cohetes nucleares.</a></li>
<li><a href="../es416845/index.html">10 razones para usar rastrearlo o abandonarlo para siempre</a></li>
<li><a href="../es416847/index.html">El sitio de administraci√≥n de Ammyy nuevamente comprometido</a></li>
<li><a href="../es416849/index.html">Oh mi c√≥digo C√≥mo convertirse en administrador del sistema</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>