<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è üé´ üëàüèø C ++ vs C # ü§∞üèΩ üèΩ üê±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todo mundo sabe que n√£o h√° nada mais est√∫pido do que argumentar "qual idioma √© melhor". Por exemplo, melhor para qu√™? Idiomas diferentes s√£o bem-suced...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vs C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br>  Todo mundo sabe que n√£o h√° nada mais est√∫pido do que argumentar "qual idioma √© melhor".  Por exemplo, melhor para qu√™?  Idiomas diferentes s√£o bem-sucedidos em nichos diferentes - e √© in√∫til tirar conclus√µes definitivas sem considerar isso. <br><br>  Mas o que acontece se voc√™ recorrer a especialistas experientes que compreendem tudo isso e pedir que organizem o C ++ vs C # holivar?  Acontece que voc√™ pode descobrir muitos detalhes interessantes.  A palavra "plataforma cruzada" pode ser aplicada de ambas as formas nos dois idiomas, mas o que isso significa na pr√°tica?  O C ++ est√° se desenvolvendo ativamente agora?  C # j√° quebrou a compatibilidade com vers√µes anteriores?  As respostas podem ser √≥bvias para aqueles que j√° est√£o profundamente imersos nos dois idiomas ao mesmo tempo, mas existem poucas pessoas - e todo mundo aprender√° algo novo. <br><br>  De C ++, <b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">sermp</a> Platonov</b> , Presidente do Comit√™ de Programa da Confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ na R√∫ssia</a> , participou.  O lado do C # foi representado por <b>Anatoly Kulakov</b> - ele est√° inclu√≠do no PC da confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext</a> e entre os l√≠deres do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNetRu</a> .  E o l√≠der da discuss√£o, na vida em que esses dois mundos coexistem, era <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">mezastel</a> Nesteruk</b> . <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>Dmitry:</b> Boa tarde, colegas.  Bem-vindo a reuni√µes informais sobre o tema das linguagens de programa√ß√£o.  Na Internet, somos constantemente lembrados de que idiomas n√£o podem ser comparados.  E hoje faremos exatamente o que voc√™ n√£o pode fazer: compare C ++ com C # e .NET, seus pr√≥s e contras.  Apresente-se, por favor. <br><br>  <b>Anatoly:</b> Meu nome √© Anatoly, e hoje vou me afogar em C #, porque tenho estudado esse idioma desde suas primeiras vers√µes e, ao que parece, sei tudo sobre ele. <br><br>  <b>Sergey:</b> Ol√°, meu nome √© Sergey, hoje vou me afogar em C ++.  Dima disse corretamente que compararemos os pr√≥s e os contras.  Todo mundo chama de "profissionais", sabe-se que, na verdade, o C # nesta discuss√£o ser√° um sinal de menos.  Est√° certo, Anatoly? <br><br>  <b>Anatoly:</b> C # tem mais duas vantagens!  Portanto, acho que esse √© um desenvolvimento evolutivo das vantagens que j√° s√£o obsoletas e n√£o s√£o capazes de competir em praticamente qualquer lugar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2>  Educa√ß√£o </h2><br>  <b>Dmitry:</b> Eu tenho o primeiro t√≥pico para a nossa discuss√£o.  Imagine que os novos estudantes venham para a universidade, eles precisam do primeiro idioma.  Qual voc√™ acha que deveria ser o primeiro idioma que as pessoas aprendem no primeiro ano: C ++, C # ou assembler em geral? <br><br>  <b>Sergey:</b> Eu ensinei por algum tempo, ent√£o tenho uma opini√£o estabelecida.  Entendo que aqui vamos discutir qual linguagem √© melhor e defendo C ++ ... Mas, para aprender C ++, voc√™ precisa entender a arquitetura do computador.  E com isso, o grande problema de ensinar os alunos (pelo menos na universidade onde lecionei).  E para ensinar algoritmos e outras coisas, voc√™ provavelmente precisar√° de algo que n√£o se concentre na infraestrutura, na pr√≥pria linguagem.  Aqui, Eiffel foi uma tentativa de fazer isso, mas tamb√©m h√° muita m√°gica.  Portanto, eu diria que nenhum dos nossos dois idiomas √© adequado. <br><br>  A programa√ß√£o √© diferente, e n√£o √© a ‚Äúprograma√ß√£o‚Äù que ensina, mas algoritmos, estruturas de dados e assim por diante.  √â poss√≠vel que fa√ßa sentido escolher seu pr√≥prio instrumento em cada assunto.  Entenda algum tipo de estrutura de dados Lisp.  E o C ++, portanto, deve ser dado depois que os alunos entenderem algo sobre arquitetura.  E ent√£o ser√° poss√≠vel entender por que toda essa dor e sofrimento.  Eu nem vou argumentar que as vantagens s√£o sobre dor. <br><br>  <b>Anatoly:</b> Sim, concordo plenamente que voc√™ precisa separar objetos e n√£o coloc√°-lo em "programa√ß√£o" e martelar tudo em um idioma.  Mas se voc√™ chegar ao ponto em que aprendeu o b√°sico, os fundamentos, os algoritmos e come√ßar a escolher algum tipo de linguagem industrial, √© claro que o C # ser√° muito melhor.  Porque isso n√£o for√ßa voc√™ a aprender tudo isso no n√≠vel de arquiteturas, bytes de mem√≥ria e outros "p√¥r do sol √† m√£o".  Ele fornece uma linguagem imediatamente compreens√≠vel, sintaxe simples e, nesse idioma, do primeiro ou do segundo ano, voc√™ pode ganhar dinheiro bastante tang√≠vel. <br><br>  <b>Dmitry:</b> H√° um argumento de que n√£o dar aos alunos iniciantes algumas coisas como ponteiros √© algum tipo de sacril√©gio.  Eles ter√£o um enorme buraco se uma pessoa n√£o entender que, por exemplo, um link √© realmente apenas o endere√ßo de uma vari√°vel na mem√≥ria.  O que voc√™ acha disso? <br><br>  <b>Anatoly:</b> 20 anos atr√°s, isso era verdade quando os computadores n√£o tinham mem√≥ria suficiente, discos insuficientes e outras coisas.  Agora, observe esses javascripts, eles arrastam 500 megabytes de bibliotecas para cada "ol√° mundo".  Quanto eles levam na mem√≥ria?  Qual √© o desempenho deles?  Quais s√£o os links a√≠?  Sim, ningu√©m liga.  O principal √© rolar e liberar rapidamente algo na produ√ß√£o.  N√£o afirmo que seja um caminho bom ou correto, afirmo que √© necess√°rio mudar junto com as realidades.  Talvez agora n√£o seja t√£o importante quanto o seu link leva. <br><br>  <b>Sergey:</b> Provavelmente dependendo de onde.  Dmitry, pelo que entendi, estava interessado em negocia√ß√£o algor√≠tmica - posso imaginar vividamente como ele puxa bibliotecas em JS para enviar um pedido √† central. <br><br>  <b>Dmitry:</b> Bem, sim, √© claro, na pr√°tica ningu√©m usa idiomas desse tipo l√°.  Embora teoricamente isso seja poss√≠vel: n√£o vamos esquecer que dinheiro fraco n√£o est√° sendo jogado na infraestrutura do JS.  Mecanismos que transformam a compila√ß√£o JS em tudo e qualquer coisa.  Muitos consideram esse idioma como o idioma de primeira classe para tudo em geral. <br><br>  Naturalmente, a negocia√ß√£o de algo √© agora uma disciplina remota de tal disciplina, mas a negocia√ß√£o de algo e a matem√°tica financeira como um todo geralmente s√£o uma √°rea espec√≠fica.  Apenas predomina C ++.  E predomina em parte devido √† in√©rcia, simplesmente por raz√µes hist√≥ricas: no come√ßo todos estavam em C ++, e essa √°rea √© conservadora. <br><br>  <b>Sergey:</b> Eu n√£o concordo.  Agora trabalho na fintech, e colegas que est√£o aqui desde o in√≠cio do com√©rcio algor√≠tmico falam sobre grandes empresas que escreveram pela primeira vez em Java.  No in√≠cio, o Java lidou com a negocia√ß√£o algor√≠tmica, mas quando o mercado come√ßou a crescer e os concorrentes com C ++ apareceram, em algum momento eles simplesmente n√£o conseguiram, n√£o conseguiram fazer tudo com efici√™ncia ... Portanto, nem todos na negocia√ß√£o algor√≠tmica come√ßaram com C ++.  Apenas aqueles que n√£o escreveram morreram.  Uma sele√ß√£o t√£o natural. <br><br>  <b>Dmitry:</b> Na verdade, voc√™ pode ampli√°-lo.  Existem muitos exemplos em que bancos grandes mant√™m seus algoritmos em um documento do Excel.  Eles tamb√©m usam o Excel como servidor para calcular tudo isso.  Existem freios infernais, mas tudo depende se voc√™ est√° negociando em alta frequ√™ncia (ou geralmente em alta frequ√™ncia).  Se voc√™ √© um formador de mercado, √© natural que voc√™ precise de alto desempenho, e a√≠ o neg√≥cio n√£o se limita nem ao C ++, ent√£o vamos para as linguagens de hardware e HDL. <br><br>  Mas nossa discuss√£o n√£o √© apenas sobre negocia√ß√£o algor√≠tmica, mas tamb√©m sobre coisas simples.  Aqui eu dou um exemplo.  Em conex√£o com a constru√ß√£o, eu precisava escrever v√°rias pequenas aplica√ß√µes calculando coisas diferentes: por exemplo, como colocar tijolos ao redor do contorno de uma casa.  E mal consigo imaginar como fazer essas coisas em C ++, porque tudo relacionado √† interface do usu√°rio √© mais fraco l√°.  Existe apenas uma estrutura, Qt, e at√© escrever sobre ela √© muito dif√≠cil.  E se eu me sentar em C #, em WinForms, ent√£o simplesmente instalei o aplicativo. <br><br>  <b>Anatoly:</b> Bem, a parte visual sempre foi uma for√ßa do C #.  A Microsoft investiu muito em moldes, e mesmo em moldes de plataforma cruzada, e em geral na visualiza√ß√£o.  Portanto, se estamos falando de aplicativos visuais para a √°rea de trabalho, parece-me que as vantagens geralmente est√£o muito, muito atr√°s. <br><br>  <b>Sergey:</b> Bem, depende, como sempre.  Eu realmente n√£o gosto de interface do usu√°rio, mas nos trunfos eu sempre tenho que fazer isso.  Parece trazer JS e apenas interagir com os profissionais.  Mas eu trabalhei com incorporado, e a√≠ √© dif√≠cil.  As pessoas compraram algum tipo de mecanismo r√°pido e caro, mas ainda n√£o conseguia lidar com a renderiza√ß√£o normal da interface do usu√°rio escrita em JS.  E depois de reescrever tudo isso no Qt, acabou fazendo overclock.  Hist√≥ria comum. <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2>  Plataforma cruzada vs plataforma cruzada </h2><br>  <b>Sergey:</b> Eu queria esclarecer aqui.  Eu n√£o sei muito sobre C #, eu mesmo o toquei h√° muito tempo, nas primeiras vers√µes (naquela √©poca eu estava com uma compatibilidade com vers√µes anteriores).  Portanto, a pergunta √©: ainda est√° sendo desenvolvido apenas pela Microsoft? <br><br>  <b>Anatoly:</b> N√£o, agora √© multiplataforma, aberta e verificada segundo a ISO (ECMA-334 e ISO / IEC 23270).  A prop√≥sito, at√© onde eu sei, o C ++ ainda n√£o possui uma especifica√ß√£o ISO aberta, apenas paga.  E o C #, por outro lado, √© completamente aberto.  Desenvolvido por muitas empresas (incluindo Google, Amazon e Samsung), temos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Foundation</a> .  Eu nem conhe√ßo um idioma mais aberto agora do que o C # e sua plataforma .NET. <br><br>  <b>Sergey:</b> Bem, Haskell. <br><br>  <b>Anatoly:</b> A prop√≥sito, o autor de Haskell trabalha na Microsoft Research e fez muitos esfor√ßos para fazer todo tipo de coisa interessante aparecer em C # - por exemplo, uma verifica√ß√£o est√°tica, algum tipo de reflex√£o com a qual voc√™ provavelmente nem sonha. <br><br>  <b>Sergey:</b> Eles podem sonhar, e at√© o trabalho est√° acontecendo nessa dire√ß√£o.  Mas √© claro que tudo tem seu pr√≥prio pre√ßo.  Em C ++, eles simplesmente se recusam a pagar esse pre√ßo. <br><br>  <b>Anatoly:</b> Qual?  Eles s√£o compilados por duas horas. Qual poderia ser o pre√ßo? <br><br>  <b>Sergey:</b> Em C ++, o princ√≠pio da abstra√ß√£o de custo zero.  Bem, isto √©, uma m√°quina virtual n√£o √© uma abstra√ß√£o de custo zero, certo?  Temos que aguentar isso. <br><br>  <b>Dmitry:</b> Bem, mas uma m√°quina virtual pode, por exemplo, obscurecer o c√≥digo para uma arquitetura espec√≠fica.  Enquanto em C ++, se eu usar a instru√ß√£o AVX em um computador sem AVX, meu processo ser√° encerrado.  Eu diria que esse argumento n√£o √© inteiramente correto, porque teoricamente - enfatizo teoricamente - o JIT pode fazer o que C ++ n√£o est√° dispon√≠vel.  Ou seja, otimiza√ß√£o no momento do lan√ßamento. <br><br>  <b>Sergey:</b> Mas em C ++, durante a compila√ß√£o, voc√™ pode controlar completamente as instru√ß√µes necess√°rias.  Nesse caso, voc√™ n√£o o controla com as m√£os, mas desiste do instrumento (compilador).  Olha, quais instru√ß√µes est√£o nessa arquitetura, que conjunto de instru√ß√µes ... <br><br>  <b>Dmitry:</b> Isso √© compreens√≠vel.  Mas voc√™ pode formul√°-lo desta maneira: como existem milh√µes de plataformas, nunca teremos nenhum tipo de ideal, porque n√£o podemos lan√ßar um milh√£o de vers√µes com diferentes sinalizadores de compila√ß√£o.  Certo?  Normalmente, lan√ßamos x86 e x64, mas n√£o dividimos tudo em alguns subgrupos. <br><br>  <b>Sergey:</b> Por que n√£o podemos?  S√©culo XXI.  Segure o Docker com par√¢metros diferentes, isso √© tudo. <br><br>  <b>Dmitry:</b> Quando temos um cliente final que baixa nosso aplicativo, ele deseja baixar um bin√°rio espec√≠fico.  E neste bin√°rio, o melhor que podemos fazer √© ficar em todos os lugares se.  Como "se cpuid √© assim e o suporte avx √© assim, ent√£o usamos a vers√£o 25 do algoritmo".  Como resultado, precisamos de 25 vers√µes diferentes do mesmo algoritmo, porque a acelera√ß√£o depende das plataformas, depende da plataforma. <br><br>  <b>Sergey:</b> Eu provavelmente concordo.  Para ser sincero, nunca criei um produto n√£o interno.  Estou principalmente em empresas que usam seus produtos. <br><br>  <b>Dmitry:</b> Bem, √© claro, a melhor op√ß√£o √© quando voc√™ conhece previsivelmente a arquitetura.  Nesse caso, a rigor, ningu√©m obriga a usar as instru√ß√µes x86.  Voc√™ pode pegar um cart√£o espec√≠fico (por exemplo, Nvidia Tesla) e fazer o que quiser.  Essa √© a minha abordagem tamb√©m, eu controlo minha arquitetura.  Mas quando voc√™ toma decis√µes de mercado de massa para o usu√°rio ... Se voc√™ usa algum ReSharper condicional, ele n√£o pode simplesmente usar e usar a acelera√ß√£o da GPU para quaisquer √≠ndices arbitr√°rios.  Porque a acelera√ß√£o da GPU n√£o √© port√°til. <br><br>  <b>Sergey:</b> Na verdade, existem abordagens (agora voc√™ provavelmente n√£o precisa entrar em detalhes), existem pessoas interessantes (o autor da abordagem, ao que parece, agora tamb√©m mudou para a Microsoft).  Aqui em nossa confer√™ncia, no ano anterior, havia um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> sobre como escrever um programa desse tipo, que por si s√≥ entender√° o que √© onde (relativamente f√°cil, novamente, abstra√ß√µes de custo zero).  Para que voc√™ possa escolher rapidamente e, se for o caso, reconstruir corretamente o c√≥digo em um estilo CUDA ... <br><br>  <b>Dmitry:</b> Na verdade, a pr√≥pria CUDA est√° tentando resolver esse problema, porque na CUDA existe uma certa camada intermedi√°ria de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PTX</a> que lida com isso.  Mas isso ainda √© muito dif√≠cil, porque o ferro est√° mudando radicalmente evolutivamente e √© muito dif√≠cil acompanh√°-lo.  E se observarmos o uso da acelera√ß√£o de GPU, por exemplo, nos produtos da Adobe, eles usam uma se√ß√£o muito restrita das tecnologias dispon√≠veis.  Se o seu cart√£o estiver correto - ent√£o sim, tudo estar√° correto.  Mas se √© um pouco ex√≥tico, nada √© garantido a esse respeito. <br><br>  <b>Anatoly:</b> Nesta discuss√£o, abordamos um t√≥pico bastante importante, como um mito: o C ++ foi declarado h√° muitos anos como uma linguagem de plataforma cruzada, mas, no momento, a plataforma cruzada √© muito mais em C #.  Um e apenas bin√°rio funciona em qualquer lugar onde o .NET √© suportado, e isso est√° quase em todo lugar. <br><br>  <b>Sergey:</b> Bem, isso tamb√©m √© bastante infundado.  Como uma pessoa que passou a maior parte da minha vida incorporada, raramente vi o .NET ser suportado pela cadeia de ferramentas do fabricante de hardware.  As empresas que produzem ferro usam o mesmo G ++ ou Clang ou o fazem come√ßar a gerar c√≥digo para sua plataforma. <br><br>  <b>Dmitry:</b> Sim, mas o problema √© que toda vez que fazem isso, eles perdem algo do C ++.  Por exemplo, a Nokia usou uma varia√ß√£o do C ++, mas o seu C ++ estava com reviravoltas loucas e APIs loucas que enfureciam a todos.  Ou seja, n√£o √© apenas C ++, mas C ++ para uma ou outra plataforma.  E ent√£o os problemas come√ßam.  Por exemplo, tome o mesmo CUDA.  √â como se apenas deixasse os profissionais passarem por si; n√£o √© um compilador, mas apenas um driver.  Mas, apesar disso, ela se preocupa com o fato de ainda usar algum tipo de estrutura para rasgar arquivos CUDA em partes de GPU e CPU.  E √†s vezes ela n√£o consegue. <br><br>  <b>Sergey:</b> Eu n√£o quis dizer isso nem um pouco.  √â que quando eu ou√ßo ".NET roda em todos os lugares", a maior parte da minha biografia √© revertida.  Quando voc√™ compra um hardware com um processador personalizado, ele √© fornecido com a entrega do G ++.  E h√° C ++ comum, que o G ++ pode converter da cadeia de ferramentas em c√≥digo de m√°quina suportado por esse processador em particular. <br><br>  <b>Dmitry:</b> Mas, novamente, isso deve ser remontado ... <br><br>  <b>Sergey:</b> Claro. <br><br>  <b>Dmitry:</b> E a ideia de pegar um c√≥digo positivo existente e arrast√°-lo para um peda√ßo de ferro - essa id√©ia tamb√©m n√£o funciona, porque de repente voc√™ arrastou seu x86 comum para algum lugar, onde voc√™ tem 8 gigabytes de mem√≥ria para tudo, e n√£o √© expandir: por exemplo, n√£o h√° troca para disco, porque n√£o h√° disco e acesso a ele.  Isto √©, se estamos falando de portabilidade.  Depende dos objetivos, naturalmente. <br><br>  <b>Anatoly: os</b> profissionais trabalham em mais dispositivos e, √© claro, o incorporado √© uma das partes mais fortes.  Mas geralmente voc√™ precisa adaptar o seu c√≥digo √† plataforma.  Isso √© ruim.  Eu posso cobrir um grande n√∫mero de plataformas, arquiteturas, modelos com um c√≥digo.  Nos aspectos positivos, eu tive que pensar em cada plataforma individual: onde ela come√ßar√° l√° e em que condi√ß√µes.  E √© muito ruim, √© muito contido. <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2>  Estabilidade, compatibilidade, desenvolvimento de linguagem </h2><br>  <b>Dmitry:</b> Abstra√ß√µes de custo zero tamb√©m foram mencionadas, mas o problema √© que isso tem um pre√ßo enorme.  Por exemplo, no .NET h√° um conceito de um tipo enumerado e uma interface IEnumerable.  E para cada tipo, por exemplo, uma matriz, voc√™ pode pegar e passar por um iterador.  Mas em C ++ n√£o existe essa ideia.  Devido √† abstra√ß√£o de custo zero, para contornar a cole√ß√£o, existem algumas begin () e end (), existem regras para seu trabalho, e tudo isso √© muito mais complicado (especialmente para quem come√ßa a programar).  Este √© um problema direto: como contornar uma matriz de A a Z. <br><br>  <b>Sergey:</b> Se eu entendi direito do que voc√™ est√° falando ... Se voc√™ s√≥ precisa percorrer um cont√™iner do come√ßo ao fim, agora basta escrever, como em algum Python. <br><br>  <b>Dmitry:</b> Isso √© tudo maravilhoso.  Mas voc√™, por exemplo, n√£o usa polimorfismo para isso.  Voc√™ n√£o pode dizer que aqui eu tenho uma fun√ß√£o que recebe um certo valor, que √© enumerado a priori.  Voc√™ n√£o pode dizer que eu tenho um valor que implementa a interface, e essa interface possui um iterador, por exemplo. <br><br>  <b>Sergey:</b> Estamos falando sobre qual C ++?  Sobre C ++ em geral, C ++ do futuro, C ++, que agora est√£o sendo aceitos como padr√£o? <br><br>  <b>Dmitry:</b> Bem, se nos profissionais do futuro ser√° ... <br><br>  <b>Sergey:</b> No C ++ 20, isso j√° est√° l√°.  Voc√™ j√° pode dizer, pode at√© se declarar.  Essas n√£o s√£o interfaces, mas, como diz√™-lo corretamente ... Em geral, voc√™ pode declarar que seu tipo deve satisfazer tais e tais condi√ß√µes.  Por exemplo, ele tem in√≠cio e fim, que retornam um iterador.  E um iterador √© um conceito t√£o preparado na biblioteca padr√£o.  Ele diz o que √©, descreve.  Os iteradores tamb√©m s√£o diferentes.  Em geral, tentamos, tornamos mais conveniente para as pessoas. <br><br>  <b>Dmitry:</b> Parece-me que isso surgiu do fato de as pessoas perceberem que √© dif√≠cil viver sem os conceitos de iter√°vel de um objeto.  Porque n√£o est√° claro como escrever coisas generalizadas.  Sim, a abstra√ß√£o de custo zero significa que n√£o temos o custo de caminhar pela tabela em V ao pesquisar ... No .NET, existe apenas um m√©todo espec√≠fico, por exemplo.  E n√≥s, para encontr√°-lo, naturalmente, temos que gastar esfor√ßos, que as vantagens recusam.  Mas, do ponto de vista da usabilidade, o resultado final n√£o √© t√£o bom, eu diria. <br><br>  <b>Sergey:</b> Naturalmente, deve haver um equil√≠brio.  Voc√™ n√£o pode ter tudo de uma vez. <br><br>  <b>Anatoly:</b> Isso faz voc√™ se perguntar quantos anos se passaram.  L√≠nguas alternativas evoluem, e nelas essas coisas b√°sicas aparecem desde o in√≠cio.  Agora eles est√£o alcan√ßando algo mais substancial e interessante.  E as vantagens ficam por dez anos com a mesma sintaxe incompreens√≠vel, abstra√ß√µes obscuras, muletas incompreens√≠veis e subdesenvolvidas.  Voc√™ pode colocar isso como um dos menos. <br><br>  <b>Sergey:</b> Bem, vamos l√°!  O que significa "mal desenvolvido"? <br><br>  Voc√™ mencionou um comit√™ - o C ++ tamb√©m possui um comit√™ ISO que o desenvolve.  Existem representantes l√°, incluindo a Microsoft, que se afogam fortemente pelo fato de que "voc√™ n√£o pode fazer isso porque temos muito legado que precisamos apoiar".  Apenas C ++ √© a linguagem j√° realizada.  E, claro, ele caminha com muito cuidado.  Uma das principais tarefas (que j√° foi declarada pela Straustrup ao criar) √© a compatibilidade com C. Mas agora C j√° evoluiu bastante, √© necess√°rio designar com qual C √© compat√≠vel. <br><br>  E, na minha opini√£o, agora o C ++ est√° se desenvolvendo em um ritmo tremendo.  Com rela√ß√£o aos conceitos e assim por diante - de fato, tudo cresce, √© claro, n√£o pela iterabilidade.  De fato, o desenvolvimento segue o que Alexander Stepanov tamb√©m descreveu - um dos autores do que agora chamamos de ‚Äúprograma√ß√£o generalizada‚Äù, a pessoa que realmente arrastou modelos, gen√©ricos e assim por diante para o C ++.  Para ser sincero, n√£o sei o quanto o comit√™ √© inspirado por essas id√©ias, mas parece-me que h√° definitivamente alguma interse√ß√£o com elas. <br><br>  <b>Anatoly:</b> Parece que todas essas metaclasses, iteradores s√£o realmente inspira√ß√£o, o que j√° era muitas d√©cadas atr√°s.  Mesmo se voc√™ usar metaprograma√ß√£o, modelos, macros - todas essas pessoas experimentaram, trabalharam h√° muito tempo e existem conceitos muito mais simples, √≥bvios e compreens√≠veis.  Em outros idiomas, tudo isso √© feito um milh√£o de vezes melhor e mais r√°pido, com seguran√ßa de tipo, verifica√ß√£o de tempo de compila√ß√£o e assim por diante. <br><br>  <b>Sergey:</b> Espere, voc√™ j√° est√° falando sobre algo que nem todo mundo est√° disposto a pagar.  N√£o quero que meu programa verifique algo em tempo de compila√ß√£o sem meu conhecimento.  Voc√™ entende? <br><br>  <b>Anatoly:</b> Eu acho que tudo isso com sinalizadores pode ser configurado.  Voc√™ define o n√≠vel de otimiza√ß√£o e ele verifica ou n√£o.  Isto n√£o √© um problema. <br><br>  <b>Sergey:</b> Muitas vezes voc√™ precisa controlar tudo com as m√£os.  Saiba exatamente o que est√° acontecendo.  Porque as ferramentas - bem, isso. <br><br>  <b>Dmitry:</b> N√£o √© nem sobre ferramentas.  Aqui, o fato de linguagens como D e Rust dizerem dizer: bem, sim, existe uma coisa que, quando voc√™ acessa um elemento da matriz, pode verific√°-lo, mas n√£o pode verific√°-lo.  E eles apenas entregam ao usu√°rio, ou seja, voc√™ pode dizer "mas vamos desativar as verifica√ß√µes de array", "mas vamos ativ√°-lo".  Ou seja, algum tipo de controle a esse respeito. <br><br>  <b>Sergey:</b> N√£o est√° claro quando voc√™ tem seguran√ßa e seguran√ßa, como em Rust, n√£o vejo a diferen√ßa com C, por exemplo, neste caso. <br><br>  <b>Anatoly:</b> A diferen√ßa √© que voc√™ pode escrever com seguran√ßa e r√°pido.  E em C voc√™ tem que escrever perigosamente.  Bem, sim, talvez r√°pido.  √Äs vezes, a estabilidade √© mais importante que a velocidade. <br><br>  <b>Dmitry:</b> Na verdade, se come√ßarmos a cavar esse t√≥pico com novas linguagens, em C ++ h√° coisas que geralmente s√£o muito dif√≠ceis de transmitir √†s pessoas.  Uma pergunta simples: qual √© o tamanho int?  Na maioria dos idiomas, voc√™ sabe a resposta para esta pergunta.  Voc√™ diz: int √© 32 bits.  Mas voc√™ n√£o conhece os profissionais.  Voc√™ sabe o tamanho do seu computador em particular porque se lembra dele, mas, estritamente falando, voc√™ nem deseja usar os tipos b√°sicos porque eles n√£o s√£o determin√≠sticos.  E essas coisas me enfurecem quando h√° um conjunto de abordagens herdadas, como o int ser√° diferente em plataformas diferentes.  E agora j√° entendemos que isso n√£o pode ser feito.  Por que n√£o dar um passo al√©m disso e de alguma forma resolver esse problema? <br><br>  <b>Sergey:</b> Bem, isso est√° decidido.  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DSTs</a> , os tipos necess√°rios com um comprimento fixo.  Agora, o representante da R√∫ssia no comit√™ est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arrastando um</a> int de comprimento vari√°vel (bem, novamente, com abstra√ß√£o de custo zero). <br><br>  <b>Anatoly:</b> Lembro-me corretamente de que existe um tamanho n√£o determin√≠stico de um ponteiro para um m√©todo?  Ou seja, sob diferentes compiladores e plataformas diferentes, os ponteiros s√£o diferentes? <br><br>  <b>Sergey:</b> Naturalmente, isso √© arquitetura.  Quando voc√™ est√° perto do hardware, como garantir o tamanho do ponteiro, se estiver em 8 bits e em 64 bits? <br><br>  <b>Anatoly:</b> E como se pode fazer aritm√©tica nos indicadores depois disso?  Isso √© loucura. <br><br>  <b>Sergey: Quero</b> dizer?  Bem, com cuidado. <br><br>  <b>Anatoly:</b> Entendo.  A abordagem √© clara em todos os lugares, controlando cuidadosamente tudo com al√ßas. <br><br>  <b>Sergey:</b> Bem, sim.  Novamente, nos padr√µes modernos de C ++, as abordagens s√£o desenvolvidas ... Se falamos sobre a escolha, nas vantagens modernas, de fato, h√° uma escolha entre usar o coletor de lixo.  S√≥ que o GC √© constru√≠do l√° em balc√µes de refer√™ncia. <br><br>  Em geral, em suas palavras, sinto muito que meus colegas n√£o atualizam seu conhecimento sobre vantagens modernas h√° muito tempo. <br><br>  Agora, pessoas como Straustrup, que fazem parte do pante√£o dos deuses positivos, v√™m com muitas chamadas para descobrir como ensinar C ++ moderno.  O problema √© o que as pessoas pensam nas categorias C ++ de 2003 e ensinam nas mesmas categorias.  E em conex√£o com isso, existem novos projetos e abordagens interessantes, existem cursos modernos - digamos que os caras da Yandex fizeram um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">curso</a> maravilhoso.  E agora, em vantagens, √© considerado uma m√° educa√ß√£o, por exemplo, usar puro novo e excluir. <br><br>  <b>Dmitry:</b> Quanto ao seu coment√°rio sobre a atualiza√ß√£o do conhecimento ... A nuance √© que minha abordagem, por exemplo, √© usar o pequeno delta de C ++, que √© garantido que funcionar√° para mim e com o qual sou "amigo".  Voc√™ v√™, C ++ √© extenso.  H√° metaprograma√ß√£o de modelos, e tudo ficaria bem, h√° muita m√°gica, mas, infelizmente, essa m√°gica √© ileg√≠vel.  Este √© um c√≥digo no qual um n√£o-autor n√£o pode descobrir isso sem nenhum conhecimento especial, em certo sentido uma caixa preta.  E existem muitas dessas caixas negras nos profissionais, √°reas de escurid√£o que n√£o podem ser digeridas ... Eu gostaria, n√£o sei, sua op√ß√£o de ser calculada de forma previs√≠vel, bem e sem truques. <br><br>  O exemplo mais simples √© falar sobre intervalos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intervalo-v3</a> e todo esse t√≥pico).  Por um lado, tudo isso √© √≥timo: h√° coisas que est√£o em C # h√° v√°rios anos, permitindo, por exemplo, criar um calend√°rio por quaisquer transforma√ß√µes da cole√ß√£o padr√£o.  Por outro lado, a maneira como √© implementada em C ++ √© simplesmente desagrad√°vel em compara√ß√£o com C #: √© pesada, n√£o leg√≠vel. <br><br>  <b>Sergey:</b> Isso √© saboroso.  Eu, pelo contr√°rio, gosto disso.  Pelo que entendi, voc√™ est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> Nibler e em sua apresenta√ß√£o ... <br><br>  <b>Dmitry:</b> Veja, quando o operador "ou" √© usado para filtrar uma cole√ß√£o, eu imediatamente tenho perguntas sobre isso.  C # e Java fizeram tudo atrav√©s do ponto, atrav√©s dos m√©todos usuais. <br><br>  <b>Sergey:</b> E me parece que isso √© inspirado no Bash.  Ou seja, √© apenas um cano. <br><br>  <b>Dmitry:</b> Bem, sim, provavelmente isso explica algo nessa abordagem. <br><br>  <b>Sergey: Isso</b> explica muito!  Vamos falar sobre o PowerShell, j√° que estamos falando sobre o Bash.  Quem viu o PowerShell? <br><br>  <b>Anatoly:</b> eu escrevo no PowerShell, um √≥timo idioma.  Mas, novamente, o tubo precisa ser inserido onde est√°, onde toda a arquitetura √© permeada por ele.  N√£o √© onde voc√™ precisa executar uma √∫nica a√ß√£o, e aqui est√° a sintaxe linguisticamente ruim. <br><br>  <b>Sergey:</b> No tubo de alcance, √© apenas muito ... <br><br>  <b>Dmitry:</b> No intervalo, eles s√£o usados, na minha opini√£o, pelo seguinte motivo ... Vou dizer o seguinte: se em C ++ havia m√©todos ou fun√ß√µes de extens√£o, voc√™ os usaria, √© claro.  Porque a coisa mais natural se voc√™ precisar classificar uma cole√ß√£o √© escrever "cole√ß√£o. Filtro ()".  E n√£o "cole√ß√£o |  view :: filter () ". <br><br>  <b>Anatoly:</b> Eu tamb√©m tive a impress√£o de que voc√™ levou um tiro nas pernas por 20 anos, bateu no rosto, bateu com a cabe√ßa na parede e, finalmente, disse: ‚ÄúBem, agora fizemos tudo muito bem no 20¬∫ padr√£o, agora vamos ensinar os profissionais est√£o certos. "  Sim, ningu√©m quer ensin√°-los corretamente!  Ou seja, √© uma dor a longo prazo. <br><br>  <b>Sergey:</b> Por favor, n√£o ensine.  Qual √© o problema?  Escreva em C # - negocie nele, escreva incorporado.  Eu n√£o me importo. <br><br>  <b>Anatoly:</b> Bem, existem nichos estreitos onde os profissionais ainda est√£o l√°. <br><br>  <b>Sergey:</b> Incorporado √© um "nicho estreito" ... Agora, olhando em volta da minha cozinha, vejo um monte de computadores. <br><br>  <b>Dmitry:</b> Toda vez que viajo de avi√£o, penso: "Droga, espero que essas vantagens tenham escrito tudo bem l√°". <br><br>  <b>Sergey:</b> Bem, a prop√≥sito, existe principalmente Ada, tanto quanto me lembro. <br><br>  <b>Dmitry:</b> Ada domina l√°, sim. <br><br>  <b>Anatoly:</b> A prop√≥sito, recentemente deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um excelente artigo em</a> que o autor em diferentes idiomas (cerca de 10) escreveu um driver de baixo n√≠vel - driver de rede para uma placa Intel de 10 gigabits.  De C para Swift, JS, Python e, naturalmente, C #.  Se olharmos para esses gr√°ficos, que ele obteve, o C # em grandes lotes (quando os custos de lan√ßamento s√£o nivelados) fica em p√© de igualdade com C e Rust. <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br>  Ou seja, se estamos falando sobre desempenho, pode ser um equ√≠voco que o C # seja muito inferior em algum lugar.  H√° tamb√©m um relat√≥rio descolado de Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scratched Metal</a> , onde ele mostrou como otimizou o c√≥digo C # para os criadores de perfil de processador. <br><br>  <b>Sergey:</b> Bem, come√ßa de novo.  O problema √© que, quando voc√™ come√ßa a otimizar esse Java, esse C #, fica claro por que n√£o escrever em vantagens.  Porque voc√™ precisa de conhecimentos espec√≠ficos.  E, como me parece, a vantagem de linguagens como C # e Java √© nivelada - n√£o um limiar de entrada muito alto.  At√© onde eu entendi, exatamente do que Dmitry estava falando: legibilidade do c√≥digo, aprendendo muito, dif√≠cil de explicar alguns conceitos e assim por diante. <br><br>  <b>Anatoly:</b> trabalho 99% do meu tempo escrevendo em C # "normal" - seguro, est√°vel e funcionando o tempo todo.  E 1% do tempo eu quero escrever algum tipo de c√≥digo r√°pido e de baixo n√≠vel.  E esse c # me permite tamb√©m.  Mas minha ferramenta principal ainda √© est√°vel, leg√≠vel, sem erros ... <br><br>  <b>Dmitry:</b> Tolya, deixe-me dar um exemplo simples: vetoriza√ß√£o.  Com a vetoriza√ß√£o no .NET, tudo fica muito ruim, apesar do System.Numerics.Vectors estar sendo serrado lentamente.  E o que isso leva, da minha parte, por exemplo?  O fato de que, se voc√™ estiver vasculhando o mercado e comprando uma biblioteca matem√°tica para .NET, ela ser√° escrita pelos profissionais (com um inv√≥lucro completo).  Como no .NET praticamente n√£o h√° acesso √† acelera√ß√£o de hardware (AVX, etc.), ele est√° agora em algum est√°gio embrion√°rio. <br><br>  <b>Anatoly: Os</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intr√≠nsecos s√£o</a> lan√ßados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Core 3,</a> onde voc√™ pode acessar diretamente o AVX.  Eles realmente est√£o na inf√¢ncia, mas existem coisas b√°sicas e o resto √© bastante emocionante. <br><br>  <b>Dmitry:</b> Voc√™ entende, temos 2019 no quintal.  Como usu√°rio de todo esse bem matem√°tico acelerado, n√£o esperei por isso.  E, como resultado, para mim, se eu quiser considerar algo rapidamente, o C # n√£o √© mais um candidato.  Porque as bibliotecas C ++ j√° existem.  Talvez o tempo j√° tenha sido perdido para isso. <br><br>  <b>Anatoly:</b> Parece-me que o C # est√° se movendo na dire√ß√£o de vantagens, est√° tentando conquistar seu mercado.  Mas as vantagens n√£o est√£o mais se movendo para lugar algum. <br><br>  <b>Sergey: De</b> onde isso vem?  O que significa "vantagens n√£o v√£o a lugar nenhum"? <br><br>  <b>Anatoly:</b> Quando eles me dizem em 2019 que haver√° iteradores no padr√£o, haver√° algum progresso sobre lambdas, parece-me que ... <br><br>  <b>Sergey:</b> N√£o sei por que voc√™ est√° falando sobre iteradores e lambdas, n√£o entendo de que maneira a pedra era ... <br><br>  <b>Anatoly:</b> N√£o sobre iteradores, eu coloquei errado, eu quis dizer os in√∫meros cont√™ineres que discutimos antes.  Enquanto isso, temos uma correspond√™ncia de padr√µes. <br><br>  <b>Sergey:</b> Tudo depende se √© necess√°rio ou n√£o.  Estamos discutindo a correspond√™ncia de padr√µes.  Mas at√© agora n√£o h√° argumentos sobre se √© necess√°rio nos profissionais. <br><br>  <b>Dmitry:</b> eu ou√ßo muitos coment√°rios semelhantes das vantagens, que dizem que "embora j√° exista uma presen√ßa √≥bvia dessa ou daquela abordagem em outros idiomas, ela j√° foi elaborada, as pessoas adoram e desenvolvem solu√ß√µes, ainda n√£o queremos isso em vantagens, porque n√£o s√£o vantagens idiom√°ticas ".  E parece-me que Java caiu no mesmo buraco.  Java disse "n√£o, pessoal, n√£o teremos delegados".  E em Java ainda n√£o h√° conceito de delegados, mas no .NET tudo isso funciona bem. <br><br>  <b>Sergey:</b> Olha, os profissionais s√£o muito simples.  Mais uma vez, de volta ao comit√™.  H√° uma dica - s√£o pessoas que est√£o desenvolvendo compiladores.  E para eles, as palavras "abstra√ß√£o de custo zero" s√£o exatamente o que devem ser orientadas.  E a palavra "legado", infelizmente. <br><br>  <b>Dmitry:</b> Bem, a abstra√ß√£o de custo zero √© um montador.  Se queremos abstra√ß√£o de custo zero em geral, precisamos escrever tudo no assembler. <br><br>  <b>Sergey:</b> N√£o h√° abstra√ß√£o. <br><br>  <b>Dmitry:</b> Assembler √© uma abstra√ß√£o sobre c√≥digo bin√°rio.  √â apenas a segunda gera√ß√£o, n√£o a terceira. <br><br>  <b>Sergey:</b> Ent√£o, sobre todos os tipos de "coisas convenientes", verifica-se que n√£o est√° claro como faz√™-las funcionar rapidamente. <br><br>  <b>Dmitry:</b> Deixe-os trabalhar mais devagar.  A id√©ia com iteradores ass√≠ncronos, corotinas, tudo isso - no .NET com C # a palavra-chave yield n√£o sabe mais quantas vers√µes funcionam muito bem.  Sim, enormes m√°quinas estatais est√£o sendo constru√≠das nos bastidores, apenas m√°gica.  Mas ass√≠ncrono / espera tamb√©m cria m√°gica e em iteradores.  Mas todo mundo usa, e √© realmente conveniente. <br><br>  <b>Sergey:</b> Coroutines adicionam vantagens, ol√°. <br><br>  <b>Dmitry:</b> Bem, sim, est√° sendo feito progresso.  Mas as corotinas est√£o aparecendo agora, n√£o h√° 10 anos. <br><br>  <b>Sergey:</b> Mais uma vez.  As vantagens s√£o mais antigas e, na minha opini√£o, a velocidade de desenvolvimento diminui com o ac√∫mulo da base de c√≥digo.  Claramente, tudo depende se existe um desejo de manter o suporte ao Legado.  Para os profissionais, esta √© uma posi√ß√£o de princ√≠pios.  Ou seja, o c√≥digo que voc√™ escreveu nos anos 80 agora √© compilado por um compilador moderno. <br><br>  <b>Dmitry:</b> Sim, mas voc√™ compila o c√≥digo que escreveu no C # 1.0 com um compilador moderno. <br><br>  <b>Sergey:</b> Isso n√£o √© verdade.  No in√≠cio da discuss√£o, eu disse que uma atualiza√ß√£o chegou nas minhas primeiras vers√µes do .NET e, de repente, todos os programas pararam de funcionar. <br><br>  <b>Dmitry:</b> Talvez as APIs que voc√™ usou tenham mudado.  Aqui voc√™ precisa separar a biblioteca e a linguagem de programa√ß√£o. <br><br>  <b>Sergey:</b> Eu n√£o tinha nada, apenas C #.  Eu era jovem, esses foram os primeiros anos. <br><br>  <b>Dmitry:</b> Lembro-me de apenas uma mudan√ßa no C # 4 - uma pequena mudan√ßa no comportamento do foreach.  Obviamente, nas vers√µes 1.x tudo poderia ser mais turbulento, mas agora definitivamente n√£o estamos na fase em que algu√©m quebra algo de repente. <br><br>  <b>Anatoly:</b> Bem, oficialmente a Microsoft adere √† posi√ß√£o que monitora estritamente a compatibilidade com vers√µes anteriores, eles testam novas vers√µes em um grande n√∫mero de m√°quinas e bases de c√≥digo.  Talvez voc√™ tenha um bug ou algo parecido. <br><br>  <b>Dmitry:</b> Em geral, o .NET tamb√©m monitora a compatibilidade com vers√µes anteriores, mas a velocidade do progresso aumentou tanto o C ++ quanto o Java. <br><br>  <b>Sergey:</b> Parece-me que desempenhou um grande papel, que a princ√≠pio tudo isso foi impulsionado por uma empresa.  Como o C ++ estava originalmente no comit√™ - e isso √© pol√≠tica, todo mundo est√° tentando tomar uma decis√£o - e isso √© como uma reuni√£o do Senado em Guerra nas Estrelas. <br><br>  <b>Dmitry:</b> Ent√£o seu argumento √© que somos todos ref√©ns dos comit√™s que n√£o s√£o movidos pela inova√ß√£o? <br><br>  <b>Sergey:</b> O problema √© que voc√™ n√£o escolhe uma solu√ß√£o que satisfa√ßa a todos.  A ferramenta √© t√£o amplamente distribu√≠da que √© usada por muitas empresas.  Voc√™s lembraram as mesmas corotinas: por que as receberam tarde?  Porque a Microsoft, ao que parece, n√£o p√¥de concordar com o Google.  Havia duas implementa√ß√µes - n√£o me lembro quem estava por tr√°s da pilha e quem estava por tr√°s da pilha, mas n√£o podia concordar.  Como as duas empresas s√£o grandes, elas t√™m enormes bases de c√≥digo que j√° cont√™m uma solu√ß√£o e se recusam a reescrev√™-la. <br><br>  <b>Dmitry:</b> Do ponto de vista do leitor, a pessoa ter√° a sensa√ß√£o de que cuspiu nele de uma torre sineira alta, porque h√° interesses corporativos, eles est√£o envolvidos em interlovers, e tudo isso n√£o parece lhe interessar - v√°, lacaios, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"deixe-os comer bolo"</a> . <br><br>  <b>Sergey:</b> Muito pelo contr√°rio.  O comit√™ est√° tentando escolher para que uma pessoa comum n√£o precise sofrer.  E muitas vezes √© dif√≠cil. <br><br>  <b>Dmitry:</b> Bem, posso dizer por mim mesmo que n√£o sofrerei se o custo zero for direto para algum lugar, mas haver√° algum tipo de oportunidade flex√≠vel de caminhar pela √°rvore bin√°ria e iterar de maneiras diferentes sem vari√°veis ‚Äã‚Äãde tempo.      yield,     -   - ‚Äî    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , ‚Ä¶  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      ¬´¬ª,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   ‚Äî  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     ‚Äî ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      ¬´¬ª.       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       ¬´ ¬ª: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  ‚Äî  ,    ,      . <br><br> <b>:</b>  ,   ‚Äî   ,    ?   ,     greenfield.    brownfield development,   .   ‚Äî ,  .   ‚Äî  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  ¬´    ,   A,  B¬ª.     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    ‚Äî   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         ¬´ ¬ª,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' ‚Äî  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       ‚Äî     .  ,    ,   C++  .  ,     .  ( ,   ) ‚Äî   cutting edge.    ,     UI-  C++,      ,   .   C# ‚Äî .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469467/">https://habr.com/ru/post/pt469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469457/index.html">Onde Extravaganza leva</a></li>
<li><a href="../pt469459/index.html">Conectando dispositivos IoT na cidade inteligente</a></li>
<li><a href="../pt469461/index.html">‚ÄúPara as Estrelas‚Äù: Anti-C√≥smico ‚ÄúApocalipse Hoje‚Äù</a></li>
<li><a href="../pt469463/index.html">Tend√™ncias e previs√µes no processamento de idiomas naturais</a></li>
<li><a href="../pt469465/index.html">Inicializa√ß√£o em C ++ moderno</a></li>
<li><a href="../pt469471/index.html">"5 centavos" para falar sobre as sortes</a></li>
<li><a href="../pt469475/index.html">A ascens√£o e queda do Flash, o plugin irritante que moldou a web moderna</a></li>
<li><a href="../pt469477/index.html">Hora da Apple parar de comparar o iPad ao PC</a></li>
<li><a href="../pt469479/index.html">De onde vem a probabilidade qu√¢ntica</a></li>
<li><a href="../pt469487/index.html">Configurando top no GNU / Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>