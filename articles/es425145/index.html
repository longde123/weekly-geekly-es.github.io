<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéôÔ∏è üë®‚Äçüíº ü§µüèø Un ir tan excepcional üßìüèº ü§∏üèª üõ≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente se han publicado borradores del dise√±o del nuevo manejo de errores en Go 2. Es muy agradable que el lenguaje no se ubique en un solo lug...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un ir tan excepcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425145/"><p>  Recientemente se han publicado borradores del dise√±o del nuevo manejo de errores en Go 2. Es muy agradable que el lenguaje no se ubique en un solo lugar: se desarrolla y cada a√±o crece mejor a pasos agigantados. </p><br><p>  Solo ahora, mientras que Go 2 solo es visible en el horizonte, es muy doloroso y triste esperar.  Por lo tanto, tomamos el asunto en nuestras propias manos.  Un poco de generaci√≥n de c√≥digo, un poco de trabajo con ast, y con un ligero movimiento del p√°nico de la mano, el p√°nico se convierte ... ¬°en elegantes excepciones! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0u/sd/fx/0usdfxkuqp9qtfe9biignfxdzxo.jpeg"></div><a name="habracut"></a><br><blockquote> E inmediatamente quiero hacer una declaraci√≥n muy importante y absolutamente seria. <br>  Esta decisi√≥n es <em>puramente</em> entretenida y educativa por naturaleza. <br>  Me refiero a solo 4 diversi√≥n.  Esto es generalmente una prueba de concepto, en verdad.  Advert√≠ :) </blockquote><br><h2 id="tak-chto-zhe-vyshlo">  Entonces que paso </h2><br><p>  El resultado fue un peque√±o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador de c√≥digo de biblioteca</a> .  Y los generadores de c√≥digos, como todos saben, llevan dentro de s√≠ bondad y gracia.  En realidad no, pero en el mundo Go son bastante populares. </p><br><p> Configuramos un generador de c√≥digo de este tipo en go-raw.  Lo analiza por la ayuda del m√≥dulo est√°ndar <code>go/ast</code> , hace algunos <del>  no </del>  astutas transformaciones, el resultado se escribe al lado del archivo, agregando el sufijo <code>_jex.go</code> .  Los archivos resultantes quieren un peque√±o tiempo de ejecuci√≥n para funcionar. </p><br><p>  De esta manera simple, agregamos excepciones a Go. </p><br><h2 id="polzuem">  Nosotros usamos </h2><br><p>  Conectamos el generador al archivo, en el encabezado (antes del <code>package</code> ) escribimos </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//+build jex //go:generate jex</span></span></code> </pre> <br><p>  Si ahora ejecuta el comando <code>go generate -tags jex</code> , se <code>jex</code> utilidad <code>jex</code> .  Toma el nombre del archivo de <code>os.Getenv("GOFILE")</code> , lo come, lo digiere y escribe <code>{file}_jex.go</code> .  El archivo reci√©n nacido ya tiene <code>//+build !jex</code> en el encabezado (la etiqueta est√° invertida), as√≠ que <code>go build</code> , y en el compartimento con √©l los otros comandos, como <code>go test</code> o <code>go install</code> , tengan en cuenta solo los archivos <em>nuevos</em> y correctos.  Lepota ... </p><br><p>  Ahora dot-import <code>github.com/anjensan/jex</code> . <br>  S√≠, mientras que la importaci√≥n a trav√©s de un punto es obligatoria.  En el futuro se planea dejar lo mismo. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex"</span></span></code> </pre> <br><p>  Genial, ahora puede insertar llamadas a las funciones de c√≥digo auxiliar <code>TRY</code> , <code>THROW</code> , <code>EX</code> en el c√≥digo.  Por todo esto, el c√≥digo sigue siendo sint√°cticamente v√°lido, e incluso se compila en una forma no procesada (simplemente no funciona), por lo que la autocompletar est√° disponible y las linters <em>realmente no</em> juran.  Los editores tambi√©n mostrar√≠an documentaci√≥n para estas funciones, si tan solo tuvieran una. </p><br><p>  Lanzar una excepci√≥n </p><br><pre> <code class="go hljs">THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"error name"</span></span>))</code> </pre> <br><p>  Atrapa la excepci√≥n </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-comment"><span class="hljs-comment">//   } else { fmt.Println(EX()) }</span></span></code> </pre> <br><p>  Se genera una funci√≥n an√≥nima debajo del cap√≥.  Y en ello <code>defer</code> .  Y tiene una funci√≥n m√°s.  Y en ella <code>recover</code> ... Bueno, todav√≠a hay un poco de magia m√°gica para manejar el <code>return</code> y <code>defer</code> . </p><br><p>  Y s√≠, por cierto, ¬°son compatibles! </p><br><p>  Adem√°s, hay una macro variable especial <code>ERR</code> .  Si le asigna un error, se produce una excepci√≥n.  Es m√°s f√°cil llamar a funciones que a√∫n devuelven un <code>error</code> de la manera anterior </p><br><pre> <code class="go hljs">file, ERR := os.Open(filename)</code> </pre> <br><p>  Adem√°s, hay un par de peque√±as bolsas de utilidad <code>ex</code> y <code>must</code> , pero no hay mucho de qu√© hablar. </p><br><h2 id="primery">  Ejemplos </h2><br><p>  Aqu√≠ hay un ejemplo del c√≥digo Go correcto e idiom√°tico </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { r, err := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, err := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := io.Copy(w, r); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { w.Close() os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := w.Close(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }</code> </pre> <br><p>  Este c√≥digo no es tan agradable y elegante.  Por cierto, ¬°esta no es solo mi opini√≥n! <br>  Pero <code>jex</code> nos ayudar√° a mejorarlo. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Logf(<span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst) r, ERR := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, ERR := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { ERR := io.Copy(w, r) ERR := w.Close() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { w.Close() os.Remove(dst) THROW() } }</code> </pre> <br><p>  Pero por ejemplo, el siguiente programa </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { hex, err := ioutil.ReadAll(os.Stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } data, err := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } os.Stdout.Write(data) }</code> </pre> <br><p>  puede reescribirse como </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { hex, ERR := ioutil.ReadAll(os.Stdin) data, ERR := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) os.Stdout.Write(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.Fatal(EX()) } }</code> </pre> <br><p>  Aqu√≠ hay otro ejemplo para sentir mejor la idea propuesta.  C√≥digo original </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x, err := strconv.Atoi(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } y, err := strconv.Atoi(b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  puede reescribirse como </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, ERR := strconv.Atoi(a) y, ERR := strconv.Atoi(b) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) }</code> </pre> <br><p>  o incluso eso </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, must.Int_(strconv.Atoi(a)) + must.Int_(strconv.Atoi(b))) }</code> </pre> <br><h2 id="isklyuchenie">  Excepci√≥n </h2><br><p>  La conclusi√≥n es una estructura de contenedor simple sobre una instancia de <code>error</code> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> exception <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,   err error //  ^W , ,    log []interface{} //      ,    suppress []*exception }</span></span></code> </pre> <br><p>  Un punto importante es que los ataques de p√°nico ordinarios no se perciben como excepciones.  Por lo tanto, todos los errores est√°ndar como <code>runtime.TypeAssertionError</code> no son una excepci√≥n.  Esto est√° en l√≠nea con las mejores pr√°cticas aceptadas en Go: si tenemos, por ejemplo, una nula desreferencia, entonces abandonamos todo el proceso alegre y alegremente.  Fiable y predecible.  Aunque no estoy seguro, quiz√°s valga la pena revisar este momento y detectar tales errores.  Tal vez opcional? </p><br><p>  Y aqu√≠ hay un ejemplo de una cadena de excepci√≥n. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"one"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">two_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { one_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { two_() } }</code> </pre> <br><p>  Aqu√≠ manejamos con calma la excepci√≥n <code>one</code> , como de repente bam ... y <code>two</code> lanza la excepci√≥n <code>two</code> .  Por lo tanto, la fuente <code>one</code> adjuntar√° <code>suppress</code> en el campo <code>suppress</code> .  Nada se perder√°, todo ir√° a los registros.  Por lo tanto, no hay una necesidad particular de insertar toda la cadena de errores directamente en el texto del mensaje utilizando el patr√≥n muy popular <code>fmt.Errorf("blabla: %v", err)</code> .  Aunque nadie, por supuesto, no proh√≠be su uso aqu√≠, si realmente lo desea. </p><br><h2 id="kogda-zabyli-otlovit">  Cuando olvid√© atrapar </h2><br><p>  Ah, otro punto muy importante.  Para aumentar la legibilidad, hay una comprobaci√≥n adicional: si una funci√≥n puede generar una excepci√≥n, entonces su nombre debe terminar con <code>_</code> .  Un nombre deliberadamente torcido que le dir√° al programador "querido se√±or, aqu√≠ en su programa algo puede salir mal, ¬°por favor sea cuidadoso y diligente!" </p><br><p>  Se inicia autom√°ticamente una comprobaci√≥n para los archivos transformados, adem√°s, tambi√©n se puede iniciar manualmente en un proyecto utilizando el <code>jex-check</code> .  Quiz√°s tenga sentido ejecutarlo como parte del proceso de compilaci√≥n junto con otros linters. </p><br><p>  La comprobaci√≥n de comentarios est√° <code>//jex:nocheck</code> .  Esto, por cierto, es la √∫nica forma de lanzar excepciones desde una funci√≥n an√≥nima. </p><br><p>  Por supuesto, esto no es una panacea para todos los problemas.  Checker se perder√° esto </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := bad_ f() }</code> </pre> <br><p>  Por otro lado, no es mucho peor que la verificaci√≥n est√°ndar de <code>err declared and not used</code> , que es muy f√°cil de eludir. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a, err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } b, err := bar() <span class="hljs-comment"><span class="hljs-comment">//  ,    ok... go vet, ? }</span></span></code> </pre> <br><p>  En general, esta pregunta es bastante filos√≥fica, qu√© es mejor hacer cuando olvid√≥ procesar el error: ign√≥relo silenciosamente o genere p√°nico ... Por cierto, los mejores resultados de la prueba podr√≠an lograrse implementando un soporte de excepci√≥n en el compilador, pero esto est√° mucho m√°s all√° del alcance de este art√≠culo . </p><br><p>  Algunos pueden decir que, aunque esta es una soluci√≥n maravillosa, ya no es una excepci√≥n, porque ahora las excepciones significan una implementaci√≥n muy espec√≠fica.  Bueno, ah√≠, porque los rastros de la pila no est√°n unidos a las excepciones, o hay un linter separado para verificar los nombres de las funciones, o que la funci√≥n puede terminar con <code>_</code> pero no arroja excepciones, o no hay soporte directo en la sintaxis, o que realmente es p√°nico, y el p√°nico no es una excepci√≥n en absoluto, porque el gladiolo ... Las esporas pueden ser tan calientes como in√∫tiles e in√∫tiles.  Por lo tanto, los dejar√© detr√°s de la pizarra del art√≠culo y continuar√© llamando a la soluci√≥n descrita de manera selectiva llamada "excepciones". </p><br><h2 id="po-povodu-stektreysov">  Sobre las carreras </h2><br><p>  A menudo, los desarrolladores, para simplificar la depuraci√≥n, pegan un seguimiento de pila a implementaciones de <code>error</code> personalizadas.  Incluso hay varias bibliotecas populares para esto.  Pero, afortunadamente, con excepciones, esto no requiere ninguna acci√≥n adicional debido a una caracter√≠stica interesante de Go: durante el p√°nico, los bloques <code>defer</code> ejecutan en el contexto de pila del c√≥digo que arroj√≥ el p√°nico.  Por lo tanto aqu√≠ </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { foo_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { debug.PrintStack() } }</code> </pre> <br><p>  Se imprimir√° un seguimiento completo de la pila, aunque sea un poco detallado (cort√© los nombres de los archivos) </p><br><pre> <code class="go hljs"> runtime/debug.Stack runtime/debug.PrintStack main.bar.func2 github.com/anjensan/jex/runtime.TryCatch.func1 <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span> main.foo_ main.bar.func1 github.com/anjensan/jex/runtime.TryCatch main.bar main.main</code> </pre> <br><p>  No est√° de m√°s hacer su propio ayudante para formatear / imprimir un seguimiento de la pila, teniendo en cuenta las funciones sustitutas, ocult√°ndolas para facilitar su lectura.  Creo que una buena idea, escribi√≥. </p><br><p>  O puede tomar la pila y adjuntarla a la excepci√≥n usando <code>ex.Log()</code> .  Entonces, tal excepci√≥n se puede transferir a otra horoutin: no se pierden los estrechos. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { e := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(e) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { checkZero_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { EX().Log(debug.Stack()) <span class="hljs-comment"><span class="hljs-comment">//   e &lt;- EX().Wrap() //     } }() ex.Must_(&lt;-e) //  ,  ,  }</span></span></code> </pre> <br><h2 id="k-sozhaleniyu">  Desafortunadamente </h2><br><p>  Eh ... por supuesto, algo as√≠ se ver√≠a mucho mejor </p><br><pre> <code class="go hljs"> try { throw io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span> } catch e { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, e) }</code> </pre> <br><p>  Pero, ay, ah, la sintaxis de Go no es extensible. <br>  [pensativo] Aunque, probablemente, es para mejor ... </p><br><p>  En cualquier caso, tienes que pervertir.  Una de las ideas alternativas era hacer </p><br><pre> <code class="go hljs"> TRY; { THROW(io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span>) }; CATCH; { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, EX) }</code> </pre> <br><p>  Pero ese c√≥digo parece bastante tonto despu√©s de <code>go fmt</code> .  Y el compilador jura cuando ve <code>return</code> en ambas ramas.  No hay tal problema con <code>if-TRY</code> . </p><br><p>  Ser√≠a genial reemplazar la macro <code>ERR</code> con la funci√≥n <code>MUST</code> (mejor que solo).  Para escribir </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MUST(strconv.Atoi(a)) + MUST(strconv.Atoi(b))</code> </pre> <br><p>  En principio, esto todav√≠a es factible, uno puede derivar el tipo de expresiones durante el an√°lisis de ast, generar una funci√≥n de envoltura simple para todos los tipos de tipos, como los declarados en el paquete <code>must</code> , y luego reemplazar <code>MUST</code> con el nombre de la funci√≥n sustituta correspondiente.  Esto no es del todo trivial, pero es completamente posible ... Solo los editores / ide no podr√°n entender dicho c√≥digo.  Despu√©s de todo, la firma de la funci√≥n STUB <code>MUST</code> no es expresable dentro del sistema de tipo Go.  Y por lo tanto no autocompletar. </p><br><h2 id="pod-kapotom">  Debajo del cap√≥ </h2><br><p>  Se agrega una nueva importaci√≥n a todos los archivos procesados. </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _jex <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex/runtime"</span></span></code> </pre> <br><p>  La llamada <code>THROW</code> reemplaza por <code>panic(_jex.NewException(...))</code> .  <code>EX()</code> tambi√©n se reemplaza por el nombre de la variable local que contiene la excepci√≥n capturada. </p><br><p>  Pero <code>if TRY() {..} else {..}</code> procesa un poco m√°s complicado.  Primero, se produce un procesamiento especial para todas las <code>return</code> y <code>defer</code> .  Luego las ramas procesadas si se colocan en funciones an√≥nimas.  Y luego estas funciones se pasan a <code>_jex.TryCatch(..)</code> .  Aqui esta </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre> <br><p>  se convierte en algo como esto (elimin√© los <code>//line</code> comentarios de <code>//line</code> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_r0 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _jex_r1 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_ret <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_md2502 _jex.MultiDefer <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex_md2502.Run() _jex.TryCatch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(_jex.NewException(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>))) } { _f, _p0, _p1 := fmt.Printf, <span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a _jex_md2502.Defer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _f(_p0, _p1) }) } _jex_ret, _jex_r0, _jex_r1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, a+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_ex _jex.Exception)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex.Suppress(_jex_ex) fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _jex_ret { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre><br><p>  Mucho, no hermoso, pero funciona.  De acuerdo, no todo y no siempre.  Por ejemplo, no puede hacer <code>defer-recover</code> diferida dentro de TRY, ya que la llamada a la funci√≥n se convierte en una lambda adicional. </p><br><p>  Adem√°s, al mostrar el √°rbol ast, se indica la opci√≥n "guardar comentarios".  Entonces, en teor√≠a, <code>go/printer</code> deber√≠a imprimirlos ... Lo que honestamente hace, la verdad es muy, muy torcida =) No dar√© ejemplos, solo torcidos.  En principio, este problema es completamente solucionable si especifica cuidadosamente las posiciones para todos los nodos ast (ahora est√°n vac√≠os), pero esto definitivamente no est√° incluido en la lista de cosas necesarias para el prototipo. </p><br><h2 id="probuem">  Prueba </h2><br><p>  Por curiosidad, escrib√≠ un peque√±o <a href="">punto de referencia</a> . </p><br><p>  Tenemos una implementaci√≥n qsort de madera que busca duplicados en la carga.  Encontrado: un error.  Una versi√≥n simplemente lo arroja a trav√©s de <code>return err</code> , la otra aclara el error llamando a <code>fmt.Errorf</code> .  Y uno m√°s usa excepciones.  Clasificamos cortes de diferentes tama√±os, ya sea sin duplicados (sin error, el corte est√° ordenado por completo) o con una repetici√≥n (la separaci√≥n se rompe aproximadamente a la mitad, puede verse por los tiempos). </p><br><div class="spoiler">  <b class="spoiler_title">Resultados</b> <div class="spoiler_text"><pre> <code class="hljs powershell">~ &gt; cat /proc/cpuinfo | grep <span class="hljs-string"><span class="hljs-string">'model name'</span></span> | head <span class="hljs-literal"><span class="hljs-literal">-1</span></span> model name : Intel(R) Core(TM) i7<span class="hljs-literal"><span class="hljs-literal">-6700K</span></span> CPU <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> <span class="hljs-number"><span class="hljs-number">4.00</span></span>GHz ~ &gt; go version go version go1.<span class="hljs-number"><span class="hljs-number">11</span></span> linux/amd64 ~ &gt; go test <span class="hljs-literal"><span class="hljs-literal">-bench</span></span>=. github.com/anjensan/jex/demo goos: linux goarch: amd64 pkg: github.com/anjensan/jex/demo BenchmarkNoErrors/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">236</span></span> ns/op BenchmarkNoErrors/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">255</span></span> ns/op BenchmarkNoErrors/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> ns/op BenchmarkNoErrors/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3119</span></span> ns/op BenchmarkNoErrors/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3194</span></span> ns/op BenchmarkNoErrors/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3533</span></span> ns/op BenchmarkNoErrors/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42356</span></span> ns/op BenchmarkNoErrors/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42204</span></span> ns/op BenchmarkNoErrors/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">44465</span></span> ns/op BenchmarkNoErrors/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">525864</span></span> ns/op BenchmarkNoErrors/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">524781</span></span> ns/op BenchmarkNoErrors/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">561256</span></span> ns/op BenchmarkNoErrors/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6309181</span></span> ns/op BenchmarkNoErrors/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6335135</span></span> ns/op BenchmarkNoErrors/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6687197</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">76274341</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">77806506</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">78019041</span></span> ns/op BenchmarkOneError/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">712</span></span> ns/op BenchmarkOneError/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> ns/op BenchmarkOneError/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">799</span></span> ns/op BenchmarkOneError/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">2296</span></span> ns/op BenchmarkOneError/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-number"><span class="hljs-number">1809</span></span> ns/op BenchmarkOneError/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3529</span></span> ns/op BenchmarkOneError/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">21168</span></span> ns/op BenchmarkOneError/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">20747</span></span> ns/op BenchmarkOneError/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-number"><span class="hljs-number">24560</span></span> ns/op BenchmarkOneError/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-number"><span class="hljs-number">242077</span></span> ns/op BenchmarkOneError/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">242376</span></span> ns/op BenchmarkOneError/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">251043</span></span> ns/op BenchmarkOneError/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2753692</span></span> ns/op BenchmarkOneError/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2824116</span></span> ns/op BenchmarkOneError/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2845701</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33452819</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33374000</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33705994</span></span> ns/op PASS ok github.com/anjensan/jex/demo <span class="hljs-number"><span class="hljs-number">64.008</span></span>s</code> </pre> </div></div><br><p>  Si el error no se ha arrojado (el c√≥digo es estable y concreto reforzado), entonces la garant√≠a con la excepci√≥n de lanzamiento es aproximadamente comparable a <code>return err</code> y <code>fmt.Errorf</code> .  A veces un poco m√°s r√°pido.  Pero si se arroj√≥ el error, las excepciones van en segundo lugar.  Pero todo depende de la proporci√≥n de "trabajo √∫til / error" y la profundidad de la pila.  Para cortes peque√±os, <code>return err</code> va por delante del espacio; para cortes medianos y grandes, las excepciones ya son iguales al reenv√≠o manual. </p><br><p>  En resumen, si los errores ocurren extremadamente raramente, las excepciones pueden incluso acelerar un poco el c√≥digo.  Si como todos los dem√°s, ser√° algo as√≠.  Pero si muy a menudo ... entonces las lentas excepciones est√°n lejos del problema m√°s importante, por lo que vale la pena preocuparse. </p><br><p>  Como prueba, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">migr√© una</a> verdadera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de</a> gosh para excepciones. </p><br><div class="spoiler">  <b class="spoiler_title">Para mi profundo pesar, no funcion√≥ reescribir 1 en 1</b> <div class="spoiler_text"><p>  M√°s precisamente, habr√≠a resultado, pero esto debe ser molestado. </p><br><p>  Entonces, por ejemplo, la funci√≥n <a href=""><code>rpc2XML</code></a> parece devolver el <code>error</code> ... s√≠, simplemente nunca lo devuelve.  Si intentas serializar un tipo de datos no admitido, no hay error, solo vac√≠a la salida.  Tal vez esto es lo que se pretend√≠a ... No, la conciencia no permite dejarlo as√≠.  Agregado por </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: THROW(fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type %T"</span></span>, value))</code> </pre> <br><p>  Pero result√≥ que esta funci√≥n se usa de manera especial </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> xml, err = rpc2XML(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer, err }</code> </pre> <br><p>  Aqu√≠ revisamos la lista de par√°metros, los serializamos todos, pero devolvemos un error <em>solo</em> para este √∫ltimo.  Los errores restantes se ignoran.  Comportamiento extra√±o hecho m√°s f√°cil </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> buffer += rpc2XML_(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  Si al menos un campo no funcion√≥ para serializar, es un error.  Bueno, eso est√° mejor.  Pero result√≥ que esta funci√≥n tambi√©n se usa de manera <a href="">especial</a> . </p><br><pre> <code class="go hljs">xmlstr, _ = rpcResponse2XML(response)</code> </pre> <br><p>  De nuevo, para el c√≥digo fuente esto no es tan importante, porque hay errores que se ignoran.  Estoy empezando a adivinar por qu√© algunos programadores aman el manejo expl√≠cito de errores <code>if err != nil</code> ... Pero con excepciones, a√∫n es m√°s f√°cil reenviar o procesar que ignorar </p><br><pre> <code class="go hljs">xmlstr = rpcResponse2XML_(response)</code> </pre> <br><p>  Y no comenc√© a eliminar la "cadena de errores".  Aqu√≠ est√° el c√≥digo original. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { rawxml, err := ioutil.ReadAll(r) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FaultSystemError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml2RPC(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  aqu√≠ est√° el reescrito </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawxml []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { rawxml, ERR = ioutil.ReadAll(r) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW(FaultSystemError) } xml2RPC_(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  Aqu√≠ el error original (que <code>ioutil.ReadAll</code> devolvi√≥) no se perder√°, se adjuntar√° a la excepci√≥n en el campo <code>ioutil.ReadAll</code> .  De nuevo, se puede hacer como en el original, pero debe confundirse especialmente ... </p><br><p>  Reescrib√≠ las pruebas, reemplazando <code>if err != nil { log.Error(..) }</code> con un simple lanzamiento de excepci√≥n.  Hay un punto negativo: las pruebas caen en el primer error y no contin√∫an funcionando "bien, al menos de alguna manera".  Seg√∫n la mente, ser√≠a necesario dividirlos en subpruebas ... Lo que, en general, vale la pena hacer en cualquier caso.  Pero es muy f√°cil obtener la pila correcta </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.TB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e error)</span></span></span></span> { t.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(debug.Stack())) t.Fatal(e) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestRPC2XMLConverter_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Catch(errorReporter(t)) <span class="hljs-comment"><span class="hljs-comment">// ... xml := rpcRequest2XML_("Some.Method", req) }</span></span></code> </pre> <br><p>  En general, los errores son muy f√°ciles de ignorar.  En el c√≥digo original </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> xml, _ := rpc2XML(fault) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  aqu√≠ el error de <code>rpc2XML</code> nuevamente se ignora silenciosamente.  Se ha convertido as√≠ </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { buffer += rpc2XML_(fault) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"ERR: %v"</span></span>, EX()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;nil/&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> </div></div><br><p>  Seg√∫n mis sentimientos personales, es m√°s f√°cil devolver un resultado "semiacabado" con errores. <br>  Por ejemplo, una respuesta a medio construir.  Las excepciones son m√°s complicadas, ya que la funci√≥n devuelve un resultado exitoso o no devuelve nada.  Una especie de atomicidad.  Por otro lado, las excepciones son m√°s dif√≠ciles de ignorar o perder la causa ra√≠z en la cadena de excepciones.  Despu√©s de todo, todav√≠a tienes que intentar hacer esto espec√≠ficamente.  Con errores, esto sucede f√°cil y naturalmente. </p><br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n </h2><br><p>  Al <em>escribir</em> este art√≠culo, ning√∫n gopher result√≥ herido. </p><br><p>  Gracias por la foto del goffer-alcoh√≥lico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://migranov.ru</a> </p><br><p>  No pude elegir entre los centros de "Programaci√≥n" y "Programaci√≥n anormal". <br>  Una elecci√≥n muy dif√≠cil, agregada a ambos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425145/">https://habr.com/ru/post/es425145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425135/index.html">Por qu√© VoIP es reconocido como un servicio de informaci√≥n en los EE. UU. Y qu√© significa para la industria de telecomunicaciones y los usuarios</a></li>
<li><a href="../es425137/index.html">Trabajamos en la consola de forma r√°pida y eficiente.</a></li>
<li><a href="../es425139/index.html">Pop estrellas bajo la lente de la inteligencia artificial</a></li>
<li><a href="../es425141/index.html">"Enfrentando a Guido lo que le dices" o conversaciones de Python con Bobuk</a></li>
<li><a href="../es425143/index.html">La Escuela Superior de Econom√≠a rechaza conferencias a favor de cursos en l√≠nea.</a></li>
<li><a href="../es425149/index.html">Entre el cielo y la tierra</a></li>
<li><a href="../es425151/index.html">Escucha a escondidas en un chat de telegramas con tu cliente</a></li>
<li><a href="../es425153/index.html">Los tres conceptos err√≥neos sobre emociones m√°s populares en la inform√°tica afectiva</a></li>
<li><a href="../es425155/index.html">Criptograf√≠a fascinante o investigaci√≥n sobre cifrado reversible en PHP</a></li>
<li><a href="../es425157/index.html">Reuni√≥n de la comunidad .Net en CLRium # 4 + en l√≠nea. A d√≥nde van CoreCLR y C #. Todos estan invitados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>