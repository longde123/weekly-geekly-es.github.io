<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¨ ‚õµÔ∏è ü§≥üèæ Likbez untuk meluncurkan Istio ‚ò∏Ô∏è ‚ôæ üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isstio service mesh 


 Kami di Yaitu telah menggunakan Istio selama setahun sekarang. Dia kemudian pergi begitu saja. Kami mengalami penurunan kinerj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez untuk meluncurkan Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Isstio service mesh</em> </p><br><p>  Kami di Yaitu telah menggunakan Istio selama setahun sekarang.  Dia kemudian pergi begitu saja.  Kami mengalami penurunan kinerja yang luar biasa di kluster Kubernetes, kami ingin distribusi tracing dan membawa Istio untuk menjalankan Jaeger dan mencari tahu.  Service mesh sangat cocok dengan infrastruktur kami sehingga kami memutuskan untuk berinvestasi dalam alat ini. </p><br><p>  Saya harus menderita, tetapi kami mempelajarinya jauh dan luas.  Ini adalah posting pertama dalam seri di mana saya akan menjelaskan bagaimana Istio terintegrasi dengan Kubernetes dan apa yang kami pelajari tentang kerjanya.  Kadang-kadang kita akan berkeliaran di belantara teknis, tetapi tidak terlalu jauh.  Selanjutnya akan ada lebih banyak posting. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  Apa itu Istio? </h3><br><p>  Istio adalah alat konfigurasi layanan mesh.  Bunyinya status cluster Kubernetes dan upgrade ke proxy L7 (HTTP dan gRPC), yang diimplementasikan sebagai sespan di pod Kubernetes.  Sespan ini adalah wadah Utusan yang membaca konfigurasi dari Istio Pilot API (dan layanan gRPC) dan rute lalu lintas melaluinya.  Dengan proxy L7 yang kuat di bawah kap, kita bisa menggunakan metrik, jejak, coba lagi logika, pemutus sirkuit, penyeimbangan muatan, dan penyebaran kenari. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Mari kita mulai dari awal: Kubernetes </h3><br><p> Di Kubernetes, kami membuat di bawah menggunakan penyebaran atau StatefulSet.  Atau itu bisa saja "vanilla" di bawah tanpa pengontrol tingkat tinggi.  Kemudian Kubernetes melakukan yang terbaik untuk mempertahankan status yang diinginkan - ia membuat pod di cluster pada node, memastikan bahwa mereka memulai dan memulai kembali.  Ketika sebuah under dibuat, Kubernet melewati siklus hidup API, memastikan bahwa setiap langkah berhasil, dan baru kemudian akhirnya menciptakan under di cluster. </p><br><p>  Tahapan Siklus Hidup API: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Terima kasih kepada Banzai Cloud untuk gambar kerennya.</em> </p><br><p>  Salah satu langkah adalah memodifikasi webhook masuk.  Ini adalah bagian terpisah dari siklus hidup di Kubernetes, di mana sumber daya dikustomisasi sebelum melakukan ke repositori etcd, sumber kebenaran untuk konfigurasi Kubernetes.  Dan di sini Istio melakukan sihirnya. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Memodifikasi webhook masuk </h3><br><p> Ketika sub dibuat (melalui <code>kubectl</code> atau <code>Deployment</code> ), ia melewati siklus hidup ini, dan akses memodifikasi webhook mengubahnya sebelum melepaskannya ke dunia besar. </p><br><p>  Selama instalasi Istio, istio-sidecar-injector ditambahkan sebagai sumber konfigurasi untuk memodifikasi webhooks: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  Dan konfigurasinya: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Dikatakan di sini bahwa Kubernetes harus mengirim semua acara pembuatan perapian ke layanan <code>istio-sidecar-injector</code> di ruang <code>istio-system</code> namespace <code>istio-system</code> jika namespace memiliki <code>istio-injection=enabled</code> .  Injektor mencakup dua wadah lagi di PodSpec: satu sementara untuk menetapkan aturan proxy dan satu untuk proxy itu sendiri.  Injector sespan memasukkan wadah ini sesuai dengan templat dari peta konfigurasi <code>istio-sidecar-injector</code> .  Proses ini juga disebut sidecaring. </p><br><h3 id="sidecar-pody">  Pod sespan </h3><br><p>  Sidecar adalah trik dari pesulap Istio kita.  Istio menjejalkan semuanya dengan sangat cerdik sehingga dari luar itu hanya keajaiban, jika Anda tidak tahu detailnya.  Dan itu berguna untuk mengetahuinya jika Anda tiba-tiba perlu men-debug permintaan jaringan. </p><br><h3 id="init--i-proksi-konteynery">  Wadah init dan proxy </h3><br><p>  Kubernetes memiliki wadah init satu kali sementara yang dapat dijalankan sebelum yang utama.  Mereka mengumpulkan sumber daya, memigrasi basis data, atau, seperti halnya dengan Istio, mengkonfigurasi aturan jaringan. </p><br><p>  Istio menggunakan Utusan untuk mem-proxy semua permintaan untuk pengiriman di sepanjang rute yang diinginkan.  Untuk melakukan ini, Istio membuat aturan <code>iptables</code> , dan mereka mengirim lalu lintas masuk dan keluar langsung ke Utusan, dan itu dengan rapi proksi lalu lintas ke tujuannya.  Lalu lintas membuat jalan memutar kecil, tetapi Anda telah mendistribusikan penelusuran, metrik kueri, dan penegakan kebijakan.  Dalam file ini, dari repositori Istio Anda <a href="">dapat melihat</a> bagaimana Istio membuat aturan iptables. </p><br><p>  <a href="">@jimmysongio</a> membuat diagram koneksi yang sangat baik antara aturan iptables dan proxy Utusan: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Utusan - Utusan Lalu Lintas</em> </p><br><p>  Utusan menerima semua lalu lintas masuk dan keluar, sehingga semua lalu lintas umumnya bergerak di dalam Utusan, seperti pada diagram.  Proxy Istio adalah wadah lain yang ditambahkan ke semua pod yang dimodifikasi oleh injektor sespan Istio.  Dalam wadah ini, proses Utusan dimulai, yang menerima semua lalu lintas dari perapian (dengan beberapa pengecualian, seperti lalu lintas dari kluster Kubernetes Anda). </p><br><p>  Proses Utusan menemukan semua rute melalui API Utusan v2, yang mengimplementasikan Istio. </p><br><h3 id="envoy-i-pilot">  Utusan dan Pilot </h3><br><p>  Utusan itu sendiri tidak memiliki logika untuk mendeteksi pod dan layanan dalam sebuah cluster.  Ini adalah bidang data dan membutuhkan bidang kontrol untuk memandu.  Parameter konfigurasi Utusan meminta host atau port layanan untuk menerima konfigurasi ini melalui API gRPC.  Istio, melalui layanan Pilot-nya, memenuhi persyaratan untuk API gRPC.  Utusan terhubung ke API ini berdasarkan konfigurasi sespan diimplementasikan melalui webhook memodifikasi.  API memiliki semua aturan lalu lintas yang perlu ditemukan Utusan dan rute untuk cluster.  Ini adalah service mesh. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Pertukaran data "di bawah Pilot &lt;-&gt;</em> </p><br><p>  Pilot terhubung ke kluster Kubernetes, membaca status kluster dan menunggu pembaruan.  Ini memantau perapian, layanan, dan titik akhir di cluster Kubernetes, untuk kemudian memberikan konfigurasi yang tepat untuk semua sespan utusan yang terhubung ke Pilot.  Ini adalah jembatan antara Kubernetes dan Utusan. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>Dari Pilot ke Kubernetes</em> </p><br><p>  Ketika pod, layanan, atau titik akhir dibuat atau diperbarui di Kubernetes, Pilot mempelajarinya dan mengirimkan konfigurasi yang diperlukan untuk semua instance Utusan yang terhubung. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  Konfigurasi apa yang sedang dikirim? </h3><br><p>  Konfigurasi apa yang didapatkan Utusan dari Istio Pilot? </p><br><p>  Secara default, Kubernetes memecahkan masalah jaringan Anda dengan layanan (layanan) yang mengelola <code>endpoint</code> .  Daftar titik akhir dapat dibuka dengan perintah: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Ini adalah daftar semua IP dan porta di cluster dan alamatnya (biasanya ini adalah pod yang dibuat dari penyebaran).  Istio penting untuk diketahui untuk mengkonfigurasi dan mengirim data rute ke Utusan. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Layanan, pendengar, dan rute </h3><br><p>  Saat Anda membuat layanan di kluster Kubernetes, Anda menyertakan pintasan yang dengannya semua pod yang sesuai akan dipilih.  Saat Anda mengirim lalu lintas ke IP layanan, Kubernetes memilih lalu lintas untuk lalu lintas ini.  Misalnya, perintahnya </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  Pertama, ia akan menemukan IP virtual yang ditetapkan untuk <code>my-service</code> di namespace <code>default</code> , dan IP ini akan meneruskan lalu lintas ke sub yang cocok dengan label layanan. </p><br><p>  Istio dan Utusan sedikit mengubah logika ini.  Istio mengkonfigurasi Utusan berdasarkan layanan dan titik akhir di kluster Kubernetes dan menggunakan fitur perutean cerdas dan penyeimbangan muatan Envoy untuk mem-bypass layanan Kubernetes.  Alih-alih proksi lebih dari satu IP, Utusan terhubung langsung ke perapian IP.  <strong>Untuk melakukan ini, Istio memetakan konfigurasi Kubernetes ke konfigurasi Utusan</strong> . </p><br><p>  Istilah Kubernetes, Istio dan Utusan sedikit berbeda, dan tidak jelas apa yang mereka makan. </p><br><h3 id="servisy">  Layanan </h3><br><p>  Layanan di Kubernetes memetakan ke sebuah <strong>cluster</strong> di Utusan.  Cluster Utusan berisi daftar <strong>titik akhir</strong> , yaitu IP (atau nama host) dari instance untuk memproses permintaan.  Untuk melihat daftar cluster yang dikonfigurasi di Istio sidecar-pod, jalankan <code>istioctl proxy-config cluster &lt; &gt;</code> .  Perintah ini menunjukkan keadaan saat ini dalam hal perapian.  Berikut adalah contoh dari salah satu lingkungan kami: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Semua layanan yang sama berada di namespace ini: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  Bagaimana Istio tahu protokol mana yang menggunakan layanan ini?  Mengkonfigurasi protokol untuk manifes layanan oleh bidang <code>name</code> di entri port. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  Jika ada <code>grpc</code> atau awalan grpc-, Istio akan mengkonfigurasi protokol HTTP2 untuk layanan ini.  Kami belajar melalui pengalaman pahit bagaimana Istio menggunakan nama port ketika konfigurasi proxy rusak karena mereka tidak menentukan awalan http atau grpc ... </p><br><p>  Jika Anda menggunakan kubectl dan halaman penerusan port admin di Utusan, Anda dapat melihat bahwa titik akhir akun-grpc-publik diimplementasikan oleh Pilot sebagai cluster di Utusan dengan protokol HTTP2.  Ini menegaskan asumsi kami: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  Port 15000 adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman admin Utusan</a> , tersedia di setiap sespan. </p><br><h3 id="proslushivateli">  Pendengar </h3><br><p>  Pendengar mengenali titik akhir Kubernetes untuk meneruskan lalu lintas ke perapian.  Layanan verifikasi alamat memiliki satu titik akhir di sini: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Oleh karena itu, perapian verifikasi alamat memiliki satu pendengar di port 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Rute </h3><br><p>  Di Istio, alih-alih objek Kubernetes Ingress standar, sumber daya kustom lebih abstrak dan efisien <code>VirtualService</code> - <code>VirtualService</code> .  VirtualService memetakan rute ke cluster hulu dengan mengikatnya ke gateway.  Ini adalah cara menggunakan Kubernetes Ingress dengan pengontrol Ingress. </p><br><p>  Di Yaitu, kami menggunakan Istio Ingress-Gateway untuk semua lalu lintas GRPC internal: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  Sekilas, Anda tidak akan mengerti apa pun dalam contoh ini.  Tidak terlihat di sini, tetapi penyebaran Istio-IngressGateway mencatat titik akhir yang diperlukan berdasarkan pada <code>istio: ingressgateway</code> .  Dalam contoh ini, IngressGateway merutekan lalu lintas untuk semua domain melalui port 80 melalui HTTP2.  VirtualService mengimplementasikan rute untuk gateway ini, cocok dengan awalan <code>/namely.address_validator.AddressValidator</code> dan meneruskan <code>addressvalidator</code> melalui port 50051 ke layanan upstream <code>addressvalidator</code> aturan coba lagi dalam dua detik. </p><br><p>  Jika kita mengarahkan ulang port pod dari Istio-IngressGateway dan melihat konfigurasi Utusan, kita akan melihat apa yang VirtualService lakukan: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  Apa yang kami googled saat menggali di Istio </h3><br><p>  <strong>Kesalahan 503 atau 404 terjadi</strong> </p><br><p>  Alasannya berbeda, tetapi biasanya ini adalah: </p><br><ul><li>  Aplikasi sespan tidak dapat menghubungi Pilot (periksa apakah Pilot sedang berjalan). </li><li>  Manifes layanan Kubernetes memiliki protokol yang tidak valid. </li><li>  Konfigurasi VirtualService / Utusan menulis rute ke cluster hulu yang salah.  Mulai dengan layanan tepi, tempat Anda mengharapkan lalu lintas masuk, dan periksa log Utusan.  Atau gunakan sesuatu seperti Jaeger untuk menemukan kesalahan. </li></ul><br><p>  <strong>Apa arti NR / UH / UF dalam log proxy Istio?</strong> </p><br><ul><li>  NR - Tanpa Rute. </li><li>  UH - Hulu Tidak Sehat (hulu yang tidak bisa dioperasi). </li><li>  UF - Kegagalan Hulu (kegagalan hulu). </li></ul><br><p>  Baca lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Utusan</a> . </p><br><p>  <strong>Mengenai Ketersediaan Tinggi dengan Istio</strong> </p><br><ul><li>  Tambahkan NodeAffinity ke komponen Istio untuk mendistribusikan perapian secara merata di berbagai zona ketersediaan dan meningkatkan jumlah replika minimum. </li><li>  Luncurkan versi baru Kubernetes dengan fitur Horizontal Pod Autoscaling.  Tungku perapian yang paling penting akan diukur berdasarkan bebannya. </li></ul><br><p>  <strong>Mengapa cronjob tidak berakhir?</strong> </p><br><p>  Ketika beban kerja utama selesai, wadah sespan terus bekerja.  Untuk mengatasi masalah ini, nonaktifkan sidecar di cronjobs dengan menambahkan <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> annotation.istio.io/inject <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> ke PodSpec. </p><br><p>  <strong>Bagaimana cara menginstal Istio?</strong> </p><br><p>  Kami menggunakan Spinnaker untuk penerapan, tetapi kami biasanya mengambil grafik Helm terbaru, menyulapnya, menggunakan <code>helm template -f values.yml</code> dan mengkomit file pada Github untuk melihat perubahan sebelum menerapkannya melalui <code>kubectl apply -f -</code> .  Ini agar tidak secara tidak sengaja mengubah CRD atau API di versi yang berbeda. </p><br><p>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bobby Tables</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Michael Hamrah</a> karena telah membantu menulis posting ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441616/">https://habr.com/ru/post/id441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441602/index.html">Mengapa mobil otomatis klasik tidak mungkin dan tidak memiliki prospek komersial</a></li>
<li><a href="../id441604/index.html">Sistem pengawasan nasional Tiongkok: sumber tidak hanya data, tetapi juga pendapatan yang stabil</a></li>
<li><a href="../id441606/index.html">Solusi yang hampir bisa diandalkan</a></li>
<li><a href="../id441608/index.html">Dualitas - mesin mudah dan cepat untuk igrostroy di Windows (Ext.)</a></li>
<li><a href="../id441610/index.html">Kebohongan LED dengan proporsi yang belum pernah terjadi sebelumnya</a></li>
<li><a href="../id441618/index.html">Pembuatan Bilah Navigasi Bawah di Kotlin menggunakan Anko</a></li>
<li><a href="../id441620/index.html">Proyek Prometheus: Mencari Api Menggunakan AI</a></li>
<li><a href="../id441626/index.html">Workshop Pencetakan Industri 3D: 1 Maret di Caliber Technopark</a></li>
<li><a href="../id441628/index.html">2018 Saint-Petersburg dan Moscow IT Employer rating: hasil survei pengembang</a></li>
<li><a href="../id441632/index.html">1 Maret - Pertemuan Timlead: penilaian dan motivasi karyawan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>