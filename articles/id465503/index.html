<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚖️ 🚱 🤙🏻 Tarantool Cartridge: merobek-robek Lua backend dalam tiga baris 👼🏻 🌍 💠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Mail.ru Group, kami memiliki Tarantool - ini adalah server aplikasi di Lua, yang juga memiliki basis data (atau sebaliknya?). Ini cepat dan keren, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Cartridge: merobek-robek Lua backend dalam tiga baris</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465503/"><img src="https://habrastorage.org/webt/zl/9w/og/zl9wogkzbdgwzzedtahlcg1f8ys.jpeg"><br><br>  Di Mail.ru Group, kami memiliki Tarantool - ini adalah server aplikasi di Lua, yang juga memiliki basis data (atau sebaliknya?).  Ini cepat dan keren, tetapi kemampuan satu server masih tidak terbatas.  Penskalaan vertikal juga bukan obat mujarab, jadi Tarantool memiliki alat untuk penskalaan horizontal - modul vshard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> .  Ini memungkinkan Anda untuk mengirim data ke beberapa server, tetapi Anda harus mengotak-atiknya untuk mengkonfigurasinya dan mempercepat logika bisnis. <br><br>  Berita bagus: kami mengumpulkan kerucut (misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[3]</a> ) dan memotong kerangka kerja lain yang secara signifikan akan menyederhanakan solusi untuk masalah ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Cartridge</a> adalah kerangka kerja baru untuk mengembangkan sistem terdistribusi yang kompleks.  Ini memungkinkan Anda untuk fokus pada penulisan logika bisnis alih-alih menyelesaikan masalah infrastruktur.  Di bawah potongan, saya akan memberitahu Anda bagaimana kerangka kerja ini diatur dan bagaimana menulis layanan terdistribusi dengannya. <br><a name="habracut"></a><br><h2>  Dan apa sebenarnya masalahnya? </h2><br>  Kami memiliki tarantula, ada vshard - apa lagi yang Anda inginkan? <br><br>  Pertama, intinya adalah kenyamanan.  Konfigurasi Vshard dikonfigurasi melalui tabel Lua.  Agar sistem terdistribusi dari beberapa proses Tarantool berfungsi dengan benar, konfigurasinya harus sama di mana-mana.  Tidak ada yang mau melakukan ini secara manual.  Oleh karena itu, semua jenis skrip, Ansible, sistem penyebaran digunakan. <br><br>  Cartridge sendiri mengelola konfigurasi vshard, ia melakukan ini berdasarkan <i>konfigurasi terdistribusi sendiri</i> .  Intinya, ini adalah file YAML sederhana, salinannya disimpan di setiap instance Tarantool.  Penyederhanaan terletak pada kenyataan bahwa kerangka itu sendiri memonitor konfigurasinya dan sehingga sama di mana-mana. <br><br>  Kedua, intinya lagi dalam kenyamanan.  Konfigurasi tidak memiliki hubungan dengan pengembangan logika bisnis dan hanya mengalihkan perhatian programmer dari pekerjaan.  Ketika kita membahas arsitektur proyek, paling sering kita berbicara tentang komponen individu dan interaksinya.  Masih terlalu dini untuk memikirkan meluncurkan cluster ke 3 pusat data. <br><br>  Kami memecahkan masalah ini berulang-ulang, dan pada titik tertentu kami berhasil mengembangkan pendekatan untuk menyederhanakan pekerjaan dengan aplikasi di seluruh siklus hidupnya: pembuatan, pengembangan, pengujian, CI / CD, pemeliharaan. <br><br>  Cartridge memperkenalkan konsep peran untuk setiap proses Tarantool.  Peran adalah konsep yang memungkinkan pengembang untuk fokus pada penulisan kode.  Semua peran yang tersedia dalam proyek dapat dijalankan pada satu instance dari Tarantool, dan ini akan cukup untuk pengujian. <br><br>  Fitur utama dari Tarantool Cartridge: <br><br><ul><li>  orkestrasi klaster otomatis; <br></li><li>  memperluas fungsionalitas aplikasi dengan peran baru; <br></li><li>  pengembangan aplikasi dan templat penyebaran; <br></li><li>  built-in sharding otomatis; <br></li><li>  integrasi dengan kerangka uji Luatest; <br></li><li>  manajemen cluster menggunakan WebUI dan API; <br></li><li>  alat pengemasan dan penyebaran. <br></li></ul><br><h2>  Halo Dunia! </h2><br>  Saya ingin menunjukkan kerangka itu sendiri, jadi mari kita tinggalkan cerita tentang arsitektur untuk nanti, dan mulai dengan yang sederhana.  Dengan asumsi Tarantool itu sendiri sudah diinstal, semua yang masih harus dilakukan adalah <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Dua perintah ini akan menginstal utilitas baris perintah dan memungkinkan Anda membuat aplikasi pertama dari templat: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Dan inilah yang kami dapatkan: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre><br>  Ini adalah repositori git dengan "Halo, Dunia!" Yang sudah jadi  aplikasi.  Mari kita segera mencoba menjalankannya, pra-instal dependensi (termasuk kerangka itu sendiri): <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Jadi, kami telah meluncurkan satu node dari aplikasi sharded yang akan datang.  Orang awam yang ingin tahu dapat segera membuka antarmuka web, menggunakan mouse untuk mengonfigurasi kluster dari satu simpul dan menikmati hasilnya, tetapi terlalu dini untuk bersukacita.  Sejauh ini, aplikasi tersebut tidak tahu bagaimana melakukan sesuatu yang berguna, jadi saya akan memberi tahu Anda tentang penerapan nanti, dan sekarang saatnya untuk menulis kode. <br><br><h2>  Pengembangan aplikasi </h2><br>  Bayangkan saja, kami akan merancang proyek yang harus menerima data, menyimpannya dan membuat laporan sekali sehari. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/357/881/992/3578819921cd1788d44a85856c6aac45.png"><br><br>  Kami mulai menggambar diagram, dan menempatkan tiga komponen di atasnya: gateway, penyimpanan dan penjadwal.  Kami sedang mengerjakan arsitektur lebih lanjut.  Karena kami menggunakan vshard sebagai penyimpanan, kami menambahkan vshard-router dan vshard-storage ke skema.  Baik gateway maupun scheduler tidak akan langsung mengakses repositori, ada router untuk ini, itu dibuat untuk itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/65d/b72/2d465db72cc6c6db294c84748566513d.png"><br><br>  Skema ini masih belum cukup akurat mencerminkan apa yang akan kita buat dalam proyek, karena komponennya terlihat abstrak.  Kita juga perlu melihat bagaimana ini diproyeksikan ke Tarantool yang asli - kita akan mengelompokkan komponen-komponen kita dengan proses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e88/314/779/e8831477921e9be63de6ada1e9385b86.png"><br><br>  Menjaga vshard-router dan gateway pada instance yang terpisah tidak masuk akal.  Mengapa kita perlu kembali ke jaringan sekali lagi, jika ini sudah menjadi tanggung jawab router?  Mereka harus berjalan dalam proses yang sama.  Yaitu, dalam satu proses, gateway dan vshard.router.cfg diinisialisasi, dan biarkan mereka berinteraksi secara lokal. <br><br>  Sangat nyaman untuk bekerja dengan tiga komponen pada tahap desain, tetapi sebagai pengembang, ketika saya menulis kode, saya tidak ingin berpikir untuk meluncurkan tiga instance dari Tarnatool.  Saya perlu menjalankan tes dan memverifikasi bahwa saya menulis gateway dengan benar.  Atau mungkin saya ingin menunjukkan fitur kepada kolega saya.  Mengapa saya harus menderita dengan penyebaran tiga salinan?  Begitulah konsep peran dilahirkan.  Peran adalah modul Loach reguler yang siklus hidupnya dikelola oleh Cartridge.  Dalam contoh ini, ada empat di antaranya - gateway, router, storage, scheduler.  Di proyek lain, mungkin ada lebih banyak.  Semua peran dapat diluncurkan dalam satu proses, dan ini sudah cukup. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/726/90c/fdf72690c30cc9b2b3ade8af667494dc.png"><br><br>  Dan ketika datang ke penerapan ke staging atau ke dalam operasi, maka kami akan menetapkan setiap set peran untuk setiap proses Tarantool, tergantung pada kemampuan perangkat keras: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/945/59f/a0394559f3f372e9de056ab4a080dff4.png"><br><br><h2>  Manajemen topologi </h2><br>  Informasi tentang di mana peran diluncurkan harus disimpan di suatu tempat.  Dan "suatu tempat" ini adalah konfigurasi terdistribusi yang saya sebutkan di atas.  Yang paling penting di dalamnya adalah topologi cluster.  Berikut adalah 3 grup replikasi dari 5 proses Tarantool: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/04d/28a/14004d28a893832830ac61ad9c4207dd.png"><br><br>  Kami tidak ingin kehilangan data, oleh karena itu kami dengan hati-hati memperlakukan informasi tentang proses yang sedang berjalan.  Cartridge memantau konfigurasi dengan komit dua fase.  Segera setelah kami ingin memperbarui konfigurasi, itu terlebih dahulu memeriksa ketersediaan semua contoh dan kesiapan mereka untuk menerima konfigurasi baru.  Setelah ini, fase kedua menerapkan konfigurasi.  Jadi, bahkan jika satu instance tidak tersedia untuk sementara, maka tidak ada hal buruk yang akan terjadi.  Konfigurasi tidak akan berlaku dan Anda akan melihat kesalahan sebelumnya. <br><br>  Juga di bagian topologi ditunjukkan parameter penting seperti pemimpin dari setiap kelompok replikasi.  Biasanya ini adalah contoh yang sedang direkam.  Sisanya paling sering hanya baca, meskipun mungkin ada pengecualian.  Terkadang pengembang yang berani tidak takut akan konflik dan dapat menulis data ke beberapa replika secara paralel, tetapi ada beberapa operasi yang, meskipun semuanya, tidak boleh dilakukan dua kali.  Ada tanda pemimpin untuk ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/6db/376/7256db376d8fe207bbf57f5f82054c3f.png"><br><br><h2>  Role life </h2><br>  Agar peran abstrak ada dalam arsitektur seperti itu, kerangka kerja entah bagaimana harus mengelolanya.  Secara alami, kontrol terjadi tanpa memulai ulang proses Tarantool.  Ada 4 panggilan balik untuk mengelola peran.  Cartridge sendiri akan memanggil mereka tergantung pada apa yang dikatakan dalam konfigurasi terdistribusi, sehingga menerapkan konfigurasi tersebut ke peran tertentu. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Setiap peran memiliki fungsi <code>init</code> .  Itu disebut sekali, baik ketika peran diaktifkan, atau ketika Tarantool restart.  Lebih mudah di sana, misalnya, untuk menginisialisasi box.space.create, atau scheduler dapat menjalankan beberapa serat latar belakang, yang akan melakukan pekerjaan pada interval tertentu. <br><br>  Fungsi <code>init</code> mungkin tidak cukup.  Cartridge memungkinkan peran mengambil keuntungan dari konfigurasi terdistribusi yang digunakannya untuk menyimpan topologi.  Dalam konfigurasi yang sama, kita dapat mendeklarasikan bagian baru dan menyimpan sebagian dari konfigurasi bisnis di dalamnya.  Dalam contoh saya, ini bisa berupa skema data, atau pengaturan jadwal untuk peran penjadwal. <br><br>  Cluster memanggil <code>validate_config</code> dan <code>apply_config</code> setiap kali konfigurasi terdistribusi berubah.  Ketika konfigurasi diterapkan oleh komit dua fase, klaster memverifikasi bahwa setiap peran siap untuk menerima konfigurasi baru ini dan, jika perlu, melaporkan kesalahan kepada pengguna.  Ketika semua orang sepakat bahwa konfigurasi itu normal, <code>apply_config</code> . <br><br>  Peran juga memiliki metode <code>stop</code> , yang diperlukan untuk menghapus tanda-tanda vital peran.  Jika kita mengatakan bahwa penjadwal pada server ini tidak lagi diperlukan, ia dapat menghentikan serat yang dimulai dengan <code>init</code> . <br><br>  Peran dapat saling berinteraksi.  Kami terbiasa menulis panggilan fungsi di Lua, tetapi mungkin saja kami tidak memiliki peran yang kami butuhkan dalam proses ini.  Untuk memfasilitasi akses jaringan, kami menggunakan modul tambahan rpc (panggilan prosedur jarak jauh), yang dibangun berdasarkan netbox standar yang dibangun di Tarantool.  Ini bisa bermanfaat jika, misalnya, gateway Anda ingin langsung meminta penjadwal untuk melakukan pekerjaan itu sekarang, daripada menunggu sehari. <br><br>  Poin penting lainnya adalah memastikan toleransi kesalahan.  Cartridge menggunakan protokol SWIM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[4]</a> untuk memantau kesehatan.  Singkatnya, proses saling bertukar “rumor” dengan satu sama lain melalui UDP - setiap proses memberitahu tetangga mereka berita terbaru, dan mereka merespons.  Jika jawabannya tidak datang, Tarantool mulai curiga ada sesuatu yang salah, dan setelah beberapa saat ia membacakan kematian dan mulai memberi tahu semua orang tentang berita ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/612/8f8/dd66128f843008534c5bd2b7d3b3474d.png"><br><br>  Berdasarkan protokol ini, Cartridge mengatur failover otomatis.  Setiap proses memantau lingkungannya, dan jika pemimpin tiba-tiba berhenti merespons, replika dapat mengambil perannya sendiri, dan Cartridge akan mengkonfigurasi peran yang berjalan sesuai. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23f/5b9/cc1/23f5b9cc17987df38ddddcf5000ab328.png"><br><br>  Anda harus berhati-hati di sini karena sering bolak-balik dapat menyebabkan konflik data selama replikasi.  Nyalakan failover otomatis secara acak, tentu saja, tidak sepadan.  Anda perlu memahami dengan jelas apa yang sedang terjadi dan memastikan bahwa replikasi tidak akan rusak setelah pemimpin pulih dan mahkota dikembalikan kepadanya. <br><br>  Dari semua yang telah dikatakan, tampaknya perannya mirip dengan layanan mikro.  Dalam arti, mereka, hanya sebagai modul dalam proses Tarantool.  Tetapi ada sejumlah perbedaan mendasar.  Pertama, semua peran proyek harus hidup dalam satu basis kode.  Dan semua proses Tarantool harus diluncurkan dari satu basis kode, sehingga tidak ada kejutan seperti ketika kita mencoba menginisialisasi penjadwal, tetapi itu tidak terjadi.  Juga, jangan biarkan perbedaan dalam versi kode, karena perilaku sistem dalam situasi seperti ini sangat sulit untuk diprediksi dan didebug. <br><br>  Tidak seperti Docker, kita tidak bisa hanya mengambil "gambar" dari sebuah peran, membawanya ke komputer lain dan menjalankannya di sana.  Peran kami tidak terisolasi seperti wadah Docker.  Selain itu, kami tidak dapat menjalankan dua peran yang identik pada instance yang sama.  Peran itu ada di sana atau tidak, dalam arti itu adalah singleton.  Dan ketiga, perannya harus sama di dalam seluruh grup replikasi, karena jika tidak maka akan menjadi konyol - datanya sama, dan konfigurasinya berbeda. <br><br><h2>  Alat penyebaran </h2><br>  Saya berjanji untuk menunjukkan bagaimana Cartridge membantu menyebarkan aplikasi.  Untuk membuat hidup lebih mudah bagi orang lain, framework ini mengemas paket RPM: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp #    ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  Paket yang terinstal membawa hampir semua yang Anda butuhkan: baik aplikasi dan dependensi lauch yang diinstal.  Tarantool juga akan datang ke server sebagai ketergantungan paket RPM, dan layanan kami siap diluncurkan.  Ini dilakukan melalui systemd, tetapi pertama-tama Anda perlu menulis sedikit konfigurasi.  Minimal, tentukan URI dari setiap proses.  Tiga misalnya sudah cukup. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Ada nuansa yang menarik di sini.  Alih-alih hanya menentukan port protokol biner, kami menentukan alamat publik dari seluruh proses termasuk nama host.  Hal ini diperlukan agar node-node cluster mengetahui bagaimana menghubungkan satu sama lain.  Ini adalah ide yang buruk untuk menggunakan alamat 0.0.0.0 sebagai advertise_uri, itu harus alamat IP eksternal, bukan bind socket.  Tanpa itu, tidak ada yang akan berfungsi, jadi Cartridge tidak akan membiarkan simpul dengan advertise_uri yang salah dimulai. <br><br>  Sekarang setelah konfigurasi siap, Anda dapat memulai proses.  Karena unit systemd reguler tidak memungkinkan memulai lebih dari satu proses, aplikasi pada Cartridge menginstal apa yang disebut  unit instantiated yang bekerja seperti ini: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Dalam konfigurasi, kami menentukan port HTTP tempat Cartridge melayani antarmuka web - 8080. Mari kita bahas dan lihat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7c/1dd/64f/d7c1dd64fdca2fed35c71dca3caaf382.png"><br><br>  Kami melihat bahwa proses, meskipun sedang berjalan, belum dikonfigurasi.  Kartrid belum tahu siapa yang harus mereplikasi dengan siapa dan tidak bisa memutuskan sendiri, jadi menunggu tindakan kami.  Dan pilihan kita tidak besar: kehidupan cluster baru dimulai dengan konfigurasi node pertama.  Kemudian kami menambahkan sisanya ke cluster, menetapkan peran padanya, dan pada penyebaran ini dapat dianggap berhasil diselesaikan. <br><br>  Tuangkan segelas minuman favorit Anda dan bersantai setelah seminggu yang panjang.  Aplikasi dapat dieksploitasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf6/c86/e44/cf6c86e448cf42c9ce190a4d13307c3a.png"><br><br><h2>  Ringkasan </h2><br>  Dan apa hasilnya?  Coba, gunakan, tinggalkan umpan balik, mulai tiket di github. <br><br><h2>  Referensi </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool »2.2» Referensi »Referensi batuan» Modul vshard</a> <br><br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana kami menerapkan inti bisnis investasi Alfa-Bank berdasarkan Tarantool</a> <br><br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Penagihan Generasi Selanjutnya: Transisi ke Tarantool</a> <br><br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SWIM - protokol bangunan cluster</a> <br><br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub - tarantool / cartridge-cli</a> <br><br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub - tarantool / kartrid</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465503/">https://habr.com/ru/post/id465503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465493/index.html">Bahasa pemrograman Swift di Raspberry Pi</a></li>
<li><a href="../id465495/index.html">Bagaimana tidak kehilangan traffic saat pindah ke domain baru: case "Vse10"</a></li>
<li><a href="../id465497/index.html">Olahpesan rahasia melalui log server</a></li>
<li><a href="../id465499/index.html">Undang-undang baru untuk menggambarkan kecepatan perkembangan komputer kuantum?</a></li>
<li><a href="../id465501/index.html">Pelajaran dipetik 40 tahun setelah lepas landas dan penurunan cepat "aplikasi pembunuh" pertama</a></li>
<li><a href="../id465509/index.html">Asya Patrysheva: “Internet tidak lagi hanya sebuah jaringan. Inilah hidup. "</a></li>
<li><a href="../id465511/index.html">Antara jalur dukungan teknis pertama dan kedua</a></li>
<li><a href="../id465513/index.html">Log in the eye: kerentanan apa yang dimiliki sistem CCTV</a></li>
<li><a href="../id465515/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 27. Pengantar ACL. Bagian 1</a></li>
<li><a href="../id465517/index.html">DoodleBattle Paper Board Game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>