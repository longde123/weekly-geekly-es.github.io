<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊗️ 🐧 👩‍⚖️ تحقق Telerik UI لـ UWP للتعرف على PVS-Studio 👨🏼‍🌾 🕯️ ☝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لقد أصبح تقليدًا أن يبدأ المبرمجون الذين يعيدون تزويد فريق PVS-Studio بعملهم من خلال كتابة مقال عن تحليل مشروع مفتوح المصدر. هذه المرة ، سيكون مثل هذا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تحقق Telerik UI لـ UWP للتعرف على PVS-Studio</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/470584/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"></p><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ww/cf/vp/wwcfvpz0hkpkv-ubqtskjfq2ahg.png" alt="الصورة 2"></div><br>  لقد أصبح تقليدًا أن يبدأ المبرمجون الذين يعيدون تزويد فريق PVS-Studio بعملهم من خلال كتابة مقال عن تحليل مشروع مفتوح المصدر.  هذه المرة ، سيكون مثل هذا المشروع الذي تم إثباته هو Telerik UI لـ UWP. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  PVS-Studio محلل الكود </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PVS-Studio</a> هي أداة للكشف عن الأخطاء ونقاط الضعف المحتملة في الكود المصدري للبرامج المكتوبة بلغات C و C ++ و C # و Java.  يعمل على أنظمة التشغيل Windows و Linux و macOS. <br><br>  يوفر المحلل سيناريوهات الاستخدام المختلفة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن استخدامها محليًا على أجهزة التطوير ، حيث يتم دمجها كعنصر إضافي في Visual Studio أو IntelliJ IDEA ؛ </li><li style=";text-align:right;direction:rtl">  يمكن أن تتكامل مع منصة ضمان الجودة المستمرة SonarQube ؛ </li><li style=";text-align:right;direction:rtl">  يمكن استخدامها بشكل مستقل ، والاندماج في نظام التجميع ؛ </li><li style=";text-align:right;direction:rtl">  من الممكن استخدام أداة مراقبة الترجمة ؛ </li><li style=";text-align:right;direction:rtl">  التكامل مع Azure DevOps و Jenkins و TeamCity و Travis CI وأنظمة مماثلة أمر ممكن ؛ </li><li style=";text-align:right;direction:rtl">  و هكذا. </li></ul><br><h2 style=";text-align:right;direction:rtl">  مشروع مدقق </h2><br>  Telerik UI for UWP عبارة عن مجموعة من مكونات واجهة المستخدم لنظام التشغيل Windows Universal Platform (UWP).  يمكن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">العثور على</a> الكود المصدري للمشروع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على جيثب</a> .  تحتوي المجموعة على أكثر من 20 مكونًا يسمح لك بتصور البيانات في شكل رسوم بيانية ، وإنشاء قوائم وجداول ، واستخدام خريطة لعرض البيانات المرتبطة بموقع ما. <br><br><h2 style=";text-align:right;direction:rtl">  شظايا جذبت الانتباه عند دراسة تقرير المحلل </h2><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3013 من</a> الغريب أن يكون نص الدالة "OnMinValuePropertyChanged" مساوياً تمامًا لجسم وظيفة "OnMaxValuePropertyChanged".  RadGauge.cs 446 <br><br><pre style=";text-align:right;direction:rtl"><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMinValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } }</code> </pre> <br>  اكتشف المحلل طريقتين ، <i>OnMinValuePropertyChanged</i> و <i>OnMaxValuePropertyChanged</i> ، والتي تقوم بتنفيذ نفس الإجراءات.  لدي شكوك قوية بأن هناك خطأ قد تسلل إلى هذا الرمز.  لاحظ أن الأسلوب <i>OnMinValuePropertyChanged</i> وأسلوب <i>OnMaxValuePropertyChanged</i> يستخدم <i>RaiseMinimumPropertyChangedEvent</i> .  في نفس الوقت ، في فئة <i>RadGaugeAutomationPeer ، يمكنك</i> العثور على طريقة "الحد الأدنى" و "الحد الأقصى": <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMaximumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MaximumProperty, oldValue, newValue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMinimumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MinimumProperty, oldValue, newValue); }</code> </pre> <br>  لا يتم استخدام الأسلوب <i>RaiseMaximumPropertyChangedEvent</i> في التعليمات البرمجية ، ولكن يتم استخدام <i>RaiseMinimumPropertyChangedEvent</i> مرتين.  كما تعلمون ، فإن أداء أسلوب <i>OnMaxValuePropertyChanged</i> يثير أسئلة ... أعتقد أنه كان من المفترض أن يكتب ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { .... peer.RaiseMaximumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); .... }</code> </pre> <br>  لكن على الرغم من ذلك ، لا يبدو الرمز أنيقًا جدًا نظرًا للعدد الكبير من العناصر المكررة.  من الصعب أن نفهم ، والخطوط المتكررة تمنع انتباه المبرمج ، ويصبح من الصعب إجراء مراجعة الكود في مثل هذه الظروف.  لكن أدوات التحليل الثابتة تقوم بعمل ممتاز في التحقق من مثل هذه الشفرة (ولكن هذا لا يعني أنه يمكنك القيام به دون إعادة التسكين ولا سيما دون تقليل عدد الخطوط المتكررة). <br><br>  من أعلاه ومقتطف الشفرة التالي ، يمكننا افتراض أن المؤلفين لا يكرهون نسخ اللصق.  ومع ذلك ، مثلنا جميعا ... :) <br><br>  <b>تحذير</b> <b>PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a> هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عنصر تعبيرات</a> فرعية متطابقة. RenderSize == حجم فارغ 'إلى اليسار وإلى يمين' || '  المشغل.  TiltInteractionEffect.cs 181 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInElementBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameworkElement element, Point position</span></span></span><span class="hljs-function">)</span></span> { Size emptySize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.RenderSize == emptySize || element.RenderSize == emptySize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(....).Contains(position); }</code> </pre> <br>  اكتشف المحلل جزءًا من رمز الخطأ يمينًا إلى يمين عامل التشغيل "||"  <i>العبارة</i> if تستخدم نفس التعبيرات الفرعية.  من الواضح أن التعبير الثاني قد بدا مختلفًا.  ربما في مكان <i>RenderSize</i> الثاني يجب أن يكون <i>DesiredSize</i> .  أو لا ينبغي أن يكون هناك تعبير ثانٍ على الإطلاق.  في أي حال ، تحتاج هذه الشفرة إلى إصلاح. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a> هناك نص تعبيرات فرعية متطابقة '[0] ==' - '' إلى اليسار وإلى يسار '||'  المشغل.  RadNumericBox.cs 1057 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.textBox.Text; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text.Length == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span> || text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetText(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  هنا ، يكتب المطور النص الذي تم إدخاله في حقل مربع النص إلى متغير.  ثم تتم مقارنة الحرف الأول من السلسلة مرتين بنفس الحرف "-" ، وهو قرار مشبوه.  من الواضح أن التحقق من صحة النص في هذه الوظيفة لا يعمل كما هو مقصود في الأصل. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a> هناك تعبيرات فرعية متطابقة 'newValue.HasValue' إلى اليسار وإلى يمين المشغل '&amp;&amp;'.  DateTimePicker.cs 576 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValueChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { DateTimePicker picker = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DateTimePicker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newValue = (DateTime?)args.NewValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue.HasValue &amp;&amp; newValue != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  تعبير <i>newValue.HasValue</i> بإرجاع <i>true</i> إذا كان <i>newValue</i> يحتوي على أي قيمة ، والتعبير <i>newValue! =</i> <i>Null</i> يفعل نفس الشيء.  يولي المحلل الانتباه إلى ذلك ، وما يجب فعله هو إزالة أحد التعبيرات الفرعية أو استبداله بأخرى (إذا كان يجب التحقق من شيء آخر) ، فإن الأمر متروك للمطورين لاتخاذ القرار. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3125</a> تم استخدام كائن "CurrentAttachedMenu" بعد أن تم التحقق منه ضد قيمة خالية.  خطوط التحقق: 98 ، 96. PopupService.cs 98 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PopupService</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Overlay_PointerPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentAttachedMenu == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !CurrentAttachedMenu.hitTestService. HitTest(e.GetCurrentPoint(CurrentAttachedMenu).Position).Any()) { CurrentAttachedMenu.IsOpen = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; HideOverlay(); } } }</code> </pre> <br>  إذا تبين أن متغير <i>CurrentAttachedMenu</i> <i>خالي</i> ، فإن تقييم التعبير <i>CurrentAttachedMenu.IsOpen سيثير</i> استثناء.  للوهلة الأولى ، يبدو أن هذا خطأ مطبعي بسيط ولا يعني مقارنة مع <i>فارغة</i> ، ولكن العملية العكسية - '! ='.  ولكن بعد ذلك سيحدث استثناء في حالة <i>العبارة</i> if إذا كان متغير <i>CurrentAttachedMenu</i> <i>خاليًا</i> . <br><br>  علاوة على ذلك ، كان هناك <b>37</b> تحذيراً من نفس التحذيرات ، يبدو أن بعضها يشير إلى الأخطاء.  لكن لوصفها في إطار مقال واحد ما زال كثيرًا ، لذا سأتركها دون مراقبة. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3019</a> ربما تتم مقارنة متغير غير صحيح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بالقيمة</a> الخالية بعد التحويل باستخدام كلمة "as".  تحقق من المتغيرات "dragDropElement" ، و "uiDragDropElement".  DragDrop.cs 91 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDrag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dragDropElement = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IDragDropElement; .... UIElement uiDragDropElement = dragDropElement <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dragDropElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !dragDropElement.CanStartDrag(trigger, initializeContext)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  من المحتمل جدًا أن يكون المؤلف قد خلط بين المتغيرات.  لا يتم التحقق من عدم المساواة <i>الفارغة من</i> خلال الرابط الذي تم الحصول عليه كنتيجة <i>للقالب</i> ، ولكن بواسطة الأصلي ( <i>dragDropElement</i> ).  على الأرجح ، كان من المفترض أن يتم <i>التحقق من</i> ارتباط <i>uiDragDropElement</i> .  يتم تأكيد <i>الحدس</i> أيضًا من خلال حقيقة أن المبرمج استخدم <i>uiDragDropElement أيضًا</i> دون التحقق من وجود قيمة <i>خالية</i> . <br><br>  <b>تحذير PVS-Studio</b> : فحص متكرر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3030</a> .  تم التحقق من الشرط "! ShowIndicatorWhenNoData" بالفعل في السطر 139. RadDataBoundListBox.PullToRefresh.cs 141 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlePullToRefreshItemStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item, ItemState state</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showIndicatorWhenNoData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ShowPullToRefreshWhenNoData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.realizedItems.Count == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == ItemState.Recycled &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.StopPullToRefreshLoading(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HidePullToRefreshIndicator(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  عثر المحلل على جزء من الكود يتم فيه إعادة التحقق من متغير <i>showIndicatorWhenNoData</i> نفسه ، في <i>ظل شرطين</i> .  ربما يكون الشيك بسيطًا ، لكن هناك أيضًا احتمال أن يكون أحد التعبيرات الفرعية المكررة مختلفًا على الإطلاق. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3031</a> يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط بالمشغل تعبيرات معاكسة.  SelectedItemCollection.cs 77 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; ((!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect); } }</code> </pre> <br>  هذا الجزء من الكود ليس خاطئًا رسميًا.  المحلل تلميحات في بعض التكرار رمز في هذه الحالة.  ومع ذلك ، تجدر الإشارة إلى أن الكود الإضافي يكون أحيانًا نتيجة لخطأ ، على سبيل المثال ، عندما يتم فحص متغير آخر ، بدلاً من متغير واحد ، عدة مرات. <br><br>  يمكنك تقليل هذا الشرط قليلاً وإزالة الرمز الإضافي.  على سبيل المثال ، مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br>  رسائل مماثلة أخرى: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط بالمشغل تعبيرات معاكسة.  SelectedItemCollection.cs 93 </li><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط بالمشغل تعبيرات معاكسة.  StackVirtualizationStrategy.cs 49 </li><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  عامل التشغيل محاط بعبارات التعبيرات المعاكسة 'state == null' و 'state! = null'.  LocalFieldDescriptionsProviderBase.cs 24 </li></ul><br>  النظر في قطعة أخرى من التعليمات البرمجية حيث عاد محلل ما يلي: <br><br>  <b>تحذيرات PVS-Studio</b> : <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3137 يتم تعيين متغير "leftMargin" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  DragDrop.cs 87 </li><li style=";text-align:right;direction:rtl">  V3137 يتم تعيين متغير "topMargin" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  DragDrop.cs 88 </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DragDrop</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> leftMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> topMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frameworkElementSource != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { leftMargin = frameworkElementSource.Margin.Left; <span class="hljs-comment"><span class="hljs-comment">// &lt;= topMargin = frameworkElementSource.Margin.Top; // &lt;= } if (dragDropElement == null || !dragDropElement.CanStartDrag(trigger, initializeContext)) { return; } var context = dragDropElement .DragStarting(trigger, initializeContext); if (context == null) { return; } var startDragPosition = e .GetCurrentPoint(context.DragSurface.RootElement).Position; var relativeStartDragPosition = e .GetCurrentPoint(uiDragDropElement).Position; var dragPositionMode = DragDrop .GetDragPositionMode(uiDragDropElement); AddOperation(new DragDropOperation( context, dragDropElement, dragPositionMode, e.Pointer, startDragPosition, relativeStartDragPosition)); }</span></span></code> </pre> <br>  يفيد المحلل في أنه تم تعيين <i>متغيرات leftMargin</i> و <i>topMargin</i> ، لكن بعد ذلك لا يتم استخدام هذه المتغيرات حتى نهاية الطريقة.  ربما لا يوجد خطأ هنا ، ولكن يبدو أن هذا الرمز مشبوه.  قد يكون هذا بسبب الخطأ المطبعي أو إعادة بيع المباني غير الناجحة. <br><br>  تم العثور على نفس المشكلة في مكان آخر: V3137 يتم تعيين متغير 'currentColumnLength' ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  WrapLayout.cs 824 <br><br>  <b>تحذير PVS-Studio</b> : يتم دائمًا إعادة كتابة "فهرس" المعلمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3061</a> في نص الطريقة قبل استخدامها.  DataEngine.cs 1443 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Tuple&lt;Group, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindGroupAndItemIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">.... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exhaustiveSearch) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aggregateRowGroup = rowRootGroup; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rowGroupNames = valueProvider.GetRowGroupNames(item); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rowGroupNames) { Group <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aggregateRowGroup.TryGetGroup(groupName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { aggregateRowGroup = <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; } } index = aggregateRowGroup.IndexOf(item, <span class="hljs-comment"><span class="hljs-comment">// &lt;= valueProvider.GetSortComparer()); return Tuple.Create(aggregateRowGroup, index); } }</span></span></code> </pre> <br>  <i>يتم</i> الكتابة فوق معلمة <i>الفهرس</i> للأسلوب <i>FindGroupAndItemIndex</i> قبل استخدامها.  على الأرجح ، يشير هذا إلى خطأ مبرمج. <br><br>  <b>تحذير PVS-Studio</b> : الاحتجاج غير الآمن على الحدث "مكتمل" ، NullReferenceException ممكن.  النظر في تعيين الحدث إلى متغير محلي قبل استدعاء ذلك.  ActionBase.cs 32 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ActionBase</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsCompleted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } } }</code> </pre> <br>  سمح المبرمج بإجراء مكالمة قد تكون غير آمنة لمعالج الأحداث في هذه الطريقة ، مما قد يؤدي إلى استثناء من النوع <i>NullReferenceException</i> .  سيتم طرح استثناء شريطة ألا يكون هذا الحدث بين الاختيار <i>الفارغ</i> واستدعاء معالجات الأحداث. <br><br>  هناك <b>49</b> مشاكل مماثلة أخرى في التعليمات البرمجية.  لن يكون من المثير للاهتمام مشاهدتها جميعًا في هذه المقالة ، وسيكون بمقدور المؤلفين العثور عليها بسهولة باستخدام PVS-Studio ، لذلك سننتقل إلى أخطاء أخرى. <br><br>  <b>PVS-Studio Warning</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3145</a> dereference غير الآمن لهدف WeakReference ، فكّر في فحص info.Target.  يمكن أن يكون الكائن قد تم تجميعه بين التحقق من "IsAlive" والوصول إلى خاصية "Target".  FadeAnimation.cs 84 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadFadeAnimation</span></span> : <span class="hljs-title"><span class="hljs-title">RadAnimation</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyAnimationValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayAnimationInfo info</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.Target.Opacity != opacity) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { info.Target.Opacity = opacity; } .... } .... }</span></span></code> </pre> <br>  يحذر المحلل من خطورة استثناء نوع <i>NullReferenceException</i> عند الوصول إلى خاصية <i>info.Target.Opacity</i> .  من أجل فهم جوهر المشكلة بشكل أفضل ، تحتاج إلى إلقاء نظرة على أجزاء من فئة <i>PlayAnimationInfo</i> ، وعلى وجه الخصوص ، خاصية <i>Target</i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayAnimationInfo</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeakReference target; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayAnimationInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Storyboard storyboard, RadAnimation animation, UIElement target</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(target); .... } .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UIElement Target { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.IsAlive) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } .... }</code> </pre> <br>  بشكل عام ، كلما قمت بحفر هذا الرمز ، زادت المشاكل المحتملة التي يمكنك العثور عليها.  دعونا نلقي نظرة على الأكثر إثارة للاهتمام - واحد الذي أصدر المحلل تحذيرا.  الحقيقة هي أنه حتى إذا كان التنفيذ يتبع الفرع آنذاك <i>لبيان if</i> ، فإن هذا لا يضمن إعادة مرجع غير صفري.  بغض النظر عن المحادثات حول المدلى بها ، هنا نعتبر أن كل شيء مسموح به بسبب تهيئة الكائن في المُنشئ. <br><br>  كيف هذا ممكن؟  الحقيقة هي أنه إذا كان الاختيار بين <i>IsAlive</i> والدعوة <i>الهدف</i> يتم تنفيذ مجموعة البيانات المهملة ، والتي <i>بموجبها يقع</i> الكائن المشار إليه بواسطة <i>WeakReference</i> ، فإن هذا. <i>target.Target</i> سيعود <i>لاغية</i> .  بمعنى أن التحقق من <i>IsAlive لا</i> يضمن أنه في المرة التالية التي يتم فيها الوصول إلى <i>الهدف</i> ، لا يزال الكائن متاحًا. <br><br>  بالمناسبة ، فإن الوضع هو <i>العودة فارغة.</i>  يمسك قاعدة تشخيصية أخرى: V3080 dereference null الممكنة.  النظر في تفتيش "info.Target".  FadeAnimation.cs 84 <br><br>  حدثت مشكلات مماثلة في التعليمات البرمجية عدة مرات: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3145 التراجع غير الآمن عن هدف WeakReference ، فكّر في فحص الهدف.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  MoveXAnimation.cs 80 </li><li style=";text-align:right;direction:rtl">  V3145 التراجع غير الآمن عن هدف WeakReference ، فكّر في فحص الهدف.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  MoveYAnimation.cs 80 </li><li style=";text-align:right;direction:rtl">  V3145 dereference غير الآمن لهدف WeakReference ، فكّر في فحص info.Target.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  PlaneProjectionAnimation.cs 244 </li><li style=";text-align:right;direction:rtl">  V3145 dreference غير آمن لهدف WeakReference.  يمكن أن يكون الكائن قد تم تجميعه بين التحقق من "IsAlive" والوصول إلى خاصية "Target".  WeakEventHandler.cs 109 </li></ul><br>  دعنا ننتقل إلى المثال التالي. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3066</a> تم تمرير ترتيب غير صحيح للوسيطات إلى مُنشئ 'NotifyCollectionChangedEventArgs': 'oldItem' و 'newItem'.  CheckedItemsCollection.cs 470 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CheckedItemsCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">INotifyCollectionChanged</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> NotifyCollectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Add: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Remove: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Replace: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex); <span class="hljs-comment"><span class="hljs-comment">// &lt;= default: return new NotifyCollectionChangedEventArgs(action); } } }</span></span></code> </pre> <br>  لفهم معنى هذا التحذير <i>الصادر</i> عن المحلل ، يجدر النظر إلى <i>معلمات</i> مُنشئ <i>NotifyCollectionChangedEventArgs</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyCollectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> NotifyCollectionChangedAction action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  المحلل يحذر من ذلك في التعبير <br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex);</code> </pre> <br>  تبديل المتغيرات <i>oldItem</i> و <i>newItem</i> .  في تعريف المنشئ ، يتم سردها بترتيب مختلف.  سواء تم ذلك بوعي أم لا ، يمكن للمرء أن يخمن فقط. <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3102</a> وصول مشبوه إلى عنصر 'x' بواسطة فهرس ثابت داخل حلقة.  DataEngine.cs 1718 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ObjectArrayComparer</span></span> : <span class="hljs-title"><span class="hljs-title">IEqualityComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>[]&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] y</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[<span class="hljs-number"><span class="hljs-number">0</span></span>], y[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return false; } } return true; } .... }</span></span></code> </pre> <br>  في كل تكرار في الحلقة ، يقارن المبرمج <i>x [0]</i> و <i>y [0].</i>  ومع ذلك ، فإن الحلقة لا معنى لها في هذا الرمز ، حيث تتم مقارنة العناصر الأولى فقط.  على الأرجح ، كان هذا يعني مقارنة العناصر المقابلة للصفائف.  ثم سيكون الرمز الصحيح مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[i], y[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3123</a> ربما يعمل المشغل '؟: بطريقة مختلفة عما كان متوقعًا.  أولويتها أقل من أولوية المشغلين الآخرين في حالتها.  EditRowHostPanel.cs 35 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Size </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureOverride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Size availableSize</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> shouldUpdateRowHeight = editorLine == <span class="hljs-number"><span class="hljs-number">0</span></span> || displayedElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : displayedElement.ContainerType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DataGridGroupHeader); .... }</code> </pre> <br>  يرتبط التحذير باستخدام المشغل "؟:".  لها أولوية أقل من <i>! = ، || ، ==.</i>  لذلك ، قد لا يتم تقييم تعبير كما هو مخطط بواسطة المبرمج.  على ما يبدو ، في هذه الحالة ، هذه إشارة إيجابية خاطئة ويعمل الرمز بشكل صحيح.  لكن قراءة هذا الرمز صعب للغاية ولا يوجد أي يقين من أنه يتم فهمه بشكل صحيح.  يبدو أن المطور كتب بطريقة لا أحد يفهم أي شيء :) أفضل طريقة للقيام بذلك هي أكثر قابلية للقراءة - استخدم الأقواس أو <i>عبارة if</i> . <br><br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3078</a> سيتم فقد ترتيب الفرز الأصلي بعد استدعاء متكرر لأسلوب "OrderBy".  استخدم طريقة "ThenBy" للحفاظ على التصنيف الأصلي.  GridModel.Selection.cs 107 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GridModel</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildCellSelectionRegions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .OrderBy(c =&gt; c.RowItemInfo.LayoutInfo.Line)); } }</code> </pre> <br>  يرتبط الخطأ باستدعاء <i>OrderBy</i> مرة أخرى لمجموعة من النوع <i>IOrderedEnumerable</i> .  هنا يتم فرز المجموعة أولاً حسب الأعمدة ، ثم حسب الصفوف.  علاوة على ذلك ، في وقت الفرز حسب الصفوف ، لا يتم أخذ الفرز حسب الأعمدة في الاعتبار في أي مكان.  لكي لا تفقد الفرز حسب الأعمدة وفرز المجموعة حسب عدة معايير في وقت واحد ، ثم استخدم <i>ThenBy</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .ThenBy(c =&gt; c.RowItemInfo.LayoutInfo.Line));</code> </pre> <br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3008</a> يتم تعيين قيم " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">currentColumnLength</a> " مرتين على التوالي.  ربما هذا خطأ.  خطوط التحقق: 791 ، 785. WrapLayout.cs 791 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAvailableLengthChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumnLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paddingValue = Math.Max(<span class="hljs-number"><span class="hljs-number">0</span></span>, newValue - currentColumnLength); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.paddingRenderInfo.Add(paddingValue); currentColumnLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= slotCount++; } this.ColumnSlotsRenderInfo.Update(i, newValue); this.paddingRenderInfo.Add(0); currentColumnLength = 0; // &lt;= slotCount++; continue; } else { .... } .... }</span></span></code> </pre> <br>  بدا من المشكوك فيه للمحلل أنه تم تعيين متغير <i>currentColumnLength</i> قيمة مرتين.  لا يتم استخدام المتغير بين المهام.  بغض النظر عن الحالة ، فإن هذا المتغير سيكون في النهاية صفرًا.  هذا الرمز هو إما غير صحيح أو زائدة عن الحاجة. <br><br>  <b>PVS-Studio Warning</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3127</a> تم العثور على شظايا رمز مماثلة.  ربما ، هذا خطأ مطبعي ويجب استخدام متغير "blankIconContainer" بدلاً من RadRatingItem.cs 240 "fillIconContainer" <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadRatingItem</span></span> : <span class="hljs-title"><span class="hljs-title">RadContentControl</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnApplyTemplate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetTemplateChild( <span class="hljs-string"><span class="hljs-string">"FilledIconContainer"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Border; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { throw new MissingTemplatePartException( "FilledIconContainer", typeof(Border)); } this.emptyIconContainer = this.GetTemplateChild( "EmptyIconContainer") as Border; if (this.filledIconContainer == null) // &lt;= { throw new MissingTemplatePartException( "EmptyIconContainer", typeof(Border)); } this.Initialize(); } .... }</span></span></code> </pre> <br>  بسبب خطأ مطبعي ، ظهرت شرطين متطابقة في التعليمات البرمجية.  اذا حكمنا من خلال الاستثناء الذي تم إنشاؤه ، يجب أن يكون الشرط الثاني كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emptyIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MissingTemplatePartException( <span class="hljs-string"><span class="hljs-string">"EmptyIconContainer"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Border)); }</code> </pre> <br>  <b>تحذير PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3020</a> "انقطاع" غير مشروط داخل حلقة.  NodePool.cs 189 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt;&gt; GetUnfrozenDisplayedElements() { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generatedContainers) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> item.Value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pair.IsFrozen) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> <br>  وجد المحلل أن بيان <i>الاستراحة</i> هنا لا ينتمي إلى <i>عبارة if</i> .  سيتم تنفيذ <i>Break</i> بغض النظر عن قيمة <i>الزوج. إذا تم تجميده</i> وبسبب هذا في <i>foreach</i> ، سيتم تنفيذ تكرار واحد فقط. <br><br>  أن أختتم نظرتي في التحذيرات.  حتى يتمكن مطورو Telerik من إجراء تحليل أكمل للشفرات وإصلاح العيوب ، نحن على استعداد لتزويدهم بترخيص مؤقت.  بالإضافة إلى ذلك ، يمكنهم الاستفادة من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الاستخدام المجاني</a> لخيار <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PVS-Studio</a> المقدم لمؤلفي المشروعات المفتوحة المصدر. <br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  على الرغم من قيام مطوري Telerik UI لـ UWP بعمل رائع ، إلا أنه لم يكن بدون أخطاء مطبعية ، كما يحدث عادةً :).  يمكن بسهولة العثور على كل هذه الأخطاء من قبل محلل ثابت وتصحيحها.  الشيء الأكثر أهمية هو استخدام محلل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بشكل صحيح ومنتظم</a> . <br><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  إذا كنت ترغب في مشاركة هذه المقالة مع جمهور يتحدث الإنجليزية ، فالرجاء استخدام الرابط الخاص بالترجمة: Ekaterina Nikiforova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فحص Telerik UI لـ UWP كطريقة للبدء باستخدام PVS-Studio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar470584/">https://habr.com/ru/post/ar470584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar470570/index.html">GridmiAPI - مكتبة Android بسيطة ومرنة للعمل مع REST & RPC</a></li>
<li><a href="../ar470572/index.html">"أتمتة البنية التحتية. لماذا نفعل هذا؟ " (دينيس ياكوفليف)</a></li>
<li><a href="../ar470576/index.html">ستتخلص بنوك أمريكا في السنوات القادمة من 200000 وظيفة</a></li>
<li><a href="../ar470578/index.html">كيف "أنسنة" مسك الدفاتر في بنك للهاتف المحمول</a></li>
<li><a href="../ar470582/index.html">فحص Telerik UI لـ UWP كطريقة للبدء باستخدام PVS-Studio</a></li>
<li><a href="../ar470592/index.html">استعراض Plesk - استضافة ومراقبة لوحات الموقع</a></li>
<li><a href="../ar470594/index.html">تقرير من المعرض الضوئي "دائرة الضوء" 2019 في موسكو</a></li>
<li><a href="../ar470596/index.html">ميزات Q و KDB + على مثال خدمة في الوقت الحقيقي</a></li>
<li><a href="../ar470598/index.html">كتاب "جافا الحديثة. تعبيرات Lambda ، والجداول ، والبرمجة الوظيفية "</a></li>
<li><a href="../ar470600/index.html">حول لوحات التحكم الآمنة في noVNC ، إجراء الفحص الذاتي في Kubernetes ، Haproxy في Ostrovka وعمل المشرفين مع المبرمجين</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>