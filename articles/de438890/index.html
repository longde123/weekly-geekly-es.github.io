<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé® üë©‚Äçüë¶ üê™ Postgres im Nachhinein ‚ô®Ô∏è üëâüèæ üëèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir machen Sie auf eine √úbersetzung von Joseph Hellersteins Artikel ‚ÄûR√ºckblick auf Postgres‚Äú aufmerksam , der unter der Creative Copyright Internation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres im Nachhinein</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Wir machen Sie auf eine √úbersetzung von <strong>Joseph Hellersteins</strong> Artikel <strong>‚ÄûR√ºckblick auf Postgres‚Äú aufmerksam</strong> , der unter der Creative <strong>Copyright</strong> International <strong>Copyright Affirmation</strong> Version 4.0 (CC-BY 4.0) ver√∂ffentlicht wurde.</em>  <em>Die Autoren behalten sich das Recht vor, diese Arbeit auf pers√∂nlichen und Unternehmenswebsites mit einem ordnungsgem√§√üen Link zur Quelle zu verbreiten.</em> <br><br>  <em>√úbersetzung von Elena Indrupskaya.</em>  <em>Ich m√∂chte von mir selbst hinzuf√ºgen, dass "ein Programmierer, der unbedingt ein System mit Multi-Versionierung bauen wollte" Vadim Mikheev zu sein scheint, aber wir alle kennen die "Freiwilligen aus Russland", die GiST neu geschrieben haben.</em> <br><br><h1>  Anmerkung </h1><br>  Dies ist eine Erinnerung an das Postgres-Projekt, das an der University of California in Berkeley durchgef√ºhrt wurde und von Mitte der 1980er bis Mitte der 1990er Jahre von Mike Stonebraker geleitet wurde.  Als eine von vielen pers√∂nlichen und historischen Erinnerungen wurde dieser Artikel f√ºr das Buch [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bro19</a> ] √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stonebreakers</a> Turing Award angefordert.  Daher liegt der Schwerpunkt des Artikels auf der Hauptrolle von Stonebreaker und seinen Gedanken zum Design.  Aber Stonebreaker war nie ein Programmierer und st√∂rte sein Entwicklungsteam nicht.  Die Postgres-Codebasis war die Arbeit eines Teams brillanter Studenten und gelegentlich hauptberuflicher Universit√§tsprogrammierer, die etwas mehr Erfahrung (und nur ein etwas h√∂heres Gehalt) als Studenten hatten.  Ich hatte das Gl√ºck, in den letzten Jahren des Projekts als Student diesem Team beizutreten.  Ich habe n√ºtzliches Material f√ºr diesen Artikel von einigen der √§lteren Studenten erhalten, die an dem Projekt beteiligt waren, aber alle Fehler oder Auslassungen sind meine.  Wenn Sie einen von ihnen bemerken, kontaktieren Sie mich bitte und ich werde versuchen, sie zu beheben. <br><a name="habracut"></a><br><h1>  1. Einleitung </h1><br>  Postgres war das ehrgeizigste Projekt von Michael Stonebreaker - sein ernsthafter Versuch, ein universelles Datenbanksystem zu schaffen.  Seit einem Jahrzehnt hat das Projekt mehr Artikel, Doktoranden, Professoren und Unternehmen hervorgebracht als jede andere Stonebreaker-Aktivit√§t.  Das Projekt deckte auch mehr technische Bereiche ab als jedes andere System, das er baute.  Trotz des inh√§renten Risikos dieser Gr√∂√üenordnung wurde Postgres auch das erfolgreichste Software-Artefakt, das aus den Forschungsteams von Stonebreaker hervorging, und sein Hauptbeitrag zu Open Source.  Dies ist ein Beispiel f√ºr ein erfolgreiches ‚Äûzweites System‚Äú [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bro75</a> ].  Zum Zeitpunkt des Schreibens, mehr als 30 Jahre seit Beginn des Projekts, ist das Open-Source-PostgreSQL-System das weltweit beliebteste unabh√§ngige Open-Source-Datenbanksystem und das viertbeliebteste Datenbanksystem.  Unternehmen, die aus Postgres gegr√ºndet wurden, erwirtschafteten insgesamt mehr als 2,6 Milliarden US-Dollar (Anschaffungskosten).  In jeder Hinsicht hatte die Vision des Postgres Stonebreaker eine enorme anhaltende Resonanz. <br><br><h2>  1.1.  Hintergrund </h2><br>  Stonebreaker war zu Beginn seiner Karriere ein gro√üer Erfolg mit dem Forschungsprojekt Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SHWK76</a> ] und dem anschlie√üenden Startup, das er zusammen mit Larry Rowe und Eugene Wong gr√ºndete: Relational Technology, Inc.  (RTI). <br><br>  Als sich RTI in den fr√ºhen 1980er Jahren entwickelte, begann Stonebreaker mit der Unterst√ºtzung von Datentypen in DBMS, die √ºber die traditionellen Zeilen und Spalten des urspr√ºnglichen relationalen Codd-Modells (Edgar Frank Codd) hinausgingen.  Ein motivierendes Beispiel war zu dieser Zeit die Notwendigkeit von Datenbanken zur Unterst√ºtzung von CAD-Werkzeugen (Computer Aided Design) f√ºr die mikroelektronische Industrie.  In einem Artikel von Stonebreaker und Studenten aus dem Jahr 1983 erkl√§rten Brad Rubenstein und Antonin Guttman, wie viel diese Branche ben√∂tigt, um ‚Äûneue Datentypen wie Polygone, Rechtecke, Textzeichenfolgen usw.‚Äú zu unterst√ºtzen. effektive r√§umliche Suche ‚Äú,‚Äû komplexe Integrit√§tsbeschr√§nkungen ‚Äúsowie‚Äû Entwurfshierarchien und Mehrfachdarstellungen ‚Äúin denselben physischen Strukturen [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SRG83</a> ].  Mit dieser Motivation begann die Gruppe mit der Indizierung (einschlie√ülich der Verwendung von Guttman-R-B√§umen f√ºr die r√§umliche Indizierung [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gut84</a> ]) und dem Hinzuf√ºgen abstrakter Datentypen (ADTs) zum relationalen Datenbanksystem.  Zu dieser Zeit waren ADTs ein beliebtes neues Design von Programmiersprachen, das zuerst von Barbara Liskov, sp√§ter Preistr√§gerin des Turing-Preises, eingef√ºhrt und von Lonely Rowe, einer neuen Mitarbeiterin bei Stonebreaker, in der Programmierung von Datenbankanwendungen untersucht wurde.  Ein Artikel in einem SIGMOD-Datensatz von 1983 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OFS83</a> ] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stonebreaker</a> und die Studenten James Ong und Dennis Fogg beschreiben eine Studie dieses Konzepts in der Ingres-Erweiterung ADT-Ingres, die viele der untersuchten Pr√§sentationskonzepte enth√§lt tiefer und mit besserer Systemunterst√ºtzung in Postgres. <br><br><h1>  2. Postgres: allgemeine Informationen </h1><br>  Wie der Name schon sagt, ist Postgres Post-Ingres: ein System, das entwickelt wurde, um das, was Ingres tun k√∂nnte, zu nutzen und dar√ºber hinauszugehen.  Eine Besonderheit von Postgres war die Einf√ºhrung der letztendlich objektrelationalen Eigenschaften der Datenbank: Unterst√ºtzung des Konzepts der objektorientierten Programmierung im Datenmodell und der deklarativen Abfragesprache des Datenbanksystems.  Stonebreaker plante jedoch auch, eine Reihe anderer technologischer Probleme unabh√§ngig von der objektorientierten Unterst√ºtzung in Postgres zu l√∂sen, z. B. aktive Datenbankregeln, versionierte Daten, terti√§rer Speicher und Parallelit√§t. <br><br>  Zwei Artikel wurden √ºber das Design von Postgres geschrieben: eine Beschreibung des fr√ºhen Designs von 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SR86</a> ] und eine Zwischenbeschreibung in CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SK91</a> ].  Das Postgres-Forschungsprojekt wurde 1992 mit der Gr√ºndung von Illustra, einem Startup-Startup, an dem Stonebreaker, der leitende Doktorand Wei Hong und sp√§ter Chefprogrammierer Jeff Meredith beteiligt waren, nach und nach zunichte gemacht.  In der folgenden Liste sind die im Artikel von 1986 genannten Gelegenheiten mit einem Sternchen * gekennzeichnet, und die Gelegenheiten aus dem Artikel von 1991, die nicht im Artikel von 1986 enthalten waren, sind mit einem Dolch <sup>‚Ä† gekennzeichnet</sup> .  Die anderen unten aufgef√ºhrten Aufgaben wurden in der System- und Forschungsliteratur √ºbernommen, sind jedoch in keiner Entwurfsspezifikation enthalten.  Viele dieser Themen wurden bei Postgres behandelt, lange bevor sie von anderen untersucht oder neu erfunden wurden.  In vielen F√§llen war Postgres seiner Zeit zu weit voraus, und das Interesse an Themen stieg aus einer modernen Perspektive sp√§ter an. <br><br><ol><li>  ADT-Unterst√ºtzung im Datenbanksystem <br><ul><li>  Komplexe Objekte (d. H. Verschachtelte Daten oder nicht erste normale Formulardaten (nicht erste normale Form - NF2)) * </li><li>  Benutzerdefinierte abstrakte Datentypen und Funktionen * </li><li>  Erweiterbare Zugriffsmethoden f√ºr neue Datentypen * </li><li>  Optimierte Abfrageverarbeitung mit kostspieligen benutzerdefinierten Funktionen </li></ul></li><li>  Aktive Datenbanken und Regelsysteme (Trigger, Warnungen) * <br><ul><li>  Regeln, die als Umschreiben von Anforderungen implementiert wurden <sup>‚Ä†</sup> </li><li>  Regeln, die als Trigger f√ºr die Aufnahmeebene implementiert wurden <sup>‚Ä†</sup> </li></ul></li><li>  Protokollbasierte Speicherung und Wiederherstellung <br><ul><li>  Wiederherstellungscode mit reduzierter Komplexit√§t, der das Protokoll als Daten * behandelt und nichtfl√ºchtigen Speicher f√ºr den Festschreibungsstatus verwendet <sup>‚Ä†</sup> </li><li>  Nicht umgeschriebener Speicher und zeitliche Abfragen <sup>‚Ä†</sup> </li></ul></li><li>  Unterst√ºtzung f√ºr neue Deep-Storage-Technologien, insbesondere optische Festplatten * </li><li>  Unterst√ºtzung f√ºr Multiprozessoren und spezialisierte Prozessoren * </li><li>  Unterst√ºtzung f√ºr verschiedene Sprachmodelle <br><ul><li>  Minimale √Ñnderungen am relationalen Modell und Unterst√ºtzung f√ºr deklarative Abfragen * </li><li>  Zugriff auf den ‚ÄûFast Track‚Äú √ºber interne APIs unter Umgehung der Abfragesprache <sup>‚Ä†</sup> </li><li>  Mehrsprachigkeit <sup>‚Ä†</sup> </li></ul></li></ol><br>  Wir werden kurz den Beitrag von Postgres f√ºr jeden dieser Punkte in Bezug auf sp√§tere Arbeiten auf dem Gebiet der Datenverarbeitung diskutieren. <br><br><h2>  2.1.  ADT-Unterst√ºtzung im Datenbanksystem </h2><br>  Das klare Ziel von Postgres bestand darin, neue objektrelationale Eigenschaften zu unterst√ºtzen: Erweiterung der Datenbanktechnologie, um die Vorteile sowohl der relationalen Abfrageverarbeitung als auch der objektorientierten Programmierung zu nutzen.  Im Laufe der Zeit wurde das objektrelationale Konzept, das erstmals in Postgres erschien, zur Standardfunktionalit√§t in den meisten modernen Datenbanksystemen. <br><br><h3>  2.1.1.  Komplexe Objekte </h3><br>  Sehr oft werden Daten als verschachtelte Entit√§ten oder ‚ÄûObjekte‚Äú dargestellt.  Ein klassisches Beispiel ist eine Bestellung, in die eine Reihe von Produkten, deren Mengen und Preise eingebettet sind.  Die Religion der relationalen Modellierung schrieb vor, dass solche Daten in einem Format ohne Verschachtelung umstrukturiert und gespeichert werden sollten, wobei mehrere flache Objekttabellen (Bestellungen, Produkte) mit verbindenden flachen Beziehungstabellen (product_in_order) verwendet wurden.  Ein typischer Grund f√ºr diese Abflachung ist die Verringerung der Datenverdoppelung (da das Produkt in vielen Bestellungen redundant beschrieben wird), wodurch die Komplexit√§t oder Fehler beim Aktualisieren aller redundanten Kopien vermieden werden.  In einigen F√§llen m√∂chten Sie jedoch die Unteransicht beibehalten, da dies f√ºr die Anwendung selbstverst√§ndlich ist (z. B. der Layoutmechanismus der Schaltung in CAD) und Aktualisierungen selten sind.  Diese Debatte √ºber Datenmodellierung ist mindestens so alt wie das relationale Modell. <br><br>  Der Hauptansatz von Postgres bestand darin, in Bezug auf die Datenmodellierung auf zwei St√ºhlen zu sitzen: Postgres speicherte Tabellen als den ‚Äûexternesten‚Äú Datentyp, erlaubte jedoch Spalten, ‚Äûkomplexe‚Äú Typen zu haben, einschlie√ülich verschachtelter Tupel oder Tabellen.  Eine der weniger verbreiteten Implementierungen, die erstmals im ADT-Ingres-Prototyp untersucht wurde, bestand darin, die deklarative Deklaration einer Tabellentypspalte als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfragedefinition</a> zu erm√∂glichen: "Quel als Datentyp" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAHR84</a> ] <em>(Quel - Ingres Query Language - Ca. .)</em> . <br><br>  Das ‚Äûpostrelationale‚Äú Thema der Unterst√ºtzung sowohl f√ºr deklarative Abfragen als auch f√ºr eingebettete Daten ist im Laufe der Jahre wieder aufgetaucht, h√§ufig durch Streitigkeiten dar√ºber, welche besser sind.  W√§hrend der Zeit von Postgres in den 1980er und 1990er Jahren haben einige Gruppen, die an objektorientierten Datenbanken beteiligt waren, diese Idee aufgegriffen und zur Standard-OQL-Sprache weiterentwickelt, die dann nicht mehr verwendet wurde. <br><br>  Um die Jahrtausendwende wurden deklarative Abfragen zu verschachtelten Objekten zu einer Besessenheit der Forschung f√ºr das Segment der Community von Datenbankentwicklern in Form von XML-Datenbanken.  Die resultierende XQuery-Sprache (angef√ºhrt von Don Chamberlin, der Person von SQL) ist erforderlich, um komplexe Objekte in der Postgel-Sprache von Postgres zu unterst√ºtzen.  XQuery ist in der Industrie weit verbreitet und weit verbreitet, war jedoch bei Benutzern noch nie beliebt.  Heute werden diese Konzepte in Abfragesprachenprojekten f√ºr das in Browseranwendungen beliebte JSON-Datenmodell erneut untersucht.  Wie bei OQL treten diese Sprachen in Gruppen, die zun√§chst deklarative Abfragen zugunsten einer entwicklerorientierten Programmierung ablehnten (die ‚ÄûNoSQL‚Äú -Bewegung), h√§ufig als sp√§te Erg√§nzung nur aus dem Wunsch heraus auf, dem System wieder Abfragen hinzuzuf√ºgen.  Zur gleichen Zeit, als Postgres im Laufe der Jahre wuchs (und von der Postquel-Abfragesprache zu SQL-Versionen wechselte, die viele der betrachteten Ziele erf√ºllen), wurde eingebettete Daten wie XML und JSON in Allzweck-DBMS unterst√ºtzt, ohne dass dies erforderlich war oder signifikante Neugestaltung.  Kontroversen laufen mit unterschiedlichem Erfolg, und der Ansatz von Postgres, die relationale Struktur mithilfe von Erweiterungen f√ºr verschachtelte Daten zu erweitern, hat sich nach dem Abklingen der Argumente wiederholt als nat√ºrlicher Endzustand f√ºr alle Parteien erwiesen. <br><br><h3>  2.1.2.  Benutzerdefinierte abstrakte Datentypen und Funktionen </h3><br>  Postgres schlug nicht nur verschachtelte Typen vor, sondern brachte auch die Idee vor, undurchsichtige, erweiterbare ADTs einzuf√ºhren, die in der Datenbank gespeichert, aber vom Kernel nicht interpretiert werden.  Grunds√§tzlich war dies immer Teil des relationalen Modells von Codd: Ganzzahlen und Zeichenfolgen waren traditionell, aber tats√§chlich umfasst das relationale Modell jeden atomaren Datentyp mit Pr√§dikaten.  Die Aufgabe bestand darin, eine solche mathematische Flexibilit√§t in der Software bereitzustellen.  Um Abfragen zu verwenden, die diese Objekte interpretieren und bearbeiten, muss ein Anwendungsprogrammierer in der Lage sein, benutzerdefinierte Funktionen (UDFs) f√ºr diese Typen im System zu registrieren und diese Funktionen in Abfragen aufzurufen.  Es ist auch w√ºnschenswert, dass benutzerdefinierte Aggregatfunktionen (UDA) die Sammlungen dieser Objekte in Abfragen zusammenfassen.  Das Postgres-Datenbanksystem war innovativ und unterst√ºtzte diese Funktionen umfassend. <br><br>  Warum sollten solche Funktionen in ein DBMS und nicht in Anwendungen auf hoher Ebene integriert werden?  Die typische Antwort auf diese Frage war ein wesentlicher Vorteil f√ºr die Leistung des auf den Daten platzierten Codes gegen√ºber dem ‚ÄûZiehen‚Äú der Daten in den Code.  Postgres hat gezeigt, dass dies in einer relationalen Umgebung ganz nat√ºrlich ist: Im relationalen Metadatenkatalog waren nur geringf√ºgige √Ñnderungen erforderlich, und es wurden Code-Aufrufmechanismen von Drittanbietern erstellt, aber die Abfragesyntax, die Semantik und die Systemarchitektur funktionierten einfach und elegant. <br><br>  Postgres ist seiner Zeit bei der Erforschung dieser Funktionalit√§t etwas voraus.  Zu dieser Zeit war die Datenbankforschungsgemeinschaft insbesondere nicht besonders besorgt √ºber die Sicherheitsauswirkungen des Herunterladens von unsicherem Code auf den Server.  Dies wurde als Problem wahrgenommen, als die Technologie in der Branche wahrgenommen wurde.  Stonebreaker brachte Postgres in seinem Startup Illustra auf den Markt, das Informix in hohem Ma√üe f√ºr seine F√§higkeit zur Unterst√ºtzung von DataBlade-Erweiterungspaketen, einschlie√ülich UDF, erworben hat.  Informix ist mit seiner Postgres-basierten Technologie und seinem starken Angebot an parallelen Datenbanken zu einer erheblichen Bedrohung f√ºr Oracle geworden.  Oracle hat stark in die negative Vermarktung der Risiken investiert, die mit der F√§higkeit von Informix verbunden sind, "unsicheren" Benutzer-C-Code auszuf√ºhren.  Einige f√ºhren den Tod von Informix auf diese Kampagne zur√ºck, obwohl der Finanzbetrug von Informix (und die anschlie√üende Strafverfolgung des damaligen CEO durch den Bund) sicherlich schwerwiegendere Probleme aufwirft.  Jetzt, Jahrzehnte sp√§ter, unterst√ºtzen alle gro√üen Datenbankanbieter benutzerdefinierte Funktionen in einer oder mehreren Sprachen und verwenden neue Technologien, um sich vor Serverabst√ºrzen oder Datenkorruption zu sch√ºtzen. <br><br>  Die Technologie-Stacks der Big Data der 2000er Jahre, einschlie√ülich des MapReduce-Ph√§nomens, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stonebreaker</a> und David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DS08</a> ] ‚Äûviel Blut verdorben‚Äú hat, sind eine Neuimplementierung der Idee von Postgres - Benutzercode, der in die Anfrage aufgenommen wurde.  Es scheint, dass MapReduce Postgres-Softwareentwicklungsideen weitgehend mit Parallelit√§tsideen von Systemen wie Gamma und Teradata kombiniert, mit einigen geringf√ºgigen Neuerungen beim Neustart des Abfrageprozesses f√ºr Workloads mit extremer Skalierbarkeit.  Startups, die auf Postgres, Greenplum und Aster basierten, zeigten um 2007, dass die Parallelisierung von Postgres f√ºr die meisten Kunden zu etwas viel Funktionalerem und Praktischerem als MapReduce f√ºhren kann, aber 2008 war der Markt noch nicht f√ºr diese Technologie bereit. .  Mittlerweile, im Jahr 2018, verarbeitet fast jeder Big-Data-Stack im Wesentlichen die parallele SQL-Workload mit UDF, was dem Design sehr √§hnlich ist, das Stonebreaker und das Team erstmals in Postgres verwendet haben. <br><br><h3>  2.1.3.  Erweiterbare Zugriffsmethoden f√ºr neue Datentypen </h3><br>  Relationale Datenbanken wurden ungef√§hr zur gleichen Zeit wie B-B√§ume in den fr√ºhen 1970er Jahren entwickelt, und B-B√§ume gaben Codd einen Traum von ‚ÄûUnabh√§ngigkeit von der physischen Datenspeicherung‚Äú: Die Indizierung mit B-B√§umen bietet eine Indirektionsebene, die Reorganisiert den physischen Speicher adaptiv, ohne dass Anwendungs√§nderungen erforderlich sind.  Die Hauptbeschr√§nkung von B-B√§umen und den damit verbundenen Strukturen bestand darin, dass sie nur Gleichheitssuche und Abfragen im eindimensionalen Bereich unterst√ºtzen.  Was aber, wenn Sie zweidimensionale Bereichsabfragen haben, die f√ºr Mapping- und CAD-Anwendungen typisch sind?  Dieses Problem war bei Postgres bekannt, und der von Antonin Guttman in der Stonebreaker-Gruppe entwickelte R-Baum [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gut84</a> ] war einer der erfolgreichsten neuen Indizes, mit denen dieses Problem in der Praxis gel√∂st werden konnte.  Die Erfindung der Indexstruktur l√∂st jedoch nicht das Problem der Unterst√ºtzung mehrdimensionaler Bereiche in einem DBMS f√ºr komplexe Systeme.  Es gibt viele Fragen.  K√∂nnen Sie Ihrem DBMS problemlos eine Zugriffsmethode wie R-B√§ume hinzuf√ºgen?  K√∂nnen Sie dem Optimierer beibringen, zu verstehen, dass die angegebene Zugriffsmethode f√ºr bestimmte Abfragen n√ºtzlich ist?  K√∂nnen Sie eine korrekte Wiederherstellung und gleichzeitigen Zugriff erreichen?  Dies war ein sehr k√ºhner Punkt im Postgres-Aktionsplan: Ein Problem mit der Softwarearchitektur, das den gr√∂√üten Teil des Datenbankmoduls betrifft, vom Optimierer √ºber die Speicherebene bis hin zum Journal- und Wiederherstellungssystem.  Postgres-R-B√§ume sind zu einer starken treibenden Kraft geworden und ein Paradebeispiel f√ºr die elegante Erweiterbarkeit der Zugriffsmethodenschicht und ihre Integration in den Abfrageoptimierer.  Postgres zeigte mit einem undurchsichtigen ADT, wie eine abstrakt beschriebene Zugriffsmethode (in diesem Fall ein R-Baum) registriert wird und wie ein Abfrageoptimierer ein abstraktes Auswahlpr√§dikat (in diesem Fall eine Bereichsauswahl) erkennen und mit dieser abstrakt beschriebenen Zugriffsmethode abgleichen kann.  Bei der ersten Arbeit wurde der gleichzeitigen Zugangskontrolle weniger Aufmerksamkeit geschenkt: Das Fehlen einer eindimensionalen Reihenfolge der Schl√ºssel machte das in B-B√§umen verwendete Schloss in diesem Fall nicht anwendbar. <br><br>  <em>Die vielversprechenden Eigenschaften der erweiterbaren Zugriffsmethoden von Postgres inspirierten eines meiner ersten Forschungsprojekte am Ende der Graduiertenschule: Generalisierte Suchb√§ume - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HNP95</a> ] und das nachfolgende Konzept der Indizierungstheorie [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>Nach meiner Promotion habe ich GiST f√ºr ein Semester in Postgres implementiert, was das Hinzuf√ºgen der neuen Indexierungslogik zu Postgres noch einfacher machte.</em>  <em>Die Dissertation von Marcel Kornacker aus Berkeley (Marcel Kornacker) l√∂ste die komplexen Probleme der Wiederherstellung und des gleichzeitigen Zugriffs, die sich aus dem erweiterbaren "Template" -Typ des Index GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KMH97</a> ] ergeben.</em> <br><br>  Heute kombiniert PostgreSQL die urspr√ºngliche Softwarearchitektur erweiterbarer Zugriffsmethoden (mit B-Tree-, GiST-, SP-GiST- und Gin-Indizes) auf vorteilhafte Weise mit der Erweiterbarkeit und dem intensiven Wettbewerbszugriff der Generalized Search Tree Interface (GiST).  GiST-Indizes unterst√ºtzen das beliebte PostGIS-Geoinformationssystem, das auf PostgreSQL basiert.  Gin-Indizes bieten Unterst√ºtzung f√ºr die interne Textindizierung in PostgreSQL. <br><br><h3>  2.1.4.  Abfrageoptimierer mit teuren UDFs </h3><br>  Bei der herk√∂mmlichen Abfrageoptimierung bestand die Aufgabe darin, die Menge des Tupelstroms (und damit der E / A-Operationen) zu minimieren, die bei der Verarbeitung der Anforderung erstellt wurden.  Dies bedeutete, dass Anweisungen, die Tupel filtern (abrufen), zu Beginn des Abfrageplans gut sind, w√§hrend Anweisungen, die neue Tupel generieren (verbinden), sp√§ter ausgef√ºhrt werden m√ºssen.  Infolgedessen "pushen" Abfrageoptimierer die Abrufoperatoren unter die Verbindungen und ordnen sie zuf√§llig an, wobei sie sich stattdessen auf die clevere Optimierung von Verbindungen und Festplattenzugriffen konzentrieren.  UDFs haben den Ansatz ge√§ndert: Wenn Ihre Beispielanweisungen teure UDFs enthalten, kann die Ausf√ºhrungsreihenfolge der UDFs f√ºr die Optimierung der Leistung von entscheidender Bedeutung sein.  Wenn die UDF im Auswahloperator wirklich viel Zeit in Anspruch nimmt, ist es au√üerdem m√∂glich, dass die Auswahl nach den Verbindungen durchgef√ºhrt wird (dh die Auswahl sollte "Pull-up" - Auswahl "Pull-up" sein).  Die Ber√ºcksichtigung dieser Faktoren hat den Suchraum f√ºr den Optimierer kompliziert.  Ich nahm dieses Problem als die erste schwierige Aufgabe in der Graduiertenschule und es war schlie√ülich Gegenstand meiner Masterarbeit bei Stonebreaker in Berkeley und meiner Promotion in Wisconsin unter der Leitung von Jeff Naughton, aber mit der st√§ndigen Hilfe von Stonebreaker.  Postgres war das erste DBMS, das die Kosten und die Selektivit√§t benutzerdefinierter Funktionen in einem Datenbankverzeichnis speicherte.  Wir n√§herten uns dem Optimierungsproblem, nachdem wir die optimale Reihenfolge der Abtastoperationen und dann die optimale Abwechslung der Abtastoperationen entlang der Zweige jedes Verbindungsbaums gefunden hatten, die bei der Plansuche ber√ºcksichtigt wurden.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      ¬´ ¬ª .</em> <br><br><h2>  2.2.       </h2><br>  Postgres                   .       :  ,      ¬´  ¬ª,     1990- . <br><br>              .  ‚Äî         Datalog.   ¬´  ¬ª  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog ‚Äî     ¬´ ¬ª     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    ‚Äî     .      ,      Ingres.      ¬´   ¬ª   ¬´       ¬ª. ,   ¬´      ¬ª     ¬´    10%¬ª.     ,     ¬´   ¬ª,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          ¬´¬ª ‚Äî      .            PostgreSQL,     -           . <br><br>   Postgres          ¬´  ¬ª     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    ¬´  ¬ª:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2> 2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log ‚Äî WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , ‚Äî     ¬´  ¬ª  ¬´  ¬ª      .   ,  , ‚Äî         .     ,    ¬´¬ª       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sto87</a> ].    Postgres   . <br><br>    ¬´ ¬ª           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       ¬´ ¬ª.  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)‚Äî    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB ‚Äî main memory databases,        ).              ,            .  ,             . <br><br><h2> 2.4.           </h2><br>  Mitten im Postgres-Projekt hat sich Stonebreaker als einer der F√ºhrungskr√§fte f√ºr ein gro√ües Stipendium f√ºr digitale Landwissenschaften namens Project Sequoia angemeldet.  Ein Teil des Zuschussvorschlags war die Verarbeitung beispielloser Mengen digitaler Satellitenbilder, die bis zu 100 Terabyte Speicher ben√∂tigten, d. H. Eine viel gr√∂√üere Datenmenge, als es zu diesem Zeitpunkt sinnvoll w√§re, sie auf Magnetplatten zu speichern.  Die Grundlage der vorgeschlagenen L√∂sung bestand darin, die Idee der Erstellung eines DBMS (Postgres) zu untersuchen, das den Zugriff auf den halbautonomen ‚Äûterti√§ren‚Äú Speicher erleichtert, der von Roboterlaufwerken mit automatischem Plattenwechsel f√ºr die Verwaltung von optischen Platten- oder Bandbibliotheken bereitgestellt wird. <br><br>  Dies f√ºhrte zu verschiedenen Studien.  Eines davon war das Inversion-Dateisystem - ein Versuch, eine Abstraktion des UNIX-Dateisystems √ºber ein relationales DBMS bereitzustellen.  In einem √úbersichtsartikel f√ºr Sequoia beschrieb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stonebreaker</a> dies in seiner √ºblichen Art, ‚Äûeinfache √úbung‚Äú zu bevormunden [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sto95</a> ].  Tats√§chlich ist Mike Olson, ein Student bei Stonebreaker (und der sp√§tere Gr√ºnder von Cloudera), seit mehreren Jahren damit besch√§ftigt, und das Endergebnis war nicht sehr einfach [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ols93</a> ] und √ºberlebte in der Praxis nicht. <br><br>  <em>Einige Jahre sp√§ter k√§mpfte Inversion Bill Gates in WinFS gegen ‚Äûdieselben Windm√ºhlen‚Äú - ein Versuch, das weltweit am h√§ufigsten verwendete Dateisystem √ºber das Back-End einer relationalen Datenbank wiederherzustellen.</em>  <em>WinFS wurde in Entwicklungsversionen von Windows ausgeliefert, kam jedoch nie auf den Markt.</em>  <em>Gates nannte es sp√§ter seine gr√∂√üte Entt√§uschung bei Microsoft.</em> <br><br>  Ein weiterer Forschungsschwerpunkt auf diesem Gebiet war die Aufnahme eines terti√§ren Repositorys in den Stapel typischerer relationaler Datenbanken, der Gegenstand einer Doktorarbeit von Sunita Sarawagi war.  Das Hauptthema bestand darin, den Ma√üstab zu √§ndern, in dem Sie Speicherplatz (d. H. Daten im Speicher und die Hierarchie des Speichers) und Zeit (Koordination der Abfrageplanung und des Cache zur Minimierung unerw√ºnschter E / A) verwalten m√∂chten.  Eines der Hauptprobleme in dieser Arbeit bestand darin, gro√üe mehrdimensionale Arrays in einem Terti√§rspeicher zu speichern und abzurufen, was die Arbeit auf dem Gebiet der mehrdimensionalen Indizierung widerspiegelt.  Zu den Schl√ºsselideen geh√∂rten das Teilen des Arrays in Teile und das Zusammenspeichern der Teile, die zusammen ausgew√§hlt wurden, sowie das Replizieren der Teile, so dass der Datenteil mehrere physische ‚ÄûNachbarn‚Äú haben kann.  Das zweite Problem besteht darin, dar√ºber nachzudenken, wie die Festplatte zu einem Cache f√ºr den terti√§ren Speicher wird.  Schlie√ülich sollten bei der Abfrageoptimierung und -planung die lange Ladezeit von Daten aus dem Terti√§rspeicher und die Bedeutung von Treffern (Treffern) des Plattencaches ber√ºcksichtigt werden.  Dies wirkt sich sowohl auf den vom Abfrageoptimierer ausgew√§hlten Plan als auch auf die Zeit aus, die zum Abschlie√üen des Plans erforderlich ist. <br><br>  Roboter auf B√§ndern und optischen Discs sind derzeit nicht weit verbreitet.  Terti√§re Speicherprobleme sind jedoch in der Cloud sehr h√§ufig, die 2018 eine tiefe Speicherhierarchie aufweist: von angeschlossenen SSDs √ºber zuverl√§ssige festplatten√§hnliche Speicherdienste (z. B. AWS EBS) bis hin zu Archivspeicher (z. B. in AWS S3) und Deep Storage (z. B.) , AWS-Gletscher).  Diese Speicherebenen sind heute noch relativ getrennt, und √úberlegungen zur End-to-End-Speicherung, die diese Ebenen umfasst, werden von der Datenbank praktisch nicht unterst√ºtzt.  Es w√ºrde mich nicht wundern, wenn die an dieser Front in Postgres untersuchten Fragen bald √ºberpr√ºft werden. <br><br><h2>  2.5.  Multiprozessor-Unterst√ºtzung: XPRS </h2><br>  Stonebreaker hat nie ein gro√ües paralleles Datenbanksystem erstellt, aber er hat viele herausfordernde Diskussionen in diesem Bereich gef√ºhrt.  Sein Artikel ‚ÄûCase for Shared Nothing‚Äú [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sto86</a> ] dokumentierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√ümodulare</a> Architekturl√∂sungen in diesem Bereich.  Er popularisierte die in der Branche verwendete Terminologie und verwirrte die Unterst√ºtzung von Architekturen ohne gemeinsame Ressourcen wie Gamma und Teradata, die in den 2000er Jahren von der Big-Data-Community wiederentdeckt wurden. <br><br>  Ironischerweise war Stonebreakers wichtigster Beitrag auf dem Gebiet der parallelen Datenbanken die "Shared Memory" -Architektur namens XPRS, was "eXtended Postgres on RAID and Sprite" bedeutete.  In den fr√ºhen neunziger Jahren war XPRS die ‚ÄûLiga der Gerechtigkeit‚Äú f√ºr Berkeley-Systeme: Es kombiniert das abgek√ºrzte Postgres Stonebreaker-System, John Ousterhout, das verteilte Sprite-Betriebssystem sowie die RAID-Architektur von Dave Patterson und Randy Katz )  Wie bei vielen fakult√§ts√ºbergreifenden Jobs wurde die Umsetzung des XPRS-Projekts tats√§chlich von den Doktoranden bestimmt, die daran gearbeitet haben.  Es stellte sich heraus, dass der Hauptbeitrag von Wei Hong geleistet wurde, der seine Doktorarbeit √ºber die Optimierung paralleler Abfragen in XPRS verfasste.  Daher bestand der Hauptbeitrag von XPRS zur Literatur und Industrie darin, gleichzeitige Anforderungen zu optimieren, ohne die mit RAID oder Sprite verbundenen Probleme wesentlich anzugehen. <br><br>  <em>Von diesen drei Projekten hatten Postgres und RAID einen gro√üen Einfluss auf die Zukunft.</em>  <em>Sprite wird am besten von Mendel Rosenblums Dissertation √ºber log strukturierte Dateisysteme (LFS) in Erinnerung behalten, die nichts Bemerkenswertes mit verteilten Betriebssystemen zu tun hatte.</em>  <em>Alle drei Projekte enthielten neben der √Ñnderung einzelner Kopien neue Ideen f√ºr die Speicherung von Datentr√§gern.</em>  <em>LFS und der Postgres-Repository-Manager sind sich in ihrer neuen Behandlung des Journals als prim√§res Repository und der Notwendigkeit einer kostspieligen Hintergrundreorganisation ziemlich √§hnlich.</em>  <em>Einmal habe ich den Steinbrecher sorgf√§ltig nach der Rivalit√§t zwischen LFS und Postgres oder den akademischen "gebratenen Fakten" √ºber ihre Beziehung untersucht, aber ich habe nie etwas Interessantes von ihm gelernt.</em>  <em>Vielleicht r√ºhrte damals in Berkeley jemand "Wasser auf".</em> <br><br>  Im Prinzip "explodiert" die Parallelit√§t den Raum der Abfrageoptimierungspl√§ne und multipliziert die traditionellen Entscheidungen, die w√§hrend der Abfrageoptimierung getroffen wurden (Datenzugriff, Verbindungsalgorithmen, Verbindungsreihenfolge), mit allen m√∂glichen M√∂glichkeiten zur Parallelisierung jeder Auswahl.  Die Hauptidee des von Stonebreaker aufgerufenen ‚ÄûWei Hong-Optimierers‚Äú bestand darin, das Problem in zwei Teile aufzuteilen: Starten Sie den herk√∂mmlichen Abfrageoptimierer im Geiste von System R f√ºr einen Knoten und ‚Äûparallelisieren‚Äú Sie den resultierenden Plan, indem Sie den Grad der Parallelit√§t und Platzierung jedes Operators basierend auf der Darstellung planen Daten- und Systemkonfiguration.  Dieser Ansatz ist heuristisch, aber gleichzeitig erh√∂ht die Parallelit√§t die Kosten der herk√∂mmlichen Abfrageoptimierung eher additiv als multiplikativ. <br><br>  Obwohl der Optimierer von Wei Hong im Kontext von Postgres entwickelt wurde, ist er zum Standardansatz f√ºr viele Optimierer f√ºr gleichzeitige Abfragen in der Branche geworden. <br><br><h2>  2.6.  Unterst√ºtzung f√ºr verschiedene Sprachmodelle </h2><br>  Zu den Interessen von Stonebreaker, die seit Ingres wiederholt erneuert wurden, geh√∂rte die API (Application System Programming Interface) des Datenbanksystems.  In seinen Vorlesungen in der Reihe "Datenbanksysteme" bezog er h√§ufig die GEM-Sprache Carlo Zaniolo als ein Thema ein, das f√ºr Bef√ºrworter von Datenbanksystemen wichtig ist.  Dieses Interesse an der Sprache f√ºhrte ihn zweifellos zu einer Partnerschaft mit Larry Rowe in Postgres, was wiederum das Design des Postgres-Datenmodells und seinen objektrelationalen Ansatz stark beeinflusste.  Ihre Arbeit konzentrierte sich haupts√§chlich auf Anwendungen f√ºr die Arbeit mit einem gro√üen Datenvolumen aus dem kommerziellen Bereich, einschlie√ülich der Verarbeitung von Gesch√§ftsinformationen und neuer Anwendungen wie CAD / CAM und GIS. <br><br>  Eines der Probleme, die Stonebreaker zu dieser Zeit auferlegt wurden, war die Idee, die Grenzen zwischen den Programmiersprachenkonstrukten und dem Datenbank-Repository zu ‚Äûverbergen‚Äú.  Verschiedene konkurrierende Forschungsprojekte und Unternehmen, die objektorientierte Datenbanken (OODBs) erforschen, haben den sogenannten ‚ÄûKonformit√§tsverlust‚Äú zwischen imperativen objektorientierten Programmiersprachen wie Smalltalk, C ++ und Java und deklarativen relationalen Daten zum Ziel Modell.  Die Idee von OODB war es, die Objekte der Programmiersprache auf Wunsch als "permanent" zu markieren und vom eingebauten DBMS automatisch zu verarbeiten.  Postgres unterst√ºtzte die Speicherung verschachtelter Objekte und abstrakter Datentypen, aber seine Schnittstelle, die auf deklarativen Abfragen in einem relationalen Stil basierte, nahm f√ºr den Programmierer einen unnat√ºrlichen Zugriff auf die Datenbank an (es erforderte die Verwendung deklarativer Abfragen), die ebenfalls teuer waren (Parsing und Optimierung).  Um mit OODB-Anbietern zu konkurrieren, stellte Postgres die sogenannte Fast Path-Schnittstelle zur Verf√ºgung: im Wesentlichen die C / C ++ - API f√ºr die interne Datenbankspeicherung.  Dies erm√∂glichte es Postgres, eine durchschnittliche Leistung im akademischen OODB-Benchmark zu erzielen, l√∂ste jedoch nie das Problem, dass Programmierer in verschiedenen Sprachen das Problem des Verlusts der Compliance vermeiden konnten.  Stattdessen bezeichnete Stonebreaker Postgres als ‚Äûobjektrelationales‚Äú Label und umging einfach die Verwendung objektorientierter Datenbanken als Null-Milliarden-Dollar-Markt.  Heutzutage sind fast alle kommerziellen relationalen Datenbanksysteme "objektrelationale" Datenbanksysteme. <br><br>  Dies stellte sich als vern√ºnftige L√∂sung heraus.  Heute existiert keines der OODB-Produkte in seiner beabsichtigten Form, und die Idee von "persistenten Objekten" in Programmiersprachen wurde weitgehend verworfen.  Im Gegensatz dazu ist die Verwendung von ORM-Ebenen (Object Relational Mapping) weit verbreitet, was auf fr√ºhe Arbeiten wie Java Hibernate und Ruby on Rails zur√ºckzuf√ºhren ist, die es erm√∂glichen, deklarative Datenbanken relativ reibungslos an nahezu jedes zwingende Objekt anzupassen. -orientierte Programmiersprache als Bibliotheken.  Dieser Ansatz auf Anwendungsebene unterscheidet sich sowohl von objektrelationalen OODB- als auch von Stonebreaker-Datenbanken.  Dar√ºber hinaus werden leichte Schl√ºsselwertspeicher sowohl in nicht-transaktionaler als auch in transaktionaler Form erfolgreich eingesetzt.  Ihre Entdeckerin war die Stonebreaker-Doktorandin Margo Seltzer, die im Rahmen ihrer Doktorarbeit gleichzeitig mit der Postgres-Gruppe an der Berkeley DB-Datenbank arbeitete und das Wachstum verteilter NoSQL-Schl√ºsselwert-Repositories wie Dynamo vorwegnahm , MongoDB und Cassandra. <br><br><h1>  3. Auswirkungen auf die Software </h1><br><h2>  3.1.  Open Source </h2><br>  Postgres war schon immer ein Open-Source-Projekt mit konsistenten Ver√∂ffentlichungen, aber am Anfang sollte es eher f√ºr die Forschung als f√ºr die Produktion verwendet werden. <br><br>  Als das Postgres-Forschungsprojekt eingeschr√§nkt wurde, modifizierten zwei Stonebreaker-Studenten, Andrew Yu und Jolly Chen, den Systemparser, um die urspr√ºngliche Postquel-Sprache durch eine erweiterbare SQL-Variante zu ersetzen.  Die erste Postgres-Version, die SQL unterst√ºtzt, war Postgres95, und die n√§chste hie√ü PostgreSQL. <br><br>  Ein Open-Source-Entwicklungsteam interessierte sich f√ºr PostgreSQL und ‚Äûakzeptierte‚Äú es, obwohl sich die Interessen des restlichen Berkeley-Teams √§nderten.  Das PostgreSQL-Kernteam ist im Laufe der Zeit relativ stabil geblieben, und das Open Source-Projekt hat sich stark entwickelt.  Urspr√ºnglich konzentrierten sich die Bem√ºhungen auf die Stabilit√§t des Codes und der Funktionalit√§t, die f√ºr den Benutzer sichtbar sind. Im Laufe der Zeit hat die Open-Source-Software-Community den Kern des Systems erheblich ver√§ndert und verbessert, vom Optimierer √ºber die Zugriffsmethoden bis hin zum Haupttransaktions- und Speichersystem.  Seit Mitte der neunziger Jahre stammte ein sehr kleiner Teil der internen Komponenten von PostgreSQL aus dem akademischen Team von Berkeley.  Ihr letzter Beitrag mag meine Implementierung von GiST in der zweiten H√§lfte der neunziger Jahre gewesen sein, aber selbst er wurde von Freiwilligen aus der Open-Source-Community (in diesem Fall Russland) grundlegend umgeschrieben und freigegeben.  Der Teil der Open Source-Community, der an PostgreSQL arbeitet, verdient das gr√∂√üte Lob f√ºr seinen optimierten Prozess, der seit Jahrzehnten dazu dient, ein hocheffizientes und langfristiges Projekt zu erstellen. <br><br>  Obwohl sich in 25 Jahren viel ge√§ndert hat, ist die zugrunde liegende PostgreSQL-Architektur den Ver√∂ffentlichungen der Postgres-Universit√§t in den fr√ºhen neunziger Jahren sehr √§hnlich, und Entwickler, die mit dem aktuellen PostgreSQL-Quellcode vertraut sind, werden es leicht finden, den Postgres 3.1-Quellcode (1991) zu lesen.  Alles von der Quellcode-Verzeichnisstruktur bis zu den Prozessstrukturen und Datenstrukturen bleibt √ºberraschend √§hnlich.  Der Code des Postgres-Teams in Berkeley hatte ein gro√üartiges R√ºckgrat. <br><br>  Heute ist PostgreSQL ohne Zweifel das leistungsst√§rkste Open-Source-Datenbankverwaltungssystem und unterst√ºtzt Funktionen, die in kommerziellen Produkten h√§ufig nicht zu finden sind.  Es ist auch (laut einer einflussreichen Bewertungsseite) das beliebteste unabh√§ngige Open-Source-DBMS der Welt, und sein Einfluss w√§chst weiter: In den Jahren 2017 und 2018 war es die Datenbank mit der am schnellsten wachsenden Popularit√§t der Welt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DE19c</a> ].  PostgreSQL wird in einer Vielzahl von Branchen und Aufgaben eingesetzt, was angesichts des Fokus auf zahlreiche M√∂glichkeiten nicht √ºberraschend ist. <br><br>  <em>Laut DB-Engines ist PostgreSQL heute nach Oracle, MySQL und MS SQL Server die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viertbeliebteste</a> Datenbank der Welt, die alle drei von bestimmten Unternehmen angeboten werden (MySQL wurde vor vielen Jahren von Oracle √ºbernommen) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DE19a</a> ].</em>  <em>Die Ranking-Regeln werden in der Beschreibung der Ranking-Methodik DB-Engines [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DE19b</a> ] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskutiert</a> .</em> <br><br>  Heroku ist der SaaS-Cloud-Anbieter, der jetzt Teil von Salesforce ist.  Postgres wurde 2010 in Heroku als Standarddatenbank f√ºr seine Plattform eingef√ºhrt.  Heroku entschied sich aus Gr√ºnden der Zuverl√§ssigkeit f√ºr Postgres.  Mit Heroku-Unterst√ºtzung empfahlen gr√∂√üere Anwendungsentwicklungsplattformen wie Ruby on Rails und Python for Django Postgres als Standarddatenbank. <br><br>  Heute unterst√ºtzt PostgreSQL eine Erweiterungsinfrastruktur, die es einfach macht, dem System zus√§tzliche Funktionen durch benutzerdefinierte Funktionen und damit verbundene √Ñnderungen hinzuzuf√ºgen.  Jetzt gibt es ein √ñkosystem von PostgreSQL-Erweiterungen, √§hnlich dem llustra-Konzept von DataBlade-Erweiterungspaketen, jedoch mit Open Source-Code.  Zu den interessantesten Erweiterungen geh√∂ren beispielsweise die Apache MADlib-Bibliothek f√ºr maschinelles Lernen in der SQL-Schnittstelle und die Citus-Bibliothek f√ºr die parallele Ausf√ºhrung von Abfragen. <br><br>  Eine der interessantesten Open-Source-Anwendungen, die auf Postgres basieren, ist das geografische PostGIS-Informationssystem, das viele der Postgres-Funktionen verwendet, die Stonebreaker urspr√ºnglich zum Start des Projekts inspiriert haben. <br><br><h2>  3.2.  Kommerzielle Implementierung </h2><br>  PostgreSQL ist seit langem ein attraktiver Ausgangspunkt f√ºr die Erstellung kommerzieller Datenbanksysteme, da es unter der Open-Source-Softwarelizenz ‚ÄûAllzul√§ssig‚Äú, zuverl√§ssigem Code, Flexibilit√§t und umfassender Funktionalit√§t verwendet wird.  Zusammenfassend sehen wir, dass Postgres Akquisitionskosten in H√∂he von mehr als 2,6 Milliarden US-Dollar erhalten hat. <br><br>  <em>Bitte beachten Sie, dass dies ein Ma√ü f√ºr reale Finanztransaktionen in US-Dollar ist und viel wichtiger ist als die Werte, die in der Hochtechnologie h√§ufig verwendet werden.</em>  <em>Zahlen in Milliarden werden h√§ufig verwendet, um den gesch√§tzten Wert von Aktienbl√∂cken zu beschreiben, werden jedoch in der Hoffnung auf ihre zuk√ºnftige Bedeutung h√§ufig um das Zehnfache oder mehr gegen√ºber dem Barwert √ºberbewertet.</em>  <em>Die Akquisitionstransaktionsdollar des Unternehmens messen den tats√§chlichen Marktwert zum Zeitpunkt der Akquisition.</em>  <em>Man kann mit Recht sagen, dass Postgres einen realen kommerziellen Wert von mehr als 2,6 Milliarden US-Dollar geschaffen hat.</em> <br><br>  Viele der mit PostgreSQL verbundenen kommerziellen Bem√ºhungen haben sich auf die wahrscheinlich gr√∂√üte Einschr√§nkung konzentriert: die M√∂glichkeit, auf eine parallele Architektur zu skalieren, ohne Ressourcen gemeinsam zu nutzen. <br><br>  <em>Die Parallelisierung von PostgreSQL erfordert eine Menge Arbeit, ist jedoch f√ºr ein kleines, erfahrenes Team sehr gut m√∂glich.</em>  <em>Heute bieten PostgreSQL-Open-Source-Branchen wie Greenplum und CitusDB eine solche M√∂glichkeit.</em>  <em>Es ist bedauerlich, dass PostgreSQL in Open Source viel fr√ºher nicht richtig parallelisiert wurde.</em>  <em>Wenn PostgreSQL in den fr√ºhen 2000er Jahren in Open Source mit Unterst√ºtzung f√ºr eine Architektur ohne gemeinsame Nutzung von Ressourcen erweitert worden w√§re, h√§tte sich die Open Source-Richtung f√ºr Big Data m√∂glicherweise auf eine v√∂llig andere und effizientere Weise entwickelt.</em> <br><br><ol><li>  Illustra war Stonebreakers zweitgr√∂√ütes Startup, das 1992 gegr√ºndet wurde, um Postgres zu kommerzialisieren, als RTI Ingres auf den Markt brachte. <br><br>  <em>Illustra war eigentlich der dritte Name, der f√ºr das Unternehmen vorgeschlagen wurde.</em>  <em>Illustra setzte das Thema Malerei unter dem Namen Ingres fort und hie√ü urspr√ºnglich Miro.</em>  <em>Aufgrund von Markenproblemen wurde der Name in Montage ge√§ndert, es traten jedoch auch Markenprobleme auf.</em> <br><br>  Das Gr√ºndungsteam bestand aus einigen Mitgliedern des Postgres-Teams, darunter der j√ºngste Absolvent der Graduiertenschule Wei Hong und der damalige Senior-Programmierer Jeff Meredith sowie Absolventen der Ingres Paula Hawthorn und Michael Ubell.  Der Postgres-Doktorand Mike Olson trat kurz nach der Gr√ºndung bei und ich arbeitete bei Illustra, um im Rahmen meiner Promotion teure Funktionen zu optimieren.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade ‚Äî       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   ¬´ ¬ª Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift ‚Äî             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon ‚Äî            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB ‚Äî  ;   Citus Data. ‚Äî . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   ¬´  ¬ª (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     ‚Äî    Postgres     ,      .               :     ,    .  , ¬´ ¬ª  .    ,    ,      .       ¬´-¬ª    ,      ¬´-¬ª    . <br><br>     ,    , ¬´   ¬ª,       ,    .     <em>( 2001           (). ‚Äî . .)</em>          2000-   ¬´    ¬ª.          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), ¬´  ‚Äî   ¬ª.</em> <br><br> ,     ¬´    ¬ª (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, ‚Äî   ,          .        ¬´ ¬ª  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   ¬´ ¬ª   .      ¬´ ¬ª.   , ,  ,         ,       Postgres.     - ,    : ¬´ -      ¬ª.   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  Literatur </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47‚Äì57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35‚Äì55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562‚Äì573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700‚Äì1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62‚Äì72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1‚Äì14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208‚Äì214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189‚Äì222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78‚Äì92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340‚Äì355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4‚Äì9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289‚Äì300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39‚Äì49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438890/">https://habr.com/ru/post/de438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438878/index.html">Das Erscheinen des Films in Str√∂men nach der Premiere erh√∂ht die Abendkasse um 3%</a></li>
<li><a href="../de438880/index.html">Wann man var, let und const in Javascript verwendet [√úbersetzung aus dem Artikel von Tyler McGinnis]</a></li>
<li><a href="../de438882/index.html">Die Wahrscheinlichkeit, ein Match mit einer bekannten Wahrscheinlichkeit, einen Punkt zu gewinnen, zu gewinnen</a></li>
<li><a href="../de438884/index.html">Wahre Begebenheit einer Outback-Werbeagentur: H√∂hen, Tiefen und CRM-Implementierung</a></li>
<li><a href="../de438886/index.html">Morty, wir sind bei UltraHD! So schauen Sie sich einen Film in 4K an und vervollst√§ndigen ihn √ºber ein wenig bekanntes neuronales Netzwerk</a></li>
<li><a href="../de438892/index.html">Was ist eine Unternehmensblockchain?</a></li>
<li><a href="../de438894/index.html">Warum Webentwicklung auf Go sch√∂ner ist als auf PHP</a></li>
<li><a href="../de438896/index.html">Weinen Sie nicht Gesch√§ft</a></li>
<li><a href="../de438898/index.html">Chrome Reverse und Extension Installation</a></li>
<li><a href="../de438900/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Ende + Volltext der √úbersetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>