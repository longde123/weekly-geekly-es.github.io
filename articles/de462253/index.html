<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∞ üëßüèΩ üëâüèæ Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA üë®‚Äçüëß‚Äçüë¶ üíáüèΩ üßöüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln haben wir uns bereits mit dem Avalon-MM- Bus getroffen, bei dem MM f√ºr Memory Mapped steht, dh auf Memory projiziert. Dieser Reif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  In fr√ºheren Artikeln haben wir uns bereits mit dem <b>Avalon-MM-</b> Bus getroffen, bei dem MM f√ºr Memory Mapped steht, dh auf Memory projiziert.  Dieser Reifen ist sehr vielseitig.  Es k√∂nnen mehrere Master- (Master) und mehrere Slave-Ger√§te daran angeschlossen werden.  Wir haben bereits zwei f√ºhrende Ger√§te gleichzeitig verbunden (Instruction Master und Data Master), da der NIOS II-Prozessor √ºber eine Harvard-Architektur verf√ºgt, sodass die Befehls- und Datenbusse unterschiedlich sind. Viele Autoren verbinden sie jedoch mit demselben gemeinsamen Ger√§t, um die Softwareentwicklung von au√üen zu vereinfachen zum Bus. <br><br>  Wenn ein Block auf dem Bus √ºber DMA-Funktionen (Direct Memory Access) verf√ºgt, enth√§lt er auch einen Master f√ºr den Bus. <br><br>  Tats√§chlich beruht die Hauptunannehmlichkeit dieses Reifens auf dieser Tatsache (viele f√ºhrende, viele Anh√§nger).  Als wir unseren Slave entworfen haben, mussten wir die Adresse dekodieren.  Als ich meinen Anf√ºhrer machte, gab es viel mehr Aufhebens um die Schiedsgerichtsbarkeit.  Ein roter Faden durch die gesamte Artikelserie ist jedoch die Behauptung, dass die Entwicklung unter Redd ein Hilfsteil des Projekts ist und nicht zu viel Arbeit erfordern sollte.  Und wenn wir uns von der Routine befreien k√∂nnen, m√ºssen wir uns davon befreien. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Alle Artikel des Zyklus: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs und Debugging am Beispiel des Speichertests</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines eigenen Kerns zur Einbettung in ein auf FPGA basierendes Prozessorsystem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Programmen f√ºr den Zentralprozessor Redd am Beispiel des Zugriffs auf das FPGA</a> </li></ol><br>  Das uns bereits bekannte Dokument mit den <b>Avalon-Schnittstellenspezifikationen</b> (im Allgemeinen gebe ich keine direkten Links an, da sie sich immer √§ndern, sodass das gesamte Netzwerk mit Artikeln mit toten Links √ºbers√§t ist. Es ist einfacher, die aktuelle Position zu finden, indem der Name in die Suchmaschine eingegeben wird) berichtet, dass zus√§tzlich zum <b>Avalon-MM-</b> Bus Es gibt auch einen <b>Avalon-ST-</b> Bus, bei dem ST f√ºr Stream steht, dh Streaming.  Tatsache ist, dass die √ºbertragenen Daten sehr oft eine Stream-Struktur haben.  Ja, sogar der klassische Sektor der Festplatte.  Es hat eine feste Gr√∂√üe.  Es sollte von Anfang bis Ende weitergegeben werden.  Selbst wenn wir es im adressierbaren Bereich betrachten, werden die Adressen linear zunehmen.  Und wenn Sie den FIFO-Block zum Speichern verwenden, sind die darin enthaltenen Adressen f√ºr uns vollst√§ndig verborgen.  Sie sind es, aber mit ihnen zu arbeiten ist nicht unser Anliegen. <br><br>  Gleiches gilt f√ºr viele andere Streaming-Daten: Sie gehen immer von Anfang bis Ende und werden nacheinander in Repositorys abgelegt.  Genau diese Streaming-Protokolle werden zum √úbertragen solcher Daten verwendet.  Neben dem Fehlen einer expliziten Adressierung ist der <b>Avalon-ST-</b> Bus insofern interessant, als er immer zwei Ger√§te verbindet: eine Quelle und einen Empf√§nger.  Es gibt immer zwei davon.  Ein Ger√§t ist immer die Quelle, das zweite ist immer der Empf√§nger.  Daher betreffen Probleme bei der Schlichtung dieses Busses nicht.  So sehen typische Ger√§tepaare aus, die an diesen Bus angeschlossen sind: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  Und hier sind die typischen Signale dieses Busses: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  Dar√ºber hinaus sind die <b>Fehlerzeilen</b> optional, sie √ºbertragen von uns zugewiesene bin√§re Fehlercodes und wir k√∂nnen sagen, dass es keine Fehlercodes gibt.  Und die Kanalnummernleitungen werden, wie wir oben gesehen haben, nur ben√∂tigt, wenn das Demultiplexen weiter durchgef√ºhrt wird.  Wenn nicht, wird die Kanalnummer nicht ben√∂tigt.  Wir werden vorerst darauf verzichten.  Es bleiben drei Zeilen √ºbrig: Daten, ein Bereitschaftssignal und ein Datenbest√§tigungssignal (Strobe).  Nun, ein weiteres Taktsignal, da der Bus synchron ist. <br><br>  Aus der Dokumentation folgt auch, dass drei weitere Signale m√∂glich sind, die dem Bus die √úbertragungseigenschaften klar definierter Pakete hinzuf√ºgen: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  Im Allgemeinen ist der Reifen sehr interessant, und heute werden wir damit experimentieren.  Wie wir bereits wissen, ist das FPGA √ºber die im <b>FT245-SYNC-</b> Modus betriebene <b>FT2232H-</b> Br√ºcke mit dem USB-Bus des Redd-Komplexes verbunden.  Genau genommen handelt es sich bei den Daten, die √ºber diese Schnittstelle √ºbertragen werden, um Streaming-Daten.  Heute lernen wir, wie wir diese Daten auf Basis von NIOS II auf unser Prozessorsystem √ºbertragen k√∂nnen.  Es ist schade, dass das <b>FT245-SYNC-</b> Protokoll, obwohl es gestreamt wird, nicht vollst√§ndig mit dem <b>Avalon-ST-</b> Bus <b>√ºbereinstimmt</b> .  Um Chipbeine zu sparen, verf√ºgt es √ºber einen bidirektionalen Datenbus, und der <b>Avalon-ST-</b> Bus ist unidirektional.  Wir m√ºssen also einen Block erstellen, der enge, aber nicht √ºbereinstimmende Protokolle koordiniert. <br><br>  Das <b>FT245-SYNC-</b> Protokoll haben wir bereits in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der vorherigen Artikel</a> <b>kennengelernt</b> .  Ich <b>m√∂chte</b> Sie daran erinnern, dass die Beschreibung im Dokument <b>AN_130 FT2232H enthalten ist, das in einem synchronen FT245-FIFO-Modus verwendet wird</b> .  Hier ist ein typisches Zeitdiagramm f√ºr die √úbertragung von einer Br√ºcke zu einem FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  Im Allgemeinen bin ich als Programmierer sehr daran interessiert, dass das √ºbertragene Paket deutlich Anfang und Ende markiert h√§tte.  Um die Logik des UDP-Protokolls logischer zu gestalten, m√ºssen Sie dem Stream spezielle Benchmark-Daten hinzuf√ºgen, die f√ºr meine Programmierung, Bem√ºhungen und Prozessorzyklen aufgewendet werden, wenn die √úbertragung im TCP-Stil erfolgt. Es sieht aus wie bei der RXF-Leitung kann uns dabei helfen.  Wir √ºberpr√ºfen ... Wir f√ºllen die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel angegebene</a> ‚ÄûFirmware‚Äú im FPGA aus, um die Leistung zu messen, und schlie√üen die Oszilloskopsonde an die RXF-Leitung an.  Als Testprogramm f√ºr den Redd-Zentralprozessor verwenden wir die Basis, die auch zur Messung der Leistung verwendet wird. Statt gro√üe Datenmengen zu senden, senden wir einen monolithischen Block mit 0 x 400 Byte. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Wir erhalten das folgende Bild auf der RXF-Linie: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  Es ist klar, dass die Mikroschaltung 0x200 Byte Puffer empf√§ngt (das ist, wie viel es in einem USB2.0 HS-Paket enthalten kann), und diese dann an den Kanal sendet.  Im Allgemeinen ist dies seltsam, da in der Dokumentation angegeben ist, dass in jeder Richtung zwei Puffer verwendet werden.  W√§hrend der √úbertragung sollte der zweite Puffer Zeit zum Auff√ºllen gehabt haben.  Leider.  Das Ende der F√ºllung ist eindeutig sp√§t.  Dies zeigt tats√§chlich, warum die Leistung die theoretischen 52 Megabyte pro Sekunde nicht erreicht: Ein gro√üer Prozentsatz der Zeit (wenn auch nicht 50%) wird einfach nicht √ºbertragen. <br><br>  Aber auf die eine oder andere Weise, und wir haben herausgefunden, dass es m√∂glich ist, den Beginn eines Pakets an einer negativen RXF-Flanke nur zu erkennen, wenn die Paketgr√∂√üe 0x200 Bytes nicht √ºberschreitet.  Wenn wir nur Befehle mit einer kleinen Datenmenge an das Ger√§t senden, ist dies durchaus erreichbar.  Wenn wir jedoch gro√üe Datenstr√∂me senden, m√ºssen wir einen kontinuierlichen Kanal verwenden, der in seiner Logik UART (oder beispielsweise dem TCP-Kanal) √§hnelt und die Paketgrenzen rein programmatisch hervorhebt. <br><br>  Im Allgemeinen verwenden wir zur Vereinfachung der Darstellung die Streaming-Version als Grundlage.  Wir werden heute keine Pakete ber√ºcksichtigen.  Nun, welche Version des <b>Avalon-ST-</b> Busses wir als Grundlage nehmen, ist klar.  Wir beginnen unseren Block zu entwerfen.  Wie oben erw√§hnt, m√ºssen wir nicht nur eine Br√ºcke, sondern auch einen Switch herstellen, da der <b>FT245FIFO-</b> Bus bidirektional und der <b>Avalon-ST-</b> Bus unidirektional ist.  Das hei√üt, es m√ºssen zwei <b>Avalon-ST-</b> Busse gleichzeitig hergestellt werden: Ausgang und Eingang. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Wir beginnen langsam, einen Automaten zu entwickeln, der die Logik implementiert, die wir brauchen.  Nat√ºrlich wird diese Logik im Artikel maximal vereinfacht.  Beginnen wir mit der √úbertragung von Daten vom FPGA auf den PC, da dieser Vorgang etwas einfacher ist (Sie m√ºssen den Status der OE-Leitung, √ºber den wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel</a> gesprochen haben, nicht √§ndern).  Das hei√üt, wir implementieren den Sink-Port. <br><br>  Von der Seite des <b>Avalon-ST-</b> Busses aus habe ich die folgende Betriebsart gew√§hlt (es gibt sehr viele davon im Dokument, aber diese ist der Schnittstelle zum <b>FT245-SYNC</b> am n√§chsten): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  Lassen Sie mich Sie an die Richtung der Signale erinnern: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Das hei√üt, wir warten nur auf die Best√§tigung im Bus ( <b>g√ºltig</b> ), klicken auf die Daten und versehen diese Tatsache mit der <b>Bereitschaftsleitung</b> . <br><br>  Von der Seite <b>FT245_FIFO</b> sieht <b>das</b> Protokoll folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Es stellt sich heraus, dass wir auf das TXE-Signal warten und die Daten mit dem WR # -Signal versehen m√ºssen (die Polarit√§t ist f√ºr beide Signale invers). <br><br>  TXE # ist in seiner Funktionalit√§t sehr √§hnlich zu <b>Ready</b> , und WR # ist <b>g√ºltig</b> .  Die Details sind etwas anders, aber die Logik ist √§hnlich. <br><br>  Es stellt sich heraus, dass wir einen einzelnen Zustand zu PC herausgreifen k√∂nnen, in dem die einfachsten Kommutierungen einiger Zeilen durchgef√ºhrt werden.  Die Bedingung f√ºr den Eintritt in diesen Zustand ist die Bereitschaft beider Parteien zur √úbertragung, dh (TXE # == 0) UND (g√ºltig == 1).  Sobald ein Teil der Bereitschaft verschwunden ist, kehren wir in den Leerlauf zur√ºck. <br><br>  Der √úbergangsgraph des Automaten ist noch einfach: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  Und die Schalttabelle ist wie folgt (wo die Namen der Signale mehrdeutig sind, werden ihnen Indizes hinzugef√ºgt, wo die Namen eindeutig sind - es gibt keine Indizes): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  ToPC-Status </th><th>  Andere Bedingungen </th></tr><tr><td>  WR # </td><td>  NICHT (validSink) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  NICHT (TXE #) </td><td>  0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z. </td></tr></tbody></table></div><br><br>  Weiter zu einer etwas komplexeren √úbertragung von Source zu FT245_FIFO.  Wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im vorherigen Artikel gesehen haben</a> , besteht die Komplikation darin, die Richtung mit dem OE # -Signal zu wechseln: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  F√ºr den <b>Avalon_ST-</b> Bus <b>ist</b> alles wie zuvor, daher werden die Bilder nicht ein zweites Mal angezeigt, aber jetzt befinden wir uns an der Quellposition. <br><br>  Hier entspricht die RXF # -Leitung der <b>g√ºltigen</b> Leitung und die RD # -Leitung der <b>Bereitschaftsleitung</b> .  Nun gut, f√ºgen Sie der Maschine ein paar Zust√§nde hinzu: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  und die folgende Logik f√ºr in diesem Zustand aktive Signale: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  dropOE </th><th>  fromPC </th><th>  Andere Bedingungen </th></tr><tr><td>  OE # </td><td>  0 </td><td>  0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  NICHT (readySource) </td><td>  1 </td></tr><tr><td>  dataSource </td><td>  Beliebiger Wert </td><td>  DATAFT245_FIFO </td><td>  Beliebiger Wert </td></tr><tr><td>  g√ºltige Quelle </td><td>  0 </td><td>  NICHT (RXF #) </td><td>  0 </td></tr></tbody></table></div><br>  Es ist klar, dass das Schema nicht das idealste war.  Es gibt verschiedene Nuancen, die mit Puffer√ºber- oder -unterl√§ufen verbunden sind.  Es sollte jedoch keinen Datenverlust geben, aber f√ºr die Optimalit√§t m√ºssen Sie irgendwo anfangen! <br><br>  Wir beginnen, die entwickelte Theorie auf SystemVerilog-Code zu √ºbertragen.  Es stimmt, wir k√∂nnen nicht alle Funktionen von SystemVerilog verwenden.  Es gab einen Fall, in dem ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üen Artikel</a> schrieb, in dem ich die praktische Synthetisierbarkeit der sch√∂nen Merkmale dieser Sprache in einer realen Entwicklungsumgebung testete.  Hier bitten wir nur um die Verwendung von Schnittstellen, da das System zwei Instanzen vom <b>Typ Avalon-ST haben wird</b> .  Ach und ah.  Hier ist der Testcode: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  Es ist im Hauptcompiler perfekt synthetisiert (eine kommentierte Zeile beim L√∂schen eines Kommentars f√ºhrt zu einem Fehler, um sicherzustellen, dass der Synthesizer alles richtig interpretiert). Wenn Sie jedoch die Schaltfl√§che <b>Synthesedateien analysieren</b> f√ºr eine Komponente f√ºr diesen Code <b>aktivieren</b> , wird ein Fehler <b>generiert,</b> dass der Typ <b>AvalonST</b> unbekannt ist.  Das hei√üt, die Analyse dort erfolgt nicht auf SystemVerilog, sondern auf reinem Verilog.  Wie schade. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  Dar√ºber hinaus wird die Sprache korrekt bestimmt, nur der Analysator versteht die Schnittstellen zwischen den Ports nicht. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  Im Allgemeinen m√ºssen Sie die h√§ssliche alte Syntax verwenden. <br><br><div class="spoiler">  <b class="spoiler_title">Mit dieser Syntax erhalten wir die folgende Modulschnittstelle:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Unh√∂flich, Vintage, aber was k√∂nnen Sie tun. <br><br><div class="spoiler">  <b class="spoiler_title">Wir realisieren den √úbergangsgraphen des Automaten ohne Schnickschnack:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  Die Steuerung der Ausg√§nge bedarf jedoch einiger Erl√§uterungen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Teil der Installationen erfolgt ‚Äûauf der Stirn‚Äú:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Beispielsweise sollte f√ºr einen bidirektionalen Datenbus eine typische L√∂sung angewendet werden.  Wie wir uns erinnern, wird es im Schnittstellenteil wie folgt deklariert: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  und das Lesen davon kann auf die √ºbliche Weise erfolgen.  In unserem Fall wickeln wir einfach alle Daten in die Daten des ausgehenden <b>Avalon-ST-</b> Busses ein: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Aber im Allgemeinen k√∂nnen Sie immer aus dem Bus lesen und nach Belieben.  Sie sollten jedoch mit dem Multiplexer darauf schreiben.  Wenn wir Daten in den Bus schreiben, sollten diese Daten von jedem anderen vorbereiteten Bus stammen.  In der Regel wird eine Variable vom Typ <b>reg</b> (oder eine neue <b>Logik</b> ) in einem Modul aufgel√∂st.  In unserem Fall existiert ein solcher Bus bereits.  Dies ist der <b>sink_data-</b> Bus.  In anderen F√§llen wird der Zustand Z ausgegeben. Wenn Sie mit der Schaltung vertraut sind, kennen Sie einen typischen Ausgabepuffer.  Entweder werden Eingabedaten √ºbersprungen oder es wird in den Z-Zustand versetzt.  In unserem Code sieht dieser Multiplexer folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  Und noch ein Signal ft245_siwu.  Wir verwenden es nie, also ziehen Sie es gem√§√ü der Dokumentation zu FT2232H zur Einheit: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  Eigentlich ist das alles. <br><br><div class="spoiler">  <b class="spoiler_title">Das ganze Modul sieht so aus:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  Wie man das Modul in die Liste der zur Verwendung im Prozessorsystem verf√ºgbaren Module aufnimmt, haben wir in einem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> ausf√ºhrlich untersucht, daher zeige ich nur das Ergebnis in der Abbildung.  Ich erinnere mich, dass ich, um dies zu erreichen, zwei <b>AVALON-ST-</b> Busse hinzuf√ºgen musste, einen <b>Conduit-</b> Bus, Signale von einem falsch definierten <b>AVALON-MM-</b> Bus <b>abrufen</b> musste. Wenn in diesem Bus kein einziges Signal mehr vorhanden ist, l√∂schen Sie es einfach.  Unterwegs zeigt die Abbildung die Einstellungen, die ich f√ºr die <b>AVALON-ST-</b> Busse ausgew√§hlt habe (8 Bit pro Symbol, keine Fehler, der maximale Kanal ist Null, die Latenz ist Null). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Mit der Entwicklung eines Moduls zum Andocken von Reifen - fertig.  Aber leider, ah.  Sich zu entwickeln ist nur der Beginn der Arbeit.  Die Implementierung ist viel schwieriger.  Wie an der Position des Scrollers auf dem Bildschirm zu sehen ist, ist das Ende des Artikels noch weit entfernt.  Wir beginnen also mit der Erstellung eines einfachen Projekts, bei dem die <b>Busverbindung FT245-SYNC</b> mit den Bussen <b>AVALON-ST verwendet wird</b> .  Es ist das einfachste.  Ein seri√∂ses Projekt passt nicht in den Rahmen eines einzelnen Artikels von angemessener Gr√∂√üe.  Ich werde jetzt eine Vereinfachung nach der anderen vereinfachen, damit die Aufmerksamkeit der Leser f√ºr den Rest des Textes ausreicht, damit sie nicht aufh√∂ren, ein Wort zu lesen.  Die erste Vereinfachung besteht darin, dass 60-MHz- <b>Takte</b> f√ºr den <b>FT245_SYNC</b> vom <b>FT2232H-</b> Chip <b>selbst erzeugt werden</b> .  Ich k√∂nnte dem System zwei Taktleitungen hinzuf√ºgen, aber sobald jeder es sieht, werden wir solche Spinnweben von Dr√§hten haben, dass meine Mutter nicht trauert.  Wenn ich immer noch auf verschiedene Taktleitungen achte, werden wir alle verwirrt sein.  Daher k√ºndige ich einfach an, dass unser Prozessorsystem heute vom <b>FT2232H-</b> Chip und nicht von einem normalen Generator <b>getaktet wird</b> . <br><br>  Warum kannst du das nicht immer tun?  Ganz einfach: Solange sich der <b>FT2232H</b> nicht im 245_SYNC-Modus befindet, liegen diese Impulse nicht am Ausgang vor.  Das hei√üt, Sie m√ºssen zuerst das Programm f√ºr den Zentralprozessor ausf√ºhren und erst dann alles in das FPGA laden.  Wenn wir ein System f√ºr einen externen Kunden erstellen w√ºrden, w√ºrde eine solche L√∂sung viele Probleme verursachen.  Ich wei√ü aus Erfahrung, dass sie uns regelm√§√üig anrufen und sagen, dass nichts funktioniert, wir w√ºrden an Bars erinnern, aber das w√ºrde f√ºr eine Weile helfen.  Aber wir machen eine interne Sache und werden sie nur unter Laborbedingungen verwenden.  Das hei√üt, im Rahmen dieser Aufgabe ist dies zul√§ssig. <br><br>  Dies bringt jedoch neue Herausforderungen mit sich.  Wir haben eine Frequenz von 60 MHz, und der SDRAM-Taktblock, den wir derzeit verwenden, ist eng an eine Frequenz von 50 MHz gebunden.  Ja, ich habe gepr√ºft, 60 k√∂nnen eingereicht werden, aber tun wir so, als w√ºrden wir versuchen, nicht √ºber die zul√§ssigen Modi hinauszugehen.  In den folgenden Artikeln werde ich versuchen zu zeigen, wie dieser harte Block ersetzt werden kann, aber heute sagen wir nur, dass wir ihn vom SDRAM-Prozessorsystem ausschlie√üen, da unsere Takteinheit vom SDRAM nicht mit der verwendeten Frequenz arbeiten kann.  Das Programm und seine Daten befinden sich vollst√§ndig im internen Speicher des FPGA.  Es wurde experimentell festgestellt, dass FPGAs in der heutigen Konfiguration maximal 28 Kilobyte RAM f√ºr dieses Unternehmen belegen k√∂nnen.  Es stellt sich heraus, dass Sie Volumen und nicht mehrere Zweierpotenzen nehmen k√∂nnen ... <br><br>  Zus√§tzlich verwenden wir die Standarduhr und die Reset-Einheit.  Es wird etwas anders zur√ºckgesetzt als das, das wir f√ºr SDRAM verwendet haben.  Um den Artikel nicht zu komplizieren, werde ich die Tatsache ausnutzen, dass das in der Entwicklung befindliche System immer unter der Kontrolle eines Debuggers arbeitet, sodass ich zum Debuggen einen Reset vom JTAG-Subsystem starten werde. <br><br>  Insgesamt erhalten wir eine solche Skizze des Basisprozessorsystems (die schwierigste Reset-Linie ist momentan hervorgehoben, die blaue Markierung befindet sich auf der Signalquelle): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  wo die Frequenz f√ºr den Takt- und R√ºcksetzblock eingestellt wurde: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  und f√ºr RAM - die Lautst√§rke: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Heute m√ºssen wir den Text im Terminal anzeigen.  Deshalb werden wir dem System einen so interessanten Block hinzuf√ºgen: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Mit diesem Block k√∂nnen wir Funktionen aufrufen, die printf √§hneln.  Zus√§tzlich zum AVALON_MM-Bus muss auch der Interrupt-Anforderungsausgang angeschlossen werden. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  Damit ist die Beschaffung f√ºr das Prozessorsystem abgeschlossen.  Es ist Zeit, unsere Einheit einzubetten.  Wohin wird er die Daten senden?  Unter den uns zur Verf√ºgung stehenden Bl√∂cken befindet sich ein sehr interessanter FIFO-Speicher mit zwei Ports.  Sein Reiz liegt in der Tatsache, dass ein Port f√ºr den <b>AVALON-ST-</b> Modus konfiguriert und mit unserem Ger√§t verbunden werden kann und der zweite f√ºr den <b>AVALON_MM-</b> Modus und die Verwendung mit dem NIOS II-Prozessor.  Dieser wundervolle Block befindet sich hier: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Wir haben zwei <b>Avalon-ST-Busse</b> (einen zum Lesen, den anderen zum Schreiben), daher ben√∂tigen wir auch zwei FIFO-Bl√∂cke.  Jetzt werde ich eines davon sehr detailliert durchgehen, wir wickeln ein paar Kilometer Web (und eine Reihe von Textbildschirmen mit Bildern) und ungef√§hr in der Sekunde sagen wir, dass "es analog gemacht werden kann", was nur auf Unterschiede hinweist.  Daher f√ºgen wir dem System vorerst nur einen Block hinzu und sehen uns seine Einstellungen an.  Es gibt viele Einstellungen.  Man k√∂nnte einfach die erforderlichen Werte angeben, so dass jeder auf den Artikel als Referenz verweist, aber pl√∂tzlich ger√§t jemand in eine Situation, die konfiguriert werden muss, aber es gibt keinen Zugriff auf das Netzwerk (und damit auf den Artikel).  Daher werde ich Einstellungen iterativ hinzuf√ºgen.  Zuerst offensichtlich, dann - wie es das System verlangt - immer wieder durch den Dialog laufen.  So wird jeder den Prozess sp√ºren und ihn jederzeit wiederholen k√∂nnen.  Also.  Standardm√§√üig erhielten wir die folgenden Einstellungen: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Ich werde jetzt FIFO machen, das Daten von <b>Avalon-ST</b> sammelt und auf <b>Avalon-MM</b> hochl√§dt.  Es stellt sich heraus, dass die erste Bearbeitung folgenderma√üen aussehen wird: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  Ich habe diese interessante Warnung erhalten: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Es stellt sich heraus, dass, wenn mindestens einer der Ports auf den Speicher projiziert wird, die <b>Avalon-ST</b> -Busbreite streng 32 Bit betragen muss.  Und wir haben einen 8-Bit-Bus.  Wie Sie sich auf die Bittiefen einigen k√∂nnen, werde ich Ihnen etwas niedriger sagen, aber im Moment machen wir hier einen 32-Bit-Bus mit einem 8-Bit-Zeichen.  Deaktivieren Sie den Batch-Modus, wie im theoretischen Teil festgelegt. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Als n√§chstes kommt die Kapazit√§t.  Angenommen, ich stelle 256 W√∂rter in die Warteschlange (d. H. 1024 Bytes): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Nun der Status.  Anfangs habe ich dem keine Bedeutung beigemessen, und ich habe das Programm fest eingefroren.  Jetzt wei√ü ich, dass der Status ben√∂tigt wird.  Da wir programmgesteuert mit dem Ausgabeport arbeiten, f√ºgen wir den Status daf√ºr hinzu. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  und den Fehler abfangen: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Na dann.  Doppelte Taktung hinzuf√ºgen.  Verbinden Sie einfach beide Eing√§nge mit derselben Taktleitung, da wir einen haben. <br>  Uhhhh  Insgesamt haben wir: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Es ist jedoch noch zu fr√ºh, um dieses Unternehmen mit dem gemeinsamen System zu verbinden.  Wie wir herausgefunden haben, verl√§sst der 8-Bit- <b>Avalon-ST-</b> Bus den von uns entwickelten Block, und dies sollte den 32-Bit-Block einschlie√üen.  Wie geht es uns  Block umbauen?  Nein!  Alles wurde vor uns getan.  Folgendes wird uns helfen: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  F√ºgen Sie es dem System hinzu.  Da es sich um eine reine Sch√∂nheitsschicht handelt, platzieren wir sie au√üerdem mit dem entsprechenden Pfeil zwischen unserem Block und dem FIFO: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Wir nehmen folgende Einstellungen vor: Am Eingang haben wir einen 8-Bit-Bus, am 32-Bit-Ausgang.  Paketsignale werden nicht verwendet, es werden <b>fertige</b> und <b>g√ºltige</b> Signale verwendet. <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  Es ist Zeit, ein Netz zu weben.  Zuerst lege ich die Streaming-Linien (in der Abbildung sind beide hervorgehoben, die Markierungen befinden sich auf den Datenempf√§ngern): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Das hei√üt, das Signal von der Quelle unseres Blocks geht zum Eingang des Adapters.  Und vom Adapterausgang zum FIFO-Eingang.  Wie gesagt, alle Verbindungen im Streaming-Protokoll werden Punkt-zu-Punkt-Verbindungen hergestellt. <br>  Nun h√§ngen wir die Reset-Leitungen und Taktleitungen auf und verbinden alles mit dem Systembus und den Interrupts ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Nun ... Und jetzt f√ºgen wir nach dem gleichen Prinzip FIFO hinzu, um Daten an den <b>FT245SYNC auszugeben</b> .  Nur dort gelangen die Daten von <b>Avalon-MM</b> in 32-Bit-Form in den FIFO.  Sie durchlaufen einen 32-in-8-Adapter und gelangen dann zum SINK-Eingang unseres Blocks, der nicht im Stromkreis angeschlossen ist ... Wir erhalten das folgende Fragment des endg√ºltigen Stromkreises (der Speicher dort stellte sich mit einem einzigen Takt heraus): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Weitere Formalit√§ten, die wir bereits in den in fr√ºheren Artikeln beschriebenen Experimenten gut ausgearbeitet haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gr√∂√ütenteils - in diesem</a> ).  Wir weisen dem Prozessor Vektoren zu.  F√ºr das System nennen wir die automatische Zuweisung von Interrupt-Nummern und Adressen.  Wir speichern das System ... Jeder erinnert sich, dass der Name des gespeicherten Systems mit dem Namen des Projekts √ºbereinstimmen muss, damit sich das System auf der obersten Ebene der Hierarchie befindet?  F√ºgen Sie das System zum Projekt hinzu, erstellen Sie einen groben Entwurf des Projekts und weisen Sie die Beine zu.  Pers√∂nlich habe ich betrogen: Ich habe die Zuweisungen aus der * .qsf-Datei des Entwurfsprojekts in die aktuelle Abschlussdatei kopiert (und Sie k√∂nnen mein Projekt √ºbernehmen und die entsprechenden * .qsf-Zeilen in Ihre kopieren, aber Sie k√∂nnen einfach alle Beine √ºber die GUI zuweisen).  Ich achte besonders darauf, dass das clk-Signal wie in fr√ºheren Projekten mit Abschnitt 23 und nicht mit Abschnitt 25 verbunden ist.  Ich erinnere Sie daran, dass wir hier von der FT2232-Ausgabe ticken. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  Gro√üartig!  Die Hardware ist bereit.  Wir gehen zur Software √ºber.  Mit was fangen wir an?  Heute ist diese Frage nicht wert.  Wenn wir mit einem Programm beginnen, das auf dem NIOS II-Prozessor ausgef√ºhrt wird, funktioniert f√ºr uns nichts.  Zuerst m√ºssen wir den FT2232 in den 245-SYNC-Modus versetzen, nur dann empf√§ngt unser Prozessorsystem Taktimpulse.  Daher beginnen wir mit dem Code f√ºr den Zentralprozessor. <br><br><div class="spoiler">  <b class="spoiler_title">Wir bekommen so etwas:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFT2232H () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten Artikel bekannt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie √∂ffnet das FT2232-Ger√§t und versetzt es in den von uns ben√∂tigten Modus. Unmittelbar nach dem erfolgreichen Start des Programms erhalten wir Taktimpulse und damit die M√∂glichkeit, das Programm f√ºr NIOS II zu debuggen. Nun, die Funktionalit√§t der Hauptfunktion ist so einfach wie ein Hocker. Senden Sie einige Daten (1), senden Sie viele Daten (2), empfangen Sie Daten (3). Bitte beachten Sie, dass alle Daten in Bl√∂cken gesendet werden, die ein Vielfaches von vier Bytes sind. Dies ist alles, weil wir einen 8-in-32-Adapter haben. Am Ende sollten die Daten in doppelten Worten stehen. Ansonsten ist alles klar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein Programm f√ºr NIOS II entwickeln, sollten Sie zuerst BSP konfigurieren. Ich erinnere Sie daran, dass ich das Programm selbst gem√§√ü der Hello World Small-Vorlage erstelle. Die ge√§nderten Felder im BSP sind in der folgenden Abbildung rot markiert (wie das Programm aus der Vorlage erstellt und wie das BSP korrigiert wird, wurde in einem der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhrlich erl√§utert </font><font style="vertical-align: inherit;">). Ich m√∂chte Sie daran erinnern, dass ich die Wurzel des Baums, dh das Element Einstellungen, ausw√§hle, sodass alle Einstellungen sofort rechts sichtbar sind. </font></font><br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes generiere BSP und √§ndere aufgrund meiner Gewohnheit den Dateinamen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.cpp. </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Danach </font></b><b><font style="vertical-align: inherit;">bereinige</font></b><font style="vertical-align: inherit;"> ich das Projekt, damit bei dieser Umbenennung keine Fehler auftreten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde die Arbeit ganz oberfl√§chlich √ºberpr√ºfen (ein echter Tester w√ºrde sicherlich die √úbertragung gro√üer Datenmengen, die die FIFO-Gr√∂√üe √ºberschreiten, gr√ºndlich testen, aber der Zweck des Artikels besteht darin, die Grundprinzipien aufzuzeigen und nicht sicherzustellen, dass sie aufgrund ihrer wahnsinnigen Gr√∂√üe nicht mehr gelesen werden k√∂nnen). </font><font style="vertical-align: inherit;">Und ich werde die Grundprinzipien in zwei Schritten zeigen. </font><font style="vertical-align: inherit;">Der erste Schritt besteht darin, die Daten√ºbertragung vom Zentralprozessor zu NIOS II zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Daf√ºr habe ich folgenden Code entwickelt:</font></font><br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Programm wartet darauf, dass Daten im FIFO angezeigt werden. </font><font style="vertical-align: inherit;">Wenn sie dort erschienen sind, werden sie angezeigt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Test kommen. </font><font style="vertical-align: inherit;">Zuerst werde ich so tun, als h√§tte ich vergessen, mit dem Timing zu beginnen. </font><font style="vertical-align: inherit;">Daher lade ich nach dem Einschalten von Redd die FPGA-Firmware und versuche dann, ein Debugging-Programm f√ºr NIOS II auszuf√ºhren. </font><font style="vertical-align: inherit;">Ich bekomme diese Nachricht:</font></font><br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dasselbe haben, bedeutet dies, dass Sie wirklich vergessen haben, das Prozessorsystem zu takten. Aber jetzt wissen Sie, wie Sie es schnell identifizieren k√∂nnen. Und um dies zu vermeiden, ist es notwendig und ausreichend, das Programm auszuf√ºhren, das wir f√ºr den Zentralprozessor geschrieben haben. Sobald die FT2232-Br√ºcke gestartet und initialisiert wird, werden Taktimpulse an unseren Prozessor gesendet, und es ist m√∂glich, den Vorgang des Startens des Debuggens zu wiederholen. Dar√ºber hinaus kann das Programm f√ºr den Zentralprozessor zu diesem Zeitpunkt abgeschlossen sein. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taktimpulse</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehen nirgendwo hin: Die Br√ºcke ist bereits f√ºr den </font><b><font style="vertical-align: inherit;">FT245-SYNC-</font></b><font style="vertical-align: inherit;"> Modus konfiguriert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dr√ºcken Sie im Programm f√ºr den Zentralprozessor 1. Je nach Situation wird im Terminal entweder </font><b><font style="vertical-align: inherit;">Folgendes </font></b><b><font style="vertical-align: inherit;">angezeigt</font></b><font style="vertical-align: inherit;"> : </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 empfangene W√∂rter: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 empfangene W√∂rter:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xb0a0908,0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entweder: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3 W√∂rter die Received: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504,0xb0a0908, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x1 W√∂rter die Received: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Prinzip kann es 1, dann 3 Doppelw√∂rter geben, aber das ist mir nicht eingefallen. Es h√§ngt alles davon ab, wie viele Bytes Zeit haben, um auf dem Bus zu laufen, bevor die erste Anzeige beginnt. Und wenn es gestartet wurde, haben am Ende alle anderen Bytes Zeit zum Ausf√ºhren, da die Daten√ºbertragung √ºber JTAG kein schneller Prozess ist. Wenn der Bus Bursts verwendet, kann das Programm die Daten erst nach Empfang des Pakets sehen. In einigen F√§llen ist es gut (es gibt noch kein Paket, warum sollte ich es sehen? Besonders wenn das Paket vor√ºbergehend ist), in einigen F√§llen ist es schlecht (FIFO ist eine Black Box, f√ºr die endg√ºltige Verarbeitung sollten die Daten in den adressierbaren RAM kopiert werden, und dies geschieht besser parallel zum Empfang von Daten ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √ºbertragenen Daten werden in Doppelw√∂rtern in Little Endian-Notation platziert. Ich m√∂chte Sie daran erinnern, dass das folgende Array √ºbergeben wird:</font></font><br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  Alles ist richtig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie im Programm Punkt 2 f√ºr den Zentralprozessor ausw√§hlen, wird eine Meldung angezeigt (zur besseren Lesbarkeit werden die Zeilen bei der Vorbereitung des Artikels formatiert): </font></font><br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist auch wahr. </font><font style="vertical-align: inherit;">Wir pr√ºfen den R√ºckw√§rtsgang. </font><font style="vertical-align: inherit;">Wir ersetzen das Programm f√ºr NIOS II durch Folgendes:</font></font><br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir w√§hlen Punkt 3 im Programm f√ºr den Zentralprozessor aus und f√ºhren diese Version des Programms f√ºr NIOS II aus. </font><font style="vertical-align: inherit;">Wir </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhalten</font></font><br><br><font style="vertical-align: inherit;"></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">16 Bytes (4 DWORDs) </font></b><b><font style="vertical-align: inherit;">empfangen 0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00,</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beide Kan√§le arbeiten grob. </font><font style="vertical-align: inherit;">Und wir werden es irgendwie ein anderes Mal √ºberpr√ºfen.</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel beschreibt die Grundlagen des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avalon-ST-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bus-Streaming-Protokolls </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Durch dieses Protokoll wird die Verbindung des Redd-Zentralprozessors mit dem im FPGA implementierten Prozessorsystem organisiert. </font><font style="vertical-align: inherit;">Die Leser erhielten eine Vorstellung von der einfachsten Interaktionsmethode zwischen Zentral- und Hilfsprozessoren. </font><font style="vertical-align: inherit;">Download gestartet in Entwicklungsprojekten kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kenntnisse √ºber Streaming-Protokolle und deren Verwendung sind jedoch sehr grundlegend. </font><font style="vertical-align: inherit;">In den folgenden Artikeln wird gezeigt, wie mit diesen Protokollen Daten im dynamischen RAM auf der Redd-Karte effizient gespeichert werden k√∂nnen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462253/">https://habr.com/ru/post/de462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462221/index.html">Wie entt√§uscht ich von Google Play bin</a></li>
<li><a href="../de462227/index.html">Moskau, 9. August - Backend Stories 4.0</a></li>
<li><a href="../de462243/index.html">Verbessern der Magento-Front-End-Leistung mit ReactJS</a></li>
<li><a href="../de462245/index.html">Auto Git Bisect als Beispiel f√ºr den Linux-Kernel</a></li>
<li><a href="../de462251/index.html">Ist der Inkognito-Modus im Browser eine Fiktion?</a></li>
<li><a href="../de462257/index.html">Kafka auf Kubernetes - ist das gut?</a></li>
<li><a href="../de462259/index.html">Erstellen eines Controllers f√ºr ein Smart Home</a></li>
<li><a href="../de462263/index.html">Pedal auf den Boden: Erstellen Sie einen weiteren Fu√ümanipulator f√ºr den PC</a></li>
<li><a href="../de462265/index.html">Python und W√ºrfel</a></li>
<li><a href="../de462267/index.html">Lernen Sie den PVS-Studio Static Analyzer f√ºr Java kennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>