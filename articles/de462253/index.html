<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍰 👧🏽 👉🏾 Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA 👨‍👧‍👦 💇🏽 🧚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In früheren Artikeln haben wir uns bereits mit dem Avalon-MM- Bus getroffen, bei dem MM für Memory Mapped steht, dh auf Memory projiziert. Dieser Reif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ersten Experimente am Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  In früheren Artikeln haben wir uns bereits mit dem <b>Avalon-MM-</b> Bus getroffen, bei dem MM für Memory Mapped steht, dh auf Memory projiziert.  Dieser Reifen ist sehr vielseitig.  Es können mehrere Master- (Master) und mehrere Slave-Geräte daran angeschlossen werden.  Wir haben bereits zwei führende Geräte gleichzeitig verbunden (Instruction Master und Data Master), da der NIOS II-Prozessor über eine Harvard-Architektur verfügt, sodass die Befehls- und Datenbusse unterschiedlich sind. Viele Autoren verbinden sie jedoch mit demselben gemeinsamen Gerät, um die Softwareentwicklung von außen zu vereinfachen zum Bus. <br><br>  Wenn ein Block auf dem Bus über DMA-Funktionen (Direct Memory Access) verfügt, enthält er auch einen Master für den Bus. <br><br>  Tatsächlich beruht die Hauptunannehmlichkeit dieses Reifens auf dieser Tatsache (viele führende, viele Anhänger).  Als wir unseren Slave entworfen haben, mussten wir die Adresse dekodieren.  Als ich meinen Anführer machte, gab es viel mehr Aufhebens um die Schiedsgerichtsbarkeit.  Ein roter Faden durch die gesamte Artikelserie ist jedoch die Behauptung, dass die Entwicklung unter Redd ein Hilfsteil des Projekts ist und nicht zu viel Arbeit erfordern sollte.  Und wenn wir uns von der Routine befreien können, müssen wir uns davon befreien. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Alle Artikel des Zyklus: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs und Debugging am Beispiel des Speichertests</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines eigenen Kerns zur Einbettung in ein auf FPGA basierendes Prozessorsystem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Programmen für den Zentralprozessor Redd am Beispiel des Zugriffs auf das FPGA</a> </li></ol><br>  Das uns bereits bekannte Dokument mit den <b>Avalon-Schnittstellenspezifikationen</b> (im Allgemeinen gebe ich keine direkten Links an, da sie sich immer ändern, sodass das gesamte Netzwerk mit Artikeln mit toten Links übersät ist. Es ist einfacher, die aktuelle Position zu finden, indem der Name in die Suchmaschine eingegeben wird) berichtet, dass zusätzlich zum <b>Avalon-MM-</b> Bus Es gibt auch einen <b>Avalon-ST-</b> Bus, bei dem ST für Stream steht, dh Streaming.  Tatsache ist, dass die übertragenen Daten sehr oft eine Stream-Struktur haben.  Ja, sogar der klassische Sektor der Festplatte.  Es hat eine feste Größe.  Es sollte von Anfang bis Ende weitergegeben werden.  Selbst wenn wir es im adressierbaren Bereich betrachten, werden die Adressen linear zunehmen.  Und wenn Sie den FIFO-Block zum Speichern verwenden, sind die darin enthaltenen Adressen für uns vollständig verborgen.  Sie sind es, aber mit ihnen zu arbeiten ist nicht unser Anliegen. <br><br>  Gleiches gilt für viele andere Streaming-Daten: Sie gehen immer von Anfang bis Ende und werden nacheinander in Repositorys abgelegt.  Genau diese Streaming-Protokolle werden zum Übertragen solcher Daten verwendet.  Neben dem Fehlen einer expliziten Adressierung ist der <b>Avalon-ST-</b> Bus insofern interessant, als er immer zwei Geräte verbindet: eine Quelle und einen Empfänger.  Es gibt immer zwei davon.  Ein Gerät ist immer die Quelle, das zweite ist immer der Empfänger.  Daher betreffen Probleme bei der Schlichtung dieses Busses nicht.  So sehen typische Gerätepaare aus, die an diesen Bus angeschlossen sind: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  Und hier sind die typischen Signale dieses Busses: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  Darüber hinaus sind die <b>Fehlerzeilen</b> optional, sie übertragen von uns zugewiesene binäre Fehlercodes und wir können sagen, dass es keine Fehlercodes gibt.  Und die Kanalnummernleitungen werden, wie wir oben gesehen haben, nur benötigt, wenn das Demultiplexen weiter durchgeführt wird.  Wenn nicht, wird die Kanalnummer nicht benötigt.  Wir werden vorerst darauf verzichten.  Es bleiben drei Zeilen übrig: Daten, ein Bereitschaftssignal und ein Datenbestätigungssignal (Strobe).  Nun, ein weiteres Taktsignal, da der Bus synchron ist. <br><br>  Aus der Dokumentation folgt auch, dass drei weitere Signale möglich sind, die dem Bus die Übertragungseigenschaften klar definierter Pakete hinzufügen: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  Im Allgemeinen ist der Reifen sehr interessant, und heute werden wir damit experimentieren.  Wie wir bereits wissen, ist das FPGA über die im <b>FT245-SYNC-</b> Modus betriebene <b>FT2232H-</b> Brücke mit dem USB-Bus des Redd-Komplexes verbunden.  Genau genommen handelt es sich bei den Daten, die über diese Schnittstelle übertragen werden, um Streaming-Daten.  Heute lernen wir, wie wir diese Daten auf Basis von NIOS II auf unser Prozessorsystem übertragen können.  Es ist schade, dass das <b>FT245-SYNC-</b> Protokoll, obwohl es gestreamt wird, nicht vollständig mit dem <b>Avalon-ST-</b> Bus <b>übereinstimmt</b> .  Um Chipbeine zu sparen, verfügt es über einen bidirektionalen Datenbus, und der <b>Avalon-ST-</b> Bus ist unidirektional.  Wir müssen also einen Block erstellen, der enge, aber nicht übereinstimmende Protokolle koordiniert. <br><br>  Das <b>FT245-SYNC-</b> Protokoll haben wir bereits in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der vorherigen Artikel</a> <b>kennengelernt</b> .  Ich <b>möchte</b> Sie daran erinnern, dass die Beschreibung im Dokument <b>AN_130 FT2232H enthalten ist, das in einem synchronen FT245-FIFO-Modus verwendet wird</b> .  Hier ist ein typisches Zeitdiagramm für die Übertragung von einer Brücke zu einem FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  Im Allgemeinen bin ich als Programmierer sehr daran interessiert, dass das übertragene Paket deutlich Anfang und Ende markiert hätte.  Um die Logik des UDP-Protokolls logischer zu gestalten, müssen Sie dem Stream spezielle Benchmark-Daten hinzufügen, die für meine Programmierung, Bemühungen und Prozessorzyklen aufgewendet werden, wenn die Übertragung im TCP-Stil erfolgt. Es sieht aus wie bei der RXF-Leitung kann uns dabei helfen.  Wir überprüfen ... Wir füllen die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel angegebene</a> „Firmware“ im FPGA aus, um die Leistung zu messen, und schließen die Oszilloskopsonde an die RXF-Leitung an.  Als Testprogramm für den Redd-Zentralprozessor verwenden wir die Basis, die auch zur Messung der Leistung verwendet wird. Statt große Datenmengen zu senden, senden wir einen monolithischen Block mit 0 x 400 Byte. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Wir erhalten das folgende Bild auf der RXF-Linie: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  Es ist klar, dass die Mikroschaltung 0x200 Byte Puffer empfängt (das ist, wie viel es in einem USB2.0 HS-Paket enthalten kann), und diese dann an den Kanal sendet.  Im Allgemeinen ist dies seltsam, da in der Dokumentation angegeben ist, dass in jeder Richtung zwei Puffer verwendet werden.  Während der Übertragung sollte der zweite Puffer Zeit zum Auffüllen gehabt haben.  Leider.  Das Ende der Füllung ist eindeutig spät.  Dies zeigt tatsächlich, warum die Leistung die theoretischen 52 Megabyte pro Sekunde nicht erreicht: Ein großer Prozentsatz der Zeit (wenn auch nicht 50%) wird einfach nicht übertragen. <br><br>  Aber auf die eine oder andere Weise, und wir haben herausgefunden, dass es möglich ist, den Beginn eines Pakets an einer negativen RXF-Flanke nur zu erkennen, wenn die Paketgröße 0x200 Bytes nicht überschreitet.  Wenn wir nur Befehle mit einer kleinen Datenmenge an das Gerät senden, ist dies durchaus erreichbar.  Wenn wir jedoch große Datenströme senden, müssen wir einen kontinuierlichen Kanal verwenden, der in seiner Logik UART (oder beispielsweise dem TCP-Kanal) ähnelt und die Paketgrenzen rein programmatisch hervorhebt. <br><br>  Im Allgemeinen verwenden wir zur Vereinfachung der Darstellung die Streaming-Version als Grundlage.  Wir werden heute keine Pakete berücksichtigen.  Nun, welche Version des <b>Avalon-ST-</b> Busses wir als Grundlage nehmen, ist klar.  Wir beginnen unseren Block zu entwerfen.  Wie oben erwähnt, müssen wir nicht nur eine Brücke, sondern auch einen Switch herstellen, da der <b>FT245FIFO-</b> Bus bidirektional und der <b>Avalon-ST-</b> Bus unidirektional ist.  Das heißt, es müssen zwei <b>Avalon-ST-</b> Busse gleichzeitig hergestellt werden: Ausgang und Eingang. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Wir beginnen langsam, einen Automaten zu entwickeln, der die Logik implementiert, die wir brauchen.  Natürlich wird diese Logik im Artikel maximal vereinfacht.  Beginnen wir mit der Übertragung von Daten vom FPGA auf den PC, da dieser Vorgang etwas einfacher ist (Sie müssen den Status der OE-Leitung, über den wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel</a> gesprochen haben, nicht ändern).  Das heißt, wir implementieren den Sink-Port. <br><br>  Von der Seite des <b>Avalon-ST-</b> Busses aus habe ich die folgende Betriebsart gewählt (es gibt sehr viele davon im Dokument, aber diese ist der Schnittstelle zum <b>FT245-SYNC</b> am nächsten): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  Lassen Sie mich Sie an die Richtung der Signale erinnern: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Das heißt, wir warten nur auf die Bestätigung im Bus ( <b>gültig</b> ), klicken auf die Daten und versehen diese Tatsache mit der <b>Bereitschaftsleitung</b> . <br><br>  Von der Seite <b>FT245_FIFO</b> sieht <b>das</b> Protokoll folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Es stellt sich heraus, dass wir auf das TXE-Signal warten und die Daten mit dem WR # -Signal versehen müssen (die Polarität ist für beide Signale invers). <br><br>  TXE # ist in seiner Funktionalität sehr ähnlich zu <b>Ready</b> , und WR # ist <b>gültig</b> .  Die Details sind etwas anders, aber die Logik ist ähnlich. <br><br>  Es stellt sich heraus, dass wir einen einzelnen Zustand zu PC herausgreifen können, in dem die einfachsten Kommutierungen einiger Zeilen durchgeführt werden.  Die Bedingung für den Eintritt in diesen Zustand ist die Bereitschaft beider Parteien zur Übertragung, dh (TXE # == 0) UND (gültig == 1).  Sobald ein Teil der Bereitschaft verschwunden ist, kehren wir in den Leerlauf zurück. <br><br>  Der Übergangsgraph des Automaten ist noch einfach: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  Und die Schalttabelle ist wie folgt (wo die Namen der Signale mehrdeutig sind, werden ihnen Indizes hinzugefügt, wo die Namen eindeutig sind - es gibt keine Indizes): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  ToPC-Status </th><th>  Andere Bedingungen </th></tr><tr><td>  WR # </td><td>  NICHT (validSink) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  NICHT (TXE #) </td><td>  0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z. </td></tr></tbody></table></div><br><br>  Weiter zu einer etwas komplexeren Übertragung von Source zu FT245_FIFO.  Wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im vorherigen Artikel gesehen haben</a> , besteht die Komplikation darin, die Richtung mit dem OE # -Signal zu wechseln: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  Für den <b>Avalon_ST-</b> Bus <b>ist</b> alles wie zuvor, daher werden die Bilder nicht ein zweites Mal angezeigt, aber jetzt befinden wir uns an der Quellposition. <br><br>  Hier entspricht die RXF # -Leitung der <b>gültigen</b> Leitung und die RD # -Leitung der <b>Bereitschaftsleitung</b> .  Nun gut, fügen Sie der Maschine ein paar Zustände hinzu: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  und die folgende Logik für in diesem Zustand aktive Signale: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  dropOE </th><th>  fromPC </th><th>  Andere Bedingungen </th></tr><tr><td>  OE # </td><td>  0 </td><td>  0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  NICHT (readySource) </td><td>  1 </td></tr><tr><td>  dataSource </td><td>  Beliebiger Wert </td><td>  DATAFT245_FIFO </td><td>  Beliebiger Wert </td></tr><tr><td>  gültige Quelle </td><td>  0 </td><td>  NICHT (RXF #) </td><td>  0 </td></tr></tbody></table></div><br>  Es ist klar, dass das Schema nicht das idealste war.  Es gibt verschiedene Nuancen, die mit Pufferüber- oder -unterläufen verbunden sind.  Es sollte jedoch keinen Datenverlust geben, aber für die Optimalität müssen Sie irgendwo anfangen! <br><br>  Wir beginnen, die entwickelte Theorie auf SystemVerilog-Code zu übertragen.  Es stimmt, wir können nicht alle Funktionen von SystemVerilog verwenden.  Es gab einen Fall, in dem ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">großen Artikel</a> schrieb, in dem ich die praktische Synthetisierbarkeit der schönen Merkmale dieser Sprache in einer realen Entwicklungsumgebung testete.  Hier bitten wir nur um die Verwendung von Schnittstellen, da das System zwei Instanzen vom <b>Typ Avalon-ST haben wird</b> .  Ach und ah.  Hier ist der Testcode: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  Es ist im Hauptcompiler perfekt synthetisiert (eine kommentierte Zeile beim Löschen eines Kommentars führt zu einem Fehler, um sicherzustellen, dass der Synthesizer alles richtig interpretiert). Wenn Sie jedoch die Schaltfläche <b>Synthesedateien analysieren</b> für eine Komponente für diesen Code <b>aktivieren</b> , wird ein Fehler <b>generiert,</b> dass der Typ <b>AvalonST</b> unbekannt ist.  Das heißt, die Analyse dort erfolgt nicht auf SystemVerilog, sondern auf reinem Verilog.  Wie schade. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  Darüber hinaus wird die Sprache korrekt bestimmt, nur der Analysator versteht die Schnittstellen zwischen den Ports nicht. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  Im Allgemeinen müssen Sie die hässliche alte Syntax verwenden. <br><br><div class="spoiler">  <b class="spoiler_title">Mit dieser Syntax erhalten wir die folgende Modulschnittstelle:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Unhöflich, Vintage, aber was können Sie tun. <br><br><div class="spoiler">  <b class="spoiler_title">Wir realisieren den Übergangsgraphen des Automaten ohne Schnickschnack:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  Die Steuerung der Ausgänge bedarf jedoch einiger Erläuterungen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Teil der Installationen erfolgt „auf der Stirn“:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Beispielsweise sollte für einen bidirektionalen Datenbus eine typische Lösung angewendet werden.  Wie wir uns erinnern, wird es im Schnittstellenteil wie folgt deklariert: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  und das Lesen davon kann auf die übliche Weise erfolgen.  In unserem Fall wickeln wir einfach alle Daten in die Daten des ausgehenden <b>Avalon-ST-</b> Busses ein: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Aber im Allgemeinen können Sie immer aus dem Bus lesen und nach Belieben.  Sie sollten jedoch mit dem Multiplexer darauf schreiben.  Wenn wir Daten in den Bus schreiben, sollten diese Daten von jedem anderen vorbereiteten Bus stammen.  In der Regel wird eine Variable vom Typ <b>reg</b> (oder eine neue <b>Logik</b> ) in einem Modul aufgelöst.  In unserem Fall existiert ein solcher Bus bereits.  Dies ist der <b>sink_data-</b> Bus.  In anderen Fällen wird der Zustand Z ausgegeben. Wenn Sie mit der Schaltung vertraut sind, kennen Sie einen typischen Ausgabepuffer.  Entweder werden Eingabedaten übersprungen oder es wird in den Z-Zustand versetzt.  In unserem Code sieht dieser Multiplexer folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  Und noch ein Signal ft245_siwu.  Wir verwenden es nie, also ziehen Sie es gemäß der Dokumentation zu FT2232H zur Einheit: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  Eigentlich ist das alles. <br><br><div class="spoiler">  <b class="spoiler_title">Das ganze Modul sieht so aus:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  Wie man das Modul in die Liste der zur Verwendung im Prozessorsystem verfügbaren Module aufnimmt, haben wir in einem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> ausführlich untersucht, daher zeige ich nur das Ergebnis in der Abbildung.  Ich erinnere mich, dass ich, um dies zu erreichen, zwei <b>AVALON-ST-</b> Busse hinzufügen musste, einen <b>Conduit-</b> Bus, Signale von einem falsch definierten <b>AVALON-MM-</b> Bus <b>abrufen</b> musste. Wenn in diesem Bus kein einziges Signal mehr vorhanden ist, löschen Sie es einfach.  Unterwegs zeigt die Abbildung die Einstellungen, die ich für die <b>AVALON-ST-</b> Busse ausgewählt habe (8 Bit pro Symbol, keine Fehler, der maximale Kanal ist Null, die Latenz ist Null). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Mit der Entwicklung eines Moduls zum Andocken von Reifen - fertig.  Aber leider, ah.  Sich zu entwickeln ist nur der Beginn der Arbeit.  Die Implementierung ist viel schwieriger.  Wie an der Position des Scrollers auf dem Bildschirm zu sehen ist, ist das Ende des Artikels noch weit entfernt.  Wir beginnen also mit der Erstellung eines einfachen Projekts, bei dem die <b>Busverbindung FT245-SYNC</b> mit den Bussen <b>AVALON-ST verwendet wird</b> .  Es ist das einfachste.  Ein seriöses Projekt passt nicht in den Rahmen eines einzelnen Artikels von angemessener Größe.  Ich werde jetzt eine Vereinfachung nach der anderen vereinfachen, damit die Aufmerksamkeit der Leser für den Rest des Textes ausreicht, damit sie nicht aufhören, ein Wort zu lesen.  Die erste Vereinfachung besteht darin, dass 60-MHz- <b>Takte</b> für den <b>FT245_SYNC</b> vom <b>FT2232H-</b> Chip <b>selbst erzeugt werden</b> .  Ich könnte dem System zwei Taktleitungen hinzufügen, aber sobald jeder es sieht, werden wir solche Spinnweben von Drähten haben, dass meine Mutter nicht trauert.  Wenn ich immer noch auf verschiedene Taktleitungen achte, werden wir alle verwirrt sein.  Daher kündige ich einfach an, dass unser Prozessorsystem heute vom <b>FT2232H-</b> Chip und nicht von einem normalen Generator <b>getaktet wird</b> . <br><br>  Warum kannst du das nicht immer tun?  Ganz einfach: Solange sich der <b>FT2232H</b> nicht im 245_SYNC-Modus befindet, liegen diese Impulse nicht am Ausgang vor.  Das heißt, Sie müssen zuerst das Programm für den Zentralprozessor ausführen und erst dann alles in das FPGA laden.  Wenn wir ein System für einen externen Kunden erstellen würden, würde eine solche Lösung viele Probleme verursachen.  Ich weiß aus Erfahrung, dass sie uns regelmäßig anrufen und sagen, dass nichts funktioniert, wir würden an Bars erinnern, aber das würde für eine Weile helfen.  Aber wir machen eine interne Sache und werden sie nur unter Laborbedingungen verwenden.  Das heißt, im Rahmen dieser Aufgabe ist dies zulässig. <br><br>  Dies bringt jedoch neue Herausforderungen mit sich.  Wir haben eine Frequenz von 60 MHz, und der SDRAM-Taktblock, den wir derzeit verwenden, ist eng an eine Frequenz von 50 MHz gebunden.  Ja, ich habe geprüft, 60 können eingereicht werden, aber tun wir so, als würden wir versuchen, nicht über die zulässigen Modi hinauszugehen.  In den folgenden Artikeln werde ich versuchen zu zeigen, wie dieser harte Block ersetzt werden kann, aber heute sagen wir nur, dass wir ihn vom SDRAM-Prozessorsystem ausschließen, da unsere Takteinheit vom SDRAM nicht mit der verwendeten Frequenz arbeiten kann.  Das Programm und seine Daten befinden sich vollständig im internen Speicher des FPGA.  Es wurde experimentell festgestellt, dass FPGAs in der heutigen Konfiguration maximal 28 Kilobyte RAM für dieses Unternehmen belegen können.  Es stellt sich heraus, dass Sie Volumen und nicht mehrere Zweierpotenzen nehmen können ... <br><br>  Zusätzlich verwenden wir die Standarduhr und die Reset-Einheit.  Es wird etwas anders zurückgesetzt als das, das wir für SDRAM verwendet haben.  Um den Artikel nicht zu komplizieren, werde ich die Tatsache ausnutzen, dass das in der Entwicklung befindliche System immer unter der Kontrolle eines Debuggers arbeitet, sodass ich zum Debuggen einen Reset vom JTAG-Subsystem starten werde. <br><br>  Insgesamt erhalten wir eine solche Skizze des Basisprozessorsystems (die schwierigste Reset-Linie ist momentan hervorgehoben, die blaue Markierung befindet sich auf der Signalquelle): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  wo die Frequenz für den Takt- und Rücksetzblock eingestellt wurde: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  und für RAM - die Lautstärke: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Heute müssen wir den Text im Terminal anzeigen.  Deshalb werden wir dem System einen so interessanten Block hinzufügen: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Mit diesem Block können wir Funktionen aufrufen, die printf ähneln.  Zusätzlich zum AVALON_MM-Bus muss auch der Interrupt-Anforderungsausgang angeschlossen werden. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  Damit ist die Beschaffung für das Prozessorsystem abgeschlossen.  Es ist Zeit, unsere Einheit einzubetten.  Wohin wird er die Daten senden?  Unter den uns zur Verfügung stehenden Blöcken befindet sich ein sehr interessanter FIFO-Speicher mit zwei Ports.  Sein Reiz liegt in der Tatsache, dass ein Port für den <b>AVALON-ST-</b> Modus konfiguriert und mit unserem Gerät verbunden werden kann und der zweite für den <b>AVALON_MM-</b> Modus und die Verwendung mit dem NIOS II-Prozessor.  Dieser wundervolle Block befindet sich hier: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Wir haben zwei <b>Avalon-ST-Busse</b> (einen zum Lesen, den anderen zum Schreiben), daher benötigen wir auch zwei FIFO-Blöcke.  Jetzt werde ich eines davon sehr detailliert durchgehen, wir wickeln ein paar Kilometer Web (und eine Reihe von Textbildschirmen mit Bildern) und ungefähr in der Sekunde sagen wir, dass "es analog gemacht werden kann", was nur auf Unterschiede hinweist.  Daher fügen wir dem System vorerst nur einen Block hinzu und sehen uns seine Einstellungen an.  Es gibt viele Einstellungen.  Man könnte einfach die erforderlichen Werte angeben, so dass jeder auf den Artikel als Referenz verweist, aber plötzlich gerät jemand in eine Situation, die konfiguriert werden muss, aber es gibt keinen Zugriff auf das Netzwerk (und damit auf den Artikel).  Daher werde ich Einstellungen iterativ hinzufügen.  Zuerst offensichtlich, dann - wie es das System verlangt - immer wieder durch den Dialog laufen.  So wird jeder den Prozess spüren und ihn jederzeit wiederholen können.  Also.  Standardmäßig erhielten wir die folgenden Einstellungen: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Ich werde jetzt FIFO machen, das Daten von <b>Avalon-ST</b> sammelt und auf <b>Avalon-MM</b> hochlädt.  Es stellt sich heraus, dass die erste Bearbeitung folgendermaßen aussehen wird: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  Ich habe diese interessante Warnung erhalten: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Es stellt sich heraus, dass, wenn mindestens einer der Ports auf den Speicher projiziert wird, die <b>Avalon-ST</b> -Busbreite streng 32 Bit betragen muss.  Und wir haben einen 8-Bit-Bus.  Wie Sie sich auf die Bittiefen einigen können, werde ich Ihnen etwas niedriger sagen, aber im Moment machen wir hier einen 32-Bit-Bus mit einem 8-Bit-Zeichen.  Deaktivieren Sie den Batch-Modus, wie im theoretischen Teil festgelegt. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Als nächstes kommt die Kapazität.  Angenommen, ich stelle 256 Wörter in die Warteschlange (d. H. 1024 Bytes): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Nun der Status.  Anfangs habe ich dem keine Bedeutung beigemessen, und ich habe das Programm fest eingefroren.  Jetzt weiß ich, dass der Status benötigt wird.  Da wir programmgesteuert mit dem Ausgabeport arbeiten, fügen wir den Status dafür hinzu. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  und den Fehler abfangen: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Na dann.  Doppelte Taktung hinzufügen.  Verbinden Sie einfach beide Eingänge mit derselben Taktleitung, da wir einen haben. <br>  Uhhhh  Insgesamt haben wir: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Es ist jedoch noch zu früh, um dieses Unternehmen mit dem gemeinsamen System zu verbinden.  Wie wir herausgefunden haben, verlässt der 8-Bit- <b>Avalon-ST-</b> Bus den von uns entwickelten Block, und dies sollte den 32-Bit-Block einschließen.  Wie geht es uns  Block umbauen?  Nein!  Alles wurde vor uns getan.  Folgendes wird uns helfen: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  Fügen Sie es dem System hinzu.  Da es sich um eine reine Schönheitsschicht handelt, platzieren wir sie außerdem mit dem entsprechenden Pfeil zwischen unserem Block und dem FIFO: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Wir nehmen folgende Einstellungen vor: Am Eingang haben wir einen 8-Bit-Bus, am 32-Bit-Ausgang.  Paketsignale werden nicht verwendet, es werden <b>fertige</b> und <b>gültige</b> Signale verwendet. <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  Es ist Zeit, ein Netz zu weben.  Zuerst lege ich die Streaming-Linien (in der Abbildung sind beide hervorgehoben, die Markierungen befinden sich auf den Datenempfängern): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Das heißt, das Signal von der Quelle unseres Blocks geht zum Eingang des Adapters.  Und vom Adapterausgang zum FIFO-Eingang.  Wie gesagt, alle Verbindungen im Streaming-Protokoll werden Punkt-zu-Punkt-Verbindungen hergestellt. <br>  Nun hängen wir die Reset-Leitungen und Taktleitungen auf und verbinden alles mit dem Systembus und den Interrupts ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Nun ... Und jetzt fügen wir nach dem gleichen Prinzip FIFO hinzu, um Daten an den <b>FT245SYNC auszugeben</b> .  Nur dort gelangen die Daten von <b>Avalon-MM</b> in 32-Bit-Form in den FIFO.  Sie durchlaufen einen 32-in-8-Adapter und gelangen dann zum SINK-Eingang unseres Blocks, der nicht im Stromkreis angeschlossen ist ... Wir erhalten das folgende Fragment des endgültigen Stromkreises (der Speicher dort stellte sich mit einem einzigen Takt heraus): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Weitere Formalitäten, die wir bereits in den in früheren Artikeln beschriebenen Experimenten gut ausgearbeitet haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">größtenteils - in diesem</a> ).  Wir weisen dem Prozessor Vektoren zu.  Für das System nennen wir die automatische Zuweisung von Interrupt-Nummern und Adressen.  Wir speichern das System ... Jeder erinnert sich, dass der Name des gespeicherten Systems mit dem Namen des Projekts übereinstimmen muss, damit sich das System auf der obersten Ebene der Hierarchie befindet?  Fügen Sie das System zum Projekt hinzu, erstellen Sie einen groben Entwurf des Projekts und weisen Sie die Beine zu.  Persönlich habe ich betrogen: Ich habe die Zuweisungen aus der * .qsf-Datei des Entwurfsprojekts in die aktuelle Abschlussdatei kopiert (und Sie können mein Projekt übernehmen und die entsprechenden * .qsf-Zeilen in Ihre kopieren, aber Sie können einfach alle Beine über die GUI zuweisen).  Ich achte besonders darauf, dass das clk-Signal wie in früheren Projekten mit Abschnitt 23 und nicht mit Abschnitt 25 verbunden ist.  Ich erinnere Sie daran, dass wir hier von der FT2232-Ausgabe ticken. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  Großartig!  Die Hardware ist bereit.  Wir gehen zur Software über.  Mit was fangen wir an?  Heute ist diese Frage nicht wert.  Wenn wir mit einem Programm beginnen, das auf dem NIOS II-Prozessor ausgeführt wird, funktioniert für uns nichts.  Zuerst müssen wir den FT2232 in den 245-SYNC-Modus versetzen, nur dann empfängt unser Prozessorsystem Taktimpulse.  Daher beginnen wir mit dem Code für den Zentralprozessor. <br><br><div class="spoiler">  <b class="spoiler_title">Wir bekommen so etwas:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFT2232H () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten Artikel bekannt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie öffnet das FT2232-Gerät und versetzt es in den von uns benötigten Modus. Unmittelbar nach dem erfolgreichen Start des Programms erhalten wir Taktimpulse und damit die Möglichkeit, das Programm für NIOS II zu debuggen. Nun, die Funktionalität der Hauptfunktion ist so einfach wie ein Hocker. Senden Sie einige Daten (1), senden Sie viele Daten (2), empfangen Sie Daten (3). Bitte beachten Sie, dass alle Daten in Blöcken gesendet werden, die ein Vielfaches von vier Bytes sind. Dies ist alles, weil wir einen 8-in-32-Adapter haben. Am Ende sollten die Daten in doppelten Worten stehen. Ansonsten ist alles klar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein Programm für NIOS II entwickeln, sollten Sie zuerst BSP konfigurieren. Ich erinnere Sie daran, dass ich das Programm selbst gemäß der Hello World Small-Vorlage erstelle. Die geänderten Felder im BSP sind in der folgenden Abbildung rot markiert (wie das Programm aus der Vorlage erstellt und wie das BSP korrigiert wird, wurde in einem der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausführlich erläutert </font><font style="vertical-align: inherit;">). Ich möchte Sie daran erinnern, dass ich die Wurzel des Baums, dh das Element Einstellungen, auswähle, sodass alle Einstellungen sofort rechts sichtbar sind. </font></font><br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes generiere BSP und ändere aufgrund meiner Gewohnheit den Dateinamen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.cpp. </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Danach </font></b><b><font style="vertical-align: inherit;">bereinige</font></b><font style="vertical-align: inherit;"> ich das Projekt, damit bei dieser Umbenennung keine Fehler auftreten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde die Arbeit ganz oberflächlich überprüfen (ein echter Tester würde sicherlich die Übertragung großer Datenmengen, die die FIFO-Größe überschreiten, gründlich testen, aber der Zweck des Artikels besteht darin, die Grundprinzipien aufzuzeigen und nicht sicherzustellen, dass sie aufgrund ihrer wahnsinnigen Größe nicht mehr gelesen werden können). </font><font style="vertical-align: inherit;">Und ich werde die Grundprinzipien in zwei Schritten zeigen. </font><font style="vertical-align: inherit;">Der erste Schritt besteht darin, die Datenübertragung vom Zentralprozessor zu NIOS II zu überprüfen. </font><font style="vertical-align: inherit;">Dafür habe ich folgenden Code entwickelt:</font></font><br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Programm wartet darauf, dass Daten im FIFO angezeigt werden. </font><font style="vertical-align: inherit;">Wenn sie dort erschienen sind, werden sie angezeigt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Test kommen. </font><font style="vertical-align: inherit;">Zuerst werde ich so tun, als hätte ich vergessen, mit dem Timing zu beginnen. </font><font style="vertical-align: inherit;">Daher lade ich nach dem Einschalten von Redd die FPGA-Firmware und versuche dann, ein Debugging-Programm für NIOS II auszuführen. </font><font style="vertical-align: inherit;">Ich bekomme diese Nachricht:</font></font><br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dasselbe haben, bedeutet dies, dass Sie wirklich vergessen haben, das Prozessorsystem zu takten. Aber jetzt wissen Sie, wie Sie es schnell identifizieren können. Und um dies zu vermeiden, ist es notwendig und ausreichend, das Programm auszuführen, das wir für den Zentralprozessor geschrieben haben. Sobald die FT2232-Brücke gestartet und initialisiert wird, werden Taktimpulse an unseren Prozessor gesendet, und es ist möglich, den Vorgang des Startens des Debuggens zu wiederholen. Darüber hinaus kann das Programm für den Zentralprozessor zu diesem Zeitpunkt abgeschlossen sein. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taktimpulse</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehen nirgendwo hin: Die Brücke ist bereits für den </font><b><font style="vertical-align: inherit;">FT245-SYNC-</font></b><font style="vertical-align: inherit;"> Modus konfiguriert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drücken Sie im Programm für den Zentralprozessor 1. Je nach Situation wird im Terminal entweder </font><b><font style="vertical-align: inherit;">Folgendes </font></b><b><font style="vertical-align: inherit;">angezeigt</font></b><font style="vertical-align: inherit;"> : </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 empfangene Wörter: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 empfangene Wörter:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xb0a0908,0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entweder: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3 Wörter die Received: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504,0xb0a0908, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x1 Wörter die Received: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Prinzip kann es 1, dann 3 Doppelwörter geben, aber das ist mir nicht eingefallen. Es hängt alles davon ab, wie viele Bytes Zeit haben, um auf dem Bus zu laufen, bevor die erste Anzeige beginnt. Und wenn es gestartet wurde, haben am Ende alle anderen Bytes Zeit zum Ausführen, da die Datenübertragung über JTAG kein schneller Prozess ist. Wenn der Bus Bursts verwendet, kann das Programm die Daten erst nach Empfang des Pakets sehen. In einigen Fällen ist es gut (es gibt noch kein Paket, warum sollte ich es sehen? Besonders wenn das Paket vorübergehend ist), in einigen Fällen ist es schlecht (FIFO ist eine Black Box, für die endgültige Verarbeitung sollten die Daten in den adressierbaren RAM kopiert werden, und dies geschieht besser parallel zum Empfang von Daten ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die übertragenen Daten werden in Doppelwörtern in Little Endian-Notation platziert. Ich möchte Sie daran erinnern, dass das folgende Array übergeben wird:</font></font><br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  Alles ist richtig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie im Programm Punkt 2 für den Zentralprozessor auswählen, wird eine Meldung angezeigt (zur besseren Lesbarkeit werden die Zeilen bei der Vorbereitung des Artikels formatiert): </font></font><br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist auch wahr. </font><font style="vertical-align: inherit;">Wir prüfen den Rückwärtsgang. </font><font style="vertical-align: inherit;">Wir ersetzen das Programm für NIOS II durch Folgendes:</font></font><br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wählen Punkt 3 im Programm für den Zentralprozessor aus und führen diese Version des Programms für NIOS II aus. </font><font style="vertical-align: inherit;">Wir </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhalten</font></font><br><br><font style="vertical-align: inherit;"></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">16 Bytes (4 DWORDs) </font></b><b><font style="vertical-align: inherit;">empfangen 0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00,</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beide Kanäle arbeiten grob. </font><font style="vertical-align: inherit;">Und wir werden es irgendwie ein anderes Mal überprüfen.</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel beschreibt die Grundlagen des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avalon-ST-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bus-Streaming-Protokolls </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Durch dieses Protokoll wird die Verbindung des Redd-Zentralprozessors mit dem im FPGA implementierten Prozessorsystem organisiert. </font><font style="vertical-align: inherit;">Die Leser erhielten eine Vorstellung von der einfachsten Interaktionsmethode zwischen Zentral- und Hilfsprozessoren. </font><font style="vertical-align: inherit;">Download gestartet in Entwicklungsprojekten kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kenntnisse über Streaming-Protokolle und deren Verwendung sind jedoch sehr grundlegend. </font><font style="vertical-align: inherit;">In den folgenden Artikeln wird gezeigt, wie mit diesen Protokollen Daten im dynamischen RAM auf der Redd-Karte effizient gespeichert werden können.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462253/">https://habr.com/ru/post/de462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462221/index.html">Wie enttäuscht ich von Google Play bin</a></li>
<li><a href="../de462227/index.html">Moskau, 9. August - Backend Stories 4.0</a></li>
<li><a href="../de462243/index.html">Verbessern der Magento-Front-End-Leistung mit ReactJS</a></li>
<li><a href="../de462245/index.html">Auto Git Bisect als Beispiel für den Linux-Kernel</a></li>
<li><a href="../de462251/index.html">Ist der Inkognito-Modus im Browser eine Fiktion?</a></li>
<li><a href="../de462257/index.html">Kafka auf Kubernetes - ist das gut?</a></li>
<li><a href="../de462259/index.html">Erstellen eines Controllers für ein Smart Home</a></li>
<li><a href="../de462263/index.html">Pedal auf den Boden: Erstellen Sie einen weiteren Fußmanipulator für den PC</a></li>
<li><a href="../de462265/index.html">Python und Würfel</a></li>
<li><a href="../de462267/index.html">Lernen Sie den PVS-Studio Static Analyzer für Java kennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>