<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ­ ğŸ„ ğŸ¨ Bagaimana saya membuat filter yang tidak merusak gambar bahkan setelah jutaan berjalan - bagian 2 ğŸš‹ ğŸ–Œï¸ ğŸ˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama dari posting ini, saya berbicara tentang bagaimana berulang kali menggunakan filter halfpel standar membuat gambar terdistorsi, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya membuat filter yang tidak merusak gambar bahkan setelah jutaan berjalan - bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="gambar"></div><br>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari</a> posting ini, saya berbicara tentang bagaimana berulang kali menggunakan filter halfpel standar membuat gambar terdistorsi, dan kemudian menunjukkan filter baru yang tidak memiliki masalah ini. <br><br>  Itu sedikit lebih buram dan ini tidak cocok untuk semua orang.  Namun, itu lebih baik daripada alternatifnya - pada kenyataannya, filter ini digunakan dalam versi asli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bink 2</a> .  Karena beban kerja terus-menerus, saya tidak pernah berhasil kembali kepadanya dan memeriksanya secara lebih rinci. <br><br>  Tetapi sekarang setelah saya <i>menemukan</i> waktu untuk kembali ke filter ini dan menulis artikel tentang itu, saya akhirnya harus bertanya: apakah ada filter yang <i>kurang buram</i> yang masih mempertahankan properti "stabilitas tak terbatas"? <br><br>  Peringatan spoiler: jawaban yang benar adalah "mungkin tidak" dan "pasti ada."  Tetapi sebelum kita sampai pada mengapa ada dua jawaban untuk pertanyaan ini dan apa artinya, mari kita siapkan bangku tes. <br><a name="habracut"></a><br><h2>  Penyesuaian offset </h2><br>  Ketika saya awalnya menangani masalah ini, saya tidak tahu apa yang saya cari.  Saya bahkan tidak tahu bahwa <i>ada yang</i> namanya filter halfpel "sangat stabil", jadi saya tidak membuat sistem dalam pencariannya.  Saya hanya mencari sesuatu yang akan menahan iterasi filter "banyak" tanpa distorsi gambar.  Semua gambar dari bagian pertama mencerminkan metodologi ini: gambar digeser dari kanan ke kiri setengah piksel pada suatu waktu, yaitu, jika Anda menerapkan filter 100 kali, gambar yang dihasilkan akan bergeser 50 piksel. <br><br>  Sekarang kita tahu apa <i>yang sebenarnya</i> kita cari, kita bisa menjadi sedikit lebih tepat.  Menerapkan filter halfpel dua kali, kami menggeser gambar tepat satu piksel.  Artinya, jika kita hanya <i>memindahkan gambar satu piksel ke belakang</i> , maka gambar itu akan tetap berada di ruang yang sama.  Berkat ini, pengujian akan terlihat jauh lebih indah, karena kita tidak hanya akan dapat menerapkan filter beberapa kali, tanpa takut bahwa gambar akan "merayap" dari layar, tetapi kita juga akan dapat menemukan <i>perbedaan</i> gambar dengan versi sebelumnya dan aslinya. <br><br>  Ini akan memungkinkan kami untuk menguji filter secara otomatis.  Kami cukup menerapkan filter berkali-kali dan melihat salah satu dari dua hal: baik konvergensi ke gambar yang tidak berubah, menunjukkan bahwa filter stabil sangat jauh, atau penyimpangan yang sangat besar dari gambar asli, menunjukkan bahwa filter "rusak".  Untuk pengujian ini, saya memilih kesalahan rata-rata per saluran 64 (dari 255), atau kesalahan maksimum pada salah satu saluran ke 255 penuh, sebagai "sangat besar". Jika salah satu dari kondisi ini benar, kami akan menganggap bahwa filter "pecah" ". <br><br><h2>  Tes ulang filter dari bagian pertama </h2><br>  Jadi, sekarang kita lebih memahami cara menguji filter ini, jadi mari kita lihat filter baru dari bagian pertama.  Mari kita mulai dengan bilinear, yang tentu saja tidak terlalu menarik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Ini adalah gambar setelah 244 iterasi.  Seperti yang Anda harapkan, gambar secara bertahap "pecah" karena rata-rata piksel yang konstan.  Tetapi bahkan secara bertahap mencapai batas kesalahan rata-rata. <br><br>  Inilah h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Untuk memecahkan gambar, 78 iterasi sudah cukup baginya.  Filter HEVC dengan 8 sampel berperilaku sedikit lebih baik, tetapi masih rusak setelah 150 iterasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos dengan 6 sampel istirahat setelah 166 iterasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  Itu semua filter kami yang rusak.  Yang tersisa hanyalah filter integer saya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Seperti yang diharapkan, dia <i>bukan</i> satu <i>-</i> satunya yang hancur.  Ini konvergen ke gambar yang tak terhingga stabil setelah 208 iterasi. <br><br>  Apa yang kita ketahui cukup luar biasa di sini: setidaknya untuk berbagai gambar uji, filter ini <i>sangat stabil</i> , yaitu, ia tidak akan pernah membuat artefak, tidak peduli berapa kali itu digunakan. <br><br>  Ini membawa kita kembali ke pertanyaan awal: apakah dia benar-benar yang terbaik?  Dan Anda sudah tahu jawabannya, karena di awal artikel saya juga menulis: "mungkin tidak" dan "pasti, ya". <br><br>  Pertama-tama mari kita lihat bagian "mungkin bukan". <br><br><h2>  Filter integer </h2><br>  Jadi, di bagian pertama posting, saya menyebutkan bahwa inti filter yang saya temukan adalah "yang terbaik dari yang terdeteksi", dan ini adalah kekhasannya.  Dan inilah fiturnya: <br><br>  Ketika saya mencari filter ini, <i>sebenarnya</i> saya tidak mencari filter <i>terbaik</i> .  Saya mencari filter terbaik <i>yang dapat diekspresikan dengan sejumlah kecil bilangan bulat, penambahan, dan pengurangan bilangan bulat</i> .  Ini mungkin terlihat aneh, tetapi luangkan waktu Anda. <br><br>  Anda mungkin telah memperhatikan bahwa ketika saya menunjukkan koefisien h.264, HEVC, dan filter bilinear, serta filter saya, saya menuliskannya sebagai pembilang bilangan bulat di atas penyebut bilangan bulat, seperti ini: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Tetapi dalam kasus windowed sinc, saya bertindak berbeda dan menulisnya seperti ini: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  Alasannya adalah karena windowed sinc sebenarnya disimpulkan dari fungsi matematika kontinu yang tidak ada hubungannya dengan pecahan bilangan bulat biasa.  Saat menggunakan filter ini, angka floating point (seakurat mungkin) digunakan yang sesuai dengan nilai fungsi sinc.  Jika Anda berusaha untuk menerapkannya secara akurat, maka Anda tidak harus membulatkannya ke fraksi biasa, karena ini akan menambah kesalahan. <br><br>  Codec video biasanya tidak mampu melakukan operasi seperti itu.  Operasi titik apung pada tugas "berat" seperti kompensasi gerak tidak mungkin digunakan pada daya rendah atau peralatan khusus.  Ini <i>terutama</i> benar jika kita berbicara tentang codec standar industri yang harus dijalankan pada berbagai perangkat, termasuk chip tertanam berbiaya rendah dan murah. <br><br>  Selain itu, bahkan jika Anda mengeksekusi mereka pada CPU, set instruksi modern didasarkan pada SIMD, yaitu, operasi integer pada CPU masih dapat dilakukan lebih cepat: Anda dapat memasukkan dua integer 16-bit ke dalam ruang satu float 32-bit, pada dasarnya menggandakan kinerja operasi, oleh karena itu, jika kita mempertimbangkan jumlah pasti siklus per operasi, maka titik apung tidak selalu merupakan pilihan tercepat. <br><br>  Sekarang Anda tahu mengapa fitur ini penting.  Karena saya hanya membutuhkan operasi integer 16-bit yang sederhana, saya mencari kernel yang dapat dinyatakan sebagai integer kecil di atas pembagi dengan kekuatan dua hingga 64 dan tidak lebih.  Ini adalah set filter yang jauh lebih terbatas dibandingkan dengan jika saya mempertimbangkan set 6 koefisien floating point. <br><br>  Demikian pula, untuk alasan efisiensi, saya tidak mempertimbangkan jumlah sampel lain.  Satu-satunya pilihan adalah 6 atau kurang, jadi saya bahkan tidak menguji versi dengan 8 atau 10 sampel. <br><br>  Jadi kami sampai pada jawaban pertama: "mungkin tidak."  Jika kita mematuhi batasan-batasan ini, maka kemungkinan besar kita tidak akan menemukan filter yang lebih baik yang dapat diterapkan berkali-kali tanpa degradasi.  Inti filter dari bagian pertama <i>mungkin</i> adalah <i>yang</i> terbaik yang bisa kita temukan, walaupun saya harus mengakui bahwa saya tidak dapat membuktikannya secara mendalam. <br><br>  Tetapi bagaimana jika kita <i>tidak perlu</i> mematuhi batasan seperti itu? <br><br><h2>  Versi titik mengambang </h2><br>  Jika kita menyingkirkan batasan khusus untuk versi asli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bink 2</a> (yang sekarang sudah ketinggalan zaman - banyak revisi telah dirilis) dan menggunakan koefisien floating-point yang sewenang-wenang, lalu seberapa banyak hasilnya dapat ditingkatkan? <br><br>  Yah, karena kita tahu bahwa kernel integer saya tidak pernah mengalami degradasi, dan kita tahu bahwa Lanczos lebih tajam, tetapi terdegradasi, masuk akal bahwa kita dapat menemukan tempat di <i>antara</i> dua set koefisien tempat degradasi dimulai.  Jadi saya menulis sebuah program yang membantu saya menemukan poin ini, dan inilah kernel yang saya temukan: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Kernel ini membutuhkan 272 iterasi untuk konvergen, tetapi ini sangat stabil dan terlihat <i>jauh</i> lebih tajam daripada filter integer saya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  Bahkan, hampir tidak bisa dibedakan dari aslinya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Hampir ... tetapi tidak cukup.  Jika Anda melihat lebih dekat, Anda masih bisa melihat buram dan atenuasi di area kontras tinggi.  Cara termudah untuk melihat ini adalah di mata "dinosaurus" oranye dan di daerah terang di balik bambu. <br><br>  Yaitu, filter titik-mengambang 6-sampel jelas lebih baik, tetapi itu tidak sempurna.  Apakah masih bisa diperbaiki? <br><br><h2>  Tambah lebar filter </h2><br>  Awalnya, filter dengan 6 sampel dipilih untuk alasan yang sama dengan fraksi dengan bilangan bulat kecil: Saya mencari filter yang sangat efisien.  Tetapi sekarang kami sedang melakukan penelitian dan telah beralih ke angka floating point, jadi mengapa tidak mempertimbangkan filter yang lebih luas? <br><br>  Menggabungkan filter integer 6-sampel kami dengan Lanczos 6-sampel, kami mendapatkan filter yang sangat baik.  Mengapa kita tidak memasangkan Lanczos 8 sampel? <br><br>  8-sampel Lanczos terlihat seperti ini: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Seperti Lanczos 6-sampel, sangat tidak stabil dan runtuh setelah 178 iterasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Jika kami mencari filter yang lebih baik antara filter integer 6-sampel dan Lanczos 8-sampel, kami menemukan filter 8-sampel yang agak luar biasa ini: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  Sebagai filter yang sangat stabil, kinerjanya sangat baik.  Ia menyatu setelah 202 iterasi (konvergensi lebih cepat dari dua filter saya), dan sangat mirip dengan aslinya sehingga sulit untuk mengetahui yang mana di antaranya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Ini yang asli sebagai referensi lagi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Dibandingkan dengan filter integer asli saya, ada peningkatan yang signifikan. <br><br><h2>  Bagaimana cara kerja filter yang sangat stabil? </h2><br>  Saya akan mengakhiri tulisan ini seperti ini: <br><br>  â€œSaya tidak tahu persis bagaimana cara kerjanya.  Di daerah lain di mana saya telah bekerja dengan transformasi yang berlaku tak terbatas, saya tahu bagaimana matematika batas dilakukan dan analisis yang berguna dibuat.  Pertama-tama, ia datang ke analisis permukaan batas untuk permukaan subdivisi, di mana nilai eigen dan vektor eigen dari matriks subdivisi dihitung, setelah itu dimungkinkan untuk secara tepat mengambil batas ke tingkat yang tak terbatas.  Tapi saya tidak punya pengalaman dalam melakukan analisis seperti itu untuk filter halfpel, karena mereka tidak meninggalkan piksel di tempat, tetapi menggeser mereka ke samping. " <br><br>  Itu rencanaku.  Tetapi di antara penulisan bagian pertama dan kedua, saya mengirimkan hasil filter yang ditingkatkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fabien Giessen</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Charles Bloom</a> .  Tidak mengherankan bahwa <i>mereka</i> tahu matematika yang diperlukan untuk studi analitis masalah ini.  Ternyata untuk filter benar-benar ada analisis nilai eigen dan vektor, tetapi tidak cukup berhasil seperti itu. <br><br>  Tapi itu <i>dapat</i> dengan mudah dieksekusi - pada kenyataannya, ini dibangun ke dalam program CAM sebagai proses satu langkah sepele dan kita benar-benar dapat melihat nilai eigen untuk filter.  Dia tidak memberi kita jawaban lengkap, karena di sini fakta <i>pembulatan</i> (atau pemotongan) menjadi 8 bit (atau 10 bit, atau 12 bit) setelah setiap penyaringan adalah penting, karena pemotongan mempengaruhi metode akumulasi kesalahan dibandingkan dengan aljabar yang sangat akurat. <br><br>  Sayangnya, karena ini sama sekali bukan bidang keahlian saya, saya bahkan tidak bisa mendapatkan gambaran umum dari analisis ini.  Saya bertanya kepada Fabien dan Charles apakah mereka dapat menulis posting dengan informasi bagus yang mereka kirimkan kepada saya melalui pos (mereka berdua memiliki blog teknis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ryg</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cbloom rants</a> ), dan Fabien menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel yang bagus tentang dasar matematika dari filter stabil</a> .  Jika Anda tertarik pada struktur teoritis tentang apa yang terjadi di dua posting saya, maka saya sarankan membaca seri ini! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468629/">https://habr.com/ru/post/id468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468615/index.html">10 Bahasa Teratas untuk Pelokalan Aplikasi</a></li>
<li><a href="../id468621/index.html">Kami menerjemahkan jaringan rumah ke DoH, atau klik lain pada hidung pemfilteran</a></li>
<li><a href="../id468623/index.html">Saya ingin ulasan tentang Habr</a></li>
<li><a href="../id468625/index.html">Tanpa server: 15% lebih lambat dan delapan kali lebih mahal</a></li>
<li><a href="../id468627/index.html">ADAM-6200 I / O Modul</a></li>
<li><a href="../id468631/index.html">Menguji aplikasi Flutter. Mulai</a></li>
<li><a href="../id468635/index.html">Logam Transisi Dichalcogenides: Membuka Kunci Rahasia Pertumbuhan Kristal WS2</a></li>
<li><a href="../id468637/index.html">Cara menangani dataset besar di panda. Kami bekerja dengan database FIAS menggunakan python dan memori 8GB</a></li>
<li><a href="../id468639/index.html">Apa yang baru di konsol web 2019</a></li>
<li><a href="../id468641/index.html">Tutorial Untuk Membuat Solusi Blockchain di Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>