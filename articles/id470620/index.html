<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛲️ 😶 👩🏿‍🤝‍👩🏻 Infrastruktur sebagai Kode: Cara Mengatasi Masalah dengan XP 🕢 👤 💪🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Sebelumnya, saya mengeluh tentang kehidupan di Infrastruktur sebagai paradigma kode dan tidak menawarkan apa pun untuk menyelesaikan situa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastruktur sebagai Kode: Cara Mengatasi Masalah dengan XP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/470620/">  Halo, Habr!  Sebelumnya, saya mengeluh tentang kehidupan di Infrastruktur sebagai paradigma kode dan tidak menawarkan apa pun untuk menyelesaikan situasi ini.  Hari ini saya kembali untuk memberi tahu Anda pendekatan dan praktik apa yang akan membantu untuk keluar dari jurang keputusasaan dan mendapatkan situasi di jalur yang benar. <br><br><img src="https://habrastorage.org/webt/xh/kw/uy/xhkwuy2lwzqfn2qpd2gzcbkqqzk.png"><br><a name="habracut"></a><br>  Dalam artikel sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Infrastruktur sebagai kode: kenalan pertama"</a> saya membagikan kesan saya tentang bidang ini, mencoba untuk merefleksikan situasi saat ini di bidang ini, dan bahkan menyarankan bahwa praktik standar yang diketahui oleh semua pengembang dapat membantu.  Tampaknya ada banyak keluhan tentang kehidupan, tetapi tidak ada proposal untuk keluar dari situasi ini. <br><br><h2>  Siapa kita, di mana kita berada dan masalah apa yang kita miliki </h2><br>  Kami sekarang berada di Sre Onboarding Team, yang terdiri dari enam programmer dan tiga insinyur infrastruktur.  Kita semua mencoba menulis Infrastruktur sebagai kode (IaC).  Kami melakukan ini karena, pada prinsipnya, kami dapat menulis kode dan dalam sejarah kami adalah pengembang tingkat "di atas rata-rata". <br><br><ul><li>  Kami memiliki serangkaian keunggulan: latar belakang tertentu, pengetahuan praktik, kemampuan menulis kode, keinginan untuk mempelajari hal-hal baru. </li><li>  Dan ada bagian yang melorot, itu juga minus: kurangnya pengetahuan tentang material infrastruktur. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Tumpukan teknologi yang kami gunakan di IaC kami.</b> <div class="spoiler_text"><ul><li>  Terraform untuk membuat sumber daya. </li><li>  Packer untuk merakit gambar.  Ini adalah gambar Windows CentOS 7. </li><li>  Jsonnet untuk melakukan build yang kuat di drone.io, serta menghasilkan packer json dan modul terraform kami. </li><li>  Azure </li><li>  Dimungkinkan untuk memasak gambar. </li><li>  Python untuk layanan dukungan serta skrip penyediaan. </li><li>  Dan semua ini dalam VSCode dengan plugin yang dibagikan di antara anggota tim. </li></ul><br></div></div><br>  Kesimpulan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> saya adalah ini: Saya mencoba menginspirasi optimisme (terutama dalam diri saya), saya ingin mengatakan bahwa kami akan mencoba pendekatan dan praktik yang kami ketahui untuk menghadapi kesulitan dan kesulitan yang ada di area ini. <br><br>  Kami sekarang berjuang dengan masalah IaC ini: <br><br><ul><li>  Ketidaksempurnaan alat, alat pengembangan kode. </li><li>  Penempatan yang lambat.  Infrastruktur adalah bagian dari dunia nyata, dan bisa lambat. </li><li>  Kurangnya pendekatan dan praktik. </li><li>  Kami baru dan tidak tahu banyak. </li></ul><br>
<h2>  Extreme Programming (XP) untuk penyelamatan </h2><br>  Semua pengembang akrab dengan pemrograman ekstrim (XP) dan praktik di baliknya.  Banyak dari kita yang mengerjakan pendekatan ini, dan itu berhasil.  Jadi mengapa tidak memanfaatkan prinsip dan praktik yang ada di sana untuk mengatasi kesulitan infrastruktur?  Kami memutuskan untuk menerapkan pendekatan ini dan melihat apa yang terjadi. <br><br><div class="spoiler">  <b class="spoiler_title">Memeriksa penerapan pendekatan XP ke bidang Anda</b> <div class="spoiler_text">  Saya memberikan deskripsi lingkungan yang cocok untuk XP, dan bagaimana hubungannya dengan kami: <br><br>  1. Mengubah persyaratan perangkat lunak secara dinamis.  Kami mengerti apa tujuan akhirnya.  Namun detailnya bisa beragam.  Kita sendiri yang memutuskan kemana kita harus mengarahkan, sehingga persyaratannya berubah secara berkala (terutama oleh diri kita sendiri).  Jika Anda menggunakan tim SRE, yang dengan sendirinya melakukan otomatisasi, dan itu sendiri membatasi persyaratan dan ruang lingkup pekerjaan, maka item ini berjalan dengan baik. <br><br>  2. Risiko yang disebabkan oleh proyek waktu tetap menggunakan teknologi baru.  Kami mungkin menghadapi risiko ketika menggunakan beberapa hal yang tidak diketahui.  Dan ini 100% kasus kami.  Seluruh proyek kami adalah penggunaan teknologi yang belum sepenuhnya kami kenal.  Secara umum, ini adalah masalah yang konstan, karena  Di bidang infrastruktur, banyak teknologi baru yang terus muncul. <br><br>  3.4.  Tim pengembangan diperpanjang kecil, berlokasi bersama.  Teknologi yang Anda gunakan memungkinkan untuk pengujian unit dan fungsional otomatis.  Dua poin ini tidak cocok untuk kita.  Pertama, kami bukan tim, dan kedua, ada sembilan dari kami, yang dapat dianggap sebagai tim besar.  Meskipun, menurut sejumlah definisi tim "besar", banyak yang 14+ orang. <br></div></div><br>  Mari kita lihat beberapa praktik dari XP dan bagaimana mereka memengaruhi kecepatan dan kualitas umpan balik. <br><br><h4>  Prinsip loop umpan balik XP </h4><br>  Dalam pemahaman saya, umpan balik adalah jawaban untuk pertanyaan, apakah saya melakukan yang benar, apakah kita pergi ke sana?  Di XP, ada skema kecil ilahi dalam hal ini: loop umpan balik waktu.  Yang menarik adalah semakin rendah kita, semakin cepat kita bisa mendapatkan OS untuk menjawab pertanyaan yang diperlukan. <br><br><img src="https://habrastorage.org/webt/wi/hu/gh/wihughno8moqt-tfrdobdtinqgu.png"><br><br>  Ini adalah topik yang agak menarik untuk dibahas bahwa dalam industri IT kita dimungkinkan untuk mendapatkan OS dengan cepat.  Bayangkan betapa <s>menyakitkannya</s> melakukan proyek selama setengah tahun dan baru kemudian mengetahui bahwa kesalahan telah dilakukan di awal.  Ini terjadi dalam desain, dan dalam setiap konstruksi sistem yang kompleks. <br><br>  Dalam kasus kami, IaC membantu kami memberikan umpan balik.  Segera saya melakukan sedikit penyesuaian pada diagram di atas: kami tidak memiliki rencana rilis bulanan, tetapi terjadi beberapa kali sehari.  Beberapa praktik terkait dengan siklus OS ini, yang akan kami periksa lebih terinci. <br><blockquote>  Penting: umpan balik dapat menjadi solusi untuk semua masalah yang disebutkan di atas.  Bersama-sama dengan praktik XP, itu dapat menarik keputusasaan keluar dari jurang maut. </blockquote><br><h2>  Cara keluar dari jurang keputusasaan: tiga latihan </h2><br><h4>  Tes </h4><br>  Tes disebutkan dua kali dalam loop umpan balik XP.  Bukan hanya itu saja.  Mereka sangat penting untuk semua teknik pemrograman ekstrim. <br><br>  Diasumsikan bahwa Anda memiliki tes Unit dan Penerimaan.  Beberapa memberi Anda umpan balik dalam beberapa menit, yang lain dalam beberapa hari, karena mereka ditulis lebih lama, dan jarang berjalan. <br><br>  Ada piramida tes klasik, yang menunjukkan bahwa harus ada lebih banyak tes. <br><br><img src="https://habrastorage.org/webt/fj/li/n4/fjlin4rb99jpdlwowbefldiyn1u.png"><br><br>  Bagaimana skema ini berlaku bagi kami dalam proyek IaC?  Sebenarnya ... tidak ada. <br><br><ul><li>  Tes unit, terlepas dari kenyataan bahwa harus ada banyak, tidak bisa sangat banyak.  Atau mereka secara tidak langsung menguji sesuatu.  Bahkan, kita dapat mengatakan bahwa kita tidak menulisnya sama sekali.  Tetapi di sini ada beberapa aplikasi untuk tes semacam itu, yang masih berhasil kami lakukan: <br><br><ol><li>  Menguji kode di jsonnet.  Ini, misalnya, adalah perakitan pipa kami di drone, yang cukup rumit.  Kode jsonnet tercakup dengan baik oleh tes. <br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka pengujian Unit</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk Jsonnet</a> . </li><li>  Tes untuk skrip yang dieksekusi ketika sumber daya dimulai.  Script dengan Python, dan karenanya tes untuk mereka, dapat ditulis. </li></ol></li><li>  Verifikasi konfigurasi dalam pengujian berpotensi dilakukan, tetapi kami tidak melakukannya.  Anda juga dapat mengkonfigurasi verifikasi aturan konfigurasi sumber daya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tflint</a> .  Namun, hanya untuk terraform ada pemeriksaan yang terlalu mendasar, tetapi banyak skrip uji ditulis untuk AWS.  Dan kami berada di Azure, jadi ini tidak cocok lagi. </li><li>  Tes integrasi komponen: tergantung pada bagaimana Anda mengklasifikasikannya dan di mana Anda menempatkannya.  Tetapi mereka pada dasarnya bekerja. <br><br>  Seperti inilah tes integrasi. <br><br><img src="https://habrastorage.org/webt/d2/zn/v7/d2znv780vuvz8thnpnu0qf_-w2m.png"><br><br>  Ini adalah contoh ketika merakit gambar di Drone CI.  Untuk mencapai mereka, Anda harus menunggu 30 menit untuk mengumpulkan gambar Packer, lalu menunggu 15 menit lagi untuk berlalu.  Tetapi mereka! <br><br><div class="spoiler">  <b class="spoiler_title">Algoritma Validasi Gambar</b> <div class="spoiler_text"><ol><li>  Pertama, Packer harus menyiapkan gambar sepenuhnya. </li><li>  Di sebelah tes ada terraform dengan keadaan lokal, yang kami gunakan untuk menyebarkan gambar ini. </li><li>  Saat menggunakan, modul kecil digunakan berbaring di sebelahnya sehingga lebih mudah untuk bekerja dengan gambar. </li><li>  Ketika VM digunakan dari gambar, Anda dapat mulai memeriksa.  Sebagian besar pemeriksaan dilakukan dengan mobil.  Ini memeriksa bagaimana skrip bekerja saat startup, bagaimana daemon bekerja.  Untuk melakukan ini, melalui ssh atau winrm, kita pergi ke mesin yang baru saja dinaikkan dan memeriksa status konfigurasi atau apakah layanan telah meningkat. </li></ol><br></div></div></li><li>  Situasi serupa dengan tes integrasi dan dalam modul untuk terraform.  Berikut ini adalah tabel singkat yang menjelaskan fitur-fitur tes tersebut. <br><br><img src="https://habrastorage.org/webt/p9/m7/oj/p9m7ojmlfizgqgg8oplrf_at014.png"><br><br>  Umpan balik pipa di area 40 menit.  Semuanya butuh waktu yang sangat lama.  Ini dapat digunakan untuk regresi, tetapi untuk perkembangan baru umumnya tidak realistis.  Jika Anda benar-benar mempersiapkan ini, siapkan skrip yang sedang berjalan, Anda dapat menguranginya menjadi 10 menit.  Tapi ini masih bukan tes Unit, yang 100 buah dalam 5 detik. </li></ul><br>  Tidak adanya Unit-tes selama perakitan gambar atau modul terraform mendorong untuk beralih kerja ke layanan terpisah yang hanya dapat ditarik oleh REST, atau ke skrip Python. <br><br>  Sebagai contoh, kami perlu membuatnya sehingga ketika mesin virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai</a> , itu terdaftar sendiri di layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ScaleFT</a> , dan ketika itu sendiri hancur, itu dihapus sendiri. <br><br>  Karena ScaleFT adalah layanan, kami terpaksa bekerja dengannya melalui API.  Ada tertulis pembungkus yang dapat Anda tarik dan katakan: "Masuk dan hapus ini, itu."  Ini menyimpan semua pengaturan dan akses yang diperlukan. <br><br>  Kami sudah dapat menulis tes normal untuk ini, karena tidak berbeda dari perangkat lunak biasa dengan cara apa pun: beberapa apiha menjadi basah, Anda mencabut, dan lihat apa yang terjadi. <br><br><img src="https://habrastorage.org/webt/mz/pz/52/mzpz52xbe3-rysioz-y_j2fo5pk.png"><br><blockquote>  Hasil pengujian: Pengujian unit, yang seharusnya memberikan OS dalam satu menit, tidak memberikannya.  Dan jenis pengujian yang lebih tinggi dalam piramida memberikan efek, tetapi hanya sebagian dari masalah yang dibahas. </blockquote><h4>  Memasangkan pemrograman </h4><br>  Tes tentu saja bagus.  Anda dapat menulis banyak dari mereka, mereka dapat dari berbagai jenis.  Mereka akan bekerja di level mereka dan memberi kami umpan balik.  Tetapi masalah dengan tes Unit yang buruk, yang memberikan OS tercepat, tetap ada.  Pada saat yang sama, ia terus menginginkan OS yang cepat, mudah dan menyenangkan untuk bekerja dengannya.  Belum lagi kualitas solusinya.  Untungnya, ada teknik untuk memberikan umpan balik yang lebih cepat daripada tes unit.  Ini adalah pemrograman berpasangan. <br><br>  Saat menulis kode, saya ingin mendapatkan umpan balik tentang kualitasnya secepat mungkin.  Ya, Anda dapat menulis semuanya di cabang fitur (agar tidak membocorkan apa pun kepada siapa pun), buat permintaan tarik di github, tetapkan ke seseorang yang pendapatnya berat, dan tunggu jawaban. <br><br>  Tapi Anda bisa menunggu lama.  Semua orang sibuk, dan jawabannya, bahkan jika itu, mungkin bukan yang tertinggi dalam kualitas.  Misalkan jawabannya datang segera, pengulas langsung memahami seluruh gagasan, tetapi jawabannya tetap terlambat, setelah fakta.  Tetapi saya menginginkan sesuatu sebelumnya.  Berikut ini adalah pemrograman pasangan dan ditujukan untuk ini - sehingga segera, pada saat penulisan. <br><br>  Berikut ini adalah gaya pemrograman pasangan dan penerapannya dalam mengerjakan IaC: <br><br>  <b>1. Klasik, Berpengalaman + berpengalaman, pengatur waktu berubah.</b>  Dua peran - pengemudi dan navigator.  Dua orang.  Mereka bekerja pada satu kode dan mengubah peran setelah periode waktu tertentu yang telah ditentukan. <br><br>  Pertimbangkan kompatibilitas masalah kami dengan gaya: <br><br><ul><li>  Masalah: ketidaksempurnaan alat, alat untuk pengembangan kode. <br>  Dampak negatif: untuk berkembang lebih lama, kita melambat, laju / ritme kerja tersesat. <br>  Cara bertarung: kami menggunakan penyetelan lain, sebuah IDE umum dan masih belajar cara pintas. </li><li>  Masalah: Deployment yang lambat. <br>  Dampak negatif: menambah waktu untuk membuat bagian kode yang berfungsi.  Kami rindu saat menunggu, tangan ditarik untuk melakukan sesuatu yang lain saat Anda menunggu. <br>  Cara bertarung: tidak diatasi. </li><li>  Masalah: kurangnya pendekatan dan praktik. <br>  Efek negatif: tidak ada pengetahuan tentang bagaimana berbuat baik, tetapi seberapa buruk.  Perpanjang umpan balik. <br>  Cara berkelahi: pertukaran pendapat dan praktik dalam berpasangan hampir memecahkan masalah. </li></ul><br>  Masalah utama dengan menerapkan gaya ini ke IaC pada kecepatan yang tidak rata.  Dalam pengembangan perangkat lunak tradisional, Anda memiliki gerakan yang sangat seragam.  Anda dapat menghabiskan lima menit dan menulis N. Luangkan 10 menit dan menulis 2N, 15 menit - 3N.  Di sini Anda dapat menghabiskan lima menit dan menulis N, dan kemudian menghabiskan 30 menit lagi dan menulis sepersepuluh dari N. Di sini Anda tidak tahu apa-apa, Anda memiliki lelucon, tolol.  Uji coba membutuhkan waktu dan mengalihkan perhatian dari pemrograman itu sendiri. <blockquote>  Kesimpulan: dalam bentuknya yang murni tidak cocok untuk kita. </blockquote>  <b>2. Ping-pong.</b>  <b>Pendekatan ini mengasumsikan bahwa satu peserta sedang menulis tes dan yang lainnya sedang melakukan implementasi untuknya.</b>  Karena semuanya rumit dengan Tes-unit, dan Anda harus menulis tes integrasi yang panjang, seluruh kemudahan ping-pong hilang. <br><br>  Saya dapat mengatakan bahwa kami mencoba pemisahan tanggung jawab untuk merancang skrip pengujian dan menerapkan kode untuk itu.  Salah satu peserta membuat naskah, di bagian pekerjaan yang menjadi tanggung jawabnya, ia memiliki kata terakhir.  Dan yang lainnya bertanggung jawab untuk implementasi.  Itu bekerja dengan baik.  Kualitas skenario dengan pendekatan ini meningkat. <br><blockquote>  Kesimpulan: sayangnya, langkah kerja tidak memungkinkan penggunaan ping-pong, seperti praktik pemrograman pasangan di IaC. </blockquote><br>  <b>3. Gaya Kuat.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Latihan yang sulit</a> .  Idenya adalah bahwa satu peserta menjadi navigator direktori, dan yang kedua mengambil peran driver pelaksana.  Dalam hal ini, hak untuk membuat keputusan secara eksklusif dengan navigator.  Pengemudi hanya mencetak dan kata dapat mempengaruhi apa yang terjadi.  Peran tidak berubah untuk waktu yang lama. <br><br>  Sangat cocok untuk pelatihan, tetapi membutuhkan keterampilan lunak yang kuat.  Tentang ini, kita goyah.  Tekniknya sulit.  Dan intinya di sini bahkan bukan infrastruktur. <br><blockquote>  Kesimpulan: berpotensi diterapkan, kita tidak menyerah. </blockquote><br>  <b>4. Mobbing, berkerumun dan semua gaya yang terkenal, tetapi tidak tercantum di sini</b> tidak dianggap, karena  tidak mencoba dan mengatakan tentang hal itu dalam konteks pekerjaan kita tidak akan berhasil. <br><br><blockquote>  Hasil umum tentang penggunaan pemrograman pasangan: <br><br><ul><li>  Kami memiliki kecepatan kerja yang tidak merata, yang merobohkan. </li><li>  Kami mengalami soft skill yang kurang bagus.  Dan area subjek tidak berkontribusi untuk mengatasi kekurangan kami ini. </li><li>  Tes panjang, masalah dengan alat membuat pengembangan pasangan kental. </li></ul></blockquote>  <b>5. Meskipun demikian, ada keberhasilan.</b>  <b>Kami datang dengan metode konvergensi kami sendiri - divergensi.</b>  Saya akan menjelaskan secara singkat cara kerjanya. <br><br>  Kami memiliki mitra reguler selama beberapa hari (kurang dari seminggu).  Kami melakukan satu tugas bersama.  Untuk sementara kami duduk bersama: yang satu menulis, yang kedua duduk dan menonton sebagai tim pendukung.  Kemudian kami tidak setuju untuk sementara waktu, semua orang melakukan beberapa hal independen, lalu kami bertemu lagi, menyinkronkan dengan sangat cepat, melakukan sesuatu bersama dan sekali lagi menyimpang. <br><br><h4>  Perencanaan dan komunikasi </h4><br>  Blok terakhir dari praktik di mana masalah OS diselesaikan adalah organisasi pekerjaan dengan tugas itu sendiri.  Ini juga termasuk pertukaran pengalaman, yang merupakan pekerjaan pasangan luar.  Pertimbangkan tiga praktik: <br><br>  <b>1. Tugas melalui pohon tujuan.</b>  Kami mengorganisir manajemen umum proyek melalui pohon yang berjalan tanpa akhir ke masa depan.  Secara teknis, memimpin dilakukan di Miro.  Ada satu tugas - itu adalah tujuan menengah.  Entah tujuan atau kelompok tugas yang lebih kecil darinya.  Dari mereka adalah tugas itu sendiri.  Semua tugas dibuat dan dilakukan di forum ini. <br><br><img src="https://habrastorage.org/webt/he/2g/ce/he2gceusaq8xs-udpe3wmt08aks.png"><br><br>  Skema ini juga memberikan umpan balik yang terjadi sekali sehari ketika kami menyinkronkan di rapat umum.  Kehadiran di depan semua orang dari rencana bersama, sementara terstruktur dan benar-benar terbuka, memungkinkan setiap orang untuk mengikuti apa yang terjadi dan seberapa jauh kita telah maju. <br><br>  Keuntungan dari penglihatan tugas: <br><br><ul><li>  Kausalitas.  Setiap tugas mengarah ke beberapa tujuan global.  Tugas dikelompokkan ke dalam tujuan yang lebih kecil.  Domain infrastruktur itu sendiri cukup teknis.  Tidak selalu jelas apa dampak spesifik pada bisnis yang diberikan, misalnya, dengan menulis buku peringkat tentang migrasi ke nginx lain.  Kehadiran kartu target terdekat membuat ini lebih jelas. <br><img src="https://habrastorage.org/webt/ez/kn/xh/ezknxhk6viwkh5ninlkwra12spi.png"><br>  Sebab-akibat adalah sifat penting dari tugas.  Itu langsung menjawab pertanyaan: "Apakah saya melakukannya?" </li><li>  Paralelisme.  Ada sembilan dari kita, dan mustahil untuk menyerang semua orang dengan satu tugas secara fisik.  Tugas dari satu area juga mungkin tidak selalu cukup.  Kami dipaksa untuk bekerja paralel antara kelompok kerja kecil.  Pada saat yang sama, kelompok duduk di tugas mereka selama beberapa waktu, mereka dapat diperkuat oleh orang lain.  Orang-orang kadang-kadang jatuh dari kelompok kerja ini.  Seseorang pergi berlibur, seseorang membuat laporan untuk konferensi conf DevOps, seseorang menulis artikel tentang Habr.  Mengetahui tujuan dan sasaran apa yang dapat dilakukan secara paralel menjadi sangat penting. </li></ul><br>  <b>2. Penyaji reli pagi yang bisa berubah.</b>  Di stand-up, kami mendapat masalah seperti itu - orang melakukan banyak tugas secara paralel.  Kadang-kadang tugas digabungkan secara longgar dan tidak ada pemahaman tentang siapa yang melakukan apa.  Dan pendapat anggota tim lain sangat penting.  Ini adalah informasi tambahan yang dapat mengubah arah penyelesaian masalah.  Tentu saja, biasanya seseorang dipasangkan dengan Anda, tetapi konsultasi dan tip selalu tidak berlebihan. <br><br>  Untuk memperbaiki situasi ini, kami menerapkan teknik "Mengubah pimpinan terkemuka".  Sekarang mereka berputar pada daftar tertentu, dan ini memiliki efek.  Ketika sampai pada Anda, Anda dipaksa untuk terjun dan memahami apa yang terjadi untuk melakukan rapat scrum dengan baik. <br><br><img src="https://habrastorage.org/webt/hz/pm/ow/hzpmowjasfdrxguplylh7uzejn0.png"><br><br>  <b>3. Demo internal.</b>  Bantuan dalam memecahkan masalah dari pemrograman pasangan, visualisasi pada pohon tugas, dan bantuan di rapat umum scrum di pagi hari adalah baik, tetapi tidak sempurna.  Dalam pasangan Anda hanya dibatasi oleh pengetahuan Anda.  Pohon tugas membantu Anda memahami siapa melakukan apa secara global.  Dan tuan rumah dan kolega di pertemuan pagi tidak akan terjun jauh ke dalam masalah Anda.  Mereka pasti bisa melewatkan sesuatu. <br><br>  Solusinya ditemukan dalam menunjukkan pekerjaan yang dilakukan satu sama lain dan diskusi berikutnya.  Kami berkumpul seminggu sekali selama satu jam dan menunjukkan perincian solusi untuk tugas-tugas yang telah kami lakukan selama seminggu terakhir. <br><br>  Dalam proses demonstrasi, perlu untuk mengungkapkan rincian tugas dan pastikan untuk menunjukkan kerjanya. <br><br><div class="spoiler">  <b class="spoiler_title">Laporan dapat disimpan dalam daftar periksa.</b> <div class="spoiler_text">  1. Masukkan dalam konteks.  Dari mana datangnya tugas itu, mengapa itu dibutuhkan? <br><br>  2. Bagaimana masalah diselesaikan sebelumnya?  Misalnya, klik mouse besar diperlukan, atau umumnya tidak mungkin melakukan apa pun. <br><br>  3. Bagaimana kita memperbaikinya.  Sebagai contoh: "Lihat, sekarang ada scriptosik, ini adalah readme." <br><br>  4. Tunjukkan cara kerjanya.  Dianjurkan untuk langsung mengimplementasikan skrip pengguna apa pun.  Saya ingin X, lakukan Y, lihat Y (atau Z).  Misalnya, gunakan NGINX, url asap, saya mendapat 200 OK.  Jika aksinya panjang, siapkan di muka untuk ditampilkan nanti.  Dianjurkan untuk tidak pecah terutama jika rapuh satu jam sebelum demo. <br><br>  5. Jelaskan seberapa baik masalah itu diselesaikan, kesulitan apa yang tersisa, apa yang tidak selesai, perbaikan apa yang mungkin dilakukan di masa depan.  Sebagai contoh, sekarang cli, maka akan ada otomatisasi penuh dalam CI. <br><br>  Disarankan bagi setiap pembicara untuk menyimpan dalam waktu 5-10 menit.  Jika kinerja Anda jelas penting dan membutuhkan lebih banyak waktu, koordinasikan terlebih dahulu di saluran sre-pengambilalihan. <br></div></div><br>  Setelah bagian penuh waktu, selalu ada diskusi di utas.  Di sinilah umpan balik yang diperlukan pada tugas kami muncul. <br><br><img src="https://habrastorage.org/webt/wy/zr/sa/wyzrsasnwslanm8n2rxc9iowa_k.png"><br>  Akibatnya, survei dilakukan untuk mengidentifikasi manfaat dari apa yang terjadi.  Ini sudah merupakan umpan balik tentang esensi pidato dan pentingnya tugas. <br><br><img src="https://habrastorage.org/webt/fk/9k/3t/fk9k3tqucbitk0e7kctd-dqoebk.png"><br><br><h2>  Kesimpulan panjang dan apa selanjutnya </h2><br>  Tampaknya nada artikel tersebut agak pesimistis.  Ini tidak benar.  Dua tingkat umpan balik akar rumput, yaitu tes dan pemrograman pasangan, bekerja.  Tidak sesempurna dalam perkembangan tradisional, tetapi ada efek positif dari ini. <br><br>  Tes, dalam bentuk saat ini, hanya menyediakan sebagian cakupan kode.  Banyak fungsi konfigurasi yang tidak diuji.  Pengaruhnya terhadap kerja langsung ketika menulis kode rendah.  Namun, ada efek dari tes integrasi, dan mereka yang memungkinkan untuk melakukan refactoring tanpa rasa takut.  Ini pencapaian yang luar biasa.  Juga, dengan transfer fokus ke pengembangan dalam bahasa tingkat tinggi (kami memiliki python, go), masalahnya hilang.  Tetapi ada banyak pemeriksaan pada "lem" dan tidak perlu integrasi umum yang cukup. <br><br>  Bekerja berpasangan lebih tergantung pada orang tertentu.  Ada faktor tugas dan soft skill kita.  Ternyata sangat baik dengan seseorang, lebih buruk dengan seseorang.  Pasti ada manfaatnya.  Jelas bahwa bahkan dengan ketaatan yang tidak memadai terhadap aturan kerja berpasangan, fakta pelaksanaan tugas bersama secara positif mempengaruhi kualitas hasilnya.  Secara pribadi, lebih mudah dan lebih menyenangkan bagi saya untuk bekerja bersama. <br><br>  Cara tingkat lebih tinggi untuk mempengaruhi OS - perencanaan dan bekerja dengan tugas-tugas justru memberikan efek: pertukaran pengetahuan berkualitas tinggi dan peningkatan kualitas pengembangan. <br><br><h4>  Kesimpulan pendek dalam satu baris </h4><br><ul><li>  Praktik XP bekerja di IaC, tetapi dengan efisiensi yang lebih rendah. </li><li>  Perkuat apa yang berhasil. </li><li>  Rancang mekanisme dan praktik kompensasi Anda sendiri. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470620/">https://habr.com/ru/post/id470620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470610/index.html">Suatu hari dalam kehidupan seorang pengembang</a></li>
<li><a href="../id470612/index.html">Apa yang ditunjukkan voltmeter, atau soket matematika</a></li>
<li><a href="../id470614/index.html">Bagaimana grafik NES diatur?</a></li>
<li><a href="../id470616/index.html">Solusi baru untuk paradoks Fermi (mengapa kita sendirian di alam semesta)</a></li>
<li><a href="../id470618/index.html">Pemodelan tematik berita menggunakan analisis faktor</a></li>
<li><a href="../id470622/index.html">Tinjauan Umum Metode Pemilihan Fitur</a></li>
<li><a href="../id470628/index.html">Pembuatan kapal simulator ruang angkasa</a></li>
<li><a href="../id470632/index.html">Arend - bahasa tipe dependen berbasis HoTT (bagian 2)</a></li>
<li><a href="../id470634/index.html">Identifikasi lintas komunitas di Instagram untuk mengidentifikasi minat pengguna</a></li>
<li><a href="../id470638/index.html">Metode kuasi-Newtonian, atau ketika ada terlalu banyak turunan kedua untuk Athos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>