<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≥ üòõ üï∫üèº .NET-Referenztypen im Vergleich zu Werttypen. Teil 1 ‚ôâÔ∏è üêç ü§¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns zun√§chst √ºber Referenztypen und Werttypen sprechen. Ich denke, die Leute verstehen die Unterschiede und Vorteile von beiden nicht wirkl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET-Referenztypen im Vergleich zu Werttypen. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439486/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Lassen Sie uns zun√§chst √ºber Referenztypen und Werttypen sprechen.  Ich denke, die Leute verstehen die Unterschiede und Vorteile von beiden nicht wirklich.  Sie sagen normalerweise, dass Referenztypen Inhalte auf dem Heap speichern und Werttypen Inhalte auf dem Stapel speichern, was falsch ist. </p><br><p>  Lassen Sie uns die wirklichen Unterschiede diskutieren: </p><br><ul><li>  <em>Ein Werttyp</em> : Sein Wert ist <strong>eine gesamte Struktur</strong> .  Der Wert eines Referenztyps ist <strong>eine Referenz</strong> auf ein Objekt.  - Eine Struktur im Speicher: Werttypen enthalten nur die von Ihnen angegebenen Daten.  Referenztypen enthalten auch zwei Systemfelder.  Der erste speichert 'SyncBlockIndex', der zweite speichert die Informationen zu einem Typ, einschlie√ülich der Informationen zu einer virtuellen Methodentabelle (VMT). </li><li>  Referenztypen k√∂nnen Methoden haben, die bei der Vererbung √ºberschrieben werden.  Werttypen k√∂nnen nicht vererbt werden. </li><li>  Sie sollten einer Instanz eines Referenztyps Speicherplatz auf dem Heap zuweisen.  Ein Werttyp <em>kann</em> auf dem Stapel zugewiesen werden oder er wird Teil eines Referenztyps.  Dies erh√∂ht die Leistung einiger Algorithmen ausreichend. </li></ul><br><p>  Es gibt jedoch gemeinsame Merkmale: </p><br><ul><li>  Beide Unterklassen k√∂nnen den Objekttyp erben und dessen Vertreter werden. </li></ul><br><p>  Schauen wir uns die einzelnen Funktionen genauer an. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/z0/iq/m6/z0iqm6nihoilvykxs3el7zujlrk.jpeg"></a> </p><a name="habracut"></a><br><p>  Schauen wir uns die einzelnen Funktionen genauer an. </p><br><h2 id="copying">  Kopieren </h2><br><p>  Der Hauptunterschied zwischen den beiden Typen ist wie folgt: </p><br><ul><li>  Alle Variablen-, Klassen- oder Strukturfelder oder Methodenparameter, die einen Referenztyp annehmen, speichern <strong>eine Referenz</strong> auf einen Wert. </li><li>  Alle Variablen-, Klassen- oder Strukturfelder oder Methodenparameter, die einen Werttyp annehmen, speichern jedoch genau einen Wert, dh eine gesamte Struktur. </li></ul><br><p>  Dies bedeutet, dass das Zuweisen oder √úbergeben eines Parameters an eine Methode den Wert kopiert.  Auch wenn Sie die Kopie √§ndern, bleibt das Original gleich.  Wenn Sie jedoch Referenztypfelder √§ndern, wirkt sich dies auf alle Teile aus, die auf eine Instanz eines Typs verweisen.  Schauen wir uns das an <br>  Beispiel: </p><br><pre><code class="cs hljs">DateTime dt = DateTime.Now; <span class="hljs-comment"><span class="hljs-comment">// Here, we allocate space for DateTime variable when calling a method, // but it will contain zeros. Next, let's copy all // values of the Now property to dt variable DateTime dt2 = dt; // Here, we copy the value once again object obj = new object(); // Here, we create an object by allocating memory on the Small Object Heap, // and put a pointer to the object in obj variable object obj2 = obj; // Here, we copy a reference to this object. Finally, // we have one object and two references.</span></span></code> </pre> <br><p>  Es scheint, dass diese Eigenschaft mehrdeutige Codekonstrukte wie das erzeugt <br>  Code√§nderung in Sammlungen: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create an array of such structures and initialize the Data field = 5 var array = new [] { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field array[0].Data = 4; // Let's check the value Console.WriteLine(array[0].Data);</code> </pre> <br><p>  In diesem Code steckt ein kleiner Trick.  Es sieht so aus, als w√ºrden wir zuerst die Strukturinstanz abrufen und dann dem Datenfeld der Kopie einen neuen Wert zuweisen.  Dies bedeutet, dass wir beim √úberpr√ºfen des Werts erneut <code>5</code> sollten.  Dies ist jedoch nicht der Fall.  MSIL verf√ºgt √ºber eine separate Anweisung zum Festlegen der Werte von Feldern in den Strukturen eines Arrays, wodurch die Leistung erh√∂ht wird.  Der Code funktioniert wie vorgesehen: Das Programm funktioniert <br>  Ausgabe <code>4</code> an eine Konsole. </p><br><p>  Mal sehen, was passiert, wenn wir diesen Code √§ndern: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field list[0].Data = 4; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Die Kompilierung dieses Codes schl√§gt fehl, da Sie beim Schreiben der <code>list[0].Data = 4</code> die Kopie der Struktur erhalten.  Tats√§chlich rufen Sie eine Instanzmethode vom Typ <code>List&lt;T&gt;</code> , die dem Zugriff durch einen Index zugrunde liegt.  Es nimmt die Kopie einer Struktur aus einem internen Array ( <code>List&lt;T&gt;</code> speichert Daten in Arrays) und gibt diese Kopie von der Zugriffsmethode mithilfe eines Index an Sie zur√ºck.  Als N√§chstes versuchen Sie, die Kopie zu √§ndern, die nicht weiter verwendet wird.  Dieser Code ist sinnlos.  Ein Compiler verbietet ein solches Verhalten, da er wei√ü, dass Benutzer Werttypen missbrauchen.  Wir sollten dieses Beispiel folgenderma√üen umschreiben: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field. Then, let's save it again. var copy = list[0]; copy.Data = 4; list[0] = copy; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Dieser Code ist trotz seiner offensichtlichen Redundanz korrekt.  Das Programm wird <br>  Ausgabe <code>4</code> an eine Konsole. </p><br><p>  Das n√§chste Beispiel zeigt, was ich unter ‚Äûder Wert einer Struktur ist ein <br>  gesamte Struktur ‚Äù </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } int x = 5; PersonInfo person; int y = 6; // Variant 2 int x = 5; int Height; int Width; int HairColor; int y = 6;</code> </pre> <br><p>  Beide Beispiele sind hinsichtlich der Datenposition im Speicher √§hnlich, da der Wert der Struktur die gesamte Struktur ist.  Es ordnet den Speicher f√ºr sich selbst zu, wo er ist. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } class Employee { public int x; public PersonInfo person; public int y; } // Variant 2 class Employee { public int x; public int Height; public int Width; public int HairColor; public int y; }</code> </pre> <br><p>  Diese Beispiele √§hneln sich auch hinsichtlich der Position der Elemente im Speicher, da die Struktur einen definierten Platz unter den Klassenfeldern einnimmt.  Ich sage nicht, dass sie v√∂llig √§hnlich sind, da Sie Strukturfelder mit Strukturmethoden bedienen k√∂nnen. </p><br><p>  Dies ist nat√ºrlich bei Referenztypen nicht der Fall.  Eine Instanz selbst befindet sich auf dem nicht erreichbaren Heap f√ºr kleine Objekte (SOH) oder dem Heap f√ºr gro√üe Objekte (LOH).  Ein Klassenfeld enth√§lt nur den Wert eines Zeigers auf eine Instanz: eine 32- oder 64-Bit-Zahl. </p><br><p>  Schauen wir uns das letzte Beispiel an, um das Problem zu schlie√üen. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } void Method(int x, PersonInfo person, int y); // Variant 2 void Method(int x, int HairColor, int Width, int Height, int y);</code> </pre> <br><p>  In Bezug auf den Speicher funktionieren beide Codevarianten auf √§hnliche Weise, jedoch nicht in Bezug auf die Architektur.  Es ist nicht nur ein Ersatz f√ºr eine variable Anzahl von Argumenten.  Die Reihenfolge √§ndert sich, weil Methodenparameter nacheinander deklariert werden.  Sie werden auf √§hnliche Weise auf den Stapel gelegt. </p><br><p>  Der Stapel w√§chst jedoch von h√∂heren zu niedrigeren Adressen.  Das hei√üt, die Reihenfolge, in der eine Struktur St√ºck f√ºr St√ºck geschoben wird, unterscheidet sich von der Reihenfolge, in der sie als Ganzes geschoben wird. </p><br><h2 id="overridable-methods-and-inheritance">  √úberschreibbare Methoden und Vererbung </h2><br><p>  Der n√§chste gro√üe Unterschied zwischen den beiden Typen ist das Fehlen von virtuellen <br>  Methodentabelle in Strukturen.  Dies bedeutet, dass: </p><br><ol><li>  Sie k√∂nnen virtuelle Methoden in Strukturen nicht beschreiben und √ºberschreiben. </li><li>  Eine Struktur kann keine andere erben.  Die einzige M√∂glichkeit, die Vererbung zu emulieren, besteht darin, eine Basistypstruktur in das erste Feld einzuf√ºgen.  Die Felder einer "geerbten" Struktur folgen den Feldern einer "Basis" -Struktur und erzeugen eine logische Vererbung.  Die Felder beider Strukturen fallen basierend auf dem Versatz zusammen. </li><li>  Sie k√∂nnen Strukturen an nicht verwalteten Code √ºbergeben.  Sie verlieren jedoch die Informationen √ºber Methoden.  Dies liegt daran, dass eine Struktur nur ein Speicherplatz ist, der mit Daten ohne Informationen zu einem Typ gef√ºllt ist.  Sie k√∂nnen es ohne √Ñnderungen an nicht verwaltete Methoden √ºbergeben, die beispielsweise in C ++ geschrieben wurden. </li></ol><br><p>  Das Fehlen einer Tabelle mit virtuellen Methoden subtrahiert einen bestimmten Teil der Vererbungsmagie von den Strukturen, bietet ihnen jedoch andere Vorteile.  Die erste besteht darin, dass wir Instanzen einer solchen Struktur an externe Umgebungen (au√üerhalb von .NET Framework) √ºbergeben k√∂nnen.  Denken Sie daran, dies ist nur eine Erinnerung <br>  Reichweite!  Wir k√∂nnen auch einen Speicherbereich von nicht verwaltetem Code nehmen und einen Typ in unsere Struktur umwandeln, um den Zugriff auf die Felder zu erleichtern.  Sie k√∂nnen dies nicht mit Klassen tun, da diese zwei unzug√§ngliche Felder haben.  Dies sind SyncBlockIndex und eine Tabellenadresse f√ºr virtuelle Methoden.  Wenn diese beiden Felder an nicht verwalteten Code √ºbergeben werden, ist dies gef√§hrlich.  Mit einer virtuellen Methodentabelle kann man auf jeden Typ zugreifen und ihn √§ndern, um eine Anwendung anzugreifen. </p><br><p>  Lassen Sie uns zeigen, dass es sich nur um einen Speicherbereich ohne zus√§tzliche Logik handelt. </p><br><pre> <code class="plaintext hljs">unsafe void Main() { int secret = 666; HeightHolder hh; hh.Height = 5; WidthHolder wh; unsafe { // This cast wouldn't work if structures had the information about a type. // The CLR would check a hierarchy before casting a type and if it didn't find WidthHolder, // it would output an InvalidCastException exception. But since a structure is a memory range, // you can interpret it as any kind of structure. wh = *(WidthHolder*)&amp;hh; } Console.WriteLine("Width: " + wh.Width); Console.WriteLine("Secret:" + wh.Secret); } struct WidthHolder { public int Width; public int Secret; } struct HeightHolder { public int Height; }</code> </pre> <br><p>  Hier f√ºhren wir die Operation aus, die bei starker Eingabe unm√∂glich ist.  Wir wandeln einen Typ in einen anderen inkompatiblen Typ um, der ein zus√§tzliches Feld enth√§lt.  Wir f√ºhren eine zus√§tzliche Variable in die Main-Methode ein.  Theoretisch ist sein Wert geheim.  Der Beispielcode gibt jedoch den Wert einer Variablen aus, die in keiner der Strukturen innerhalb der <code>Main()</code> -Methode gefunden wurde.  Sie k√∂nnten es als Sicherheitsverletzung betrachten, aber die Dinge sind nicht so einfach.  Sie k√∂nnen nicht verwalteten Code in einem Programm nicht entfernen.  Der Hauptgrund ist die Struktur des Thread-Stacks.  Man kann damit auf nicht verwalteten Code zugreifen und mit lokalen Variablen spielen.  Sie k√∂nnen Ihren Code vor diesen Angriffen sch√ºtzen, indem Sie die Gr√∂√üe eines Stapelrahmens zuf√§llig festlegen.  Sie k√∂nnen auch die Informationen zum <code>EBP</code> Register l√∂schen, um die R√ºckgabe eines <code>EBP</code> zu erschweren.  Dies ist jedoch f√ºr uns jetzt nicht wichtig.  Was uns an diesem Beispiel interessiert, ist das Folgende.  Die "geheime" Variable steht <strong>vor</strong> der Definition der hh-Variablen und <strong>danach</strong> in der WidthHolder-Struktur (tats√§chlich an verschiedenen Stellen).  Warum haben wir seinen Wert leicht bekommen?  Die Antwort ist, dass der Stapel von rechts nach links w√§chst.  Die zuerst deklarierten Variablen haben viel h√∂here Adressen, und die sp√§ter deklarierten Variablen haben niedrigere Adressen. </p><br><h2 id="the-behavior-when-calling-instance-methods">  Das Verhalten beim Aufrufen von Instanzmethoden </h2><br><p>  Beide Datentypen haben eine weitere Funktion, die nicht klar erkennbar ist und die Struktur beider Typen erkl√§ren kann.  Es befasst sich mit dem Aufrufen von Instanzmethoden. </p><br><pre> <code class="plaintext hljs">// The example with a reference type class FooClass { private int x; public void ChangeTo(int val) { x = val; } } // The example with a value type struct FooStruct { private int x; public void ChangeTo(int val) { x = val; } } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); klass.ChangeTo(10); strukt.ChangeTo(10);</code> </pre> <br><p>  Logischerweise k√∂nnen wir entscheiden, dass die Methode einen kompilierten K√∂rper hat.  Mit anderen Worten, es gibt keine Instanz eines Typs, der √ºber einen eigenen kompilierten Satz von Methoden verf√ºgt, √§hnlich wie die S√§tze anderer Instanzen.  Die aufgerufene Methode wei√ü jedoch, zu welcher Instanz sie geh√∂rt, da der Verweis auf die Instanz eines Typs der erste Parameter ist.  Wir k√∂nnen unser Beispiel umschreiben und es wird mit dem identisch sein, was wir zuvor gesagt haben.  Ich verwende kein Beispiel absichtlich mit virtuellen Methoden, da sie eine andere Prozedur haben. </p><br><pre> <code class="plaintext hljs">// An example with a reference type class FooClass { public int x; } // An example with a value type struct FooStruct { public int x; } public void ChangeTo(FooClass klass, int val) { klass.x = val; } public void ChangeTo(ref FooStruct strukt, int val) { strukt.x = val; } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); ChangeTo(klass, 10); ChangeTo(ref strukt, 10);</code> </pre> <br><p>  Ich sollte die Verwendung des Schl√ºsselworts ref erkl√§ren.  Wenn ich es nicht verwenden w√ºrde, w√ºrde ich anstelle des Originals eine <strong>Kopie</strong> der Struktur als Methodenparameter erhalten.  Dann w√ºrde ich es √§ndern, aber das Original w√ºrde gleich bleiben.  Ich m√ºsste eine ge√§nderte Kopie von einer Methode an einen Aufrufer zur√ºckgeben (eine weitere Kopie), und der Aufrufer w√ºrde diesen Wert wieder in der Variablen speichern (eine weitere Kopie).  Stattdessen erh√§lt eine Instanzmethode einen Zeiger und verwendet ihn zum sofortigen √Ñndern des Originals.  Die Verwendung eines Zeigers hat keinen Einfluss auf die Leistung, da Operationen auf Prozessorebene Zeiger verwenden.  Ref ist ein Teil der C # -Welt, nicht mehr. </p><br><h2 id="the-capability-to-point-to-the-position-of-elements">  Die F√§higkeit, auf die Position von Elementen zu zeigen. </h2><br><p>  Sowohl Strukturen als auch Klassen haben eine andere F√§higkeit, auf den Versatz eines bestimmten Feldes in Bezug auf den Beginn einer Struktur im Speicher zu zeigen.  Dies dient mehreren Zwecken: </p><br><ul><li>  mit externen APIs in der nicht verwalteten Welt zu arbeiten, ohne nicht verwendete Felder vor einem erforderlichen einf√ºgen zu m√ºssen; </li><li>  um einen Compiler anzuweisen, ein Feld direkt am Anfang des Typs ( <code>[FieldOffset(0)]</code> ) zu <code>[FieldOffset(0)]</code> .  Dies beschleunigt die Arbeit mit diesem Typ.  Wenn es sich um ein h√§ufig verwendetes Feld handelt, k√∂nnen wir die Leistung der Anwendung steigern.  Dies gilt jedoch nur f√ºr Werttypen.  Bei Referenztypen enth√§lt das Feld mit einem Nullpunktversatz die Adresse einer virtuellen Methodentabelle, die 1 Maschinenwort enth√§lt.  Selbst wenn Sie das erste Feld einer Klasse adressieren, wird eine komplexe Adressierung (Adresse + Offset) verwendet.  Dies liegt daran, dass das am h√§ufigsten verwendete Klassenfeld die Adresse einer virtuellen Methodentabelle ist.  Die Tabelle ist erforderlich, um alle virtuellen Methoden aufzurufen. </li><li>  um mit einer Adresse auf mehrere Felder zu verweisen.  In diesem Fall wird derselbe Wert als unterschiedliche Datentypen interpretiert.  In C ++ wird dieser Datentyp als Union bezeichnet. </li><li>  sich nicht die M√ºhe machen, etwas zu deklarieren: Ein Compiler ordnet Felder optimal zu.  Daher kann die endg√ºltige Reihenfolge der Felder unterschiedlich sein. </li></ul><br><p>  <strong>Allgemeine Bemerkungen</strong> </p><br><ul><li>  <strong>Auto</strong> : Die Laufzeitumgebung w√§hlt automatisch einen Ort und eine Packung f√ºr alle Klassen- oder Strukturfelder aus.  Die definierten Strukturen, die von einem Mitglied dieser Aufz√§hlung markiert werden, k√∂nnen nicht in nicht verwalteten Code √ºbertragen werden.  Der Versuch, dies zu tun, f√ºhrt zu einer Ausnahme. </li><li>  <strong>Explizit</strong> : Ein Programmierer steuert explizit die genaue Position jedes Felds eines Typs mit dem FieldOffsetAttribute. </li><li>  <strong>Sequenziell</strong> : Typelemente werden in einer sequentiellen Reihenfolge geliefert, die w√§hrend des Typentwurfs definiert wird.  Der StructLayoutAttribute.Pack-Wert eines Packungsschritts gibt deren Position an. </li></ul><br><p>  <strong>Verwenden von FieldOffset zum √úberspringen nicht verwendeter Strukturfelder</strong> </p><br><p>  Die Strukturen aus der nicht verwalteten Welt k√∂nnen reservierte Felder enthalten.  Man kann sie in einer zuk√ºnftigen Version einer Bibliothek verwenden.  In C / C ++ f√ºllen wir diese L√ºcken, indem wir Felder hinzuf√ºgen, z. B. reserviert1, reserviert2, ... In .NET versetzen wir jedoch nur mit dem FieldOffsetAttribute-Attribut und <code>[StructLayout(LayoutKind.Explicit)]</code> an den Anfang eines Feldes. </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] public struct SYSTEM_INFO { [FieldOffset(0)] public ulong OemId; // 92 bytes reserved [FieldOffset(100)] public ulong PageSize; [FieldOffset(108)] public ulong ActiveProcessorMask; [FieldOffset(116)] public ulong NumberOfProcessors; [FieldOffset(124)] public ulong ProcessorType; }</code> </pre> <br><p>  Eine L√ºcke ist belegt, aber ungenutzter Raum.  Die Struktur hat die Gr√∂√üe 132 und nicht 40 Bytes, wie es von Anfang an scheinen mag. </p><br><p>  <strong>Union</strong> </p><br><p>  Mit dem FieldOffsetAttribute k√∂nnen Sie den C / C ++ - Typ emulieren, der als Union bezeichnet wird.  Es erm√∂glicht den Zugriff auf dieselben Daten wie Entit√§ten von <br>  verschiedene Arten.  Schauen wir uns das Beispiel an: </p><br><pre> <code class="plaintext hljs">// If we read the RGBA.Value, we will get an Int32 value accumulating all // other fields. // However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we // will get separate components of Int32. [StructLayout(LayoutKind.Explicit)] public struct RGBA { [FieldOffset(0)] public uint Value; [FieldOffset(0)] public byte R; [FieldOffset(1)] public byte G; [FieldOffset(2)] public byte B; [FieldOffset(3)] public byte Alpha; }</code> </pre> <br><p>  Man k√∂nnte sagen, dass ein solches Verhalten nur f√ºr Werttypen m√∂glich ist.  Sie k√∂nnen es jedoch f√ºr Referenztypen simulieren, indem Sie eine Adresse verwenden, um zwei Referenztypen oder einen Referenztyp und einen Werttyp zu √ºberlappen: </p><br><pre> <code class="plaintext hljs">class Program { public static void Main() { Union x = new Union(); x.Reference.Value = "Hello!"; Console.WriteLine(x.Value.Value); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</code> </pre> <br><p>  Ich habe absichtlich einen generischen Typ zum √úberlappen verwendet.  Wenn ich es gewohnt bin <br>  √úberlappend w√ºrde dieser Typ beim Laden in eine Anwendungsdom√§ne die TypeLoadException verursachen.  Theoretisch mag es wie eine Sicherheitsverletzung aussehen (insbesondere wenn es um Anwendungs- <strong>Plug-Ins geht</strong> ), aber wenn wir versuchen, diesen Code unter Verwendung einer gesch√ºtzten Dom√§ne <code>TypeLoadException</code> , erhalten wir dieselbe <code>TypeLoadException</code> . </p><br><h2 id="the-difference-in-allocation">  Der Unterschied in der Zuordnung </h2><br><p>  Ein weiteres Merkmal, das beide Typen unterscheidet, ist die Speicherzuordnung f√ºr Objekte oder Strukturen.  Die CLR muss √ºber mehrere Dinge entscheiden, bevor sie einem Objekt Speicher zuweist.  Wie gro√ü ist ein Objekt?  Ist es mehr oder weniger als 85K?  Wenn es weniger ist, gibt es dann gen√ºgend freien Speicherplatz auf dem SOH, um dieses Objekt zuzuweisen?  Wenn es mehr ist, aktiviert die CLR den Garbage Collector.  Es geht durch ein Objektdiagramm, komprimiert die Objekte, indem es sie in den freien Raum verschiebt.  Wenn auf dem SOH noch kein Speicherplatz vorhanden ist, wird die Zuweisung zus√§tzlicher virtueller Speicherseiten gestartet.  Erst dann wird einem Objekt Speicherplatz zugewiesen, der aus dem M√ºll entfernt wird.  Anschlie√üend legt die CLR SyncBlockIndex und VirtualMethodsTable fest.  Schlie√ülich kehrt der Verweis auf ein Objekt zu einem Benutzer zur√ºck. </p><br><p>  Wenn ein zugewiesenes Objekt gr√∂√üer als 85 KB ist, wird es in den Heap f√ºr gro√üe Objekte (Large Objects Heap, LOH) verschoben.  Dies ist bei gro√üen Strings und Arrays der Fall.  Hier m√ºssen wir aus der Liste der nicht besetzten Bereiche den am besten geeigneten Speicherplatz finden oder einen neuen zuweisen.  Es ist nicht schnell, aber wir werden sorgf√§ltig mit Objekten dieser Gr√∂√üe umgehen.  Wir werden hier auch nicht dar√ºber sprechen. </p><br><p>  Es gibt mehrere m√∂gliche Szenarien f√ºr RefTypes: </p><br><ul><li>  RefType &lt;85K, auf dem SOH ist Platz: schnelle Speicherzuweisung; </li><li>  RefType &lt;85K, der Speicherplatz auf dem SOH ist knapp: sehr langsame Speicherzuweisung; </li><li>  RefType&gt; 85K, langsame Speicherzuordnung. </li></ul><br><p>  Solche Operationen sind selten und k√∂nnen nicht mit ValTypes konkurrieren.  Der Algorithmus der Speicherzuordnung f√ºr Werttypen existiert nicht.  Die Speicherzuordnung f√ºr Werttypen kostet nichts.  Das einzige, was beim Zuweisen von Speicher f√ºr diesen Typ passiert, ist das Setzen von Feldern auf Null.  Mal sehen, warum dies passiert: 1. Wenn man eine Variable im Hauptteil einer Methode deklariert, ist die Zeit der Speicherzuweisung f√ºr eine Struktur nahe Null.  Dies liegt daran, dass der Zeitpunkt der Zuweisung f√ºr lokale Variablen nicht von ihrer Anzahl abh√§ngt.  2. Wenn ValTypes als Felder zugewiesen werden, erh√∂hen Reftypes die Gr√∂√üe der Felder.  Ein Werttyp wird vollst√§ndig zugewiesen und wird zu seinem Teil.  3. Wie beim Kopieren tritt bei der √úbergabe von ValTypes als Methodenparameter je nach Gr√∂√üe und Position eines Parameters ein Unterschied auf. </p><br><p>  Dies dauert jedoch nicht l√§nger als das Kopieren einer Variablen in eine andere. </p><br><h2 id="the-choice-between-a-class-or-a-structure">  Die Wahl zwischen einer Klasse oder einer Struktur </h2><br><p>  Lassen Sie uns die Vor- und Nachteile beider Typen diskutieren und ihre Verwendungsszenarien festlegen.  Ein klassisches Prinzip besagt, dass wir einen Werttyp w√§hlen sollten, wenn er nicht gr√∂√üer als 16 Byte ist, w√§hrend seiner Lebensdauer unver√§ndert bleibt und nicht vererbt wird.  Die Auswahl des richtigen Typs bedeutet jedoch, ihn aus verschiedenen Perspektiven zu √ºberpr√ºfen, basierend auf Szenarien der zuk√ºnftigen Verwendung.  Ich schlage drei Kriteriengruppen vor: </p><br><ul><li>  basierend auf der Typsystemarchitektur, in der Ihr Typ interagiert; </li><li>  basierend auf Ihrem Ansatz als Systemprogrammierer bei der Auswahl eines Typs mit optimaler Leistung; </li><li>  wenn es keine andere Wahl gibt. </li></ul><br><p>  Jedes entworfene Merkmal sollte seinen Zweck widerspiegeln.  Dies betrifft nicht nur den Namen oder die Interaktionsschnittstelle (Methoden, Eigenschaften).  Man kann architektonische √úberlegungen verwenden, um zwischen Wert- und Referenztypen zu w√§hlen.  Lassen Sie uns √ºberlegen, warum aus Sicht des Typsystemsystems eine Struktur und keine Klasse ausgew√§hlt werden k√∂nnte. </p><br><ol><li><p>  Wenn Ihr entworfener Typ f√ºr seinen Zustand agnostisch ist, bedeutet dies, dass sein Zustand einen Prozess widerspiegelt oder ein Wert von etwas ist.  Mit anderen Worten, eine Instanz eines Typs ist von Natur aus konstant und unver√§nderlich.  Wir k√∂nnen eine weitere Instanz eines Typs basierend auf dieser Konstante erstellen, indem wir einen Versatz angeben.  Oder wir k√∂nnen eine neue Instanz erstellen, indem wir ihre Eigenschaften angeben.  Wir d√ºrfen es jedoch nicht √§ndern.  Ich meine nicht, dass Struktur ein unver√§nderlicher Typ ist.  Sie k√∂nnen die Feldwerte √§ndern.  Dar√ºber hinaus k√∂nnen Sie mit dem Parameter ref einen Verweis auf eine Struktur an eine Methode √ºbergeben. Nach dem Beenden der Methode erhalten Sie ge√§nderte Felder.  Wor√ºber ich hier spreche, ist der architektonische Sinn.  Ich werde einige Beispiele geben. </p><br><ul><li>  DateTime ist eine Struktur, die das Konzept eines Zeitpunkts zusammenfasst.  Es speichert diese Daten als Uint, bietet jedoch Zugriff auf separate Merkmale eines bestimmten Zeitpunkts: Jahr, Monat, Tag, Stunde, Minuten, Sekunden, Millisekunden und sogar Prozessorticks.  Es ist jedoch unver√§nderlich und basiert auf dem, was es einschlie√üt.  Wir k√∂nnen keinen Moment in der Zeit √§ndern.  Ich kann nicht in der n√§chsten Minute leben, als w√§re es mein bester Geburtstag in der Kindheit.  Wenn wir also einen Datentyp ausw√§hlen, k√∂nnen wir eine Klasse mit einer schreibgesch√ºtzten Schnittstelle ausw√§hlen, die f√ºr jede √Ñnderung der Eigenschaften eine neue Instanz erzeugt.  Oder wir k√∂nnen eine Struktur ausw√§hlen, die die Felder ihrer Instanzen √§ndern kann, aber nicht sollte: Ihr <em>Wert</em> ist die Beschreibung eines Zeitpunkts wie einer Zahl.  Sie k√∂nnen nicht auf die Struktur einer Nummer zugreifen und diese √§ndern.  Wenn Sie einen weiteren Moment erhalten m√∂chten, der sich f√ºr einen Tag vom Original unterscheidet, erhalten Sie nur eine neue Instanz einer Struktur. </li><li>  <code>KeyValuePair&lt;TKey, TValue&gt;</code> ist eine Struktur, die das Konzept eines verbundenen Schl√ºssel-Wert-Paares kapselt.  Diese Struktur dient nur dazu, den Inhalt eines W√∂rterbuchs w√§hrend der Aufz√§hlung auszugeben.  Aus architektonischer Sicht sind ein Schl√ºssel und ein Wert untrennbare Konzepte in <code>Dictionary&lt;T&gt;</code> .  Im Inneren haben wir jedoch eine komplexe Struktur, in der ein Schl√ºssel getrennt von einem Wert liegt.  F√ºr einen Benutzer ist ein Schl√ºssel-Wert-Paar ein untrennbares Konzept in Bezug auf die Schnittstelle und die Bedeutung einer Datenstruktur.  Es ist ein ganzer <em>Wert</em> .  Wenn einem Schl√ºssel ein anderer Wert zugewiesen wird, √§ndert sich das gesamte Paar.  Sie repr√§sentieren also eine einzelne Einheit.  Dies macht eine Struktur in diesem Fall zu einer idealen Variante. </li></ul><br></li><li><p>  Wenn Ihr entworfener Typ ein untrennbarer Bestandteil eines externen Typs ist, aber strukturell ein integraler Bestandteil ist.  Das hei√üt, es ist falsch zu sagen, dass sich der externe Typ auf eine Instanz eines gekapselten Typs bezieht.  Es ist jedoch richtig zu sagen, dass ein gekapselter Typ zusammen mit all seinen Eigenschaften Teil eines externen Typs ist.  Dies ist n√ºtzlich, wenn Sie eine Struktur entwerfen, die Teil einer anderen Struktur ist. </p><br><ul><li>  Wenn wir beispielsweise eine Struktur eines Dateikopfs verwenden, ist es unangemessen, einen Verweis von einer Datei auf eine andere zu √ºbergeben, z. B. eine Datei header.txt.  Dies ist angemessen, wenn Sie ein Dokument in ein anderes einf√ºgen, nicht durch Einbetten einer Datei, sondern durch Verwendung einer Referenz in einem Dateisystem.  Ein gutes Beispiel sind Verkn√ºpfungsdateien unter Windows.  Wenn es sich jedoch um einen Dateikopf handelt (z. B. einen JPEG-Dateikopf mit Metadaten zu Bildgr√∂√üe, Komprimierungsmethoden, Fotoparametern, GPS-Koordinaten usw.), sollten wir Strukturen zum Entwerfen von Typen zum Parsen des Kopfes verwenden.  Wenn Sie alle Header in Strukturen beschreiben, erhalten Sie die gleiche Position der Felder im Speicher wie in einer Datei.  Mit der einfachen unsicheren <code>*(Header *)readedBuffer</code> Transformation ohne Deserialisierung erhalten Sie vollst√§ndig gef√ºllte Datenstrukturen. </li></ul><br></li></ol><br><ol><li>  Keines der beiden Beispiele zeigt die Vererbung von Verhalten.  Sie zeigen, dass das Verhalten dieser Entit√§ten nicht geerbt werden muss.  Sie sind in sich geschlossen.  Wenn wir jedoch die Effektivit√§t von Code ber√ºcksichtigen, werden wir die Wahl von einer anderen Seite sehen: </li><li>  Wenn wir strukturierte Daten aus nicht verwaltetem Code entnehmen m√ºssen, sollten wir Strukturen ausw√§hlen.  Wir k√∂nnen die Datenstruktur auch an eine unsichere Methode √ºbergeben.  Ein Referenztyp ist daf√ºr √ºberhaupt nicht geeignet. </li><li>  Eine Struktur ist Ihre Wahl, wenn ein Typ die Daten in Methodenaufrufen (als zur√ºckgegebene Werte oder als Methodenparameter) √ºbergibt und nicht von verschiedenen Stellen auf denselben Wert verwiesen werden muss.  Das perfekte Beispiel sind Tupel.  Wenn eine Methode mehrere Werte mit Tupeln zur√ºckgibt, gibt sie ein ValueTuple zur√ºck, das als Struktur deklariert ist.  Die Methode reserviert keinen Speicherplatz auf dem Heap, verwendet jedoch den Stapel des Threads, wobei die Speicherzuweisung nichts kostet. </li><li>  Wenn Sie ein System entwerfen, das gro√üen Datenverkehr mit Instanzen mit geringer Gr√∂√üe und Lebensdauer erzeugt, f√ºhrt die Verwendung von Referenztypen entweder zu einem Objektpool oder, wenn kein Objektpool vorhanden ist, zu einer unkontrollierten Speicherbereinigung auf dem Heap.  Einige Objekte werden zu √§lteren Generationen, was die Belastung des GC erh√∂ht.  Die Verwendung von Werttypen an solchen Stellen (wenn dies m√∂glich ist) f√ºhrt zu einer Leistungssteigerung, da nichts an die SOH weitergegeben wird.  Dies verringert die Belastung des GC und der Algorithmus arbeitet schneller. </li></ol><br><p>  Auf der Grundlage meiner Aussagen finden Sie hier einige Ratschl√§ge zur Verwendung von Strukturen: </p><br><ol><li>  Bei der Auswahl von Sammlungen sollten Sie gro√üe Arrays vermeiden, in denen gro√üe Strukturen gespeichert sind.  Dies schlie√üt Datenstrukturen ein, die auf Arrays basieren.  Dies kann zu einem √úbergang zum Heap f√ºr gro√üe Objekte und seiner Fragmentierung f√ºhren.  Es ist falsch zu glauben, dass unsere Struktur 4 Bytes ben√∂tigt, wenn sie 4 Felder vom Bytetyp hat.  Wir sollten verstehen, dass in 32-Bit-Systemen jedes Strukturfeld an 4-Byte-Grenzen ausgerichtet ist (jedes Adressfeld sollte genau durch 4 geteilt werden) und in 64-Bit-Systemen an 8-Byte-Grenzen.  Die Gr√∂√üe eines Arrays sollte von der Gr√∂√üe einer Struktur und einer Plattform abh√§ngen, auf der ein Programm ausgef√ºhrt wird.  In unserem Beispiel mit 4 Bytes - 85 KB / (von 4 bis 8 Bytes pro Feld * Anzahl der Felder = 4) abz√ºglich der Gr√∂√üe eines Array-Headers entspricht dies je nach Plattform etwa 2 600 Elementen pro Array (dies sollte abgerundet werden )  Das ist nicht sehr viel.  Es schien, als k√∂nnten wir leicht eine magische Konstante von 20.000 Elementen erreichen </li><li>  Manchmal verwenden Sie eine gro√üe Struktur als Datenquelle und platzieren sie als Feld in einer Klasse, w√§hrend eine Kopie repliziert wird, um tausend Instanzen zu erzeugen.  Anschlie√üend erweitern Sie jede Instanz einer Klasse um die Gr√∂√üe einer Struktur.  Dies f√ºhrt zu einer Schwellung der Generation Null und zum √úbergang zur ersten und sogar zur zweiten Generation.  Wenn die Instanzen einer Klasse eine kurze Lebensdauer haben und Sie glauben, dass der GC sie bei der Generation Null sammelt - f√ºr 1 ms, werden Sie entt√§uscht sein.  Sie sind bereits in der ersten und sogar zweiten Generation.  Das macht den Unterschied.  Wenn der GC 1 ms lang die Generation Null sammelt, werden die Generationen eins und zwei sehr langsam gesammelt, was zu einer Abnahme der Effizienz f√ºhrt. </li><li>  Aus dem gleichen Grund sollten Sie vermeiden, gro√üe Strukturen durch eine Reihe von Methodenaufrufen zu leiten.  Wenn sich alle Elemente gegenseitig aufrufen, beanspruchen diese Aufrufe mehr Speicherplatz auf dem Stapel und bringen Ihre Anwendung durch StackOverflowException zum Tode.  Der n√§chste Grund ist die Leistung.  Je mehr Kopien es gibt, desto langsamer funktioniert alles. </li></ol><br><p>  Aus diesem Grund ist die Auswahl eines Datentyps kein offensichtlicher Prozess.  Dies kann h√§ufig auf eine vorzeitige Optimierung hinweisen, die nicht empfohlen wird.  Wenn Sie jedoch wissen, dass Ihre Situation unter die oben genannten Grunds√§tze f√§llt, k√∂nnen Sie leicht einen Werttyp ausw√§hlen. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439486/">https://habr.com/ru/post/de439486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439476/index.html">Cockney Slang: moderne Geschichte und sozialer Status</a></li>
<li><a href="../de439478/index.html">Unterhaltsames C #. F√ºnf Beispiele f√ºr Kaffeepausen</a></li>
<li><a href="../de439480/index.html">Nachgeben oder warum verlangsamt sich Ihr CRM (und CRM)?</a></li>
<li><a href="../de439482/index.html">devleads - (un) finanzielle Motivation</a></li>
<li><a href="../de439484/index.html">Abrufen von Aufz√§hlungsdaten in einer Automapper-Perspektive</a></li>
<li><a href="../de439488/index.html">QA Meetup Videoaufzeichnung</a></li>
<li><a href="../de439490/index.html">.NET-Referenztypen im Vergleich zu Werttypen. Teil 2</a></li>
<li><a href="../de439492/index.html">10 Tipps f√ºr einen guten technischen Vorsprung</a></li>
<li><a href="../de439496/index.html">So erfolgt die Abrechnung dort: Wenn Kunde und Entwickler unterschiedliche Sprachen sprechen</a></li>
<li><a href="../de439498/index.html">Auf welcher Hardware soll ein riesiger Informationsschacht analysiert werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>