<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏻 🕉️ 🤷🏾 Prinsip terbuka-tertutup ◽️ 👨🏼‍🚒 🌩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Berikut ini adalah terjemahan dari artikel oleh Robert Martin dari Prinsip Terbuka-Tertutup , yang ia terbitkan pada Januari 1996. Artikel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip terbuka-tertutup</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Halo, Habr!  Berikut ini adalah terjemahan dari artikel oleh Robert Martin dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20060822033314/">Prinsip Terbuka-Tertutup</a> , yang ia terbitkan pada Januari 1996.  Artikel ini, secara sederhana, bukan yang terbaru.  Tetapi di RuNet, artikel Paman Bob tentang SOLID hanya diceritakan kembali dalam bentuk terpotong, jadi saya pikir terjemahan penuh tidak akan berlebihan. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Saya memutuskan untuk memulai dengan huruf O, karena prinsip keterbukaan-penutupan, sebenarnya, adalah sentral.  Di antara hal-hal lain, ada banyak seluk-beluk penting yang perlu diperhatikan: </p><br><ul><li>  Tidak ada program yang dapat "ditutup" 100%. </li><li>  Pemrograman berorientasi objek (OOP) beroperasi tidak dengan objek fisik dari dunia nyata, tetapi dengan konsep - misalnya, konsep "pemesanan". <a name="habracut"></a></li></ul><br><p>  Ini adalah artikel pertama di kolom <em>Catatan Teknisi</em> untuk <em>The C ++ Report</em> .  Artikel-artikel yang diterbitkan dalam kolom ini akan fokus pada penggunaan C ++ dan OOP dan menyentuh kesulitan dalam pengembangan perangkat lunak.  Saya akan mencoba membuat bahan-bahan yang pragmatis dan berguna untuk melatih para insinyur.  Untuk dokumentasi desain berorientasi objek dalam artikel ini saya akan menggunakan notasi Buch. </p><br><p>  Ada banyak heuristik yang terkait dengan pemrograman berorientasi objek.  Misalnya, "semua variabel anggota harus pribadi", atau "variabel global harus dihindari", atau "penentuan jenis saat runtime berbahaya".  Apa alasan heuristik seperti itu?  Mengapa itu benar?  Apakah itu <em>selalu</em> benar?  Kolom ini mengeksplorasi prinsip desain yang mendasari heuristik ini - prinsip keterbukaan-penutupan. <br>  Ivar Jacobson berkata: “Semua sistem berubah selama siklus hidup.  Ini harus diingat ketika merancang sistem yang memiliki lebih dari satu versi yang diharapkan. "  Bagaimana kita bisa merancang suatu sistem sehingga stabil dalam menghadapi perubahan dan memiliki lebih dari satu versi yang diharapkan?  Bertrand Meyer memberi tahu kami tentang hal ini pada tahun 1988, ketika prinsip keterbukaan-kedekatan yang terkenal sekarang dirumuskan: </p><br><p>  <strong>Entitas program (kelas, modul, fungsi, dll.) Harus terbuka untuk ekspansi dan ditutup untuk perubahan.</strong> </p><br><p>  Jika satu perubahan dalam program ini melibatkan perubahan dalam modul dependen, maka program menampilkan tanda-tanda yang tidak diinginkan dari desain "buruk". </p><br><p>  Program menjadi rapuh, tidak fleksibel, tidak dapat diprediksi dan tidak digunakan.  Prinsip keterbukaan-kedekatan menyelesaikan masalah-masalah ini dengan cara yang sangat mudah.  Dia mengatakan bahwa perlu untuk merancang modul yang tidak pernah <em>berubah</em> .  Ketika persyaratan berubah, Anda perlu memperluas perilaku modul tersebut dengan menambahkan kode baru, daripada mengubah kode lama yang sudah berfungsi. </p><br><h1>  Deskripsi </h1><br><p>  Modul yang memenuhi prinsip keterbukaan-kedekatan memiliki dua karakteristik utama: </p><br><ol><li>  <strong>Terbuka untuk ekspansi.</strong>  Ini berarti bahwa perilaku modul dapat diperluas.  Artinya, kita dapat menambahkan perilaku baru ke modul sesuai dengan persyaratan perubahan untuk aplikasi atau untuk memenuhi kebutuhan aplikasi baru. </li><li> <strong>Ditutup untuk perubahan.</strong>  Kode sumber modul semacam itu tidak dapat disentuh.  Tidak ada yang punya hak untuk mengubahnya. </li></ol><br><p>  Tampaknya kedua tanda ini tidak cocok satu sama lain.  Cara standar untuk memperluas perilaku modul adalah dengan mengubahnya.  Modul yang tidak dapat diubah biasanya dianggap sebagai modul dengan perilaku tetap.  Bagaimana dua kondisi yang berlawanan ini dipenuhi? </p><br><h1>  Kunci dari solusinya adalah abstraksi. </h1><br><p>  Dalam C ++, menggunakan prinsip-prinsip desain berorientasi objek, dimungkinkan untuk membuat abstraksi tetap yang dapat mewakili serangkaian perilaku yang tidak terbatas. </p><br><p>  Abstraksi adalah kelas dasar abstrak, dan serangkaian perilaku yang tidak terbatas diwakili oleh semua kelas penerus yang mungkin.  Modul dapat memanipulasi abstraksi.  Modul semacam itu ditutup untuk perubahan, karena itu tergantung pada abstraksi tetap.  Juga, perilaku modul dapat diperluas dengan menciptakan keturunan abstraksi baru. </p><br><p> Diagram di bawah ini menunjukkan opsi desain sederhana yang tidak memenuhi prinsip keterbukaan-kedekatan.  Kedua kelas, <code>Client</code> dan <code>Server</code> , tidak abstrak.  Tidak ada jaminan bahwa fungsi yang menjadi anggota kelas <code>Server</code> adalah virtual.  Kelas <code>Client</code> menggunakan kelas <code>Server</code> .  Jika kami ingin objek kelas <code>Client</code> menggunakan objek server yang berbeda, kami harus mengubah kelas <code>Client</code> untuk merujuk ke kelas server baru. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="gambar"><br>  <em>Klien tertutup</em> </p><br><p>  Dan diagram berikut menunjukkan opsi desain yang sesuai, yang memenuhi prinsip keterbukaan-kedekatan.  Dalam hal ini, kelas <code>AbstractServer</code> adalah kelas abstrak, semua fungsi anggota yang virtual.  Kelas <code>Client</code> menggunakan abstraksi.  Namun, objek dari kelas <code>Client</code> akan menggunakan objek dari kelas penerus <code>Server</code> .  Jika kami ingin objek kelas <code>Client</code> menggunakan kelas server yang berbeda, kami akan memperkenalkan turunan baru dari kelas <code>AbstractServer</code> .  Kelas <code>Client</code> akan tetap tidak berubah. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="gambar"><br>  <em>Buka klien</em> </p><br><h1>  <code>Shape</code> Abstrak </h1><br><p>  Pertimbangkan aplikasi yang harus menggambar lingkaran dan bujur sangkar dalam GUI standar.  Lingkaran dan kotak harus digambar dalam urutan tertentu.  Dalam urutan yang sesuai, daftar lingkaran dan kotak akan dikompilasi, program harus melalui daftar ini dalam urutan dan menggambar setiap lingkaran atau kotak. </p><br><p>  Dalam C, menggunakan teknik pemrograman prosedural yang tidak memenuhi prinsip buka-tutup, kita bisa menyelesaikan masalah ini seperti yang ditunjukkan pada Listing 1. Di sini kita melihat banyak struktur data dengan elemen pertama yang sama.  Elemen ini adalah kode tipe yang mengidentifikasi struktur data sebagai lingkaran atau kuadrat.  Fungsi <code>DrawAllShapes</code> melewati array pointer ke struktur data ini, mengenali kode jenis dan kemudian memanggil fungsi yang sesuai ( <code>DrawCircle</code> atau <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  Fungsi <code>DrawAllShapes</code> tidak memenuhi prinsip keterbukaan-penutupan, karena tidak dapat "ditutup" dari jenis bentuk baru.  Jika saya ingin memperluas fungsi ini dengan kemampuan untuk menggambar bentuk dari daftar yang menyertakan segitiga, maka saya perlu mengubah fungsinya.  Sebenarnya, saya harus mengubah fungsi untuk setiap jenis bentuk baru yang perlu saya gambar. </p><br><p>  Tentu saja, program ini hanyalah sebuah contoh.  Dalam kehidupan nyata, operator <code>switch</code> dari fungsi <code>DrawAllShapes</code> akan diulang berkali-kali di berbagai fungsi di seluruh aplikasi, dan masing-masing akan melakukan sesuatu yang berbeda.  Menambahkan bentuk baru ke aplikasi seperti itu berarti menemukan semua tempat di mana <code>switch</code> (atau <code>if/else</code> rantai <code>if/else</code> ) digunakan, dan menambahkan bentuk baru ke masing-masing.  Selain itu, sangat tidak mungkin bahwa semua <code>switch</code> dan <code>if/else</code> rantai <code>if/else</code> akan terstruktur sebaik di <code>DrawAllShapes</code> .  Adalah jauh lebih mungkin bahwa predikat <code>if</code> akan digabungkan dengan operator logis, atau blok <code>case</code> dari <code>switch</code> akan digabungkan sedemikian rupa untuk “menyederhanakan” tempat tertentu dalam kode.  Karena itu, masalah menemukan dan memahami semua tempat di mana Anda perlu menambahkan sosok baru bisa menjadi hal yang tidak sepele. </p><br><p>  Dalam Listing 2, saya akan menunjukkan kode yang menunjukkan solusi persegi / lingkaran yang memenuhi prinsip keterbukaan-penutupan.  Kelas <code>Shape</code> abstrak diperkenalkan.  Kelas abstrak ini berisi satu fungsi <code>Draw</code> virtual murni.  Kelas <code>Circle</code> dan <code>Square</code> adalah turunan dari kelas <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Perhatikan bahwa jika kita ingin memperluas perilaku fungsi <code>DrawAllShapes</code> di Listing 2 untuk menggambar bentuk baru, yang perlu kita lakukan adalah menambahkan turunan baru dari kelas <code>Shape</code> .  Tidak perlu mengubah fungsi <code>DrawAllShapes</code> .  Oleh karena itu, <code>DrawAllShapes</code> memenuhi prinsip keterbukaan-kedekatan.  Perilakunya dapat diperluas tanpa mengubah fungsi itu sendiri. </p><br><p>  Di dunia nyata, kelas <code>Shape</code> akan berisi banyak metode lain.  Namun, menambahkan bentuk baru ke aplikasi masih sangat sederhana, karena yang perlu Anda lakukan adalah memasukkan pewaris baru dan mengimplementasikan fungsi-fungsi ini.  Tidak perlu menjelajahi seluruh aplikasi untuk mencari tempat yang membutuhkan perubahan. </p><br><p>  Oleh karena itu, program yang memenuhi prinsip keterbukaan-kedekatan diubah dengan menambahkan kode baru, dan bukan dengan mengubah kode yang sudah ada, mereka tidak mengubah perubahan karakteristik program yang tidak sesuai dengan prinsip ini. </p><br><h1>  Strategi Entri Tertutup </h1><br><p>  Jelas, tidak ada program yang dapat ditutup 100%.  Misalnya, apa yang terjadi pada fungsi <code>DrawAllShapes</code> di Listing 2 jika kita memutuskan bahwa lingkaran dan kotak harus digambar terlebih dahulu?  Fungsi <code>DrawAllShapes</code> tidak tertutup dari perubahan semacam ini.  Secara umum, tidak masalah seberapa "tertutup" modul ini, selalu ada beberapa jenis perubahan yang tidak ditutup. </p><br><p>  Karena penutupan tidak dapat lengkap, itu harus diperkenalkan secara strategis.  Artinya, perancang harus memilih jenis perubahan dari mana program akan ditutup.  Ini membutuhkan beberapa pengalaman.  Pengembang berpengalaman mengetahui pengguna dan industri dengan cukup baik untuk menghitung kemungkinan berbagai perubahan.  Dia kemudian memastikan bahwa prinsip keterbukaan-kedekatan dihormati untuk perubahan yang paling mungkin. </p><br><h2>  Gunakan abstraksi untuk mencapai kedekatan tambahan </h2><br><p>  Bagaimana kita bisa menutup fungsi <code>DrawAllShapes</code> dari perubahan dalam urutan gambar?  Ingat bahwa penutupan didasarkan pada abstraksi.  Oleh karena itu, untuk menutup <code>DrawAllShapes</code> dari pemesanan, kita perlu semacam "pemesanan abstraksi".  Kasus khusus pemesanan, yang disajikan di atas, adalah menggambar tokoh dari satu jenis di depan tokoh dari jenis lain. </p><br><p>  Kebijakan pemesanan menyiratkan bahwa dengan dua objek, Anda dapat menentukan mana yang harus ditarik terlebih dahulu.  Oleh karena itu, kita dapat mendefinisikan metode untuk kelas <code>Shape</code> disebut <code>Precedes</code> , yang mengambil objek <code>Shape</code> lain sebagai argumen dan mengembalikan nilai Boolean <code>true</code> sebagai hasilnya jika objek kelas <code>Shape</code> yang menerima pesan ini perlu disortir sebelum objek kelas <code>Shape</code> yang sebelumnya disahkan sebagai argumen. </p><br><p>  Dalam C ++, fungsi ini dapat direpresentasikan sebagai kelebihan dari operator "&lt;".  Listing 3 memperlihatkan kelas <code>Shape</code> dengan metode penyortiran. </p><br><p>  Sekarang kita memiliki cara untuk menentukan urutan objek dari kelas <code>Shape</code> , kita dapat mengurutkannya dan kemudian menggambarnya.  Kode 4 menunjukkan kode C ++ yang sesuai.  Menggunakan kelas <code>Set</code> , <code>OrderedSet</code> dan <code>Iterator</code> dari kategori <code>Components</code> dikembangkan dalam buku saya (Merancang Aplikasi Berorientasi Objek C ++ menggunakan Metode Booch, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Jadi, kami telah menerapkan pemesanan objek dari kelas <code>Shape</code> dan menggambarnya dalam urutan yang sesuai.  Namun kami masih belum memiliki implementasi abstraksi pemesanan.  Jelas, setiap objek <code>Shape</code> harus menimpa metode <code>Precedes</code> untuk menentukan urutan.  Bagaimana ini bisa berhasil?  Kode apa yang perlu ditulis dalam <code>Circle::Precedes</code> sehingga lingkaran ditarik ke kotak?  Perhatikan daftar 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Jelas bahwa fungsi ini tidak memenuhi prinsip keterbukaan-kedekatan.  Tidak ada cara untuk menutupnya dari keturunan baru dari kelas <code>Shape</code> .  Setiap kali keturunan baru dari kelas <code>Shape</code> muncul, fungsi ini perlu diubah. </p><br><h2>  Menggunakan Pendekatan Data Driven untuk Mencapai Penutupan </h2><br><p>  Kedekatan pewaris dari kelas <code>Shape</code> dapat dicapai dengan menggunakan pendekatan tabular yang tidak memicu perubahan di setiap kelas yang diwariskan.  Contoh dari pendekatan ini ditunjukkan pada Listing 6. </p><br><p>  Dengan menggunakan pendekatan ini, kami berhasil menutup fungsi <code>DrawAllShapes</code> dari perubahan yang terkait dengan pemesanan, dan setiap keturunan dari kelas <code>Shape</code> - dari memperkenalkan turunan baru atau dari perubahan kebijakan pemesanan untuk objek-objek dari kelas <code>Shape</code> tergantung pada jenisnya (misalnya, sehingga objek dari kelas <code>Squares</code> harus ditarik terlebih dahulu). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  Satu-satunya elemen yang tidak tertutup dari mengubah urutan bentuk gambar adalah tabel.  Tabel dapat ditempatkan dalam modul terpisah, terpisah dari semua modul lainnya, dan karenanya perubahannya tidak akan memengaruhi modul lainnya. </p><br><h2>  Penutupan lebih lanjut </h2><br><p>  Ini bukan akhir dari cerita.  Kami menutup hierarki kelas <code>Shape</code> dan fungsi <code>DrawAllShapes</code> dari mengubah kebijakan pemesanan berdasarkan jenis bentuk.  Namun, turunan dari kelas <code>Shape</code> tidak tertutup dari kebijakan pemesanan yang tidak terkait dengan tipe <code>Shape</code> .  Tampaknya kita perlu mengatur gambar bentuk sesuai dengan struktur tingkat yang lebih tinggi.  Sebuah studi lengkap tentang masalah-masalah semacam itu berada di luar cakupan artikel ini;  namun, pembaca yang tertarik mungkin berpikir bagaimana menyelesaikan masalah ini menggunakan kelas <code>OrderedObject</code> abstrak yang terkandung dalam kelas <code>OrderedShape</code> , yang mewarisi dari kelas <code>Shape</code> dan <code>OrderedObject</code> . </p><br><h1>  Heuristik dan Konvensi </h1><br><p>  Seperti yang telah disebutkan di awal artikel, prinsip keterbukaan-kedekatan adalah motivasi utama di balik banyak heuristik dan konvensi yang telah muncul selama bertahun-tahun dalam pengembangan paradigma OOP.  Berikut ini adalah yang paling penting. </p><br><h2>  Jadikan semua variabel anggota bersifat pribadi </h2><br><p>  Ini adalah salah satu konvensi PLO yang paling bertahan lama.  Variabel anggota hanya boleh diketahui dengan metode kelas di mana mereka didefinisikan.  Anggota variabel tidak boleh diketahui ke kelas lain, termasuk kelas turunan.  Oleh karena itu, mereka harus dinyatakan dengan pengubah akses <code>private</code> , bukan <code>public</code> atau <code>protected</code> . <br>  Dalam terang prinsip keterbukaan-kedekatan, alasan konvensi semacam itu dapat dipahami.  Ketika variabel anggota kelas berubah, setiap fungsi yang bergantung padanya harus berubah.  Artinya, fungsinya tidak tertutup dari perubahan variabel-variabel ini. </p><br><p>  Dalam OOP, kami berharap bahwa metode kelas tidak tertutup terhadap perubahan variabel yang menjadi anggota kelas ini.  Namun, kami berharap bahwa kelas lain, termasuk subclass, ditutup dari perubahan variabel-variabel ini.  Ini disebut enkapsulasi. </p><br><p>  Tetapi bagaimana jika Anda memiliki variabel yang Anda yakin tidak akan pernah berubah?  Apakah masuk akal untuk menjadikannya <code>private</code> ?  Misalnya, Listing 7 menunjukkan kelas <code>Device</code> yang berisi <code>bool status</code> anggota variabel.  Ini menyimpan status operasi terakhir.  Jika operasi berhasil, maka nilai variabel <code>status</code> akan <code>true</code> , jika tidak <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Kita tahu bahwa jenis atau makna variabel ini tidak akan pernah berubah.  Jadi mengapa tidak membuatnya <code>public</code> dan memberikan klien akses langsung ke sana?  Jika variabel benar-benar tidak pernah berubah, jika semua klien mengikuti aturan dan hanya membaca dari variabel ini, maka tidak ada yang salah dengan fakta bahwa variabel tersebut bersifat publik.  Namun, pertimbangkan apa yang akan terjadi jika salah satu klien mengambil kesempatan untuk menulis ke variabel ini dan mengubah nilainya. </p><br><p>  Tiba-tiba, klien ini dapat memengaruhi operasi klien lain apa pun dari kelas <code>Device</code> .  Ini berarti bahwa tidak mungkin untuk menutup klien dari kelas <code>Device</code> dari perubahan ke modul yang salah ini.  Ini terlalu banyak risiko. </p><br><p>  Di sisi lain, anggaplah kita memiliki kelas <code>Time</code> , ditunjukkan pada Listing 8. Apa bahaya dari publisitas variabel yang menjadi anggota kelas ini?  Sangat tidak mungkin mereka akan berubah.  Selain itu, tidak masalah jika modul klien mengubah nilai-nilai variabel ini atau tidak, karena perubahan dalam variabel-variabel ini diasumsikan.  Juga sangat tidak mungkin bahwa kelas yang diwarisi dapat bergantung pada nilai variabel anggota tertentu.  Jadi, apakah ada masalah? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  Satu-satunya keluhan yang bisa saya buat pada kode di Listing 8 adalah bahwa perubahan waktu tidak terjadi secara atom.  Artinya, klien dapat mengubah nilai variabel <code>minutes</code> tanpa mengubah nilai variabel <code>hours</code> .  Ini dapat menyebabkan objek dari kelas <code>Time</code> mengandung data yang tidak konsisten.  Saya lebih suka memperkenalkan fungsi tunggal untuk mengatur waktu, yang akan membutuhkan tiga argumen, yang akan menjadikan pengaturan waktu sebagai operasi atom.  Tapi ini argumen yang lemah. </p><br><p>  Sangat mudah untuk menemukan kondisi lain di mana publisitas variabel-variabel ini dapat menyebabkan masalah.  Namun, pada akhirnya, tidak ada alasan yang meyakinkan untuk menjadikannya <code>private</code> .  Saya masih berpikir bahwa mempublikasikan variabel semacam itu adalah gaya yang buruk, tapi mungkin itu bukan desain yang buruk.  Saya percaya bahwa ini adalah gaya yang buruk, karena hampir tidak ada biaya untuk memasuki fungsi yang sesuai untuk mengakses anggota ini, dan sudah pasti layak untuk melindungi diri Anda dari risiko kecil yang terkait dengan kemungkinan terjadinya masalah dengan penutupan. </p><br><p>  Oleh karena itu, dalam kasus yang jarang terjadi, ketika prinsip keterbukaan-kedekatan tidak dilanggar, larangan variabel <code>public</code> - dan <code>protected</code> lebih tergantung pada gaya dan bukan pada konten. </p><br><h2>  Tidak ada variabel global ... sama sekali! </h2><br><p>  Argumen terhadap variabel global sama dengan argumen terhadap variabel anggota publik.  Tidak ada modul yang bergantung pada variabel global yang dapat ditutup dari modul yang dapat menulisnya.  Setiap modul yang menggunakan variabel ini dengan cara yang tidak dimaksudkan oleh modul lain akan merusak modul ini.  Terlalu berisiko untuk memiliki banyak modul, tergantung pada keanehan dari satu modul jahat. <br>  Di sisi lain, dalam kasus di mana variabel global memiliki sejumlah kecil modul bergantung padanya atau tidak dapat digunakan dengan cara yang salah, mereka tidak membahayakan.  Perancang harus mengevaluasi seberapa banyak privasi dikorbankan dan menentukan apakah kenyamanan yang disediakan oleh variabel global sepadan. </p><br><p>  Di sini lagi, masalah gaya ikut bermain.  Alternatif untuk menggunakan variabel global biasanya tidak mahal.  Dalam kasus seperti itu, penggunaan teknik yang memperkenalkan, meskipun kecil, tetapi risiko untuk penutupan, bukan teknik yang sepenuhnya menghilangkan risiko seperti itu, adalah tanda gaya buruk.  Namun, terkadang menggunakan variabel global sangat nyaman.  Contoh tipikal adalah variabel global cout dan cin.  Dalam kasus seperti itu, jika prinsip keterbukaan-kedekatan tidak dilanggar, Anda dapat mengorbankan gaya demi kenyamanan. </p><br><h2>  RTTI berbahaya </h2><br><p>  Larangan umum lainnya adalah penggunaan <code>dynamic_cast</code> .  Sangat sering, <code>dynamic_cast</code> atau bentuk lain dari penentuan jenis runtime (RTTI) dituduh sebagai teknik yang sangat berbahaya dan karenanya harus dihindari.  Pada saat yang sama, mereka sering memberikan contoh dari Listing 9, yang jelas-jelas melanggar prinsip keterbukaan-kedekatan.  Namun, Listing 10 menunjukkan contoh program serupa yang menggunakan <code>dynamic_cast</code> tanpa melanggar prinsip buka-tutup. </p><br><p>  Perbedaan di antara mereka adalah bahwa dalam kasus pertama, ditunjukkan pada Listing 9, kode perlu diubah setiap kali keturunan baru dari kelas <code>Shape</code> muncul (belum lagi bahwa ini adalah solusi yang benar-benar konyol).  Namun, dalam Listing 10, tidak diperlukan perubahan dalam kasus ini.  Oleh karena itu, kode dalam Listing 10 tidak melanggar prinsip buka-tutup. <br>  Dalam hal ini, aturan praktisnya adalah bahwa RTTI dapat digunakan jika prinsip keterbukaan-penutupan tidak dilanggar. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Kesimpulan </h1><br><p>  Saya bisa berbicara lama tentang prinsip keterbukaan-kedekatan.  Dalam banyak hal, prinsip ini paling penting untuk pemrograman berorientasi objek.  Kepatuhan dengan prinsip khusus ini memberikan keuntungan utama dari teknologi berorientasi objek, yaitu penggunaan kembali dan dukungan. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472186/">https://habr.com/ru/post/id472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472174/index.html">Kepribadian dan suara: Paul Voight - "Sennheiser 30s", ayah dari broadband, crossover mekanis dan jalur transmisi</a></li>
<li><a href="../id472176/index.html">Museum Pushkin Virtual</a></li>
<li><a href="../id472178/index.html">Holivar. Sejarah Runet. Bagian 7. YouTube: pelawak, cicit, dan Lembah Silikon</a></li>
<li><a href="../id472182/index.html">Mengumumkan .NET Core 3.1 Pratinjau 1</a></li>
<li><a href="../id472184/index.html">Remote SSH: Tip dan Trik</a></li>
<li><a href="../id472188/index.html">Yang Perlu Anda Ketahui tentang Verifikasi Pemeriksaan Toko Aplikasi (tanda terima App Store)</a></li>
<li><a href="../id472190/index.html">Jalankan skrip PHP melalui php-fpm tanpa server web. Atau klien FastCGI Anda (di bawah tenda)</a></li>
<li><a href="../id472196/index.html">"Gula" buatan rumah untuk proyek Android atau "Bagaimana tidak melakukannya"</a></li>
<li><a href="../id472198/index.html">Lokalisasi pesan push dalam aplikasi seluler</a></li>
<li><a href="../id472200/index.html">Modernisasi kelas ilmu komputer di sekolah Rusia dengan raspberry: murah dan ceria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>