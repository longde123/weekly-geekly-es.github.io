<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üë©üèª‚ÄçüöÄ ü§üüèæ ‚Äú20.000 IOPS por n√≥ t√™m bom desempenho com lat√™ncia de 5 ms.‚Äù Para OLTP - n√£o ü§≤üèª üïû ‚õé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O motivo para escrever este artigo foi uma revis√£o muito √∫til de Como testamos o VMware vSAN ... CROC. A revis√£o √© digna, mas h√° uma frase com a qual ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>‚Äú20.000 IOPS por n√≥ t√™m bom desempenho com lat√™ncia de 5 ms.‚Äù Para OLTP - n√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414269/"><p><img src="https://habrastorage.org/webt/fq/yy/2k/fqyy2kbw4iqx5ikqy7v-o60jfce.jpeg" alt="KDPV"></p><br><p>  O motivo para escrever este artigo foi uma revis√£o muito √∫til de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como testamos o VMware vSAN ...</a> CROC.  A revis√£o √© digna, mas h√° uma frase com a qual estou lutando h√° mais de uma d√©cada.  Administradores de armazenamento, virtualizadores e integradores repetem v√°rias vezes: "Atrasos de 5 ms s√£o um excelente indicador".  Mesmo o valor de 5 ms por dez anos n√£o muda.  Ouvi isso ao vivo de administradores altamente respeitados, pelo menos uma d√∫zia de vezes.  De menos respeitados - dezenas, e quantas vezes eu li na Internet ... N√£o, n√£o, n√£o.  Para cargas OLTP de 5 ms, principalmente porque geralmente s√£o medidas, s√£o falhas √©picas.  Eu tive que explicar as raz√µes para isso muitas vezes, desta vez decidi reunir meus pensamentos de forma reutiliz√°vel. </p><br><p>  Devo dizer imediatamente que n√£o existem tais erros no artigo mencionado acima, mas a frase funcionou como um gatilho. </p><a name="habracut"></a><br><h2 id="tipichnoe-nachalo">  In√≠cio t√≠pico </h2><br><p>  Tudo o que √© descrito neste artigo √© verdadeiro para DBMSs comuns usados ‚Äã‚Äãpara OLTP comercial t√≠pico.  Acima de tudo, tenho experi√™ncia com o MS SQL Server, mas, pelo menos para o PostgeSQL, Oracle e Sybase, muitos pontos e conclus√µes tamb√©m permanecer√£o verdadeiros. </p><br><p>  O DBMS de desempenho geralmente n√£o est√° satisfeito com todos.  Se houver um DBMS em um sistema grande - e de repente ele quase sempre estiver l√° -, esse DBMS ser√° um gargalo.  Bem, ou ele imediatamente se tornar√° um gargalo se voc√™ come√ßar a otimizar todo o resto.  E assim, o cliente chega e diz com uma voz humana: "Socorro! Economize! Eles pagaram $ NNNNNNNN pelo servidor e armazenamento, mas a velocidade n√£o aumenta! Ah, e o administrador configurou e o fornecedor consultou, mas ainda n√£o se move".  Se os desenvolvedores do sistema se encaixam na defini√ß√£o de Lavrov (podemos fazer sem uma cota√ß√£o exata) e os especialistas em opera√ß√£o e manuten√ß√£o "enfrentam incidentes ao reiniciar o servidor", o problema geralmente √© simples e despretensioso: n√£o h√° √≠ndices, consultas distorcidas, erros fatais de configura√ß√£o (sobre os quais a documenta√ß√£o est√° em negrito ele diz <strong>"voc√™ n√£o pode fazer isso !!!"</strong> ), bloqueios excessivos, impasses e outras bobagens simples e claras.  Existem muitos desses casos, a maioria, mas n√£o todos.  Se o sistema, em complexidade ou carga, ultrapassar algum limite invis√≠vel, ele morrer√° desses problemas ou passar√° para o pr√≥ximo n√≠vel. </p><br><div class="spoiler">  <b class="spoiler_title">Dicas de diagn√≥stico do SQL Server</b> <div class="spoiler_text"><p> IMHO, a melhor ferramenta agora √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SQL Server First Responder Kit</a> , promovido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brent Ozar</a> .  Esta ferramenta est√° se desenvolvendo muito ativamente.  Ainda h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto</a> digno de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Glenn Berry</a> , ele tamb√©m n√£o abandonou seu projeto.  Ambos os conjuntos s√£o bonitos √† sua maneira, ler coment√°rios e consultas pela primeira vez abre muitas coisas novas.  Eu mesmo sempre come√ßo pesquisando com <code>sys.dm_os_waitsats</code> , uma r√°pida olhada no log de erros e descobrindo se h√° pelo menos algum sistema de backup em funcionamento. </p></div></div><br><p>  Nesse n√≠vel, o servidor n√£o est√° mais na tabela do diretor, os discos n√£o est√£o mais dentro do servidor, mas no sistema de armazenamento, os desenvolvedores conhecem os √≠ndices e os administradores j√° conhecem o PowerShell, e os gerentes de TI come√ßam a dizer palavras inteligentes como SLA e RPO / RTO.  Uma situa√ß√£o interessante surge neste n√≠vel: </p><br><ul><li>  DBMS √© um gargalo. </li><li>  O servidor parece ser suficiente em todos os aspectos. </li><li>  O DBMS pode ser aprimorado ainda mais programaticamente, mas √© dif√≠cil (alternar para licen√ßas mais caras ou alternar para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"zona vermelha da curva Shipilev"</a> para otimiza√ß√£o) </li><li>  O sistema de disco √© comprado caro e, ao que parece, est√° de alguma forma configurado. </li></ul><br><p>  Mas n√£o.  O crocodilo n√£o √© capturado, o coco n√£o cresce e o desempenho do sistema √© igual ou inferior ao do servidor antigo.  Olho em <code>sys.dm_os_waitsats</code> e vejo <code>WRITELOG</code> , <code>PAGEIOLATCH_SH</code> e <code>PAGEIOLATCH_EX</code> na parte superior, o tempo m√©dio de espera √© de mais de 5 ms.  Bem, t√≠pico, cho: "Ei, administradores e DBA, aqui voc√™ tem um sistema de disco - gargalo" e aqui come√ßa uma m√∫sica antiga com cerca de 5 ms: </p><br><ul><li>  Temos 5 ms para SLA </li><li>  Sim, temos um regimento de 20.000 IOPS </li><li>  O fornecedor nos disse que todos os arquivos de banco de dados podem estar em uma parti√ß√£o </li><li>  Temos virtualiza√ß√£o e hiperconverg√™ncia e n√£o podemos alocar discos separados no banco de dados </li><li>  De acordo com nossos dados, a utiliza√ß√£o do servidor 5% </li><li>  Tudo √© configurado de acordo com as recomenda√ß√µes </li><li>  Seus bancos de dados n√£o precisam de muito desempenho, n√£o exigem mais de 300 IOPS (e temos uma prateleira para 20.000 IOPS) </li></ul><br><p>  A prop√≥sito, tudo isso acima, n√£o apenas sobre "seus" servidores, mas tamb√©m sobre servi√ßos em nuvem e virtualiza√ß√£o.  H√° muitas especificidades pr√≥prias, mas o quadro cl√≠nico t√≠pico √© o mesmo: banco de dados moderadamente otimizado, equipe de desenvolvimento e manuten√ß√£o inteligente, h√° uma reserva para o processador e a mem√≥ria, a "exaust√£o" de novos investimentos √© quase zero. </p><br><p>  Ent√£o aqui.  Toda essa m√∫sica sobre "5 ms" √© um absurdo e um absurdo.  Se voc√™ mesmo diz isso, leia este artigo.  E se eles lhe disserem, prepare os argumentos.  Antes, quando ouvi essas palavras, fiquei com raiva, mas n√£o estou mais com raiva.  Eu, como aquele pote com uma pet√∫nia do Guia do Mochileiro das Gal√°xias, tenho apenas um pensamento: "Bem, de novo ...". </p><br><h2 id="kto-vinovat">  Quem √© o culpado? </h2><br><p>  Por que o banco de dados √© t√£o lento?  Bem, parece que um servidor t√≠pico com 20-64 n√∫cleos a uma frequ√™ncia de 2-3 GHz √© capaz de executar 50-150 bilh√µes de opera√ß√µes simples, e os testes m√°ximos (sint√©ticos) do banco de dados mostram nessas m√°quinas apenas 10.000-50000 transa√ß√µes por segundo.  Ei!  Bem, isso √© de um milh√£o a uma d√∫zia de milh√µes de transa√ß√µes poss√≠veis por transa√ß√£o.  N√£o √© s√≥ muita coisa, √© muita coisa para sentir. <br>  Essa sobrecarga custa requisitos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ACID</a> para transa√ß√µes. </p><br><ul><li>  <strong>Uma</strong> tomicidade - a transa√ß√£o inteira est√° conclu√≠da ou o todo n√£o est√° conclu√≠do. </li><li>  <strong>C</strong> onist√¢ncia - na entrada e sa√≠da de uma transa√ß√£o, o sistema est√° em um estado consistente </li><li>  <strong>I</strong> solation - as transa√ß√µes n√£o v√™em os estados intermedi√°rios um do outro </li><li>  Durabilidade - se a transa√ß√£o foi conclu√≠da com √™xito (confirmada), ent√£o, independentemente das circunst√¢ncias, as altera√ß√µes feitas devem permanecer no sistema. </li></ul><br><p>  A prop√≥sito, letra por letra, esses requisitos n√£o s√£o cumpridos quase em qualquer lugar e nunca, mas simplesmente nunca em sistemas distribu√≠dos (o teorema da PAC interfere).  Para nossa situa√ß√£o, √© mais prov√°vel que o requisito "D" seja mais caro que outros, esse requisito √© fornecido pelo mecanismo principal de todos os DBMSs OLTP comuns: WAL, log write-ahead (PostgeSQL), tamb√©m √© um log de transa√ß√µes (SQL Server), tamb√©m conhecido como REDO log (Oracle).  Aqui est√° - uma pedra no pesco√ßo da produtividade e √© a base das transa√ß√µes de Durabilidade. </p><br><h3 id="chto-takoe-wal">  O que √© o WAL? </h3><br><p>  Vamos esquecer por um momento os SSDs modernos, os sistemas de armazenamento legais.  Suponha que tenhamos um servidor, ele tenha um ou mais discos. <br>  Qualquer transa√ß√£o, mesmo a inser√ß√£o de um registro, √© pelo menos potencialmente, mas de fato quase sempre e realisticamente uma a√ß√£o n√£o at√¥mica.  Quase sempre precisamos alterar n√£o apenas a p√°gina em que o registro est√° localizado, mas tamb√©m as p√°ginas de √≠ndice, possivelmente as p√°ginas de servi√ßo.  Al√©m disso, na mesma transa√ß√£o, a mesma p√°gina pode mudar v√°rias vezes.  Al√©m disso, outras transa√ß√µes podem ser realizadas em paralelo conosco.  Al√©m disso - as transa√ß√µes vizinhas no tempo constantemente "puxam" as mesmas p√°ginas.  Se esperarmos que cada p√°gina seja gravada no disco antes de continuar, que √© essencialmente o que o Durability exige, teremos que escrever muitas vezes mais e esperar que cada grava√ß√£o seja conclu√≠da em m√≠dia n√£o vol√°til.  Sem caches, sem reorganiza√ß√£o das opera√ß√µes na fila, caso contr√°rio, n√£o haver√° integridade!  Al√©m disso, precisamos observar de alguma forma quais dados j√° est√£o em transa√ß√µes fixas e quais ainda n√£o est√£o (e quais estavam antes).  Para entender - um disco r√≠gido √∫nico (HDD) t√≠pico nesse modo fornecer√° 50-100 IOPS e isso √© uma constante h√° 20 anos.  Uma transa√ß√£o pequena exigir√° 5-10 opera√ß√µes de grava√ß√£o.  Ah, sim, para saber o que gravar, voc√™ deve l√™-lo.  Mesmo sistemas OLTP com muita, muita escrita podem ler 3 vezes mais do que escrevem.  Portanto, nossa transa√ß√£o custa 20-40 IO, o que significa 0,2-0,8 segundos por disco. <br>  2 transa√ß√µes por segundo.  N√£o √© suficiente?  Vamos tentar espalhar os discos?  Ah, mas ainda precisamos esperar at√© que o anterior seja gravado e n√£o haja paralelismo no final.  Como ser  E vamos come√ßar um arquivo de log no qual gravaremos seq√ºencialmente todas as opera√ß√µes de grava√ß√£o no banco de dados e nas marcas de transa√ß√£o!  Pr√≥s: </p><br><ul><li>  As informa√ß√µes sobre a opera√ß√£o podem ser muito mais compactas do que gravar a p√°gina inteira (um tamanho de p√°gina t√≠pico √© 8 KiB, as informa√ß√µes gravadas no log geralmente s√£o 0,5-1 KiB). </li><li>  Em vez de escrever sobre se a transa√ß√£o √© registrada ou n√£o diretamente na p√°gina, h√° r√≥tulos suficientes sobre o in√≠cio e a corre√ß√£o da transa√ß√£o no log. </li><li>  As p√°ginas n√£o podem ser gravadas ap√≥s cada transa√ß√£o - v√°rias vezes menos.  O processo de leitura / grava√ß√£o de dados √© completamente "desatado" do log. </li><li>  A principal coisa.  Se colocarmos nosso di√°rio em um disco separado e gravar registros sequencialmente, devido ao fato de voc√™ n√£o precisar reposicionar constantemente os cabe√ßotes de disco, mesmo um HDD dom√©stico nesse modo comprime at√© 1000 IOPS, considerando que pequenas transa√ß√µes "custam" de 2 a 4 entradas no di√°rio, ent√£o voc√™ pode espremer 200-400 TPS </li><li>  No caso de uma falha, o estado do arquivo de dados pode ser restaurado usando esse log e, se uma transa√ß√£o for cancelada, as altera√ß√µes poder√£o ser revertidas. </li></ul><br><p>  Esse log √© chamado de log write-ahead / log de transa√ß√µes / log REDO. </p><br><p>  Viva!  √ìtimo!  Havia duas transa√ß√µes por segundo, tornou-se 300 - melhorou 150 vezes.  E a que custo?  Como se v√™, o pre√ßo √© significativo: </p><br><ul><li>  Em todos os DBMSs comuns, o log √© estritamente consistente.  Um segmento √© respons√°vel por gravar no log.  Voc√™ tem 100 processadores?  Legal.  E o log ainda gravar√° um thread.  A profundidade da fila √© exatamente uma. </li><li>  Ainda - sem caches de SO, sem permuta√ß√µes de opera√ß√µes.  Os requisitos de durabilidade permaneceram.  Opera√ß√µes de grava√ß√£o: at√© o disco responder "escrevi, escrevi diretamente na superf√≠cie, n√£o no cache, com certeza" O DBMS n√£o continua funcionando. </li><li>  Se voc√™ colocar o arquivo de log no disco de dados, quase todos os benef√≠cios da grava√ß√£o seq√ºencial ser√£o perdidos.  Al√©m disso - para sempre, se houver v√°rios bancos de dados no servidor, v√°rios discos para revistas. </li><li>  Revers√£o de transa√ß√£o (pelo menos no MS SQL Server) - leia o log e restaure o estado dele.  S√£o tantas ou mais opera√ß√µes de grava√ß√£o quanto houve opera√ß√µes de grava√ß√£o na transa√ß√£o.  A revers√£o √© cara! </li></ul><br><p>  Essa explica√ß√£o √© muito simplificada "nos dedos".  Isso √© suficiente para o nosso t√≥pico.  O WAL √© um mecanismo fundamental e fundamental para garantir a transacionalidade, √© necessariamente write-through, o acesso √© de thread √∫nico apenas para grava√ß√£o sequencial, do ponto de vista do armazenamento, a profundidade da fila √© 1. </p><br><div class="spoiler">  <b class="spoiler_title">Se voc√™ est√° interessado neste t√≥pico</b> <div class="spoiler_text"><ul><li>  Um artigo muito introdut√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como os bancos de dados s√£o projetados</a> </li><li>  H√° uma excelente s√©rie de artigos para o SQL Server.Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parar de chamar o log de transa√ß√µes do SQL Server como um arquivo de log e parar de lutar por seu tamanho.</a> </li><li>  √â interessante olhar um pouco do outro lado, por exemplo, a transcri√ß√£o de um excelente relat√≥rio sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarantool</a> DBMS na mem√≥ria </li><li>  Cada DBMS possui se√ß√µes extensivas que explicam como o WAL funciona. </li></ul></div></div><br><p>  O t√≥pico do log de grava√ß√£o antecipada no banco de dados deve ser pelo menos m√≠nimo conhecido por qualquer pessoa que de alguma forma administre o DBMS ou a infraestrutura do DBMS ou desenvolva bancos de dados. </p><br><h3 id="wal-i-shd">  WAL e SHD </h3><br><p>  Os fabricantes de armazenamento ‚Äúdesde o nascimento‚Äù s√£o confrontados com o DBMS.  √â para bancos de dados que as empresas compram esses complexos insanamente caros: dos armazenamentos de pre√ßos de rua da Dell-EMC, HP, Hitachi, NetApp, ao impor um or√ßamento, os olhos se enchem de l√°grimas pela maioria dos gerentes de topo, a menos que, √© claro, eles obtenham uma porcentagem desse pre√ßo.  Mas h√° um conflito de engenharia e marketing.  Explicarei isso usando o Dell-EMC como exemplo, mas apenas porque lembro onde eles t√™m a documenta√ß√£o. </p><br><p>  Ent√£o: </p><br><ol><li>  Di√°rio de encadeamento √∫nico </li><li>  O log de grava√ß√£o, ou seja, lat√™ncia, √© "eterno" comparado ao desempenho da CPU </li><li>  As cargas OLTP s√£o muitas transa√ß√µes relativamente pequenas, </li><li>  A maioria das outras cargas de DBMS s√£o paralelas de uma maneira ou de outra. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A lei da Amdahl</a> impiedosamente nos diz que uma carga de baixo desempenho de thread √∫nico tornar√° a adi√ß√£o de processadores in√∫teis, e o desempenho ser√° determinado pelo log.  Al√©m disso, neste momento, n√£o daremos a m√≠nima para o desempenho do armazenamento no IOPS, e apenas a lat√™ncia se tornar√° importante. <br>  Mas n√£o desconte outras opera√ß√µes de disco - leitura e grava√ß√£o em arquivos de dados e <code>tempdb</code> .  A leitura tamb√©m √© uma opera√ß√£o "em espera".  At√© que uma p√°gina de dados seja lida do disco para a mem√≥ria, o processador n√£o poder√° process√°-la.  Por√©m, para essas opera√ß√µes, grandes filas e permuta√ß√µes de opera√ß√µes nessa fila s√£o poss√≠veis: o DBMS geralmente sabe quais p√°ginas carregar na mem√≥ria, quais p√°ginas despejar e coloca muitas filas para leitura de uma s√≥ vez.  Como nesse cen√°rio √© importante quando a √∫ltima opera√ß√£o do pacote termina, nesse carregamento, pelo contr√°rio, o IOPS √© mais importante para n√≥s do que a lat√™ncia de uma √∫nica opera√ß√£o.  Para entender o escopo: as opera√ß√µes de leitura em um sistema OLTP t√≠pico s√£o de 85% a 95%.  Sim, sim, sim, as opera√ß√µes de grava√ß√£o s√£o uma ordem de magnitude menor. </p><br><p>  Os engenheiros de armazenamento de fornecedores est√£o trabalhando em estreita colabora√ß√£o com os fornecedores de DBMS e est√£o bem cientes de todas as nuances t√©cnicas de como um DBMS funciona com um subsistema de disco.  O planejamento, o particionamento e a aloca√ß√£o adequados de recursos de disco para o DBMS s√£o uma compet√™ncia complexa e importante do <strong>administrador do sistema de armazenamento</strong> .  O mesmo Dell-EMC ainda possui o white paper b√°sico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">H14621</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">H12341</a> para recomenda√ß√µes de particionamento para o SQL Server - mais de cem p√°ginas.  Ei!  Este n√£o √© um encaixe detalhado, √© o white paper mais comum!  Ainda h√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos</a> espec√≠ficos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h15142</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h16389</a> ... h√° escurid√£o l√°).  Os ‚Äúadjacentes‚Äù do VMware - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura do Microsoft SQL Server no VMware vSphere</a> n√£o est√£o muito atr√°s.  Observe que esses documentos n√£o s√£o apenas para os DBAs e n√£o para os administradores de infraestrutura e armazenamento. <br>  Tamb√©m observo que em todos esses documentos LUNs separados s√£o cortados para dados, logs e <code>tempdb</code> .  Sim, em algum lugar nos documentos mais recentes, eles dizem claramente que, para as solu√ß√µes All-Flash, n√£o faz sentido separar os logs em m√≠dia fisicamente separada, mas os LUNs ainda oferecem cort√°-los separadamente.  Se voc√™ despejar dados e efetuar logon em um LUN, do ponto de vista do sistema operacional, haver√° uma fila de E / S.  E haver√° um problema.  As opera√ß√µes de lat√™ncia ter√£o imediatamente uma ordem de magnitude maior.  E devido ao fato de opera√ß√µes de log n√£o realoc√°veis ‚Äã‚Äãaparecerem na fila, o IOPS escorregar√° nos arquivos de dados e no <code>tempdb</code> .  Esta n√£o √© uma "descoberta do s√©culo", √© uma verdade elementar do trabalho com o banco de dados.  N√£o est√° desatualizado ou cancelado com o advento do All-Flash.  Sim, os atrasos nas opera√ß√µes com SSDs s√£o mais r√°pidos em uma ordem de magnitude do que nas opera√ß√µes com HDDs, mas ainda assim algumas ordens de magnitude mais lentas que as opera√ß√µes com mem√≥ria.  O IO ainda √© o gargalo do DBMS. <br>  E os documentos t√©cnicos enfatizam corretamente que, nos logs de transa√ß√µes, o n√∫mero de IOPS n√£o √© importante, mas √© importante que a lat√™ncia seja m√≠nima (nos tempos modernos, est√° escrito que menos de 1 ms). </p><br><p>  Mas os profissionais de marketing precisam vender.  Hiperconverg√™ncia!  Virtualiza√ß√£o!  Flexibilidade de implanta√ß√£o!  Desduplica√ß√£o!  Configura√ß√£o f√°cil!  Muitos, muitos IOPS!  Belas apresenta√ß√µes, voz confiante, trajes formais.  Mas de que outra forma vender uma solu√ß√£o com um pre√ßo de 6 a 7 d√≠gitos em d√≥lares?  Por isso, esquece-se de alguma forma que a lat√™ncia ou a taxa de transfer√™ncia podem ser obtidas no sistema de armazenamento, mas n√£o de uma s√≥ vez, que algum tipo de licen√ßa para o balanceador de carga √© como outra prateleira, que se a grava√ß√£o intensiva durar mais de uma hora, a RAM dos controladores n√£o √© suficiente e a produtividade diminui para "como se n√£o houvesse cache", que treinar os funcion√°rios do cliente custa outros 100.000 rublos pelo primeiro ano, bem, esses truques ... </p><br><h3 id="5-ms">  5 ms </h3><br><p>  Ouve falar muito de ter lido profissionais de marketing, ou de pregui√ßa, ou por causa de algum tipo de barata, mas, por algum motivo, os administradores de armazenamento costumam fazer algo assim.  Pegamos uma prateleira grande, combinamos tudo em algo plano, cortamos em LUNs provisionadas finas e distribu√≠mos por LUN ao servidor.  Ou dois, porque "a parti√ß√£o do sistema est√° bem desduplicada".  E quando vejo que, com o subsistema de disco do lado do SQL, inferno-inferno-inferno, come√ßa a m√∫sica: "5 ms √© um excelente indicador", "100000 IOPS", "Sua carga de armazenamento √© inferior a 5%" </p><br><p>  <strong>N√ÉO</strong> . </p><br><ul><li>  Para sistemas OLTP em uma parti√ß√£o com logs WAL / transa√ß√£o de 5 ms, este √© um indicador inv√°lido.  No peda√ßo de ferro "quase comoditizado" por um pre√ßo de 1.000 (em palavras: mil) vezes mais barato, o indicador normal agora ser√° de 0,1-0,3 ms.  E amanh√£ - 0,01 ms.  Velocidade, como a do HDD de 2008, ao pre√ßo de uma entrada inteira de apartamentos em Moscou, n√£o √© necess√°ria.  Nenhuma "manuten√ß√£o" vale a pena. </li><li>  O fornecedor escreve que os logs de transa√ß√µes n√£o s√£o exigentes no IOPS e podem ser colocados no HDD?  √â sim.  Mas, para isso, √© necess√°rio que nenhum desses discos <del>  cont√°gio </del>  Al√©m de gravar logs, o DBMS n√£o tocou na tarefa.  E para que o sistema de armazenamento responda ao servidor que os dados foram gravados, imediatamente quando os dados foram inseridos na mem√≥ria n√£o vol√°til (isso √© muito mais cedo do que eles ser√£o gravados) </li><li>  Discos finos para bancos de dados OLTP reais s√£o ruins. </li><li>  Para o WAL, √© absolutamente desinteressante a quantidade de IOPS que pode ser extra√≠da por a√≠ a uma profundidade de fila de 10 ou 20. N√£o h√° profundidade l√°. </li><li>  Para o WAL, n√£o √© absolutamente um indicador de que a fila de E / S no SO seja "apenas cerca de 1".  Ela n√£o ser√° mais. </li><li>  N√£o, os desenvolvedores de DBA e DB n√£o s√£o "pica-paus dobrados que n√£o podem configurar adequadamente para gravar no paralelo WAL" <em>(opini√£o real do administrador)</em> </li><li>  A l√≥gica dos f√£s de considerar a reciclagem ", uma vez que o sistema <em>configurado em uma parti√ß√£o</em> tortamente n√£o faz 10.000 IOPS; ele deve ser movido de uma matriz de gama alta para m√©dia" - essa √© uma l√≥gica incorreta. </li><li>  Se o servidor de 40 n√∫cleos tiver uma carga de processador de 2,5%, isso n√£o significa que n√£o h√° nada a fazer, mas, muito provavelmente, significa que existe algum tipo de tarefa que bloqueia todo mundo. </li></ul><br><p>  Quando um carregamento de dados no laptop do desenvolvedor leva 5 minutos, e no 40¬∫ servidor nuclear com 1 TiB de RAM e armazenamento por meio milh√£o de d√≥lares, a mesma tarefa √© executada por uma hora, mesmo os clientes mais pacientes ter√£o d√∫vidas sobre a justificativa dos custos. </p><br><table><thead><tr><th>  Lat√™ncia m√©dia da parti√ß√£o WAL </th><th>  nunca haver√° mais transa√ß√µes por segundo do que: </th></tr></thead><tbody><tr><td>  5 ms </td><td>  200 </td></tr><tr><td>  1 ms </td><td>  1000 </td></tr><tr><td>  0,5 ms </td><td>  2000 </td></tr><tr><td>  0,1 ms </td><td>  10.000 </td></tr><tr><td>  0,05 ms </td><td>  20000 </td></tr></tbody></table><br><h2 id="chto-delat">  O que fazer </h2><br><h3 id="sovety-administratoram-i-dba">  Dicas de administrador e DBAs </h3><br><p>  Para OLTP, pare de contar "reciclagem" e IOPS.  Separadamente, observo - n√£o olhe para o IOPS com uma grande profundidade de fila: mesmo nas parti√ß√µes de dados, as grandes filas geralmente t√™m uma pequena explos√£o ou algo que n√£o afeta o desempenho real do OLTP. </p><br><p>  Compartilhar espa√ßo em disco pelo LUN n√£o √© um capricho do DBA.  O banco de dados possui v√°rios perfis diferentes de carregamento do subsistema de disco.  No m√≠nimo, √© poss√≠vel distinguir o seguinte: </p><br><ul><li>  Trabalhe com arquivos de dados.  Normalmente, isso √© leitura e escrita com blocos aleat√≥rios de 8/64 KiB.  Leituras 80-95%.  Filas surgem: durante per√≠odos de servi√ßo, durante per√≠odos de carregamento em massa, em solicita√ß√µes ineficientes ou em massa e durante o ponto de verifica√ß√£o.  O desempenho √© afetado pela capacidade de resposta √† leitura.  √â importante que o alinhamento dos blocos 8/64 KiB "passados" passe por todo o sistema de armazenamento. </li><li>  Trabalhar com <code>tempdb</code> √© o mesmo que trabalhar com arquivos de dados, mas as leituras geralmente s√£o de 40 a 75% e a capacidade de resposta √† grava√ß√£o pode ser importante.  Nos modernos sistemas MS SQL, esse banco de dados pode ser carregado v√°rias vezes mais forte que os bancos de dados.  Em uma configura√ß√£o do DBMS n√£o em cluster, esta se√ß√£o deve ser exclu√≠da de qualquer replica√ß√£o de armazenamento.  Seu conte√∫do ap√≥s a reinicializa√ß√£o do servi√ßo ainda ser√° destru√≠do. </li><li>  Trabalhe com dados arquivados / DWH.  As leituras s√£o pr√≥ximas de 100%.  O tamanho de um bloco de leitura geralmente √© de 64 KiB.  As solicita√ß√µes s√£o lidas muito e seguidas, para que a fila possa saltar at√© 1000 ou mais. </li><li>  Trabalhe com logs de transa√ß√µes.  A leitura √© apenas para manuten√ß√£o (backup, replica√ß√£o etc.), o desempenho do aplicativo √© afetado apenas pela grava√ß√£o.  Grava√ß√£o em blocos de 0,5 a 64 KiB.  Sem fila, em um thread.  O atraso √© cr√≠tico para aplicativos. </li><li>  Backup e restaura√ß√£o.  Do ponto de vista do banco de dados, est√° lendo em grandes blocos (geralmente 1 MiB).  √â importante que essa carga possa repousar nos canais / barramentos (FC e Ethernet) e no desempenho dos processadores de armazenamento em alguns casos.  O backup de um servidor pode afetar o desempenho de outros servidores da mesma SAN / SHD. </li><li>  Trabalhar com arquivos de aplicativo: s√£o logs, rastreamento padr√£o, arquivos bin√°rios etc.  Essa carga raramente √© significativa e √© importante apenas no in√≠cio do sistema. </li></ul><br><p>  Existem outros tipos de carregamento, mas eles s√£o um pouco ex√≥ticos (por exemplo, pode haver um reposit√≥rio de arquivos armazenados no banco de dados na forma do diret√≥rio FileStream).  Todos esses tipos de cargas t√™m requisitos de disco diferentes, geralmente conflitantes.  Se todos eles estiverem empilhados em uma parti√ß√£o, voc√™ n√£o apenas prejudicar√° o desempenho, mas √© muito importante perder a capacidade de entender por que o sistema fica mais lento e tamb√©m perder a oportunidade de melhorar apenas a parte que precisa de aprimoramento sem melhorias / upgrades globais de armazenamento.  Portanto, a principal recomenda√ß√£o: </p><br><p> <strong>      ,   "   "        .        .</strong> </p><br><p>     </p><br><ul><li>    ,   .  Dell/EMC  SQL Server     . </li><li>    .      ""  (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> NUC c SSD,  , </a> ).    --,    . </li><li>      <strong></strong>     DBA,    -   ( 200   ). </li><li>        (etrolaster   ), ,     ,  .      +0,5 ,    0,2,     0,7     3 . </li><li>   ,          .      <code>tempdb</code>  , , ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RCSI</a>   12      . </li><li> Latency    throughput.         ,   " ",   .    throughput  latency,    .      . </li></ul><br><h3 id="ms-sql-server"> MS SQL Server </h3><br><p>    MS SQL,            bottleneck  ,  - : </p><br><ol><li>        .  Isto est√° correto.        . 1000          5-30      1000 <code>INSERT</code> . , , ,       ,      "  ‚Äî  ". </li><li>  <code>tempdb</code>   " ".    . ,     ,       . </li><li>     ,    BULK INSERT      .            ,      "Simple"  "Bulk logged". , ,         Simple/Bulk logged  Full  .         ‚Äî <a href="">The Data Loading Performance Guide</a> ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .   (  ETL,   OLTP)       <a href="">We Loaded 1TB in 30 Minutes with SSIS, and So Can You</a> </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Delayed Transaction Durability</a> ‚Äî ,       . </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">In-Memory OLTP</a> .    ,        . </li><li> ,     ,   AlwaysOn . </li></ol><br><h2>  *** </h2><br><p>  Isso √© tudo.   . 20000 IOPS  5  latency    4-16         OLTP.  OLTP    ,        . </p><br><div class="spoiler"> <b class="spoiler_title">PS:    SSD.</b> <div class="spoiler_text"><p>              .  Intel Optane.   SSD ""       4,       .            SSD, ,     ,      .    SSD  . ,      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,    </a> .      Intel Optane:      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> )        1     20 .     ,  . SSD        100-300 .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>     SSD. <br>  , .         OLTP "",  in-memory     ACID.     latency 20      "" .  low-latency        Optane ( <em>    ?</em> ). <br>          ( ) Optane. </p></div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">eugeneb0</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">apatyukov</a>     . </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414269/">https://habr.com/ru/post/pt414269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414253/index.html">Padr√µes para testadores. Proxy (alternativo)</a></li>
<li><a href="../pt414261/index.html">Onde voc√™ armazena os dados?</a></li>
<li><a href="../pt414263/index.html">Existe vida fora de Roscosmos? Vis√£o geral da explora√ß√£o espacial privada russa</a></li>
<li><a href="../pt414265/index.html">Richard Hamming: Cap√≠tulo 7. Intelig√™ncia Artificial - II</a></li>
<li><a href="../pt414267/index.html">Como substituir um contador por um rob√¥?</a></li>
<li><a href="../pt414271/index.html">Como domesticar um disco r√≠gido em um laptop e impedir o estacionamento em 8 segundos de inatividade</a></li>
<li><a href="../pt414273/index.html">O que voc√™ precisa saber antes de desenvolver um backtester para uma estrat√©gia de negocia√ß√£o: problemas t√≠picos, tipos de sistemas e seus par√¢metros</a></li>
<li><a href="../pt414277/index.html">Homem, seu ambiente e a Internet das coisas</a></li>
<li><a href="../pt414279/index.html">Vota√ß√£o de relat√≥rios na oitava reuni√£o DIY no Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../pt414281/index.html">Desenvolvimento de um veloc√≠metro de bicicleta baseado em uma tela do Nokia 3310</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>