<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😶 🈯️ 😑 OpenGL中的WBOIT：无需排序即可透明 🧘🏼 🦊 👨🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将讨论“加权混合的不依赖顺序的透明性”（以下简称WBOIT）-JCGT在2013年描述的技术（ 链接 ）。 

 当屏幕上出现几个透明物体时，像素的颜色取决于哪一个更靠近观察者。 这是这种情况下的众所周知的混色公式： 





\开始{matrix} C = C_ {near} \ alpha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL中的WBOIT：无需排序即可透明</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/"> 我们将讨论“加权混合的不依赖顺序的透明性”（以下简称WBOIT）-JCGT在2013年描述的技术（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> ）。 <br><a name="habracut"></a><br> 当屏幕上出现几个透明物体时，像素的颜色取决于哪一个更靠近观察者。 这是这种情况下的众所周知的混色公式： <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#x5F00;&amp;#x59CB;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha&amp;#xFF09;&amp;amp;&amp;amp;&amp;#xFF08;1&amp;#xFF09;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\开始{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}（1-&nbsp;\&nbsp;alpha）&amp;&amp;（1）\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\开始{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}（1-&nbsp;\&nbsp;alpha）&amp;&amp;（1）\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \开始{matrix} C = C_ {near} \ alpha + C_ {far}（1- \ alpha）&&（1）\ end {matrix} </script></p><br> 片段排列的顺序对此很重要：Near片段的颜色及其不透明度用C <sub>near</sub>和<i>α</i>表示，位于它后面的所有片段的结果颜色用C <sub>far</sub>表示。 不透明度是一个属性，其取值范围为0到1，其中0表示对象非常透明以至于不可见，而1表示对象不透明以致<i>在其后</i>不可见。 <br><br> 要使用此公式，必须首先按深度对片段进行排序。 想象一下这涉及多少头痛！ 通常，应在每个帧中进行排序。 如果要对对象进行排序，则必须将某些形状复杂的对象切成碎片，并按切出部分的深度进行排序（特别是对于相交的曲面，肯定需要这样做）。 如果对片段排序，则排序将在着色器中进行。 这种方法称为“顺序无关的透明度”（OIT），它使用存储在视频卡内存中的链表。 预测必须为此列表分配多少内存几乎是不现实的。 如果没有足够的内存，则在屏幕上会出现伪像。 <br><br> 幸运的是，那些谁能够控制在舞台上放置多少个半透明物体以及它们在彼此之间的相对位置。 但是，如果您进行CAD，那么您将拥有用户想要的尽可能多的透明对象，并且它们将随机放置。 <br><br> 现在，您了解了某些人简化生活的愿望，并提出了无需排序即可混合颜色的公式。 这样的公式出现在我开头提到的文章中。 甚至有几个公式，但是根据作者（我也认为）最好的公式是： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha_i&amp;#xFF09;&amp;#xFF09;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha_i&amp;#xFF09;&amp;amp;&amp;amp;&amp;#xFF08;2&amp;#xFF09;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}（1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i））+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i）&amp;&amp;（2）\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}（1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i））+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i）&amp;&amp;（2）\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}}（1- \ prod_ {i = 1} ^ {n}（1- \ alpha_i））+ C_0 \ prod_ {i = 1} ^ {n}（1- \ alpha_i）&&（2）\ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br> 屏幕截图中的是位于四个深度的半透明三角形组。 在左侧，使用WBOIT技术对其进行渲染。 右侧是使用公式（1）获得的图片，其中考虑了片段排列的顺序，是经典的色彩混合。 接下来，我将其称为CODB（经典顺序相关混合）。 <br><br> 在开始渲染透明对象之前，我们必须渲染所有不透明对象。 之后，使用深度测试渲染透明对象，但不写入深度缓冲区（这是这样完成的： <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ）。 也就是说，这是在具有某些屏幕坐标（x，y）的点处发生的情况：比不透明的更近的透明片段通过深度测试，而不管它们相对于已绘制的透明片段的深度如何，以及出现得更远的透明片段不透明的，不通过深度测试，因此被丢弃。 <br><br> 式（2）中的C <sub>0</sub>是不透明片段的颜色，在该不透明片段的顶部绘制了透明片段，其中有n个片段，由索引1至n表示。  C <sub>i</sub>是第i个透明片段的颜色， <i><sub>αi</sub></i>是其不透明度。 <br><br> 如果仔细观察，则公式（2）有点像公式（1）。 如果你想像到 <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  C <sub>在附近</sub> ，C <sub>0</sub>在C <sub>在附近</sub> ，并且 <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  -这是<i>α</i> ，那么这将是第一个公式，一对一。 真的 <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  -这是透明片段颜色的加权平均值（质心在力学上由相同公式确定），它将是最近的片段C <sub>near</sub>的颜色。  C <sub>0</sub>是位于所有片段后面的不透明片段的颜色，为此我们计算了该加权平均值，并且对于C <sub>far</sub> ，它将通过。 也就是说，我们用一个“平均”片段替换了所有透明片段，并应用了用于混合颜色的标准公式-公式（1）。 原始文章的作者为我们提供的<i>α</i>这个狡猾公式是什么？ <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="36.279ex" height="2.78ex" viewBox="0 -780.1 15619.9 1197.1" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-31" x="1124" y="0"></use></g></g><g transform="translate(9204,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-31" x="10034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMAIN-2212" x="10757" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-61" x="12008" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-6C" x="12537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-70" x="12836" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-68" x="13339" y="0"></use><g transform="translate(13916,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhjQLFfaD6EUoB4bamlRImYEm9QgCg#MJMATHI-69" x="748" y="-213"></use></g><g transform="translate(14789,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n}（1- \ alpha_i）</script></p><br> 这是n维空间中的标量函数，因此让我们回想一下对多个变量的函数进行的差分分析。 假定所有<i><sub>αi</sub></i>都在0到1的范围内，则相对于任何变量的偏导数将始终是非负常数。 这意味着“平均”片段的不透明度随任何透明片段的不透明度的增加而增加，这正是我们所需要的。 另外，它线性增加。 <br><br> 如果片段的不透明度为0，则根本不可见，也不会影响最终的颜色。 <br><br> 如果至少一个片段的不透明度为1，则<i>α</i>为1。即，不透明的片段变得不可见，通常是好的。 仅位于透明度为1的片段后面的透明片段仍会通过它发光并影响最终的颜色： <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br> 在这里，橙色三角形位于其上方，绿色位于其下，灰色和青色位于绿色下，而所有这些都是黑色背景。 蓝色不透明度= 1，其他所有颜色-0.5。 右边的图片是应该的。 如您所见，WBOIT看起来令人作呕。 正常橙色显示的唯一位置是绿色三角形的边缘，周围是不透明的白线。 就像我刚才说的，如果透明片段的不透明度为1，则不透明片段是不可见的。 <br><br> 这在这里更好看： <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br> 橙色三角形的不透明度为1，简单地用不透明的对象绘制了透明性已关闭的绿色三角形。 看起来绿色三角形通过橙色三角形穿过橙色。 <br><br> 为了使图片看起来像样，最简单的方法是不为对象分配高不透明度。 在我的工作项目中，我不允许将不透明度设置为大于0.5。 这是3D CAD，其中示意性地绘制了对象，并且不需要特殊的现实感，因此在此允许这样的限制。 <br><br> 使用低不透明度值时，左右图片几乎相同： <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br> 而且较高时它们明显不同： <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br> 这是透明多面体的样子： <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br> 多面体具有橙色的侧面和绿色的水平面。 不幸的是，您乍看之下不会理解这一点，即 图片看起来并不令人信服。 前面有橙色墙的地方，您需要的不仅仅是橙色，而绿色比绿色多。 用一种颜色绘制面会更好： <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3> 基于深度的WBOIT </h3><br> 为了以某种方式弥补按深度排序的不足，本文的作者提出了几种在公式（2）中增加深度的选项。 这使实施更加困难，结果难以预测，并且取决于特定三维场景的特征。 我没有深入研究这个主题，所以谁在乎-我建议阅读这篇文章。 <br><br> 有人认为，WBOIT有时具有传统分拣透明性无法提供的功能。 例如，您仅使用两个粒子-深色和浅色烟雾，将烟雾绘制为一个粒子系统。 当一个粒子通过另一个粒子时，经典的颜色混合和分类会产生难看的结果-来自灯光的烟雾的颜色急剧变暗。 文章说，深度敏感的WBOIT允许平滑过渡，并且看起来更可信。 可以用细管的形式为皮毛和头发建模的方式也是如此。 <br><br><h3> 代号 </h3><br> 现在介绍如何在OpenGL上实现公式（2）。 示例代码位于Github（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> ）上，文章中的大多数图片都来自此。 您可以收集和玩我的三角形。 使用Qt框架。 <br><br> 对于那些刚开始研究透明对象的渲染的人，我建议这两篇文章： <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">学习OpenGL。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4.3课-混合颜色</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Direct3D 11和OpenGL 4上的链表的顺序无关的透明度算法</a> <br><br> 但是，第二篇对于理解该材料并不那么重要，但是第一篇是必读的。 <br><br> 要计算公式（2），我们需要2个额外的帧缓冲区，3个多样本纹理和一个渲染缓冲区，在其中写入深度。 在第一个纹理-colorTextureNT（NT表示非透明）中，我们将渲染不透明的对象。 它的类型为GL_RGB10_A2。 第二个纹理（colorTexture）的类型为GL_RGBA16F； 在此纹理的前三个组成部分中，我们将编写以下公式（2）： <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70"> 在第四- <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  。  GL_R16类型的另一个纹理（alphaTexture）将包含 <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  。 <br><br> 首先，您需要创建以下对象以从OpenGL获取其标识符： <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br> 就像我说的，这里使用Qt框架，所有OpenGL调用都要通过QOpenGLFunctions_4_5_Core类型的对象，在我看来，该对象始终表示为f。 <br><br> 现在您应该分配内存： <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br> 并配置帧缓冲区： <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br> 在第二次渲染过程中，片段着色器的输出将立即转到两个纹理，并且必须使用glDrawBuffers明确指定。 <br><br> 大部分这些代码在程序启动时执行一次。 每次调整窗口大小时，都会调用为纹理和渲染缓冲区分配内存的代码。 接下来是渲染代码，每次重新绘制窗口时都会调用该代码。 <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br> 我们只是在colorTextureNT纹理上绘制了所有不透明的对象，并将深度写入渲染缓冲区。 在下一个绘图阶段使用相同的渲染缓冲区之前，您需要确保所有不透明对象的深度均已写入那里。 为此，使用GL_FRAMEBUFFER_BARRIER_BIT。 渲染透明对象之后，我们调用ApplyTextures（）函数，它将启动渲染的最后阶段，其中片段着色器将从纹理colorTextureNT，colorTexture和alphaTexture中读取数据以应用公式（2）。 到那时纹理应该已经完全写好了，因此在调用ApplyTextures（）之前，我们使用GL_TEXTURE_FETCH_BARRIER_BIT。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO是通过其显示图像的帧缓冲区。 在大多数情况下，它是0，但在Qt中，它是QOpenGLWidget :: defaultFramebufferObject（）。 <br><br> 每次调用片段着色器时，我们都会获得有关当前片段的颜色和不透明度的信息。 但是，在colorTexture纹理的输出处，我们希望获得这些数量的某些函数的总和（在alphaTexture纹理中为乘积）。 为此使用混合。 此外，由于对于第一个纹理我们计算总和，对于第二个纹理我们计算总和，因此必须分别设置每个附件的混合设置（glBlendFunc和glBlendEquation）。 <br><br> 这是PrepareToTransparentRendering（）函数的内容： <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br> 以及CleanupAfterTransparentRendering（）函数的内容： <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br> 在我的片段着色器中，不透明度用字母w表示。 颜色与w和w本身的乘积我们输出到一个输出参数，而1-w输出到另一个输出参数。 对于每个输出参数，以“ location = X”的形式设置布局限定符，其中X是附件数组中元素的索引，我们将其传递给第3个列表中的glDrawBuffers（具体来说，location = 0的输出参数将发送到绑定到GL_COLOR_ATTACHMENT0的纹理，以及位置= 1的参数-在附加到GL_COLOR_ATTACHMENT1的纹理中）。  glBlendFunci和glBlendEquationi函数中使用了相同的数字来表示我们为其设置混合参数的附件编号。 <br><br> 片段着色器： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br> 在ApplyTextures（）函数中，我们只需在整个窗口上绘制一个矩形。 片段着色器使用当前屏幕坐标作为纹理坐标，并使用当前样本编号（gl_SampleID）作为多样本纹理中的样本编号，从我们创建的所有纹理中请求数据。 当为每个样本调用一次片段着色器时，在着色器中使用gl_SampleID变量会自动打开该模式（在正常情况下，对于整个像素都将调用一次，并将结果写入基本体内部的所有样本）。 <br><br> 顶点着色器没有什么特别之处： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br> 片段着色器： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br> 最后，ApplyTextures（）函数的内容： <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br> 好了，结束后释放OpenGL资源会很好。 我在OpenGL小部件的析构函数中调用了以下代码： <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457284/">https://habr.com/ru/post/zh-CN457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457262/index.html">后端开发人员中的编程冠军资格分析</a></li>
<li><a href="../zh-CN457266/index.html">敏捷危机。 怎么办</a></li>
<li><a href="../zh-CN457270/index.html">Prisma-CMS作为快速创建MVP的引擎</a></li>
<li><a href="../zh-CN457276/index.html">对您网站的七种机器人威胁</a></li>
<li><a href="../zh-CN457282/index.html">“上帝之死”或21世纪建立IT团队和创建IT系统的普遍接受的法律的崩溃</a></li>
<li><a href="../zh-CN457286/index.html">以“ CCA”权限解决网络模块的WorldSkills任务。 第1部分-基本设置</a></li>
<li><a href="../zh-CN457288/index.html">基于PKCS＃11令牌的加密工作站。 电子签名。 第二部分</a></li>
<li><a href="../zh-CN457290/index.html">DEFCON 25会议，Garry Kasparov。 “大脑的最后一战。” 第二部分</a></li>
<li><a href="../zh-CN457292/index.html">OpenGL中的WBOIT：无需排序即可透明</a></li>
<li><a href="../zh-CN457294/index.html">“过高的生活”或我从拖延到自我发展的故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>