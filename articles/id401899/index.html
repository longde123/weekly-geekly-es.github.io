<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ƒğŸ¾ ğŸ‘©ğŸ»â€âš•ï¸ ğŸï¸ Logger DIY Multifungsi. Bagian 1 ğŸ’— ğŸ‘¨ğŸ¼â€âš•ï¸ ğŸ›€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya adalah pemilik perangkat yang luar biasa - Pencatat GPS Holux M-241. Masalahnya sangat nyaman dan berguna saat bepergian. Dengan bantuan logger, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logger DIY Multifungsi. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/401899/"><img src="https://habrastorage.org/getpro/geektimes/post_images/65a/f4c/1c8/65af4c1c8bd4dd394b6a6d2939c6d211.jpg" alt="gambar"><br><br>  Saya adalah pemilik perangkat yang luar biasa - Pencatat GPS Holux M-241.  Masalahnya sangat nyaman dan berguna saat bepergian.  Dengan bantuan logger, saya menulis trek perjalanan GPS, di mana Anda kemudian dapat melihat jalan Anda secara rinci, dan juga melampirkan foto yang Anda ambil ke koordinat GPS.  Dia juga memiliki layar kecil yang menunjukkan informasi tambahan - jam, kecepatan saat ini, ketinggian dan arah, odometer dan banyak lagi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> saya pernah menulis ulasan singkat. <br><br>  Dengan semua kelebihan sepotong besi, saya mulai tumbuh darinya.  Saya kehilangan beberapa barang kecil tapi berguna: beberapa odometer, menunjukkan kecepatan vertikal, mengukur parameter bagian lintasan.  Sepertinya hal-hal kecil, tetapi perusahaan Holux menemukan ini tidak cukup berguna untuk implementasi di firmware.  Selain itu, saya tidak menyukai beberapa parameter perangkat keras, dan beberapa hal telah menjadi usang dalam 10 tahun ... <br><br>  Pada titik tertentu, saya menyadari bahwa saya sendiri dapat membuat logger dengan fitur yang saya butuhkan.  Untungnya, semua komponen yang diperlukan cukup murah dan terjangkau.  Saya mulai membuat implementasi berdasarkan Arduino.  Di bawah potongan, buku harian konstruksi tempat saya mencoba melukis solusi teknis saya. <br><a name="habracut"></a><br><h1>  Menentukan fitur </h1><br>  Banyak yang akan bertanya mengapa saya perlu membuat logger sendiri, jika pasti ada sesuatu yang siap untuk produsen terkemuka.  Mungkin  Sejujurnya, saya tidak benar-benar mencarinya.  Namun yang pasti akan ada sesuatu yang hilang.  Bagaimanapun, proyek ini adalah penggemar bagi saya.  Mengapa kita tidak mulai membangun perangkat impian kita? <br><br>  Jadi, untuk apa saya menghargai Holux M-241 saya. <br><br><ul><li>  <b>Layar</b> membuat "kotak hitam", yang hasilnya hanya tersedia setelah perjalanan, alat yang sangat nyaman, bacaan yang tersedia di sini dan sekarang.  Memiliki layar memungkinkan hampir semua fitur pada daftar ini menjadi mungkin. </li><li>  <b>Sebuah arloji</b> berguna dalam dirinya sendiri.  Pada perjalanan GPS, penebang yang menggantung pada tali di lehernya sering kali ternyata lebih dekat daripada ponsel di sakunya atau di ransel.  Arloji mendukung semua zona waktu (meskipun dengan pengalihan manual) </li><li>  <b>Tombol POI</b> memungkinkan Anda untuk menandai koordinat saat ini di trek.  Misalnya, untuk mencatat tengara yang telah menyelinap di luar jendela bus, tentang yang saya ingin google nanti. </li><li>  Dengan menggunakan <b>odometer,</b> Anda dapat mengukur jarak yang ditempuh dari beberapa titik.  Misalnya, jarak yang ditempuh per hari, atau panjang lintasan. </li><li>  <b>Kecepatan, ketinggian, dan arah saat ini</b> membantu Anda menemukan diri Anda di luar angkasa </li><li>  <b>Kelangsungan hidup 12-14 jam</b> dari satu baterai AA dalam banyak kasus memungkinkan Anda untuk tidak memikirkan masalah catu daya.  Yaitu  biaya hampir selalu cukup untuk perjalanan sehari penuh. </li><li>  <b>Kompak dan mudah digunakan</b> - hal-hal di dunia modern sangat bagus </li></ul><br>  Namun, beberapa hal dapat dilakukan sedikit lebih baik: <br><br><ul><li>  Subsistem daya pada <b>baterai AA</b> ditulis oleh banyak orang sebagai plus plus - satu baterai berlangsung lama, dan Anda dapat mengisi ulang pasokan di hutan belantara.  Anda dapat menyimpan setidaknya satu bulan berkemah mandiri. <br><br>  Tetapi bagi saya, daya tahan baterai adalah wasir belaka.  Anda harus membawa beberapa baterai dan siapa yang tahu seberapa tinggi kualitas mereka (tiba-tiba mereka berbaring di rak selama 5 tahun dan sudah habis sendiri).  Dengan baterai, perdarahan bahkan lebih besar.  Pengisi daya saya hanya dapat mengisi daya secara berpasangan.  Kita harus membuang baterai agar memiliki tingkat pengosongan yang sama.  Akibatnya, Anda tidak pernah ingat di mana sudah habis, dan di mana belum. <br><br>  Selama 6 tahun menggunakan logger, saya hanya berakhir di hutan belantara tanpa listrik beberapa kali.  Sebagai aturan, saya mendapatkan akses ke outlet setidaknya sekali sehari.  Dalam hal ini, baterai lithium bawaan akan jauh lebih nyaman.  Nah, dalam kasus ekstrim, saya punya paverbank. <br><br></li><li>  <b>Indikasi tingkat debit</b> dibuat sangat bodoh - indikator mulai berkedip ketika baterai hampir habis.  Selain itu, dapat mati dalam 5 menit, dan mungkin bekerja satu jam lagi.  Sangat mudah untuk melewatkan momen ini dan kehilangan sebagian dari log. <br><br></li><li>  Sebagai orang yang tertarik dalam penerbangan, akan sangat menarik bagi saya untuk mengamati <b>kecepatan vertikal saat ini</b> . <br><br></li><li>  <b>Beberapa odometer</b> - seringkali menarik untuk mengukur lebih dari satu jarak.  Misalnya, jarak yang ditempuh per hari dan untuk seluruh perjalanan. <br><br></li><li>  Odometer diatur ulang saat Anda mematikan perangkat atau saat mengganti baterai.  Ini sangat tidak nyaman.  Jika Anda berhenti untuk makan di kafe, maka pencatat GPS tidak dapat dimatikan karena nilainya akan diatur ulang.  Dia harus membiarkannya dihidupkan dan dia terus berputar beberapa kilometer dan memakan baterai.  Akan jauh lebih nyaman untuk dapat menempatkan odometer pada <b>jeda</b> dan <b>menyimpan nilai di</b> antara inklusi. <br><br></li><li>  <b>Pengukuran parameter situs</b> .  Ketika bermain ski, misalnya, saya tertarik pada panjangnya keturunan, ketinggian, rata-rata dan kecepatan maksimum di situs, waktu yang dihabiskan.  Apa yang ingin Anda ketahui adalah segera, dan tidak di rumah ketika Anda mengunduh trek. <br><br></li><li>  <b>Akurasi</b> buruk.  Ketika Anda bergerak cepat - tidak ada yang lain.  Tetapi ketika kecepatannya kecil di trek, "suara" + - 50m terlihat jelas.  Dan selama satu jam berdiri, Anda bisa "mendesak" hampir satu kilometer.  Manfaat teknologi selama 10 tahun telah berjalan jauh ke depan dan penerima modern memberikan akurasi yang jauh lebih besar. <br><br></li><li>  <b>Kecepatan penggabungan</b> trek hanya 38.400. Tidak, yah, pada tahun 2017 tidak serius untuk menggunakan port COM untuk mentransfer sejumlah besar data.  Menggabungkan 2 megabita flash internal membutuhkan waktu lebih dari 20 menit. <br><br>  Selain itu, tidak setiap program dapat mencerna format trek yang digabungkan.  Utilitas asli sangat menyedihkan.  Untungnya, ada BT747, yang dapat secara memadai menggabungkan trek dan mengubahnya menjadi semacam format yang dapat dicerna. <br><br></li><li>  <b>Ukuran flash drive</b> hanya 2MB.  Di satu sisi, ini cukup untuk perjalanan dua minggu dengan poin penghematan setiap 5 detik.  Tapi pertama-tama, format internal yang dikemas <br>  membutuhkan konversi, dan yang kedua tidak memungkinkan untuk meningkatkan volume </li><li>  <b>Perangkat penyimpanan massal</b> untuk beberapa alasan sekarang tidak dalam mode.  Antarmuka modern berusaha menyembunyikan fakta keberadaan file.  Saya telah menggunakan komputer selama 25 tahun, dan bekerja dengan file secara langsung jauh lebih nyaman bagi saya daripada dengan cara lain. </li></ul><br>  Tidak ada apa pun di sini yang tidak dapat diwujudkan tanpa upaya yang signifikan. <br><br>  Ada yang berbeda.  Saya tidak menggunakannya sendiri, tetapi tiba-tiba seseorang berguna: <br><br><ul><li>  Memperlihatkan koordinat saat ini (lintang, bujur) </li><li>  Ikon-ikon yang berbeda digambar di sisi kiri layar, esensi yang bahkan tidak dapat saya ingat tanpa manual. </li><li>  Ada switching meter / km - kaki / mil. </li><li>  Pencatat Bluetooth dapat dihubungkan ke ponsel tanpa GPS. </li><li>  Jarak absolut ke titik. </li><li>  Logging berdasarkan waktu (setiap N detik) atau berdasarkan jarak (setiap X meter). </li><li>  Dukungan untuk berbagai bahasa. </li></ul><br><h1>  Pilih besi </h1><br>  Persyaratannya kurang lebih didefinisikan.  Sudah waktunya untuk memahami bagaimana semua ini dapat diimplementasikan.  Komponen utama yang akan saya miliki adalah: <br><br><ul><li>  <b>Mikrokontroler</b> - Saya tidak punya rencana untuk algoritma komputasi canggih, sehingga kekuatan pemrosesan kernel tidak terlalu penting.  Saya juga tidak memiliki persyaratan khusus untuk pengisian - satu set periferal standar akan dilakukan. <br><br>  Di tangan hanya sebaran arduino aneka, serta beberapa stm32f103c8t6.  Saya memutuskan untuk memulai dengan AVR, yang saya ketahui dengan baik di level controller / register / peripheral.  Jika saya mengalami pembatasan - akan ada alasan untuk merasakan STM32. <br><br></li><li>  <b>Penerima GPS</b> dipilih dari modul NEO6MV2, Beitan BN-800 dan Beitan BN-880.  Forum yang di-Google untuk beberapa waktu.  Orang yang berpengalaman mengatakan bahwa penerima pertama adalah abad terakhir.  Dua lainnya berbeda satu sama lain hanya di lokasi antena - di BN-800 itu tergantung pada kabel, dan di BN-880 itu dilem dengan sandwich ke modul utama.  Butuh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BN-880</a> . <br><br></li><li>  <b>Layar</b> - aslinya menggunakan LCD 128 x 32 dengan lampu latar.  Saya tidak menemukan yang persis sama.  Saya membeli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OLED 0,91 â€pada pengontrol SSD1306</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layar LCD 1,2â€ pada pengontrol ST7565R</a> .  Saya memutuskan untuk memulai dari yang pertama, karena  lebih mudah untuk terhubung dengan sisir standar sesuai dengan I2C atau SPI.  Tapi itu sedikit lebih kecil dibandingkan dengan aslinya, dan juga tidak akan bekerja di atasnya untuk terus menampilkan gambar karena alasan efisiensi bahan bakar.  Tampilan kedua seharusnya tidak terlalu rakus, tetapi Anda harus menyolder konektor yang rumit untuknya dan mencari tahu cara menyalakan lampu latar. </li></ul><br>  Dari hal-hal kecil: <br><br><ul><li>  Tombol pernah membeli seluruh tas; </li><li>  Melindungi dengan untuk kartu SD - juga berbaring di sekitar; </li><li>  Saya membeli sepasang pengontrol biaya yang berbeda untuk baterai lithium, tetapi saya masih tidak memahaminya. </li></ul><br>  Saya memutuskan untuk merancang papan di bagian paling akhir, ketika firmware sudah siap.  Pada saat ini, saya akhirnya akan memutuskan komponen utama dan skema untuk dimasukkannya.  Pada tahap pertama, saya memutuskan untuk melakukan debugging di papan tempat memotong roti dengan menghubungkan komponen menggunakan kabel patch. <br><br>  Tetapi pertama-tama Anda harus memutuskan masalah yang sangat penting - nutrisi komponen.  Menurut saya masuk akal untuk menyalakan segala sesuatu mulai dari 3.3V: GPS dan layar hanya di atasnya dan tahu cara bekerja.  Ini juga tegangan asli untuk USB dan SD.  Selain itu, sirkuit dapat ditenagai dari satu kaleng lithium. <br><br>  Pilihannya jatuh pada Arduino Pro Mini, yang dapat ditemukan dalam versi 8MHz / 3.3V.  Tapi dia tidak punya USB on board - saya harus menggunakan adaptor USB-UART. <br><br><h1>  Langkah pertama </h1><br>  Awalnya, proyek ini dibuat di Arduino IDE.  Tapi jujur â€‹â€‹saja, bahasa saya tidak berani menyebutnya IDE - seperti editor teks dengan kompiler.  Bagaimanapun, setelah Visual Studio, di mana saya telah bekerja selama 13 tahun terakhir, saya tidak dapat melakukan sesuatu yang serius di IDE Arduino tanpa air mata dan matyuk. <br><br>  Untungnya, ada Atmel Studio gratis, di mana bahkan Visual Assist sudah ada di dalam kotak !!!  Program tahu semua yang dibutuhkan, semuanya sudah akrab dan sebagai gantinya.  Ya, hampir semuanya (saya tidak menemukan cara mengkompilasi hanya satu file, misalnya, untuk memeriksa sintaks) <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/bfc/b08/98f/bfcb0898f136628896be3b6769eda34f.png" alt="gambar"><br><br>  Dimulai dari layar - ini diperlukan untuk men-debug kerangka firmware, lalu mengisinya dengan fungsionalitas.  Dia berhenti di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan pertama yang tersedia untuk Adafruit SSD1306</a> .  Dia tahu semua yang dibutuhkan dan menyediakan antarmuka yang sangat sederhana. <br><br>  Dimainkan dengan font.  Ternyata satu font dapat memakan waktu hingga 8 kb (ukuran hurufnya 24pt) - Anda tidak dapat terutama memutar-mutar di pengontrol 32kb.  Font besar diperlukan, misalnya, untuk menampilkan waktu. <br><br><div class="spoiler">  <b class="spoiler_title">Kode Contoh Huruf</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #include &lt;gfxfont.h&gt; #include &lt;fonts/FreeMono12pt7b.h&gt; #include &lt;fonts/FreeMono18pt7b.h&gt; ... #include &lt;fonts/FreeSerifItalic24pt7b.h&gt; #include &lt;fonts/FreeSerifItalic9pt7b.h&gt; #include &lt;fonts/TomThumb.h&gt; struct font_and_name { const char * PROGMEM name; GFXfont * font; }; #define FONT(name) {#name, &amp;name} const font_and_name fonts[] = { // FONT(FreeMono12pt7b), FONT(FreeMono18pt7b), /* FONT(FreeMono24pt7b), FONT(FreeMono9pt7b), FONT(FreeMonoBold12pt7b), ... FONT(FreeSerifItalic9pt7b), FONT(TomThumb)*/ }; const unsigned int fonts_count = sizeof(fonts) / sizeof(font_and_name); unsigned int current_font = 0; extern Adafruit_SSD1306 display; void RunFontTest() { display.clearDisplay(); display.setCursor(0,30); display.setFont(fonts[current_font].font); display.print("12:34:56"); display.setCursor(0,6); display.setFont(&amp;TomThumb); display.print(fonts[current_font].name); display.display(); } void SwitchToNextFont() { current_font = ++current_font % fonts_count; }</span></span></span></span></code> </pre> <br></div></div><br>  Font lengkap dengan pustaka sangat canggung.  Font monospace ternyata sangat lebar - garis "12:34:56" tidak cocok, Serif - semua angka memiliki bobot yang berbeda.  Kecuali font 5x7 standar di perpustakaan terlihat dapat dimakan. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b7a/67f/676/b7a67f676d061bdb4920985b0c46692a.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9de/e19/69f/9dee1969f16ad50138756b9dab906d4d.jpg" alt="gambar"><br><br>  Ternyata font-font ini dikonversi dari beberapa font open source ttf yang sama sekali tidak dioptimalkan untuk resolusi kecil. <br><br>  Saya harus menggambar font saya.  Lebih tepatnya, pertama, gali masing-masing simbol dari yang sudah jadi.  Simbol ':' dalam tabel ASCII sangat berguna tepat setelah angka dan dapat dibeli dalam satu blok.  Anda juga dapat membuat font bukan untuk semua karakter, tetapi hanya untuk rentang, misalnya, dari 0x30 ('0') hingga 0x3a (':').  T.O.  dari FreeSans18pt7b ternyata membuat font yang sangat ringkas hanya untuk karakter yang diperlukan.  Benar, saya harus sedikit menyesuaikan lebar agar teks pas dengan lebar layar. <br><br><div class="spoiler">  <b class="spoiler_title">Sub-Huruf FreeSans18pt7b</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// This font consists only of digits and ':' to display current time. // The font is very based on FreeSans18pt7b.h //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> 25 pixel height is too much for displaying time. Create another 22px font const uint8_t TimeFontBitmaps[] PROGMEM = { /* 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0x20, 0x3F, 0xFC, 0xE3, 0xF1, 0xF8, 0xFC, 0x7E, 0x3F, 0x1F, 0x8E, 0x82, 0x41, 0x00, 0x01, 0xC3, 0x80, ... 0x03, 0x00, 0xC0, 0x60, 0x18, 0x06, 0x03, 0x00, 0xC0, 0x30, 0x18, 0x06, 0x01, 0x80, 0xC0, 0x30, 0x00, */0x07, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x3C, 0x78, 0x1E, 0x70, 0x0E, 0x70, 0x0E, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0E, 0x70, 0x0E, 0x78, 0x1E, 0x3C, 0x3C, 0x1F, 0xF8, 0x1F, 0xF0, 0x07, 0xE0, 0x03, 0x03, 0x07, 0x0F, 0x3F, 0xFF, 0xFF, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3E, 0x70, 0x0F, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0xF8, 0x03, 0xF0, 0x07, 0xC0, 0x1F, 0x00, 0x3C, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF0, 0x07, 0xFE, 0x07, 0xFF, 0x87, 0x83, 0xC3, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x1F, 0xE0, 0x00, 0x78, 0x00, 0x1E, 0x00, 0x07, 0x00, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFE, 0x00, 0x77, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x78, 0x00, 0xF8, 0x00, 0xF8, 0x01, 0xF8, 0x03, 0xB8, 0x03, 0x38, 0x07, 0x38, 0x0E, 0x38, 0x1C, 0x38, 0x18, 0x38, 0x38, 0x38, 0x70, 0x38, 0x60, 0x38, 0xE0, 0x38, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x1F, 0xFF, 0x0F, 0xFF, 0x8F, 0xFF, 0xC7, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x39, 0xF0, 0x3F, 0xFE, 0x1F, 0xFF, 0x8F, 0x83, 0xE7, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xFC, 0x00, 0xEF, 0x00, 0x73, 0xC0, 0xF0, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xE0, 0x00, 0x03, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x1E, 0x38, 0x0E, 0x70, 0x0E, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xE3, 0xE0, 0xEF, 0xF8, 0xFF, 0xFC, 0xFC, 0x3E, 0xF0, 0x0E, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0x60, 0x07, 0x70, 0x0F, 0x70, 0x0E, 0x3C, 0x3E, 0x3F, 0xFC, 0x1F, 0xF8, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x18, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xC0, 0x01, 0xC0, 0x01, 0x80, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x07, 0xF0, 0x0F, 0xFE, 0x0F, 0xFF, 0x87, 0x83, 0xC7, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x78, 0x0F, 0x1E, 0x0F, 0x07, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xE3, 0xE0, 0xF9, 0xC0, 0x1D, 0xC0, 0x0F, 0xE0, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFC, 0x00, 0xF7, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3C, 0x70, 0x0E, 0xF0, 0x0E, 0xE0, 0x06, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0F, 0x78, 0x3F, 0x3F, 0xFF, 0x1F, 0xF7, 0x07, 0xC7, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0E, 0x70, 0x0E, 0x70, 0x1C, 0x78, 0x3C, 0x3F, 0xF8, 0x1F, 0xF0, 0x07, 0xC0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x80 /*, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xB6, 0xD6, 0x00, 0x00, 0x80, 0x03, 0xC0, 0x07, 0xE0, 0x0F, 0xC0, 0x3F, 0x80, 0x7E, 0x00, 0xFC, 0x01, 0xF0, 0x00, 0xE0, 0x00, ... 0x38, 0x38, 0xF8, 0xF0, 0xE0, 0x38, 0x00, 0xFC, 0x03, 0xFC, 0x1F, 0x3E, 0x3C, 0x1F, 0xE0, 0x1F, 0x80, 0x1E, 0x00 */ }; //TODO Recalc offset numbers const GFXglyph TimeFontGlyphs[] PROGMEM = { { 449-449, 16, 25, 19, 2, -24 }, // 0x30 '0' { 499-449, 8, 25, 19, 4, -24 }, // 0x31 '1' { 524-449, 16, 25, 19, 2, -24 }, // 0x32 '2' { 574-449, 17, 25, 19, 1, -24 }, // 0x33 '3' { 628-449, 16, 25, 19, 1, -24 }, // 0x34 '4' { 678-449, 17, 25, 19, 1, -24 }, // 0x35 '5' { 732-449, 16, 25, 19, 2, -24 }, // 0x36 '6' { 782-449, 16, 25, 19, 2, -24 }, // 0x37 '7' { 832-449, 17, 25, 19, 1, -24 }, // 0x38 '8' { 886-449, 16, 25, 19, 1, -24 }, // 0x39 '9' { 936-449, 3, 19, 7, 2, -20 }, // 0x3A ':' }; const GFXfont TimeFont PROGMEM = { (uint8_t *)TimeFontBitmaps, (GFXglyph *)TimeFontGlyphs, 0x30, 0x3A, 20 };</span></span></code> </pre> </div></div><br>  Ternyata font 18pt sebenarnya tingginya 25 piksel.  Karena itu, ia sedikit cocok dengan prasasti lain <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/543/aee/2e5/543aee2e5c6515307a4c969a3bfff374.jpg" alt="gambar"><br><br>  Tampilan terbalik, omong-omong, membantu untuk memahami di mana batas-batas area gambar sebenarnya dan bagaimana garis berada relatif terhadap batas ini - layar memiliki bingkai yang sangat besar. <br><br>  Di-google untuk waktu yang lama font yang sudah jadi, tetapi mereka tidak cocok dalam ukuran, atau dalam bentuk, atau konten.  Misalnya, di Internet, poros font 8x12 (dump generator karakter kartu VGA).  Namun pada kenyataannya, font-font ini berukuran 6x8, yaitu  banyak ruang berjalan - dalam hal resolusi dan ukuran kecil seperti milik saya itu sangat penting. <br><br>  Saya harus menggambar font sendiri, karena format font perpustakaan Adafruit sangat sederhana.  Saya menyiapkan gambar di Paint.net - Saya hanya menggambar huruf-huruf dalam font yang tepat, kemudian sedikit mengoreksi dengan pensil.  Saya menyimpan gambar sebagai png, dan kemudian mengirimnya dengan cepat ke skrip python yang tertulis di lutut saya.  Script ini menghasilkan kode setengah jadi yang sudah mengarahkan aturan di IDE tepat di kode hex. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/618/78f/f7e/61878ff7eff21be033fdbc56183a4f5e.png" alt="gambar"><br><br>  Sebagai contoh, ini adalah bagaimana proses pembuatan font monospaced 8x12 dengan huruf kecil dan spasi tampak.  Setiap karakter pada akhirnya ternyata sekitar 7x10, dan secara default menempati 10 byte.  Mungkin saja untuk mengemas setiap karakter dalam 8-9 byte (perpustakaan memungkinkan ini), tapi saya tidak repot-repot.  Selain itu, dalam formulir ini, Anda dapat mengedit masing-masing piksel langsung dalam kode. <br><br><div class="spoiler">  <b class="spoiler_title">Font 8x12</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A simple 8x12 font (slightly modifier Courier New) const uint8_t Monospace8x12Bitmaps[] PROGMEM = { 0x1e, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1e, //0 0x18, 0x68, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, //1 0x3e, 0x41, 0x41, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x41, 0x7f, //2 0x3e, 0x41, 0x01, 0x01, 0x0e, 0x02, 0x01, 0x01, 0x41, 0x3e, //3 0x02, 0x06, 0x0a, 0x12, 0x12, 0x22, 0x3f, 0x02, 0x02, 0x0f, //4 0x7f, 0x41, 0x40, 0x40, 0x7e, 0x01, 0x01, 0x01, 0x41, 0x3e, //5 0x1e, 0x21, 0x40, 0x40, 0x5e, 0x61, 0x41, 0x41, 0x41, 0x3e, //6 0x7f, 0x41, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, //7 0x1e, 0x21, 0x21, 0x21, 0x1e, 0x21, 0x21, 0x21, 0x21, 0x1e, //8 0x1e, 0x21, 0x21, 0x21, 0x23, 0x1d, 0x01, 0x01, 0x22, 0x1c, //9 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, //: }; const GFXglyph Monospace8x12Glyphs[] PROGMEM = { { 0, 8, 10, 8, 0, -11 }, // 0x30 '0' { 10, 8, 10, 8, 0, -11 }, // 0x31 '1' { 20, 8, 10, 8, 0, -11 }, // 0x32 '2' { 30, 8, 10, 8, 0, -11 }, // 0x33 '3' { 40, 8, 10, 8, 0, -11 }, // 0x34 '4' { 50, 8, 10, 8, 0, -11 }, // 0x35 '5' { 60, 8, 10, 8, 0, -11 }, // 0x36 '6' { 70, 8, 10, 8, 0, -11 }, // 0x37 '7' { 80, 8, 10, 8, 0, -11 }, // 0x38 '8' { 90, 8, 10, 8, 0, -11 }, // 0x39 '9' { 100, 8, 10, 8, 0, -11 }, // 0x3A ':' }; const GFXfont Monospace8x12Font PROGMEM = { (uint8_t *)Monospace8x12Bitmaps, (GFXglyph *)Monospace8x12Glyphs, 0x30, 0x3A, 12 };</span></span></code> </pre><br></div></div><br><h1>  Bingkai </h1><br>  Perangkat asli menyediakan antarmuka yang sangat sederhana dan nyaman.  Informasi dikelompokkan ke dalam kategori yang ditampilkan dari masing-masing halaman (layar).  Dengan menggunakan tombol, Anda dapat menelusuri halaman, dan menggunakan tombol kedua untuk memilih item saat ini atau melakukan tindakan yang ditunjukkan dalam tanda tangan di bawah tombol.  Menurut saya pendekatan ini sangat nyaman dan tidak perlu mengubah apa pun. <br><br>  Saya suka keindahan OOP, karena saya segera menyilaukan antarmuka kecil, setiap halaman mengimplementasikan antarmuka sesuai kebutuhan.  Halaman tahu cara menggambar sendiri dan menerapkan reaksi terhadap tombol. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Screen(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Screen() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOkButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOkButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span></span>; };</code> </pre> <br>  Tombol dapat melakukan berbagai tindakan tergantung pada layar saat ini.  Oleh karena itu, di bagian atas layar dengan ketinggian 8 piksel, saya ditugaskan ke label untuk tombol.  Teks untuk tanda tangan tergantung pada layar saat ini dan dikembalikan oleh fungsi virtual getSelButtonText () dan getOkButtonText ().  Juga dalam item layanan tajuk seperti kekuatan sinyal GPS dan pengisian daya baterai masih akan ditampilkan.  Layar Â¾ yang tersisa tersedia untuk informasi yang berguna. <br><br>  Seperti yang saya katakan, layar bisa dibalik, yang berarti bahwa di suatu tempat harus ada daftar objek untuk halaman yang berbeda.  Apa yang lebih dari satu - layar dapat disarangkan, seperti submenu.  Saya bahkan memulai kelas ScreenManager, yang seharusnya mengelola daftar ini, tetapi kemudian saya menemukan solusinya lebih mudah. <br><br>  Jadi setiap layar hanya memiliki pointer ke yang berikutnya.  Jika layar memungkinkan Anda untuk masuk ke submenu, maka ia menambahkan satu penunjuk lagi ke layar submenu ini <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; â€¦ }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentScreen</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Screen { Screen * childScreen; â€¦ };</code> </pre> <br>  Secara default, penangan tombol hanya memanggil fungsi ganti layar, melewatinya dengan pointer yang diinginkan.  Fungsi ini ternyata sepele - hanya mengubah pointer ke layar saat ini.  Untuk memastikan layar bersarang, saya membuat tumpukan kecil.  Jadi seluruh manajer layar cocok dalam 25 baris dan 4 fungsi kecil. <br><br><pre> <code class="cpp hljs">Screen * screenStack[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> screenIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenStack[screenIdx] = screen; } <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> screenStack[screenIdx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enterChildScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenIdx++; <span class="hljs-comment"><span class="hljs-comment">//TODO limit this screenStack[screenIdx] = screen; } void backToParentScreen() { if(screenIdx) screenIdx--; }</span></span></code> </pre> <br>  Benar, kode untuk mengisi struktur ini tidak terlihat sangat bagus, tetapi sejauh ini belum ditemukan dengan lebih baik. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCurrentTimeScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TimeZoneScreen * tzScreen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>)); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// TODO Add real timezones here CurrentTimeScreen * screen = new CurrentTimeScreen(); screen-&gt;addChildScreen(tzScreen); return screen; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pikiran itu</b> <div class="spoiler_text">  Penataan, tentu saja, ternyata indah, tetapi saya khawatir itu memakan banyak memori.  Anda harus melawan diri sendiri dan zafigachit meja statis besar dengan pointer. <br></div></div><br>  Silakan.  Dalam implementasi antarmuka saya, saya ingin melakukan sesuatu seperti kotak pesan, pesan singkat yang akan muncul selama satu atau dua detik, dan kemudian menghilang.  Misalnya, jika Anda menekan tombol POI (Tempat Menarik) di layar dengan koordinat saat ini, maka selain menulis titik ke trek, alangkah baiknya untuk menunjukkan kepada pengguna pesan "Waypoint Disimpan" (di perangkat asli, ikon tambahan hanya ditampilkan sebentar).  Atau, ketika baterai hampir habis, "menghibur" pengguna dengan pesan. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/aa5/dec/17b/aa5dec17b1b4b298b764fce33b8441db.jpg" alt="gambar"><br><br>  Karena data dari GPS akan datang terus-menerus, tidak ada pembicaraan tentang fungsi pemblokiran.  Oleh karena itu, saya harus menciptakan mesin keadaan sederhana (state machine), yang pada fungsi loop () akan memilih apa yang harus dilakukan - perlihatkan layar saat ini atau kotak pesan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { IDLE_DISPLAY_OFF, IDLE, MESSAGE_BOX, BUTTON_PRESSED, };</code> </pre> <br>  Juga nyaman untuk menangani penekanan tombol menggunakan mesin negara.  Mungkin itu akan benar melalui interupsi, tetapi ternyata juga baik.  Ini bekerja seperti ini: jika tombol ditekan dalam status IDLE, ingat waktu itu ditekan dan pergi ke status BUTTON_PRESSED.  Dalam keadaan ini, kami menunggu hingga pengguna melepaskan tombol.  Di sini kita bisa menghitung durasi ketika tombol ditekan.  Respons singkat (&lt;30 ms) diabaikan begitu saja - kemungkinan besar ini adalah pantulan kontak.  Perjalanan panjang sudah bisa diartikan sebagai tombol tekan. <br><br>  Saya berencana untuk menggunakan kedua penekanan tombol untuk tindakan biasa, dan panjang (&gt; 1c) untuk fungsi khusus.  Misalnya, tekan sebentar memulai / menjeda odometer, tekan lama akan mengatur ulang penghitung ke 0. <br><br>  Mungkin negara bagian lain akan ditambahkan.  Jadi, misalnya, dalam logger asli setelah beralih ke halaman berikutnya, nilai pada layar sering berubah, dan lebih jarang setelah beberapa detik - sekali per detik.  Ini bisa dilakukan dengan menambahkan status lain. <br><br>  Ketika bingkai sudah siap, saya sudah mulai menghubungkan GPS.  Namun di sini ada nuansa yang membuat saya menunda tugas ini. <br><br><h1>  Pengoptimalan firmware </h1><br>  Sebelum melanjutkan, saya perlu terganggu oleh beberapa detail teknis.  Faktanya adalah bahwa di sekitar tempat ini saya mulai menambah konsumsi memori.  Ternyata garis yang dinyatakan secara sembarangan tanpa pengubah PROGMEM pada awal firmware disalin ke RAM dan memakan ruang di sana sepanjang waktu berjalan. <br><br><div class="spoiler">  <b class="spoiler_title">Berbagai arsitektur</b> <div class="spoiler_text">  Singkatnya.  Pada komputer besar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur Von Neumann digunakan di</a> mana kode dan data berada di ruang alamat yang sama.  Yaitu  data dari RAM dan ROM akan dibaca dengan cara yang sama. <br><br>  Mikrokontroler biasanya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur Harvard</a> , tempat kode dan data dipisahkan.  T.O.  Anda harus menggunakan berbagai fungsi untuk membaca memori dan flash.  Dari sudut pandang bahasa C / C ++, pointer terlihat sama, tetapi ketika menulis sebuah program, kita perlu tahu persis di mana tepatnya memori yang menunjuk pointer kita dan memanggil fungsi yang sesuai. </div></div><br>  Untungnya, sebagian pengembang perpustakaan sudah menangani ini.  Kelas utama pustaka tampilan - Adafruit_SSD1306 diwarisi dari kelas Print dari pustaka standar Arduino. <br><br>  Ini memberi kami serangkaian modifikasi modifikasi metode cetak - untuk mencetak string, karakter tunggal, angka, dan lainnya.  Jadi ia memiliki 2 fungsi terpisah untuk jalur pencetakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __FlashStringHelper *); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[]);</code> </pre><br>  Yang pertama tahu bahwa Anda perlu mencetak garis dari flash drive dan memuatnya karakter per karakter.  Yang kedua mencetak karakter dari RAM.  Faktanya, kedua fungsi ini mengambil pointer ke string, hanya dari ruang alamat yang berbeda. <br><br>  Untuk waktu yang lama saya mencari kode arduino untuk __FlashStringHelper ini untuk mempelajari cara memanggil fungsi print () yang diinginkan.  Ternyata orang-orang melakukan trik: mereka hanya menyatakan jenis ini menggunakan deklarasi maju (tanpa menyatakan jenis itu sendiri) dan menulis makro yang melemparkan pointer ke garis dalam sekejap ke tipe __FlashStringHelper.  Hanya untuk kompiler untuk memilih fungsi kelebihan beban yang diperlukan <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashStringHelper</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F(string_literal) (reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(PSTR(string_literal)))</span></span></span></span></code> </pre><br>  Ini memungkinkan Anda untuk menulis seperti ini: <br><br><pre> <code class="cpp hljs">display.print(F(â€œString in flash memoryâ€));</code> </pre> <br><br>  Tetapi tidak memungkinkan menulis seperti <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> text[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"String in flash memory"</span></span>; display.print(F(text));</code> </pre> <br>  Dan, tampaknya, perpustakaan tidak menyediakan apa pun yang bisa dilakukan dengan cara itu.  Saya tahu bahwa tidak baik menggunakan potongan perpustakaan pribadi dalam kode saya, tetapi apa yang harus saya lakukan?  Saya menggambar makro saya, yang melakukan apa yang saya butuhkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USE_PGM_STRING(x) reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(x)</span></span></span></span></code> </pre><br>  Jadi fungsi menggambar topi mulai terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Screen::drawHeader() { display.setFont(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); display.setCursor(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getSelButtonText())); display.setCursor(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getOkButtonText())); }</code> </pre> <br>  Yah, karena saya masuk ke bagian rendah dari firmware, saya memutuskan untuk mempelajari lebih dalam bagaimana semuanya bekerja di dalam. <br><br>  Secara umum, orang-orang yang datang dengan Arduino perlu mendirikan sebuah monumen.  Mereka membuat platform yang sederhana dan nyaman untuk pembuatan prototipe dan kerajinan tangan.  Sejumlah besar orang dengan pengetahuan minimal tentang elektronik dan pemrograman dapat memasuki dunia Arduino.  Tetapi semua ini mulus dan indah saat melakukan sampah seperti lampu tanda dengan LED atau membaca termometer.  Begitu Anda mengayunkan sesuatu yang serius, Anda harus segera memahami lebih dalam dari yang Anda inginkan sejak awal. <br><br>  Jadi, setelah setiap perpustakaan ditambahkan atau bahkan kelas, saya mencatat seberapa cepat konsumsi memori meningkat.  Pada titik ini, saya sibuk dengan lebih dari 14 KB flash 32 KB dan 1300 byte RAM (dari 2k).  Setiap gerakan yang ceroboh menambahkan 10 persen ke gerakan yang sudah digunakan.  Tapi saya masih belum benar-benar menghubungkan perpustakaan GPS dan SD / FAT32, dan kucing itu sendiri menangis.  Saya harus mengambil <s>checker</s> disassembler dan mempelajari apa yang dilakukan kompiler. <br><br>  Diam-diam saya berharap bahwa linker membuang fungsi yang tidak digunakan.  Tetapi ternyata sebagian dari mereka menyisipkan linker hampir seluruhnya.  Dalam firmware, saya menemukan fungsi menggambar garis dan beberapa lainnya dari perpustakaan bekerja dengan layar, meskipun dalam kode saya jelas tidak memanggil mereka pada waktu itu.  Secara implisit, mereka juga tidak boleh disebut - mengapa saya memerlukan fungsi menggambar garis jika saya hanya menggambar huruf dari bitmap?  Lebih dari 5.2kb tiba-tiba (dan itu tidak termasuk font). <br><br>  Selain pustaka kontrol tampilan, saya juga menemukan: <br><br><ul><li>  2,6 kb - di SoftwareSerial (saya menariknya ke proyek di beberapa titik) </li><li>  1,6 kb - I2C </li><li>  1.3 kb - HardwareSerial </li><li>  2 kb - TinyGPS </li><li>  2,5 kb pada arduino yang sebenarnya (inisialisasi, pin, semua jenis tabel, timer utama untuk fungsi millis () dan delay ()), </li></ul><br>  Jumlahnya sangat indikatif, seperti  pengoptimal serius mencampur kode.  Beberapa fungsi dapat dimulai di satu tempat, dan kemudian yang lain dari perpustakaan lain, yang dipanggil dari yang pertama, dapat segera mengikutinya.  Selain itu, cabang-cabang yang terpisah dari fungsi-fungsi ini dapat ditemukan di ujung flash lainnya. <br><br>  Juga dalam kode yang saya temukan: <br><br><ul><li>  Kontrol layar oleh SPI (meskipun saya sudah terhubung melalui I2C) </li><li>  Metode kelas dasar itu sendiri tidak disebut, karena  didefinisikan ulang dalam ahli waris </li><li>  Destructors yang tidak pernah dipanggil oleh desain </li><li>  Fungsi menggambar (dan tidak semua - bagian dari fungsi yang masih dilemparkan oleh linker) </li><li>  malloc / gratis saat dalam kode saya semua objek pada dasarnya statis </li></ul><br>  Tetapi tidak hanya konsumsi memori flash, tetapi juga SRAM tumbuh dengan pesat: <br><br><ul><li>  130 byte - I2C </li><li>  100 byte - SoftwareSerial </li><li>  157 byte - Serial </li><li>  558 byte - Tampilan (yang 512 adalah frame buffer) </li></ul><br>  Yang tidak kalah menghibur adalah bagian. Data.  Ada sekitar 700 byte dan hal ini dimuat dari flash ke RAM di awal.  Ternyata ada tempat yang dicadangkan untuk variabel dalam memori, dan bersama dengan nilai inisialisasi.  Disini tinggal variabel-variabel dan konstanta yang Anda lupa deklarasikan sebagai const PROGMEM. <br><br>  Di antara ini adalah array yang lumayan dengan "layar splash" layar - nilai-nilai awal dari frame buffer.  Secara teoritis, jika Anda membuat layar display () segera setelah start, Anda dapat melihat tulisan bunga dan Prasasti, tetapi dalam kasus saya tidak ada gunanya menghabiskan memori flash untuk ini. <br><br>  Bagian. Data juga berisi vtables.  Mereka disalin ke memori dari flash drive, rupanya karena alasan efisiensi dalam runtime.  Tetapi Anda harus mengorbankan sepotong RAM yang agak besar - lebih dari selusin kelas lebih dari 150 byte.  Selain itu, tampaknya tidak ada kunci kompiler yang, mengorbankan kinerja, akan meninggalkan tabel virtual dalam memori flash. <br><br>  Apa yang harus dilakukan?  Saya belum tahu.  Itu akan tergantung pada bagaimana konsumsi akan terus tumbuh.  Untuk menemukan kusen yang baik perlu diperbaiki tanpa ampun.  Kemungkinan besar saya harus menarik semua perpustakaan ke dalam proyek saya secara eksplisit dan kemudian membahasnya secara menyeluruh.  Dan Anda mungkin juga harus menulis ulang beberapa bagian secara berbeda untuk mengoptimalkan memori.  Atau beralih ke perangkat keras yang lebih kuat.  Bagaimanapun, sekarang saya tahu tentang masalah dan ada strategi tentang cara memperbaikinya. <br><br>  <b>PEMBARUAN:</b> <br>  Sedikit kemajuan dalam efisiensi sumber daya.  Saya melakukan pembaruan untuk bagian ini, karena  selanjutnya saya ingin fokus pada hal-hal yang sama sekali berbeda. <br><br>  Dalam komentar ada beberapa kebingungan tentang penggunaan C ++.  Secara khusus, mengapa dia begitu buruk dan menyimpan vtable dalam RAM yang berharga?  Secara umum, fungsi virtual, konstruktor, dan destruktor adalah overhead.  Mengapa  Mari kita cari tahu! <br><br>  Berikut ini adalah statistik tentang memori pada beberapa tahap proyek <br>  Ukuran program: 15 458 byte (digunakan 50% dari maksimum 30 720 byte) (2,45 detik) <br>  Penggunaan Memori Minimum: 1258 byte (61% dari maksimum 2048 byte) <br><br>  Eksperimen No. 1 - tulis ulang ke C. <br><br>  Saya melemparkan kelas, menulis ulang semuanya di atas meja dengan pointer ke fungsi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena layar sebenarnya selalu memiliki struktur yang sama, semua anggota data telah menjadi variabel global biasa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistik setelah refactoring </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran program: 14 568 byte (digunakan 47% dari maksimum 30 720 byte) (2,35 detik) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan Memori Minimum: 1176 byte (57% dari maksimum 2048 byte) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total. Memenangkan 900 byte flash dan 80 byte RAM. Apa yang tepatnya meninggalkan flash tidak menggali. 80 byte RAM hanya ukuran vtable. Semua data lain (anggota kelas) tetap ada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harus mengatakan bahwa saya tidak merusak segalanya - saya hanya ingin melihat gambaran besarnya tanpa menghabiskan banyak waktu untuk itu. Setelah refactoring, saya "kehilangan" tangkapan layar bersarang. Dengan mereka, konsumsi akan sedikit lebih banyak.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi yang paling penting dalam percobaan ini adalah kualitas kode telah menurun secara signifikan. Kode satu fungsional telah tersebar di beberapa file. Untuk beberapa bagian data, "satu pemilik" tidak ada lagi, beberapa modul mulai masuk ke memori orang lain. Kode telah menjadi luas dan jelek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksperimen # 2 - menekan byte dari C ++ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memutar kembali eksperimen saya, saya memutuskan untuk meninggalkan semuanya sebagai kelas. Hanya kali ini, layar dilakukan pada objek yang didistribusikan secara statis. Struktur halaman di layar saya sudah diperbaiki. Anda dapat menentukannya pada tahap kompilasi tanpa menggunakan baru / hapus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran program: 15 408 byte (digunakan 50% dari maksimum 30 720 byte) (2,60 detik) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan Memori Minimum: 1273 byte (62% dari maksimum 2048 byte)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsumsi RAM sedikit meningkat. </font><font style="vertical-align: inherit;">Tapi ini, pada kenyataannya, menjadi lebih baik. </font><font style="vertical-align: inherit;">Peningkatan konsumsi RAM dijelaskan oleh perpindahan objek dari heap ke area memori yang didistribusikan secara statis.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya, objek dibuat sebelumnya, tetapi ini tidak masuk ke statistik. </font><font style="vertical-align: inherit;">Dan sekarang benda-benda ini diperhitungkan secara eksplisit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi untuk secara signifikan mengurangi konsumsi flash tidak bekerja. </font><font style="vertical-align: inherit;">Kode masih berisi konstruktor sendiri, yang masih dipanggil saat startup.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler tidak dapat "mengeksekusi" mereka terlebih dahulu dan meletakkan semua nilai di area yang dialokasikan sebelumnya. Dan masih ada destruktor dalam kode, meskipun jelas bagi landak bahwa objek tidak akan pernah dihapus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam upaya untuk menyelamatkan setidaknya sedikit, saya menghapus semua destruktor dalam hierarki, dan khususnya destruktor virtual di kelas dasar. Idenya adalah untuk membebaskan beberapa byte di setiap vtable. Dan kemudian kejutan menunggu saya: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran program: 14 704 byte (digunakan 48% dari maksimum 30 720 byte) (2,94 detik) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan Memori Minimum: 1211 byte (59% dari maksimum 2048 byte)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata vtable tidak berjalan dengan satu pointer, tetapi sudah oleh 2. Selain itu, keduanya berkaitan dengan destruktor. </font><font style="vertical-align: inherit;">Hanya satu destruktor kosong (terlihat untuk objek pada stack), dan yang lainnya dengan panggilan gratis, terlihat untuk objek pada heap (-12 byte RAM). </font><font style="vertical-align: inherit;">Juga, variabel yang terkait dengan pinggul (8 byte) dan label objek yang tidak pernah dibuat (Layar, ParentScreen - 40 byte) hilang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsumsi flash telah menurun secara signifikan - sebesar 700 byte. </font><font style="vertical-align: inherit;">Tidak hanya para destruktor itu sendiri, tetapi juga implementasi malloc / free / new / delete hilang. </font><font style="vertical-align: inherit;">700 byte untuk destruktor virtual kosong! </font><font style="vertical-align: inherit;">700 byte, Carl! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tidak akan bolak-balik, di sini semua angka di satu tempat</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++ </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flash </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15 458 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.568 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.704 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RAM </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1258 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1176 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1211 </font></font></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya: Konsumsi dalam C ++ ternyata hampir sama dengan di C. Tetapi pada saat yang sama, enkapsulasi, pewarisan dan polimorfisme adalah kekuatan. </font><font style="vertical-align: inherit;">Saya siap membayar lebih untuk ini dengan beberapa peningkatan konsumsi. </font><font style="vertical-align: inherit;">Mungkin saya tidak bisa menulis dengan indah di C, tapi mengapa, jika saya bisa menulis dengan indah di C ++?</font></font><br><br><h1>  Kata penutup </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, saya ingin menulis satu artikel di akhir proyek. </font><font style="vertical-align: inherit;">Tetapi karena uang kertas menumpuk dengan cepat saat pekerjaan berjalan, artikel itu mengancam menjadi sangat besar. </font><font style="vertical-align: inherit;">Jadi saya memutuskan untuk memecahnya menjadi beberapa bagian. </font><font style="vertical-align: inherit;">Pada bagian ini, saya berbicara tentang tahap persiapan: memahami apa yang sebenarnya saya inginkan, memilih platform, menerapkan kerangka kerja aplikasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian selanjutnya, saya berencana untuk beralih ke implementasi fungsi dasar - bekerja dengan GPS. </font><font style="vertical-align: inherit;">Saya sudah menemukan beberapa garu yang menarik yang ingin saya ceritakan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama lebih dari 10 tahun saya belum memprogram secara serius untuk mikrokontroler. </font><font style="vertical-align: inherit;">Ternyata saya agak dimanjakan oleh banyaknya sumber daya komputer besar dan sempit dalam realitas ATMega32. </font><font style="vertical-align: inherit;">Oleh karena itu, saya harus memikirkan berbagai opsi cadangan, seperti memangkas fungsionalitas perpustakaan atau mendesain ulang aplikasi atas nama penggunaan memori yang efisien. </font><font style="vertical-align: inherit;">Saya juga tidak mengecualikan kemungkinan beralih ke pengontrol yang lebih kuat - ATMega64 atau sesuatu dari jalur STM32. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berdasarkan gaya, artikel itu ternyata seperti majalah konstruksi. </font><font style="vertical-align: inherit;">Dan saya akan dengan senang hati memberikan komentar yang membangun - belum terlambat untuk mengubah apa pun. </font><font style="vertical-align: inherit;">Mereka yang ingin dapat bergabung dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">di github</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhir dari bagian pertama. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian kedua</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id401899/">https://habr.com/ru/post/id401899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id401889/index.html">Amplifier legendaris tahun 80-an: 90-an paradoks Lamm, monster Johnson, pembunuh integral "lampu hangat"</a></li>
<li><a href="../id401891/index.html">Pemindaian 3D dan pencetakan 3D dalam aksi (didedikasikan untuk pengendara sepeda motor)</a></li>
<li><a href="../id401893/index.html">Dari mana air dan oksigen berasal dari ISS?</a></li>
<li><a href="../id401895/index.html">Penyerang menjadi lebih inventif dalam membuat skimmers</a></li>
<li><a href="../id401897/index.html">Paket Berita untuk SLS dan Orion</a></li>
<li><a href="../id401901/index.html">Jendela cahaya bulan ke Semesta</a></li>
<li><a href="../id401903/index.html">Bagaimana Suara Mempengaruhi Tidur dan Produktivitas Kita</a></li>
<li><a href="../id401905/index.html">Apple Power Mac G4 Cube dan orang-orang sezamannya dalam ulasan foto kecil</a></li>
<li><a href="../id401907/index.html">Mobil robot harus belajar memahami orang.</a></li>
<li><a href="../id401909/index.html">Sistem keamanan buatan rumah yang didasarkan pada produk untuk rumah pintar dari Nootekhnika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>