<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👨 🤟🏽 Kotlin: creuser plus profondément. Constructeurs et initialiseurs 💊 💃🏾 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mai 2017, Google a annoncé que Kotlin était devenu le langage de développement officiel pour Android. Quelqu'un a ensuite entendu le nom de cette l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: creuser plus profondément. Constructeurs et initialiseurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  En mai 2017, Google a annoncé que Kotlin était devenu le langage de développement officiel pour Android.  Quelqu'un a ensuite entendu le nom de cette langue pour la première fois, quelqu'un a écrit dessus pendant longtemps, mais à partir de ce moment, il est devenu clair que toute personne proche du développement Android est maintenant obligée de la connaître.  Cela a été suivi par des réponses enthousiastes "Enfin!" Et une terrible indignation "Pourquoi avons-nous besoin d'une nouvelle langue?"  Qu'est-ce qui n'a pas plu à Java?  etc.  etc. <br><br>  Depuis, assez de temps s'est écoulé, et bien que le débat sur la bonne ou la mauvaise Kotlin ne soit toujours pas résolu, de plus en plus de code pour Android y est écrit.  Et même des développeurs assez conservateurs y passent également.  De plus, sur le réseau, vous pouvez tomber sur des informations selon lesquelles la vitesse de développement après la maîtrise de ce langage est augmentée de 30% par rapport à Java. <br><br>  Aujourd'hui, Kotlin a déjà réussi à se remettre de plusieurs maladies infantiles, envahies par de nombreuses questions et réponses sur Stack Overflow.  À l'œil nu, ses avantages et ses faiblesses sont devenus visibles. <br><br>  Et sur cette vague, l'idée m'est venue d'analyser en détail les éléments individuels d'un langage jeune mais populaire.  Faites attention aux points complexes et comparez-les avec Java pour plus de clarté et une meilleure compréhension.  Pour comprendre la question un peu plus profondément que cela peut être fait en lisant la documentation.  Si cet article suscite l'intérêt, il posera très probablement les bases de toute une série d'articles.  En attendant, je vais commencer par des choses assez basiques, qui cachent cependant pas mal d'embûches.  Parlons des constructeurs et des initialiseurs dans Kotlin. <a name="habracut"></a><br><br>  Comme en Java, dans Kotlin, la création de nouveaux objets - entités d'un certain type - se produit en appelant le constructeur de classe.  Vous pouvez également passer des arguments au constructeur, et il peut y avoir plusieurs constructeurs.  Si vous regardez ce processus de l'extérieur, la seule différence avec Java est le manque de nouveau mot-clé lors de l'appel du constructeur.  Maintenant, jetez un œil plus profond et voyez ce qui se passe à l'intérieur de la classe. <br><br>  Une classe peut avoir des constructeurs primaires et secondaires. <br>  Un constructeur est déclaré à l'aide du mot-clé constructeur.  Si le constructeur principal n'a pas de modificateurs d'accès et d'annotations, le mot-clé peut être omis. <br>  Une classe peut ne pas avoir de constructeurs déclarés explicitement.  Dans ce cas, après la déclaration de la classe il n'y a pas de constructions, on passe immédiatement au corps de la classe.  Si nous établissons une analogie avec Java, cela équivaut à l'absence d'une déclaration explicite de constructeurs, à la suite de quoi le constructeur par défaut (sans paramètres) sera généré automatiquement au stade de la compilation.  Il semble comme prévu: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Cela équivaut à l'entrée suivante: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Mais si vous écrivez de cette façon, il vous sera poliment demandé de supprimer le constructeur principal sans paramètres. <br><br>  Le constructeur principal est celui qui est toujours appelé lorsqu'un objet est créé au cas où il existe.  Bien que nous en tenions compte et que nous analyserons plus en détail plus tard, lorsque nous passerons aux constructeurs secondaires.  En conséquence, nous nous souvenons que s'il n'y a pas de constructeurs du tout, alors en fait il y en a un (principal), mais nous ne le voyons pas. <br><br>  Si, par exemple, nous voulons que le constructeur principal sans paramètres n'ait pas d'accès public, alors avec la modification <code>private</code> , nous devrons le déclarer explicitement avec le mot-clé <code>constructor</code> . <br><br>  La principale caractéristique du constructeur principal est qu'il n'a pas de corps, c'est-à-dire  ne peut pas contenir de code exécutable.  Il prend simplement les paramètres en eux-mêmes et les transmet profondément dans la classe pour une utilisation future.  Au niveau de la syntaxe, cela ressemble à ceci: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Les paramètres passés de cette manière peuvent être utilisés pour diverses initialisations, mais pas plus.  Dans sa forme pure, nous ne pouvons pas utiliser ces arguments dans le code de travail de la classe.  Cependant, nous pouvons initialiser les champs de la classe ici.  Cela ressemble à ceci: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Ici, <code>param1</code> et <code>param2</code> peuvent être utilisés dans le code en tant que champs de la classe, ce qui équivaut à ce qui suit: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Eh bien, si vous comparez avec Java, cela ressemblerait à ceci (et au fait, dans cet exemple, vous pouvez évaluer dans quelle mesure Kotlin peut réduire la quantité de code): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Parlons de designers supplémentaires.  Ils rappellent plus les constructeurs ordinaires en Java: ils acceptent des paramètres et peuvent avoir un bloc exécutable.  Lors de la déclaration de constructeurs supplémentaires, le mot-clé constructeur est requis.  Comme mentionné précédemment, malgré la possibilité de créer un objet en appelant un constructeur supplémentaire, le constructeur principal (le cas échéant) doit également être appelé à l'aide du <code>this</code> .  Au niveau de la syntaxe, cela est organisé comme suit: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  C'est-à-dire  le constructeur supplémentaire est, pour ainsi dire, l'héritier du primaire. <br>  Maintenant, si nous créons un objet en appelant un constructeur supplémentaire, ce qui se passera: <br><br>  appeler un constructeur supplémentaire; <br>  appeler le constructeur principal; <br>  initialisation d'un champ de classe <code>p1</code> dans le constructeur principal; <br>  exécution de code dans le corps d'un constructeur supplémentaire. <br><br>  Ceci est similaire à une telle construction en Java: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Rappelons qu'en Java on ne peut appeler un constructeur d'un autre en utilisant le <code>this</code> qu'au début du corps du constructeur.  Chez Kotlin, ce problème était fondamentalement résolu - ils ont fait de cet appel une partie de la signature du constructeur.  Juste au cas où, je note qu'il est interdit d'appeler un constructeur (principal ou supplémentaire) directement à partir du corps du constructeur supplémentaire. <br><br>  Un constructeur supplémentaire doit toujours faire référence au constructeur principal (le cas échéant), mais peut le faire indirectement, en faisant référence à un autre constructeur supplémentaire.  L'essentiel est qu'à la fin de la chaîne, nous arrivons toujours à l'essentiel.  Le déclenchement des constructeurs se fera évidemment dans l'ordre inverse des concepteurs se tournant les uns vers les autres: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Maintenant, la séquence est: <br><br><ul><li>  appeler un constructeur supplémentaire avec 4 paramètres; </li><li>  appeler un constructeur supplémentaire avec 3 paramètres; </li><li>  appeler le constructeur principal; </li><li>  initialisation d'un champ de classe p1 dans le constructeur primaire; </li><li>  exécution de code dans le corps du constructeur avec 3 paramètres; </li><li>  exécution de code dans le corps du constructeur avec 4 paramètres. </li></ul><br>  Dans tous les cas, le compilateur n'oubliera jamais de se rendre au constructeur principal. <br><br>  Il arrive qu'une classe n'ait pas de constructeur principal, alors qu'elle peut en avoir un ou plusieurs supplémentaires.  Ensuite, les constructeurs supplémentaires ne sont pas tenus de faire référence à quelqu'un, mais ils peuvent également faire référence à d'autres constructeurs supplémentaires de cette classe.  Plus tôt, nous avons découvert que le constructeur principal, non spécifié explicitement, est généré automatiquement, mais cela s'applique aux cas où il n'y a aucun constructeur dans la classe.  S'il existe au moins un constructeur supplémentaire, un constructeur principal sans paramètres n'est pas créé: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Nous pouvons créer un objet de classe en appelant: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  Dans ce cas: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Nous ne pouvons créer un objet qu'avec cet appel: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(“<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string”, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  Il n'y a rien de nouveau dans Kotlin par rapport à Java. <br><br>  Soit dit en passant, comme le constructeur principal, le constructeur supplémentaire peut ne pas avoir de corps si sa tâche consiste uniquement à transmettre des paramètres à d'autres constructeurs. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Il convient également de prêter attention au fait que, contrairement au constructeur principal, l'initialisation des champs de classe dans la liste d'arguments du constructeur supplémentaire est interdite. <br>  C'est-à-dire  un tel enregistrement sera invalide: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Séparément, il convient de noter que le constructeur supplémentaire, comme le principal, peut bien être sans paramètres: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  En parlant de constructeurs, on ne peut que mentionner l'une des fonctionnalités pratiques de Kotlin - la possibilité d'attribuer des valeurs par défaut aux arguments. <br><br>  Supposons maintenant que nous ayons une classe avec plusieurs constructeurs qui ont un nombre d'arguments différent.  Je vais donner un exemple en Java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Comme le montre la pratique, ces conceptions sont assez courantes.  Voyons comment la même chose peut être écrite sur Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Maintenant, tapotons Kotlin ensemble pour combien il a coupé le code.  Soit dit en passant, en plus de réduire le nombre de lignes, nous obtenons plus d'ordre.  Rappelez-vous, vous devez avoir vu quelque chose comme ça plus d'une fois: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Lorsque vous voyez cela, vous voulez trouver la personne qui l'a écrit, le prendre par un bouton, le porter à l'écran et demander d'une voix triste: "Pourquoi?" <br>  Bien que vous puissiez répéter cet exploit sur Kotlin, mais pas nécessaire. <br><br>  Il y a cependant un détail que, dans le cas d'une telle notation abrégée sur Kotlin, il est nécessaire de prendre en compte: si nous voulons appeler le constructeur avec des valeurs par défaut à partir de Java, alors nous devons lui ajouter l'annotation <b><code>@JvmOverloads</code></b> : <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Sinon, nous obtenons une erreur. <br><br>  Parlons maintenant des <b>initialiseurs</b> . <br><br>  Un initialiseur est un bloc de code marqué avec le mot-clé <code>init</code> .  Dans ce bloc, vous pouvez exécuter une logique pour initialiser les éléments de la classe, notamment en utilisant les valeurs des arguments fournis par le constructeur principal.  Nous pouvons également appeler des fonctions à partir de ce bloc. <br><br>  Java a également des blocs d'initialisation, mais ce n'est pas la même chose.  En eux, on ne peut pas, comme dans Kotlin, passer une valeur de l'extérieur (les arguments du constructeur primaire).  L'initialiseur est très similaire au corps du constructeur principal, extrait dans un bloc séparé.  Mais c'est à première vue.  En fait, ce n'est pas entièrement vrai.  Faisons les choses correctement. <br><br>  Un initialiseur peut également exister en l'absence de constructeur principal.  Si c'est le cas, son code, comme tous les processus d'initialisation, est exécuté avant le code du constructeur supplémentaire.  Il peut y avoir plusieurs initialiseurs.  Dans ce cas, l'ordre de leur appel coïncidera avec l'ordre de leur emplacement dans le code.  Notez également que l'initialisation du champ de classe peut se produire en dehors des blocs <code>init</code> .  Dans ce cas, l'initialisation se produit également conformément à la disposition des éléments dans le code, et cela doit être pris en compte lors de l'appel de méthodes à partir du bloc d'initialisation.  Si vous le prenez imprudemment, il y a une chance de se tromper. <br><br>  Je vais vous donner quelques cas intéressants de travail avec des initialiseurs. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Ce code est tout à fait valide, mais pas tout à fait évident.  Si vous regardez, vous pouvez voir que l'affectation d'une valeur au champ <code>testParam</code> dans le bloc d'initialisation se produit avant la déclaration du paramètre.  Soit dit en passant, cela ne fonctionne que si nous avons un constructeur supplémentaire dans la classe, mais nous n'avons pas de constructeur principal (si nous élevons la déclaration du champ <code>testParam</code> au-dessus du bloc <code>init</code> , cela fonctionnera sans constructeur).  Si nous décompilons le code octet de cette classe en Java, nous obtenons ce qui suit: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  On voit ici que le premier appel au champ lors de l'initialisation (dans le bloc <code>init</code> ou en dehors) équivaut à son initialisation habituelle en Java.  Toutes les autres actions associées à l'affectation d'une valeur pendant le processus d'initialisation, à l'exception de la première (la première affectation d'une valeur est combinée avec la déclaration de champ), sont transférées au constructeur. <br>  Si nous menons des expériences de décompilation, il s'avère que s'il n'y a pas de constructeur, alors le constructeur principal est généré, et toute la magie s'y produit.  S'il y a plusieurs constructeurs supplémentaires qui ne se réfèrent pas l'un à l'autre, et qu'il n'y en a pas de principal, alors dans le code Java de cette classe toutes les affectations suivantes au champ <code>testParam</code> dupliquées dans tous les constructeurs supplémentaires.  S'il y a un constructeur principal, alors seulement dans le primaire.  Fuf ... <br><br>  Et la chose la plus intéressante pour les <code>testParam</code> : changeons la signature <code>testParam</code> de <code>var</code> en <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Et quelque part dans le code que nous appelons: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Tout a été compilé sans erreur, a commencé, et maintenant nous voyons la sortie des journaux: <br><br>  dans showTestParam testParam = une chaîne <br>  dans constructeur testParam = après <br><br>  Il s'avère que le champ déclaré comme <code>val</code> changé la valeur lors de l'exécution du code.  Pourquoi  Je pense que c'est une faille dans le compilateur Kotlin, et à l'avenir, cela ne compilera peut-être pas, mais aujourd'hui tout est comme ça. <br><br>  En tirant des conclusions des cas ci-dessus, on ne peut que conseiller de ne pas produire de blocs d'initialisation et de ne pas les disperser dans la classe, pour éviter l'affectation répétée de valeurs pendant le processus d'initialisation, pour appeler uniquement des fonctions pures à partir de blocs init.  Tout cela est fait pour éviter une éventuelle confusion. <br><br>  Alors.  <b>Les initialiseurs sont un certain bloc de code qui doit être exécuté lors de la création d'un objet, quel que soit le constructeur avec lequel cet objet est créé.</b> <br><br>  Cela semble réglé.  Considérez l'interaction des constructeurs et des initialiseurs.  Dans une classe, tout est assez simple, mais vous devez vous rappeler: <br><br><ul><li>  appeler un constructeur supplémentaire; </li><li>  appeler le constructeur principal; </li><li>  initialisation des champs de classe et des blocs d'initialisation dans l'ordre de leur emplacement dans le code; </li><li>  exécution de code dans le corps d'un constructeur supplémentaire. </li></ul><br>  Les cas avec héritage semblent plus intéressants. <br><br>  Il convient de noter que, comme Object est la base de toutes les classes en Java, Any est tel dans Kotlin.  Cependant, Any et Object ne sont pas la même chose. <br><br>  Pour commencer sur le fonctionnement de l'héritage.  La classe descendante, comme la classe parente, peut ou non avoir un constructeur principal, mais elle doit faire référence à un constructeur spécifique de la classe parente. <br><br>  Si la classe descendante a un constructeur principal, ce constructeur doit pointer vers un constructeur spécifique de la classe de base.  Dans ce cas, tous les constructeurs supplémentaires de la classe successeur doivent faire référence au constructeur principal de leur classe. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Si la classe descendante n'a pas de constructeur principal, chacun des constructeurs supplémentaires doit accéder au constructeur de la classe parente à l'aide du <code>super</code> mot clé.  Dans ce cas, différents constructeurs supplémentaires de la classe successeur peuvent accéder à différents constructeurs de la classe parente: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  N'oubliez pas non plus la possibilité d'appeler indirectement le constructeur de la classe parente via d'autres constructeurs de la classe dérivée: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Si la classe descendante n'a pas de constructeur, alors nous ajoutons simplement l'appel constructeur de la classe parente après le nom de la classe descendante: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(“some string”) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Cependant, il existe toujours une option avec héritage, dans laquelle une référence au constructeur de la classe parente n'est pas requise.  Un tel enregistrement est valide: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Mais seulement si la classe parente a un constructeur sans paramètres, qui est le constructeur par défaut (principal ou facultatif - cela n'a pas d'importance). <br><br>  Considérons maintenant l'ordre d'invocation des initialiseurs et des constructeurs lors de l'héritage: <br><br><ul><li>  appeler le constructeur supplémentaire de l'héritier; </li><li>  appeler le constructeur principal de l'héritier; </li><li>  appeler le constructeur supplémentaire du parent; </li><li>  appeler le constructeur principal du parent; </li><li>  <code>init</code> des blocs <code>init</code> parentaux </li><li>  exécution du code du corps du constructeur supplémentaire du parent; </li><li>  exécution du bloc <code>init</code> de l'héritier; </li><li>  exécution du code du corps du constructeur supplémentaire de l'héritier </li></ul><br>  Parlons de comparaison avec Java, dans lequel, en fait, il n'y a pas d'analogue du constructeur principal de Kotlin.  En Java, tous les constructeurs sont des pairs et peuvent être appelés ou non les uns des autres.  En Java et Kotlin, il y a un constructeur par défaut, c'est un constructeur sans paramètres, mais il n'acquiert un statut spécial qu'en héritant.  Ici, il convient de prêter attention aux éléments suivants: lors de l'héritage dans Kotlin, nous devons explicitement dire à la classe successeur quel constructeur de la classe parent utiliser - le compilateur ne nous laissera pas l'oublier.  En Java, nous ne pouvons pas l'indiquer explicitement.  Attention: dans ce cas, le constructeur par défaut de la classe parent sera appelé (le cas échéant). <br><br>  À ce stade, nous supposerons que nous avons étudié les concepteurs et les initialiseurs assez profondément et maintenant nous savons presque tout à leur sujet.  Nous allons nous reposer un peu et creuser dans l'autre sens! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425943/">https://habr.com/ru/post/fr425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425931/index.html">«Je veux quitter l'usine sur le Web» - 10 questions au programmeur, 8e édition</a></li>
<li><a href="../fr425933/index.html">L'humidité dans le centre de données: pourquoi c'est important</a></li>
<li><a href="../fr425935/index.html">Suspension de l'unité centrale sous la table debout</a></li>
<li><a href="../fr425937/index.html">CoreBluetooth en pratique</a></li>
<li><a href="../fr425939/index.html">DataIncrement - ajout aux fonctionnalités de phpMyAdmin</a></li>
<li><a href="../fr425945/index.html">Conseils pour une utilisation professionnelle de RecyclerView. Partie 1</a></li>
<li><a href="../fr425947/index.html">Ratatouille corporative</a></li>
<li><a href="../fr425951/index.html">Comment piraté la blockchain et les crypto-monnaies: 6 attaques réussies "51 pour cent"</a></li>
<li><a href="../fr425953/index.html">Station météo sur Arduino de A à Z. Partie 3</a></li>
<li><a href="../fr425955/index.html">8 bogues bêta intéressants d'iOS 12 et comment nous les avons recherchés</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>