<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö± üë® ü§üüèΩ Kotlin: creuser plus profond√©ment. Constructeurs et initialiseurs üíä üíÉüèæ üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mai 2017, Google a annonc√© que Kotlin √©tait devenu le langage de d√©veloppement officiel pour Android. Quelqu'un a ensuite entendu le nom de cette l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: creuser plus profond√©ment. Constructeurs et initialiseurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  En mai 2017, Google a annonc√© que Kotlin √©tait devenu le langage de d√©veloppement officiel pour Android.  Quelqu'un a ensuite entendu le nom de cette langue pour la premi√®re fois, quelqu'un a √©crit dessus pendant longtemps, mais √† partir de ce moment, il est devenu clair que toute personne proche du d√©veloppement Android est maintenant oblig√©e de la conna√Ætre.  Cela a √©t√© suivi par des r√©ponses enthousiastes "Enfin!" Et une terrible indignation "Pourquoi avons-nous besoin d'une nouvelle langue?"  Qu'est-ce qui n'a pas plu √† Java?  etc.  etc. <br><br>  Depuis, assez de temps s'est √©coul√©, et bien que le d√©bat sur la bonne ou la mauvaise Kotlin ne soit toujours pas r√©solu, de plus en plus de code pour Android y est √©crit.  Et m√™me des d√©veloppeurs assez conservateurs y passent √©galement.  De plus, sur le r√©seau, vous pouvez tomber sur des informations selon lesquelles la vitesse de d√©veloppement apr√®s la ma√Ætrise de ce langage est augment√©e de 30% par rapport √† Java. <br><br>  Aujourd'hui, Kotlin a d√©j√† r√©ussi √† se remettre de plusieurs maladies infantiles, envahies par de nombreuses questions et r√©ponses sur Stack Overflow.  √Ä l'≈ìil nu, ses avantages et ses faiblesses sont devenus visibles. <br><br>  Et sur cette vague, l'id√©e m'est venue d'analyser en d√©tail les √©l√©ments individuels d'un langage jeune mais populaire.  Faites attention aux points complexes et comparez-les avec Java pour plus de clart√© et une meilleure compr√©hension.  Pour comprendre la question un peu plus profond√©ment que cela peut √™tre fait en lisant la documentation.  Si cet article suscite l'int√©r√™t, il posera tr√®s probablement les bases de toute une s√©rie d'articles.  En attendant, je vais commencer par des choses assez basiques, qui cachent cependant pas mal d'emb√ªches.  Parlons des constructeurs et des initialiseurs dans Kotlin. <a name="habracut"></a><br><br>  Comme en Java, dans Kotlin, la cr√©ation de nouveaux objets - entit√©s d'un certain type - se produit en appelant le constructeur de classe.  Vous pouvez √©galement passer des arguments au constructeur, et il peut y avoir plusieurs constructeurs.  Si vous regardez ce processus de l'ext√©rieur, la seule diff√©rence avec Java est le manque de nouveau mot-cl√© lors de l'appel du constructeur.  Maintenant, jetez un ≈ìil plus profond et voyez ce qui se passe √† l'int√©rieur de la classe. <br><br>  Une classe peut avoir des constructeurs primaires et secondaires. <br>  Un constructeur est d√©clar√© √† l'aide du mot-cl√© constructeur.  Si le constructeur principal n'a pas de modificateurs d'acc√®s et d'annotations, le mot-cl√© peut √™tre omis. <br>  Une classe peut ne pas avoir de constructeurs d√©clar√©s explicitement.  Dans ce cas, apr√®s la d√©claration de la classe il n'y a pas de constructions, on passe imm√©diatement au corps de la classe.  Si nous √©tablissons une analogie avec Java, cela √©quivaut √† l'absence d'une d√©claration explicite de constructeurs, √† la suite de quoi le constructeur par d√©faut (sans param√®tres) sera g√©n√©r√© automatiquement au stade de la compilation.  Il semble comme pr√©vu: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Cela √©quivaut √† l'entr√©e suivante: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Mais si vous √©crivez de cette fa√ßon, il vous sera poliment demand√© de supprimer le constructeur principal sans param√®tres. <br><br>  Le constructeur principal est celui qui est toujours appel√© lorsqu'un objet est cr√©√© au cas o√π il existe.  Bien que nous en tenions compte et que nous analyserons plus en d√©tail plus tard, lorsque nous passerons aux constructeurs secondaires.  En cons√©quence, nous nous souvenons que s'il n'y a pas de constructeurs du tout, alors en fait il y en a un (principal), mais nous ne le voyons pas. <br><br>  Si, par exemple, nous voulons que le constructeur principal sans param√®tres n'ait pas d'acc√®s public, alors avec la modification <code>private</code> , nous devrons le d√©clarer explicitement avec le mot-cl√© <code>constructor</code> . <br><br>  La principale caract√©ristique du constructeur principal est qu'il n'a pas de corps, c'est-√†-dire  ne peut pas contenir de code ex√©cutable.  Il prend simplement les param√®tres en eux-m√™mes et les transmet profond√©ment dans la classe pour une utilisation future.  Au niveau de la syntaxe, cela ressemble √† ceci: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Les param√®tres pass√©s de cette mani√®re peuvent √™tre utilis√©s pour diverses initialisations, mais pas plus.  Dans sa forme pure, nous ne pouvons pas utiliser ces arguments dans le code de travail de la classe.  Cependant, nous pouvons initialiser les champs de la classe ici.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Ici, <code>param1</code> et <code>param2</code> peuvent √™tre utilis√©s dans le code en tant que champs de la classe, ce qui √©quivaut √† ce qui suit: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Eh bien, si vous comparez avec Java, cela ressemblerait √† ceci (et au fait, dans cet exemple, vous pouvez √©valuer dans quelle mesure Kotlin peut r√©duire la quantit√© de code): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Parlons de designers suppl√©mentaires.  Ils rappellent plus les constructeurs ordinaires en Java: ils acceptent des param√®tres et peuvent avoir un bloc ex√©cutable.  Lors de la d√©claration de constructeurs suppl√©mentaires, le mot-cl√© constructeur est requis.  Comme mentionn√© pr√©c√©demment, malgr√© la possibilit√© de cr√©er un objet en appelant un constructeur suppl√©mentaire, le constructeur principal (le cas √©ch√©ant) doit √©galement √™tre appel√© √† l'aide du <code>this</code> .  Au niveau de la syntaxe, cela est organis√© comme suit: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  C'est-√†-dire  le constructeur suppl√©mentaire est, pour ainsi dire, l'h√©ritier du primaire. <br>  Maintenant, si nous cr√©ons un objet en appelant un constructeur suppl√©mentaire, ce qui se passera: <br><br>  appeler un constructeur suppl√©mentaire; <br>  appeler le constructeur principal; <br>  initialisation d'un champ de classe <code>p1</code> dans le constructeur principal; <br>  ex√©cution de code dans le corps d'un constructeur suppl√©mentaire. <br><br>  Ceci est similaire √† une telle construction en Java: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Rappelons qu'en Java on ne peut appeler un constructeur d'un autre en utilisant le <code>this</code> qu'au d√©but du corps du constructeur.  Chez Kotlin, ce probl√®me √©tait fondamentalement r√©solu - ils ont fait de cet appel une partie de la signature du constructeur.  Juste au cas o√π, je note qu'il est interdit d'appeler un constructeur (principal ou suppl√©mentaire) directement √† partir du corps du constructeur suppl√©mentaire. <br><br>  Un constructeur suppl√©mentaire doit toujours faire r√©f√©rence au constructeur principal (le cas √©ch√©ant), mais peut le faire indirectement, en faisant r√©f√©rence √† un autre constructeur suppl√©mentaire.  L'essentiel est qu'√† la fin de la cha√Æne, nous arrivons toujours √† l'essentiel.  Le d√©clenchement des constructeurs se fera √©videmment dans l'ordre inverse des concepteurs se tournant les uns vers les autres: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Maintenant, la s√©quence est: <br><br><ul><li>  appeler un constructeur suppl√©mentaire avec 4 param√®tres; </li><li>  appeler un constructeur suppl√©mentaire avec 3 param√®tres; </li><li>  appeler le constructeur principal; </li><li>  initialisation d'un champ de classe p1 dans le constructeur primaire; </li><li>  ex√©cution de code dans le corps du constructeur avec 3 param√®tres; </li><li>  ex√©cution de code dans le corps du constructeur avec 4 param√®tres. </li></ul><br>  Dans tous les cas, le compilateur n'oubliera jamais de se rendre au constructeur principal. <br><br>  Il arrive qu'une classe n'ait pas de constructeur principal, alors qu'elle peut en avoir un ou plusieurs suppl√©mentaires.  Ensuite, les constructeurs suppl√©mentaires ne sont pas tenus de faire r√©f√©rence √† quelqu'un, mais ils peuvent √©galement faire r√©f√©rence √† d'autres constructeurs suppl√©mentaires de cette classe.  Plus t√¥t, nous avons d√©couvert que le constructeur principal, non sp√©cifi√© explicitement, est g√©n√©r√© automatiquement, mais cela s'applique aux cas o√π il n'y a aucun constructeur dans la classe.  S'il existe au moins un constructeur suppl√©mentaire, un constructeur principal sans param√®tres n'est pas cr√©√©: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Nous pouvons cr√©er un objet de classe en appelant: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  Dans ce cas: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Nous ne pouvons cr√©er un objet qu'avec cet appel: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string‚Äù, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  Il n'y a rien de nouveau dans Kotlin par rapport √† Java. <br><br>  Soit dit en passant, comme le constructeur principal, le constructeur suppl√©mentaire peut ne pas avoir de corps si sa t√¢che consiste uniquement √† transmettre des param√®tres √† d'autres constructeurs. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Il convient √©galement de pr√™ter attention au fait que, contrairement au constructeur principal, l'initialisation des champs de classe dans la liste d'arguments du constructeur suppl√©mentaire est interdite. <br>  C'est-√†-dire  un tel enregistrement sera invalide: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  S√©par√©ment, il convient de noter que le constructeur suppl√©mentaire, comme le principal, peut bien √™tre sans param√®tres: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  En parlant de constructeurs, on ne peut que mentionner l'une des fonctionnalit√©s pratiques de Kotlin - la possibilit√© d'attribuer des valeurs par d√©faut aux arguments. <br><br>  Supposons maintenant que nous ayons une classe avec plusieurs constructeurs qui ont un nombre d'arguments diff√©rent.  Je vais donner un exemple en Java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Comme le montre la pratique, ces conceptions sont assez courantes.  Voyons comment la m√™me chose peut √™tre √©crite sur Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Maintenant, tapotons Kotlin ensemble pour combien il a coup√© le code.  Soit dit en passant, en plus de r√©duire le nombre de lignes, nous obtenons plus d'ordre.  Rappelez-vous, vous devez avoir vu quelque chose comme √ßa plus d'une fois: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Lorsque vous voyez cela, vous voulez trouver la personne qui l'a √©crit, le prendre par un bouton, le porter √† l'√©cran et demander d'une voix triste: "Pourquoi?" <br>  Bien que vous puissiez r√©p√©ter cet exploit sur Kotlin, mais pas n√©cessaire. <br><br>  Il y a cependant un d√©tail que, dans le cas d'une telle notation abr√©g√©e sur Kotlin, il est n√©cessaire de prendre en compte: si nous voulons appeler le constructeur avec des valeurs par d√©faut √† partir de Java, alors nous devons lui ajouter l'annotation <b><code>@JvmOverloads</code></b> : <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Sinon, nous obtenons une erreur. <br><br>  Parlons maintenant des <b>initialiseurs</b> . <br><br>  Un initialiseur est un bloc de code marqu√© avec le mot-cl√© <code>init</code> .  Dans ce bloc, vous pouvez ex√©cuter une logique pour initialiser les √©l√©ments de la classe, notamment en utilisant les valeurs des arguments fournis par le constructeur principal.  Nous pouvons √©galement appeler des fonctions √† partir de ce bloc. <br><br>  Java a √©galement des blocs d'initialisation, mais ce n'est pas la m√™me chose.  En eux, on ne peut pas, comme dans Kotlin, passer une valeur de l'ext√©rieur (les arguments du constructeur primaire).  L'initialiseur est tr√®s similaire au corps du constructeur principal, extrait dans un bloc s√©par√©.  Mais c'est √† premi√®re vue.  En fait, ce n'est pas enti√®rement vrai.  Faisons les choses correctement. <br><br>  Un initialiseur peut √©galement exister en l'absence de constructeur principal.  Si c'est le cas, son code, comme tous les processus d'initialisation, est ex√©cut√© avant le code du constructeur suppl√©mentaire.  Il peut y avoir plusieurs initialiseurs.  Dans ce cas, l'ordre de leur appel co√Øncidera avec l'ordre de leur emplacement dans le code.  Notez √©galement que l'initialisation du champ de classe peut se produire en dehors des blocs <code>init</code> .  Dans ce cas, l'initialisation se produit √©galement conform√©ment √† la disposition des √©l√©ments dans le code, et cela doit √™tre pris en compte lors de l'appel de m√©thodes √† partir du bloc d'initialisation.  Si vous le prenez imprudemment, il y a une chance de se tromper. <br><br>  Je vais vous donner quelques cas int√©ressants de travail avec des initialiseurs. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Ce code est tout √† fait valide, mais pas tout √† fait √©vident.  Si vous regardez, vous pouvez voir que l'affectation d'une valeur au champ <code>testParam</code> dans le bloc d'initialisation se produit avant la d√©claration du param√®tre.  Soit dit en passant, cela ne fonctionne que si nous avons un constructeur suppl√©mentaire dans la classe, mais nous n'avons pas de constructeur principal (si nous √©levons la d√©claration du champ <code>testParam</code> au-dessus du bloc <code>init</code> , cela fonctionnera sans constructeur).  Si nous d√©compilons le code octet de cette classe en Java, nous obtenons ce qui suit: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  On voit ici que le premier appel au champ lors de l'initialisation (dans le bloc <code>init</code> ou en dehors) √©quivaut √† son initialisation habituelle en Java.  Toutes les autres actions associ√©es √† l'affectation d'une valeur pendant le processus d'initialisation, √† l'exception de la premi√®re (la premi√®re affectation d'une valeur est combin√©e avec la d√©claration de champ), sont transf√©r√©es au constructeur. <br>  Si nous menons des exp√©riences de d√©compilation, il s'av√®re que s'il n'y a pas de constructeur, alors le constructeur principal est g√©n√©r√©, et toute la magie s'y produit.  S'il y a plusieurs constructeurs suppl√©mentaires qui ne se r√©f√®rent pas l'un √† l'autre, et qu'il n'y en a pas de principal, alors dans le code Java de cette classe toutes les affectations suivantes au champ <code>testParam</code> dupliqu√©es dans tous les constructeurs suppl√©mentaires.  S'il y a un constructeur principal, alors seulement dans le primaire.  Fuf ... <br><br>  Et la chose la plus int√©ressante pour les <code>testParam</code> : changeons la signature <code>testParam</code> de <code>var</code> en <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Et quelque part dans le code que nous appelons: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Tout a √©t√© compil√© sans erreur, a commenc√©, et maintenant nous voyons la sortie des journaux: <br><br>  dans showTestParam testParam = une cha√Æne <br>  dans constructeur testParam = apr√®s <br><br>  Il s'av√®re que le champ d√©clar√© comme <code>val</code> chang√© la valeur lors de l'ex√©cution du code.  Pourquoi  Je pense que c'est une faille dans le compilateur Kotlin, et √† l'avenir, cela ne compilera peut-√™tre pas, mais aujourd'hui tout est comme √ßa. <br><br>  En tirant des conclusions des cas ci-dessus, on ne peut que conseiller de ne pas produire de blocs d'initialisation et de ne pas les disperser dans la classe, pour √©viter l'affectation r√©p√©t√©e de valeurs pendant le processus d'initialisation, pour appeler uniquement des fonctions pures √† partir de blocs init.  Tout cela est fait pour √©viter une √©ventuelle confusion. <br><br>  Alors.  <b>Les initialiseurs sont un certain bloc de code qui doit √™tre ex√©cut√© lors de la cr√©ation d'un objet, quel que soit le constructeur avec lequel cet objet est cr√©√©.</b> <br><br>  Cela semble r√©gl√©.  Consid√©rez l'interaction des constructeurs et des initialiseurs.  Dans une classe, tout est assez simple, mais vous devez vous rappeler: <br><br><ul><li>  appeler un constructeur suppl√©mentaire; </li><li>  appeler le constructeur principal; </li><li>  initialisation des champs de classe et des blocs d'initialisation dans l'ordre de leur emplacement dans le code; </li><li>  ex√©cution de code dans le corps d'un constructeur suppl√©mentaire. </li></ul><br>  Les cas avec h√©ritage semblent plus int√©ressants. <br><br>  Il convient de noter que, comme Object est la base de toutes les classes en Java, Any est tel dans Kotlin.  Cependant, Any et Object ne sont pas la m√™me chose. <br><br>  Pour commencer sur le fonctionnement de l'h√©ritage.  La classe descendante, comme la classe parente, peut ou non avoir un constructeur principal, mais elle doit faire r√©f√©rence √† un constructeur sp√©cifique de la classe parente. <br><br>  Si la classe descendante a un constructeur principal, ce constructeur doit pointer vers un constructeur sp√©cifique de la classe de base.  Dans ce cas, tous les constructeurs suppl√©mentaires de la classe successeur doivent faire r√©f√©rence au constructeur principal de leur classe. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Si la classe descendante n'a pas de constructeur principal, chacun des constructeurs suppl√©mentaires doit acc√©der au constructeur de la classe parente √† l'aide du <code>super</code> mot cl√©.  Dans ce cas, diff√©rents constructeurs suppl√©mentaires de la classe successeur peuvent acc√©der √† diff√©rents constructeurs de la classe parente: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  N'oubliez pas non plus la possibilit√© d'appeler indirectement le constructeur de la classe parente via d'autres constructeurs de la classe d√©riv√©e: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Si la classe descendante n'a pas de constructeur, alors nous ajoutons simplement l'appel constructeur de la classe parente apr√®s le nom de la classe descendante: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(‚Äúsome string‚Äù) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Cependant, il existe toujours une option avec h√©ritage, dans laquelle une r√©f√©rence au constructeur de la classe parente n'est pas requise.  Un tel enregistrement est valide: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Mais seulement si la classe parente a un constructeur sans param√®tres, qui est le constructeur par d√©faut (principal ou facultatif - cela n'a pas d'importance). <br><br>  Consid√©rons maintenant l'ordre d'invocation des initialiseurs et des constructeurs lors de l'h√©ritage: <br><br><ul><li>  appeler le constructeur suppl√©mentaire de l'h√©ritier; </li><li>  appeler le constructeur principal de l'h√©ritier; </li><li>  appeler le constructeur suppl√©mentaire du parent; </li><li>  appeler le constructeur principal du parent; </li><li>  <code>init</code> des blocs <code>init</code> parentaux </li><li>  ex√©cution du code du corps du constructeur suppl√©mentaire du parent; </li><li>  ex√©cution du bloc <code>init</code> de l'h√©ritier; </li><li>  ex√©cution du code du corps du constructeur suppl√©mentaire de l'h√©ritier </li></ul><br>  Parlons de comparaison avec Java, dans lequel, en fait, il n'y a pas d'analogue du constructeur principal de Kotlin.  En Java, tous les constructeurs sont des pairs et peuvent √™tre appel√©s ou non les uns des autres.  En Java et Kotlin, il y a un constructeur par d√©faut, c'est un constructeur sans param√®tres, mais il n'acquiert un statut sp√©cial qu'en h√©ritant.  Ici, il convient de pr√™ter attention aux √©l√©ments suivants: lors de l'h√©ritage dans Kotlin, nous devons explicitement dire √† la classe successeur quel constructeur de la classe parent utiliser - le compilateur ne nous laissera pas l'oublier.  En Java, nous ne pouvons pas l'indiquer explicitement.  Attention: dans ce cas, le constructeur par d√©faut de la classe parent sera appel√© (le cas √©ch√©ant). <br><br>  √Ä ce stade, nous supposerons que nous avons √©tudi√© les concepteurs et les initialiseurs assez profond√©ment et maintenant nous savons presque tout √† leur sujet.  Nous allons nous reposer un peu et creuser dans l'autre sens! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425943/">https://habr.com/ru/post/fr425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425931/index.html">¬´Je veux quitter l'usine sur le Web¬ª - 10 questions au programmeur, 8e √©dition</a></li>
<li><a href="../fr425933/index.html">L'humidit√© dans le centre de donn√©es: pourquoi c'est important</a></li>
<li><a href="../fr425935/index.html">Suspension de l'unit√© centrale sous la table debout</a></li>
<li><a href="../fr425937/index.html">CoreBluetooth en pratique</a></li>
<li><a href="../fr425939/index.html">DataIncrement - ajout aux fonctionnalit√©s de phpMyAdmin</a></li>
<li><a href="../fr425945/index.html">Conseils pour une utilisation professionnelle de RecyclerView. Partie 1</a></li>
<li><a href="../fr425947/index.html">Ratatouille corporative</a></li>
<li><a href="../fr425951/index.html">Comment pirat√© la blockchain et les crypto-monnaies: 6 attaques r√©ussies "51 pour cent"</a></li>
<li><a href="../fr425953/index.html">Station m√©t√©o sur Arduino de A √† Z. Partie 3</a></li>
<li><a href="../fr425955/index.html">8 bogues b√™ta int√©ressants d'iOS 12 et comment nous les avons recherch√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>