<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèº üë©üèΩ‚Äçü§ù‚Äçüë©üèº üéø Enfoque codicioso y m√°quinas tragamonedas. An√°lisis de las tareas de la ML-track del campeonato de programaci√≥n. ü§µ üê± ‚òÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos publicando an√°lisis de las tareas que se propusieron en el reciente campeonato. A continuaci√≥n se encuentran las tareas tomadas de la rond...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enfoque codicioso y m√°quinas tragamonedas. An√°lisis de las tareas de la ML-track del campeonato de programaci√≥n.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/461273/"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  Continuamos publicando an√°lisis de las tareas que se propusieron en el reciente campeonato.  A continuaci√≥n se encuentran las tareas tomadas de la ronda de calificaci√≥n para especialistas en aprendizaje autom√°tico.  Esta es la tercera pista de cuatro (backend, frontend, ML, analytics).  Los participantes deb√≠an hacer un modelo para corregir errores tipogr√°ficos en los textos, proponer una estrategia para jugar en m√°quinas tragamonedas, recordar un sistema de recomendaciones de contenido y componer varios programas m√°s. <br><br><a name="habracut"></a><h2>  A. Typos </h2><br><h4>  Condici√≥n </h4><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Todos los idiomas</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  L√≠mite de tiempo </td><td>  1 s </td><td>  5 s </td><td>  5 s </td></tr><tr><td>  L√≠mite de memoria </td><td>  64 MB </td><td>  256 MB </td><td>  256 MB </td></tr><tr><td>  Entrar </td><td colspan="3">  entrada est√°ndar o input.txt </td></tr><tr><td>  Conclusi√≥n </td><td colspan="3">  salida est√°ndar o salida.txt </td></tr></tbody></table></div>  (ep√≠grafe) (de un foro) <br>  - ¬øQui√©n compuso estas tonter√≠as? <br>  - Astrof√≠sicos.  Ellos tambi√©n son personas. <br>  - Cometiste 10 errores en la palabra "periodistas". <br><br>  Muchos usuarios cometen errores de tipeo, algunos por presionar teclas y otros por analfabetismo.  Queremos verificar si el usuario podr√≠a tener en mente otra palabra que no sea la que escribi√≥. <br><br>  M√°s formalmente, suponga que se produce el siguiente modelo de error: el usuario comienza con una palabra que quiere escribir y luego comete una serie de errores.  Cada error es una sustituci√≥n de alguna subcadena de la palabra por otra subcadena.  Un error corresponde a reemplazar solo en una posici√≥n (es decir, si el usuario quiere cometer un solo error por la regla "abc" ‚Üí "cba", entonces de la cadena "abcabc" puede obtener "cbaabc" o "abccba").  Despu√©s de cada error, el proceso se repite.  La misma regla podr√≠a usarse varias veces en diferentes pasos (por ejemplo, en el ejemplo anterior, "cbacba" podr√≠a obtenerse en dos pasos). <br><br>  Es necesario determinar el n√∫mero m√≠nimo de errores que un usuario podr√≠a cometer si tuviera en mente una palabra determinada y escribiera otra. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S y ejemplo</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  La primera l√≠nea contiene la palabra, que, seg√∫n nuestra suposici√≥n, el usuario ten√≠a en mente (consiste en letras del alfabeto latino en min√∫sculas, la longitud no excede de 20). <br><br>  La segunda l√≠nea contiene la palabra que realmente escribi√≥ (tambi√©n consta de letras del alfabeto latino en min√∫sculas, la longitud no excede de 20). <br><br>  La tercera l√≠nea contiene un solo n√∫mero N (N &lt;50): el n√∫mero de reemplazos que describen varios errores. <br><br>  Las siguientes N l√≠neas contienen posibles reemplazos en el formato &amp; lt secuencia de letras "correcta" y gt &lt;espacio&gt; &lt;secuencia de letras "err√≥nea"&gt;.  Las secuencias no tienen m√°s de 6 caracteres. <br><br><h4>  Formato de salida </h4><br>  Se requiere imprimir un n√∫mero: el n√∫mero m√≠nimo de errores que el usuario podr√≠a cometer.  Si este n√∫mero excede 4 o es imposible obtener otro de una palabra, imprima -1. <br><br><h4>  Ejemplo </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4>  Soluci√≥n </h4><br>  Intentemos generar de la ortograf√≠a correcta todas las palabras posibles con no m√°s de 4 errores.  En el peor de los casos, puede haber O ((LÔπíN) <sup>4</sup> ).  En las limitaciones del problema, este es un n√∫mero bastante grande, por lo que debe descubrir c√≥mo reducir la complejidad.  En su lugar, puede usar el algoritmo de encuentro en el medio: genere palabras con no m√°s de 2 errores, as√≠ como palabras de las que puede obtener una palabra escrita por el usuario, cometiendo no m√°s de 2 errores.  Tenga en cuenta que el tama√±o de cada uno de estos conjuntos no exceder√° de 10 <sup>6</sup> .  Si el n√∫mero de errores cometidos por el usuario no supera los 4, estos conjuntos se intersectar√°n.  Del mismo modo, podemos verificar que el n√∫mero de errores no exceda de 3, 2 y 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2>  B. Bandido de muchos brazos </h2><br><h4>  Condici√≥n </h4><div class="scrollable-table"><table><tbody><tr><td>  L√≠mite de tiempo </td><td>  2 s </td></tr><tr><td>  L√≠mite de memoria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada est√°ndar </td></tr><tr><td>  Conclusi√≥n </td><td>  salida est√°ndar </td></tr></tbody></table></div>  Esta es una tarea interactiva. <br><br>  Usted mismo no sabe c√≥mo sucedi√≥, pero se encontr√≥ en una sala con m√°quinas tragamonedas con una bolsa llena de fichas.  Desafortunadamente, en la taquilla, se niegan a aceptar los tokens y decidiste probar suerte.  Hay muchas m√°quinas tragamonedas en el pasillo que puedes jugar.  Para un juego con una m√°quina tragamonedas, usa una ficha.  En caso de ganar, la m√°quina le da un d√≥lar, en caso de p√©rdida, nada.  Cada m√°quina tiene una probabilidad fija de ganar (que no conoce), pero es diferente para diferentes m√°quinas.  Despu√©s de estudiar el sitio web del fabricante de estas m√°quinas, descubri√≥ que la probabilidad de ganar para cada m√°quina se selecciona aleatoriamente en la etapa de fabricaci√≥n a partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">distribuci√≥n beta</a> con ciertos par√°metros. <br><br>  Desea maximizar sus ganancias esperadas. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S y ejemplo</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  Una ejecuci√≥n puede consistir en varias pruebas. <br><br>  Cada prueba comienza con el hecho de que su programa en la l√≠nea contiene dos enteros separados por un espacio: el n√∫mero N es el n√∫mero de fichas en su bolsa y M es el n√∫mero de m√°quinas en el pasillo (N ‚â§ 10 <sup>4</sup> , M ‚â§ min (N, 100) )  La siguiente l√≠nea contiene dos n√∫meros reales Œ± y Œ≤ (1 ‚â§ Œ±, Œ≤ ‚â§ 10): los par√°metros de la distribuci√≥n beta de la probabilidad de ganar. <br><br>  El protocolo de comunicaci√≥n con el sistema de verificaci√≥n es el siguiente: realiza exactamente N solicitudes.  Para cada solicitud, imprima en una l√≠nea separada el n√∫mero de la m√°quina que jugar√° (de 1 a M inclusive).  Como respuesta, en una l√≠nea separada habr√° "0" o "1", lo que significa, respectivamente, una p√©rdida y una victoria en un juego con la m√°quina tragamonedas solicitada. <br><br>  Despu√©s de la √∫ltima prueba, en lugar de los n√∫meros N y M, habr√° dos ceros. <br><br><h4>  Formato de salida </h4><br>  La tarea se considerar√° completada si su decisi√≥n no es mucho peor que la decisi√≥n del jurado.  Si su decisi√≥n es significativamente peor que la decisi√≥n del jurado, recibir√° el veredicto "respuesta incorrecta". <br><br>  Se garantiza que si su decisi√≥n no es peor que la decisi√≥n del jurado, entonces la probabilidad de recibir el veredicto de "respuesta incorrecta" no excede de <sup>10-6</sup> . <br><br><h4>  Notas </h4><br>  Ejemplo de interacci√≥n: <br><br><pre> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  Soluci√≥n </h4><br>  Este problema es bien conocido, podr√≠a resolverse de diferentes maneras.  La decisi√≥n principal del jurado implement√≥ la estrategia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muestreo de Thompson</a> , pero dado que el n√∫mero de pasos se conoc√≠a al comienzo del programa, existen estrategias m√°s √≥ptimas (por ejemplo, UCB1).  Adem√°s, uno podr√≠a incluso pasar con la estrategia √©psilon-codiciosa: con cierta probabilidad Œµ jugar una m√°quina aleatoria y con una probabilidad (1 - Œµ) jugar una m√°quina con las mejores estad√≠sticas de victoria. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2>  C. Alineaci√≥n de oraciones </h2><br><h4>  Condici√≥n </h4><div class="scrollable-table"><table><tbody><tr><td>  L√≠mite de tiempo </td><td>  2 s </td></tr><tr><td>  L√≠mite de memoria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada est√°ndar o input.txt </td></tr><tr><td>  Conclusi√≥n </td><td>  salida est√°ndar o salida.txt </td></tr></tbody></table></div>  Una de las tareas m√°s importantes para entrenar un buen modelo de traducci√≥n autom√°tica es un buen caso de oraciones paralelas.  Por lo general, la fuente de ofertas paralelas son los documentos paralelos.  Resulta que, a menudo, para construir un cierto corpus de oraciones paralelas, no necesita saber nada m√°s que su longitud.  En particular, puede notar que cuanto m√°s larga sea la oraci√≥n en el idioma de origen, m√°s probablemente ser√° traducida.  Cierta dificultad radica en el hecho de que durante la traducci√≥n el n√∫mero de oraciones en el texto puede cambiar: a veces dos oraciones adyacentes en la traducci√≥n se pueden combinar en una, o viceversa: una oraci√≥n se puede dividir en dos.  En algunos casos raros, las oraciones pueden omitirse por completo en una traducci√≥n, o una traducci√≥n puede aparecer en una traducci√≥n que no estaba en el original. <br><br>  M√°s formalmente, suponga que el siguiente modelo generativo para recintos paralelos es verdadero.  En cada paso, hacemos uno de los siguientes: <br><br>  <b>1. <i>Parar</i></b> <br><br>  Con probabilidad p <sub>h,</sub> finaliza <sub>la</sub> generaci√≥n de cascos. <br><br>  <b>2. [1-0] <i>Saltar ofertas</i></b> <br><br>  Con probabilidad p <sub>d,</sub> atribuimos una oraci√≥n al texto original.  No atribuimos nada a la traducci√≥n.  La longitud de la oraci√≥n en el idioma original L ‚â• 1 se selecciona de la distribuci√≥n discreta: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  Aqu√≠ <i>Œº <sub>s</sub></i> , <i>œÉ <sub>s</sub></i> son los par√°metros de distribuci√≥n, y <i>Œ± <sub>s</sub></i> es el coeficiente de normalizaci√≥n elegido para que <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>Insertar propuesta</i></b> <br><br>  Con probabilidad p <sub>i</sub> asignamos una oraci√≥n a la traducci√≥n.  No atribuimos nada al original.  La longitud de una oraci√≥n en un idioma de traducci√≥n L ‚â• 1 se selecciona de una distribuci√≥n discreta: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  Aqu√≠ <i>Œº <sub>t</sub></i> , <i>œÉ <sub>t</sub></i> son los par√°metros de distribuci√≥n, y <i>Œ± <sub>t</sub></i> es el coeficiente de normalizaci√≥n elegido para que <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>Traducci√≥n</i></b> <br><br>  Con probabilidad (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ) tomamos la longitud de la oraci√≥n en el idioma original L <sub>s</sub> ‚â• 1 de la distribuci√≥n p <sub>s</sub> (con redondeo).  A continuaci√≥n, generamos la longitud de la oraci√≥n en el lenguaje de traducci√≥n L <sub>t</sub> ‚â• 1 a partir de la distribuci√≥n discreta condicional: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  Aqu√≠, <i>Œ± <sub>st</sub></i> es el coeficiente de normalizaci√≥n, y los par√°metros restantes se describen en los p√°rrafos anteriores. <br><br>  El siguiente es otro paso: <br><br>  1. [2-1] Con probabilidad p <sub>dividida s, la</sub> oraci√≥n generada en el idioma original se divide en dos no vac√≠as, de modo que el n√∫mero total de palabras <b><i>aumenta exactamente en una</i></b> .  La probabilidad de que una oraci√≥n de longitud L <sub>s se</sub> separe en partes de longitud L <sub>1</sub> y L <sub>2</sub> (es decir, L <sub>1</sub> + L <sub>2</sub> = L <sub>s</sub> + 1) es proporcional a P <sub>s</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>s</sub> (L <sub>2</sub> ). <br><br>  2. [1-2] Con la probabilidad p <sub>dividida t, la</sub> oraci√≥n generada en el idioma de destino se divide en dos oraciones no vac√≠as, de modo que el n√∫mero total de palabras aumenta exactamente en una.  La probabilidad de que una oraci√≥n de longitud L <sub>t se</sub> separe en partes de longitud L1 y L2 (es decir, L <sub>1</sub> + L <sub>2</sub> = L <sub>t</sub> + 1) es proporcional a P <sub>t</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>t</sub> (L <sub>2</sub> ). <br><br>  3. 3. [1-1] Con una probabilidad de (1 - p <sub>dividido s</sub> - p <sub>dividido t</sub> ), ninguno de los par de oraciones generadas decaer√°. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S, ejemplos y notas</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  La primera l√≠nea del archivo contiene los par√°metros de distribuci√≥n: p <sub>h</sub> , p <sub>d</sub> , p <sub>i</sub> , p <sub>split s</sub> , p <sub>split t</sub> , Œº <sub>s</sub> , œÉ <sub>s</sub> , Œº <sub>t</sub> , œÉ <sub>t</sub> .  0.1 ‚â§ œÉ <sub>s</sub> &lt;œÉ <sub>t</sub> ‚â§ 3. 0 ‚â§ Œº <sub>s</sub> , Œº <sub>t</sub> ‚â§ 5. <br><br>  La siguiente l√≠nea contiene los n√∫meros N <sub>sy</sub> N <sub>t</sub> : el n√∫mero de oraciones en el caso en el idioma original y en el idioma de destino, respectivamente (1 ‚â§ N <sub>s</sub> , N <sub>t</sub> ‚â§ 1000). <br><br>  La siguiente l√≠nea contiene N <sub>s</sub> enteros: la longitud de las oraciones en el idioma original.  La siguiente l√≠nea contiene N <sub>t</sub> enteros: la longitud de las oraciones en el idioma de destino. <br><br>  La siguiente l√≠nea contiene dos n√∫meros: j y k (1 ‚â§ j ‚â§ N <sub>s</sub> , 1 ‚â§ k ‚â§ N <sub>t</sub> ). <br><br><h4>  Formato de salida </h4><br>  Se requiere derivar la probabilidad de que las oraciones con los √≠ndices j y k en los textos, respectivamente, sean paralelas (es decir, que se generan en un paso del algoritmo y ninguna de ellas es el resultado de la descomposici√≥n). <br><br>  Su respuesta ser√° aceptada si el error absoluto no excede de 10 a <sup>4</sup> . <br><br><h4>  Ejemplo 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4>  Ejemplo 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4>  Ejemplo 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4>  Notas </h4><br>  En el primer ejemplo, la secuencia inicial de n√∫meros se puede obtener de tres maneras: <br><br>  ‚Ä¢ Primero, con probabilidad p <sub>d</sub> agregue una oraci√≥n al texto original, luego con probabilidad p agrego una oraci√≥n a la traducci√≥n, luego con probabilidad p <sub>h</sub> termine la generaci√≥n. <br><br>  La probabilidad de este evento es P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  ‚Ä¢ Primero, con probabilidad p <sub>d</sub> agregue una oraci√≥n al texto original, luego con probabilidad p agrego una oraci√≥n a la traducci√≥n, luego con probabilidad p <sub>h</sub> termine la generaci√≥n. <br><br>  La probabilidad de este evento es igual a P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  ‚Ä¢ Con probabilidad (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) generar dos oraciones, luego con probabilidad (1 - p <sub>dividir s</sub> - p <sub>dividir t</sub> ) dejar todo como est√° (es decir, no dividir el original o la traducci√≥n en dos oraciones ) y despu√©s de eso con probabilidad p <sub>h</sub> terminar la generaci√≥n. <br><br>  La probabilidad de este evento es <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  Como resultado, la respuesta se calcula como <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4>  Soluci√≥n </h4><br>  La tarea es un caso especial de alineaci√≥n utilizando modelos ocultos de Markov (alineaci√≥n HMM).  La idea principal es que puede calcular la probabilidad de generar un par espec√≠fico de documentos utilizando este modelo y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo de reenv√≠o</a> : en este caso, el estado es un par de prefijos de documentos.  En consecuencia, la probabilidad requerida de alineaci√≥n de un par espec√≠fico de oraciones paralelas puede calcularse mediante el algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">avance hacia atr√°s</a> . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2>  D. Cinta de recomendaciones </h2><br><h4>  Condici√≥n </h4><div class="scrollable-table"><table><tbody><tr><td>  L√≠mite de tiempo </td><td>  2 s </td></tr><tr><td>  L√≠mite de memoria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada est√°ndar o input.txt </td></tr><tr><td>  Conclusi√≥n </td><td>  salida est√°ndar o salida.txt </td></tr></tbody></table></div>  Considere una fuente de recomendaciones para contenido heterog√©neo.  Mezcla objetos de varios tipos (im√°genes, videos, noticias, etc.).  Estos objetos generalmente est√°n ordenados por relevancia para el usuario: cuanto m√°s relevante (interesante) sea el objeto para el usuario, m√°s cerca estar√° al principio de la lista de recomendaciones.  Sin embargo, con este orden, a menudo surgen situaciones en las que varios objetos del mismo tipo aparecen en la lista de recomendaciones.  Esto empeora en gran medida la variedad externa de nuestras recomendaciones y, por lo tanto, a los usuarios no les gusta.  Es necesario implementar un algoritmo que, de acuerdo con la lista de recomendaciones, constituir√° una nueva lista que estar√° libre de este problema y ser√° m√°s relevante. <br><br>  Sea una lista inicial de recomendaciones a = [a <sub>0</sub> , a <sub>1</sub> , ..., a <sub>n - 1</sub> ] de longitud n&gt; 0. Un objeto con n√∫mero i tiene tipo con n√∫mero b <sub>i</sub> b {0, ..., m - 1}.  Adem√°s, un objeto bajo el n√∫mero i tiene relevancia r (a <sub>i</sub> ) = 2 <sub>‚àíi</sub> .  Considere la lista que se obtiene de la inicial eligiendo un subconjunto de objetos y su permutaci√≥n: x = [a <sub>i <sub>0</sub></sub> , a <sub>i <sub>1</sub></sub> , ..., a <sub>i <sub>k - 1</sub></sub> ] de longitud k (0 ‚â§ k ‚â§ n).  Una lista se llama admisible si no coinciden dos objetos consecutivos en ella, es decir, b <sub>i <sub>j</sub></sub> ‚â† b <sub>i <sub>j + 1</sub></sub> para todo j = 0, ..., k - 2.  La relevancia de la lista se calcula mediante la f√≥rmula. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhiTWgu2tKqM4zBfm2wCbdyAdOoVAA#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>‚àí</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  Necesita encontrar la lista de relevancia m√°xima entre todas las v√°lidas. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S y ejemplos</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  En la primera l√≠nea, los n√∫meros n y m se escriben con un espacio (1 ‚â§ n ‚â§ 100000, 1 ‚â§ m ‚â§ n).  Las siguientes n l√≠neas contienen los n√∫meros b <sub>i</sub> para i = 0, ..., n - 1 (0 ‚â§ b <sub>i</sub> ‚â§ m - 1). <br><br><h4>  Formato de salida </h4><br>  Escriba, con un espacio, el n√∫mero de objetos en la lista final: i <sub>0</sub> , i <sub>1</sub> , ..., i <sub>k - 1</sub> . <br><br><h4>  Ejemplo 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Ejemplo 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Ejemplo 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Soluci√≥n </h4><br>  Utilizando c√°lculos matem√°ticos simples, se puede demostrar que el problema se puede resolver mediante un enfoque "codicioso", es decir, en la lista √≥ptima de recomendaciones, cada elemento tiene el objeto m√°s relevante de todos los que son v√°lidos al mismo comienzo de la lista.  La implementaci√≥n de este enfoque es simple: tomamos objetos en una fila y los agregamos a la respuesta, si es posible.  Cuando se encuentra un objeto no v√°lido (cuyo tipo coincide con el tipo del anterior), lo ponemos a un lado en una cola separada, desde la cual lo insertamos en la respuesta lo antes posible.  Tenga en cuenta que en todo momento, todos los objetos en esta cola tendr√°n un tipo coincidente.  Al final, varios objetos pueden permanecer en la cola, ya no se incluir√°n en la respuesta. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2>  D. Clusterizaci√≥n de secuencias de caracteres. </h2><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Todos los idiomas</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  L√≠mite de tiempo </td><td>  1 s </td><td>  6 s </td><td>  6 s </td></tr><tr><td>  L√≠mite de memoria </td><td>  64 MB </td><td>  64 MB </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td colspan="3">  entrada est√°ndar o input.txt </td></tr><tr><td>  Conclusi√≥n </td><td colspan="3">  salida est√°ndar o salida.txt </td></tr></tbody></table></div>  Hay un alfabeto finito A = {a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>K - 1</sub> , a <sub>K</sub> = S}, a <sub>i</sub> ‚àà {a, b, ..., z}, S es el final de la l√≠nea. <br><br>  Considere el siguiente m√©todo para generar cadenas aleatorias sobre el alfabeto A: <br><br>  1. El primer car√°cter x <sub>1</sub> es una variable aleatoria con la distribuci√≥n P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (se sabe que q <sub>K</sub> = 0). <br>  2. Cada siguiente car√°cter se genera en base al anterior de acuerdo con la distribuci√≥n condicional P (x <sub>i</sub> = a <sub>j</sub> || x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. Si x <sub>i</sub> = S, la generaci√≥n se detiene y el resultado es x <sub>1</sub> x <sub>2</sub> ... x <sub>i - 1</sub> . <br><br>  Se da el conjunto de l√≠neas generadas a partir de una mezcla de dos modelos descritos con diferentes par√°metros.  Es necesario que cada fila proporcione el √≠ndice de la cadena a partir de la cual se gener√≥. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S, ejemplo y notas</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  La primera l√≠nea contiene dos n√∫meros 1000 ‚â§ N ‚â§ 2000 y 3 ‚â§ K ‚â§ 27: el n√∫mero de l√≠neas y el tama√±o del alfabeto, respectivamente. <br><br>  La segunda l√≠nea contiene una l√≠nea que consta de K - 1 letras min√∫sculas diferentes del alfabeto latino, que indican los primeros elementos K - 1 del alfabeto. <br><br>  Cada una de las siguientes N l√≠neas se genera de acuerdo con el algoritmo descrito en la condici√≥n. <br><br><h4>  Formato de salida </h4><br>  N l√≠neas, la l√≠nea i-√©sima contiene el n√∫mero de cl√∫ster (0/1) para la secuencia en la l√≠nea i + 1-th del archivo de entrada.  La coincidencia con la respuesta verdadera debe ser al menos del 80%. <br><br><h4>  Ejemplo </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclusi√≥n</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4>  Notas </h4><br>  Nota para la prueba de la condici√≥n: en ella se generan las primeras 50 l√≠neas de la distribuci√≥n <br>  P (x <sub>i</sub> = a | x <sub>i - 1</sub> = a) = 0.5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = a) = 0.5, P (x <sub>1</sub> = a) = 1;  segundo 50 - de distribuci√≥n <br>  P (x <sub>i</sub> = b | x <sub>i - 1</sub> = b) = 0.5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = b) = 0.5, P (x <sub>1</sub> = b) = 1. </div></div><br><h4>  Soluci√≥n </h4><br>  El problema se resuelve utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo EM</a> : se supone que la muestra presentada se genera a partir de una mezcla de dos cadenas de Markov cuyos par√°metros se restauran durante las iteraciones.  Se realiza una restricci√≥n del 80% de las respuestas correctas para que la correcci√≥n de la soluci√≥n no se vea afectada por ejemplos que tienen una alta probabilidad en ambas cadenas.  Por lo tanto, estos ejemplos, cuando se restauran correctamente, se pueden asignar a una cadena que es incorrecta en t√©rminos de la respuesta generada. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461273/">https://habr.com/ru/post/461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461261/index.html">Lista de verificaci√≥n de seminarios web √∫tiles de RRC sobre productos de RRC</a></li>
<li><a href="../461265/index.html">Sobre el abuso del uso del sistema operativo en proyectos para microcontroladores</a></li>
<li><a href="../461267/index.html">Nuevas tecnolog√≠as Intel para el empaquetado de chips</a></li>
<li><a href="../461269/index.html">La soluci√≥n de trabajo con pwnable.kr 08 es pierna y 10 es shellshock. Ensamblador de BRAZOS. Vulnerabilidad de Bash</a></li>
<li><a href="../461271/index.html">C√≥mo promocionar una aplicaci√≥n m√≥vil en 2019: 4 formas pr√°cticas + herramientas √∫tiles</a></li>
<li><a href="../461277/index.html">Descripci√≥n general de la herramienta gratuita SQLIndexManager</a></li>
<li><a href="../461279/index.html">C√≥mo crear un microservicio simple en Golang y gRPC y ponerlo en contenedores usando Docker</a></li>
<li><a href="../461281/index.html">Tutorial para configurar un servidor DNS BIND en un entorno chroot para Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../461283/index.html">Arquitectura de software y dise√±o de sistemas: el panorama general y la gu√≠a de recursos</a></li>
<li><a href="../461285/index.html">5 algoritmos de muestreo principales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>