<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏿 🤪 ↪️ Le backend pour le frontend, ou comment Yandex.Market crée une API sans béquilles 🧛🏾 👂🏿 👩🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi certaines API sont-elles plus pratiques à utiliser que d'autres? Que pouvons-nous faire en tant que fournisseurs frontaux de notre côté pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le backend pour le frontend, ou comment Yandex.Market crée une API sans béquilles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428141/"><p>  Pourquoi certaines API sont-elles plus pratiques à utiliser que d'autres?  Que pouvons-nous faire en tant que fournisseurs frontaux de notre côté pour travailler avec une API de qualité acceptable?  Aujourd'hui, je parlerai aux lecteurs de Habr à la fois des options techniques et des mesures organisationnelles qui aideront les fournisseurs frontaux et principaux à trouver un langage commun et à établir un travail efficace. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  Cet automne, Yandex.Market fête ses 18 ans.  Pendant tout ce temps, l'interface d'affiliation du marché s'est développée.  En bref, c'est le panneau d'administration avec lequel les magasins peuvent télécharger des catalogues, travailler avec l'assortiment, surveiller les statistiques, répondre aux avis, etc.  Les spécificités du projet sont telles que vous devez beaucoup interagir avec différents backends.  Cependant, les données ne peuvent pas toujours être obtenues en un seul endroit, à partir d'un backend spécifique. </p><br><p><a name="habracut"></a></p><h3>  Symptômes d'un problème </h3><br>  Alors, imaginez, il y avait une sorte de problème.  Le gestionnaire confie la tâche aux concepteurs - ils dessinent la mise en page.  Puis il va au back-end - ils font des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plumes</a> et écrivent une liste de paramètres et le format de réponse sur le wiki interne. <br><p>  Ensuite, le gestionnaire passe au front-end avec les mots «Je vous ai apporté l'API» et vous propose de tout scénariser rapidement, car, selon lui, presque tout le travail a déjà été fait. </p><br><p>  Vous regardez la documentation et voyez ceci: </p><br><pre><code class="xml hljs">№ |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Ne remarquez rien d'étrange?  Camel, Snake and Kebab Case dans un seul stylo.  Je ne parle pas du paramètre fesh.  Qu'est-ce que le fesh?  Un tel mot n'existe même pas.  Essayez de deviner avant d'ouvrir le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh est un filtre par ID de magasin.  Vous pouvez passer plusieurs identifiants séparés par des virgules.  Un identifiant peut être précédé d'un signe moins, ce qui signifie que ce magasin doit être exclu des résultats. </p></div></div><br><p>  En même temps, à partir de JavaSctipt, bien sûr, je ne peux pas accéder aux propriétés d'un tel objet via la notation en pointillés.  Sans parler du fait que si vous avez plus de 50 paramètres à un endroit, alors, évidemment, dans votre vie, vous vous êtes tourné ailleurs. </p><br><p>  Il existe de nombreuses options pour une API peu pratique.  Un exemple classique - l'API recherche et renvoie des résultats: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Si les marchandises sont trouvées, nous obtenons un tableau.  Si un produit est trouvé, nous obtenons un objet avec ce produit.  Si rien n'est trouvé, alors au mieux, nous obtenons null.  Dans le pire des cas, le backend répond avec 404 ou même 400 (Bad Request). </p><br><p>  Les situations sont plus faciles.  Par exemple, vous devez obtenir une liste de magasins dans un backend et stocker les paramètres dans un autre.  Dans certains enclos, il n'y a pas assez de données, dans certaines données il y en a trop.  Filtrer tout cela sur le client ou faire plusieurs requêtes ajax est une mauvaise idée. </p><br><p>  Alors, quelles peuvent être les solutions à ce problème?  Que pouvons-nous faire en tant que fournisseurs frontaux de notre côté pour travailler avec une API de qualité acceptable? </p><br><h3>  Backend frontend </h3><br><p>  Nous utilisons le client React / Redux dans l'interface partenaire.  Sous le client se trouve Node.js, qui fait beaucoup de choses auxiliaires, par exemple, le jette sur la page InitialState pour les éditeurs.  Si vous avez un rendu côté serveur, peu importe avec quelle infrastructure client, il est très probable qu'il soit rendu par un nœud.  Mais que se passe-t-il si vous allez plus loin et que vous ne contactez pas directement le client dans le backend, mais que vous créez votre API proxy sur le nœud, au maximum adaptée aux besoins du client? <br>  Cette technique est appelée BFF (Backend For Frontend).  Ce terme a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduit pour la</a> première <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fois par</a> SoundCloud en 2015, et l'idée peut être schématisée comme suit: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Ainsi, vous arrêtez de passer du code client directement à l'API.  Chaque poignée, chaque méthode de la véritable API que vous dupliquez sur le nœud et du client va exclusivement au nœud.  Et le nœud envoie déjà la requête par procuration à la véritable API et vous renvoie une réponse. </p><br><p>  Cela s'applique non seulement aux requêtes get primitives, mais généralement à toutes les requêtes, y compris avec les données en plusieurs parties / formulaires.  Par exemple, un magasin télécharge un fichier .xls avec son catalogue via un formulaire sur un site.  Ainsi, dans cette implémentation, le répertoire n'est pas chargé directement dans l'API, mais dans votre handle Nod, qui procède à un streaming vers un véritable backend. </p><br><p>  Vous vous souvenez de cet exemple avec résultat lorsque le backend a retourné null, un tableau ou un objet?  Maintenant, nous pouvons le ramener à la normale - quelque chose comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  Ce code a l'air horrible.  Parce qu'il est terrible.  Mais nous devons encore le faire.  Nous avons le choix: faites-le sur le serveur ou sur le client.  Je choisis un serveur. </p><br><p>  Nous pouvons également mapper tous ces cas de kebab et de serpent dans un style qui nous convient et immédiatement mettre la valeur par défaut si nécessaire. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  Quels autres avantages obtenons-nous? </p><br><ol><li>  <strong>Filtrage</strong> .  Le client ne reçoit que ce dont il a besoin, ni plus, ni moins. </li><li>  <strong>Agrégation</strong>  Pas besoin de gaspiller le réseau client et la batterie pour faire plusieurs demandes ajax.  Un gain de vitesse notable dû au fait que l'ouverture d'une connexion est une opération coûteuse. </li><li>  <strong>Mise en cache</strong>  Votre appel groupé répété n'attirera plus personne, mais renvoie simplement 304 Non modifié. </li><li>  <strong>Masquage des</strong> données.  Par exemple, vous pouvez avoir des jetons nécessaires entre les backends et ne pas aller au client.  Le client peut ne pas avoir le droit de connaître l'existence de ces jetons, sans parler de leur contenu. </li><li>  <strong>Microservices</strong> .  Si vous avez un monolithe à l'arrière, alors BFF est la première étape des microservices. </li></ol><br><p>  Maintenant sur les inconvénients. </p><br><ol><li>  <strong>Difficulté</strong> croissante.  Toute abstraction est une autre couche qui doit être codée, déployée, prise en charge.  Une autre partie mobile du mécanisme qui peut échouer. </li><li>  <strong>Duplication des</strong> poignées.  Par exemple, plusieurs points de terminaison peuvent effectuer le même type d'agrégation. </li><li>  BFF est une <strong>couche limite</strong> qui doit prendre en charge le routage général, les restrictions des droits des utilisateurs, la journalisation des requêtes, etc. </li></ol><br><p>  Pour niveler ces inconvénients, il suffit d'adhérer à des règles simples.  La première consiste à séparer la logique frontale et la logique métier.  Votre BFF ne doit pas modifier la logique métier de l'API principale.  Deuxièmement, votre couche ne doit convertir les données qu'en cas de nécessité absolue.  Nous ne parlons pas d'une API complète et autonome, mais uniquement d'un proxy qui comble le vide et corrige les failles du backend. </p><br><h3>  GraphQL </h3><br><p>  GraphQL résout des problèmes similaires.  Avec GraphQL, au lieu de nombreux points de terminaison «stupides», vous disposez d'un stylet intelligent qui peut travailler avec des requêtes complexes et générer des données sous la forme dans laquelle le client le demande. </p><br><p>  Dans le même temps, GraphQL peut fonctionner au-dessus de REST, c'est-à-dire que la source de données n'est pas la base de données, mais l'API de repos.  En raison de la nature déclarative de GraphQL, du fait que tout cela est ami avec React et Editors, votre client devient plus facile. </p><br><p>  En fait, je vois GraphQL comme une implémentation de BFF avec son protocole et son langage de requête strict. </p><br><p>  C'est une excellente solution, mais elle présente plusieurs inconvénients, en particulier avec la typification, la différenciation des droits, et en général c'est une approche relativement nouvelle.  Par conséquent, nous n'y sommes pas encore passés, mais à l'avenir, il me semble que le moyen le plus optimal pour créer une API. </p><br><h3>  Meilleurs amis pour toujours </h3><br><p>  Aucune solution technique ne fonctionnera correctement sans changements organisationnels.  Vous avez toujours besoin de documentation, de garanties que le format de réponse ne changera pas subitement, etc. </p><br><p>  Il faut comprendre que nous sommes tous dans le même bateau.  Pour un client abstrait, que ce soit un manager ou votre manager, cela ne fait aucune différence - vous avez GraphQL ou BFF.  Il est plus important pour lui que le problème soit résolu et que les erreurs n'apparaissent pas sur le prod.  Pour lui, il n'y a pas beaucoup de différence en raison de la faute à laquelle une erreur s'est produite dans le produit - par la faute de l'avant ou de l'arrière.  Par conséquent, vous devez négocier avec les backders. </p><br><p>  De plus, les défauts dans le dos dont j'ai parlé au début du rapport ne se produisent pas toujours en raison des actions malveillantes de quelqu'un.  Il est possible que le paramètre fesh ait également une signification. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Faites attention à la date du commit.  Il s'avère que fesh a récemment célébré son dix-septième anniversaire. </p><br><p>  Vous voyez des identifiants étranges sur la gauche?  C'est SVN, simplement parce qu'il n'y avait pas de gita en 2001.  Pas un github en tant que service, mais un github en tant que système de contrôle de version.  Il n'est apparu qu'en 2005. </p><br><h3>  La documentation </h3><br><p>  Donc, tout ce dont nous avons besoin n'est pas de nous disputer avec le back-end, mais d'être d'accord.  Cela ne peut être fait que si nous trouvons une seule source de vérité.  Cette source devrait être la documentation. </p><br><p>  La chose la plus importante ici est d'écrire de la documentation avant de commencer à travailler sur les fonctionnalités.  Comme pour un accord prénuptial, il vaut mieux se mettre d'accord sur tout sur le rivage. </p><br><p>  Comment ça marche?  Relativement parlant, trois vont: manager, front-end et back-end.  Fronteder connaît bien le sujet, sa participation est donc d'une importance cruciale.  Ils se réunissent et commencent à réfléchir à l'API: de quelles manières, quelles réponses doivent être retournées, jusqu'au nom et au format des champs. </p><br><h3>  Swagger </h3><br><p>  Une bonne option pour la documentation de l'API est le format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swagger</a> , maintenant appelé OpenAPI.  Il est préférable d'utiliser Swagger au format YAML, car, contrairement à JSON, il est mieux lu par les humains, mais il n'y a pas de différence pour la machine. </p><br><p>  Par conséquent, tous les accords sont fixés au format Swagger et publiés dans un référentiel commun.  La documentation du backend de vente doit être dans l'assistant. </p><br><p>  Le maître est protégé contre les validations, le code n'y entre que via le pool de requêtes, vous ne pouvez pas le pousser.  Le représentant de l'équipe de front est obligé de procéder à un examen du pool de demandes, sans sa mise à niveau le code ne va pas au maître.  Cela vous protège des modifications inattendues de l'API sans préavis. </p><br><p>  Alors vous vous êtes réunis, a écrit Swagger, donc vous avez signé le contrat.  A partir de ce moment, vous en tant que front-end pouvez commencer votre travail sans attendre la création d'une véritable API.  Après tout, quel était le point de séparation entre le client et le serveur, si nous ne pouvons pas travailler en parallèle et que les développeurs clients doivent attendre les développeurs de serveurs?  Si nous avons un «contrat», nous pouvons paralléliser cette question en toute sécurité. </p><br><h3>  Faker.js </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faker</a> est idéal à ces fins.  Il s'agit d'une bibliothèque pour générer une énorme quantité de fausses données.  Il peut générer différents types de données: dates, noms, adresses, etc., tout cela est bien localisé, il y a un support pour la langue russe. </p><br><p>  En même temps, le truqueur est ami avec le fanfaron, et vous pouvez tranquillement lever le serveur Mock, qui, basé sur le schéma Swagger, vous générera de fausses réponses le long des chemins nécessaires. </p><br><h3>  Validation </h3><br><p>  Swagger peut être converti en schéma json, et à l'aide d'outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajv,</a> vous pouvez valider les réponses du backend directement dans le runtime, dans votre BFF, et signaler les testeurs, les backenders eux-mêmes, en cas de divergences, etc. </p><br><p>  Supposons qu'un testeur trouve une sorte de bogue sur le site, par exemple, lorsqu'un bouton est cliqué, rien ne se passe.  Que fait le testeur?  Il met un ticket sur le front-end: "c'est ton bouton, il n'est pas pressé, répare-le." </p><br><p>  S'il y a un validateur entre vous et l'arrière, le testeur saura que le bouton est réellement enfoncé, seul le backend envoie la mauvaise réponse.  Faux - c'est une réponse à laquelle le front ne s'attend pas, c'est-à-dire qu'il ne correspond pas au «contrat».  Et ici, il est déjà nécessaire de réparer le dos ou de modifier le contrat. </p><br><h3>  Conclusions </h3><br><ol><li>  Nous sommes activement impliqués dans la conception de l'API.  Nous concevons l'API de manière à ce qu'elle soit pratique à utiliser après 17 ans. </li><li>  Nous avons besoin de la documentation Swagger.  Aucune documentation - l'opération principale n'a pas été terminée. </li><li>  Il existe de la documentation - nous la publions dans git, et toute modification de l'API doit être mise à jour par le représentant de l'équipe de front. </li><li>  Nous élevons le faux serveur et commençons à travailler sur le front sans attendre la vraie API. </li><li>  Nous plaçons le nœud sous le frontend et validons toutes les réponses.  De plus, nous avons la possibilité d'agréger, de normaliser et de mettre en cache les données. </li></ol><br><h4>  Voir aussi </h4><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment construire une API de type REST dans un grand projet</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Backend dans le frontend</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de GraphQL comme implémentation de modèle BFF</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428141/">https://habr.com/ru/post/fr428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428129/index.html">Une logique floue simple collée «de ce qui était» pour un moteur à turbine à gaz</a></li>
<li><a href="../fr428131/index.html">Toute la vérité sur RTOS. Article # 17. Groupes de drapeaux d'événements: introduction et services de base</a></li>
<li><a href="../fr428133/index.html">Hasura. Architecture GraphQL à SQL Server haute performance</a></li>
<li><a href="../fr428135/index.html">Comment configurer ou désactiver les peluches dans l'éditeur de code intégré</a></li>
<li><a href="../fr428137/index.html">Olympiade, concours d'idées, conférences sur la gestion de projets informatiques et projections de films: 10 événements à venir à l'Université ITMO</a></li>
<li><a href="../fr428143/index.html">Approche de mise en œuvre de ReactJS RBAC</a></li>
<li><a href="../fr428147/index.html">Script pour collecter des citations et reconnaître le texte d'une vidéo en Python</a></li>
<li><a href="../fr428149/index.html">Votre nouvel allié Mavic 2 Enterprise Sky</a></li>
<li><a href="../fr428151/index.html">Examen des performances de PostgreSQL 10.5 dans les derniers services cloud Yandex.Cloud</a></li>
<li><a href="../fr428155/index.html">Limite de vitesse pour les véhicules électriques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>