<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¿ ğŸ¤ª â†ªï¸ Le backend pour le frontend, ou comment Yandex.Market crÃ©e une API sans bÃ©quilles ğŸ§›ğŸ¾ ğŸ‘‚ğŸ¿ ğŸ‘©ğŸ¼â€ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi certaines API sont-elles plus pratiques Ã  utiliser que d'autres? Que pouvons-nous faire en tant que fournisseurs frontaux de notre cÃ´tÃ© pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le backend pour le frontend, ou comment Yandex.Market crÃ©e une API sans bÃ©quilles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428141/"><p>  Pourquoi certaines API sont-elles plus pratiques Ã  utiliser que d'autres?  Que pouvons-nous faire en tant que fournisseurs frontaux de notre cÃ´tÃ© pour travailler avec une API de qualitÃ© acceptable?  Aujourd'hui, je parlerai aux lecteurs de Habr Ã  la fois des options techniques et des mesures organisationnelles qui aideront les fournisseurs frontaux et principaux Ã  trouver un langage commun et Ã  Ã©tablir un travail efficace. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  Cet automne, Yandex.Market fÃªte ses 18 ans.  Pendant tout ce temps, l'interface d'affiliation du marchÃ© s'est dÃ©veloppÃ©e.  En bref, c'est le panneau d'administration avec lequel les magasins peuvent tÃ©lÃ©charger des catalogues, travailler avec l'assortiment, surveiller les statistiques, rÃ©pondre aux avis, etc.  Les spÃ©cificitÃ©s du projet sont telles que vous devez beaucoup interagir avec diffÃ©rents backends.  Cependant, les donnÃ©es ne peuvent pas toujours Ãªtre obtenues en un seul endroit, Ã  partir d'un backend spÃ©cifique. </p><br><p><a name="habracut"></a></p><h3>  SymptÃ´mes d'un problÃ¨me </h3><br>  Alors, imaginez, il y avait une sorte de problÃ¨me.  Le gestionnaire confie la tÃ¢che aux concepteurs - ils dessinent la mise en page.  Puis il va au back-end - ils font des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plumes</a> et Ã©crivent une liste de paramÃ¨tres et le format de rÃ©ponse sur le wiki interne. <br><p>  Ensuite, le gestionnaire passe au front-end avec les mots Â«Je vous ai apportÃ© l'APIÂ» et vous propose de tout scÃ©nariser rapidement, car, selon lui, presque tout le travail a dÃ©jÃ  Ã©tÃ© fait. </p><br><p>  Vous regardez la documentation et voyez ceci: </p><br><pre><code class="xml hljs">â„– |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Ne remarquez rien d'Ã©trange?  Camel, Snake and Kebab Case dans un seul stylo.  Je ne parle pas du paramÃ¨tre fesh.  Qu'est-ce que le fesh?  Un tel mot n'existe mÃªme pas.  Essayez de deviner avant d'ouvrir le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh est un filtre par ID de magasin.  Vous pouvez passer plusieurs identifiants sÃ©parÃ©s par des virgules.  Un identifiant peut Ãªtre prÃ©cÃ©dÃ© d'un signe moins, ce qui signifie que ce magasin doit Ãªtre exclu des rÃ©sultats. </p></div></div><br><p>  En mÃªme temps, Ã  partir de JavaSctipt, bien sÃ»r, je ne peux pas accÃ©der aux propriÃ©tÃ©s d'un tel objet via la notation en pointillÃ©s.  Sans parler du fait que si vous avez plus de 50 paramÃ¨tres Ã  un endroit, alors, Ã©videmment, dans votre vie, vous vous Ãªtes tournÃ© ailleurs. </p><br><p>  Il existe de nombreuses options pour une API peu pratique.  Un exemple classique - l'API recherche et renvoie des rÃ©sultats: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Si les marchandises sont trouvÃ©es, nous obtenons un tableau.  Si un produit est trouvÃ©, nous obtenons un objet avec ce produit.  Si rien n'est trouvÃ©, alors au mieux, nous obtenons null.  Dans le pire des cas, le backend rÃ©pond avec 404 ou mÃªme 400 (Bad Request). </p><br><p>  Les situations sont plus faciles.  Par exemple, vous devez obtenir une liste de magasins dans un backend et stocker les paramÃ¨tres dans un autre.  Dans certains enclos, il n'y a pas assez de donnÃ©es, dans certaines donnÃ©es il y en a trop.  Filtrer tout cela sur le client ou faire plusieurs requÃªtes ajax est une mauvaise idÃ©e. </p><br><p>  Alors, quelles peuvent Ãªtre les solutions Ã  ce problÃ¨me?  Que pouvons-nous faire en tant que fournisseurs frontaux de notre cÃ´tÃ© pour travailler avec une API de qualitÃ© acceptable? </p><br><h3>  Backend frontend </h3><br><p>  Nous utilisons le client React / Redux dans l'interface partenaire.  Sous le client se trouve Node.js, qui fait beaucoup de choses auxiliaires, par exemple, le jette sur la page InitialState pour les Ã©diteurs.  Si vous avez un rendu cÃ´tÃ© serveur, peu importe avec quelle infrastructure client, il est trÃ¨s probable qu'il soit rendu par un nÅ“ud.  Mais que se passe-t-il si vous allez plus loin et que vous ne contactez pas directement le client dans le backend, mais que vous crÃ©ez votre API proxy sur le nÅ“ud, au maximum adaptÃ©e aux besoins du client? <br>  Cette technique est appelÃ©e BFF (Backend For Frontend).  Ce terme a Ã©tÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduit pour la</a> premiÃ¨re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fois par</a> SoundCloud en 2015, et l'idÃ©e peut Ãªtre schÃ©matisÃ©e comme suit: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Ainsi, vous arrÃªtez de passer du code client directement Ã  l'API.  Chaque poignÃ©e, chaque mÃ©thode de la vÃ©ritable API que vous dupliquez sur le nÅ“ud et du client va exclusivement au nÅ“ud.  Et le nÅ“ud envoie dÃ©jÃ  la requÃªte par procuration Ã  la vÃ©ritable API et vous renvoie une rÃ©ponse. </p><br><p>  Cela s'applique non seulement aux requÃªtes get primitives, mais gÃ©nÃ©ralement Ã  toutes les requÃªtes, y compris avec les donnÃ©es en plusieurs parties / formulaires.  Par exemple, un magasin tÃ©lÃ©charge un fichier .xls avec son catalogue via un formulaire sur un site.  Ainsi, dans cette implÃ©mentation, le rÃ©pertoire n'est pas chargÃ© directement dans l'API, mais dans votre handle Nod, qui procÃ¨de Ã  un streaming vers un vÃ©ritable backend. </p><br><p>  Vous vous souvenez de cet exemple avec rÃ©sultat lorsque le backend a retournÃ© null, un tableau ou un objet?  Maintenant, nous pouvons le ramener Ã  la normale - quelque chose comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  Ce code a l'air horrible.  Parce qu'il est terrible.  Mais nous devons encore le faire.  Nous avons le choix: faites-le sur le serveur ou sur le client.  Je choisis un serveur. </p><br><p>  Nous pouvons Ã©galement mapper tous ces cas de kebab et de serpent dans un style qui nous convient et immÃ©diatement mettre la valeur par dÃ©faut si nÃ©cessaire. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  Quels autres avantages obtenons-nous? </p><br><ol><li>  <strong>Filtrage</strong> .  Le client ne reÃ§oit que ce dont il a besoin, ni plus, ni moins. </li><li>  <strong>AgrÃ©gation</strong>  Pas besoin de gaspiller le rÃ©seau client et la batterie pour faire plusieurs demandes ajax.  Un gain de vitesse notable dÃ» au fait que l'ouverture d'une connexion est une opÃ©ration coÃ»teuse. </li><li>  <strong>Mise en cache</strong>  Votre appel groupÃ© rÃ©pÃ©tÃ© n'attirera plus personne, mais renvoie simplement 304 Non modifiÃ©. </li><li>  <strong>Masquage des</strong> donnÃ©es.  Par exemple, vous pouvez avoir des jetons nÃ©cessaires entre les backends et ne pas aller au client.  Le client peut ne pas avoir le droit de connaÃ®tre l'existence de ces jetons, sans parler de leur contenu. </li><li>  <strong>Microservices</strong> .  Si vous avez un monolithe Ã  l'arriÃ¨re, alors BFF est la premiÃ¨re Ã©tape des microservices. </li></ol><br><p>  Maintenant sur les inconvÃ©nients. </p><br><ol><li>  <strong>DifficultÃ©</strong> croissante.  Toute abstraction est une autre couche qui doit Ãªtre codÃ©e, dÃ©ployÃ©e, prise en charge.  Une autre partie mobile du mÃ©canisme qui peut Ã©chouer. </li><li>  <strong>Duplication des</strong> poignÃ©es.  Par exemple, plusieurs points de terminaison peuvent effectuer le mÃªme type d'agrÃ©gation. </li><li>  BFF est une <strong>couche limite</strong> qui doit prendre en charge le routage gÃ©nÃ©ral, les restrictions des droits des utilisateurs, la journalisation des requÃªtes, etc. </li></ol><br><p>  Pour niveler ces inconvÃ©nients, il suffit d'adhÃ©rer Ã  des rÃ¨gles simples.  La premiÃ¨re consiste Ã  sÃ©parer la logique frontale et la logique mÃ©tier.  Votre BFF ne doit pas modifier la logique mÃ©tier de l'API principale.  DeuxiÃ¨mement, votre couche ne doit convertir les donnÃ©es qu'en cas de nÃ©cessitÃ© absolue.  Nous ne parlons pas d'une API complÃ¨te et autonome, mais uniquement d'un proxy qui comble le vide et corrige les failles du backend. </p><br><h3>  GraphQL </h3><br><p>  GraphQL rÃ©sout des problÃ¨mes similaires.  Avec GraphQL, au lieu de nombreux points de terminaison Â«stupidesÂ», vous disposez d'un stylet intelligent qui peut travailler avec des requÃªtes complexes et gÃ©nÃ©rer des donnÃ©es sous la forme dans laquelle le client le demande. </p><br><p>  Dans le mÃªme temps, GraphQL peut fonctionner au-dessus de REST, c'est-Ã -dire que la source de donnÃ©es n'est pas la base de donnÃ©es, mais l'API de repos.  En raison de la nature dÃ©clarative de GraphQL, du fait que tout cela est ami avec React et Editors, votre client devient plus facile. </p><br><p>  En fait, je vois GraphQL comme une implÃ©mentation de BFF avec son protocole et son langage de requÃªte strict. </p><br><p>  C'est une excellente solution, mais elle prÃ©sente plusieurs inconvÃ©nients, en particulier avec la typification, la diffÃ©renciation des droits, et en gÃ©nÃ©ral c'est une approche relativement nouvelle.  Par consÃ©quent, nous n'y sommes pas encore passÃ©s, mais Ã  l'avenir, il me semble que le moyen le plus optimal pour crÃ©er une API. </p><br><h3>  Meilleurs amis pour toujours </h3><br><p>  Aucune solution technique ne fonctionnera correctement sans changements organisationnels.  Vous avez toujours besoin de documentation, de garanties que le format de rÃ©ponse ne changera pas subitement, etc. </p><br><p>  Il faut comprendre que nous sommes tous dans le mÃªme bateau.  Pour un client abstrait, que ce soit un manager ou votre manager, cela ne fait aucune diffÃ©rence - vous avez GraphQL ou BFF.  Il est plus important pour lui que le problÃ¨me soit rÃ©solu et que les erreurs n'apparaissent pas sur le prod.  Pour lui, il n'y a pas beaucoup de diffÃ©rence en raison de la faute Ã  laquelle une erreur s'est produite dans le produit - par la faute de l'avant ou de l'arriÃ¨re.  Par consÃ©quent, vous devez nÃ©gocier avec les backders. </p><br><p>  De plus, les dÃ©fauts dans le dos dont j'ai parlÃ© au dÃ©but du rapport ne se produisent pas toujours en raison des actions malveillantes de quelqu'un.  Il est possible que le paramÃ¨tre fesh ait Ã©galement une signification. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Faites attention Ã  la date du commit.  Il s'avÃ¨re que fesh a rÃ©cemment cÃ©lÃ©brÃ© son dix-septiÃ¨me anniversaire. </p><br><p>  Vous voyez des identifiants Ã©tranges sur la gauche?  C'est SVN, simplement parce qu'il n'y avait pas de gita en 2001.  Pas un github en tant que service, mais un github en tant que systÃ¨me de contrÃ´le de version.  Il n'est apparu qu'en 2005. </p><br><h3>  La documentation </h3><br><p>  Donc, tout ce dont nous avons besoin n'est pas de nous disputer avec le back-end, mais d'Ãªtre d'accord.  Cela ne peut Ãªtre fait que si nous trouvons une seule source de vÃ©ritÃ©.  Cette source devrait Ãªtre la documentation. </p><br><p>  La chose la plus importante ici est d'Ã©crire de la documentation avant de commencer Ã  travailler sur les fonctionnalitÃ©s.  Comme pour un accord prÃ©nuptial, il vaut mieux se mettre d'accord sur tout sur le rivage. </p><br><p>  Comment Ã§a marche?  Relativement parlant, trois vont: manager, front-end et back-end.  Fronteder connaÃ®t bien le sujet, sa participation est donc d'une importance cruciale.  Ils se rÃ©unissent et commencent Ã  rÃ©flÃ©chir Ã  l'API: de quelles maniÃ¨res, quelles rÃ©ponses doivent Ãªtre retournÃ©es, jusqu'au nom et au format des champs. </p><br><h3>  Swagger </h3><br><p>  Une bonne option pour la documentation de l'API est le format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swagger</a> , maintenant appelÃ© OpenAPI.  Il est prÃ©fÃ©rable d'utiliser Swagger au format YAML, car, contrairement Ã  JSON, il est mieux lu par les humains, mais il n'y a pas de diffÃ©rence pour la machine. </p><br><p>  Par consÃ©quent, tous les accords sont fixÃ©s au format Swagger et publiÃ©s dans un rÃ©fÃ©rentiel commun.  La documentation du backend de vente doit Ãªtre dans l'assistant. </p><br><p>  Le maÃ®tre est protÃ©gÃ© contre les validations, le code n'y entre que via le pool de requÃªtes, vous ne pouvez pas le pousser.  Le reprÃ©sentant de l'Ã©quipe de front est obligÃ© de procÃ©der Ã  un examen du pool de demandes, sans sa mise Ã  niveau le code ne va pas au maÃ®tre.  Cela vous protÃ¨ge des modifications inattendues de l'API sans prÃ©avis. </p><br><p>  Alors vous vous Ãªtes rÃ©unis, a Ã©crit Swagger, donc vous avez signÃ© le contrat.  A partir de ce moment, vous en tant que front-end pouvez commencer votre travail sans attendre la crÃ©ation d'une vÃ©ritable API.  AprÃ¨s tout, quel Ã©tait le point de sÃ©paration entre le client et le serveur, si nous ne pouvons pas travailler en parallÃ¨le et que les dÃ©veloppeurs clients doivent attendre les dÃ©veloppeurs de serveurs?  Si nous avons un Â«contratÂ», nous pouvons parallÃ©liser cette question en toute sÃ©curitÃ©. </p><br><h3>  Faker.js </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faker</a> est idÃ©al Ã  ces fins.  Il s'agit d'une bibliothÃ¨que pour gÃ©nÃ©rer une Ã©norme quantitÃ© de fausses donnÃ©es.  Il peut gÃ©nÃ©rer diffÃ©rents types de donnÃ©es: dates, noms, adresses, etc., tout cela est bien localisÃ©, il y a un support pour la langue russe. </p><br><p>  En mÃªme temps, le truqueur est ami avec le fanfaron, et vous pouvez tranquillement lever le serveur Mock, qui, basÃ© sur le schÃ©ma Swagger, vous gÃ©nÃ©rera de fausses rÃ©ponses le long des chemins nÃ©cessaires. </p><br><h3>  Validation </h3><br><p>  Swagger peut Ãªtre converti en schÃ©ma json, et Ã  l'aide d'outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajv,</a> vous pouvez valider les rÃ©ponses du backend directement dans le runtime, dans votre BFF, et signaler les testeurs, les backenders eux-mÃªmes, en cas de divergences, etc. </p><br><p>  Supposons qu'un testeur trouve une sorte de bogue sur le site, par exemple, lorsqu'un bouton est cliquÃ©, rien ne se passe.  Que fait le testeur?  Il met un ticket sur le front-end: "c'est ton bouton, il n'est pas pressÃ©, rÃ©pare-le." </p><br><p>  S'il y a un validateur entre vous et l'arriÃ¨re, le testeur saura que le bouton est rÃ©ellement enfoncÃ©, seul le backend envoie la mauvaise rÃ©ponse.  Faux - c'est une rÃ©ponse Ã  laquelle le front ne s'attend pas, c'est-Ã -dire qu'il ne correspond pas au Â«contratÂ».  Et ici, il est dÃ©jÃ  nÃ©cessaire de rÃ©parer le dos ou de modifier le contrat. </p><br><h3>  Conclusions </h3><br><ol><li>  Nous sommes activement impliquÃ©s dans la conception de l'API.  Nous concevons l'API de maniÃ¨re Ã  ce qu'elle soit pratique Ã  utiliser aprÃ¨s 17 ans. </li><li>  Nous avons besoin de la documentation Swagger.  Aucune documentation - l'opÃ©ration principale n'a pas Ã©tÃ© terminÃ©e. </li><li>  Il existe de la documentation - nous la publions dans git, et toute modification de l'API doit Ãªtre mise Ã  jour par le reprÃ©sentant de l'Ã©quipe de front. </li><li>  Nous Ã©levons le faux serveur et commenÃ§ons Ã  travailler sur le front sans attendre la vraie API. </li><li>  Nous plaÃ§ons le nÅ“ud sous le frontend et validons toutes les rÃ©ponses.  De plus, nous avons la possibilitÃ© d'agrÃ©ger, de normaliser et de mettre en cache les donnÃ©es. </li></ol><br><h4>  Voir aussi </h4><br><p>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment construire une API de type REST dans un grand projet</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Backend dans le frontend</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de GraphQL comme implÃ©mentation de modÃ¨le BFF</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428141/">https://habr.com/ru/post/fr428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428129/index.html">Une logique floue simple collÃ©e Â«de ce qui Ã©taitÂ» pour un moteur Ã  turbine Ã  gaz</a></li>
<li><a href="../fr428131/index.html">Toute la vÃ©ritÃ© sur RTOS. Article # 17. Groupes de drapeaux d'Ã©vÃ©nements: introduction et services de base</a></li>
<li><a href="../fr428133/index.html">Hasura. Architecture GraphQL Ã  SQL Server haute performance</a></li>
<li><a href="../fr428135/index.html">Comment configurer ou dÃ©sactiver les peluches dans l'Ã©diteur de code intÃ©grÃ©</a></li>
<li><a href="../fr428137/index.html">Olympiade, concours d'idÃ©es, confÃ©rences sur la gestion de projets informatiques et projections de films: 10 Ã©vÃ©nements Ã  venir Ã  l'UniversitÃ© ITMO</a></li>
<li><a href="../fr428143/index.html">Approche de mise en Å“uvre de ReactJS RBAC</a></li>
<li><a href="../fr428147/index.html">Script pour collecter des citations et reconnaÃ®tre le texte d'une vidÃ©o en Python</a></li>
<li><a href="../fr428149/index.html">Votre nouvel alliÃ© Mavic 2 Enterprise Sky</a></li>
<li><a href="../fr428151/index.html">Examen des performances de PostgreSQL 10.5 dans les derniers services cloud Yandex.Cloud</a></li>
<li><a href="../fr428155/index.html">Limite de vitesse pour les vÃ©hicules Ã©lectriques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>