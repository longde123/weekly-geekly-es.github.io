<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏽 🤢 🥜 Túnel VPN directo entre computadoras a través de proveedores NAT (sin VPS, usando un servidor STUN y Yandex.Disk) 📻 💟 🦐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La continuación del artículo sobre cómo logré organizar un túnel VPN directo entre dos computadoras ubicadas detrás de los proveedores de NAT. El últi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Túnel VPN directo entre computadoras a través de proveedores NAT (sin VPS, usando un servidor STUN y Yandex.Disk)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481034/">  La continuación del <a href="https://habr.com/ru/post/478452/">artículo</a> sobre cómo logré organizar un túnel VPN directo entre dos computadoras ubicadas detrás de los proveedores de NAT.  El último artículo describió el proceso de organizar una conexión con un tercero: un intermediario (un VPS alquilado que actúa como un servidor STUN y un transmisor de datos de nodo para una conexión).  En este artículo, le diré cómo prescindir de VPS, pero los intermediarios permanecieron y fueron el servidor STUN y Yandex.Disk ... <br><img src="https://habrastorage.org/webt/ud/sj/3t/udsj3te1itgjnnv-bsk99369pre.jpeg"><br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Después de leer los comentarios de la última publicación, me di cuenta de que el principal inconveniente de la implementación era el uso de un intermediario, un tercero (VPS) que indicaba los parámetros actuales del nodo, dónde y cómo conectarse.  Dadas las recomendaciones para usar este STUN (hay <a href="https://ru.wikipedia.org/wiki/STUN" rel="nofollow">muchas</a> ) para determinar los parámetros de conexión actuales.  En primer lugar, decidí mirar el contenido de los paquetes usando TCPDump cuando el servidor STUN estaba trabajando con clientes y recibía contenido completamente ilegible.  Googleando el protocolo se encontró con un <a href="https://tools.ietf.org/html/rfc3489" rel="nofollow">artículo que describe el protocolo</a> .  Me di cuenta de que no puedo implementar la solicitud al servidor STUN yo mismo y puse la idea en el "cuadro lejano". <br><br><h3>  Teoría </h3><br>  Recientemente tuve que instalar un servidor STUN en Debian desde un paquete <pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt install stun-server</span></span></code> </pre>  y en las dependencias vi el paquete aturdidor-cliente, pero de alguna manera no le di importancia a esto.  Pero más tarde, recordé sobre el paquete aturdidor-cliente y decidí averiguar cómo funciona, buscando en Google y Poindeksiv que recibí: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt install stun-client # stun stun.ekiga.net -p 21234 -v</span></span></code> </pre><br>  En respuesta, recibí: <br><br><blockquote>  Cliente STUN versión 0.97 <br>  Puerto abierto 21234 con fd 3 <br>  Puerto abierto 21235 con fd 4 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 0 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Mensaje de aturdimiento recibido: 92 bytes <br>  MappedAddress = &lt;Mi IP&gt;: 2885 <br>  SourceAddress = 216.93.246.18//478 <br>  ChangedAddress = 216.93.246.17lla479 <br>  Atributo desconocido: 32800 <br>  ServerName = Vovida.org 0.98-CPC <br>  Mensaje recibido del tipo 257 id = 1 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 0 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.17lla478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 0 <br><br>  A punto de enviar un mensaje de len 28 a &lt;Mi IP&gt;: 2885 <br>  Mensaje de aturdimiento recibido: 28 bytes <br>  ChangeRequest = 0 <br>  Mensaje recibido de tipo 1 id = 11 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 0 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.17lla478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Mensaje de aturdimiento recibido: 92 bytes <br>  MappedAddress = &lt;Mi IP&gt;: 2885 <br>  SourceAddress = 216.93.246.17lla479 <br>  ChangedAddress = 216.93.246.18 {478 <br>  Atributo desconocido: 32800 <br>  ServerName = Vovida.org 0.98-CPC <br>  Mensaje recibido del tipo 257 id = 10 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 4 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  Codificar mensaje de aturdimiento: <br>  Solicitud de cambio de codificación: 2 <br><br>  A punto de enviar un mensaje de len 28 a 216.93.246.18 opin478 <br>  prueba I = 1 <br>  prueba II = 0 <br>  prueba III = 0 <br>  prueba I (2) = 1 <br>  es nat = 1 <br>  IP asignada igual = 1 <br>  horquilla = 1 <br>  puerto de conservador = 0 <br>  Primario: mapeo independiente, filtro dependiente del puerto, puerto aleatorio, horquilla <br>  El valor de retorno es 0x000006 </blockquote><br>  Cadena con valor <blockquote>  MappedAddress = &lt;Mi IP&gt;: 2885 </blockquote><br>  justo lo que necesitas!  Mostraba el estado actual de la conexión en el puerto UDP local 21234. Pero esto es solo la mitad de la batalla, surgió la pregunta de cómo transferir estos datos a un host remoto y establecer una conexión VPN.  Usando el protocolo de correo, ¿tal vez Telegram?  Hay muchas opciones y decidí usar Yandex.Disk, ya que encontré <a href="https://fritool.ru/curl-for-webdav/" rel="nofollow">un artículo sobre cómo Curl funciona a través de WebDav con Yandex.Disk</a> .  Después de pensar en la implementación, llegué a este esquema: <br><br><ol><li>  Para indicar que los nodos están listos para establecer una conexión por la presencia de un archivo específico con una marca de tiempo en Yandex.disk; </li><li>  Si los nodos están listos, obtenga los parámetros actuales del servidor STUN; </li><li>  Suba los parámetros actuales a Yandex.Disk; </li><li>  Verifique la disponibilidad y lea los parámetros de un sitio remoto desde un archivo en Yandex.Disk; </li><li>  Establezca una conexión a un host remoto utilizando OpenVPN. </li></ol><br><h3>  Practica </h3><br>  Después de pensar un poco, teniendo en cuenta la experiencia del artículo anterior, escribí un guión rápido.  Necesitaremos: <pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt install openvpn stun-client curl</span></span></code> </pre> <br>  En realidad, el guión en sí mismo: <br><div class="spoiler">  <b class="spoiler_title">Opción inicial</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat vpn8.sh</span></span></code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ########################    ### WARN='\033[37;1;41m' # END='\033[0m' # RED='\033[0;31m' # ${RED} # GREEN='\033[0;32m' # ${GREEN} # ################################################# #######################     ######################################################### al="echo readlink dirname grep awk md5sum shuf nc curl sleep openvpn cat stun" ch=0 for i in $al; do which $i &gt; /dev/null || echo -e "${WARN}   $i ${END}"; which $i &gt; /dev/null || ch=1; done if (( $ch &gt; 0 )); then echo -e "${WARN},      ${END}"; exit; fi ####################################################################################################################### if [[ $1 == '' ]]; then echo -e "${WARN}   (  ,      !) ${END} \t ${GREEN}           /etc/rc.local  nohup /&lt;  &gt;/vpn8.sh &gt; /var/log/vpn8.log 2&gt;/dev/hull &amp; ${END}"; exit; fi ABSOLUTE_FILENAME=`readlink -f "$0"` #     DIR=`dirname "$ABSOLUTE_FILENAME"` #      ###############################     ################################## key="$DIR/secret.key" if [ ! -f "$key" ]; then echo -e "${WARN}  VPN-  ,    : \ openvpn --genkey --secret secret.key :       \     !!!${END} # ls -l secret.key -rw------- 1 root root 637  27 11:12 secret.key # chmod 600 secret.key"; exit; fi ######################################################################################################################## ABSOLUTE_FILENAME=`readlink -f "$0"` #     DIR=`dirname "$ABSOLUTE_FILENAME"` #      name=$(uname -n | md5sum | awk '{print $1}') vpn=$(echo $1 | md5sum | awk '{print $1}') stun="stun.ekiga.net" # STUN  username="Yandex" #   . password="Password" #   . localport=`shuf -i 20000-65000 -n 1` #    echo "$(date)    ." curl -X MKCOL --user "${username}:${password}" https://webdav.yandex.ru/vpn-$vpn echo "$(date)     " for i in `curl --silent --user "$username:$password" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/\n/g' | grep "d:displayname" | sed 's/d:displayname//g' | sed 's/&gt;//g' | sed 's/&lt;//' | sed 's/\///g' | grep -v $(date +%Y-%m-%d-%H-%M)`; do echo "$(date) Delete: $i" curl -X DELETE --user "${username}:${password}" https://webdav.yandex.ru/vpn-$vpn/$i done until [ $c ];do until [[ $b ]]; do echo "$(date)  " date=`date +%Y-%m-%d-%H-%M` mydata=`curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/&gt;\n&lt;/g' | grep $name | grep $date | grep "d:displayname"` if [[ -z $mydata ]]; then echo "$(date)   " echo "$date" &gt; "/tmp/$date-$name-ready.txt" curl -T "/tmp/$date-$name-ready.txt" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$date-$name-ready.txt else echo "$(date)     - $date" fi remote=`curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/&gt;\n&lt;/g' | grep -v $name | grep $date | grep "d:displayname"` if [[ -z $remote ]]; then echo -e "$(date) ${RED}     ${END}" echo "$(date) " sleep 20 else echo -e "$(date) ${GREEN}    ${END}" b=1 a='' fi done until [ $a ]; do echo "$(date)      STUN : $stun" mydata=`stun $stun -p $localport -v 2&gt;&amp;1 | grep MappedAddress | sort | uniq` echo -e "$(date) ${GREEN}  : $mydata${END}" echo "$mydata" &gt; "$DIR/mydata" echo "$(date)    ." curl -T "$DIR/mydata" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$name.txt echo "$(date)     " filename=$(curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/\n/g' | grep "d:displayname&gt;" | grep "txt" | grep -v "$name" | grep -v "ready" | sed 's|.*d:displayname&gt;||' | sed 's/&lt;/ /g' | awk '{print $1}') echo "$(date)     : $filename" address=$(curl --silent --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$filename | sort | uniq | head -n1 | sed 's/:/ /g') echo "$(date)  IP-  " ip=$(echo "$address" | awk '{print $3}') port=$(echo "$address" | awk '{print $4}') if [[ -n "$ip" &amp;&amp; -n "$port" ]]; then echo -e "$(date) ${GREEN}  $ip $port ${END}" openvpn --remote $ip --rport $port --lport $localport \ --proto udp --dev tap --float --auth-nocache --verb 3 --mute 20 \ --ifconfig 10.45.54.2 255.255.255.252 \ --secret "$DIR/secret.key" \ --auth SHA256 --cipher AES-256-CBC \ --ncp-disable --ping 10 --ping-exit 30 \ --comp-lzo yes echo -e "$(date) ${WARN}  ${END}" a=1 b='' else a=1 b='' fi done done</span></span></code> </pre> <br>  Para ejecutar el script necesitas: <br><ol><li>  Copie en el portapapeles y péguelo en el editor, por ejemplo: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># nano vpn8.sh</span></span></code> </pre> </li><li>  especifique el nombre de usuario y la contraseña de Yandex.Disk. </li><li>  en el campo "--ifconfig 10.45.54. (1 o 2) 255.255.255.252" especifique la dirección IP interna de la interfaz </li><li>  crear <b>secret.key con el</b> comando: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># openvpn --genkey --secret secret.key</span></span></code> </pre> </li><li>  hacer que el script sea ejecutable: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chmod +x vpn8.sh</span></span></code> </pre> </li><li>  ejecuta el script: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./vpn8.sh nZbVGBuX5dtturD</span></span></code> </pre> <br>  donde nZbVGBuX5dtturD es la ID de conexión generada <a href="https://strongpasswordgenerator.com/" rel="nofollow">aquí</a> </li></ol><br>  En el nodo remoto, haga lo mismo excepto por la generación de secret.key y la conexión de ID, deben ser idénticos. <br></div></div><br>  Versión actualizada (para un funcionamiento correcto, la hora debe estar sincronizada): <br><br><pre> <code class="bash hljs">cat vpn10.sh</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash stuns="stun.sipnet.ru stun.ekiga.net" #  STUN    username=" Login " #   . password=" Password " #   . intip="10.23.22.1" # IP-   WARN='\033[37;1;41m' END='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' al="ip echo readlink dirname grep awk md5sum openssl sha256sum shuf curl sleep openvpn cat stun" ch=0 for i in $al; do which $i &gt; /dev/null || echo -e "${WARN}   $i ${END}"; which $i &gt; /dev/null || ch=1; done if (( $ch &gt; 0 )); then echo -e "${WARN},      ${END}"; exit; fi if [[ $1 == '' ]]; then echo -e "${WARN}   (  ,      !) ${END} \t ${GREEN}           /etc/rc.local  nohup /&lt;  &gt;/vpn10.sh &gt; /var/log/vpn10.log 2&gt;/dev/hull &amp; ${END}" exit fi ABSOLUTE_FILENAME=`readlink -f "$0"` #     DIR=`dirname "$ABSOLUTE_FILENAME"` #      key="$DIR/secret.key" until [[ -n "$iftosrv" ]] do echo "$(date)   "; iftosrv=`ip route get 8.8.8.8 | head -n 1 | sed 's|.*dev ||' | awk '{print $1}'` sleep 5 done timedatectl name=$(uname -n | md5sum | awk '{print $1}') vpn=$(echo $1 | md5sum | awk '{print $1}') echo "$(date)    ." curl -X MKCOL --user "${username}:${password}" https://webdav.yandex.ru/vpn-$vpn echo "$(date) ID  : $vpn" until [ $c ];do echo "$(date)     " for i in `curl --silent --user "$username:$password" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/\n/g' | grep "d:displayname" | sed 's/d:displayname//g' | sed 's/&gt;//g' | sed 's/&lt;//' | sed 's/\///g' | grep -v $(date +%Y-%m-%d-%H-%M)` do echo -e "$(date)${RED}   : $i${END}" curl -X DELETE --user "${username}:${password}" https://webdav.yandex.ru/vpn-$vpn/$i done echo "$(date) ID  : $vpn" openvpn --genkey --secret "$key" passwd=`echo "$vpn-tt" | sha256sum | awk '{print $1}'` openssl AES-256-CBC -e -in "$key" -out "$DIR/file.enc" -k "$passwd" -base64 curl -T "$DIR/file.enc" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/key.enc rm "$DIR"/file.enc echo -e "$(date) ${GREEN} 1 -    ${END}" go=3 localport=`shuf -i 20000-65000 -n 1` #    start='' remote='' timeout1='' nextcheck='' timestart='' until [[ $b ]] do echo "$(date)  " date=`date +%s` timeout1=60 echo "$(date)    $date" echo "$date" &gt; "/tmp/ready-$date-$name.txt" curl -T "/tmp/ready-$date-$name.txt" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/ready-$name.txt readyfile=`curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/&gt;\n&lt;/g' | grep -v $name | grep "ready" | grep "d:displayname" | sed 's/&lt;d:displayname&gt;//g' | sed 's/&lt;\/d:displayname&gt;//g'` if [[ -z $readyfile ]] then echo -e "$(date) ${RED}     ${END}" echo "$(date)  60 " sleep $timeout1 else remote=$(curl --silent --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$readyfile) echo -e "$(date) ${GREEN}    ${END}" start=`curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/&gt;\n&lt;/g' | grep "start" | grep "d:displayname" | sed 's/-/ /g' | awk '{print $2}'` if [[ -z $start ]] then let nextcheck=$timeout1-$date+$remote let timestart=$date+$timeout1-$nextcheck go=$nextcheck echo "$timestart" &gt; "/tmp/start-$date-$name.txt" curl -T "/tmp/start-$date-$name.txt" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/start-$date-$name.txt else echo "$(date)  $go " sleep $go b=1 a='' fi fi done echo -e "$(date) ${GREEN} 2 -     ${END}" mydata='' filename='' address='' myip='' ip='' port='' ex=0 until [ $a ]; do until [[ -n "$mydata" ]]; do k=`echo "$stuns" | wc -w` x=1 z=`shuf -i 1-$k -n 1` for st in $stuns; do if [[ $x == $z ]]; then stun=$st; fi; (( x++ )); done echo "$(date)      STUN : $stun" sleep 5 &amp;&amp; for pid in $(ps xa | grep "stun "$stun" 1 -p "$localport" -v" | grep -v grep | awk '{print $1}'); do kill $pid; done &amp; mydata=`stun "$stun" 1 -p "$localport" -v 2&gt;&amp;1 | grep "MappedAddress" | sort | uniq` done echo -e "$(date) ${GREEN}  : $mydata${END}" echo "$(date)    ." echo "$mydata" &gt; "$DIR/mydata" echo "IntIP $intip" &gt;&gt; "$DIR/mydata" curl -T "$DIR/mydata" --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$name-ipport.txt rm "$DIR/mydata" sleep 5 echo "$(date)     " filename=$(curl --silent --user "${username}:${password}" -X PROPFIND -H "Depth: 1" https://webdav.yandex.ru/vpn-$vpn/ | sed 's/&gt;&lt;/\n/g' | grep "d:displayname&gt;" | grep "ipport" | grep -v "$name" | sed 's|.*d:displayname&gt;||' | sed 's/&lt;/ /g' | awk '{print $1}') if [[ -n "$filename" ]] then echo "$(date)     : $filename" address=$(curl --silent --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$filename | grep "MappedAddress" | head -n1 | sed 's/:/ /g') intip2=$(curl --silent --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/$filename | grep "IntIP" | head -n1 | awk '{print $2}') echo "$(date)  IP-  : $address $sesid2 $tunid2" ip=$(echo "$address" | awk '{print $3}') port=$(echo "$address" | awk '{print $4}') myip=`ip route get "$ip" | head -n 1 | sed 's|.*src ||' | awk '{print $1}'` if [[ -n "$ip" &amp;&amp; -n "$port" &amp;&amp; -n "$myip" &amp;&amp; -n "$localport" ]]; then echo -e "$(date) ${GREEN}  $ip $port ${END}" echo -e "`date` ${GREEN} $myip:$localport -&gt; $ip:$port ${END}" curl --silent --user "$username:$password" https://webdav.yandex.ru/vpn-$vpn/key.enc &gt; "$DIR/secret.enc" openssl AES-256-CBC -d -in "$DIR/secret.enc" -out "$key" -k "$passwd" -base64 chmod 600 "$key" rm "$DIR/secret.enc" openvpn --remote $ip --rport $port --lport $localport \ --proto udp --dev tun --float --auth-nocache --verb 3 --mute 20 \ --ifconfig "$intip" "$intip2" \ --secret "$key" \ --auth SHA256 --cipher AES-256-CBC \ --ncp-disable --ping 10 --ping-exit 20 \ --comp-lzo yes a=1 b='' fi else if (( $ex &gt;= 5 )) then echo "$(date) " a=1 b='' fi (( ex++ )) sleep 5 fi done done</span></span></code> </pre><br>  Para ejecutar el script necesitas: <br><ol><li>  Copie en el portapapeles y péguelo en el editor, por ejemplo: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># nano vpn10.sh</span></span></code> </pre> </li><li>  especifique inicio de sesión (segunda línea) y contraseña de Yandex.Disk (tercera línea). </li><li>  especifique la dirección IP interna del túnel (cuarta línea). </li><li>  hacer que el script sea ejecutable: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chmod +x vpn10.sh</span></span></code> </pre> </li><li>  ejecuta el script: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./vpn10.sh nZbVGBuX5dtturD</span></span></code> </pre> <br>  donde nZbVGBuX5dtturD es la ID de conexión generada <a href="https://strongpasswordgenerator.com/" rel="nofollow">aquí</a> </li></ol><br>  En el nodo remoto, haga lo mismo, especifique la dirección IP interna correspondiente del túnel y la conexión de ID. <br><br>  Para iniciar el script al inicio, uso el comando "nohup / &lt;ruta al script&gt; /vpn10.sh nZbVGBuX5dtturD&gt; /var/log/vpn10.log 2&gt; / dev / null &amp;" contenido en el archivo /etc/rc.local <br><br><h3>  Conclusión </h3><br>  El script funciona, probado en Ubuntu 18.04 y Debian 9. Puede usar cualquier otro servicio como transmisor, pero por la experiencia utilicé Yandex.Disk. <br>  En el curso de los experimentos, se descubrió que algunos tipos de proveedores de NAT no permiten una conexión.  Principalmente con operadores móviles donde los torrents están bloqueados. <br><br>  Planeo finalizar en términos de: <br><ul><li>  La generación automática de secret.key cada vez que inicie, cifre y copie a Yandex.Disk para transferir a un host remoto (tomado en cuenta en la versión actualizada) </li><li>  Asignar automáticamente direcciones IP de interfaz </li><li>  Cifrado de datos antes de subir a Yandex.Disk </li><li>  Optimización de código </li></ul><br>  ¡Que haya IPv6 en cada hogar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481034/">https://habr.com/ru/post/481034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481020/index.html">Escribir un simulador de escritura táctil usando JavaScript puro: Parte 2</a></li>
<li><a href="../481024/index.html">¿Por qué abandoné la API de Google Maps?</a></li>
<li><a href="../481028/index.html">Guía para organizar una conexión remota a un PLC industrial utilizando OpenVPN</a></li>
<li><a href="../481030/index.html">¿Qué tipo de cyberdec me gustaría hacer por mí mismo?</a></li>
<li><a href="../481032/index.html">¿Por qué fue posible hackear? Probablemente porque el atacante</a></li>
<li><a href="../481036/index.html">30 utilidades para herramientas de desarrollo de Firefox</a></li>
<li><a href="../481038/index.html">Confesión de un adicto al diseño. Cómo hicimos el juego "IT Alchemy" en un mes</a></li>
<li><a href="../481042/index.html">El sabor de Django nos entusiasma y atrae</a></li>
<li><a href="../481044/index.html">Qué presentar para 2020: guía de Año Nuevo Madrobots</a></li>
<li><a href="../481048/index.html">Reconocimiento de circuitos digitales. Elemento C generalizado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>