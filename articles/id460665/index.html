<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴️ 👩‍🌾 🕋 Draft FAQ: Mengapa standar C ++ keluar setiap tiga tahun? 👩🏿‍⚖️ 👆🏽 🎄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WG21 memiliki jadwal yang ketat (lihat P1000 ) untuk rilis standar setiap tiga tahun. Dan tidak ada penundaan. 

 Selama setiap siklus, kami secara te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Draft FAQ: Mengapa standar C ++ keluar setiap tiga tahun?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  WG21 memiliki jadwal yang ketat (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1000</a> ) untuk rilis standar setiap tiga tahun.  Dan tidak ada penundaan. <br><br>  Selama setiap siklus, kami secara teratur menerima pertanyaan "Mengapa begitu ketat?", Terutama dari anggota baru komite yang tidak akrab dengan sejarahnya dan alasan untuk keadaan saat ini.  Dan selama teleconference awal dengan pemerintah Cologne, beberapa orang merekomendasikan untuk menjelaskan mengapa kami melakukan ini dan bagaimana keputusan dibuat untuk mengadopsi jadwal ini. <br><br>  Saya melukis semua ini dalam bentuk pertanyaan dan jawaban untuk draft P1000 berikutnya, dan mengirim salinan kepada anggota komite dalam perjalanan ke Cologne.  Materi ini akan diterbitkan dalam versi publik P1000 berikutnya, kami akan mengirimkannya dalam beberapa minggu mulai dari saat ini. <br><br>  Namun, draft FAQ mungkin menarik bagi publik, jadi saya menawarkan kepada Anda salinannya.  Saya berharap bahwa sebagian besar akan bermanfaat bagi Anda, mencerahkan dalam beberapa hal, dan mungkin bahkan menghibur sedikit. <br><br><a name="habracut"></a><br><h2>  Ada bug dalam standar, haruskah Anda menunda C ++ 20? </h2><br>  Tentu saja ya dan tidak. <br><br>  Kami bergerak ke arah tertentu dengan kecepatan yang dipilih: perbaikan bug direncanakan untuk tahun lalu ini, sehingga jadwal di awal C ++ "19" (Kona) menetapkan batas waktu untuk menghentikan penambahan fitur di C ++ "20" sehingga kami punya waktu satu tahun untuk memperbaiki bug, termasuk bekerja dengan komentar dari berbagai negara musim panas ini.  Sebelum awal 2020 (pertemuan di Cologne, Belfast dan Praha), kami harus memberikan umpan balik dan menerapkan solusi lain untuk masalah, serta perbaikan bug. <br><br><h2>  Jika kita memiliki satu atau dua pertemuan lagi, maka kita dapat menambahkan &lt;nama fitur&gt;, yang hampir siap, jadi apakah Anda harus menunda C ++ 20? </h2><br>  Tentu saja ya dan tidak. <br><br>  Tunggu beberapa pertemuan lagi (setelah Praha), dan C ++ 23 akan terbuka untuk bisnis, dan pertama-tama kami akan memilih untuk menambahkan &lt;fitur nama&gt; ke draft kerja C ++ 23.  Inilah yang kami lakukan dengan konsep: mereka tidak siap untuk transisi dari TS langsung ke C ++ 17.  Oleh karena itu, pada pertemuan pertama tentang C ++ 20 (di Toronto), mereka memilih untuk mentransfer fungsionalitas dasar konsep ke konsep C ++ 20, yang memberi banyak waktu untuk memperbaiki dan memperbaiki sisa bagian kontradiktif dari sintaks TS (non-"template"), yang diperkenalkan tahun depan (San Diego).  Sekarang semua fungsionalitas siap. <br><br><h2>  Ini sepertinya terlalu ketat.  Mengapa rilis rilis IS pada interval tetap (tiga tahun)? </h2><br>  Karena dalam kasus rilis C ++ IS, ini adalah salah satu dari dua opsi utama untuk manajemen proyek, dan pengalaman menunjukkan bahwa opsi ini lebih baik daripada yang kedua. <br><br><h2>  Apa dua opsi untuk manajemen proyek untuk rilis C ++ IS? </h2><br>  Senang Anda bertanya. <br><br>  Dalam hal rilis, ada dua opsi utama: pilih fitur atau tanggal rilis, dan ketika Anda memilih satu, Anda kehilangan kendali atas definisi yang lain.  Anda tidak dapat secara bersamaan mengontrol keduanya.  Singkatnya: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Jika kita mengendalikannya <br></th><th>  Kami akan berhenti mengendalikannya <br></th><th> Bisakah kita bekerja pada fitur multi-tahun "besar"? <br></th><th>  Kapan kami menambahkan fitur ke draft IS? <br></th><th>  Apa yang kita lakukan jika kita menemukan masalah dengan fitur yang ditambahkan? <br></th></tr><tr><td>  <b>"Apa": fitur yang kami kirimkan</b> <br></td><td>  "Kapan": tanggal rilis. <br></td><td>  Ya, dalam dokumen dengan proposal dan draft IS. <br></td><td>  Biasanya lebih awal untuk melakukan lebih banyak tes integrasi → stabilitas rata-rata draft kerja berkurang. <br></td><td>  Kami menunda rilis standar. <br></td></tr><tr><td>  <b>Kapan: Tanggal Rilis</b> <br></td><td>  "Apa": fitur yang kami kirimkan <br></td><td>  Ya, dalam dokumen dengan penawaran dan "cabang fitur" di TS. <br></td><td>  Biasanya nanti, ketika fitur bekerja dengan lebih baik → stabilitas rata-rata draft kerja meningkat. <br></td><td>  Kami menghapus fitur, nanti kita bisa menambahkannya lagi jika sudah siap pada saat kereta IS berikutnya dikirim. <br></td></tr></tbody></table></div><br>  Saya jelaskan: <br><br>  <b>(1) "Apa": kami memilih fitur dan mengirim sebagai siap, tidak perlu memilih waktu rilis</b> .  Jika ternyata Anda perlu lebih banyak waktu untuk menyelesaikan fitur dari standar rancangan, maka seluruh dunia harus menunggu Anda.  Anda mengerjakan fitur besar yang membutuhkan pengembangan selama beberapa tahun, dan kemudian Anda mencoba untuk berhenti bekerja pada fitur baru sama sekali sambil menstabilkan rilis. <br><br>  Demikian juga dengan C ++ 98 (diperkirakan sekitar tahun 1994, Björn mengatakan bahwa jika rilis tidak keluar maka itu akan menjadi kegagalan) dengan C ++ 11 (disebut 0x karena x diharapkan pada 2007 )  Ini adalah pendekatan "biarkan pasien tidak terlindung" untuk periode yang tidak terbatas, yang menyebabkan keterlambatan dalam pengujian dan pelepasan integrasi.  Dan ini, pada gilirannya, menyebabkan ketidakpastian pasar yang besar mengenai waktu standar berikutnya, dan apakah akan dirilis sama sekali (ya, tidak hanya para peserta pengembangan, tetapi bahkan beberapa anggota komite sangat meragukan pada tahun 1996 dan 2009, akan muncul apakah ada rilis yang relevan).  Selama beberapa tahun, sebagian besar penyusun tidak memenuhi standar, karena tidak ada yang tahu berapa banyak perubahan yang tidak kompatibel yang akan dikeluarkan panitia dalam rilis baru, atau kapan itu diharapkan?  Ini telah menyebabkan beragam dan fragmentasi dukungan C ++ dalam kompiler yang tersedia bagi masyarakat. <br><br>  Mengapa kita melakukan ini, apakah kita idiot?  Tidak juga, mereka hanya tidak berpengalaman dan ... katakanlah, "optimis."  Itu jalan beraspal dengan niat terbaik.  Pada 1994-1996 dan 2007-2009 kami benar-benar percaya bahwa kami sekarang akan pindah satu, dua atau tiga pertemuan lagi, dan kami akan melakukan segalanya, dan setiap kali mereka akan ditunda hingga empat tahun.  Dan sekarang mereka telah melihat dari pengalaman mereka sendiri bahwa tidak ada transfer untuk satu atau dua tahun. <br><br>  Untungnya, semuanya telah berubah berkat opsi (2). <br><br>  <b>(2) "Kapan": kami memilih tanggal rilis dan mengirimkan fitur yang siap, Anda tidak perlu memilih satu set fitur</b> .  Jika ternyata diperlukan lebih banyak waktu untuk menyaring fitur dari konsep standar, kami membuangnya dan mengirimkan yang siap.  Anda dapat terus bekerja pada fitur-fitur besar, pembuatannya membutuhkan waktu untuk beberapa rilis, tetapi melakukannya di "cabang" pihak ketiga, menambahkannya ke cabang master IS sesegera mungkin.  Dan Anda terus bekerja pada fitur, karena pengembangannya benar-benar terpisah dari rilis saat ini (tidak ada titik koneksi besar). <br><br>  Kami telah mengikuti pendekatan ini sejak 2012 dan tidak ingin meninggalkannya.  Ini adalah pendekatan "secara teratur memperbaiki pasien", yang mengarah pada ekspektasi kualitas yang lebih tinggi karena integrasi reguler yang dipaksakan dan penolakan untuk menambah pekerjaan pada rancangan IS sampai mencapai tingkat stabilitas tertentu, biasanya dalam cabang fitur.  Ini juga menciptakan siklus rilis yang dapat diprediksi yang dapat diandalkan pasar.  Selama bertahun-tahun, penulis kompiler mulai lebih awal dan lebih awal, setelah rilis berikutnya, untuk merilis versi produk mereka sesuai dengan standar, yang belum pernah terjadi sebelumnya.  Dan pada tahun 2020, kami berharap rilis implementasi yang sepenuhnya sesuai dalam satu tahun dengan rilis standar, yang juga tidak pernah terjadi sebelumnya.  Ini hanya untuk kepentingan seluruh pasar - pengembang, pengguna, guru. <br><br>  Dan juga perhatikan bahwa sejak kami mulai mematuhi pendekatan ini, kami telah mulai melakukan lebih banyak (jika diukur dengan fitur besar, sedang dan kecil) dan dengan kualitas yang lebih tinggi (jika diukur dengan pengurangan ketat dalam jumlah laporan bug dan komentar pada konsep dari setiap standar).  Meskipun kami mengirimkan apa yang kami siapkan (dan jika kami tidak mengelola sesuatu, kami tidak mengirimkannya). <br><br><h2>  Seberapa serius Anda tentang pendekatan (2)?  Jika, menurut anggota komite yang berwenang, beberapa fitur besar "hampir siap", maka Anda akan tergoda untuk menunggu sebentar, bukan? </h2><br>  Sangat serius, dan tidak. <br><br>  Kami memiliki statistik: pada tahun 2016 di Jacksonville, ketika kami akhirnya memutuskan fitur untuk C ++ 17, Björn Straustrup berbicara pada pertemuan pleno dengan proposal untuk memasukkan konsep dalam C ++ 17.  Ketika tidak ada konsensus tercapai, Straustrup langsung ditanya apakah ia ingin menunda rilis C ++ 17 selama satu tahun untuk memasukkan konsep di dalamnya.  Bjorn menjawab "tidak" tanpa ragu-ragu dan mengelak, dan menambahkan bahwa C ++ 17 tanpa konsep lebih penting daripada C ++ 18 atau C ++ 19 dengan konsep, meskipun Straustrup telah mengerjakannya selama sekitar 15 tahun.  Pilihannya adalah ini: (2) kami merilis C ++ 17 tanpa konsep, dan kemudian C ++ 20 dengan konsep (yang kami lakukan), atau (1) kami mengganti nama C ++ 17 menjadi C ++ 20, yang isomorfis (2) dengan pengecualian melewatkan C ++ 17 dan menolak untuk melepaskan apa yang sudah siap untuk C ++ 17. <br><br><h2>  Bagaimana dengan trade-off antara (1) dan (2)?  Katakanlah, kita biasanya mematuhi (2), tetapi dengan fleksibilitas "sedikit" untuk mendapatkan waktu tambahan "sedikit", jika Anda perlu memperbaiki fitur? </h2><br>  Tidak, karena ternyata (1). <br><br>  Fred Brooks dalam <i>The Mythical Man-Month secara</i> populer menjelaskan "pemindahan kecil mitis" dan menyimpulkan: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jangan izinkan pemindahan kecil apa pun</a> ." <br><br>  Bayangkan kita porting C ++ 20.  Kita harus kembali dari (2) ke (1), tidak peduli seberapa keras kita berusaha menghindarinya, dan pada saat yang sama tidak akan menerima manfaat apa pun.  Jika kami memutuskan untuk menunda C ++ 20 untuk memolesnya, maka kami akan menunda standar untuk setidaknya dua tahun.  Tidak ada konsep seperti transfer satu atau tiga pertemuan, karena selama waktu ini orang lain akan melanjutkan (secara adil) untuk mengatakan: "Ya, fitur saya hanya perlu satu pertemuan lagi, kami masih menjadwal ulang, mari kita transfer yang lain."  Dan jika kita mentransfer setidaknya dua tahun, itu berarti bahwa C ++ 20 menjadi C ++ 22, dan kemungkinan besar C ++ 23 ... tetapi kita sudah akan mengirimkan C ++ 23!  - Artinya, dalam hal apa pun, kami akan mengirimkan C ++ 23, dan satu-satunya perbedaan adalah bahwa kami <b>tidak</b> mentransfer C ++ 20 dengan sejumlah besar pekerjaan yang dilakukan, siap untuk dirilis, dan tidak membuat seluruh dunia menunggu tiga tahun lagi.  Penundaan tidak akan menguntungkan fitur-fitur ini, sebagian besar atau semuanya bersama-sama. <br><br>  Oleh karena itu, kalimatnya setara dengan "mari kita ubah C ++ 20 menjadi C ++ 22 atau C ++ 23", dan jawaban sederhana untuk itu: "ya, kita akan memiliki C ++ 23, tetapi selain C ++ 20, dan tidak di tempatnya. "  Penundaan C ++ 20 berarti melewatkan C ++ 20 alih-alih melepaskan produk yang bagus, stabil, jadi, dan tidak akan ada manfaatnya. <br><br><h2>  Tetapi fitur X rusak / butuh lebih banyak waktu daripada yang tersisa untuk memperbaiki bug di C ++ 20! </h2><br>  Tidak ada pertanyaan!  Kita bisa memotongnya. <br><br>  Dalam hal ini, seseorang perlu menulis surat dalam EWG atau LEWG (tergantung pada situasinya) dengan uraian situasi, dan menawarkan untuk menghapus fitur dari draft kerja IS.  Grup-grup ini akan mempertimbangkan banding, dan jika mereka memutuskan bahwa fitur tersebut rusak (dan pleno setuju dengan mereka), maka fitur tersebut akan ditunda hingga rilis C ++ berikutnya.  Kami sudah melakukan ini dengan konsep C ++ 0x. <br><br>  Tetapi dalam kasus (1), kami tidak hanya akan mentransfer fitur ini, tetapi <b>seluruh rangkaian fitur</b> dari C ++ 20 ke C ++ 23!  Itu akan ... bangkrut. <br><br><h2>  Apakah pendekatan (2) berarti rilis “besar / kecil”? </h2><br>  Tidak.  Pada awalnya kami mengatakan ini sampai kami menyadari bahwa (2) hanya berarti bahwa Anda tidak perlu memilih serangkaian fitur bahkan dari sudut pandang rilis "utama / sekunder". <br><br>  Pendekatan (2) hanya berarti “kami mengirimkan apa yang siap”.  Rilis diperoleh: <br><br><ul><li>  ukuran yang sama (yaitu, biasanya rata-rata) untuk fitur "lebih kecil" karena lebih sedikit waktu yang dihabiskan untuk pengembangannya (katakanlah, masing-masing kurang dari tiga tahun), dan secara umum kami mendapatkan jumlah fitur yang sama dalam rilis; <br></li><li>  dan ukuran variabel (tidak perlu satu atau dua kali) untuk fitur "lebih besar", yang membutuhkan lebih banyak waktu (misalnya, masing-masing lebih dari tiga tahun), dan setiap rilis IS mencakup sebanyak mungkin fitur yang dikelola untuk diselesaikan untuk rilis.  Oleh karena itu, dalam beberapa rilis ada lebih banyak, yang lain lebih sedikit. <br></li></ul><br>  C ++ 14 dan C ++ 17 relatif kecil, karena banyak upaya standardisasi dihabiskan untuk fitur lama yang dijelaskan dalam proposal implementasi (misalnya, kontrak) dan "cabang fitur" di TS (misalnya, konsep). <br><br><h2>  C ++ 20 adalah rilis hebat ... </h2><br>  Ya  C ++ 20 memiliki banyak fitur utama.  Tiga yang terbesar dimulai dengan "ko" (konsep, kontrak, coroutine), sehingga kita bisa menyebutnya co_cpp20.  Atau co_dependent. <br><br><h2>  ... dan tidak terlalu banyak dilakukan dalam siklus tiga tahun untuk C ++ 20? </h2><br>  Tidak, lihat di atas "sekali waktu tidak perlu." <br><br>  C ++ 20 besar bukan karena kami telah melakukan lebih banyak dalam tiga tahun, tetapi karena ada banyak perkembangan panjang (termasuk setidaknya dua yang telah kami kerjakan dalam bentuk saat ini sejak 2012 dalam bentuk kalimat-P dan cabang-cabang TS ) mencapai tahap kesiapan dan mereka memutuskan untuk memasukkan mereka dalam draft IS dari rilis yang sama. <br><br>  Hampir selalu, fitur utama dikembangkan selama bertahun-tahun.  Perbedaan utama antara pendekatan (1) untuk C ++ 98 dan C ++ 11 dan pendekatan (2) adalah bahwa dalam C ++ 98 dan C ++ 11 rilisnya ditunda sampai semua fitur ini siap, dan sekarang kami mengirim besar segera setelah siap, dan bersama mereka kami akan merilis lebih banyak lagi. <br><br>  C ++ 20 melewati siklus tiga tahun yang sama dengan C ++ 14 dan C ++ 17.  Kami belum melakukan lebih banyak dalam tiga tahun terakhir daripada dalam dua siklus sebelumnya, kami hanya menambahkan lebih banyak fitur utama.  Jika ada dari mereka yang tidak siap, maka kita akan membuangnya dan menyelesaikannya untuk C ++ 23.  Jika ini terjadi, kami akan melaporkan ini dalam proposal implementasi dan menjelaskan alasannya. <br><br>  C ++ 14 + 17 + 20 merupakan siklus sembilan tahun ketiga kami (2011-2020) setelah C ++ 98 (1989-1998) dan C ++ 11 (2002-2011).  Tetapi karena kami menganut pendekatan (2), kami <b>juga</b> merilis perkembangan yang siap untuk akhir siklus tiga tahun dan enam tahun. <br><br><h2>  Bukankah lebih baik untuk menangkap bug ketika suatu produk sedang dalam pengembangan, dan tidak setelah itu dirilis? </h2><br>  Tentu saja lebih baik. <br><br>  Tetapi jika kita berbicara tentang alasan keterlambatan dalam rilis standar C ++, maka pertanyaan ini menyiratkan dua asumsi yang salah: <br><br><ul><li>  bahwa sebelum standar dirilis, fitur tidak keluar dan tidak digunakan (bagi banyak orang, sudah ada pengalaman dalam produksi); <br></li><li>  dan bahwa semua fitur dapat digunakan bersama hingga standar dilepaskan (tidak diizinkan). <br></li></ul><br>  Saya jelaskan: <br><br><ol><li>  Sebagian besar fitur utama C ++ 20 diimplementasikan dalam bentuk yang tercermin dalam rancangan standar saat ini dalam setidaknya satu kompiler, dan dalam sebagian besar kasus telah digunakan dalam kode produksi (yaitu, mereka sudah tersedia untuk pengguna yang sangat puas) .  Sebagai contoh, coroutine (diperkenalkan hanya lima bulan sebelum artikel ini) digunakan selama dua tahun dalam produksi di MSVC dan satu tahun di Clang, yang sangat senang dengan pelanggan besar (misalnya, Azure dan Facebook). </li><li>  Kami tidak akan menangkap banyak masalah interaksi antara fitur sampai pengguna mulai menggunakannya dalam produksi, yaitu, sebelum standar dirilis, karena banyak pengembang akan menunggu untuk dirilis untuk mengimplementasikan proyek yang berbeda.  Dan jika kami menunjukkan ketidakpastian tentang waktu rilis, maka implementasi ini juga akan ditunda.  Yah, mereka masih menerapkan sesuatu, tetapi banyak yang akan dijeda sampai pengembang yakin bahwa kami siap untuk rilis.  Tanyakan kepada pembuat &lt;nama kompiler favorit&gt; apa yang terjadi ketika mereka menerapkan &lt;nama fitur besar&gt; sebelum muncul dalam standar yang diterbitkan.  Dalam banyak kasus, perlu untuk menerapkan berulang kali, dan memutuskan konsumen berulang kali.  Karena itu, pengembang lebih suka menunggu panitia untuk menyetujui fitur tertentu. </li></ol><br>  Akhirnya, jangan lupa tentang masalah fitur interaksi.  Kami tidak hanya merilisnya ketika kami siap, setelah itu kami masih perlu waktu untuk mencari masalah interaksi antara fitur dan untuk menambahkan dukungan untuk interaksi tersebut, yang kami tidak dapat mengetahuinya sebelum fitur baru menjadi banyak digunakan.  Dan tidak masalah seberapa banyak kita menunda rilis standar, akan selalu ada interaksi yang hanya bisa kita eksplorasi nanti.  Anda perlu mengelola risiko ini dengan bantuan desain yang fleksibel, memastikan kompatibilitas fitur, dan tidak menunggu untuk menyingkirkan semua risiko. <br><br><h2>  Standar tidak akan pernah sempurna ... bukankah Anda merilis bug? </h2><br>  Ya <br><br>  Jika kami melihat bahwa fitur tersebut tidak siap, maka kami harus menghapusnya dari rilis. <br><br>  Jika kita melihat bahwa suatu fitur bisa lebih baik, dan kita tahu bahwa perubahan itu ternyata kompatibel dengan mundur, maka ini bukan alasan untuk menolak rilisnya sekarang.  Ini bisa dirilis sebagai ekstensi di C ++ berikut. <br><br>  Kami sengaja merilis fitur yang kami rencanakan untuk ditingkatkan di masa mendatang, sementara kami yakin bahwa kami dapat mempertahankan kompatibilitas ke belakang. <br><br><h2>  Tapi bukankah Anda harus mencoba meminimalkan kesalahan rilis? </h2><br>  Ya  Kami sedang berusaha. <br><br>  Namun kami tidak berusaha menghindari semua risiko.  Ada juga risiko dan (mungkin) harga menolak untuk melepaskan apa yang tampaknya siap untuk kita.  Dan lebih sering daripada tidak, kita benar. <br><br><h2>  Apakah Anda yakin sekarang kualitasnya lebih baik daripada menggunakan pendekatan (1)? </h2><br>  Ya <br><br>  Menurut metrik objektif, volume komentar dari berbagai negara dan laporan bug, C ++ 14 dan C ++ 17 adalah rilis kami yang paling stabil, dan dengan metrik ini, 3-4 kali lebih tinggi daripada C ++ 98 dan C ++ 11.  Dan alasannya justru karena keteraturan rilis, dalam menempatkan fitur besar pertama di cabang TS (termasuk deskripsi lengkap integrasi mereka dengan standar utama) dan dalam pemasukan berikutnya, ketika kami yakin akan kesiapan. <br><br>  Sejak 2012, standar utama <b>selalu</b> dipertahankan dalam kondisi hampir siap-kapal (bahkan draft konsep kerja dengan kualitas tinggi yang sama dengan rilis standar C ++ 98 dan C ++ 11).  Ini belum pernah terjadi sebelumnya, ketika kami menjaga pasien tanpa jaminan untuk waktu yang lama, dengan daftar panjang masalah dan organ menyebar, yang akan segera kami kembalikan.  Sekarang kita tahu bahwa kita dapat mempertahankan jadwal dengan pekerjaan yang berkualitas tinggi, karena kita selalu tetap dalam kondisi siap untuk rilis.  Jika Anda mau, Anda dapat merilis CD sekarang, tanpa bertemu di Cologne, dan kualitasnya akan jauh lebih tinggi dari sebelumnya dengan CD C ++ 98 atau C ++ 11 (sebenarnya, dan standar yang diterbitkan) .  Dan mengingat bahwa C ++ 98 dan C ++ 11 berhasil, pemahaman bahwa sekarang kualitasnya lebih tinggi berarti kita berada di jalur yang benar. <br><br><h2>  C ++ 98 dan C ++ 11 dikembangkan selama sekitar 9 tahun dan merupakan produk yang sangat bagus ... </h2><br>  Ya: 1989-1998 dan 2002-2011. <br><br><h2>  ... dan C ++ 14 dan C ++ 17 adalah rilis minor.  Apakah C ++ 20 rilis utama? </h2><br>  Saya ulangi, saya percaya bahwa itu benar untuk membandingkan C ++ 14 + 17 + 20 secara keseluruhan: ini adalah siklus sembilan tahun kami, tetapi karena kami menganut pendekatan (2), kami juga merilis perkembangan yang siap untuk menyelesaikan siklus tiga tahun dan enam tahun. . <br><br><h2>  Approach (2) memungkinkan Anda untuk mencapai sasaran berbasis fitur seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0592</a> untuk C ++ selanjutnya? </h2><br>  Tentu saja!  Meskipun tidak ada kata-kata di dalamnya seperti "harus menyertakan fitur-fitur ini", karena dengan demikian akan menjadi pendekatan (1). <br><br>  Berusaha keras untuk satu set fitur tertentu dan memberikan salah satu di antaranya prioritas adalah normal, tetapi kemudian itu adalah masalah prioritas.  Sejauh ini, kita hanya akan mengambil apa yang sudah siap, tetapi kita dapat memilih apa yang harus dikerjakan pertama-tama untuk mempersiapkan sesegera mungkin. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460665/">https://habr.com/ru/post/id460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460647/index.html">Memecahkan pekerjaan dengan pwnable.kr 05 - passcode. Tabel tautan prosedur penulisan ulang melalui kerentanan format string</a></li>
<li><a href="../id460651/index.html">Pertemuan Society of Anonymous Testers: TMS, pemantauan pemantauan, penilaian kualitas pencarian dan tes iOS asli</a></li>
<li><a href="../id460655/index.html">Bagaimana saya mematahkan Telegram</a></li>
<li><a href="../id460659/index.html">Menggunakan Pipa untuk Pivoting</a></li>
<li><a href="../id460661/index.html">Semua yang perlu Anda ketahui tentang Node.js</a></li>
<li><a href="../id460667/index.html">Otomatisasi pengujian layanan berbayar di iOS</a></li>
<li><a href="../id460669/index.html">Bagaimana memastikan keamanan pengembangan, menghemat waktu dan saraf</a></li>
<li><a href="../id460671/index.html">Kepemilikan dan pinjaman dalam D</a></li>
<li><a href="../id460673/index.html">Paparkan keajaiban DiffUtil</a></li>
<li><a href="../id460675/index.html">Ekstraksi Data Pembelajaran Mesin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>