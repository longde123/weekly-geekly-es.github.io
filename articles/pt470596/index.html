<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèº ü§∏ üê£ Recursos do Q e KDB + no exemplo de um servi√ßo em tempo real üíÉüèæ ü§µüèª ‚ÄºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que √© o KDB +, a linguagem de programa√ß√£o Q, quais s√£o seus pontos fortes e fracos, podem ser encontrados no meu artigo anterior e brevemente na int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos do Q e KDB + no exemplo de um servi√ßo em tempo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/">  O que √© o KDB +, a linguagem de programa√ß√£o Q, quais s√£o seus pontos fortes e fracos, podem ser encontrados no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior e brevemente na introdu√ß√£o.  No artigo, implementamos um servi√ßo em Q que processar√° o fluxo de dados recebidos e calcular√° por minuto v√°rias fun√ß√µes agregadas no modo "tempo real" (ou seja, haver√° tempo para calcular tudo at√© a pr√≥xima parte dos dados).  A principal caracter√≠stica do Q √© que √© uma linguagem vetorial que permite operar n√£o com objetos √∫nicos, mas com suas matrizes, matrizes de matrizes e outros objetos complexos.  Idiomas como Q e seus relacionados K, J, APL s√£o famosos por sua brevidade.  Geralmente, um programa que abrange v√°rias telas de c√≥digo em uma linguagem familiar como Java pode ser escrito nelas em v√°rias linhas.  √â exatamente isso que quero demonstrar neste artigo. <br><br><img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  O KDB + √© um banco de dados de coluna focado em volumes muito grandes de dados, classificados de uma certa maneira (principalmente por tempo).  √â usado, antes de tudo, em organiza√ß√µes financeiras - bancos, fundos de investimento, companhias de seguros.  O idioma Q √© um idioma interno do KDB + que permite trabalhar efetivamente com esses dados.  A ideologia de Q √© concis√£o e efici√™ncia, enquanto a clareza √© sacrificada.  Isso √© justificado pelo fato de que, em qualquer caso, a linguagem do vetor ser√° dif√≠cil de perceber, e a brevidade e a riqueza da grava√ß√£o permitem que voc√™ veja uma parte muito maior do programa em uma tela, o que facilita a compreens√£o. <br><br>  Neste artigo, estamos implementando um programa Q completo e voc√™ pode experiment√°-lo.  Para fazer isso, voc√™ precisar√° do Q. atual. √â poss√≠vel fazer o download da vers√£o gratuita de 32 bits no site da empresa kx - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.kx.com</a> .  L√°, se voc√™ estiver interessado, encontrar√° informa√ß√µes de refer√™ncia sobre Q, o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Q For Mortals</a> e v√°rios artigos sobre esse t√≥pico. <br><br>
<h3>  Declara√ß√£o do problema </h3><br>  H√° uma fonte que envia uma tabela de dados a cada 25 milissegundos.  Como o KDB + √© usado principalmente em finan√ßas, assumimos que esta √© uma tabela de negocia√ß√µes na qual existem as seguintes colunas: tempo (tempo em milissegundos), sym (nome da empresa na bolsa - <b>IBM</b> , <b>AAPL</b> , ...), pre√ßo (pre√ßo pelo qual as a√ß√µes foram compradas), tamanho (tamanho da transa√ß√£o).  Um intervalo de 25 milissegundos √© escolhido arbitrariamente, n√£o √© muito pequeno nem muito grande.  Sua presen√ßa significa que os dados que chegam ao servi√ßo j√° est√£o armazenados em buffer.  Seria f√°cil implementar o buffer no lado do servi√ßo, incluindo buffer din√¢mico, dependendo da carga atual, mas, por simplicidade, permanecemos em um intervalo fixo. <br><br>  O servi√ßo deve considerar por minuto, para cada caractere recebido da coluna sym, um conjunto de fun√ß√µes agregadas - pre√ßo m√°ximo, pre√ßo m√©dio, tamanho da soma etc.  informa√ß√£o √∫til.  Para simplificar, assumimos que todas as fun√ß√µes podem ser calculadas incrementalmente, ou seja,  para obter um novo valor, basta conhecer dois n√∫meros - o valor antigo e o valor recebido.  Por exemplo, as fun√ß√µes max, average, sum t√™m essa propriedade, mas a fun√ß√£o mediana n√£o. <br><br>  Tamb√©m assumimos que o fluxo de dados recebidos √© ordenado por tempo.  Isso nos dar√° a oportunidade de trabalhar apenas com o √∫ltimo minuto.  Na pr√°tica, basta trabalhar com os minutos atuais e anteriores, caso haja atraso nas atualiza√ß√µes.  Por simplicidade, n√£o consideraremos esse caso. <br><br><h3>  Fun√ß√µes agregadas </h3><br>  Listadas abaixo est√£o as fun√ß√µes agregadas necess√°rias.  Levei o m√°ximo poss√≠vel para aumentar a carga no servi√ßo: <br><br><ul><li>  alto - pre√ßo m√°ximo - pre√ßo m√°ximo por minuto. </li><li>  baixo - pre√ßo m√≠nimo - o pre√ßo m√≠nimo por minuto. </li><li>  firstPrice - primeiro pre√ßo - o primeiro pre√ßo por minuto. </li><li>  lastPrice - last price - o √∫ltimo pre√ßo por minuto. </li><li>  firstSize - primeiro tamanho - o primeiro tamanho da transa√ß√£o em um minuto. </li><li>  lastSize - last size - o √∫ltimo tamanho da oferta em um minuto. </li><li>  numTrades - count i - o n√∫mero de transa√ß√µes por minuto. </li><li>  volume - tamanho da soma - a soma dos tamanhos de transa√ß√£o por minuto. </li><li>  pvolume - sum price - a soma dos pre√ßos por minuto, necess√°ria para avgPrice. </li><li>  volume de neg√≥cios - pre√ßo soma * tamanho - volume total de transa√ß√µes por minuto. </li><li>  avgPrice - pvolume% numTrades - pre√ßo m√©dio por minuto. </li><li>  avgSize - volume% numTrades - tamanho m√©dio da negocia√ß√£o por minuto. </li><li>  vwap - volume% de rotatividade - o pre√ßo m√©dio por minuto ponderado pelo tamanho da transa√ß√£o. </li><li>  cumVolume - volume da soma - tamanho da transa√ß√£o acumulada durante todo o tempo. </li></ul><br>  Discuta imediatamente um ponto n√£o √≥bvio - como inicializar essas colunas pela primeira vez e a cada minuto seguinte.  Algumas colunas do tipo firstPrice precisam ser inicializadas com nulo sempre que seu valor n√£o √© definido.  Outros tipos de volume sempre devem ser definidos como 0. Ainda existem colunas que exigem uma abordagem combinada - por exemplo, cumVolume deve ser copiado do minuto anterior e, para o primeiro conjunto, como 0. Definiremos todos esses par√¢metros usando o dicion√°rio de tipos de dados (an√°logo do registro): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// list ! list ‚Äì  , 0n ‚Äì float null, 0N ‚Äì long null, `sym ‚Äì  , `sym1`sym2 ‚Äì   initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;00:00;0n;0n;0n;0n;0N;0N;0;0;0.0;0.0;0n;0n;0n;0); aggCols:reverse key[initWith] except `sym`time; //    , reverse  </span></span></code> </pre> <br>  Adicionei sym e time ao dicion√°rio por conveni√™ncia, agora initWith √© uma linha final da tabela agregada final, onde resta definir o sym e time corretos.  Voc√™ pode us√°-lo para adicionar novas linhas √† tabela. <br><br>  aggCols que precisamos ao criar uma fun√ß√£o agregada.  A lista precisa ser invertida devido √†s peculiaridades da ordem em que as express√µes s√£o calculadas em Q (da direita para a esquerda).  O objetivo √© fornecer computa√ß√£o na dire√ß√£o de alto para cumVolume, pois algumas colunas dependem das anteriores. <br><br>  Colunas a serem copiadas para um novo minuto do anterior, coluna sym adicionada por conveni√™ncia: <br><br><pre> <code class="cpp hljs">rollColumns:`sym`cumVolume;</code> </pre><br>  Agora, dividimos as colunas em grupos de acordo com a forma como elas devem ser atualizadas.  Tr√™s tipos podem ser distinguidos: <br><br><ol><li>  Baterias (volume, rotatividade, etc.) - devemos adicionar o valor de entrada ao anterior. </li><li>  Com um ponto especial (alto, baixo, ..) - o primeiro valor em um minuto √© obtido dos dados de entrada, o restante √© contado usando a fun√ß√£o. </li><li>  O resto.  Sempre contado usando uma fun√ß√£o. </li></ol><br>  Defina vari√°veis ‚Äã‚Äãpara estas classes: <br><br><pre> <code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize;</code> </pre><br><h3>  Ordem de c√°lculo </h3><br>  Atualizaremos a tabela agregada em dois est√°gios.  Por quest√µes de efici√™ncia, primeiro reduziremos a tabela de entrada para que haja uma linha restante para cada caractere e minuto.  O fato de todas as nossas fun√ß√µes serem incrementais e associativas nos garante que o resultado dessa etapa adicional n√£o ser√° alterado.  Voc√™ pode espremer a tabela usando o select: <br><br><pre> <code class="cpp hljs">select high:max price, low:min price ‚Ä¶ by sym,time.minute from table</code> </pre><br>  Este m√©todo possui um sinal de menos - o conjunto de colunas calculadas √© predefinido.  Felizmente, em Q, a sele√ß√£o tamb√©m √© implementada como uma fun√ß√£o em que voc√™ pode substituir argumentos criados dinamicamente: <br><br><pre> <code class="cpp hljs">?[table;whereClause;byClause;selectClause]</code> </pre><br>  N√£o descreverei detalhadamente o formato dos argumentos; no nosso caso, apenas as express√µes e select n√£o s√£o triviais e devem ser dicion√°rios das colunas do formul√°rio! Expressions.  Assim, a fun√ß√£o restritiva pode ser definida da seguinte maneira: <br><br><pre> <code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// each   map  Q    preprocess:?[;();`sym`time!`sym`time.minute;selExpression];</span></span></code> </pre><br>  Para maior clareza, usei a fun√ß√£o de an√°lise, que transforma uma string com uma express√£o Q em um valor que pode ser passado para a fun√ß√£o eval e que √© necess√°rio na sele√ß√£o da fun√ß√£o.  Observe tamb√©m que o pr√©-processo √© definido como uma proje√ß√£o (ou seja, uma fun√ß√£o com argumentos parcialmente definidos) da fun√ß√£o de sele√ß√£o, um argumento (tabela) est√° ausente.  Se aplicarmos o pr√©-processo a uma tabela, obteremos uma tabela reduzida. <br><br>  O segundo est√°gio √© atualizar a tabela agregada.  Primeiro, escrevemos o algoritmo no pseudoc√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each sym in inputTable idx: row index in agg table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym+currentTime; aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high]; aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume]; ‚Ä¶</code> </pre><br>  Em Q, em vez de loops, √© habitual usar fun√ß√µes de mapa / redu√ß√£o.  Mas como Q √© uma linguagem vetorial e todas as opera√ß√µes, podemos aplicar com seguran√ßa a todos os s√≠mbolos de uma s√≥ vez; ent√£o, como primeira aproxima√ß√£o, podemos fazer sem um ciclo, realizando opera√ß√µes com todos os s√≠mbolos de uma s√≥ vez: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; row:aggTable idx; aggTable[idx;`high]: row[`high] | inputTable`high; aggTable[idx;`volume]: row[`volume] + inputTable`volume; ‚Ä¶</code> </pre><br>  Mas podemos ir al√©m: em Q, existe um operador √∫nico e extremamente poderoso - o operador de atribui√ß√£o generalizada.  Permite alterar o conjunto de valores em uma estrutura de dados complexa usando uma lista de √≠ndices, fun√ß√µes e argumentos.  No nosso caso, fica assim: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; rows:aggTable idx; <span class="hljs-comment"><span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;‚Ä¶]: function[target[idx 0;idx 1;‚Ä¶];argument],     ‚Äì   .[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</span></span></code> </pre><br>  Infelizmente, para atribuir a uma tabela, voc√™ precisa de uma lista de linhas, n√£o de colunas, e precisa transpor a matriz (lista de colunas para uma lista de linhas) usando a fun√ß√£o flip.  Para uma tabela grande, isso √© desnecess√°rio; portanto, em vez disso, aplicamos a atribui√ß√£o generalizada a cada coluna separadamente, usando a fun√ß√£o map (que se parece com um ap√≥strofo): <br><br><pre> <code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</code> </pre><br>  Novamente usamos a fun√ß√£o de proje√ß√£o.  Observe tamb√©m que em Q, criar uma lista tamb√©m √© uma fun√ß√£o e podemos cham√°-la usando a fun√ß√£o each (map) para obter uma lista de listas. <br><br>  Para que o conjunto de colunas calculadas n√£o seja fixo, crie a express√£o acima dinamicamente.  Primeiro, definimos as fun√ß√µes para calcular cada coluna, usando as vari√°veis ‚Äã‚Äãrow e inp para referenciar dados agregados e de entrada: <br><br><pre> <code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume! (<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>);</code> </pre><br>  Algumas colunas s√£o especiais; seu primeiro valor n√£o deve ser calculado por uma fun√ß√£o.  Podemos determinar que √© o primeiro na linha da coluna [`numTrades] - se tiver 0, o valor ser√° o primeiro.  Q possui uma fun√ß√£o de sele√ß√£o -? [Lista booleana; lista1; lista2] - que seleciona um valor da lista 1 ou 2, dependendo da condi√ß√£o no primeiro argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high] // @ -         @[`aggExpression;specialCols;{[x;y]"?[isFirst;inp`",y,";",x,"]"};string specialCols];</span></span></code> </pre><br>  Aqui chamei uma atribui√ß√£o gen√©rica com a minha fun√ß√£o (express√£o entre chaves).  O valor atual (o primeiro argumento) e um argumento adicional, que passo no 4¬∫ par√¢metro, s√£o passados ‚Äã‚Äãpara ele. <br><br>  Separadamente, adicionamos alto-falantes da bateria, porque para eles a fun√ß√£o √© a mesma: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume aggExpression[accumulatorCols]:{"row[`",x,"]+inp`",x } each string accumulatorCols;</span></span></code> </pre><br>  Essa √© uma tarefa usual pelos padr√µes de Q, s√≥ atribuo uma lista de valores de uma s√≥ vez.  Por fim, crie a fun√ß√£o principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,          // string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,'   map[concat] // ";" sv exprs ‚Äì String from Vector (sv),     ‚Äú;‚Äù  updateAgg:value "{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;(",(";"sv string[aggCols],'":",/:aggExpression aggCols),")]}";</span></span></code> </pre><br>  Com essa express√£o, crio dinamicamente uma fun√ß√£o a partir de uma sequ√™ncia que cont√©m a express√£o que citei acima.  O resultado ser√° semelhante a este: <br><br><pre> <code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;‚Ä¶ ; high:?[isFirst;inp`high;row[`high]|inp`high])]}</code> </pre><br>  A ordem de c√°lculo das colunas √© invertida, pois em Q a ordem de c√°lculo √© da direita para a esquerda. <br><br>  Agora, temos duas fun√ß√µes principais necess√°rias para os c√°lculos, resta adicionar um pouco de infraestrutura e o servi√ßo est√° pronto. <br><br><h3>  Etapas finais </h3><br>  Temos fun√ß√µes de pr√©-processo e updateAgg que fazem todo o trabalho.  Mas ainda √© necess√°rio garantir a transi√ß√£o correta em minutos e calcular os √≠ndices de agrega√ß√£o.  Primeiro, definimos a fun√ß√£o init: <br><br><pre> <code class="cpp hljs">init:{ tradeAgg:: <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-meta"><span class="hljs-meta">#enlist[initWith]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    , enlist    ,  0#   0    currTime::00:00; //   0, :: ,      currSyms::`u#`symbol$(); // `u# -    ,     offset::0; //   tradeAgg,     rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; //     roll ,    sym }</span></span></span></span></code> </pre><br>  Tamb√©m definimos a fun√ß√£o roll, que mudar√° o minuto atual: <br><br><pre> <code class="cpp hljs">roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; <span class="hljs-comment"><span class="hljs-comment">//    ,    init rollCache,::offset _ rollColumns#tradeAgg; //   ‚Äì  roll   aggTable, ,   rollCache offset::count tradeAgg; currSyms::`u#`$(); }</span></span></code> </pre><br>  Precisamos de uma fun√ß√£o para adicionar novos caracteres: <br><br><pre> <code class="java hljs">addSyms:{[syms] currSyms,::syms; <span class="hljs-comment"><span class="hljs-comment">//     //    sym, time  rollColumns   . //  ^      roll ,     . value flip table     . `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }</span></span></code> </pre><br>  E, finalmente, a fun√ß√£o upd (o nome tradicional dessa fun√ß√£o para os servi√ßos Q), chamada pelo cliente, para adicionar dados: <br><br><pre> <code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment"><span class="hljs-comment">// tblName   ,       tm:exec distinct time from data:() xkey preprocess data; // preprocess &amp; calc time updMinute[data] each tm; //      }; updMinute:{[data;tm] if[tm&lt;&gt;currTime; roll tm; currTime::tm]; //  ,   data:select from data where time=tm; //  if[count msyms:syms where not (syms:data`sym)in currSyms; addSyms msyms]; //   updateAgg[`tradeAgg;offset+currSyms?syms;data]; //   .  ?        . };</span></span></code> </pre><br>  Isso √© tudo.  Aqui est√° o c√≥digo completo do nosso servi√ßo, conforme prometido, apenas algumas linhas: <br><br><pre> <code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>); aggCols:reverse key[initWith] except `sym`time; rollColumns:`sym`cumVolume; accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize; selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; preprocess:?[;();`sym`time!`sym`time.minute;selExpression]; aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>); @[`aggExpression;specialCols;{<span class="hljs-string"><span class="hljs-string">"?[isFirst;inp`"</span></span>,y,<span class="hljs-string"><span class="hljs-string">";"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]"</span></span>};<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> specialCols]; aggExpression[accumulatorCols]:{<span class="hljs-string"><span class="hljs-string">"row[`"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]+inp`"</span></span>,x } each <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> accumulatorCols; updateAgg:value <span class="hljs-string"><span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span></span>,(<span class="hljs-string"><span class="hljs-string">";"</span></span>sv <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[aggCols],<span class="hljs-string"><span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span></span> init:{ tradeAgg::<span class="hljs-number"><span class="hljs-number">0</span></span>#enlist[initWith]; currTime::<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>; currSyms::`u#`symbol$(); offset::<span class="hljs-number"><span class="hljs-number">0</span></span>; rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; }; roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; rollCache,::offset _ rollColumns#tradeAgg; offset::count tradeAgg; currSyms::`u#`$(); }; addSyms:{[syms] currSyms,::syms; `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }; upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data}; updMinute:{[data;tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; data:select from data where time=tm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[count msyms:syms where <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (syms:data`sym)in currSyms; addSyms msyms]; updateAgg[`tradeAgg;offset+currSyms?syms;data]; };</code> </pre><br><h3>  Teste </h3><br>  Verifique o desempenho do servi√ßo.  Para fazer isso, execute-o em um processo separado (coloque o c√≥digo no arquivo service.q) e chame a fun√ß√£o init: <br><br><pre> <code class="plaintext hljs">q service.q ‚Äìp 5566 q)init[]</code> </pre><br>  Em outro console, inicie o segundo processo Q e conecte-se ao primeiro: <br><br><pre> <code class="cpp hljs">h:hopen `:host:<span class="hljs-number"><span class="hljs-number">5566</span></span> h:hopen <span class="hljs-number"><span class="hljs-number">5566</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Primeiro, crie uma lista de caracteres - 10.000 pe√ßas e adicione uma fun√ß√£o para criar uma tabela aleat√≥ria.  No segundo console: <br><br><pre> <code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number"><span class="hljs-number">-9997</span></span>?`<span class="hljs-number"><span class="hljs-number">8</span></span> rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number"><span class="hljs-number">25</span></span>; price:n?<span class="hljs-number"><span class="hljs-number">10f</span></span>; size:n?<span class="hljs-number"><span class="hljs-number">10</span></span>)}</code> </pre><br>  Adicionei tr√™s caracteres reais √† lista de caracteres para torn√°-lo mais conveniente para procur√°-los na tabela.  A fun√ß√£o rnd cria uma tabela aleat√≥ria com n linhas, onde o tempo varia de t a t + 25 milissegundos. <br><br>  Agora voc√™ pode tentar enviar dados para o servi√ßo (adicione as primeiras dez horas): <br><br><pre> <code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number"><span class="hljs-number">10000</span></span>;x])} each `time$<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> + til <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Voc√™ pode verificar no servi√ßo se a tabela foi atualizada: <br><br><pre> <code class="cpp hljs">\c <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> select from tradeAgg where sym=`AAPL <span class="hljs-number"><span class="hljs-number">-20</span></span>#select from tradeAgg where sym=`AAPL</code> </pre><br>  Resultado: <br><br><pre> <code class="1c hljs">sym<span class="hljs-string"><span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume --|--|--|--|--|-------------------------------- AAPL|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888 AAPL|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895 AAPL|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909 AAPL|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915 AAPL|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></span></code> </pre> <br>  Agora, realizaremos testes de carga para descobrir quantos dados o servi√ßo pode processar por minuto.  Deixe-me lembr√°-lo de que definimos o intervalo de atualiza√ß√µes para 25 milissegundos.  Assim, um servi√ßo deve (em m√©dia) caber em pelo menos 20 milissegundos por atualiza√ß√£o para dar aos usu√°rios tempo para solicitar dados.  Digite o seguinte no segundo processo: <br><br><pre> <code class="cpp hljs">tm:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.000</span></span> stressTest:{[n] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[tm],<span class="hljs-string"><span class="hljs-string">" "</span></span>; times,::h ({st:.zT; upd[`trade;x]; .zT-st};rnd[n;tm]); tm+:<span class="hljs-number"><span class="hljs-number">25</span></span>} start:{[n] times::(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>[<span class="hljs-number"><span class="hljs-number">4800</span></span>;stressTest[n]]; <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; `min`avg`med`max!(min times;avg times;med times;max times)}</code> </pre><br>  4800 √© de dois minutos.  Voc√™ pode tentar come√ßar primeiro por 1000 linhas a cada 25 milissegundos: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  No meu caso, o resultado √© de alguns milissegundos por atualiza√ß√£o.  Ent√£o, aumentarei imediatamente o n√∫mero de linhas para 10.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  Resultado: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.004</span></span> avg| <span class="hljs-number"><span class="hljs-number">9.191458</span></span> med| <span class="hljs-number"><span class="hljs-number">9f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.030</span></span></code> </pre><br>  Novamente, nada de especial, mas s√£o 24 milh√µes de linhas por minuto, 400 mil por segundo.  Por mais de 25 milissegundos, a atualiza√ß√£o diminuiu apenas 5 vezes, aparentemente ao alterar o minuto.  Aumente para 100.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  Resultado: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.013</span></span> avg| <span class="hljs-number"><span class="hljs-number">25.11083</span></span> med| <span class="hljs-number"><span class="hljs-number">24f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.108</span></span> q)sum times <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">00.532</span></span></code> </pre><br>  Como voc√™ pode ver, o servi√ßo mal lida, mas mesmo assim consegue se manter √† tona.  Essa quantidade de dados (240 milh√µes de linhas por minuto) √© extremamente grande; nesses casos, √© habitual executar v√°rios clones (ou mesmo dezenas de clones) do servi√ßo, cada um dos quais processa apenas parte dos caracteres.  No entanto, o resultado √© impressionante para a linguagem interpretada, focada principalmente no armazenamento de dados. <br><br>  A quest√£o pode surgir: por que o tempo cresce de maneira n√£o linear com o tamanho de cada atualiza√ß√£o?  O motivo √© que a fun√ß√£o de compress√£o √© realmente uma fun√ß√£o C que funciona muito mais eficientemente que o updateAgg.  Come√ßando com algum tamanho de atualiza√ß√£o (cerca de 10.000), o updateAgg atinge seu limite m√°ximo e, em seguida, seu tempo de execu√ß√£o n√£o depende do tamanho da atualiza√ß√£o.  √â devido √† etapa preliminar Q que o servi√ßo √© capaz de digerir esses volumes de dados.  Isso enfatiza a import√¢ncia de trabalhar com big data para escolher o algoritmo certo.  Outro ponto √© o armazenamento correto de dados na mem√≥ria.  Se os dados n√£o estivessem armazenados em colunas ou n√£o fossem ordenados por tempo, nos familiarizar√≠amos com falta de cache TLB - a aus√™ncia de um endere√ßo de p√°gina de mem√≥ria no cache de endere√ßo do processador.  A localiza√ß√£o do endere√ßo leva cerca de 30 vezes mais em caso de falha e, no caso de dados dispersos, pode retardar o servi√ßo v√°rias vezes. <br><br><h3>  Conclus√£o </h3><br>  Neste artigo, mostrei que os bancos de dados KDB + e Q s√£o adequados n√£o apenas para armazenar big data e f√°cil acesso a eles via select, mas tamb√©m para criar servi√ßos de processamento de dados que podem digerir centenas de milh√µes de linhas / gigabytes de dados, mesmo em um √∫nico processo Q .  A pr√≥pria linguagem Q permite a implementa√ß√£o r√°pida e eficiente de algoritmos relacionados ao processamento de dados devido √† sua natureza vetorial, o int√©rprete interno do dialeto SQL e um conjunto muito bem-sucedido de fun√ß√µes da biblioteca. <br><br>  Vou notar que o exposto acima √© apenas parte dos recursos do Q, possui outros recursos exclusivos.  Por exemplo, um protocolo IPC extremamente simples que apaga a fronteira entre processos Q individuais e permite combinar centenas desses processos em uma √∫nica rede, que pode estar localizada em dezenas de servidores em diferentes partes do mundo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470596/">https://habr.com/ru/post/pt470596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470578/index.html">Como "humanizamos" a contabilidade em um banco m√≥vel</a></li>
<li><a href="../pt470582/index.html">Verificando a interface do usu√°rio da Telerik quanto √† UWP como uma maneira de come√ßar a usar o PVS-Studio</a></li>
<li><a href="../pt470584/index.html">Verifique a interface do usu√°rio da Telerik para obter UWP para se familiarizar com o PVS-Studio</a></li>
<li><a href="../pt470592/index.html">Revis√£o do Plesk - pain√©is de controle de hospedagem e site</a></li>
<li><a href="../pt470594/index.html">Relat√≥rio do show de luzes ‚ÄúCircle of Light‚Äù 2019 em Moscou</a></li>
<li><a href="../pt470598/index.html">O livro "Java moderno. Express√µes, fluxos e programa√ß√£o funcional Lambda ‚Äù</a></li>
<li><a href="../pt470600/index.html">Sobre consoles noVNC seguros, escalonamento autom√°tico em Kubernetes, Haproxy em Ostrovka e o trabalho de administradores com programadores</a></li>
<li><a href="../pt470602/index.html">Como seria o metr√¥ de Moscou em um mundo tridimensional</a></li>
<li><a href="../pt470604/index.html">Velocidade de carregamento de sites no com√©rcio eletr√¥nico: an√°lise das 48 principais lojas online da R√∫ssia</a></li>
<li><a href="../pt470608/index.html">Otimiza√ß√£o da interface do usu√°rio do Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>