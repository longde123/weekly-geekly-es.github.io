<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸš´ğŸ¼ ğŸ™ğŸ» Cara Kerja Chrome Tanpa Kepala ğŸ•¤ ğŸ‘‰ğŸ¿ ğŸ‘¶ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah jelas dari namanya bahwa browser tanpa kepala adalah sesuatu tanpa kepala. Dalam konteks frontend, ini adalah alat yang sangat diperlukan bagi p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja Chrome Tanpa Kepala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421137/">  Sudah jelas dari namanya bahwa browser tanpa kepala adalah sesuatu tanpa kepala.  Dalam konteks frontend, ini adalah alat yang sangat diperlukan bagi pengembang, yang dengannya Anda dapat menguji kode, memeriksa kualitas dan kepatuhan dengan tata letak.  Vitaliy Slobodin di Frontend Conf memutuskan bahwa perlu untuk mengenal perangkat alat ini lebih dekat. <br><br>  Di bawah komponen terpotong dan fitur Chrome Tanpa Kepala, skenario menarik untuk menggunakan Chrome Tanpa Kepala.  Bagian kedua tentang Puppeteer adalah perpustakaan Node.js yang nyaman untuk mengelola mode Tanpa Kepala di Google Chrome dan Chromium. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Vitaliy Slobodin - mantan pengembang PhantomJS - yang menutup dan menguburnya.  Terkadang ini membantu Konstantin Tokarev ( <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">annulen</a></u> ) dalam versi QtWebKit yang "dihidupkan kembali" - yang sangat QtWebKit, di mana ada dukungan untuk ES6, Flexbox dan banyak standar modern lainnya. <br><br>  Vitaliy suka menjelajahi peramban, menggali WebKit, Chrome, dan sebagainya di waktu luangnya, dan banyak lagi.  Kami akan berbicara tentang browser hari ini, yaitu tentang browser tanpa kepala dan seluruh keluarga hantu mereka. <a name="habracut"></a><br><br><h2>  <strong>Apa itu browser tanpa kepala?</strong> <br></h2><br>  Sudah dari namanya jelas bahwa ini adalah sesuatu tanpa kepala.  Dalam konteks browser, ini berarti yang berikut. <br><br><ol><li>  Itu <strong>tidak memiliki rendering nyata dari konten</strong> , yaitu, itu <strong>menarik</strong> semuanya dalam memori. </li><li> Karena ini, <strong>memori yang digunakan lebih sedikit</strong> , karena tidak perlu menggambar atau gigabyte PNG yang orang coba masukkan ke backend menggunakan bom. </li><li>  Ini <strong>bekerja lebih cepat</strong> karena tidak perlu membuat apa pun di layar nyata. </li><li>  Memiliki <strong>antarmuka pemrograman untuk manajemen</strong> .  Anda bertanya - dia tidak memiliki antarmuka, tombol, windows?  Bagaimana cara mengelolanya?  Oleh karena itu, tentu saja, ia memiliki antarmuka untuk manajemen. </li><li>  Properti penting adalah <strong>kemampuan untuk menginstal pada server Linux telanjang</strong> .  Hal ini diperlukan agar jika Anda memiliki Ubuntu atau Red Hat yang baru diinstal, Anda bisa menjatuhkan biner atau meletakkan paket di sana, dan browser akan berfungsi di luar kotak.  Tidak perlu perdukunan atau sihir voodoo. </li></ol><br>  Ini adalah browser berbasis WebKit yang khas.  Anda tidak dapat memahami komponen - ini hanya gambar visual. <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br>  Kami hanya tertarik pada komponen teratas UI Browser.  Ini adalah antarmuka pengguna yang sama - windows, menu, notifikasi pop-up dan yang lainnya. <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br>  Seperti inilah tampilan browser tanpa kepala.  Perhatikan perbedaannya?  Kami sepenuhnya menghapus antarmuka pengguna.  Dia tidak ada lagi.  <strong>Hanya peramban yang tersisa</strong> . <br><br>  Hari ini kita akan berbicara tentang Chrome Tanpa Kepala ().  Apa perbedaan di antara mereka?  Faktanya, Chrome adalah versi merek Chromium, yang memiliki codec eksklusif, H.264 yang sama, integrasi dengan layanan Google dan yang lainnya.  Chromium hanyalah implementasi sumber terbuka. <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br>  Tanggal lahir Chrome tanpa kepala: 2016.  Jika Anda menemukan dia, Anda dapat mengajukan pertanyaan rumit kepada saya: "Bagaimana bisa, saya ingat berita tahun 2017?"  Faktanya adalah tim insinyur dari Google menghubungi pengembang PhantomJS pada tahun 2016, ketika mereka baru mulai menerapkan mode Headless di Chrome.  Kami menulis seluruh Google Docks, bagaimana kami akan mengimplementasikan antarmuka dan sebagainya.  Kemudian Google ingin membuat antarmuka yang sepenuhnya kompatibel dengan PhantomJS.  Baru pada saat itulah tim insinyur memutuskan untuk tidak melakukan kompatibilitas seperti itu. <br><br>  Kami akan berbicara tentang antarmuka manajemen (API), yang merupakan protokol Chrome DevTools, nanti dan lihat apa yang dapat Anda lakukan dengannya. <br><br>  Artikel ini akan dibangun berdasarkan prinsip piramida Dalang (dari Dalang Inggris).  Nama yang baik dipilih - dalang adalah orang yang mengendalikan semua orang! <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br>  Di dasar piramida adalah Chrome Tanpa Kepala - Chrome Tanpa Kepala - apa itu? <br><br><h2>  <strong>Chrome tanpa kepala</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br>  Di tengah - Browser tanpa kepala - Chromium atau Chrome yang sama (biasanya Chromium).  Ia memiliki apa yang disebut renderers (RENDERER) - proses yang menarik konten halaman (jendela Anda).  Selain itu, setiap tab membutuhkan penyaji sendiri, jadi jika Anda membuka banyak tab, maka Chrome akan memulai sebanyak mungkin proses rendering. <br><br>  Di atas semua ini adalah aplikasi Anda.  Jika kami menggunakan Chromium atau Chrome Tanpa Kepala, maka Chrome akan ada di atasnya, atau beberapa aplikasi tempat Anda dapat menyematkannya.  Analog terdekat dapat disebut Steam.  Semua orang tahu bahwa pada dasarnya Steam hanyalah peramban ke situs web Steam.  Dia, tentu saja, bukan tanpa kepala, tetapi mirip dengan skema ini. <br><br>  Ada 2 cara untuk menyematkan Chrome tanpa kepala di aplikasi Anda (atau menggunakannya): <br><br><ol><li>  Standar saat Anda menggunakan <strong>Dalang</strong> dan menggunakan Chrome Tanpa Kepala. <br></li><li>  Ketika Anda mengambil komponen <strong>perpustakaan tanpa kepala</strong> , yaitu, perpustakaan yang mengimplementasikan mode tanpa kepala, dan menanamkannya ke dalam aplikasi Anda, misalnya, di C ++. <br></li></ol><br>  Anda mungkin bertanya, mengapa C ++ ada di ujung depan?  Jawabannya adalah DevTools C ++ API.  Anda dapat menerapkan dan menggunakan fitur Chrome tanpa kepala dengan berbagai cara.  Jika Anda menggunakan Puppeteer, komunikasi dengan browser tanpa kepala akan dilakukan melalui soket web.  Jika Anda menyematkan pustaka Headless di aplikasi desktop, Anda akan menggunakan antarmuka asli, yang ditulis dalam C ++. <br><br>  Namun selain semua ini, Anda masih memiliki hal-hal tambahan, termasuk: <br><br><ul><li>  <strong>Custom networking</strong> - implementasi kustom interaksi dengan jaringan.  Katakanlah Anda bekerja di bank atau di lembaga pemerintah, yang terdiri dari tiga huruf dan dimulai dengan "F", dan menggunakan otentikasi yang sangat rumit atau protokol otorisasi yang tidak didukung oleh browser.  Oleh karena itu, Anda mungkin memerlukan penangan khusus untuk jaringan Anda.  Anda cukup mengambil pustaka yang sudah diterapkan dan menggunakannya di Chrome. </li><li>  <strong>Modul Mojo</strong> .  Analog Mojo terdekat adalah binder asli di Node.js dengan pustaka asli Anda yang ditulis dalam C ++.  Mojo melakukan hal yang sama - Anda mengambil perpustakaan asli Anda, menulis antarmuka Mojo untuknya, dan kemudian Anda dapat memanggil metode perpustakaan asli Anda di browser Anda. </li></ul><br><h3>  Komponen Chromium <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br>  Sekali lagi saya mendengar pertanyaan rumit: â€œMengapa saya perlu skema yang mengerikan ini?  Saya menulis di bawah (masukkan nama kerangka kerja favorit Anda). " <br><br><blockquote>  Saya percaya bahwa seorang pengembang harus tahu cara kerja alatnya.  Jika Anda menulis di bawah React, Anda harus tahu bagaimana React bekerja.  Jika Anda menulis di bawah Angular, Anda harus tahu apa yang dimiliki Angular di bawah tenda. <br></blockquote><br>  Karena dalam hal sesuatu, misalnya, kesalahan fatal atau bug yang sangat serius dalam produksi, Anda harus berurusan dengan "nyali", dan Anda bisa saja tersesat di sana - di mana, apa dan bagaimana.  Jika Anda, misalnya, menulis tes atau menggunakan Chrome Tanpa Kepala, Anda juga mungkin menemukan beberapa perilaku dan bug yang aneh.  Karenanya, saya akan secara singkat memberi tahu Anda apa yang memiliki komponen Chromium.  Saat Anda melihat jejak tumpukan besar, Anda sudah tahu cara menggali dan cara memperbaikinya sama sekali. <br><br>  Level terendah dari <strong>lapisan Platform</strong> .  Komponennya: <br><br><ul><li>  <strong>Ozone</strong> , window manager abstrak di Chrome, adalah apa yang window manager berinteraksi dengan sistem operasi.  Di Linux, itu adalah server-X atau Wayland.  Pada Windows, itu adalah manajer jendela Windows. </li><li>  <strong>Penjadwal</strong> adalah penjadwal yang sama yang tanpanya kita tidak ada di mana-mana, karena kita semua tahu bahwa Chrome adalah aplikasi multi-proses, dan kita perlu entah bagaimana menyelesaikan semua utas, proses, dan yang lainnya. </li><li>  <strong>Net</strong> - browser harus selalu memiliki komponen untuk bekerja dengan jaringan, misalnya, mem-parsing HTTP, membuat tajuk, mengedit, dll. </li></ul><br>  <strong>Lapisan Konten</strong> adalah komponen terbesar yang dimiliki Chrome.  Itu termasuk: <br><br><ul><li>  <strong>Blink</strong> adalah mesin web berbasis WebCore dari WebKit.  Itu bisa menggunakan HTML sebagai string, parse, jalankan JavaScript - dan hanya itu.  Dia tidak lagi tahu bagaimana melakukan apa pun: tidak bekerja dengan jaringan, atau menggambar - semua ini terjadi di atas Blink. <br>  Blink meliputi: versi WebCore yang sangat dimodifikasi - mesin web untuk bekerja dengan HTML dan CSS;  V8 (mesin JavaScript);  serta API untuk semua ekstensi yang kami gunakan di Chrome, seperti pemblokir iklan.  Ini juga termasuk protokol DevTools. <br></li><li>  <strong>API Konten</strong> adalah antarmuka yang dengannya Anda dapat dengan mudah menggunakan semua fitur mesin web.  Karena ada banyak hal di dalam Blink (mungkin lebih dari satu juta antarmuka), agar tidak tersesat dalam semua metode dan fungsi ini, Anda memerlukan API Konten.  Anda memasukkan HTML, mesin akan secara otomatis memprosesnya, mengurai DOM, membangun CSS OM, menjalankan JavaScript, menjalankan pengatur waktu, penangan, dan yang lainnya. <br></li></ul><br>  Tingkat <strong>lapisan</strong> tanpa kepala - tingkat browser tanpa kepala: <br><br><ul><li>  <strong>Perpustakaan tanpa kepala</strong> . </li><li>  <strong>Antarmuka Embedder API</strong> untuk menyematkan pustaka Headless dalam aplikasi. </li><li>  <strong>API Klien</strong> adalah antarmuka yang digunakan Puppeteer. </li></ul><br>  <strong>Lapisan aplikasi Lapisan aplikasi</strong> : <br><br><ul><li>  Aplikasi Anda ( <strong>Aplikasi embedding</strong> ); </li><li>  Gadget, misalnya, <strong>Shell tanpa kepala</strong> . </li></ul><br>  Sekarang mari kita naik dari kedalaman sedikit lebih tinggi, aktifkan - sekarang frontend akan pergi. <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Protokol Chrome DevTools <br></h3><br>  Kita semua menemukan protokol Chrome DevTools, karena kami menggunakan panel pengembang di Chrome atau debugger jarak jauh - alat pengembangan yang sama.  Jika Anda menjalankan alat pengembang dari jarak jauh, komunikasi dengan browser terjadi menggunakan protokol DevTools.  Saat Anda menginstal debugger, lihat cakupan kode, gunakan geolokasi atau yang lainnya - semua ini dikontrol menggunakan DevTools. <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br>  Bahkan, protokol DevTools sendiri memiliki sejumlah besar metode.  Alat pengembang Anda tidak memiliki akses, mungkin hingga 80% darinya.  Sungguh, Anda bisa melakukan semuanya di sana! <br><br>  Mari kita lihat protokol ini.  Sebenarnya, ini sangat sederhana.  Ini memiliki 2 komponen: <br><br><ol><li>  Target DevTools - tab yang Anda periksa; <br></li><li>  Klien DevTools - katakanlah ini adalah panel pengembang yang diluncurkan dari jarak jauh. <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br>  Mereka berkomunikasi menggunakan JSON sederhana: <br><br><ul><li>  Ada pengidentifikasi untuk perintah, nama metode yang akan dieksekusi, dan beberapa parameter. </li><li>  Kami mengirim permintaan dan mendapatkan jawaban yang juga terlihat sangat sederhana: pengidentifikasi yang diperlukan karena semua perintah yang dijalankan menggunakan protokol tidak sinkron.  Agar kami dapat selalu membandingkan respons mana dengan tim mana yang kami terima, kami membutuhkan pengidentifikasi. </li><li>  Ada hasilnya.  Dalam kasus kami, ini adalah objek hasil dengan atribut berikut: <strong>ketik:</strong> <strong>"angka",</strong> <strong>nilai:</strong> <strong>2,</strong> <strong>deskripsi:</strong> <strong>"2"</strong> , tidak terkecuali dilemparkan: <strong>wasThrown:</strong> <strong>false.</strong> <br></li></ul><br>  Tetapi di antara hal-hal lain, tab Anda dapat mengirim acara kembali kepada Anda.  Misalkan ketika suatu peristiwa pada halaman terjadi, atau ada pengecualian pada suatu halaman, Anda akan menerima pemberitahuan melalui protokol ini. <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>Dalang</strong> <br></h2><br>  Anda dapat menginstal Puppeteer menggunakan manajer paket favorit Anda - baik itu benang, npm atau lainnya. <br><br>  Menggunakannya juga mudah - cukup minta saja di skrip Node.js Anda, dan Anda sudah bisa menggunakannya. <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br>  Dengan menggunakan tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://try-puppeteer.appspot.com,</a> Anda dapat menulis skrip langsung di situs, jalankan dan dapatkan hasilnya langsung di peramban.  Semua ini akan diimplementasikan menggunakan Chrome Tanpa Kepala. <br><br>  Pertimbangkan skrip paling sederhana di bawah Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br>  Di sini kita cukup membuka halaman dan mencetaknya dalam PDF.  Mari kita lihat operasi skrip ini secara real time: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Semuanya akan keren, tetapi tidak jelas apa yang ada di dalamnya.  Tentu saja, kami memiliki browser tanpa kepala, tetapi kami tidak melihat apa pun.  Oleh karena itu, Dalang memiliki bendera khusus yang disebut tanpa kepala: false: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br>  Diperlukan untuk meluncurkan browser tanpa kepala dalam mode headful, ketika Anda dapat melihat beberapa jendela dan melihat apa yang terjadi pada halaman Anda secara real time, yaitu, bagaimana skrip Anda berinteraksi dengan halaman Anda. <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br>  Ini akan terlihat skrip yang sama ketika kita menambahkan bendera ini.  Jendela browser muncul di sebelah kiri - lebih jelas. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Pro dalang:</strong> <br><br>  + Ini adalah perpustakaan Node.js untuk Chrome tanpa kepala. <br>  + Dukungan untuk versi lawas Node.js&gt; = 6. <br>  + Instalasi mudah. <br>  + API tingkat tinggi untuk mengelola seluruh mesin raksasa ini. <br><br>  Chrome Tanpa Kepala memasang dengan mudah dan tanpa intervensi sistem.  Pada instalasi pertama, Puppeteer mengunduh versi Chromium dan menginstalnya langsung di folder node_modules khusus untuk arsitektur dan OS Anda.  Anda tidak perlu mengunduh apa pun, itu dilakukan secara otomatis.  Anda juga dapat menggunakan versi Chrome favorit Anda, yang diinstal pada sistem Anda.  Anda dapat melakukan ini juga - Dalang memberi Anda API semacam itu. <br><br>  Sayangnya, ada juga kelemahannya, jika kita hanya mengambil instalasi dasar saja. <br><br>  <strong>Cons Puppeteer</strong> : <br><br>  - <strong>Tidak ada fungsi tingkat atas</strong> : sinkronisasi bookmark dan kata sandi;  dukungan profil;  akselerasi perangkat keras dll. <br>  - <strong>Render perangkat lunak</strong> adalah minus yang paling signifikan.  Semua perhitungan dan render dilakukan pada CPU Anda.  Tapi di sini, para insinyur Google akan segera mengejutkan kami - pengerjaan implementasi akselerasi perangkat keras sudah berlangsung.  Sudah sekarang Anda dapat mencoba menggunakannya jika Anda berani dan berani. <br>  - Sampai saat ini, tidak ada dukungan untuk ekstensi - sekarang ada!  Jika Anda adalah pengembang yang licik, Anda dapat mengambil AdBlock favorit Anda, tentukan bagaimana Puppeteer akan menggunakannya, dan semua iklan akan diblokir. <br>  - <strong>Tidak ada dukungan audio / video</strong> .  Karena, yah, kenapa tanpa browser audio dan video. <br><br>  <strong>Apa yang bisa Dalang:</strong> <br><br><ul><li>  Sesi Isolasi. </li><li>  Pengatur waktu virtual. </li><li>  Intersepsi permintaan jaringan. </li></ul><br>  Dan beberapa hal keren yang akan saya tunjukkan sedikit lebih jauh. <br><br><h4>  Isolasi Sesi <br></h4><br>  Ada apa, dengan apa dimakan, dan apakah kita tidak akan tersedak?  - Jangan tersedak! <br><br>  Isolasi sesi adalah <strong>"repositori" yang terpisah untuk setiap tab</strong> .  Saat Anda memulai Dalang, Anda dapat membuat halaman baru, dan setiap halaman baru dapat memiliki repositori sendiri, termasuk: <br><br><ul><li>  memasak <br></li><li>  penyimpanan lokal; <br></li><li>  cache. <br></li></ul><br>  Semua halaman akan hidup secara independen satu sama lain.  Ini diperlukan, misalnya, untuk mempertahankan keaslian dari pengujian. <br><br>  Isolasi sesi <strong>menghemat sumber daya dan waktu ketika memulai sesi paralel</strong> .  Misalkan Anda sedang menguji situs yang sedang dibangun dalam mode pengembangan, yaitu, bundel tidak diminimalkan, dan beratnya 20 MB.  Jika Anda hanya ingin me-cache-nya, Anda bisa memberi tahu Puppeteer untuk menggunakan cache yang umum untuk semua halaman yang dibuat, dan bundel ini akan di-cache. <br><br>  Anda dapat membuat <strong>serial sesi untuk digunakan nanti</strong> .  Anda menulis tes yang memeriksa tindakan tertentu di situs Anda.  Tetapi Anda memiliki masalah - situs tersebut memerlukan otorisasi.  Anda tidak akan terus-menerus menambahkan sebelumnya dalam setiap pengujian untuk otorisasi di situs.  Dalang memungkinkan Anda untuk masuk ke situs sekali, dan kemudian menggunakan kembali sesi ini di masa depan. <br><br><h4>  Pengatur waktu virtual <br></h4><br>  Anda mungkin sudah menggunakan penghitung waktu virtual.  Jika Anda memindahkan slider di alat pengembang yang mempercepat atau memperlambat animasi (dan tentu saja mencuci tangan Anda setelah itu!), Maka pada saat itu Anda menggunakan penghitung waktu virtual di browser. <br><br>  Browser dapat menggunakan penghitung waktu virtual alih-alih yang asli untuk <strong>"menggulir"</strong> ke <strong>depan</strong> untuk mempercepat pemuatan halaman atau menyelesaikan animasi.  Misalkan Anda memiliki tes yang sama, Anda pergi ke halaman utama, dan ada animasi selama 30 detik.  Tidak ada manfaatnya bagi siapa pun untuk menjalani tes ini selama ini.  Oleh karena itu, Anda cukup mempercepat animasi sehingga selesai secara instan saat halaman dimuat, dan pengujian Anda berlanjut. <br><br>  Anda dapat <strong>menghentikan waktu saat permintaan jaringan sedang berjalan</strong> .  Misalnya, Anda menguji reaksi aplikasi Anda ketika permintaan yang telah pergi ke backend membutuhkan waktu yang sangat lama untuk dieksekusi, atau kembali dengan kesalahan.  Anda dapat menghentikan waktu - Dalang memungkinkannya. <br><br>  Pada slide di bawah ini, ada opsi lain: <strong>berhenti dan lanjutkan</strong> renderer.  Dalam mode eksperimental, memungkinkan untuk memberi tahu peramban untuk tidak membuat, dan kemudian, jika perlu, meminta tangkapan layar.  Maka Chrome tanpa kepala akan dengan cepat merender semuanya, memberikan tangkapan layar, dan kembali berhenti menggambar apa pun.  Sayangnya, para pengembang telah berhasil mengubah prinsip kerja API ini dan tidak ada fungsi seperti itu lagi. <br><br>  Tampilan skematis penghitung waktu virtual di bawah ini. <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br>  Baris teratas memiliki dua penghitung waktu reguler: yang pertama dimulai pada unit waktu pertama dan berjalan dalam satu unit waktu, yang kedua dimulai pada unit waktu ketiga dan berjalan dalam tiga unit waktu. <br><br>  Mempercepat pengatur waktu - mereka memulai satu demi satu.  Ketika kita menjeda mereka, kita memiliki periode waktu di mana semua timer mulai. <br><br>  Anggap ini sebagai contoh.  Di bawah ini adalah potongan kode yang pada dasarnya hanya memuat halaman animasi dari codepen.io dan menunggu: <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br>  Demonstrasi implementasi selama presentasi ini hanyalah animasi. <br><br>  Sekarang, menggunakan protokol Chrome DevTools, kami akan mengirim metode yang disebut Animation.setPlaybackRate, berikan itu playbackRate dengan nilai 12 sebagai parameter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br>  Kami memuat tautan yang sama, dan animashka mulai bekerja lebih cepat.  Ini karena kami menggunakan penghitung waktu virtual dan mempercepat pemutaran animasi sebanyak 12 kali. <br><br>  Mari kita lakukan percobaan sekarang - lulus playbackRate: 0 - dan lihat apa yang terjadi.  Dan ini akan menjadi ini: tidak ada animasi sama sekali, tidak bisa diputar.  Nilai nol dan negatif hanya menghentikan seluruh animasi sepenuhnya. <br><br><h4>  Bekerja dengan permintaan jaringan <br></h4><br>  Anda dapat <strong>mencegat permintaan jaringan</strong> dengan mengatur tanda berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Dalam mode ini, acara tambahan muncul yang menyala saat permintaan jaringan dikirim atau diterima. <br><br>  Anda dapat <strong>mengubah permintaan dengan cepat</strong> .  Ini berarti Anda dapat sepenuhnya mengubah semua konten (isi) dan tajuknya, memeriksa, bahkan membatalkan permintaan. <br><br>  Ini diperlukan untuk <strong>memproses otorisasi atau otentikasi</strong> , termasuk otentikasi dasar melalui HTTP. <br><br>  Anda juga dapat melakukan <strong>cakupan kode (JS / CSS)</strong> .  Dengan Dalang, Anda dapat mengotomatiskan semua ini.  Kita semua tahu utilitas yang dapat memuat halaman, menunjukkan kelas mana yang digunakan di dalamnya, dll.  Tetapi apakah kita puas dengan mereka?  Saya kira tidak. <br><br><blockquote>  Browser lebih tahu selektor dan kelas mana yang digunakan - ini adalah browser!  Dia selalu tahu JavaScript yang dieksekusi, yang tidak, CSS mana yang digunakan, yang tidak. <br></blockquote><br>  Protokol Chrome DevTools datang untuk menyelamatkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br>  Di dua baris pertama, kami meluncurkan fitur yang relatif baru yang memungkinkan Anda mengetahui cakupan kode.  Jalankan JS dan CSS, buka beberapa halaman, lalu katakan - berhenti - dan kita bisa melihat hasilnya.  Dan ini bukan beberapa hasil imajiner, tetapi yang dilihat browser karena mesinnya. <br><br>  Antara lain, sudah ada plugin yang untuk Puppeteer mengekspor semuanya ke Istanbul. <br><br>  Di bagian atas piramida Puppeteer adalah skrip yang Anda tulis di Node.js - itu seperti ayah baptis untuk semua poin terbawah. <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br>  Tapi ... "tidak semuanya tenang di kerajaan Denmark ..." - seperti yang ditulis William Shakespeare. <br><br><h2>  <strong>Apa yang salah dengan browser tanpa kepala?</strong> <br></h2><br>  Browser tanpa kepala memiliki masalah meskipun semua fitur kerennya dapat melakukan banyak hal. <br><br><h4>  Perbedaan rendering halaman pada platform yang berbeda <br></h4><br>  Saya sangat menyukai item ini dan terus membicarakannya.  Mari kita lihat gambar ini. <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br>  Berikut ini adalah halaman reguler dengan teks biasa: di sebelah kanan - render di Chrome di Linux, di sebelah kiri - di bawah Windows.  Mereka yang menguji dengan tangkapan layar tahu bahwa suatu nilai selalu ditetapkan, disebut â€œmargin of error,â€ yang menentukan kapan tangkapan layar dianggap identik dan kapan tidak. <br><br>  Faktanya, masalahnya adalah tidak peduli bagaimana Anda mencoba menetapkan ambang ini, kesalahan akan selalu melampaui batas ini, dan Anda masih akan menerima hasil positif palsu.  Ini disebabkan oleh fakta bahwa semua halaman, dan bahkan font web, dirender secara berbeda pada ketiga platform - pada Windows menurut satu algoritma, pada MacOS berbeda, pada Linux pada umumnya kebun binatang.  <strong>Anda tidak bisa hanya mengambil dan menguji dengan tangkapan layar</strong> . <br><br>  Anda akan berkata: "Saya hanya perlu mesin referensi di mana saya akan menjalankan semua tes ini dan membandingkan tangkapan layar."  Tetapi pada kenyataannya, ini sangat merepotkan, karena Anda harus menunggu untuk CI, dan Anda ingin memeriksa di sini secara lokal pada mesin Anda apakah Anda telah merusak sesuatu.  Jika Anda memiliki tangkapan layar referensi yang diambil pada mesin Linux, dan Anda memiliki Mac, maka akan ada hasil yang salah. <br><br><blockquote>  Karena itu, saya katakan bahwa jangan menguji dengan screenshot sama sekali - lupakan saja. <br></blockquote><br>  Ngomong-ngomong, jika Anda masih ingin menguji dengan tangkapan layar, ada artikel bagus dari Roman Dvornov, â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unit-testing dengan tangkapan layar: melanggar penghalang suara</a> â€.  Ini fiksi detektif langsung. <br><br><h4>  Kunci <br></h4><br>  Banyak penyedia konten besar tidak suka ketika Anda melakukan pengikisan atau mendapatkan konten mereka secara ilegal.  Bayangkan bahwa saya adalah penyedia konten utama dan ingin bermain game yang sama dengan Anda.  Ada dua permintaan GET di dua browser yang berbeda. <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br>  Bisakah Anda menebak di mana Chrome ada di sini?  Opsi "keduanya" tidak diterima - Chrome hanya satu.  Kemungkinan besar, Anda tidak akan dapat menjawab pertanyaan ini, dan saya, sebagai penyedia konten utama, dapat: di sebelah kanan - PhantomJS, dan di sebelah kiri - Chrome. <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br>  Saya dapat mencapai titik di mana saya akan mendeteksi browser Anda (apa sebenarnya Chrome atau FireFox) dengan mencocokkan urutan header HTTP dalam permintaan Anda.  Jika tuan rumah lebih dulu - saya jelas tahu - ini adalah Chrome.  Maka saya tidak bisa membandingkan.  Ya, tentu saja, ada algoritma yang lebih kompleks - kami memeriksa tidak hanya urutannya, tetapi juga nilainya, dll.  dll.  Tetapi penting bahwa saya dapat memberikan pos Anda, memeriksa siapa Anda, dan kemudian hanya memblokir Anda atau tidak memblokir Anda. <br><br><h4>  Tidak dapat mengimplementasikan beberapa fitur (Flash) <br></h4><br>  Pernahkah Anda mempelajari secara mendalam, langsung hardcore, Flash di browser?  Entah bagaimana saya melihat ke dalam - maka saya tidak tidur selama enam bulan. <br><br>  Kita semua ingat bagaimana dulu menonton YouTube ketika masih ada Flash: videonya berputar, semuanya baik-baik saja.  Tetapi pada saat objek tertanam dibuat pada halaman seperti Flash, selalu meminta jendela nyata dari OS Anda.  Yaitu, selain jendela browser Anda, ada jendela lain dari OS Anda di dalam jendela Flash YouTube.  Flash tidak dapat berfungsi kecuali Anda memberikannya jendela nyata - bukan hanya jendela nyata, tetapi jendela yang terlihat di layar Anda.  Oleh karena itu, beberapa fungsi tidak dapat diimplementasikan di browser tanpa kepala, termasuk Flash. <br><br><h4>  Otomasi dan bot penuh <br></h4><br>  Seperti yang saya katakan sebelumnya, penyedia konten besar sangat takut ketika Anda menulis spider atau grabbings yang hanya mencuri informasi yang disediakan untuk biaya. <br><br>  Berbagai trik digunakan.  Ada artikel tentang cara masih mendeteksi browser tanpa kepala.  Saya dapat mengatakan bahwa <strong>Anda tidak akan dapat mendeteksi browser tanpa kepala</strong> .  Semua metode yang dijelaskan ada yang dilewati.  Misalnya, ada metode deteksi menggunakan Canvas.  Saya ingat bahkan ada satu skrip yang menyaksikan mouse bergerak di sekitar layar dan mengisi kanvas.  Kami adalah orang-orang dan kami menggerakkan mouse dengan agak lambat, dan Chrome Tanpa Kepala jauh lebih cepat.  Script mengerti bahwa Canvas terisi terlalu cepat - yang artinya kemungkinan Chrome tanpa kepala.  Kami juga menghindari ini, hanya memperlambat browser tidak menjadi masalah. <br><br><h4>  Tidak ada API standar (tunggal) <br></h4><br>  Jika Anda menyaksikan penerapan tanpa kepala di peramban lain - baik itu Safari atau FireFox - di sana semuanya diterapkan menggunakan API webdriver.  Chrome memiliki protokol Chrome DevTools.  Di Edge, tidak ada yang jelas sama sekali - apa yang ada di sana, apa yang tidak. <br><br><h4>  WebGL? <br></h4><br>  Orang-orang juga meminta WebGL dalam mode tanpa kepala.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memungkinkan</a> Anda untuk mengakses pelacak bug Google Chrome.  Di sana, pengembang secara aktif memberikan suara untuk penerapan mode tanpa kepala untuk WebGL, dan dia sudah dapat menggambar sesuatu.  Mereka sekarang hanya dikendalikan oleh perenderan perangkat keras.  Segera setelah implementasi perenderan perangkat keras selesai, maka WebGL akan secara otomatis tersedia, yaitu, sesuatu dapat dilakukan di latar belakang. <br><br>  Tapi tidak semuanya begitu buruk! <br><br>  Kami memiliki pemain kedua di pasaran - pada 11 Mei 2018 ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berita</a> bahwa Microsoft di browser Edge memutuskan untuk menerapkan protokol yang hampir sama dengan yang digunakan di Google Chrome.  Mereka secara khusus membuat konsorsium di mana mereka mendiskusikan protokol yang ingin mereka bawa ke standar industri sehingga Anda dapat mengambil skrip Anda dan menjalankannya di bawah Edge, Chrome, dan FireFox. <br><br>  Tetapi ada satu "tetapi" - Sayangnya, Microsoft Edge tidak memiliki mode tanpa kepala.  Mereka memiliki surat suara di mana orang menulis: "Beri kami mode tanpa kepala!"  - tetapi mereka diam.  Mungkin melihat sesuatu secara rahasia. <br><br><h2>  <strong>TODO (kesimpulan)</strong> <br></h2><br>  Saya mengatakan semua ini sehingga Anda bisa datang ke manajer Anda, atau, jika Anda seorang manajer, ke pengembang, dan berkata: â€œItu dia!  <strong>Kami tidak ingin Selenium lagi - beri kami Dalang!</strong>  Kami akan menguji di dalamnya. "  Jika ini terjadi, saya akan senang. <br><br>  Tetapi jika Anda dapat belajar, seperti saya, browser menggunakan Puppeteer, secara aktif memposting bug, atau mengirim permintaan tarik, maka saya akan lebih senang lagi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alat</a> dalam OpenSource ini terletak pada GitHub, ditulis dalam Node.js - Anda bisa meminjam dan berkontribusi padanya. <br><br>  Kasing dengan Puppeteer unik karena ada dua tim yang bekerja di Google: satu berurusan khusus dengan Puppeteer, yang lainnya dengan mode tanpa kepala.  Jika pengguna menemukan bug dan menulisnya di GitHub, maka jika bug ini tidak ada di Puppeteer, tetapi di Headless Chrome, bug tersebut menuju ke perintah Headless Chrome.  Jika mereka memperbaikinya di sana, maka Puppeteer diperbarui dengan sangat cepat.  Ini menghasilkan satu ekosistem ketika komunitas membantu meningkatkan peramban. <br><br>  Oleh karena itu, saya mendorong Anda untuk membantu meningkatkan alat ini, yang tidak hanya digunakan oleh Anda, tetapi juga oleh pengembang dan penguji lainnya. <br><br>  Rincian kontak: <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf Moscow</a> - konferensi khusus pengembang front-end akan diadakan <strong>pada tanggal 4 dan 5 Oktober di Moskow</strong> , di Infospace.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar</a> laporan yang diterima telah dipublikasikan di situs web konferensi. <br><br>  Dalam buletin kami, kami secara teratur melakukan tinjauan tematis tentang pidato, berbicara tentang transkrip yang telah dirilis dan acara mendatang - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendaftar</a> untuk menerima berita terlebih dahulu. <br><br>  Dan ini adalah tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran Youtube</a> kami di ujung depan, ini berisi semua pidato yang terkait dengan pengembangan bagian klien dari proyek. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421137/">https://habr.com/ru/post/id421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421127/index.html">Webinar Skillbox Friday: Desain & Pengembang</a></li>
<li><a href="../id421129/index.html">Cara mengurangi ulasan kode dari dua minggu menjadi beberapa jam. Pengalaman tim Yandex.Market</a></li>
<li><a href="../id421131/index.html">Kerentanan Penting Server 1Cloud</a></li>
<li><a href="../id421133/index.html">LINKa. Keyboard kertas. Tombol ekstra besar</a></li>
<li><a href="../id421135/index.html">Au / Ni / MgO: transfer panas berskala nano</a></li>
<li><a href="../id421139/index.html">Frontend Conf - menjaga pengguna</a></li>
<li><a href="../id421141/index.html">Analisis mutasi, atau cara menguji tes</a></li>
<li><a href="../id421143/index.html">Aurora Labs S-Titanium Pro Mini Logam 3D Printer</a></li>
<li><a href="../id421147/index.html">Monster setelah liburan: AMD Threadripper 2990WX 32-Core dan 2950X 16-Core</a></li>
<li><a href="../id421149/index.html">Beberapa kata tentang gradien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>