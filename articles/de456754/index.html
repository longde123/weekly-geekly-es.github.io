<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèæ üë®üèΩ‚Äçüé® üë©üèæ‚Äçüéì GitOps: Vergleichen von Pull- und Push-Methoden üéÆ üßïüèø üï∂Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : In der Kubernetes-Community gewinnt ein Trend namens GitOps an Popularit√§t, wie wir pers√∂nlich beim Besuch der KubeCon Europe 2019 ge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GitOps: Vergleichen von Pull- und Push-Methoden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/456754/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: In der Kubernetes-Community gewinnt ein Trend namens GitOps an Popularit√§t, wie wir pers√∂nlich beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besuch der</a> KubeCon Europe 2019 gesehen haben. Dieser Begriff wurde vor relativ kurzer Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom</a> Leiter von Weaveworks - Alexis Richardson - gepr√§gt und bedeutet die Verwendung bekannter Tools f√ºr Entwickler (haupts√§chlich Git, woher der Name selbst) zur L√∂sung von Betriebsproblemen.</i>  <i>Insbesondere geht es darum, Kubernetes auszunutzen, indem seine Konfigurationen in Git gespeichert und √Ñnderungen am Cluster automatisch eingef√ºhrt werden.</i>  <i>Matthias Jg spricht in diesem Artikel √ºber zwei Ans√§tze f√ºr diesen Rollout.</i> <br><br><img src="https://habrastorage.org/webt/ex/dn/gg/exdnggi20gpsaezt2rokmb8xfz0.jpeg"><br><br>  Letztes Jahr <i>(tats√§chlich geschah dies offiziell im August 2017 - ungef√§hr √ºbersetzt)</i> wurde ein neuer Ansatz f√ºr die Bereitstellung von Anwendungen in Kubernetes vorgestellt.  Es hei√üt GitOps und basiert auf der Grundidee, dass die Versionsverfolgung von Bereitstellungen in einer sicheren Git-Repository-Umgebung erfolgt. <a name="habracut"></a><br><br>  <b>Die Hauptvorteile dieses Ansatzes sind folgende</b> : <br><br><ol><li>  <b>Versionierung von Bereitstellungen und √Ñnderungsverlauf</b> .  Der Status des gesamten Clusters wird im Git-Repository gespeichert, und Bereitstellungen werden nur durch Commits aktualisiert.  Dar√ºber hinaus k√∂nnen alle √Ñnderungen mithilfe des Festschreibungsverlaufs verfolgt werden. </li><li>  <b>Kickbacks mit bekannten Git-Befehlen</b> .  Mit einem einfachen <code>git reset</code> k√∂nnen Sie √Ñnderungen in der Bereitstellung verwerfen.  vergangene Zust√§nde sind immer verf√ºgbar. </li><li>  <b>Bereit Zugriffskontrolle</b> .  In der Regel enth√§lt ein Git-System viele vertrauliche Daten, daher achten die meisten Unternehmen besonders auf deren Schutz.  Dementsprechend erstreckt sich dieser Schutz auf Vorg√§nge mit Bereitstellungen. </li><li>  <b>Richtlinien f√ºr Bereitstellungen</b> .  Die meisten Git-Systeme unterst√ºtzen zun√§chst Richtlinien f√ºr verschiedene Zweige. Beispielsweise k√∂nnen nur Pull-Anforderungen den Master aktualisieren, und ein anderes Mitglied des Teams muss die √Ñnderungen √ºberpr√ºfen und akzeptieren.  Wie bei der Zugriffssteuerung gelten f√ºr Bereitstellungsaktualisierungen dieselben Richtlinien. </li></ol><br>  Wie Sie sehen k√∂nnen, hat die GitOps-Methode viele Vorteile.  Im vergangenen Jahr haben zwei Ans√§tze besondere Popularit√§t erlangt.  Einer basiert auf Push, der andere auf Pull.  Bevor wir uns diese ansehen, schauen wir uns zun√§chst an, wie typische Kubernetes-Bereitstellungen aussehen. <br><br><h2>  Bereitstellungsmethoden </h2><br>  In den letzten Jahren wurden bei Kubernetes verschiedene Bereitstellungsmethoden und -tools eingerichtet: <br><br><ol><li>  <b>Basierend auf nativen Kubernetes / Kustomize-Vorlagen</b> .  Dies ist der einfachste Weg, um Anwendungen auf Kubernetes bereitzustellen.  Der Entwickler erstellt die grundlegenden YAML-Dateien und wendet sie an.  Um das st√§ndige Umschreiben derselben Muster zu vermeiden, wurde Kustomize entwickelt (es verwandelt Kubernetes-Muster in Module).  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Kustomize wurde mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ver√∂ffentlichung von Kubernetes 1.14</a> in kubectl integriert.</i> </li><li>  <b>Charts Helm</b> .  Mithilfe von Helmdiagrammen k√∂nnen Sie S√§tze von Vorlagen, Init-Containern, Sidecar'ov usw. erstellen, mit denen Anwendungen mit flexibleren Konfigurationsoptionen als beim vorlagenbasierten Ansatz bereitgestellt werden.  Diese Methode basiert auf YAML-Vorlagendateien.  Helm f√ºllt sie mit verschiedenen Parametern und sendet sie dann an Tiller, die Clusterkomponente, die sie im Cluster bereitstellt und Aktualisierungen und Rollbacks erm√∂glicht.  Wichtig ist, dass Helm die erforderlichen Werte einfach in die Vorlagen einf√ºgt und sie dann auf die gleiche Weise wie beim herk√∂mmlichen Ansatz anwendet <i>(weitere Informationen dazu, wie dies alles funktioniert und wie Sie es verwenden k√∂nnen, finden Sie in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Helm</a> - ca. .)</i> .  Es gibt eine Vielzahl von vorgefertigten Helmkarten, die eine Vielzahl von Aufgaben abdecken. </li><li>  <b>Alternative Werkzeuge</b> .  Es gibt viele alternative Werkzeuge.  Alle sind sich einig, dass sie einige Vorlagendateien in Kubernetes-freundliche YAML-Dateien umwandeln und sie dann anwenden. </li></ol><br>  In unserer Arbeit verwenden wir st√§ndig Helm-Diagramme f√ºr wichtige Tools (da viele bereits bereit sind, was das Leben erheblich vereinfacht) und Kubernetes ‚Äûsaubere‚Äú YAML-Dateien f√ºr die Bereitstellung unserer eigenen Anwendungen. <br><br><h2>  Ziehen und dr√ºcken </h2><br>  In einem meiner letzten Blog-Beitr√§ge habe ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weave Flux-</a> Tool vorgestellt, mit dem Sie Vorlagen f√ºr das Git-Repository festschreiben und die Bereitstellung nach jedem Festschreibungs- oder Push-Container aktualisieren k√∂nnen.  Meine Erfahrung zeigt, dass dieses Tool eines der Hauptinstrumente bei der F√∂rderung des Pull-Ansatzes ist, daher werde ich h√§ufig darauf verweisen.  Wenn Sie mehr √ºber die Verwendung erfahren m√∂chten, finden Sie hier einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Artikel</a> . <br><br>  <i><b>NB!</b></i>  <i>Alle Vorteile der Verwendung von GitOps bleiben f√ºr beide Ans√§tze erhalten.</i> <br><br><h2>  Pull-basierter Ansatz </h2><br><img src="https://habrastorage.org/webt/v-/a1/ob/v-a1obddnsnwhhvukh2iuzgmrkw.jpeg"><br><br>  Der Pull-Ansatz basiert auf der Tatsache, dass alle √Ñnderungen innerhalb des Clusters angewendet werden.  Innerhalb des Clusters gibt es einen Operator, der regelm√§√üig die zugeh√∂rigen Git- und Docker-Registrierungsrepositorys √ºberpr√ºft.  Wenn √Ñnderungen an ihnen auftreten, wird der Status des Clusters intern aktualisiert.  Es wird normalerweise angenommen, dass ein solcher Prozess sehr sicher ist, da kein externer Client Zugriff auf Clusteradministratorrechte hat. <br><br>  <b>Vorteile:</b> <br><br><ol><li>  Kein externer Client hat das Recht, √Ñnderungen am Cluster vorzunehmen. Alle Aktualisierungen werden von innen ausgef√ºhrt. </li><li>  Mit einigen Tools k√∂nnen Sie auch Aktualisierungen von Helm-Diagrammen synchronisieren und an einen Cluster binden. </li><li>  Die Docker-Registrierung kann nach neuen Versionen durchsucht werden.  Wenn ein neues Image angezeigt wird, werden das Git-Repository und die Bereitstellung auf die neue Version aktualisiert. </li><li>  Pull-Tools k√∂nnen mit unterschiedlichen Git-Repositorys und Berechtigungen auf verschiedene Namespaces verteilt werden.  Dank dessen ist es m√∂glich, das Multitenant-Modell zu verwenden.  Beispielsweise kann Team A den Namespace A verwenden, Team B den Namespace B und ein Infrastruktur-Team den globalen Speicherplatz. </li><li>  Werkzeuge sind in der Regel sehr leicht. </li><li>  In Kombination mit Tools wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitnami Sealed Secrets-</a> Anweisung k√∂nnen Geheimnisse verschl√ºsselt im Git-Repository gespeichert und im Cluster abgerufen werden. </li><li>  Es gibt keine Kommunikation mit CD-Pipelines, da Bereitstellungen innerhalb des Clusters erfolgen. </li></ol><br>  <b>Nachteile</b> : <br><br><ol><li>  Das Verwalten von Bereitstellungsgeheimnissen aus Helmdiagrammen ist komplizierter als gew√∂hnlich, da Sie sie zuerst in beispielsweise versiegelten Geheimnissen generieren, dann mit einem internen Operator entschl√ºsseln m√ºssen und erst danach f√ºr das Pull-Tool verf√ºgbar werden.  Anschlie√üend k√∂nnen Sie die Version in Helm mit Werten in bereits bereitgestellten Geheimnissen starten.  Am einfachsten ist es, ein Geheimnis mit allen f√ºr die Bereitstellung verwendeten Helmwerten zu erstellen, es zu entschl√ºsseln und in Git festzuschreiben. </li><li>  Bei Verwendung des Pull-Ansatzes sind Sie an Werkzeuge gebunden, die mit Pulls arbeiten.  Dies schr√§nkt die M√∂glichkeit ein, den Bereitstellungsbereitstellungsprozess im Cluster anzupassen.  Die Arbeit mit Kustomize wird beispielsweise dadurch erschwert, dass es ausgef√ºhrt werden muss, bevor die endg√ºltigen Vorlagen in Git eintreffen.  Ich sage nicht, dass Sie keine einzelnen Tools verwenden k√∂nnen, aber sie sind schwieriger in den Bereitstellungsprozess zu integrieren. </li></ol><br><h2>  Push-basierter Ansatz </h2><br><img src="https://habrastorage.org/webt/1r/b_/qo/1rb_qoykirrwpkjjcnnd7ojrykk.jpeg"><br><br>  Beim Push-Ansatz wird ein externes System (haupts√§chlich CD-Pipelines) nach dem Festschreiben im Git-Repository oder bei erfolgreicher Ausf√ºhrung der vorherigen CI-Pipeline mit der Bereitstellung im Cluster begonnen.  Bei diesem Ansatz hat das System Zugriff auf den Cluster. <br><br>  <b>Vorteile</b> : <br><br><ol><li>  Die Sicherheit wird vom Git-Repository und der Build-Pipeline bestimmt. </li><li>  Das Bereitstellen von Helm-Diagrammen ist einfacher, Helm-Plugins werden unterst√ºtzt. </li><li>  Geheimnisse sind einfacher zu verwalten, da Geheimnisse in Pipelines verwendet und in Git in verschl√ºsselter Form gespeichert werden k√∂nnen (abh√§ngig von den Vorlieben des Benutzers). </li><li>  Fehlende Bindung an ein bestimmtes Werkzeug, da jeder ihrer Typen verwendet werden kann. </li><li>  Aktualisierungen der Containerversion k√∂nnen von der Assembly-Pipeline ausgel√∂st werden. </li></ol><br>  <b>Nachteile</b> : <br><br><ol><li>  Die Daten f√ºr den Zugriff auf den Cluster befinden sich im Build-System. </li><li>  Das Aktualisieren von Bereitstellungscontainern ist mit dem Pull-Prozess noch einfacher. </li><li>  Dies h√§ngt stark vom CD-System ab, da die ben√∂tigten Pipelines wahrscheinlich urspr√ºnglich f√ºr Gitlab Runners geschrieben wurden. Anschlie√üend entscheidet sich das Team f√ºr den Wechsel zu Azure DevOps oder Jenkins. Sie m√ºssen dann eine gro√üe Anzahl von Build-Pipelines migrieren. </li></ol><br><h2>  Fazit: Push oder Pull? </h2><br>  Wie √ºblich hat jeder Ansatz seine Vor- und Nachteile.  Einige Aufgaben sind mit der einen leichter zu erledigen und mit der anderen schwieriger.  Zuerst habe ich Bereitstellungen manuell ausgegeben, aber nachdem ich auf mehrere Artikel √ºber Weave Flux gesto√üen war, habe ich beschlossen, GitOps-Prozesse f√ºr alle Projekte zu implementieren.  Bei einfachen Vorlagen stellte sich heraus, dass dies einfach war, aber dann bekam ich Schwierigkeiten bei der Arbeit mit Helm-Diagrammen.  Zu dieser Zeit bot Weave Flux nur eine rudiment√§re Version des Helmdiagramm-Operators an, aber selbst jetzt sind einige Aufgaben komplizierter, da Geheimnisse manuell erstellt und angewendet werden m√ºssen.  Sie k√∂nnen sagen, dass der Pull-Ansatz viel sicherer ist, da die Cluster-Anmeldeinformationen au√üerhalb nicht verf√ºgbar sind, und dies erh√∂ht die Sicherheit so sehr, dass es zus√§tzlichen Aufwand kostet. <br><br>  Nachdem ich ein bisschen nachgedacht hatte, kam ich zu dem unerwarteten Schluss, dass dies nicht so ist.  Wenn wir √ºber Komponenten sprechen, die maximalen Schutz erfordern, enth√§lt diese Liste die Speicherung von Geheimnissen und CI / CD-Systemen sowie Git-Repositorys.  Die darin enthaltenen Informationen sind sehr anf√§llig und ben√∂tigen maximalen Schutz.  Wenn jemand Ihr Git-Repository betritt und den Code dort pushen kann, kann er au√üerdem alles bereitstellen, was er will (unabh√§ngig vom gew√§hlten Ansatz wird es Pull oder Push sein) und die Clustersysteme infiltrieren.  Daher sind die wichtigsten Komponenten, die gesch√ºtzt werden m√ºssen, das Git-Repository und die CI / CD-Systeme, nicht die Cluster-Anmeldeinformationen.  Wenn Sie √ºber gut abgestimmte Richtlinien und Sicherheitsma√ünahmen f√ºr Systeme dieses Typs verf√ºgen und Cluster-Anmeldeinformationen nur als Geheimnisse in Pipes abgerufen werden, ist die zus√§tzliche Sicherheit des Pull-Ansatzes m√∂glicherweise nicht so wertvoll wie urspr√ºnglich beabsichtigt. <br><br>  Wenn der Pull-Ansatz zeitaufw√§ndiger ist und keinen Sicherheitsgewinn bringt, ist es dann nicht logisch, nur den Push-Ansatz zu verwenden?  Aber vielleicht sagt jemand, dass Sie beim Push-Ansatz zu sehr an das CD-System gebunden sind, und vielleicht ist es besser, dies nicht zu tun, um Migrationen in Zukunft einfacher zu machen. <br><br>  Meiner Meinung nach sollten Sie (wie immer) das verwenden, was f√ºr einen bestimmten Fall besser geeignet ist, oder kombinieren.  Pers√∂nlich verwende ich beide Ans√§tze: Weave Flux f√ºr Pull-basierte Bereitstellungen, die haupts√§chlich unsere eigenen Dienste umfassen, und einen Push-Ansatz mit Helm und Plugins, der die Anwendung von Helm-Diagrammen auf den Cluster vereinfacht und es Ihnen erm√∂glicht, auf einfache Weise Geheimnisse zu erstellen.  Ich denke, es wird nie eine einzige L√∂sung geben, die f√ºr alle F√§lle geeignet ist, da es immer viele Nuancen gibt und diese von der spezifischen Anwendung abh√§ngen.  Gleichzeitig empfehle ich GitOps sehr - es vereinfacht das Leben erheblich und verbessert die Sicherheit. <br><br>  Ich hoffe, dass meine Erfahrung zu diesem Thema dazu beitr√§gt, festzustellen, welche Methode f√ºr Ihre Art der Bereitstellung besser geeignet ist, und ich freue mich √ºber Ihre Meinung. <br><br><h2>  PS Hinweis vom √úbersetzer </h2><br>  In den Minuspunkten des Pull-Modells gibt es einen Punkt dar√ºber, dass es schwierig ist, gerenderte Manifeste in Git zu platzieren. Es gibt jedoch kein Minus, dass die CD-Pipeline im Pull-Modell getrennt vom Rollout lebt und tats√§chlich zu einer <i>Pipeline f√ºr die</i> Kategorie " <i>Kontinuierliches Anwenden</i> " wird.  Daher sind noch weitere Anstrengungen erforderlich, um ihren Status aus allen Bereitstellungen zu erfassen und irgendwie Zugriff auf die Protokolle / den Status zu gew√§hren, vorzugsweise in Bezug auf das CD-System. <br><br>  In diesem Sinne k√∂nnen Sie mit dem Push-Modell zumindest eine gewisse Garantie f√ºr den Rollout geben, da die Lebensdauer der Pipeline der Rollout-Lebensdauer entsprechen kann. <br><br>  Wir haben beide Modelle getestet und sind zu den gleichen Ergebnissen gekommen wie der Autor des Artikels: <br><br><ol><li>  Das Pull-Modell eignet sich f√ºr uns zum Organisieren von Systemkomponentenaktualisierungen in einer gro√üen Anzahl von Clustern (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Addon-Operator</a> ). </li><li>  Das GitLab CI-basierte Push-Modell eignet sich gut f√ºr die Einf√ºhrung von Anwendungen mithilfe von Helm-Diagrammen.  In diesem Rollout wird die Bereitstellung innerhalb der Pipelines mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf-</a> Tool √ºberwacht.  √úbrigens haben wir im Rahmen unseres Projekts die st√§ndigen ‚ÄûGitOps‚Äú geh√∂rt, als wir an unserem Stand auf der KubeCon Europe'19 die dringenden Probleme der DevOps-Ingenieure besprochen haben. </li></ol><br><h2>  PPS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung von werf 1.0 Stable: Was hat GitOps damit zu tun, Status und Pl√§ne?</a> " </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist GitOps?</a>  "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps und Tricks von Kubernetes: √úbertragen von Ressourcen in einem Cluster auf Helm 2</a> ‚Äú; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterung und Erweiterung von Kubernetes (Review und Videobericht)</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456754/">https://habr.com/ru/post/de456754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456736/index.html">PostgreSQL-Rezepte: cURL: Abrufen, Ver√∂ffentlichen und ... E-Mail</a></li>
<li><a href="../de456738/index.html">Neuronale Netze und tiefes Lernen, Kapitel 1: Verwenden neuronaler Netze zum Erkennen handgeschriebener Zahlen</a></li>
<li><a href="../de456744/index.html">10 Probleme, die ich mit Erinnerungen auf meinem Smartphone gel√∂st habe</a></li>
<li><a href="../de456746/index.html">Big Data - gro√üe Verantwortung, gro√üer Stress und viel Geld</a></li>
<li><a href="../de456748/index.html">2003 Thermodrucker von einem Flohmarkt: Was kann er 2019 tun?</a></li>
<li><a href="../de456756/index.html">Warum √§ndert CockroachDB die Open Source-Lizenz?</a></li>
<li><a href="../de456760/index.html">Crowdsourcing im ML Boot Camp. Wir betrachten mIOU ohne Bilder f√ºr eine neue Aufgabe von Odnoklassniki</a></li>
<li><a href="../de456762/index.html">Von Witcher 3 zu Cyberpunk: Die Entwicklung des CD Projekt Quest Designs</a></li>
<li><a href="../de456768/index.html">4 Schwierigkeiten bei der Lokalisierung von Handyspielen am Beispiel von Fishing Clash - √úbersetzung</a></li>
<li><a href="../de456770/index.html">Wettr√ºsten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>