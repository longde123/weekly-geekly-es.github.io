<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì° ü•ü ü§æüèΩ PHP-Leistung: Planen, Profilieren, Optimieren üßïüèø üëÇ üë®üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Vor zwei Jahren haben wir dar√ºber geschrieben, wie wir auf PHP 7.0 umgestiegen sind und eine Million Dollar gespart haben. In unserem Last...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP-Leistung: Planen, Profilieren, Optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430722/"><img src="https://habrastorage.org/webt/k_/fe/vv/k_fevvrhhn2aruuz19gpne_jypy.jpeg"><br><br>  Hallo Habr!  Vor zwei Jahren haben wir dar√ºber geschrieben, wie wir auf PHP 7.0 umgestiegen sind und eine Million Dollar gespart haben.  In unserem Lastprofil erwies sich die neue Version als doppelt so effizient bei der CPU-Auslastung: Die Last, mit der wir ~ 600 Server bedienten, nachdem der √úbergang begonnen hatte, ~ 300 zu bedienen.  Infolgedessen verf√ºgten wir zwei Jahre lang √ºber Kapazit√§tsreserven. <br><br>  Aber Badoo w√§chst.  Die Anzahl der aktiven Benutzer nimmt st√§ndig zu.  Wir verbessern und entwickeln unsere Funktionen, dank derer Benutzer immer mehr Zeit in der Anwendung verbringen.  Dies spiegelt sich wiederum in der Anzahl der Anfragen wider, die sich in den letzten zwei Jahren um das 2- bis 2,5-fache erh√∂ht haben. <br><br>  Wir befanden uns in einer Situation, in der ein zweifacher Leistungszuwachs durch mehr als eine zweifache Steigerung der Anforderungen ausgeglichen wurde, und wir n√§herten uns erneut den Grenzen unseres Clusters.  Im Kern von PHP werden wieder n√ºtzliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierungen</a> (JIT, Preloading) erwartet, die jedoch nur f√ºr PHP 7.4 geplant sind. Diese Version wird fr√ºhestens in einem Jahr ver√∂ffentlicht.  Daher kann der √úbergangstrick jetzt nicht wiederholt werden - Sie m√ºssen den Anwendungscode selbst optimieren. <br><br>  Im Folgenden werde ich Ihnen erl√§utern, wie wir solche Aufgaben angehen, welche Tools wir verwenden, und Beispiele f√ºr Optimierungen, Ideen und Ans√§tze nennen, die wir anwenden und die uns in unserer Zeit geholfen haben. <br><a name="habracut"></a><br><h1>  Warum optimieren? </h1><br>  Der einfachste und naheliegendste Weg, um das Leistungsproblem zu l√∂sen, ist das Hinzuf√ºgen von Eisen.  Wenn Ihr Code auf demselben Server ausgef√ºhrt wird, verdoppelt das Hinzuf√ºgen eines weiteren die Leistung Ihres Clusters.  Wenn wir diese Kosten auf die Arbeitszeit des Entwicklers √ºbertragen, fragen wir uns: Wird er in dieser Zeit aufgrund von Optimierungen eine zweifache Produktivit√§tssteigerung erzielen k√∂nnen?  Vielleicht ja, aber vielleicht auch nicht: Es kommt darauf an, wie optimal das System bereits funktioniert und wie gut der Entwickler ist.  Auf der anderen Seite bleibt der gekaufte Server Eigentum des Unternehmens und die aufgewendete Zeit wird nicht zur√ºckgegeben. <br><br>  Es stellt sich heraus, dass bei kleinen Mengen die richtige L√∂sung h√§ufig die Zugabe von Eisen ist. <br><br>  Aber nehmen Sie unsere Situation.  Nachdem der Gewinn durch die Umstellung auf PHP 7.0 durch die Zunahme der Aktivit√§t und der Anzahl der Benutzer ausgeglichen wurde, haben wir wieder 600 Server, die Anforderungen an die PHP-Anwendung bedienen.  Um die Kapazit√§t um das Eineinhalbfache zu erh√∂hen, m√ºssen 300 Server hinzugef√ºgt werden. <br><br>  Berechnen Sie die durchschnittlichen Kosten eines Servers mit 4.000 US-Dollar.  300 * 4000 = 1.200.000 USD - die Kosten f√ºr die anderthalbfache Erh√∂hung der Kapazit√§t. <br><br>  Das hei√üt, unter unseren Bedingungen k√∂nnen wir viel Arbeitszeit in die Optimierung des Systems investieren, und es wird immer noch rentabler sein als der Kauf von Eisen. <br><br><h1>  Kapazit√§tsplanung </h1><br>  Bevor Sie etwas unternehmen, ist es wichtig zu verstehen, ob ein Problem vorliegt.  Wenn sie nicht da ist, lohnt es sich vorherzusagen, wann sie erscheinen wird.  Dieser Prozess wird als Kapazit√§tsplanung bezeichnet. <br><br>  Ein konkreter Indikator f√ºr das Vorhandensein von Leistungsproblemen ist die Reaktionszeit.  Schlie√ülich spielt es keine Rolle, ob die CPU (oder andere Ressourcen) zu 6% oder 146% ausgelastet ist: Wenn ein Client in zufriedenstellender Zeit einen Dienst der erforderlichen Qualit√§t erh√§lt, funktioniert alles einwandfrei. <br><br>  Der Nachteil der Konzentration auf die Reaktionszeit besteht darin, dass sie normalerweise erst dann zunimmt, wenn das Problem bereits aufgetreten ist.  Wenn es noch nicht ist, ist es schwierig, sein Aussehen vorherzusagen.  Dar√ºber hinaus spiegelt die Reaktionszeit die Ergebnisse des Einflusses aller Faktoren (Bremsdienste, Netzwerk, Antriebe usw.) wider und bietet kein Verst√§ndnis f√ºr die Ursachen von Problemen. <br><br>  In unserem Fall ist die CPU normalerweise der Engpass. Bei der Planung der Gr√∂√üe und Leistung von Clustern achten wir daher in erster Linie auf die mit ihrer Verwendung verbundenen Metriken.  Wir erfassen die CPU-Auslastung aller unserer Maschinen und erstellen Diagramme mit dem Durchschnittswert, dem Median, dem 75. und 95. Perzentil: <br><br><img src="https://habrastorage.org/webt/pt/xs/dr/ptxsdr6jybv45cznqjykeqd11_g.png"><br>  <i>CPU-Auslastung von Cluster-Maschinen in Prozent: Durchschnitt, Median, Perzentile</i> <br><br>  Es gibt Hunderte von Maschinen in unseren Clustern, die dort seit vielen Jahren hinzugef√ºgt wurden.  Sie unterscheiden sich in Konfiguration und Leistung (der Cluster ist nicht homogen).  Unser Balancer ber√ºcksichtigt dies ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> ) und l√§dt die Maschinen entsprechend ihrer F√§higkeiten.  Um diesen Prozess zu steuern, haben wir auch einen Zeitplan f√ºr maximal und minimal geladene Maschinen. <br><br><img src="https://habrastorage.org/webt/nf/we/f7/nfwef7cixau-uxenwsglrnvfzho.png"><br>  <i>Die am meisten und am wenigsten belasteten Cluster-Computer</i> <br><br>  Wenn Sie sich diese Diagramme (oder nur die Ausgabe des Befehls top) ansehen und die CPU-Auslastung von 50% sehen, denken Sie, dass wir noch einen Spielraum f√ºr eine zweifache Erh√∂hung der Auslastung haben.  Tats√§chlich ist dies jedoch normalerweise nicht der Fall.  Und hier ist warum. <br><br><h1>  Hyper-Threading </h1><br>  Stellen Sie sich einen einzelnen Kern ohne Hypertreading vor.  Wir laden es mit einem CPU-gebundenen Thread.  Oben wird 100% geladen. <br><br>  Aktivieren Sie nun das Hyperlesen auf diesem Kernel und laden Sie es genauso.  Oben sehen wir bereits zwei logische Kerne, und die Gesamtlast betr√§gt 50% (normalerweise auf einem 0% und auf dem anderen 100%). <br><br><img src="https://habrastorage.org/webt/gr/zi/hw/grzihwfkj986zatrfrsrgg4-ykk.png"><br>  <i>CPU-Auslastung: Top-Daten und was wirklich passiert</i> <br><br>  Als ob der Prozessor nur zu 50% ausgelastet w√§re.  Aber physikalisch erschien kein zus√§tzlicher freier Kern.  Hypertreading erm√∂glicht <i>in einigen F√§llen</i> die gleichzeitige Ausf√ºhrung von mehr als einem Prozess auf einem physischen Kern.  Dies ist jedoch weit davon entfernt, die Leistung in typischen Situationen zu verdoppeln, obwohl es im Diagramm zur CPU-Auslastung wie die H√§lfte der Ressourcen aussieht: von 50% auf 100%. <br><br>  Dies bedeutet, dass nach 50% der CPU-Auslastung, wenn Hypertreading aktiviert ist, es nicht mehr so ‚Äã‚Äãw√§chst wie zuvor. <br><br>  Ich habe diesen Code geschrieben, um zu demonstrieren (dies ist eine Art synthetischer Fall, in Wirklichkeit werden die Ergebnisse unterschiedlich sein): <br><br><div class="spoiler">  <b class="spoiler_title">Skriptcode</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $concurrency = $_SERVER[<span class="hljs-string"><span class="hljs-string">'argv'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ?? <span class="hljs-number"><span class="hljs-number">1</span></span>; $hashes = <span class="hljs-number"><span class="hljs-number">100000000</span></span>; $chunkSize = intval($hashes / $concurrency); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $children = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $concurrency; $i++) {    $pid = pcntl_fork();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> === $pid) {        $first = $i * $chunkSize;        $last = ($i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * $chunkSize - <span class="hljs-number"><span class="hljs-number">1</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = $first; $j &lt; $last; $j++) {            $dummy = md5($j);        }        printf(<span class="hljs-string"><span class="hljs-string">"[%d]: %d hashes in %0.4f sec\n"</span></span>, $i, $last - $first, microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1);        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        $children[$pid] = <span class="hljs-number"><span class="hljs-number">1</span></span>;    } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count($children) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    $pid = pcntl_waitpid(<span class="hljs-number"><span class="hljs-number">-1</span></span>, $status);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($children[$pid]);    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a error pid=$pid"</span></span>);    } }</code> </pre> <br><br></div></div><br>  Ich habe zwei physische Kerne auf meinem Laptop.  F√ºhren Sie diesen Code mit unterschiedlichen Eingabedaten aus, um seine Leistung mit einer unterschiedlichen Anzahl paralleler C-Prozesse zu messen. <br><br><div class="spoiler">  <b class="spoiler_title">Messergebnisse</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/n5/3z/ev/n53zevyyvda4w4u-2xkjryqlj9m.png"><br></div></div><br>  Wir zeichnen die Ergebnisse der Starts auf: <br><img src="https://habrastorage.org/webt/xg/iv/rn/xgivrnyyynb418fnr5muqfn0qba.png"><br>  <i>Skriptleistung abh√§ngig von der Anzahl der parallelen Prozesse</i> <br><br>  Worauf Sie achten k√∂nnen: <br><br><ul><li>  C = 1 und C = 2 sind vorhersehbar gleich f√ºr HT = Ein und HT = Aus. Die Leistung verdoppelt sich, wenn ein physischer Kern hinzugef√ºgt wird. <br></li></ul><br><ul><li>  Bei C = 3 machen sich die Vorteile von HT bemerkbar: Bei HT = Ein konnten wir zus√§tzliche Leistung erzielen, w√§hrend bei HT = Aus ab C = 3 die Vorhersage vorhersehbar langsam abnimmt. <br></li></ul><br><ul><li>  bei C = 4 sehen wir alle Vorteile von HT;  Wir konnten weitere 30% der Produktivit√§t herausholen, aber im Vergleich zu C = 2 zu diesem Zeitpunkt stieg die CPU-Auslastung von 50% auf 100%. <br></li></ul><br>  Insgesamt erhalten wir bei der Ausf√ºhrung dieses Skripts in den oberen 50% der CPU-Auslastung 8.065 Mhash / Sek. Und bei 100% - 10.511 Mhash / Sek.  Dies bedeutet, dass wir bei etwa 50% der Spitze 8,065 / 10,511 ~ 77% der maximalen Systemleistung erhalten und tats√§chlich noch etwa 100% in der Reserve verbleiben - 77% = 23% und nicht 50%, wie es scheint. <br><br>  Diese Tatsache muss bei der Planung ber√ºcksichtigt werden. <br><br><img src="https://habrastorage.org/webt/ru/6g/00/ru6g002t0ziv1pkppgqfjber80o.png"><br>  <i>CPU-Auslastung f√ºr Demoscript: Top-Daten und was wirklich passiert</i> <br><br><h1>  Verkehrsinkonsistenz </h1><br>  Neben dem Hypertreading erschwert die Planung auch die Unebenheiten des Verkehrs in Abh√§ngigkeit von Tageszeit, Wochentag, Jahreszeit und anderer H√§ufigkeit.  F√ºr uns ist der H√∂hepunkt zum Beispiel Sonntagabend. <br><br><img src="https://habrastorage.org/webt/eh/ks/58/ehks58pfn7sjva3c869i7cwj7fy.png"><br>  <i>Anzahl der Anfragen pro Sekunde, Spitzen-Sonntagabend</i> <br><br>  Nicht immer √§ndert sich die Anzahl der Anfragen auf offensichtliche Weise.  Zum Beispiel k√∂nnen Benutzer irgendwie mit anderen Benutzern interagieren: Die Aktivit√§t einiger kann Push / E-Mail an andere generieren und sie somit in den Prozess einbeziehen.  Hinzu kommen Werbekampagnen, die den Traffic erh√∂hen und auf die Sie ebenfalls vorbereitet sein m√ºssen. <br><br>  All dies ist auch bei der Planung zu ber√ºcksichtigen: Zum Beispiel, um einen Trend nach Spitzentagen aufzubauen und die m√∂gliche Nichtlinearit√§t des Spitzenwachstums zu ber√ºcksichtigen. <br><br><h1>  Profilierungs- und Messwerkzeuge </h1><br>  Angenommen, wir stellen fest, dass es Leistungsprobleme gibt, verstehen, dass dies nicht die Datenbank / die Dienste / das Zeug ist, und haben uns dennoch entschlossen, den Code zu optimieren.  Dazu ben√∂tigen wir zun√§chst einen Profiler oder einige Tools, um Engp√§sse zu finden und anschlie√üend die Ergebnisse unserer Optimierungen anzuzeigen. <br><br>  Leider gibt es f√ºr PHP heute kein gutes universelles Tool. <br><br><h2>  perf </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">perf</a> ist ein Profiling-Tool, das in den Linux-Kernel integriert ist.  Es handelt sich um einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stichprobenprofiler</a> , der von einem separaten Prozess gestartet wird. Daher wird dem zu profilierenden Programm kein direkter Overhead hinzugef√ºgt.  Indirekt hinzugef√ºgter Overhead wird gleichm√§√üig ‚Äûverschmiert‚Äú, sodass die Messungen nicht verzerrt werden. <br><br>  Trotz all seiner Vorteile kann perf nur mit kompiliertem Code und mit JIT arbeiten und nicht mit Code, der "unter einer virtuellen Maschine" ausgef√ºhrt wird.  Daher kann der PHP-Code selbst nicht profiliert werden, aber Sie k√∂nnen deutlich sehen, wie PHP im Inneren funktioniert, einschlie√ülich verschiedener PHP-Erweiterungen, und wie viel Ressourcen daf√ºr aufgewendet werden. <br><br>  Zum Beispiel haben wir bei perf mehrere Engp√§sse festgestellt, einschlie√ülich einer Komprimierungsstelle, auf die ich weiter unten eingehen werde. <br><br>  Ein Beispiel: <br><br> <code>perf record --call-graph dwarf,65528 -F 99 -p $(pgrep php-cgi | paste -sd "," -) -- sleep 20 <br> perf report</code> <br> <br>  (Wenn der Prozess und perf unter verschiedenen Benutzern ausgef√ºhrt werden, muss perf unter sudo ausgef√ºhrt werden.) <br><br><img src="https://habrastorage.org/webt/k9/vu/k6/k9vuk6sf37xhshipgvx2byw3xps.png"><br>  <i>Beispiel f√ºr die Ausgabe eines Perf-Berichts f√ºr PHP-FPM</i> <br><br><h2>  XHProf und XHProf Aggregator </h2><br>  XHProf ist eine Erweiterung f√ºr PHP, die Timer um alle Aufrufe von Funktionen / Methoden platziert und Tools zur Visualisierung der so erhaltenen Ergebnisse enth√§lt.  Im Gegensatz zu perf k√∂nnen Sie damit mit PHP-Code arbeiten (gleichzeitig ist nicht sichtbar, was in den Erweiterungen passiert). <br><br>  Die Nachteile umfassen zwei Dinge: <br><br><ul><li>  Alle Messungen werden im Rahmen einer einzigen Anfrage gesammelt, daher liefern sie keine Informationen √ºber das Gesamtbild. <br></li><li>  Der Overhead ist zwar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht so gro√ü</a> wie beispielsweise bei Verwendung von Xdebug, aber er ist und in einigen F√§llen sind die Ergebnisse stark verzerrt (je √∂fter eine Funktion aufgerufen wird und je einfacher sie ist, desto gr√∂√üer ist die Verzerrung). <br></li></ul><br>  Hier ist ein Beispiel, das den letzten Punkt veranschaulicht: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ child1(); child2(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; $i++) { parent1(); }</code> </pre> <br><img src="https://habrastorage.org/webt/iw/7m/y6/iw7my6irzq5xg7_soy7sfkqpj7m.png"><br>  <i>XHProf-Ausgabe f√ºr Demos: parent1 ist um Gr√∂√üenordnungen gr√∂√üer als die Summe von child1 und child2</i> <br><br>  Es ist ersichtlich, dass parent1 () ~ 500-mal l√§nger ausgef√ºhrt wurde als child1 () + child2 (), obwohl diese Zahlen in Wirklichkeit ungef√§hr gleich sein sollten, ebenso wie main () und parent1 (). <br><br>  Wenn der letzte Nachteil schwer zu bek√§mpfen ist, haben wir zur Bek√§mpfung des ersten einen Zusatz f√ºr XHProf erstellt, der die Profile verschiedener Anforderungen aggregiert und aggregierte Daten visualisiert. <br><br>  Neben XHProf gibt es viele andere weniger bekannte Profiler, die nach einem √§hnlichen Prinzip arbeiten.  Sie haben √§hnliche Vor- und Nachteile. <br><br><h2>  Pinba </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit Pinba</a> k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Leistung anhand von</a> Skripten (Aktionen) und voreingestellten Timern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberwachen</a> .  Alle Messungen im Rahmen von Skripten werden sofort durchgef√ºhrt, hierf√ºr sind keine zus√§tzlichen Schritte erforderlich.  F√ºr jedes Skript und jeden Timer wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getrusage ausgef√ºhrt</a> , sodass wir genau wissen, wie viel Prozessorzeit f√ºr einen bestimmten Code aufgewendet wurde (im Gegensatz zu Stichprobenprofilern, bei denen sich diese Zeit m√∂glicherweise als Netzwerk, Festplatte usw. herausstellt).  Pinba eignet sich hervorragend zum Speichern historischer Daten und zum Abrufen eines Bildes im Allgemeinen und innerhalb bestimmter Arten von Abfragen. <br><br><img src="https://habrastorage.org/webt/od/x5/qr/odx5qryl0ufhceiuyjkytjhtm0c.png"><br>  <i>Die allgemeine Auswahl aller von Pinba erhaltenen Skripte</i> <br><br>  Zu den Nachteilen geh√∂ren die Tatsache, dass Timer, die bestimmte Abschnitte des Codes und nicht die gesamten Skripte profilieren, im Voraus im Code angeordnet werden m√ºssen, sowie das Vorhandensein eines Overheads, der (wie in XHProf) Daten verzerren kann. <br><br><h2>  phpspy </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phpspy</a> ist ein relativ neues Projekt (das erste Commit auf GitHub war vor einem halben Jahr), das vielversprechend aussieht, daher beobachten wir es genau. <br><br>  Aus Sicht des Benutzers √§hnelt phpspy perf: Es wird ein paralleler Prozess gestartet, der die Speicherteile des PHP-Prozesses regelm√§√üig kopiert, analysiert und von dort Stapelspuren und andere Daten empf√§ngt.  Dies geschieht auf eine ziemlich spezifische Art und Weise.  Um den Overhead zu minimieren, stoppt phpspy den PHP-Prozess nicht und kopiert den Speicher direkt, w√§hrend er ausgef√ºhrt wird.  Dies f√ºhrt dazu, dass der Profiler einen inkonsistenten Status erhalten kann und Stapelspuren besch√§digt werden k√∂nnen.  Aber phpspy kann dies erkennen und solche Daten verwerfen. <br><br>  Mit diesem Tool k√∂nnen k√ºnftig sowohl Daten zum Gesamtbild als auch Profile bestimmter Abfragetypen erfasst werden. <br><br><h2>  Vergleichstabelle </h2><br>  Um die Unterschiede zwischen den Werkzeugen zu strukturieren, erstellen wir eine Pivot-Tabelle: <br><br><img src="https://habrastorage.org/webt/bg/1a/bt/bg1abtxk-f8i5q83qm5teok3lbs.png"><br>  <i>Vergleich der Hauptmerkmale von Profilern</i> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flammengraphen</a></i> <br><br><h1>  Optimierung und Ans√§tze </h1><br>  Mit diesen Tools √ºberwachen wir st√§ndig die Leistung und Nutzung unserer Ressourcen.  Wenn sie ungerechtfertigt verwendet werden oder wir uns dem Schwellenwert n√§hern (f√ºr die CPU haben wir empirisch einen Wert von 55% gew√§hlt, um im Falle eines Wachstums eine Zeitspanne zu haben), wie ich oben geschrieben habe, ist eine der L√∂sungen f√ºr das Problem die Optimierung. <br><br>  Nun, wenn die Optimierung bereits von jemand anderem durchgef√ºhrt wurde, wie dies bei PHP 7.0 der Fall war, stellte sich heraus, dass diese Version viel produktiver war als die vorherigen.  Wir versuchen im Allgemeinen, moderne Technologien und Tools zu verwenden, einschlie√ülich zeitnaher Updates auf die neuesten Versionen von PHP.  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√∂ffentlichen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmarks</a> ist PHP 7.2 5-12% schneller als PHP 7.1.  Aber dieser √úbergang gab uns leider viel weniger. <br><br>  F√ºr die ganze Zeit haben wir eine Vielzahl von Optimierungen implementiert.  Leider h√§ngen die meisten von ihnen stark mit unserer Gesch√§ftslogik zusammen.  Ich werde √ºber diejenigen sprechen, die nicht nur f√ºr uns relevant sein k√∂nnen, oder √ºber Ideen und Ans√§tze, die au√üerhalb unseres Codes verwendet werden k√∂nnen. <br><br><h2>  Zlib-Komprimierung =&gt; zstd </h2><br>  Wir verwenden die Komprimierung f√ºr gro√üe Memkey-Schl√ºssel.  Dies erm√∂glicht es uns, drei- bis viermal weniger Speicher f√ºr Speicher zu verwenden, da zus√§tzliche CPU-Kosten f√ºr die Komprimierung / Dekomprimierung anfallen.  Wir haben daf√ºr zlib verwendet (unsere Erweiterung f√ºr die Arbeit mit Memekes unterscheidet sich von der mit PHP, aber offizielle verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch</a> zlib). <br><br>  In der Perfektion war die Produktion ungef√§hr so: <br><br> <code>+    4.03%     0.22% php-cgi  libz.so.1.2.11      [.] inflate <br> +    3.38%     0.00% php-cgi  libz.so.1.2.11      [.] deflate</code> <br> <br>  7-8% der Zeit wurden f√ºr die Komprimierung / Dekomprimierung aufgewendet. <br><br>  Wir haben uns entschlossen, verschiedene Ebenen und Komprimierungsalgorithmen zu testen.  Es stellte sich heraus, dass zstd auf unseren Daten fast zehnmal schneller l√§uft und ~ 1,1-mal an Ort und Stelle verliert.  Eine ziemlich einfache √Ñnderung des Algorithmus hat uns ~ 7,5% CPU gespart (dies entspricht, wie ich mich erinnere, auf unseren Volumes ~ 45 Servern). <br><br>  Es ist wichtig zu verstehen, dass das Verh√§ltnis der Leistung verschiedener Komprimierungsalgorithmen in Abh√§ngigkeit von den Eingabedaten stark variieren kann.  Es gibt verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleiche</a> , aber am genauesten kann dies nur anhand von Beispielen aus der Praxis gesch√§tzt werden. <br><br><h2>  IS_ARRAY_IMMUTABLE als Repository selten ge√§nderter Daten </h2><br>  Wenn Sie mit realen Aufgaben arbeiten, m√ºssen Sie mit solchen Daten umgehen, die Sie h√§ufig ben√∂tigen und gleichzeitig selten √§ndern und eine begrenzte Gr√∂√üe haben.  Wir haben viele √§hnliche Daten, ein gutes Beispiel ist die Konfiguration von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Split-Tests</a> .  Wir pr√ºfen, ob der Benutzer unter die Bedingungen eines bestimmten Tests f√§llt, und zeigen ihm abh√§ngig davon experimentelle oder normale Funktionen (dies geschieht fast bei jeder Anforderung).  In anderen Projekten k√∂nnen Konfigurationen und verschiedene Verzeichnisse ein Beispiel sein: L√§nder, St√§dte, Sprachen, Kategorien, Marken usw. <br><br>  Da solche Daten h√§ufig angefordert werden, kann ihr Empfang sowohl f√ºr die Anwendung selbst als auch f√ºr den Dienst, in dem diese Daten gespeichert sind, eine sp√ºrbare zus√§tzliche Belastung darstellen.  Das letztere Problem kann beispielsweise mit APCu gel√∂st werden, das den Speicher desselben Computers verwendet, auf dem PHP-FPM als Speicher ausgef√ºhrt wird.  Aber auch dann: <br><br><ul><li>  Es fallen Serialisierungs- / Deserialisierungskosten an. <br></li><li>  Sie m√ºssen die Daten beim √Ñndern irgendwie ung√ºltig machen. <br></li><li>  Es gibt einen gewissen Overhead im Vergleich zum Zugriff auf nur eine Variable in PHP. <br></li></ul><br>  PHP 7.0 f√ºhrt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IS_ARRAY_IMMUTABLE-</a> Optimierung ein.  Wenn Sie ein Array deklarieren, dessen Elemente zum Zeitpunkt der Kompilierung bekannt sind, wird es einmal verarbeitet und in den OPCache-Speicher gestellt. PHP-FPM-Mitarbeiter verweisen auf diesen gemeinsam genutzten Speicher, ohne ihre Zeit zu verbringen, bevor sie versuchen, √Ñnderungen vorzunehmen.  Daraus folgt auch, dass das Einschlie√üen eines solchen Arrays unabh√§ngig von der Gr√∂√üe eine konstante Zeit ben√∂tigt (normalerweise ~ 1 Mikrosekunde). <br><br>  Zum Vergleich: Ein Beispiel f√ºr die Zeit, um ein Array mit 10.000 Elementen √ºber include und apcu_fetch abzurufen: <br><br><pre> <code class="php hljs">$t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'test-incl-1.php'</span></span>; $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"include (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); $t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = apcu_fetch(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"apcu_fetch (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//include (10000): 1 microsec //apcu_fetch (10000): 792 microsec</span></span></code> </pre><br>  Die √úberpr√ºfung, ob diese Optimierung angewendet wurde, kann sehr einfach sein, wenn Sie sich die generierten Opcodes ansehen: <br><br><pre> <code class="php hljs">$ cat immutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val1'</span></span>, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ cat mutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; \SomeClass::CONST_1, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ php -d opcache.enable=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> immutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">1</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">0</span></span>) ; (after optimizer) ; /home/ubuntu/immutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(...) $ php -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> mutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">5</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">2</span></span>) ; (after optimizer) ; /home/ubuntu/mutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T1 = FETCH_CLASS_CONSTANT string(<span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"CONST_1"</span></span>) L1 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T0 = INIT_ARRAY <span class="hljs-number"><span class="hljs-number">3</span></span> T1 string(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) L2 (<span class="hljs-number"><span class="hljs-number">5</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val2"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>) L3 (<span class="hljs-number"><span class="hljs-number">6</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>) L4 (<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T0</code> </pre><br>  Im ersten Fall ist klar, dass die Datei nur einen Opcode enth√§lt - die R√ºckgabe des fertigen Arrays.  Im zweiten Fall erfolgt die Element-f√ºr-Element-Bildung jedes Mal, wenn diese Datei ausgef√ºhrt wird. <br><br>  Somit ist es m√∂glich, Strukturen in einer Form zu generieren, die keine weitere Transformation zur Laufzeit erfordert.  Anstatt beispielsweise die Klassennamen jedes Mal f√ºr das automatische Laden durch die Zeichen "_" und "\" zu zerlegen, k√∂nnen Sie die Korrespondenzzuordnung "Klasse =&gt; Pfad" vorab generieren.  In diesem Fall wird die Konvertierungsfunktion auf einen einzelnen Hash-Tabellenaufruf reduziert.  Composer f√ºhrt diese Art der Optimierung durch, wenn Sie die <a href="">Option "Autoloader optimieren"</a> aktivieren. <br><br>  F√ºr die Ung√ºltigmachung solcher Daten m√ºssen Sie nichts Spezielles tun. PHP selbst kompiliert die Datei beim √Ñndern neu, genau wie bei einer normalen Codebereitstellung.  Der einzige Nachteil, den Sie nicht vergessen d√ºrfen: Wenn die Datei sehr gro√ü ist, f√ºhrt die erste Anforderung nach dem √Ñndern zu einer Neukompilierung, die eine sp√ºrbare Zeit in Anspruch nehmen kann. <br><br><h2>  Leistung umfassen / erfordern </h2><br>  Im Gegensatz zum statischen Array-Beispiel ist das Anh√§ngen von Dateien mit Klassen- und Funktionsdeklarationen nicht so schnell.  Trotz des Vorhandenseins von OPCache muss die PHP-Engine sie in den Prozessspeicher kopieren und Abh√§ngigkeiten rekursiv verbinden, was am Ende Hunderte von Mikrosekunden oder sogar Millisekunden pro Datei dauern kann. <br><br>  Wenn Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symfony 4.1</a> ein neues leeres Projekt erstellen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">get_included_files () als</a> erste Zeile in die Aktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einf√ºgen</a> , sehen Sie, dass bereits 310 Dateien verbunden sind.  In einem realen Projekt kann diese Anzahl Tausende pro Anfrage erreichen.  Es lohnt sich, auf folgende Dinge zu achten. <br><br>  <b>Fehlende automatische Ladefunktionen</b> <br><br>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function Autoloading RFC</a> , aber seit einigen Jahren ist keine Entwicklung mehr zu beobachten.  Wenn eine Abh√§ngigkeit in Composer Funktionen au√üerhalb der Klasse definiert und diese Funktionen f√ºr den Benutzer zug√§nglich sein sollten, erfolgt dies durch <a href="">obligatorisches Verbinden einer</a> Datei mit diesen Funktionen mit jeder Initialisierung des Autoloaders. <br><br>  Wenn Sie beispielsweise eine der Abh√§ngigkeiten aus composer.json entfernen, die viele Funktionen deklariert und leicht durch hundert Codezeilen ersetzt werden kann, haben wir ein paar Prozent der CPU gewonnen. <br><br>  <b>Der Auto-Loader wird h√§ufiger aufgerufen, als es den Anschein hat.</b> <br><br>  Erstellen Sie eine solche Datei mit einer Klasse, um die Idee zu demonstrieren: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">D</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC1 = \E::E1;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC2 = \F::F1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as3 = \G::G1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as4 = \H::H1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a5 = \I::I1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a6 = \J::J1;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\K $k = null)</span></span></span><span class="hljs-function"> </span></span>{}   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\L $l = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\M $m = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\N $n = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\P $p = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>Auto-Loader registrieren:</b> <br><br><pre> <code class="php hljs">spl_autoload_register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Including $name...\n"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"$name.php"</span></span>; });</code> </pre> <br>  <b>Und wir werden mehrere Anwendungsf√§lle f√ºr diese Klasse machen:</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'A.php'</span></span> Including B... Including D... Including C... \A::AC1 Including A... Including B... Including D... Including C... Including E... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A() Including A... Including B... Including D... Including C... Including E... Including F... Including G... Including H... Including I... Including J...</code> </pre><br>  M√∂glicherweise stellen Sie fest, dass, wenn wir die Klasse nur irgendwie verbinden, aber ihre Instanz nicht erstellen, die √ºbergeordneten Elemente, Schnittstellen und Merkmale miteinander verbunden werden.  Dies erfolgt rekursiv f√ºr alle Dateien, die als Aufl√∂sungen verbunden sind. <br><br>  Beim Erstellen einer Instanz wird die Aufl√∂sung aller Konstanten und Felder hinzugef√ºgt, was zur Verbindung aller daf√ºr erforderlichen Dateien f√ºhrt, was wiederum auch die rekursive Verbindung von Merkmalen, Eltern und Schnittstellen der neu verbundenen Klassen bewirkt. <br><br><img src="https://habrastorage.org/webt/8a/qq/2t/8aqq2tf_8j-mixi8p_ydoypo-yo.png"><br>  <i>Verbinden verwandter Klassen f√ºr den Instanzerstellungsprozess und andere F√§lle</i> <br><br>  Es gibt keine universelle L√∂sung f√ºr dieses Problem. Sie m√ºssen nur daran denken und die Verbindungen zwischen Klassen √ºberwachen: Eine Zeile kann die Verbindung von Hunderten von Dateien herstellen. <br><br>  <b>OPCache-Einstellungen</b> <br><br>  Wenn Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">atomare Bereitstellungsmethode</a> verwenden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">indem Sie den</a> von Rasmus Lerdorf, dem Ersteller von PHP, vorgeschlagenen Symlink √§ndern, m√ºssen Sie opcache.revalidate_path einschlie√üen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um das</a> Problem des "Festhaltens" des Symlinks an der alten Version zu l√∂sen, wie beispielsweise in diesem von Mail √ºbersetzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber OPCache empfohlen .Ru Group. <br><br>  Das Problem ist, dass diese Option die Zeit f√ºr das Einschlie√üen jeder Datei erheblich verl√§ngert (durchschnittlich eineinhalb bis zwei Mal).  Insgesamt kann dies eine erhebliche Menge an Ressourcen verbrauchen (in unserem Fall ergab das Deaktivieren dieser Option einen Gewinn von 7‚Äì9%). <br><br>  Um es zu deaktivieren, m√ºssen Sie zwei Dinge tun: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie den</a> Webserver Symlinks aufl√∂sen. <br></li><li>  Beenden Sie die Verbindung von Dateien innerhalb des PHP-Skripts entlang der Pfade, die Symlinks enthalten, oder erzwingen Sie sie √ºber readlink () oder realpath (). <br></li></ul><br>  Wenn alle Dateien mit dem Composer-Autoloader verbunden sind, wird das zweite Element automatisch ausgef√ºhrt, nachdem das erste abgeschlossen ist: composer verwendet die Konstante __DIR__, die korrekt aufgel√∂st wird. <br><br>  OPCache bietet einige weitere Optionen, die im Austausch f√ºr Flexibilit√§t zu einer Leistungssteigerung f√ºhren k√∂nnen.  Sie k√∂nnen mehr dar√ºber in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> lesen, den ich oben erw√§hnt habe. <br><br>  Trotz all dieser Optimierungen ist include immer noch nicht kostenlos.  Um dem entgegenzuwirken, plant PHP 7.4 das Hinzuf√ºgen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preload</a> . <br><br><h2>  APCu-Sperre </h2><br>  Obwohl es sich hier nicht um Datenbanken und Dienste handelt, k√∂nnen im Code auch verschiedene Arten von Sperren auftreten, die die Ausf√ºhrungszeit des Skripts verl√§ngern. <br><br>  Als die Anfragen wuchsen, stellten wir zu Spitzenzeiten eine starke Verlangsamung der Reaktion fest.  Nachdem die Gr√ºnde herausgefunden wurden, stellte sich heraus, dass APCu zwar der schnellste Weg ist, um Daten zu erhalten (im Vergleich zu Memcache, Redis und anderen externen Speichern), aber auch langsam arbeiten kann, wenn dieselben Schl√ºssel h√§ufig √ºberschrieben werden. <br><br><img src="https://habrastorage.org/webt/hs/05/gc/hs05gcwvqozrqews1ewwtsskdyo.png"><br>  <i>Anzahl der Anfragen pro Sekunde und Laufzeit: Spitzenwerte am 16. und 17. Oktober</i> <br><br>  Bei Verwendung von APCu als Cache ist dieses Problem nicht so relevant, da das Caching normalerweise seltenes Schreiben und h√§ufiges Lesen umfasst.  Einige Aufgaben und Algorithmen (z. B. Leistungsschalter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung in PHP</a> )) beinhalten jedoch auch h√§ufige Aufzeichnungen, die zu Sperren f√ºhren. <br><br>  Es gibt keine universelle L√∂sung f√ºr dieses Problem, aber im Fall von Leistungsschaltern kann es beispielsweise gel√∂st werden, indem es in einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Dienst gestellt wird</a> , der auf Computern mit PHP installiert ist. <br><br><h2>  Stapelverarbeitung </h2><br>  Selbst wenn Sie include nicht ber√ºcksichtigen, wird in der Regel trotzdem ein erheblicher Teil der Ausf√ºhrungszeit f√ºr die Initialisierung f√ºr die Initialisierung aufgewendet: ein Framework (z. B. Erstellen eines DI-Containers und Initialisieren aller Abh√§ngigkeiten, Routing, Ausf√ºhren aller Listener), Ausl√∂sen der Sitzung, des Benutzers usw. weiter. <br><br>  Wenn Ihr Backend eine interne API f√ºr etwas ist, k√∂nnen einige Anforderungen auf Clients geb√ºndelt und als einzelne Anforderung gesendet werden.  In diesem Fall wird die Initialisierung f√ºr mehrere Anforderungen einmal durchgef√ºhrt. <br><br>      ,   ,    .    -  ,          .       . <br><br><h2>    </h2><br>    Badoo   ,     .    PHP-FPM,      CPU,   ,            ,    :        IO, CPU  . <br><br>      PHP-FPM    ‚Äî  ,          PHP. <br><br>         (CPU, IO),    . , ,       ,  ,    -     ,        .        ,     .   ,  ,      . <br><br><h1>  Fazit </h1><br>        .                    PHP     . <br><br>  : <br><br><ul><li>       ; <br></li><li>     ; <br></li><li>  -  ,  :  ,    ; <br></li><li>   :       (, ,  ); <br></li><li>    :     ; <br></li><li>   , OPCache    PHP,  , ,   ; <br></li><li>    :       (, ,   PHP 7.2   ,   ); <br></li><li>    : ,        . <br></li></ul><br>       ? <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430722/">https://habr.com/ru/post/de430722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430710/index.html">Was tun, wenn der Schwarze Freitag morgen ist und Ihre Server nicht bereit sind?</a></li>
<li><a href="../de430712/index.html">NeurIPS: Wie man die beste ML-Konferenz erobert</a></li>
<li><a href="../de430714/index.html">VMware kauft Heptio - was bedeutet das f√ºr Kubernetes?</a></li>
<li><a href="../de430718/index.html">F√ºr welche Objekte lohnt sich die Cloud-Video√ºberwachung?</a></li>
<li><a href="../de430720/index.html">Intel RealSense D435i: kleines Update und kurzer historischer Exkurs</a></li>
<li><a href="../de430724/index.html">DEFCON 21. DNS-Konferenzen k√∂nnen gesundheitssch√§dlich sein. Teil 1</a></li>
<li><a href="../de430728/index.html">Lehre mich, Feedback zu geben</a></li>
<li><a href="../de430730/index.html">Was macht F & E ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../de430732/index.html">Zur Frage der Teilung und TI</a></li>
<li><a href="../de430734/index.html">Intelligente Updates im Vergleich zu intelligenten Vertr√§gen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>