<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📡 🥟 🤾🏽 PHP-Leistung: Planen, Profilieren, Optimieren 🧕🏿 👂 👨🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Vor zwei Jahren haben wir darüber geschrieben, wie wir auf PHP 7.0 umgestiegen sind und eine Million Dollar gespart haben. In unserem Last...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP-Leistung: Planen, Profilieren, Optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430722/"><img src="https://habrastorage.org/webt/k_/fe/vv/k_fevvrhhn2aruuz19gpne_jypy.jpeg"><br><br>  Hallo Habr!  Vor zwei Jahren haben wir darüber geschrieben, wie wir auf PHP 7.0 umgestiegen sind und eine Million Dollar gespart haben.  In unserem Lastprofil erwies sich die neue Version als doppelt so effizient bei der CPU-Auslastung: Die Last, mit der wir ~ 600 Server bedienten, nachdem der Übergang begonnen hatte, ~ 300 zu bedienen.  Infolgedessen verfügten wir zwei Jahre lang über Kapazitätsreserven. <br><br>  Aber Badoo wächst.  Die Anzahl der aktiven Benutzer nimmt ständig zu.  Wir verbessern und entwickeln unsere Funktionen, dank derer Benutzer immer mehr Zeit in der Anwendung verbringen.  Dies spiegelt sich wiederum in der Anzahl der Anfragen wider, die sich in den letzten zwei Jahren um das 2- bis 2,5-fache erhöht haben. <br><br>  Wir befanden uns in einer Situation, in der ein zweifacher Leistungszuwachs durch mehr als eine zweifache Steigerung der Anforderungen ausgeglichen wurde, und wir näherten uns erneut den Grenzen unseres Clusters.  Im Kern von PHP werden wieder nützliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierungen</a> (JIT, Preloading) erwartet, die jedoch nur für PHP 7.4 geplant sind. Diese Version wird frühestens in einem Jahr veröffentlicht.  Daher kann der Übergangstrick jetzt nicht wiederholt werden - Sie müssen den Anwendungscode selbst optimieren. <br><br>  Im Folgenden werde ich Ihnen erläutern, wie wir solche Aufgaben angehen, welche Tools wir verwenden, und Beispiele für Optimierungen, Ideen und Ansätze nennen, die wir anwenden und die uns in unserer Zeit geholfen haben. <br><a name="habracut"></a><br><h1>  Warum optimieren? </h1><br>  Der einfachste und naheliegendste Weg, um das Leistungsproblem zu lösen, ist das Hinzufügen von Eisen.  Wenn Ihr Code auf demselben Server ausgeführt wird, verdoppelt das Hinzufügen eines weiteren die Leistung Ihres Clusters.  Wenn wir diese Kosten auf die Arbeitszeit des Entwicklers übertragen, fragen wir uns: Wird er in dieser Zeit aufgrund von Optimierungen eine zweifache Produktivitätssteigerung erzielen können?  Vielleicht ja, aber vielleicht auch nicht: Es kommt darauf an, wie optimal das System bereits funktioniert und wie gut der Entwickler ist.  Auf der anderen Seite bleibt der gekaufte Server Eigentum des Unternehmens und die aufgewendete Zeit wird nicht zurückgegeben. <br><br>  Es stellt sich heraus, dass bei kleinen Mengen die richtige Lösung häufig die Zugabe von Eisen ist. <br><br>  Aber nehmen Sie unsere Situation.  Nachdem der Gewinn durch die Umstellung auf PHP 7.0 durch die Zunahme der Aktivität und der Anzahl der Benutzer ausgeglichen wurde, haben wir wieder 600 Server, die Anforderungen an die PHP-Anwendung bedienen.  Um die Kapazität um das Eineinhalbfache zu erhöhen, müssen 300 Server hinzugefügt werden. <br><br>  Berechnen Sie die durchschnittlichen Kosten eines Servers mit 4.000 US-Dollar.  300 * 4000 = 1.200.000 USD - die Kosten für die anderthalbfache Erhöhung der Kapazität. <br><br>  Das heißt, unter unseren Bedingungen können wir viel Arbeitszeit in die Optimierung des Systems investieren, und es wird immer noch rentabler sein als der Kauf von Eisen. <br><br><h1>  Kapazitätsplanung </h1><br>  Bevor Sie etwas unternehmen, ist es wichtig zu verstehen, ob ein Problem vorliegt.  Wenn sie nicht da ist, lohnt es sich vorherzusagen, wann sie erscheinen wird.  Dieser Prozess wird als Kapazitätsplanung bezeichnet. <br><br>  Ein konkreter Indikator für das Vorhandensein von Leistungsproblemen ist die Reaktionszeit.  Schließlich spielt es keine Rolle, ob die CPU (oder andere Ressourcen) zu 6% oder 146% ausgelastet ist: Wenn ein Client in zufriedenstellender Zeit einen Dienst der erforderlichen Qualität erhält, funktioniert alles einwandfrei. <br><br>  Der Nachteil der Konzentration auf die Reaktionszeit besteht darin, dass sie normalerweise erst dann zunimmt, wenn das Problem bereits aufgetreten ist.  Wenn es noch nicht ist, ist es schwierig, sein Aussehen vorherzusagen.  Darüber hinaus spiegelt die Reaktionszeit die Ergebnisse des Einflusses aller Faktoren (Bremsdienste, Netzwerk, Antriebe usw.) wider und bietet kein Verständnis für die Ursachen von Problemen. <br><br>  In unserem Fall ist die CPU normalerweise der Engpass. Bei der Planung der Größe und Leistung von Clustern achten wir daher in erster Linie auf die mit ihrer Verwendung verbundenen Metriken.  Wir erfassen die CPU-Auslastung aller unserer Maschinen und erstellen Diagramme mit dem Durchschnittswert, dem Median, dem 75. und 95. Perzentil: <br><br><img src="https://habrastorage.org/webt/pt/xs/dr/ptxsdr6jybv45cznqjykeqd11_g.png"><br>  <i>CPU-Auslastung von Cluster-Maschinen in Prozent: Durchschnitt, Median, Perzentile</i> <br><br>  Es gibt Hunderte von Maschinen in unseren Clustern, die dort seit vielen Jahren hinzugefügt wurden.  Sie unterscheiden sich in Konfiguration und Leistung (der Cluster ist nicht homogen).  Unser Balancer berücksichtigt dies ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> ) und lädt die Maschinen entsprechend ihrer Fähigkeiten.  Um diesen Prozess zu steuern, haben wir auch einen Zeitplan für maximal und minimal geladene Maschinen. <br><br><img src="https://habrastorage.org/webt/nf/we/f7/nfwef7cixau-uxenwsglrnvfzho.png"><br>  <i>Die am meisten und am wenigsten belasteten Cluster-Computer</i> <br><br>  Wenn Sie sich diese Diagramme (oder nur die Ausgabe des Befehls top) ansehen und die CPU-Auslastung von 50% sehen, denken Sie, dass wir noch einen Spielraum für eine zweifache Erhöhung der Auslastung haben.  Tatsächlich ist dies jedoch normalerweise nicht der Fall.  Und hier ist warum. <br><br><h1>  Hyper-Threading </h1><br>  Stellen Sie sich einen einzelnen Kern ohne Hypertreading vor.  Wir laden es mit einem CPU-gebundenen Thread.  Oben wird 100% geladen. <br><br>  Aktivieren Sie nun das Hyperlesen auf diesem Kernel und laden Sie es genauso.  Oben sehen wir bereits zwei logische Kerne, und die Gesamtlast beträgt 50% (normalerweise auf einem 0% und auf dem anderen 100%). <br><br><img src="https://habrastorage.org/webt/gr/zi/hw/grzihwfkj986zatrfrsrgg4-ykk.png"><br>  <i>CPU-Auslastung: Top-Daten und was wirklich passiert</i> <br><br>  Als ob der Prozessor nur zu 50% ausgelastet wäre.  Aber physikalisch erschien kein zusätzlicher freier Kern.  Hypertreading ermöglicht <i>in einigen Fällen</i> die gleichzeitige Ausführung von mehr als einem Prozess auf einem physischen Kern.  Dies ist jedoch weit davon entfernt, die Leistung in typischen Situationen zu verdoppeln, obwohl es im Diagramm zur CPU-Auslastung wie die Hälfte der Ressourcen aussieht: von 50% auf 100%. <br><br>  Dies bedeutet, dass nach 50% der CPU-Auslastung, wenn Hypertreading aktiviert ist, es nicht mehr so ​​wächst wie zuvor. <br><br>  Ich habe diesen Code geschrieben, um zu demonstrieren (dies ist eine Art synthetischer Fall, in Wirklichkeit werden die Ergebnisse unterschiedlich sein): <br><br><div class="spoiler">  <b class="spoiler_title">Skriptcode</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $concurrency = $_SERVER[<span class="hljs-string"><span class="hljs-string">'argv'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ?? <span class="hljs-number"><span class="hljs-number">1</span></span>; $hashes = <span class="hljs-number"><span class="hljs-number">100000000</span></span>; $chunkSize = intval($hashes / $concurrency); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $children = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $concurrency; $i++) {    $pid = pcntl_fork();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> === $pid) {        $first = $i * $chunkSize;        $last = ($i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * $chunkSize - <span class="hljs-number"><span class="hljs-number">1</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = $first; $j &lt; $last; $j++) {            $dummy = md5($j);        }        printf(<span class="hljs-string"><span class="hljs-string">"[%d]: %d hashes in %0.4f sec\n"</span></span>, $i, $last - $first, microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1);        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        $children[$pid] = <span class="hljs-number"><span class="hljs-number">1</span></span>;    } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count($children) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    $pid = pcntl_waitpid(<span class="hljs-number"><span class="hljs-number">-1</span></span>, $status);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($children[$pid]);    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a error pid=$pid"</span></span>);    } }</code> </pre> <br><br></div></div><br>  Ich habe zwei physische Kerne auf meinem Laptop.  Führen Sie diesen Code mit unterschiedlichen Eingabedaten aus, um seine Leistung mit einer unterschiedlichen Anzahl paralleler C-Prozesse zu messen. <br><br><div class="spoiler">  <b class="spoiler_title">Messergebnisse</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/n5/3z/ev/n53zevyyvda4w4u-2xkjryqlj9m.png"><br></div></div><br>  Wir zeichnen die Ergebnisse der Starts auf: <br><img src="https://habrastorage.org/webt/xg/iv/rn/xgivrnyyynb418fnr5muqfn0qba.png"><br>  <i>Skriptleistung abhängig von der Anzahl der parallelen Prozesse</i> <br><br>  Worauf Sie achten können: <br><br><ul><li>  C = 1 und C = 2 sind vorhersehbar gleich für HT = Ein und HT = Aus. Die Leistung verdoppelt sich, wenn ein physischer Kern hinzugefügt wird. <br></li></ul><br><ul><li>  Bei C = 3 machen sich die Vorteile von HT bemerkbar: Bei HT = Ein konnten wir zusätzliche Leistung erzielen, während bei HT = Aus ab C = 3 die Vorhersage vorhersehbar langsam abnimmt. <br></li></ul><br><ul><li>  bei C = 4 sehen wir alle Vorteile von HT;  Wir konnten weitere 30% der Produktivität herausholen, aber im Vergleich zu C = 2 zu diesem Zeitpunkt stieg die CPU-Auslastung von 50% auf 100%. <br></li></ul><br>  Insgesamt erhalten wir bei der Ausführung dieses Skripts in den oberen 50% der CPU-Auslastung 8.065 Mhash / Sek. Und bei 100% - 10.511 Mhash / Sek.  Dies bedeutet, dass wir bei etwa 50% der Spitze 8,065 / 10,511 ~ 77% der maximalen Systemleistung erhalten und tatsächlich noch etwa 100% in der Reserve verbleiben - 77% = 23% und nicht 50%, wie es scheint. <br><br>  Diese Tatsache muss bei der Planung berücksichtigt werden. <br><br><img src="https://habrastorage.org/webt/ru/6g/00/ru6g002t0ziv1pkppgqfjber80o.png"><br>  <i>CPU-Auslastung für Demoscript: Top-Daten und was wirklich passiert</i> <br><br><h1>  Verkehrsinkonsistenz </h1><br>  Neben dem Hypertreading erschwert die Planung auch die Unebenheiten des Verkehrs in Abhängigkeit von Tageszeit, Wochentag, Jahreszeit und anderer Häufigkeit.  Für uns ist der Höhepunkt zum Beispiel Sonntagabend. <br><br><img src="https://habrastorage.org/webt/eh/ks/58/ehks58pfn7sjva3c869i7cwj7fy.png"><br>  <i>Anzahl der Anfragen pro Sekunde, Spitzen-Sonntagabend</i> <br><br>  Nicht immer ändert sich die Anzahl der Anfragen auf offensichtliche Weise.  Zum Beispiel können Benutzer irgendwie mit anderen Benutzern interagieren: Die Aktivität einiger kann Push / E-Mail an andere generieren und sie somit in den Prozess einbeziehen.  Hinzu kommen Werbekampagnen, die den Traffic erhöhen und auf die Sie ebenfalls vorbereitet sein müssen. <br><br>  All dies ist auch bei der Planung zu berücksichtigen: Zum Beispiel, um einen Trend nach Spitzentagen aufzubauen und die mögliche Nichtlinearität des Spitzenwachstums zu berücksichtigen. <br><br><h1>  Profilierungs- und Messwerkzeuge </h1><br>  Angenommen, wir stellen fest, dass es Leistungsprobleme gibt, verstehen, dass dies nicht die Datenbank / die Dienste / das Zeug ist, und haben uns dennoch entschlossen, den Code zu optimieren.  Dazu benötigen wir zunächst einen Profiler oder einige Tools, um Engpässe zu finden und anschließend die Ergebnisse unserer Optimierungen anzuzeigen. <br><br>  Leider gibt es für PHP heute kein gutes universelles Tool. <br><br><h2>  perf </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">perf</a> ist ein Profiling-Tool, das in den Linux-Kernel integriert ist.  Es handelt sich um einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stichprobenprofiler</a> , der von einem separaten Prozess gestartet wird. Daher wird dem zu profilierenden Programm kein direkter Overhead hinzugefügt.  Indirekt hinzugefügter Overhead wird gleichmäßig „verschmiert“, sodass die Messungen nicht verzerrt werden. <br><br>  Trotz all seiner Vorteile kann perf nur mit kompiliertem Code und mit JIT arbeiten und nicht mit Code, der "unter einer virtuellen Maschine" ausgeführt wird.  Daher kann der PHP-Code selbst nicht profiliert werden, aber Sie können deutlich sehen, wie PHP im Inneren funktioniert, einschließlich verschiedener PHP-Erweiterungen, und wie viel Ressourcen dafür aufgewendet werden. <br><br>  Zum Beispiel haben wir bei perf mehrere Engpässe festgestellt, einschließlich einer Komprimierungsstelle, auf die ich weiter unten eingehen werde. <br><br>  Ein Beispiel: <br><br> <code>perf record --call-graph dwarf,65528 -F 99 -p $(pgrep php-cgi | paste -sd "," -) -- sleep 20 <br> perf report</code> <br> <br>  (Wenn der Prozess und perf unter verschiedenen Benutzern ausgeführt werden, muss perf unter sudo ausgeführt werden.) <br><br><img src="https://habrastorage.org/webt/k9/vu/k6/k9vuk6sf37xhshipgvx2byw3xps.png"><br>  <i>Beispiel für die Ausgabe eines Perf-Berichts für PHP-FPM</i> <br><br><h2>  XHProf und XHProf Aggregator </h2><br>  XHProf ist eine Erweiterung für PHP, die Timer um alle Aufrufe von Funktionen / Methoden platziert und Tools zur Visualisierung der so erhaltenen Ergebnisse enthält.  Im Gegensatz zu perf können Sie damit mit PHP-Code arbeiten (gleichzeitig ist nicht sichtbar, was in den Erweiterungen passiert). <br><br>  Die Nachteile umfassen zwei Dinge: <br><br><ul><li>  Alle Messungen werden im Rahmen einer einzigen Anfrage gesammelt, daher liefern sie keine Informationen über das Gesamtbild. <br></li><li>  Der Overhead ist zwar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht so groß</a> wie beispielsweise bei Verwendung von Xdebug, aber er ist und in einigen Fällen sind die Ergebnisse stark verzerrt (je öfter eine Funktion aufgerufen wird und je einfacher sie ist, desto größer ist die Verzerrung). <br></li></ul><br>  Hier ist ein Beispiel, das den letzten Punkt veranschaulicht: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ child1(); child2(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; $i++) { parent1(); }</code> </pre> <br><img src="https://habrastorage.org/webt/iw/7m/y6/iw7my6irzq5xg7_soy7sfkqpj7m.png"><br>  <i>XHProf-Ausgabe für Demos: parent1 ist um Größenordnungen größer als die Summe von child1 und child2</i> <br><br>  Es ist ersichtlich, dass parent1 () ~ 500-mal länger ausgeführt wurde als child1 () + child2 (), obwohl diese Zahlen in Wirklichkeit ungefähr gleich sein sollten, ebenso wie main () und parent1 (). <br><br>  Wenn der letzte Nachteil schwer zu bekämpfen ist, haben wir zur Bekämpfung des ersten einen Zusatz für XHProf erstellt, der die Profile verschiedener Anforderungen aggregiert und aggregierte Daten visualisiert. <br><br>  Neben XHProf gibt es viele andere weniger bekannte Profiler, die nach einem ähnlichen Prinzip arbeiten.  Sie haben ähnliche Vor- und Nachteile. <br><br><h2>  Pinba </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit Pinba</a> können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Leistung anhand von</a> Skripten (Aktionen) und voreingestellten Timern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">überwachen</a> .  Alle Messungen im Rahmen von Skripten werden sofort durchgeführt, hierfür sind keine zusätzlichen Schritte erforderlich.  Für jedes Skript und jeden Timer wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getrusage ausgeführt</a> , sodass wir genau wissen, wie viel Prozessorzeit für einen bestimmten Code aufgewendet wurde (im Gegensatz zu Stichprobenprofilern, bei denen sich diese Zeit möglicherweise als Netzwerk, Festplatte usw. herausstellt).  Pinba eignet sich hervorragend zum Speichern historischer Daten und zum Abrufen eines Bildes im Allgemeinen und innerhalb bestimmter Arten von Abfragen. <br><br><img src="https://habrastorage.org/webt/od/x5/qr/odx5qryl0ufhceiuyjkytjhtm0c.png"><br>  <i>Die allgemeine Auswahl aller von Pinba erhaltenen Skripte</i> <br><br>  Zu den Nachteilen gehören die Tatsache, dass Timer, die bestimmte Abschnitte des Codes und nicht die gesamten Skripte profilieren, im Voraus im Code angeordnet werden müssen, sowie das Vorhandensein eines Overheads, der (wie in XHProf) Daten verzerren kann. <br><br><h2>  phpspy </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phpspy</a> ist ein relativ neues Projekt (das erste Commit auf GitHub war vor einem halben Jahr), das vielversprechend aussieht, daher beobachten wir es genau. <br><br>  Aus Sicht des Benutzers ähnelt phpspy perf: Es wird ein paralleler Prozess gestartet, der die Speicherteile des PHP-Prozesses regelmäßig kopiert, analysiert und von dort Stapelspuren und andere Daten empfängt.  Dies geschieht auf eine ziemlich spezifische Art und Weise.  Um den Overhead zu minimieren, stoppt phpspy den PHP-Prozess nicht und kopiert den Speicher direkt, während er ausgeführt wird.  Dies führt dazu, dass der Profiler einen inkonsistenten Status erhalten kann und Stapelspuren beschädigt werden können.  Aber phpspy kann dies erkennen und solche Daten verwerfen. <br><br>  Mit diesem Tool können künftig sowohl Daten zum Gesamtbild als auch Profile bestimmter Abfragetypen erfasst werden. <br><br><h2>  Vergleichstabelle </h2><br>  Um die Unterschiede zwischen den Werkzeugen zu strukturieren, erstellen wir eine Pivot-Tabelle: <br><br><img src="https://habrastorage.org/webt/bg/1a/bt/bg1abtxk-f8i5q83qm5teok3lbs.png"><br>  <i>Vergleich der Hauptmerkmale von Profilern</i> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flammengraphen</a></i> <br><br><h1>  Optimierung und Ansätze </h1><br>  Mit diesen Tools überwachen wir ständig die Leistung und Nutzung unserer Ressourcen.  Wenn sie ungerechtfertigt verwendet werden oder wir uns dem Schwellenwert nähern (für die CPU haben wir empirisch einen Wert von 55% gewählt, um im Falle eines Wachstums eine Zeitspanne zu haben), wie ich oben geschrieben habe, ist eine der Lösungen für das Problem die Optimierung. <br><br>  Nun, wenn die Optimierung bereits von jemand anderem durchgeführt wurde, wie dies bei PHP 7.0 der Fall war, stellte sich heraus, dass diese Version viel produktiver war als die vorherigen.  Wir versuchen im Allgemeinen, moderne Technologien und Tools zu verwenden, einschließlich zeitnaher Updates auf die neuesten Versionen von PHP.  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">öffentlichen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmarks</a> ist PHP 7.2 5-12% schneller als PHP 7.1.  Aber dieser Übergang gab uns leider viel weniger. <br><br>  Für die ganze Zeit haben wir eine Vielzahl von Optimierungen implementiert.  Leider hängen die meisten von ihnen stark mit unserer Geschäftslogik zusammen.  Ich werde über diejenigen sprechen, die nicht nur für uns relevant sein können, oder über Ideen und Ansätze, die außerhalb unseres Codes verwendet werden können. <br><br><h2>  Zlib-Komprimierung =&gt; zstd </h2><br>  Wir verwenden die Komprimierung für große Memkey-Schlüssel.  Dies ermöglicht es uns, drei- bis viermal weniger Speicher für Speicher zu verwenden, da zusätzliche CPU-Kosten für die Komprimierung / Dekomprimierung anfallen.  Wir haben dafür zlib verwendet (unsere Erweiterung für die Arbeit mit Memekes unterscheidet sich von der mit PHP, aber offizielle verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch</a> zlib). <br><br>  In der Perfektion war die Produktion ungefähr so: <br><br> <code>+    4.03%     0.22% php-cgi  libz.so.1.2.11      [.] inflate <br> +    3.38%     0.00% php-cgi  libz.so.1.2.11      [.] deflate</code> <br> <br>  7-8% der Zeit wurden für die Komprimierung / Dekomprimierung aufgewendet. <br><br>  Wir haben uns entschlossen, verschiedene Ebenen und Komprimierungsalgorithmen zu testen.  Es stellte sich heraus, dass zstd auf unseren Daten fast zehnmal schneller läuft und ~ 1,1-mal an Ort und Stelle verliert.  Eine ziemlich einfache Änderung des Algorithmus hat uns ~ 7,5% CPU gespart (dies entspricht, wie ich mich erinnere, auf unseren Volumes ~ 45 Servern). <br><br>  Es ist wichtig zu verstehen, dass das Verhältnis der Leistung verschiedener Komprimierungsalgorithmen in Abhängigkeit von den Eingabedaten stark variieren kann.  Es gibt verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleiche</a> , aber am genauesten kann dies nur anhand von Beispielen aus der Praxis geschätzt werden. <br><br><h2>  IS_ARRAY_IMMUTABLE als Repository selten geänderter Daten </h2><br>  Wenn Sie mit realen Aufgaben arbeiten, müssen Sie mit solchen Daten umgehen, die Sie häufig benötigen und gleichzeitig selten ändern und eine begrenzte Größe haben.  Wir haben viele ähnliche Daten, ein gutes Beispiel ist die Konfiguration von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Split-Tests</a> .  Wir prüfen, ob der Benutzer unter die Bedingungen eines bestimmten Tests fällt, und zeigen ihm abhängig davon experimentelle oder normale Funktionen (dies geschieht fast bei jeder Anforderung).  In anderen Projekten können Konfigurationen und verschiedene Verzeichnisse ein Beispiel sein: Länder, Städte, Sprachen, Kategorien, Marken usw. <br><br>  Da solche Daten häufig angefordert werden, kann ihr Empfang sowohl für die Anwendung selbst als auch für den Dienst, in dem diese Daten gespeichert sind, eine spürbare zusätzliche Belastung darstellen.  Das letztere Problem kann beispielsweise mit APCu gelöst werden, das den Speicher desselben Computers verwendet, auf dem PHP-FPM als Speicher ausgeführt wird.  Aber auch dann: <br><br><ul><li>  Es fallen Serialisierungs- / Deserialisierungskosten an. <br></li><li>  Sie müssen die Daten beim Ändern irgendwie ungültig machen. <br></li><li>  Es gibt einen gewissen Overhead im Vergleich zum Zugriff auf nur eine Variable in PHP. <br></li></ul><br>  PHP 7.0 führt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IS_ARRAY_IMMUTABLE-</a> Optimierung ein.  Wenn Sie ein Array deklarieren, dessen Elemente zum Zeitpunkt der Kompilierung bekannt sind, wird es einmal verarbeitet und in den OPCache-Speicher gestellt. PHP-FPM-Mitarbeiter verweisen auf diesen gemeinsam genutzten Speicher, ohne ihre Zeit zu verbringen, bevor sie versuchen, Änderungen vorzunehmen.  Daraus folgt auch, dass das Einschließen eines solchen Arrays unabhängig von der Größe eine konstante Zeit benötigt (normalerweise ~ 1 Mikrosekunde). <br><br>  Zum Vergleich: Ein Beispiel für die Zeit, um ein Array mit 10.000 Elementen über include und apcu_fetch abzurufen: <br><br><pre> <code class="php hljs">$t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'test-incl-1.php'</span></span>; $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"include (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); $t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = apcu_fetch(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"apcu_fetch (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//include (10000): 1 microsec //apcu_fetch (10000): 792 microsec</span></span></code> </pre><br>  Die Überprüfung, ob diese Optimierung angewendet wurde, kann sehr einfach sein, wenn Sie sich die generierten Opcodes ansehen: <br><br><pre> <code class="php hljs">$ cat immutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val1'</span></span>, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ cat mutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; \SomeClass::CONST_1, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ php -d opcache.enable=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> immutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">1</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">0</span></span>) ; (after optimizer) ; /home/ubuntu/immutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(...) $ php -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> mutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">5</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">2</span></span>) ; (after optimizer) ; /home/ubuntu/mutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T1 = FETCH_CLASS_CONSTANT string(<span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"CONST_1"</span></span>) L1 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T0 = INIT_ARRAY <span class="hljs-number"><span class="hljs-number">3</span></span> T1 string(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) L2 (<span class="hljs-number"><span class="hljs-number">5</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val2"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>) L3 (<span class="hljs-number"><span class="hljs-number">6</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>) L4 (<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T0</code> </pre><br>  Im ersten Fall ist klar, dass die Datei nur einen Opcode enthält - die Rückgabe des fertigen Arrays.  Im zweiten Fall erfolgt die Element-für-Element-Bildung jedes Mal, wenn diese Datei ausgeführt wird. <br><br>  Somit ist es möglich, Strukturen in einer Form zu generieren, die keine weitere Transformation zur Laufzeit erfordert.  Anstatt beispielsweise die Klassennamen jedes Mal für das automatische Laden durch die Zeichen "_" und "\" zu zerlegen, können Sie die Korrespondenzzuordnung "Klasse =&gt; Pfad" vorab generieren.  In diesem Fall wird die Konvertierungsfunktion auf einen einzelnen Hash-Tabellenaufruf reduziert.  Composer führt diese Art der Optimierung durch, wenn Sie die <a href="">Option "Autoloader optimieren"</a> aktivieren. <br><br>  Für die Ungültigmachung solcher Daten müssen Sie nichts Spezielles tun. PHP selbst kompiliert die Datei beim Ändern neu, genau wie bei einer normalen Codebereitstellung.  Der einzige Nachteil, den Sie nicht vergessen dürfen: Wenn die Datei sehr groß ist, führt die erste Anforderung nach dem Ändern zu einer Neukompilierung, die eine spürbare Zeit in Anspruch nehmen kann. <br><br><h2>  Leistung umfassen / erfordern </h2><br>  Im Gegensatz zum statischen Array-Beispiel ist das Anhängen von Dateien mit Klassen- und Funktionsdeklarationen nicht so schnell.  Trotz des Vorhandenseins von OPCache muss die PHP-Engine sie in den Prozessspeicher kopieren und Abhängigkeiten rekursiv verbinden, was am Ende Hunderte von Mikrosekunden oder sogar Millisekunden pro Datei dauern kann. <br><br>  Wenn Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symfony 4.1</a> ein neues leeres Projekt erstellen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">get_included_files () als</a> erste Zeile in die Aktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfügen</a> , sehen Sie, dass bereits 310 Dateien verbunden sind.  In einem realen Projekt kann diese Anzahl Tausende pro Anfrage erreichen.  Es lohnt sich, auf folgende Dinge zu achten. <br><br>  <b>Fehlende automatische Ladefunktionen</b> <br><br>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function Autoloading RFC</a> , aber seit einigen Jahren ist keine Entwicklung mehr zu beobachten.  Wenn eine Abhängigkeit in Composer Funktionen außerhalb der Klasse definiert und diese Funktionen für den Benutzer zugänglich sein sollten, erfolgt dies durch <a href="">obligatorisches Verbinden einer</a> Datei mit diesen Funktionen mit jeder Initialisierung des Autoloaders. <br><br>  Wenn Sie beispielsweise eine der Abhängigkeiten aus composer.json entfernen, die viele Funktionen deklariert und leicht durch hundert Codezeilen ersetzt werden kann, haben wir ein paar Prozent der CPU gewonnen. <br><br>  <b>Der Auto-Loader wird häufiger aufgerufen, als es den Anschein hat.</b> <br><br>  Erstellen Sie eine solche Datei mit einer Klasse, um die Idee zu demonstrieren: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">D</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC1 = \E::E1;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC2 = \F::F1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as3 = \G::G1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as4 = \H::H1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a5 = \I::I1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a6 = \J::J1;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\K $k = null)</span></span></span><span class="hljs-function"> </span></span>{}   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\L $l = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\M $m = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\N $n = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\P $p = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>Auto-Loader registrieren:</b> <br><br><pre> <code class="php hljs">spl_autoload_register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Including $name...\n"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"$name.php"</span></span>; });</code> </pre> <br>  <b>Und wir werden mehrere Anwendungsfälle für diese Klasse machen:</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'A.php'</span></span> Including B... Including D... Including C... \A::AC1 Including A... Including B... Including D... Including C... Including E... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A() Including A... Including B... Including D... Including C... Including E... Including F... Including G... Including H... Including I... Including J...</code> </pre><br>  Möglicherweise stellen Sie fest, dass, wenn wir die Klasse nur irgendwie verbinden, aber ihre Instanz nicht erstellen, die übergeordneten Elemente, Schnittstellen und Merkmale miteinander verbunden werden.  Dies erfolgt rekursiv für alle Dateien, die als Auflösungen verbunden sind. <br><br>  Beim Erstellen einer Instanz wird die Auflösung aller Konstanten und Felder hinzugefügt, was zur Verbindung aller dafür erforderlichen Dateien führt, was wiederum auch die rekursive Verbindung von Merkmalen, Eltern und Schnittstellen der neu verbundenen Klassen bewirkt. <br><br><img src="https://habrastorage.org/webt/8a/qq/2t/8aqq2tf_8j-mixi8p_ydoypo-yo.png"><br>  <i>Verbinden verwandter Klassen für den Instanzerstellungsprozess und andere Fälle</i> <br><br>  Es gibt keine universelle Lösung für dieses Problem. Sie müssen nur daran denken und die Verbindungen zwischen Klassen überwachen: Eine Zeile kann die Verbindung von Hunderten von Dateien herstellen. <br><br>  <b>OPCache-Einstellungen</b> <br><br>  Wenn Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">atomare Bereitstellungsmethode</a> verwenden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">indem Sie den</a> von Rasmus Lerdorf, dem Ersteller von PHP, vorgeschlagenen Symlink ändern, müssen Sie opcache.revalidate_path einschließen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um das</a> Problem des "Festhaltens" des Symlinks an der alten Version zu lösen, wie beispielsweise in diesem von Mail übersetzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über OPCache empfohlen .Ru Group. <br><br>  Das Problem ist, dass diese Option die Zeit für das Einschließen jeder Datei erheblich verlängert (durchschnittlich eineinhalb bis zwei Mal).  Insgesamt kann dies eine erhebliche Menge an Ressourcen verbrauchen (in unserem Fall ergab das Deaktivieren dieser Option einen Gewinn von 7–9%). <br><br>  Um es zu deaktivieren, müssen Sie zwei Dinge tun: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie den</a> Webserver Symlinks auflösen. <br></li><li>  Beenden Sie die Verbindung von Dateien innerhalb des PHP-Skripts entlang der Pfade, die Symlinks enthalten, oder erzwingen Sie sie über readlink () oder realpath (). <br></li></ul><br>  Wenn alle Dateien mit dem Composer-Autoloader verbunden sind, wird das zweite Element automatisch ausgeführt, nachdem das erste abgeschlossen ist: composer verwendet die Konstante __DIR__, die korrekt aufgelöst wird. <br><br>  OPCache bietet einige weitere Optionen, die im Austausch für Flexibilität zu einer Leistungssteigerung führen können.  Sie können mehr darüber in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> lesen, den ich oben erwähnt habe. <br><br>  Trotz all dieser Optimierungen ist include immer noch nicht kostenlos.  Um dem entgegenzuwirken, plant PHP 7.4 das Hinzufügen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preload</a> . <br><br><h2>  APCu-Sperre </h2><br>  Obwohl es sich hier nicht um Datenbanken und Dienste handelt, können im Code auch verschiedene Arten von Sperren auftreten, die die Ausführungszeit des Skripts verlängern. <br><br>  Als die Anfragen wuchsen, stellten wir zu Spitzenzeiten eine starke Verlangsamung der Reaktion fest.  Nachdem die Gründe herausgefunden wurden, stellte sich heraus, dass APCu zwar der schnellste Weg ist, um Daten zu erhalten (im Vergleich zu Memcache, Redis und anderen externen Speichern), aber auch langsam arbeiten kann, wenn dieselben Schlüssel häufig überschrieben werden. <br><br><img src="https://habrastorage.org/webt/hs/05/gc/hs05gcwvqozrqews1ewwtsskdyo.png"><br>  <i>Anzahl der Anfragen pro Sekunde und Laufzeit: Spitzenwerte am 16. und 17. Oktober</i> <br><br>  Bei Verwendung von APCu als Cache ist dieses Problem nicht so relevant, da das Caching normalerweise seltenes Schreiben und häufiges Lesen umfasst.  Einige Aufgaben und Algorithmen (z. B. Leistungsschalter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung in PHP</a> )) beinhalten jedoch auch häufige Aufzeichnungen, die zu Sperren führen. <br><br>  Es gibt keine universelle Lösung für dieses Problem, aber im Fall von Leistungsschaltern kann es beispielsweise gelöst werden, indem es in einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Dienst gestellt wird</a> , der auf Computern mit PHP installiert ist. <br><br><h2>  Stapelverarbeitung </h2><br>  Selbst wenn Sie include nicht berücksichtigen, wird in der Regel trotzdem ein erheblicher Teil der Ausführungszeit für die Initialisierung für die Initialisierung aufgewendet: ein Framework (z. B. Erstellen eines DI-Containers und Initialisieren aller Abhängigkeiten, Routing, Ausführen aller Listener), Auslösen der Sitzung, des Benutzers usw. weiter. <br><br>  Wenn Ihr Backend eine interne API für etwas ist, können einige Anforderungen auf Clients gebündelt und als einzelne Anforderung gesendet werden.  In diesem Fall wird die Initialisierung für mehrere Anforderungen einmal durchgeführt. <br><br>      ,   ,    .    -  ,          .       . <br><br><h2>    </h2><br>    Badoo   ,     .    PHP-FPM,      CPU,   ,            ,    :        IO, CPU  . <br><br>      PHP-FPM    —  ,          PHP. <br><br>         (CPU, IO),    . , ,       ,  ,    -     ,        .        ,     .   ,  ,      . <br><br><h1>  Fazit </h1><br>        .                    PHP     . <br><br>  : <br><br><ul><li>       ; <br></li><li>     ; <br></li><li>  -  ,  :  ,    ; <br></li><li>   :       (, ,  ); <br></li><li>    :     ; <br></li><li>   , OPCache    PHP,  , ,   ; <br></li><li>    :       (, ,   PHP 7.2   ,   ); <br></li><li>    : ,        . <br></li></ul><br>       ? <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430722/">https://habr.com/ru/post/de430722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430710/index.html">Was tun, wenn der Schwarze Freitag morgen ist und Ihre Server nicht bereit sind?</a></li>
<li><a href="../de430712/index.html">NeurIPS: Wie man die beste ML-Konferenz erobert</a></li>
<li><a href="../de430714/index.html">VMware kauft Heptio - was bedeutet das für Kubernetes?</a></li>
<li><a href="../de430718/index.html">Für welche Objekte lohnt sich die Cloud-Videoüberwachung?</a></li>
<li><a href="../de430720/index.html">Intel RealSense D435i: kleines Update und kurzer historischer Exkurs</a></li>
<li><a href="../de430724/index.html">DEFCON 21. DNS-Konferenzen können gesundheitsschädlich sein. Teil 1</a></li>
<li><a href="../de430728/index.html">Lehre mich, Feedback zu geben</a></li>
<li><a href="../de430730/index.html">Was macht F & E ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../de430732/index.html">Zur Frage der Teilung und TI</a></li>
<li><a href="../de430734/index.html">Intelligente Updates im Vergleich zu intelligenten Verträgen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>