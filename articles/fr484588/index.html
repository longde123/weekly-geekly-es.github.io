<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèΩ ü§¶üèº üåø Mod√®le de gestion de programme automatis√© üåí ü¶í üÖøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 Dans [1], une r√©ponse a √©t√© donn√©e √† la question de ce qui est consid√©r√© comme une programmation automatique (AP), mais le mod√®le d'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®le de gestion de programme automatis√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1. Introduction </h3><br>  Dans [1], une r√©ponse a √©t√© donn√©e √† la question de ce qui est consid√©r√© comme une programmation automatique (AP), mais le mod√®le d'une machine √† √©tats finis (SC) n'a pas √©t√© d√©crit en d√©tail comme un mod√®le de contr√¥le des programmes automatiques.  Il est clair qu‚Äôun automate abstrait pur ne convient pas √† ce r√¥le, car  limit√© par le nombre de canaux.  Mais le mod√®le structurel de l'automate, ainsi que la th√©orie des automates structuraux qui lui correspondent, ne permettent pas encore de donner une r√©ponse sur le choix du mod√®le de l'automate. <br><br>  Le probl√®me commence par le fait que parmi les nombreux travaux sur la th√©orie des automates finis (TCA), rares sont ceux qui donnent une d√©finition du mod√®le d'un automate fini structurel (SCA).  Certes, on peut comprendre qu'un automate structurel est un diagramme [structurel] d'automates √©l√©mentaires (√©l√©ments fonctionnels) qui impl√©mente un mod√®le d'automate abstrait [2].  Rappelons que, conform√©ment √† la th√©orie, tout commence par la cr√©ation d'un mod√®le d'appareil sous la forme d'un automate abstrait, puis la t√¢che est de synth√©tiser un circuit num√©rique qui le met en ≈ìuvre [3]. <br><br>  La programmation √† premi√®re vue ressemble un peu √† une synth√®se de circuits num√©riques.  Mais seulement au d√©but.  Tout d'abord, √ßa et l√† tout commence par un algorithme.  Deuxi√®mement, les probl√®mes structurels d'organisation et de mise en ≈ìuvre des circuits et de la programmation num√©riques ont beaucoup en commun, en particulier dans le contexte de la programmation parall√®le.  Mais nous aborderons s√©par√©ment le sujet du parall√©lisme.  En attendant, notre t√¢che consiste √† choisir et / ou modifier le mod√®le d'une machine √† √©tats finis, ce qui serait compr√©hensible, pratique et agr√©able pour les programmeurs g√¢t√©s par divers outils logiciels. <br><br>  Certes, la question est imm√©diatement logique - pourquoi une ¬´bo√Æte √† outils automatique¬ª de plus et plut√¥t inhabituelle?  Nous allons essayer de r√©pondre √† cette question en d√©finissant un mod√®le de contr√¥le automatique [imbriqu√©], consid√©rant √©galement ses avantages par rapport au mod√®le de programmation habituel. <br><a name="habracut"></a><br><h3>  2. D√©finition du mod√®le de contr√¥le des programmes automatiques </h3><br>  En cours d'√©volution, la pratique de la programmation a form√© certaines exigences pour le mod√®le de gestion de programme.  Il faut reconna√Ætre que le mod√®le d'une machine √† √©tats finis classique leur correspond plut√¥t peu.  Et si la t√¢che consiste √† utiliser des automates dans la programmation, il doit √™tre adapt√©.  Il est souhaitable de le faire dans le cadre de la th√©orie des automates.  Les principales pr√©tentions au PA existant sont r√©duites au fait que cette condition est viol√©e. <br><br>  <i>D√©finition 1.</i> Nous appelons la <i>forme normale disjonctive des automates finis (DNKA)</i> des automates finis enti√®rement d√©finis dont les transitions sont √©tiquet√©es par des conjonctions √©l√©mentaires de variables logiques. <br><br>  Le mod√®le d'ADN est bas√© sur des mod√®les formels d' <i>automates</i> enti√®rement (enti√®rement) d√©finis <i>avec un √©tat abstrait</i> [4] et <i>des automates logiques</i> [5]. <br><br>  <i>D√©finition 2.</i> Nous appelons la <i>forme disjonctive d'un automate fini (DFA) un</i> automate sous la forme d'un DFA ne contenant que des <i>transitions r√©sultantes</i> . <br><br>  Les transitions marqu√©es avec des signaux de sortie et les transitions avec un tiret √† la place des signaux de sortie qui changent l'√©tat actuel de l'automate sont class√©es comme transitions effectives.  Les transitions qui ne sont pas incluses dans la description de l'automate disjonctif constituent un <i>ajout du DKA (DDA)</i> √† l'automate DFA enti√®rement d√©fini.  Un tel ajout est un automate compos√© d'√©tats isol√©s avec des transitions sous forme de boucles et des tirets √† la place des signaux de sortie. <br><br><h3>  3. Le mod√®le de m√©moire pour le mod√®le de calcul AP </h3><br>  La pr√©sence de nombreuses entr√©es et sorties du DFA d√©finit le parall√©lisme des op√©rateurs / fonctions logicielles qui lui sont associ√©s.  Pour sa mise en ≈ìuvre correcte, un mod√®le de m√©moire de type CREW (lecture simultan√©e exclusive - √©criture) est requis [6].  Dans son cadre, la lecture des valeurs de donn√©es actuelles est autoris√©e de la part de l'ensemble de toutes les fonctions (pr√©dicats et actions), et une seule d'entre elles est autoris√©e √† modifier <i>les donn√©es g√©n√©rales</i> pour les actions ex√©cutables parall√®les. <br><br>  Le mod√®le de contr√¥le automatique, contrairement au mod√®le informatique multithread, limite clairement l'ex√©cution des op√©rateurs / fonctions du programme automatique aux limites d'un cycle temporel discret.  Dans une telle situation, toute modification de la m√©moire par des actions effectu√©es sur le cycle d'horloge en cours peut √™tre √©crite dans la <i>¬´m√©moire fant√¥me¬ª</i> , de sorte qu'apr√®s leur ach√®vement et avant le d√©but du cycle d'horloge discret suivant, elle devienne ses nouvelles valeurs. <br><br>  L'interaction des op√©rateurs de programme d'automate avec la m√©moire sera appel√©e <i>mod√®le de m√©moire fant√¥me</i> .  Ce mod√®le est une partie essentielle du mod√®le g√©n√©ral de programmation automatique.  Il garantit l'exactitude du fonctionnement parall√®le des op√©rateurs AP et simplifie la programmation des processus parall√®les. <br><br>  Dans le cadre du mod√®le de m√©moire, des m√©canismes complexes et peu fiables de synchronisation multithread des processus ne sont en fait pas n√©cessaires (pour plus de d√©tails voir [7]).  Mais si n√©cessaire, en raison de l'√©quivalence des automates et <i>des sch√©mas d'algorithmes (GAW)</i> [8], le mod√®le de programmation automatique ne limite pas leur application. <br><br><h3>  4. Mod√®les imbriqu√©s et inertiels d'automates </h3><br>  La t√¢che de cr√©er un mod√®le de l'√©l√©ment logique du retard, choisi plus loin √† titre d'exemple, d'une part, d√©montre les probl√®mes du mod√®le classique de l'automate et, d'autre part, refl√®te les qualit√©s du mod√®le DFA qui r√©sout les probl√®mes algorithmiques avec des moyens plus visuels et pratiques.  Le mod√®le introduit d'automates imbriqu√©s g√©n√®re une sous-classe de mod√®les d'automates, ci-apr√®s d√©nomm√©s <i>automates inertiels</i> , et une sous-classe correspondante d' <i>algorithmes inertiels</i> . <br><br>  Alors, que ce soit la t√¢che de cr√©er un mod√®le discret d'un √©l√©ment logique √† retard qui impl√©mente la transmission d'un signal d'entr√©e binaire.  De plus, les instants de ses retards t01 et t10, respectivement, aux √©tats unitaire et z√©ro dans le cas g√©n√©ral ne co√Øncident pas. <br><br>  Le mod√®le le plus simple d'un <i>seul retard</i> sous la forme d'un automate Mealy est illustr√© √† la Fig.  1 (voir, pour comparaison, le mod√®le de retard dans [2]).  Ses retards sont d√©termin√©s par un seul cycle d'horloge discret.  Des mod√®les plus complexes de retards de <i>transport</i> (pour plus de d√©tails sur les types de retards, voir [9]) sous la forme d'un automate Miley et d'un mod√®le Miley-Moore combin√© sont pr√©sent√©s, respectivement, sur la Fig.  2a et fig.  2b. <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="image"><br>  Fig.  1. Mod√®le de retard d'unit√© sous la forme d'un automate Miles <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="image"><br>  Fig.  2. Le mod√®le de retard de transport de Miles (a) et Miles-Moore (b) <br><br>  Le signal d'entr√©e x3 (on rappelle que dans le programme automatique il correspond au pr√©dicat [1]) prend une valeur vraie si la valeur du compteur d'horloge est √©gale √† la valeur de la variable t √©gale au retard t01 ou t10.  La valeur de la variable t est affect√©e aux signaux y3 et y4 (dans le programme, les fonctions d'action du m√™me nom que les signaux de sortie).  Les signaux y1, y2 d√©finissent la valeur de la variable repr√©sentant la sortie du mod√®le.  Le signal y5 incr√©mente le compteur d'horloge, qui est r√©initialis√© par le signal y6. <br><br>  <i>Remarque 2. Les √©tats internes du mod√®le de la Fig.</i>  <i>1, il est commode de l'associer √† un √©tat de sortie d'un √©l√©ment.</i>  <i>Cela nous permet d'exclure non seulement les op√©rateurs y1 et y2, mais √©galement la variable de sortie elle-m√™me.</i> <i><br></i> <br>  L'impl√©mentation de l'int√©gration d'automates similaires aux sous-routines d'appel forme la technologie de programmation modulaire d'automates.  En m√™me temps, au niveau logiciel, contrairement √† des tentatives similaires au niveau mat√©riel (voir [10] pour comparaison), c'est beaucoup plus simple.  Pour ce faire, vous devez ins√©rer l'appel de programme de l'automate imbriqu√©, puis le noyau de l'impl√©mentation des automates, comme un processeur normal, organise le retour du contr√¥le au niveau d'imbrication actuel. <br><br>  <i>D√©finition 3. Les automates imbriqu√©s</i> seront appel√©s automates avec un √©tat final, dont la transition d√©marre la proc√©dure de retour au niveau pr√©c√©dent (rang) d'imbrication. <br><br>  La mise en ≈ìuvre correcte de l'imbrication des automates impose des restrictions sur la proc√©dure de leur cr√©ation.  Tout d'abord, un automate imbriqu√© ne peut √™tre que subordonn√©.  De plus, un automate de niveau sup√©rieur, √† l'exclusion du rang z√©ro, peut √©galement √™tre un automate imbriqu√©.  Deuxi√®mement, √† chaque transition, <b>un seul</b> automate imbriqu√© peut √™tre cr√©√©.  Le m√©canisme des automates imbriqu√©s cr√©e √©galement la base pour la mise en ≈ìuvre d'algorithmes r√©cursifs bas√©s sur le contr√¥le automatique. <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="image"><br>  Fig.  3. Mod√®le de retard sous forme d'automates imbriqu√©s <br><br>  La Fig. 3 montre le mod√®le de retard, o√π la Fig. 3a repr√©sente le mod√®le de niveau sup√©rieur, et la Fig. 3b et la Fig.  3c - variantes d'automates imbriqu√©s pour le transport et <i>les</i> retards <i>inertiels</i> (pour plus de d√©tails sur les types de retards, voir [8]).  En m√™me temps, ce sont des exemples de deux types d'automates imbriqu√©s - <i>ordinaire</i> et <i>inertiel</i> .  Le type d'un automate imbriqu√© est d√©fini par le nom de ses √©tats finaux: un √©tat avec le nom "00" d√©termine la sortie habituelle de l'automate imbriqu√©, et un √©tat avec le nom "XX" ne change pas l'√©tat actuel de l'automate de niveau sup√©rieur. <br><br>  Une explication importante pour comprendre l'algorithme de retard inertiel.  Pour cela (voir Fig. 3c), la valeur du pr√©dicat x1 d√©pend de la transition sur laquelle l'automate embarqu√© est cr√©√©.  En d'autres termes, le pr√©dicat dans l'√©tat "0" contr√¥le la conservation de "z√©ro" √† l'entr√©e, et dans l'√©tat "1", au contraire, "unit√©s".  Si la valeur √† l'entr√©e est z√©ro √† la valeur z√©ro de la sortie, vous devez renvoyer la vraie valeur.  De plus, si la stabilit√© de l'entr√©e est viol√©e (la valeur x1 est fausse) et le temps de retard n'a pas expir√© (la valeur x3 est fausse), alors la sortie de la machine embarqu√©e est r√©alis√©e par l'√©tat inertiel (voir Fig.3c). <br><br>  <i>D√©finition 4. Les</i> automates, y compris l'appel des automates imbriqu√©s qui ont un √©tat inertiel final, seront appel√©s <i>automates inertiels</i> . <br><br>  Dans le mod√®le de la figure 3a, l'action z1 (le symbole z est s√©lectionn√© pour les noms d'actions qui incluent un appel √† un automate imbriqu√©) cr√©e un automate imbriqu√© si une valeur de retard est d√©finie.  Dans le cadre de cette action, le type de retard sp√©cifi√© est d√©termin√©, selon lequel l'un des automates imbriqu√©s est cr√©√©, illustr√© sur la Fig.3b ou la Fig.  3c. <br><br>  Au niveau sup√©rieur de la hi√©rarchie, la vue de l'automate sur la figure 3a co√Øncide compl√®tement en structure avec le mod√®le de la figure 1, ne diff√©rant que par la pr√©sence d'actions sur les transitions.  Les retards avec des automates imbriqu√©s ont une forme plus simple que le mod√®le √† un niveau de la figure 2.  Un automate imbriqu√© peut √©galement √™tre consid√©r√© comme une sorte d '¬´automate de biblioth√®que¬ª qui peut √™tre appel√© √† partir de n'importe quel autre automate. <br><br><h3>  3. Programmation d'un automate objet </h3><br>  Le mod√®le de contr√¥le automatique, en plus de la forme graphique, a √©galement une forme tabulaire simple - une table de transition (TP), qui peut √™tre efficacement interpr√©t√©e en C ++.  Dans son cadre, un programme automate s√©par√© (ou une partie de celui-ci) et, par cons√©quent, sa d√©finition sous la forme d'un circuit de programme S peuvent √™tre repr√©sent√©s par une classe.  Dans ce cas, les mod√®les de m√©moire correspondront aux propri√©t√©s de la classe, l'ensemble des op√©rations correspondra aux m√©thodes de la classe, et le contr√¥le automatique sous forme de TP d√©crira le comportement de la classe.  L'introduction du contr√¥le dans la classe nous permet de parler des objets actifs, aussi souvent appel√©s agents, etc. <br><br>  De nombreux objets ayant un comportement sous forme de contr√¥le d'automate officialisent le concept d'un <i>programme parall√®le d'objet automate</i> .  Dans ce cas, le mod√®le de tout programme parall√®le peut √™tre repr√©sent√© par un diagramme de programme dans lequel le contr√¥le C sera pr√©sent√© sous la forme d'un r√©seau d'automates, o√π les automates de composants d√©crivent le comportement des objets actifs, la m√©moire M est repr√©sent√©e par une combinaison de propri√©t√©s d'objets, et de nombreux op√©rateurs A sont repr√©sent√©s par une combinaison de m√©thodes d'objets de programme. <br><br>  Dans l'environnement VKPA, le r√¥le du langage de programmation automatis√© est attribu√© au langage C ++.  En ¬´C ++ automatique¬ª, les objets sont dot√©s d'activit√© / de comportement et ont les moyens de d√©crire et de mettre en ≈ìuvre le parall√©lisme, tant au niveau des m√©thodes des objets individuels qu'au niveau de la description du fonctionnement parall√®le de nombreux objets. <br><br>  Les impl√©mentations d'objets existantes d'AP sont plut√¥t compliqu√©es.  Dans VKPa, son impl√©mentation d'objet est bas√©e sur l'interpr√©tation d'automates et un contr√¥le d√©di√© du programme.  Contrairement √† l'impl√©mentation directe d'automates, utilis√©e par exemple dans la technologie SWITH, cela √©limine la proc√©dure de conversion d'un mod√®le d'automate en mod√®le d'organigramme.  L'algorithme d'interpr√©tation utilis√© dans VKPa est similaire √† la m√©thode d'interpr√©tation des tables de d√©cision par E. Hamby [12]. <br><br>  Sauf indication contraire, nous associerons en outre le concept de programme d'automate au concept d' <i>objet automate (AO)</i> au sens de POO, mais en tenant compte du concept de programme parall√®le d'automate objet introduit ci-dessus.  Pour cette raison, les op√©rateurs et la m√©moire de l'AP seront d√©termin√©s par les m√©thodes et les propri√©t√©s des objets actifs.  Les objets automates se distinguent des objets ordinaires par la pr√©sence d'un comportement d√©termin√© par le mod√®le de machine √† √©tats. <br><br><h3>  4. Conclusions </h3><br>  La cr√©ation d'un mod√®le d'automates imbriqu√©s est une √©tape vers un changement qualitatif dans la technologie de programmation.  Le mod√®le inertiel d√©crit de l'automate est similaire au concept d'√©tats historiques en UML.  L'incorporation habituelle des automates a un analogue en programmation, l '"incorporation inertielle" ne l'a pas, car  Dans un programme, vous ne pouvez pas revenir √† une commande pr√©c√©dant un appel de sous-routine.  Et ce sont des √©l√©ments d'une diff√©rence qualitative entre la programmation automatique et la programmation ordinaire. <br><br>  Vous pouvez, bien s√ªr, introduire la m√©moire fant√¥me dans la programmation ordinaire et d√©noter le parall√©lisme des fonctions.  Mais dans le cadre du mod√®le automate, tout cela a une forme organique, √† la fois en termes de description et en termes de performances.  Tout est d√©termin√© par le parall√©lisme naturel du mod√®le.  Le mod√®le de diagramme n'a pas de telles capacit√©s. <br><br>  Les objets actifs √©tendent √©galement les capacit√©s de programmation.  Mais le ¬´wrapper d'objet¬ª, pour sa part, affecte qualitativement la programmation automatique, simplifiant les proc√©dures d'invocation et d'impl√©mentation d'automates imbriqu√©s.  Ainsi, l'utilisation des propri√©t√©s de classe [locales] vous permet d'impl√©menter non seulement l'incorporation, mais aussi des algorithmes r√©cursifs. <br><br><div class="spoiler">  <b class="spoiler_title">Les r√©f√©rences</b> <div class="spoiler_text">  1. Machine de Turing, comme mod√®le de programmes automatiques.  [Ressource √©lectronique], Mode d'acc√®s: <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratuit.  Yaz.  Russe  (date du traitement 07.01.2020). <br>  2. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introduction √† la th√©orie des automates - M.: Science.  Ch.  √©d.  Phys.-Math.  lit., 1985 .-- 320 p. <br>  3. GLUSHKOV V.M.  Synth√®se de machines num√©riques.  M.: Fizmatgiz, 1962. <br>  4. ZAKREVSKY A.D.  Synth√®se logique des sch√©mas en cascade.  - M.: Science.  Ch.  √©d.  Tapis physique  lit., 1981. - 416 p. <br>  5. KUZNETSOV O.P.  Graphes d'automates logiques et leurs transformations // Automatisation et T√©l√©m√©canique.  - 1975. - n ¬∞ 9.‚Äì art. 149-158. <br>  6. Kormen T., Leiserson Ch., Rivest R. Algorithms: construction and analysis - M .: MCCMO, 2001. - 960 p. <br>  7. BUCH G., RAMBO J., JACOBSON I. UML.  Manuel d'utilisation.  Deuxi√®me √©dition.  IT Academy: Moscou, 2007 .-- 493 p. <br>  8. BARANOV S.I.  Synth√®se du firmware  - L.: Energy, 1979-232s. <br>  9. ARMSTRONG J.R.  Mod√©lisation des syst√®mes num√©riques en langage VHDL: Traduit de l'anglais / M .: Mir, 1992. - 175 p. <br>  10. HAMBARTSUMYAN A.A., ZAPOLSKYH E.N.  Une approche de la d√©composition temporaire des automates.  Moi, Avtomat.  et Telemech., 1981, num√©ro 2, 135-144 <br>  11. SHALYTO A. A. Le paradigme de la programmation automatique.  Bulletin scientifique et technique de l'Universit√© d'√âtat des technologies de l'information, de la m√©canique et de l'optique de Saint-P√©tersbourg.  Vol.  53. Programmation automatis√©e.  2008, p.  3-23. <br>  12. HAMBI E. Programmation des tables de d√©cision.  M.: Mir, 1976 .-- 86 p. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484588/">https://habr.com/ru/post/fr484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484578/index.html">Objectifs de niveau de service - Exp√©rience Google (traduction de la section Google SRE Book)</a></li>
<li><a href="../fr484580/index.html">Ce que vous devez savoir sur les simulateurs de m√©moire</a></li>
<li><a href="../fr484582/index.html">ASP.NET MVC - Entity Framework, MySQL et utilisation de Dependency Resolver pour s√©lectionner un r√©f√©rentiel</a></li>
<li><a href="../fr484584/index.html">Pourquoi avons-nous besoin d'un gestionnaire dans un projet informatique et que se passera-t-il lorsqu'il ne l'est pas</a></li>
<li><a href="../fr484586/index.html">Travailler avec IPv6 en PHP</a></li>
<li><a href="../fr484590/index.html">Pour que les gar√ßons n'aient pas honte de montrer</a></li>
<li><a href="../fr484592/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 398 (13-19 janvier 2020)</a></li>
<li><a href="../fr484596/index.html">Boutique en ligne c√¥t√© client Blazor: Partie 1 - Autorisation oidc (oauth2) + Identity Server4</a></li>
<li><a href="../fr484600/index.html">Microsoft Ignite The Tour Prague Conf√©rence technique</a></li>
<li><a href="../fr484602/index.html">Livre ¬´D√©veloppement d'applications mobiles en C # pour iOS et Android¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>