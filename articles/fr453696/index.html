<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏿 💇🏼 👩🏻‍⚖️ Reliure angulaire bidirectionnelle, un peu plus de compréhension 🦅 👈🏼 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Du traducteur  D'un traducteur : il y a deux ans, j'ai commencé mon premier projet sur Angular (2+), ayant une grande et réussie expérience AngularJS....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reliure angulaire bidirectionnelle, un peu plus de compréhension</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453696/"><div class="spoiler">  <b class="spoiler_title">Du traducteur</b> <div class="spoiler_text">  <b>D'un traducteur</b> : il y a deux ans, j'ai commencé mon premier projet sur Angular (2+), ayant une grande et réussie expérience AngularJS.  La transition a nécessité un formatage sensible de la pensée, car trop sur A1 et A2 + se fait «un peu différemment».  La douleur de la transition a considérablement réduit le blog de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinktram</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moi</a> .  Il y a un an, j'ai reçu la permission de traduire cet article "sur élémentaire et facilement compréhensible pour tout le monde".  Mais ce sont de telles mains (leurs articles sont un tas de livres inachevés).  Étonnamment, l'article se traduit bien sur Google translate.  Mais certaines des nuances de cette traduction ont été perdues, sans parler du style de l'auteur.  Le style de l'auteur n'a pas été entièrement conservé dans ma version.  Mais, j'espère, j'ai réussi à transmettre l'humeur et les pensées de l'article. <br><br>  Je comprends que Angular n'est pas le sujet le plus populaire sur Habré, mais j'espère que la traduction aidera quelqu'un, tout comme l'article original m'a aidé une fois. <br></div></div><br>  C'est ce qui a causé l'effet wow dans le bon vieux AngularJS, c'est donc une "liaison bidirectionnelle".  Cette magie est instantanément tombée amoureuse d'AngularJS et a brisé toutes les idées sur la programmation de pages ennuyeuses et (oh, l'horreur!) Les formulaires Web.  Les modifications apportées aux données sont instantanément affichées à l'écran et vice versa.  Ceux qui ont précédemment développé des applications jQuery ont perçu la liaison comme tombant dans un conte de fées.  Et les monstres barbus, voyant des gros clients avant jQuery, ont commencé à compter frénétiquement les mois-hommes stupidement perdus. <br><br>  De plus, la magie de la reliure bidirectionnelle était disponible non seulement pour les notations spéciales et les composants sélectionnés.  Nous pourrions facilement l'utiliser dans nos propres directives et composants (simplement en définissant le paramètre de configuration). <br><br>  <b>Dans Angular2 +, les créateurs ont abandonné la liaison de données bidirectionnelle intégrée</b> (sauf via ngModel).  Mais cela ne signifie pas que nous ne pouvons pas utiliser la liaison bidirectionnelle dans nos propres directives ... C'est juste que le cadeau est terminé et maintenant nous devons faire quelque chose par nous-mêmes.  Et, de préférence, avec une compréhension de la façon dont cela fonctionne dans Angular. <br><a name="habracut"></a><br><h3>  Table des matières </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliure bidirectionnelle en bref</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre ngModel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Créez vos propres liaisons de données bidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><a name="in2word"></a><h3>  Reliure bidirectionnelle en bref </h3><br>  Dans A2 +, une seule directive implémente la liaison de données bidirectionnelle: <b>ngModel</b> .  Et à première vue, c'est la même magie que dans AngularJS (uniquement dans une notation différente).  Mais qu'est-ce qui se cache sous le capot? <br><br>  Étonnamment, sous le capot, tout est relativement simple et logique: la liaison bidirectionnelle est réduite à la liaison de propriété et à la liaison d'événement.  Deux consolidations unilatérales, au lieu d'une bilatérale?  Ok, disons deux. <br><br>  Et immédiatement un exemple: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Oui, oui, c'est une belle et étonnante démo Angular2 de 2009.  Sans blague, magnifique.  Lors de la modification du champ, la valeur du <b>nom d'utilisateur</b> tombe dans le modèle et est immédiatement reflétée dans le message de bienvenue sur le formulaire. <br><br>  Mais comment ça marche?  Rappelons que la liaison bidirectionnelle dans Angular2 est une liaison de propriété et une liaison d'événement.  Et oui, ils peuvent être disponibles simultanément dans une seule directive.  De plus, même sans <b>ngModel</b> , nous pourrions facilement implémenter une liaison de données bidirectionnelle.  Par exemple, comme ceci: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event.target.value"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  La sortie <b>{{username}} est</b> claire, mais qu'est-ce qui y est écrit en <b>entrée</b> ?  Comprenons: <br><br><ul><li>  <b>[valeur] = «nom d'utilisateur»</b> - notation entre crochets, associe l'expression du nom d'utilisateur à la propriété value </li><li>  <b>(entrée) = "expression"</b> - une notation entre parenthèses, l'expression est attachée à l'événement d' <b>entrée</b> (oui, il y a un tel événement).  Dans notre cas: <br><ul><li>  <b>username = $ event.target.value</b> - cette expression sera exécutée en réponse à l'événement d'entrée </li><li>  <b>$ event</b> est une variable synthétique dans les événements angulaires qui porte une charge utile: dans ce cas, il contient des informations sur ce qui s'est passé et ses environs </li></ul></li></ul><br>  Est-ce que ça devient plus clair?  Nous le réparons. <br><br>  Nous lions la propriété <b>username</b> du modèle angulaire à la propriété <b>value</b> de l'élément d'entrée du navigateur (liaison unidirectionnelle du modèle à la vue). <br><br>  Nous lions également une expression à l'événement d' <b>entrée</b> de notre élément.  Qui affecte la valeur de <b>$ event.target.value</b> à la propriété de <b>nom d'utilisateur</b> du modèle. <br><br>  Qu'est-ce que <b>$ event.target.value</b> ?  Comme déjà mentionné, <b>$ event</b> regorge de diverses informations utiles sur l'événement.  Dans ce cas, il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">InputEventObject</a> dans lequel la propriété <b>target</b> fait référence à l'élément DOM qui a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déclenché l'</a> événement (c'est-à-dire notre élément d'entrée). <br><br>  Donc, tout ce que nous faisons essentiellement, c'est lire le contenu ( <b>valeur</b> ) de l'élément d'entrée ( <b>$ event.target</b> ) lorsque l'utilisateur entre une valeur.  Et lorsque nous attribuons cette valeur de nom d'utilisateur, les données de vue seront envoyées au modèle. <br><br>  <b>C’est tout.</b>  <b>Il s'agit d'une "liaison bidirectionnelle en bref"</b> .  La beauté? <br><br>  Mais quand <b>ngModel</b> entre-t-il en jeu?  Le scénario de travail avec des éléments d'entrée est très courant et très demandé.  Et pour une raison quelconque, je veux avoir une directive qui masque l'implémentation et économise des frappes supplémentaires. <br><br><a name="ngModel"></a><h3>  Comprendre ngModel </h3><br>  Si vous regardez la source, vous pouvez vous assurer que <b>ngModel a</b> également une liaison à la propriété et à l'événement.  Voici à quoi ressemble notre exemple ngModel, mais sans utiliser de syntaxe abrégée: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModelChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Presque tout est pareil.  La liaison de la <b>propriété [ngModel]</b> se charge de mettre à jour la valeur de l'élément d'entrée.  Une liaison d'événement <b>(ngModelChange)</b> informe le monde que des changements se produisent dans le DOM. <br><br>  Et vous avez remarqué que l'expression du gestionnaire utilise uniquement <b>$ event</b> , pas <b>$ event.target.value</b> .  Quelque chose ne va pas ici?  Pas du tout.  Comme indiqué ci-dessus, <b>$ event</b> est une variable synthétique qui transporte une <b>charge utile</b> .  La décision de ce qui est considéré comme utile est prise par Angular.  En d'autres termes, <b>ngModelChange</b> se charge d'extraire <b>target.value</b> de l' <b>événement $</b> interne et nous donne simplement ce que nous voulons, sans empaquetage ni tambourin.  Pour être techniquement précis, ce sont ceux de <a href="">DefaultValueAccessor</a> : c'est lui qui extrait les données et les transfère à l'objet DOM de base, bien que ... vous ne pouvez tout simplement pas y penser). <br><br>  Dernier point mais non des moindres, puisque l'écriture deux fois de <b>nom d'utilisateur</b> et de <b>ngModel</b> est toujours redondante, Angular permet l'utilisation de la syntaxe abrégée <b>[()]</b> , également appelée «banane dans une boîte».  Ce qui est similaire à l'exemple précédent, et nous renvoie à l'exemple du début de la section, mais avec une compréhension de l'implémentation de <b>ngModel</b> .  Fournir la même liaison bidirectionnelle. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><a name="bindings"></a><br><h3>  Créez vos propres liaisons de données bidirectionnelles </h3><br>  Nous en savons maintenant assez pour créer nos propres liaisons de données bidirectionnelles.  Il vous suffit de suivre les mêmes règles que <b>ngModel</b> , à savoir: <br><br><ul><li>  Entrez une liaison de propriété (par exemple: <b>[foo]</b> ) </li><li>  Lier à un événement portant le même nom et le même suffixe <b>Change</b> (par exemple: <b>(fooChange)</b> ) </li><li>  Assurez-vous que la liaison d'événement prend en charge la récupération de la propriété (si nécessaire) </li></ul><br>  Notez que la création d'une liaison de données bidirectionnelle nécessite beaucoup plus de travail que AngularJS?  Cela pourrait être très frustrant pour nous ... Si nous essayions d'utiliser notre propre liaison bidirectionnelle dans la mesure du possible.  Dans la vraie vie, vous devez toujours vous demander si nous avons besoin d'une liaison bidirectionnelle et, si nécessaire, s'il est plus facile de profiter de ngModel.  Ce dernier, par exemple, a lieu lors de la création de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôles de formulaire personnalisés</a> . <br><br>  Mais disons que nous créons un composant de compteur personnalisé (et que nous ne voulons pas utiliser un contrôle de formulaire personnalisé). <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'custom-counter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;{{counter}}&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } set counter(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = value; } decrement() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter--; } increment() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre><br>  Nous avons la propriété du composant <b>compteur</b> pour afficher la valeur actuelle du compteur.  Pour lui fournir une liaison bidirectionnelle, la première chose à faire est de le transformer en paramètre d' <b>entrée</b> .  Pour cela, le décorateur <b>@Input ()</b> est très utile: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; @Input() get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } ... }</code> </pre><br>  Cela vous permet déjà de lier la propriété du composant au consommateur comme suit: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Maintenant, nous devons définir l' <b>événement @Output ()</b> avec le même nom ( <b>compteur</b> ) et le suffixe <b>Change</b> (il s'avère que counterChange).  Nous voulons soulever cet événement à chaque fois que le <b>compteur</b> change.  Pourquoi ajouter la propriété <b>@Output ()</b> .  Et nous terminerons, dans quelques getters, le compteur de compteur, dans lequel nous intercepterons le changement de valeur et lancerons un événement avec la valeur de compteur actuelle: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ ... @Output() counterChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); set counter(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterChange.emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue); } ... }</code> </pre><br>  Ça y est!  Maintenant, nous pouvons lier l'expression à cette propriété en utilisant la syntaxe de liaison de données bidirectionnelle: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>counterValue = {{someValue}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Découvrez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> et essayez-la! <br><br>  Encore une fois, gardez à l'esprit qu'un composant tel qu'un compteur personnalisé est mieux implémenté avec un contrôle de formulaire personnalisé et profitez de <b>ngModel</b> pour implémenter la liaison de données bidirectionnelle, comme décrit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> . <br><br><a name="conclusion"></a><h3>  Conclusion </h3><br>  Angular n'est plus fourni avec une liaison de données bidirectionnelle intégrée.  Au lieu de cela, il y a des API dans la boîte qui vous permettent d'implémenter la liaison complète en tant que propriétés et événements de liaison. <br><br>  <b>ngModel</b> est une directive de liaison bidirectionnelle intégrée dans FormsModule (n'oubliez pas de l'ajouter à la section des <b>importations</b> de la déclaration <b>@NgModule</b> : environ par).  La liaison via ngModel doit être préférée lors de la création de composants qui servent de contrôles de formulaire personnalisés.  Sinon, tout dépend de votre imagination. <br><br>  <b>PS du traducteur:</b> <i>l'implémentation de liaison dans A2 + est devenue plus moderne.</i>  <i>Désormais, des setters presque «gratuits» sont utilisés pour surveiller les changements par le «feng shui» (bien qu'il soit clair que les mécanismes de vérification des erreurs restent, au moins pour les composants utilisateurs de haut niveau).</i>  <i>Cela a permis d'abandonner 100 500 observateurs (procédures de suivi des évolutions de «leurs» données).</i>  <i>Qui dans A1 aimait créer une charge malveillante sur le navigateur et nécessitait des mains inhabituellement directes lors de la planification de pages interactives riches.</i> <i><br><br></i>  <i>Avec des composants correctement conçus, A2 prêt à l'emploi est devenu beaucoup plus réactif.</i>  <i>Laissez au détriment du travail des programmeurs.</i>  <i>Vous pouvez maintenant placer une légion de composants sur la page et ne vous souciez pas des ressources du processeur.</i> <i><br><br></i>  <i>Le revers de la médaille était le coût initial du "processus d'entrée" dans A2 +, qui a affecté la popularité du cadre.</i>  <i>Mais A1 avait également un coût d'entrée élevé, seulement il a été relégué dans la ligue majeure.</i>  <i>En raison d'un manque de compréhension sur la façon d'organiser de grandes applications, de nombreux prototypes "ont décollé" sur A1, puis "se sont effondrés" et correspondaient à React et Vue.</i> <i><br><br></i>  <i>J'espère qu'avec cet article, j'aiderai à abaisser légèrement le seuil d'entrée initiale à A2 +, qui continue d'être en demande (que je connais de première main).</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453696/">https://habr.com/ru/post/fr453696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453682/index.html">Développement du «firmware» le plus simple pour les FPGA installés dans Redd. Partie 2. Code de programme</a></li>
<li><a href="../fr453686/index.html">Semaine de la sécurité 22: statistiques sur les menaces, chevaux de Troie bancaires et exploits populaires</a></li>
<li><a href="../fr453688/index.html">Java n'est pas seulement une entreprise sanglante, mais aussi des applications sensibles à la latence rapide</a></li>
<li><a href="../fr453692/index.html">Shaders de jeu 3D pour débutants: Effets</a></li>
<li><a href="../fr453694/index.html">Connectez-vous à Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453698/index.html">L'information quantique dans la conscience quantique</a></li>
<li><a href="../fr453700/index.html">Leçons sur SDL 2: Leçon 1 - Bonjour, SDL 2</a></li>
<li><a href="../fr453706/index.html">Comment j'ai réussi l'examen de certification Google Cloud Professional Data Engineer</a></li>
<li><a href="../fr453708/index.html">Système d'exploitation en temps réel AQUA RTOS pour MK AVR dans l'environnement BASCOM AVR</a></li>
<li><a href="../fr453710/index.html">Pratique de développement dans les grands projets: mitap SberPractice iOS # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>