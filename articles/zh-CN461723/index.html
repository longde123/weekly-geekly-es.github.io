<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ 👱🏿 🏇🏾 了解Golang中的Context包 ⛄️ 👩🏼‍🤝‍👩🏻 🤸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go中的上下文包对于与API和慢速流程的交互很有用，尤其是在处理Web请求的生产级系统中。 有了它的帮助，可以告知goroutine需要完成其工作。 


 以下是一个小型指南，可帮助您在项目中使用此软件包以及一些最佳实践和陷阱。 


 （注意：在许多软件包中都使用了上下文，例如，在使用Docke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>了解Golang中的Context包</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/461723/"><p><img src="https://habrastorage.org/getpro/habr/post_images/2f4/49e/54b/2f449e54b5540578a8ead5599e9e7f0e.jpg" alt="图片"></p><br><p>  Go中的上下文包对于与API和慢速流程的交互很有用，尤其是在处理Web请求的生产级系统中。 有了它的帮助，可以告知goroutine需要完成其工作。 </p><br><p> 以下是一个小型指南，可帮助您在项目中使用此软件包以及一些最佳实践和陷阱。 </p><br><p>  <em>（注意：在许多软件包中都使用了上下文，例如，在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker时</a> ）。</em> </p><a name="habracut"></a><br><h2 id="pered-tem-kak-nachat"> 开始之前 </h2><br><p> 要使用上下文，您必须了解什么是goroutine和通道。 我将尝试简要地考虑它们。 如果您已经熟悉它们，请直接转到“上下文”部分。 </p><br><h3 id="gorutina"> 古鲁丁 </h3><br><p> 官方文件说：“ Gorutin是一种轻量级的执行流。”  Goroutine比线程轻，因此管理它们的资源消耗相对较少。 </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">沙箱</a> </p><br><pre><code class="plaintext hljs">package main import "fmt" // ,   Hello func printHello() { fmt.Println("Hello from printHello") } func main() { //   //       go func(){fmt.Println("Hello inline")}() //     go printHello() fmt.Println("Hello from main") }</code> </pre> <br><p> 如果运行此程序，您将看到仅打印<code>Hello from main</code> 。 实际上，两个goroutine都已开始，但是<code>main</code>却更早完成了。 因此，Goroutines需要一种方法来通知<code>main</code>执行结束，以便她等待。 在这里渠道对我们有所帮助。 </p><br><h3 id="kanaly-channels"> 频道 </h3><br><p> 通道是goroutine之间的一种通信方式。 当您要将结果，错误或其他信息从一个goroutine传输到另一个goroutine时，可以使用它们。 通道具有不同的类型，例如， <code>int</code>类型的通道接收整数，而<code>error</code>类型的通道接收错误，等等。 </p><br><p> 假设我们有一个<code>int</code>类型的<code>ch</code>通道。 如果要向通道发送内容，则语法将为<code>ch &lt;- 1</code> 。 您可以从渠道中获取以下信息： <code>var := &lt;- ch</code> ，即 从通道中获取值并将其保存在<code>var</code>变量中。 </p><br><p> 以下代码说明了如何使用通道来确认goroutine已完成工作并将其值返回给<code>main</code> 。 </p><br><p>  <em>注意： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等待组</a>也可以用于同步，但是在本文中，我选择了代码示例的通道，因为稍后将在上下文部分中使用它们。</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">沙箱</a> </p><br><pre> <code class="plaintext hljs">package main import "fmt" //       int   func printHello(ch chan int) { fmt.Println("Hello from printHello") //     ch &lt;- 2 } func main() { //  .       make //       : // ch := make(chan int, 2),       . ch := make(chan int) //  .  ,    . //       go func(){ fmt.Println("Hello inline") //     ch &lt;- 1 }() //     go printHello(ch) fmt.Println("Hello from main") //      //     ,    i := &lt;- ch fmt.Println("Received ",i) //      //    ,      &lt;- ch }</code> </pre> <br><h2 id="kontekst-context"> 语境 </h2><br><p>  go中的上下文包允许您以某种“上下文”将数据传递到程序。 上下文（如超时，截止日期或通道）表示关闭并调用返回。 </p><br><p> 例如，如果您发出Web请求或执行系统命令，则对生产级系统使用超时将是一个好主意。 因为如果您正在访问的API速度很慢，则您不太可能希望在系统上累积请求，因为这可能导致在处理自己的请求时增加负载并降低性能。 结果是级联效应。 </p><br><p> 在这里，超时或截止日期可能是正确的。 </p><br><h3 id="sozdanie-konteksta"> 上下文创建 </h3><br><p> 上下文包允许您通过以下方式创建和继承上下文： </p><br><p>  <strong>context.Background（）ctx上下文</strong> </p><br><p> 此函数返回一个空上下文。 仅应在较高级别（主要或最高级别的请求处理程序）中使用。 它可以用于获取其他上下文，我们将在后面讨论。 </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.Background()</code> </pre> <br><p>  <em>注意事项</em>  <em>trans .:原始文章中有一个错误，使用<code>context.Background</code>的正确示例如下：</em> </p><br><pre> <code class="plaintext hljs">ctx := context.Background()</code> </pre> <br><p>  <strong>context.TODO（）ctx上下文</strong> </p><br><p> 此函数还会创建一个空上下文。 并且，当您不确定要使用哪个上下文时，或者如果函数尚未收到所需的上下文时，也应仅在较高级别上使用它。 这意味着您（或支持代码的人）计划在以后向该功能添加上下文。 </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.TODO()</code> </pre> <br><p>  <em>注意事项</em>  <em>trans .：原始文章中有一个错误，使用<code>context.TODO</code>的正确示例如下：</em> </p><br><pre> <code class="plaintext hljs">ctx := context.TODO()</code> </pre> <br><p> 有趣的是，看一下<a href="">代码</a> ，它与背景绝对相同。 唯一的区别是，在这种情况下，您可以使用静态分析工具来检查上下文传输的有效性，这是一个重要的细节，因为这些工具有助于在早期阶段识别潜在的错误，并且可以包含在CI / CD管道中。 </p><br><p>  <a href="">从这里</a> ： </p><br><pre> <code class="plaintext hljs">var ( background = new(emptyCtx) todo = new(emptyCtx) )</code> </pre> <br><p>  <strong>context.WithValue（父上下文，键，val接口{}）（ctx上下文，取消CancelFunc）</strong> </p><br><p>  <em>注意事项</em>  <em>莱恩：原始文章中有一个错误， <code>context.WithValue</code>的正确签名<code>context.WithValue</code>将如下所示：</em> </p><br><pre> <code class="plaintext hljs">context.WithValue(parent Context, key, val interface{}) Context</code> </pre> <br><p> 该函数获取一个上下文，并返回从中派生的上下文，其中<code>val</code>值与<code>key</code>关联，并通过整个上下文树。 也就是说，一旦创建<code>WithValue</code>上下文，任何派生的上下文都会收到该值。 </p><br><p> 不建议使用上下文值传递关键参数；相反，函数应在签名中显式地使用它们。 </p><br><pre> <code class="plaintext hljs">ctx := context.WithValue(context.Background(), key, "test")</code> </pre> <br><p>  <strong>context.WithCancel（父上下文）（ctx上下文，取消CancelFunc）</strong> </p><br><p> 这里变得更加有趣。 此函数从传递给它的父级创建一个新的上下文。 父级可以是背景上下文，也可以是作为参数传递给函数的上下文。 </p><br><p> 返回派生的上下文和撤消函数。 只有创建它的函数才应调用该函数以取消上下文。 您可以根据需要将undo函数传递给其他函数，但是强烈建议不要这样做。 通常，此决定是基于对上下文取消的误解而做出的。 因此，从该父对象生成的上下文可能会影响程序，从而导致意外结果。 简而言之，最好不要通过取消功能。 </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>注意事项</em>  <em>Lane：在原始文章中，作者显然是针对<code>context.WithCancel</code>给出了一个<code>context.WithCancel</code>的示例。</em>  <em><code>context.WithCancel</code>的正确示例为：</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithCancel(context.Background())</code> </pre> <br><p>  <strong>context.WithDeadline（父上下文，d time.Time）（ctx上下文，取消CancelFunc）</strong> </p><br><p> 此函数从其父级返回派生上下文，该上下文在截止日期或调用cancel函数后被取消。 例如，您可以创建一个在特定时间自动取消的上下文，并将其传递给子函数。 在截止日期之后取消此上下文时，应通过通知来通知具有此上下文的所有功能。 </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <strong>context.WithTimeout（父上下文，超时时间。持续时间）（ctx上下文，取消CancelFunc）</strong> </p><br><p> 此功能类似于context.WithDeadline。 区别在于将时间长度用作输入。 此函数返回派生的上下文，该上下文在调用cancel函数或一段时间后被取消。 </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>注意事项</em>  <em>Lane：在原始文章中，作者显然是针对<code>context.WithTimeout</code>给出了一个<code>context.WithTimeout</code>的示例。</em>  <em><code>context.WithTimeout</code>的正确示例是这样的：</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)</code> </pre> <br><h3 id="priyom-i-ispolzovanie-kontekstov-v-vashih-funkciyah"> 在函数中接收和使用上下文 </h3><br><p> 现在，我们知道如何创建上下文（背景和TODO）以及如何生成上下文（WithValue，WithCancel，Deadline和Timeout），让我们讨论如何使用它们。 </p><br><p> 在下面的示例中，您可以看到获取上下文的函数启动了goroutine并期望它返回或取消上下文。  select语句帮助我们确定首先发生什么并终止函数。 </p><br><p> 关闭通道Done <code>&lt;-ctx.Done()</code> ，选择案例<code>case &lt;-ctx.Done():</code> 一旦发生这种情况，该函数应中断工作并准备返回。 这意味着您必须关闭所有打开的连接，释放资源并从函数中返回。 有时资源的释放可能会延迟返回，例如，清理挂起。 您必须牢记这一点。 </p><br><p> 本节后面的示例是一个完全完成的go程序，它说明了超时和撤消功能。 </p><br><pre> <code class="plaintext hljs">// ,  -      // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } }</code> </pre> <br><h3 id="primer"> 例子 </h3><br><p> 正如我们所看到的，使用上下文可以处理截止日期，超时，还可以调用cancel函数，从而使用派生上下文使所有函数都清楚需要完成工作并执行返回。 考虑一个例子： </p><br><p>  <code>main</code>功能： </p><br><ul><li> 创建一个取消函数上下文 </li><li> 任意超时后调用取消功能 </li></ul><br><p>  <code>doWorkContext</code>函数： </p><br><ul><li> 创建带有超时的派生上下文 </li><li> 当主函数调用cancelFunction，超时到期或doWorkContext调用其cancelFunction时，将取消此上下文。 </li><li> 运行goroutine来执行一些缓慢的任务，并传递结果上下文 </li><li> 等待goroutine完成或从main取消上下文，以先到者为准 </li></ul><br><p>  <code>sleepRandomContext</code>函数： </p><br><ul><li> 启动goroutine以执行一些缓慢的任务 </li><li> 等待goroutine完成，或者 </li><li> 等待上下文被主函数取消，超时或调用其自己的cancelFunction </li></ul><br><p>  <code>sleepRandom</code>函数： </p><br><ul><li> 随机入睡 </li></ul><br><p> 本示例使用睡眠模式来模拟随机处理时间，但实际上，您可以使用通道向此功能发出信号以告知清洁开始，并等待通道确认清洁已完成。 </p><br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">沙箱</a> （看来我在沙箱中使用的随机时间几乎没有变化。请在您的本地计算机上尝试一下以查看随机性）</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github</a> </p><br><pre> <code class="plaintext hljs">package main import ( "context" "fmt" "math/rand" "Time" ) //   func sleepRandom(fromFunction string, ch chan int) { //    defer func() { fmt.Println(fromFunction, "sleepRandom complete") }() //    //   , // «»      seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) randomNumber := r.Intn(100) sleeptime := randomNumber + 100 fmt.Println(fromFunction, "Starting sleep for", sleeptime, "ms") time.Sleep(time.Duration(sleeptime) * time.Millisecond) fmt.Println(fromFunction, "Waking up, slept for ", sleeptime, "ms") //   ,     if ch != nil { ch &lt;- sleeptime } } // ,       // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,    doWorkContext  // doWorkContext  main  cancelFunction //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("sleepRandomContext: Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } } //  ,         //       //   ,      main func doWorkContext(ctx context.Context) { //          - //  150  //  ,   ,   150  ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(150)*time.Millisecond) //         defer func() { fmt.Println("doWorkContext complete") cancelFunction() }() //       //         , //      ,    ch := make(chan bool) go sleepRandomContext(ctxWithTimeout, ch) //  select      select { case &lt;-ctx.Done(): //   ,           //     ,   main   cancelFunction fmt.Println("doWorkContext: Time to return") case &lt;-ch: //   ,       fmt.Println("sleepRandomContext returned") } } func main() { //   background ctx := context.Background() //     ctxWithCancel, cancelFunction := context.WithCancel(ctx) //      //        defer func() { fmt.Println("Main Defer: canceling context") cancelFunction() }() //     - //   ,        go func() { sleepRandom("Main", nil) cancelFunction() fmt.Println("Main Sleep complete. canceling context") }() //   doWorkContext(ctxWithCancel) }</code> </pre> <br><h3 id="podvodnye-kamni"> 陷阱 </h3><br><p> 如果函数使用上下文，请确保正确处理了取消通知。 例如， <code>exec.CommandContext</code>在命令完成该进程（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github</a> ）创建的所有派生之前不会关闭读取通道，即，如果您等待cmd.Wait（），则取消上下文不会立即从函数返回。直到外部命令的所有分支完成处理。 </p><br><p> 如果您使用的超时或截止日期具有最大的运行时间，则可能无法按预期运行。 在这种情况下，最好使用<code>time.After</code>实现超时。 </p><br><h3 id="luchshie-praktiki"> 最佳实务 </h3><br><ol><li>  context.Background只能在最高级别使用，作为所有派生上下文的根。 </li><li> 当您不确定要使用什么时，或者当前函数将来将使用上下文时，应使用context.TODO。 </li><li> 建议取消上下文，但是清除和退出这些功能可能需要一些时间。 </li><li>  context.Value应该尽可能少地使用，并且不应用于传递可选参数。 这会使API难以理解，并可能导致错误。 这些值应作为参数传递。 </li><li> 不要将上下文存储在结构中；应在函数中显式传递它们，最好将其作为第一个参数。 </li><li> 切勿将nil上下文作为参数传递。 如有疑问，请使用TODO。 </li><li>  <code>Context</code>结构没有取消方法，因为只有产生上下文的函数才应取消它。 </li></ol><br><h3 id="ot-perevodchika"> 来自翻译 </h3><br><p> 在我们公司中，当开发供内部使用的服务器应用程序时，我们会积极使用Context包。 但是，除了上下文之外，此类用于正常运行的应用程序还需要其他元素，例如： </p><br><ul><li> 记录中 </li><li> 用于应用程序终止，重新加载和对数旋转的信号处理 </li><li> 使用pid文件 </li><li> 使用配置文件 </li><li> 等 </li></ul><br><p> 因此，在某个时候，我们决定总结所有积累的经验，并创建辅助软件包，这些软件包大大简化了应用程序（尤其是具有API的应用程序）的编写。 我们已将我们的开发发布到公共领域，任何人都可以使用它们。 以下是一些可用于解决此类问题的软件包的链接： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nxs-go-appctx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nxs-go-conf</a> </li></ul><br><p> 另请阅读我们博客上的其他文章： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">减少Docker映像的三个简单技巧</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes中的状态备份</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">备份大量异构Web项目</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redmine的电报机器人。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何简化自己和他人的生活</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461723/">https://habr.com/ru/post/zh-CN461723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461713/index.html">4种保存云备份的方法</a></li>
<li><a href="../zh-CN461715/index.html">恐惧与厌恶饰演Techdir</a></li>
<li><a href="../zh-CN461717/index.html">如何在对象存储中压缩多达90％的备份存储</a></li>
<li><a href="../zh-CN461719/index.html">开源的报告自动化解决方案</a></li>
<li><a href="../zh-CN461721/index.html">新的聚类分析方法</a></li>
<li><a href="../zh-CN461725/index.html">DataGrip 2019.2：连接管理，数据搜索，导航过滤</a></li>
<li><a href="../zh-CN461727/index.html">思科小型企业解决方案：好的网络并不一定要付出高昂的代价</a></li>
<li><a href="../zh-CN461729/index.html">使用越狱来提取数据：风险和后果</a></li>
<li><a href="../zh-CN461731/index.html">DPKI：通过区块链解决集中式PKI的缺点</a></li>
<li><a href="../zh-CN461733/index.html">学习英语：9种美式习语</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>