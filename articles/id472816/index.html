<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ï¸ ğŸ¤• ğŸ‘¨ğŸ½â€ğŸ« Pola Elegan dalam JavaScript Modern (Siklus Tim Sourour Bill) ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ¤¾ğŸ¼ â˜ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Cukup guru guru JavaScript terkenal Bill Sourour pada saat itu menulis beberapa artikel tentang pola modern di JS. Sebagai bagian dari art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pola Elegan dalam JavaScript Modern (Siklus Tim Sourour Bill)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472816/"> Halo, Habr!  Cukup guru guru JavaScript terkenal Bill Sourour pada saat itu menulis beberapa artikel tentang pola modern di JS.  Sebagai bagian dari artikel ini, kami akan mencoba meninjau ide-ide yang dia bagikan.  Bukannya itu beberapa patters unik, tapi saya harap artikel ini akan menemukan pembacanya.  Artikel ini bukan "terjemahan" dari sudut pandang kebijakan Habr sejak itu  Saya menggambarkan pikiran saya bahwa artikel Bill telah mengarahkan saya. <br><br><h2>  Rooro </h2><br>  Singkatan berarti Menerima objek, mengembalikan objek - mendapatkan objek, mengembalikan objek.  Saya memberikan tautan ke artikel asli: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> <br><br>  Bill menulis bahwa ia menemukan cara untuk menulis fungsi di mana kebanyakan dari mereka hanya menerima satu parameter - objek dengan argumen fungsi.  Mereka juga mengembalikan objek hasil.  Bill terinspirasi oleh restrukturisasi ide ini (salah satu fitur ES6). <br><br>  Bagi mereka yang tidak tahu tentang perusakan, saya akan memberikan penjelasan yang diperlukan selama cerita. <br><a name="habracut"></a><br>  Bayangkan kita memiliki data pengguna yang berisi haknya untuk bagian tertentu dari aplikasi yang disajikan dalam objek data.  Kami perlu menunjukkan informasi tertentu berdasarkan data ini.  Untuk melakukan ini, kami dapat menawarkan implementasi berikut: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const user = { name: 'John Doe', login: 'john_doe', password: 12345, active: true, rules: { finance: true, analitics: true, hr: false } }; //   const users = [user]; //,     function findUsersByRule ( rule, withContactInfo, includeInactive) { //        active const filtredUsers= users.filter(item =&gt; includeInactive ? item.rules[rule] : item.active &amp;&amp; item.rules[rule]); //  ()   ( )     withContactInfo return withContactInfo ? filtredUsers.reduce((acc, curr) =&gt; { acc[curr.id] = curr; return acc; }, {}) : filtredUsers.map(item =&gt; item.id) } //     findUsersByRule( 'finance', true, true)</span></span></code> </pre> <cut></cut><br>  Dengan menggunakan kode di atas, kami akan mencapai hasil yang diinginkan.  Namun, ada beberapa jebakan dalam menulis kode dengan cara ini. <br><br>  Pertama, panggilan ke fungsi <code>findUsersByRule</code> sangat diragukan.  Perhatikan betapa ambigu dua parameter terakhir.  Apa yang terjadi jika aplikasi kita hampir tidak pernah membutuhkan informasi kontak (withContactInfo) tetapi hampir selalu membutuhkan pengguna yang tidak aktif (termasukInactive)?  Kami akan selalu harus melewati nilai-nilai logis.  Sekarang sementara deklarasi fungsi di sebelah panggilannya, ini tidak begitu menakutkan, tetapi bayangkan bahwa Anda melihat panggilan semacam itu di suatu tempat yang dibuat di modul lain.  Anda harus mencari modul dengan deklarasi fungsi untuk memahami mengapa dua nilai logis dalam bentuk murni ditransfer ke sana. <br><br>  Kedua, jika kita ingin membuat beberapa parameter wajib, kita harus menulis sesuatu seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRule</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> role, withContactInfo, includeInactive</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!role) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(...) ; } <span class="hljs-comment"><span class="hljs-comment">//...  }</span></span></code> </pre><br>  Dalam hal ini, fungsi kami, selain tanggung jawab pencariannya, juga akan melakukan validasi, dan kami hanya ingin menemukan pengguna dengan parameter tertentu.  Tentu saja, fungsi pencarian dapat mengambil fungsi validasi, tetapi kemudian daftar parameter input akan diperluas.  Ini juga merupakan minus dari pola pengkodean seperti itu. <br><br>  <b>Destrukturisasi</b> melibatkan memecah struktur yang kompleks menjadi bagian-bagian sederhana.  Dalam JavaScript, struktur kompleks seperti itu biasanya berupa objek atau array.  Menggunakan sintaksis penataan, Anda dapat mengekstrak fragmen kecil dari array atau objek.  Sintaks ini dapat digunakan untuk mendeklarasikan variabel atau tujuannya.  Anda juga dapat mengelola struktur bersarang menggunakan sintaksis dari penghancuran bersarang. <br><br>  Menggunakan destructure, fungsi dari contoh kita sebelumnya akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRule</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rule, withContactInfo, includeInactive}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    } findUsersByRule({ rule: 'finance', withContactInfo: true, includeInactive: true})</span></span></code> </pre><br>  Harap perhatikan bahwa fungsi kami terlihat hampir identik, kecuali bahwa kami menempatkan tanda kurung di sekitar parameter kami.  Alih-alih menerima tiga parameter berbeda, fungsi kami sekarang mengharapkan satu objek dengan properti: <code>rule</code> , <code>withContactInfo</code> dan <code>includeInactive</code> . <br><br>  Ini jauh lebih ambigu, lebih mudah dibaca dan dimengerti.  Selain itu, melewatkan atau urutan parameter kami yang lain tidak lagi menjadi masalah, karena sekarang parameter tersebut dinamai properti objek.  Kita juga bisa menambahkan parameter baru dengan aman ke deklarasi fungsi.  Selain itu, sejak  Karena merusak menyalin nilai yang diteruskan, perubahan fungsi tidak akan memengaruhi yang asli. <br><br>  Masalah dengan parameter yang diperlukan juga dapat diselesaikan dengan cara yang lebih elegan. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requiredParam</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requiredParamError = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">`Required parameter, "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">" is missing.`</span></span> ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRule</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rule = requiredParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'rule'</span></span></span></span></span><span class="hljs-function">), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withContactInfo</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">includeInactive</span></span></span><span class="hljs-function">} = </span></span>{}) {...}</code> </pre><br>  Jika kita tidak melewatkan nilai aturan, maka fungsi yang dilewati secara default akan berfungsi, yang akan menghasilkan pengecualian. <br><br>  Fungsi dalam JS hanya dapat mengembalikan satu nilai, sehingga Anda dapat menggunakan objek untuk mentransfer informasi lebih lanjut.  Tentu saja, kami tidak selalu membutuhkan fungsi untuk mengembalikan banyak informasi, dalam beberapa kasus kami akan puas dengan pengembalian primitif, misalnya, <code>findUserId</code> secara alami akan mengembalikan satu pengidentifikasi dengan beberapa syarat. <br><br>  Juga, pendekatan ini menyederhanakan komposisi fungsi.  Memang, dengan komposisi, fungsi seharusnya hanya mengambil satu parameter.  Pola RORO mematuhi kontrak yang sama. <br><br>  Bill Sourour: <i>â€œSeperti templat apa pun, RORO harus dilihat sebagai alat lain di kotak alat kami.</i>  <i>"Kami menggunakannya di tempat yang menguntungkan, membuat daftar parameter lebih mudah dimengerti dan fleksibel, dan nilai pengembalian lebih ekspresif."</i> <br><br><h2>  Pabrik es </h2><br>  Anda dapat menemukan artikel asli di tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Menurut penulis, templat ini adalah fungsi yang membuat dan mengembalikan objek beku. <br><br>  Bill berpikir.  bahwa dalam beberapa situasi pola ini dapat menggantikan kelas ES6 yang biasa bagi kita.  Misalnya, kami memiliki keranjang makanan tertentu di mana kami dapat menambah / menghapus produk. <br><br>  Kelas ES6: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ShoppingCart.js class ShoppingCart { constructor({db}) { this.db = db } addProduct (product) { this.db.push(product) } empty () { this.db = [] } get products () { return Object .freeze([...this.db]) } removeProduct (id) { // remove a product } // other methods } // someOtherModule.js const db = [] const cart = new ShoppingCart({db}) cart.addProduct({ name: 'foo', price: 9.99 })</span></span></code> </pre><br>  Objek yang dibuat menggunakan kata kunci <code>new</code> dapat berubah, yaitu  kita dapat mengganti metode instance kelas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = [] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShoppingCart({db}) cart.addProduct = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'nope!'</span></span> <span class="hljs-comment"><span class="hljs-comment">//   JS  cart.addProduct({ name: 'foo', price: 9.99 }) // output: "nope!"    </span></span></code> </pre><br>  Juga harus diingat bahwa kelas-kelas di JS diimplementasikan pada delegasi prototipe, oleh karena itu, kita dapat mengubah implementasi metode dalam prototipe kelas dan perubahan-perubahan ini akan mempengaruhi semua instance yang ada (saya membicarakan hal ini secara lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang OOP</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShoppingCart({<span class="hljs-attr"><span class="hljs-attr">db</span></span>: []}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> other = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShoppingCart({<span class="hljs-attr"><span class="hljs-attr">db</span></span>: []}) ShoppingCart.prototype .addProduct = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'nope!'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     JS cart.addProduct({ name: 'foo', price: 9.99 }) // output: "nope!" other.addProduct({ name: 'bar', price: 8.88 }) // output: "nope!"</span></span></code> </pre><br>  Setuju, fitur tersebut dapat menyebabkan kita banyak masalah. <br><br>  Masalah umum lainnya adalah menetapkan metode instance ke pengendali event. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span> .querySelector(<span class="hljs-string"><span class="hljs-string">'#empty'</span></span>) .addEventListener( <span class="hljs-string"><span class="hljs-string">'click'</span></span>, cart.empty )</code> </pre><br>  Mengklik tombol tidak akan mengosongkan keranjang.  Metode ini menetapkan properti baru ke tombol kami bernama db dan menyetel properti ini ke [] alih-alih memengaruhi db objek keranjang.  Namun, tidak ada kesalahan di konsol, dan akal sehat Anda akan memberi tahu Anda bahwa kode harus bekerja, tetapi tidak. <br><br>  Agar kode ini berfungsi, Anda harus menulis fungsi panah: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span> .querySelector(<span class="hljs-string"><span class="hljs-string">"#empty"</span></span>) .addEventListener( <span class="hljs-string"><span class="hljs-string">"click"</span></span>, () =&gt; cart.empty() )</code> </pre><br>  Atau ikat konteks dengan ikat: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span> .querySelector(<span class="hljs-string"><span class="hljs-string">"#empty"</span></span>) .addEventListener( <span class="hljs-string"><span class="hljs-string">"click"</span></span>, cart.empty.bind(cart) )</code> </pre><br>  <b>Pabrik Es</b> akan membantu kita menghindari perangkap ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeShoppingCart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ db }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ addProduct, empty, getProducts, removeProduct, <span class="hljs-comment"><span class="hljs-comment">// others }) function addProduct (product) { db.push(product) } function empty () { db = [] } function getProducts () { return Object .freeze([...db]) } function removeProduct (id) { // remove a product } // other functions } // someOtherModule.js const db = [] const cart = makeShoppingCart({ db }) cart.addProduct({ name: 'foo', price: 9.99 })</span></span></code> </pre><br>  Fitur dari pola ini: <br><br><ul><li>  tidak perlu menggunakan kata kunci baru </li><li>  tidak perlu mengikat ini </li><li>  kereta sepenuhnya portabel </li><li>  variabel lokal dapat dideklarasikan yang tidak akan terlihat dari luar </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeThing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spec</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secret = <span class="hljs-string"><span class="hljs-string">'shhh!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ doStuff }) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    secret } } // secret    const thing = makeThing() thing.secret // undefined</span></span></code> </pre><br><ul><li>  Pola mendukung warisan </li><li>  membuat objek menggunakan Ice Factory lebih lambat dan membutuhkan lebih banyak memori daripada menggunakan kelas (Dalam banyak situasi, kita mungkin perlu kelas, jadi saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini) </li><li>  ini adalah fungsi umum yang dapat ditetapkan sebagai panggilan balik </li></ul><br><h2>  Kesimpulan </h2><br>  Ketika kita berbicara tentang arsitektur perangkat lunak yang dikembangkan, kita harus selalu membuat kompromi yang nyaman.  Tidak ada aturan dan batasan ketat dalam jalur ini, setiap situasi unik, jadi semakin banyak pola dalam gudang senjata kita, semakin besar kemungkinan kita akan memilih opsi arsitektur terbaik dalam situasi tertentu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472816/">https://habr.com/ru/post/id472816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472798/index.html">Peta Yandex untuk aplikasi Taksi</a></li>
<li><a href="../id472802/index.html">MIRO adalah platform robot terbuka dalam ruangan. Bagian 2 - Desain Robot</a></li>
<li><a href="../id472810/index.html">Untuk administrator sistem awal: cara membuat pesanan dari kekacauan</a></li>
<li><a href="../id472812/index.html">Apakah server "padam" jika tes asap dari pusat data "terbakar"?</a></li>
<li><a href="../id472814/index.html">Mesin virtual pertama saya: bagaimana tidak mengacaukan</a></li>
<li><a href="../id472818/index.html">Gerakan Kolektif: Bagaimana Para Ilmuwan Semut Gabus Belajar</a></li>
<li><a href="../id472822/index.html">Ketika Akademi Ilmu Pengetahuan Rusia tidak berdaya</a></li>
<li><a href="../id472826/index.html">Interaksi mikro dan penggunaannya dalam antarmuka pengguna</a></li>
<li><a href="../id472830/index.html">Cara menulis kode yang mudah dijelaskan</a></li>
<li><a href="../id472832/index.html">Lokalisasi atau Adaptasi Kreatif? Studi Kasus Game Streets of Rogue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>