<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦐 🦌 👃🏻 Machine Learning para Vertica 👨🏻‍🚀 🎤 👖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotación 
 En este artículo quiero compartir mi propia experiencia con el aprendizaje automático en un almacén de datos en Vertica. 

 Francamente, n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machine Learning para Vertica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436306/"><h2>  Anotación </h2><br>  En este artículo quiero compartir mi propia experiencia con el aprendizaje automático en un almacén de datos en Vertica. <br><br>  Francamente, no soy un analista experto que podrá describir en detalle toda la variedad de métodos de investigación y algoritmos de predicción de datos.  Pero aún así, como soy un experto en Vertica y tengo experiencia básica con ML, trataré de hablar sobre formas de trabajar con el análisis predictivo en Vertica utilizando la funcionalidad del servidor incorporado y el lenguaje R. <br><br><h2>  Biblioteca de aprendizaje automático Vertica </h2><br>  A partir de la versión 7, Vertica se ha ampliado con la biblioteca Machine Learning, con la que puede: <br><br><ul><li>  Prepare ejemplos de datos para el aprendizaje automático </li><li> entrenar modelos de aprendizaje automático sobre datos preparados; </li><li>  Realizar análisis predictivos de datos de almacenamiento en modelos de aprendizaje automático guardados. </li></ul><br>  La biblioteca viene inmediatamente con la instalación de Vertica para todas las versiones, incluida la Comunidad gratuita.  Trabajar con él se enmarca en forma de una llamada a funciones desde SQL, que se describen en detalle en la documentación con ejemplos de uso en datos de demostración preparados. <br><a name="habracut"></a><br><h2>  Un ejemplo de trabajo con ML en Vertica </h2><br>  Como un ejemplo simple de cómo funciona ML, tomé los datos de demostración de mtcars que forman parte del ejemplo de datos ML para Vertica.  Estos datos incluyen dos tablas: <br><br><ul><li>  mtcars_train: datos preparados para entrenar modelos de aprendizaje automático </li><li>  mtcars - datos para análisis </li></ul><br>  Veamos los datos para el entrenamiento: <br><br><pre><code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars_train;</code> </pre> <br><img src="https://habrastorage.org/webt/mu/4_/o0/mu4_o0ovpeupz4c3qkf1uvnegya.jpeg"><br><br>  En el conjunto de datos sobre modelos de automóviles, se describen sus características.  Intentemos entrenar el aprendizaje automático para que, de acuerdo con las características de los automóviles, sea posible predecir qué tipo de caja de cambios está involucrada en el automóvil: una caja manual o una caja de cambios automática.  Para hacer esto, necesitaremos construir un modelo de regresión logística en los datos preparados, encontrando la dependencia del tipo de caja del campo "am" y los campos de peso del vehículo "wt", el número de cilindros "cyl" y el número de velocidades en el cuadro "gear": <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> LOGISTIC_REG(<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>, <span class="hljs-string"><span class="hljs-string">'mtcars_train'</span></span>, <span class="hljs-string"><span class="hljs-string">'am'</span></span>, <span class="hljs-string"><span class="hljs-string">'cyl, wt, gear'</span></span>); Finished in 19 iterations</code> </pre> <br>  La función llamada analizó la relación entre am y los campos cyl, wt, gear, reveló la fórmula de dependencia y escribió el resultado de la simulación de la dependencia en la base de datos Vertica en el modelo "logistic_reg_mtcars".  Con este modelo guardado, ahora puede analizar datos sobre automóviles y predecir la disponibilidad de cajas de cambios automáticas. <br><br>  Se puede ver información sobre el modelo: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GET_MODEL_SUMMARY(<span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> model_name=<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/hd/aj/gp/hdajgpkb3a4jvlq2-czafzt9mv0.jpeg"><br><br>  Ahora usamos el modelo en los datos para automóviles, guardando el resultado en una nueva tabla: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> mtcars_predict_results <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> car_model, am, PREDICT_LOGISTIC_REG(cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> model_name=<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prediction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars );</code> </pre> <br>  Y comparando los valores reales de am con los obtenidos en la predicción predicción: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars_predict_results;</code> </pre> <br><img src="https://habrastorage.org/webt/48/rt/zh/48rtzhy3c4ahjfqrupulpfy_mqy.jpeg"><br><br>  En este caso, el pronóstico para el 100% coincidió con el tipo real de cuadro en los modelos presentados.  En el caso de preparar nuevos datos para la capacitación, deberá eliminar y volver a guardar el modelo. <br><br><h2>  Funcionalidad ML en Vertica </h2><br>  La biblioteca Vertica ML admite los siguientes tipos de análisis predictivo: <br><br><ul><li>  <b>Previsión:</b> <br><ul><li>  Regresión lineal </li><li>  Bosque aleatorio para regresión </li><li>  SVM (Máquina de vectores de soporte) para regresión </li></ul></li><li>  <b>Clasificación:</b> <br><ul><li>  Regresión logística </li><li>  Bayes ingenuos </li><li>  Bosque aleatorio para clasificación </li><li>  SVM (Máquina de vectores de soporte) para clasificación </li></ul></li><li>  <b>Agrupamiento:</b> <br><ul><li>  k-significa </li></ul></li></ul><br>  Para preparar los datos para el entrenamiento, se presenta la siguiente funcionalidad: <br><br><ul><li>  Balance de datos </li><li>  Limpieza de emisiones </li><li>  Codificación de valores de columna categóricos (textuales) </li><li>  Reemplazar datos faltantes </li><li>  Normalización de datos. </li><li>  Análisis de componentes principales </li><li>  Muestreo de datos </li><li>  Descomposición de valores singulares </li></ul><br>  Teniendo en cuenta la funcionalidad de ML en Vertica, podemos decir que la biblioteca incorporada nos permite resolver una amplia gama de problemas, pero no tiene el trabajo atrasado para estudiar los patrones y las dependencias en los datos.  Existen funciones para preparar datos para el aprendizaje automático, pero sin visualizar la distribución de datos en forma de gráficos, solo los gurús del análisis con conocimiento experto de los datos analizados pueden "preparar" dichos datos y entrenar modelos de aprendizaje en ellos. <br><br><h2>  R Studio con Vertica </h2><br>  Para un análisis de datos predictivos más completo e interactivo, el lenguaje R es ideal, ya que tiene un entorno visual para trabajar con datos de R Studio.  Las ventajas tangibles de usar R con Vertica serán: <br><br><ul><li>  interactividad del entorno con la capacidad de guardar el estado para un análisis posterior después de la próxima ejecución; </li><li>  visualización visual de datos en forma de tablas y gráficos; </li><li>  Potencia de lenguaje R para trabajar con conjuntos de datos; </li><li>  Una variedad de algoritmos de análisis predictivo similares a los presentados en Vertica ML. </li></ul><br>  Las desventajas de trabajar con R con big data son los requisitos de RAM, la velocidad de trabajar con grandes arrays de datos y la necesidad de importar y exportar datos Vertica.  Estas deficiencias están cubiertas por la capacidad de incrustar funciones R escritas para la ejecución directa en un clúster en Vertica, que se describirá a continuación. <br><br><h2>  Una pequeña introducción a R </h2><br>  Reproduciremos el pronóstico para cuadros automáticos en datos Vertica usando R. Para no asustar a los programadores que no están familiarizados con este lenguaje, conduciré un curso corto de un joven luchador R. <br><br>  Entonces, el lenguaje R es el mismo lenguaje de procedimiento que tiene objetos, clases y funciones. <br>  Un objeto puede ser un conjunto de datos (vector, lista, conjunto de datos ...), valor (texto, número, fecha, hora ...) o una función.  Para los valores, se admiten los tipos numéricos, de cadena, booleanos y de fecha y hora.  Para los conjuntos de datos, la numeración de la matriz comienza en 1, no en 0. <br><br>  Clásicamente, en lugar de "=" en R, se usa el operador de asignación "&lt;-".  Aunque no está prohibido utilizar la asignación al otro lado "-&gt;" e incluso el habitual "=".  El operador "=" en sí mismo se usa cuando se llaman funciones para especificar parámetros con nombre. <br><br>  En lugar de "."  "$" se utiliza para acceder a los campos de los conjuntos de datos.  Un punto no es una palabra clave y se usa en nombres de objetos para aumentar su legibilidad.  Por lo tanto, "my.data $ field" se descifrará como una matriz de registros del campo "field" del conjunto de datos "my.data". <br><br>  Puede usar comillas simples o dobles para enmarcar textos. <br><br>  <b>Lo más importante:</b> R está orientado a trabajar con conjuntos de datos.  Incluso si el código dice "a &lt;-1", asegúrese de que R dentro de sí cree que "a" es una matriz de 1 elemento.  El diseño del lenguaje le permite trabajar con conjuntos de datos, como con variables ordinarias: sumar y restar, conectar y desconectar, filtrar por medidas.  La forma más fácil de crear una matriz que enumere sus elementos es llamar a la función "c (elementos de matriz separados por comas)".  El nombre "c" aparentemente se toma como una abreviatura corta de Collection, pero no lo diré con certeza. <br><br><h2>  Cargando datos de un DBMS en R </h2><br>  Para usar RDBMS a través de ODBC para R, debe instalar el paquete RODBC.  Se puede instalar en R Studio en la pestaña de paquetes o usando el comando R: <br><br><pre> <code class="plaintext hljs">install.packages('RODBC') library('RODBC')</code> </pre> <br><br>  Ahora podemos trabajar con Vertica.  Creamos un alias ODBC para el servidor y obtenemos los datos de prueba y el conjunto de datos completo para el automóvil: <br><br><pre> <code class="plaintext hljs">#    Vertica con &lt;- odbcConnect(dsn='VerticaDSN') #    mtcars_train mtcars.train &lt;- sqlQuery(con, "SELECT * FROM public.mtcars_train") #    mtcars&lt;/b&gt; mtcars.data &lt;- sqlQuery(con, "SELECT * FROM public.mtcars") #   odbcClose(con)</code> </pre> <br>  Al cargar datos de fuentes R para campos de tipos de texto y fecha-hora, su pertenencia a factores se establece automáticamente.  El campo "am" es de tipo numérico y R se percibe como un indicador numérico, y no como un factor, que no permitirá una regresión logística.  Por lo tanto, convertimos este campo a un factor numérico: <br><br><pre> <code class="plaintext hljs">mtcars.data$am = factor(mtcars.data$am) mtcars.train$am = factor(mtcars.train$am)</code> </pre> <br>  En R Studio, es conveniente ver interactivamente los datos, construir gráficos de análisis predictivo y escribir código en R con consejos: <br><br> <a href=""><img src="https://habrastorage.org/webt/r2/ft/b8/r2ftb85rnjcmpiblxomwdiicr7k.jpeg"></a> <br><br><h2>  Construyendo un modelo en R </h2><br>  Construiremos un modelo de regresión logística sobre el conjunto de datos preparado para las mismas dimensiones que en Vertica: <br><br><pre> <code class="plaintext hljs">mtcars.model &lt;- glm(formula = am ~ cyl + wt + gear, family = binomial(), data = mtcars.train)</code> </pre> <br>  <b>Explicación:</b> en el lenguaje R, la fórmula de análisis predictivo se indica como: <br><br><pre> <code class="plaintext hljs">&lt;  &gt;~&lt;   &gt;</code> </pre> <br><h2>  Análisis de datos del modelo en R </h2><br>  Inicializamos el conjunto de datos resultante, tomando de mtcars todos los registros para los campos requeridos: <br><br><pre> <code class="plaintext hljs">mtcars.result &lt;- data.frame(car_model = mtcars.data$car_model, am = mtcars.data$am, predict = 0)</code> </pre> <br>  Ahora, basado en el modelo construido, puede realizar un análisis de los datos en sí: <br><br><pre> <code class="plaintext hljs">mtcars.result$predict &lt;- predict.glm(mtcars.model, newdata = subset(mtcars.data, select = c('cyl', 'wt', 'gear')), type = 'response' )</code> </pre> <br>  El resultado del análisis se devuelve al campo de predicción como un porcentaje de la probabilidad del pronóstico.  Simplifique por analogía con Vertica a valores 0 o 1, considerando el pronóstico positivo con una probabilidad de más del 50%: <br><br><pre> <code class="plaintext hljs">mtcars.result$predict &lt;- ifelse(mtcars.result$predict &gt; 0.5, 1, 0)</code> </pre> <br>  Calculamos el número total de registros para los cuales el campo de predicción predicho no coincide con el valor real en am: <br><br><pre> <code class="plaintext hljs">nrow(mtcars[mtcars.result$am != mtcars.result$predict, ])</code> </pre> <br>  R devolvió cero.  Por lo tanto, el pronóstico convergió en todos los modelos de automóviles, como en el ML de Vertica. <br><br>  <b>Tenga en cuenta:</b> el filtro devolvió los registros de mtcars (el primer parámetro entre corchetes) con todas las columnas (el segundo parámetro se omitió después de la coma entre corchetes). <br><br><h2>  Guardar y cargar datos localmente en R </h2><br>  Al salir de R, el estudio sugiere guardar el estado de todos los objetos para continuar trabajando después de un reinicio.  Si por alguna razón necesita guardar y luego restaurar el estado de objetos individuales, para esto se proporcionan funciones especiales en R: <br><br><pre> <code class="plaintext hljs">#      save(mtcars.model, file = 'mtcars.model') #      load('mtcars.model')</code> </pre> <br><h2>  Guardar datos de R a Vertica </h2><br>  Si R Studio se usó para preparar datos para entrenar modelos ML Vertica, o si el análisis se realizó directamente en él, que luego se usará en la base de datos Vertica, los conjuntos de datos R se pueden escribir en la tabla Vertica. <br><br>  Dado que la biblioteca ODBC para R está diseñada para RDTPMS OLTP, no puede generar correctamente consultas de creación de tablas para Vertica.  Por lo tanto, para registrar datos con éxito, deberá crear manualmente la tabla necesaria en Vertica utilizando SQL, cuyo conjunto de campos y tipos coincide con el conjunto de datos grabables R. <br><br>  Además, el proceso de grabación en sí parece simple (no olvide abrir y luego cerrar la conexión): <br><br><pre> <code class="plaintext hljs">sqlSave(con, mtcars.result, tablename = 'public.mtcars_result', append = TRUE, rownames = FALSE, colnames = FALSE)</code> </pre> <br><h2>  Usando Vertica con R </h2><br>  El trabajo interactivo con datos en R Studio es adecuado para el modo de investigación y preparación de datos.  Pero es completamente inadecuado para el análisis de flujos de datos y grandes matrices en modo automático.  Una de las opciones para el esquema de análisis predictivo híbrido R con Vertica es la preparación de datos para aprender sobre R e identificar dependencias para construir modelos.  Luego, utilizando las funciones ML integradas en Vertica, los modelos de pronóstico para los datos preparados en R se entrenan teniendo en cuenta las dependencias identificadas de las variables. <br><br>  Hay una opción más flexible cuando toda la potencia del lenguaje R se usa directamente desde debajo de Vertica.  Para esto, Vertica desarrolló la distribución R en forma de una biblioteca de complementos que le permite utilizar funciones de transformación escritas directamente en el lenguaje R en consultas SQL. La documentación describe en detalle la instalación del soporte R para Vertica y los paquetes R adicionales necesarios para la operación, si los hay. <br><br><h2>  Guardar el modelo R en Vertica </h2><br>  Para utilizar el modelo de análisis preparado previamente por R Studio en las funciones de R que se ejecutan en Vertica, debe guardarlas en los servidores de Vertica.  Guardar localmente en cada servidor del clúster con un archivo no es conveniente ni confiable, se pueden agregar nuevos servidores al clúster y, al cambiar el modelo, deberá recordar volver a escribir todos los archivos nuevamente. <br><br>  La forma más conveniente es serializar el modelo R en texto y guardar la función Vertica como UDF, que devolverá este texto como una constante (no olvide abrir y luego cerrar la conexión): <br><br><pre> <code class="plaintext hljs">#     mtcars.model.text &lt;- rawToChar( serialize(mtcars.model, connection = NULL, ascii = TRUE)) #       Vertica # (     ) mtcars.func &lt;- paste0( "CREATE OR REPLACE FUNCTION public.MtCarsAnalizeModel() RETURN varchar(65000) AS BEGIN RETURN '", gsub("'", "''", mtcars.model.text), "'; END; GRANT EXECUTE ON FUNCTION public.MtCarsAnalizeModel() TO public;" ) #    Vertica sqlQuery(con, mtcars.func)</code> </pre> <br>  El método propuesto permite eludir la restricción de Vertica en los parámetros transmitidos en la función de transformación, donde solo se requiere la transferencia de constantes o expresiones de constantes.  Vertica UDF SQL compila no como funciones, sino como expresiones calculadas, es decir, al pasar un parámetro, en lugar de llamar a la función, se transferirá su texto (en este caso una constante), que se guardó en el código anterior. <br><br>  Si cambia el modelo, deberá recrear su función en Vertica.  Tiene sentido envolver este código en una función universal que genera una función en Vertica con el nombre especificado del modelo pasado. <br><br><h2>  Funciones R para Vertica </h2><br>  Para conectar las funciones R a Vertica, debe escribir funciones de análisis y registro de datos en Vertica. <br><br>  La función de trabajar con datos desde la propia Vertica debe tener dos parámetros: el conjunto de datos resultante (como data.frame) y los parámetros de trabajo (como la lista): <br><br><pre> <code class="plaintext hljs">MtCarsAnalize &lt;- function(data, parameters) { if ( is.null(parameters[['model']]) ) { stop("NULL value for model! Model cannot be NULL.") } else { model &lt;- unserialize(charToRaw(parameters[['model']])) } names(data) &lt;- c('car_model', 'cyl', 'wt', 'gear') result &lt;- data.frame(car_model = data$car_model, predict = 0) result$predict &lt;- predict.glm(model, newdata = subset(data, select = c('cyl', 'wt', 'gear')), type = 'response' ) result$predict &lt;- ifelse(result$predict &gt; 0.5, TRUE, FALSE) return(result) }</code> </pre> <br>  En el cuerpo de la función, se verifica que se pasa el parámetro del modelo, cuyo texto se traduce en forma binaria y se deserializa en el objeto del modelo de análisis.  Como Vertica transfiere sus propios nombres de campo al conjunto de datos para la función, los nombres de campo explícitos se establecen en el conjunto de datos.  En base a los datos obtenidos, se construye un conjunto de resultados con el nombre del modelo de máquina y cero predicción.  A continuación, se construye un pronóstico utilizando solo los campos necesarios para el análisis del conjunto de datos obtenido.  El campo de predicción del conjunto de resultados se establece en valores booleanos (para un cambio en lugar de valores numéricos) y el resultado se devuelve desde la función. <br><br>  Ahora queda por describir el registro de esta función en Vertica: <br><br><pre> <code class="plaintext hljs">MtCarsAnalizeFactory &lt;- function() { list(name = MtCarsAnalize, udxtype = c("transform"), intype = c("varchar", "int", "float", "int"), outtype = c("varchar", "boolean"), outnames = c("car_model", "predict"), parametertypecallback=MtCarsAnalizeParameters) } MtCarsAnalizeParameters &lt;- function() { parameters &lt;- list(datatype = c("varchar"), length = 65000, scale = c("NA"), name = c("model")) return(parameters) }</code> </pre> <br>  La función MtCarsAnalizeFactory describe el nombre de la función utilizada para la operación, el campo para el conjunto de datos entrantes y salientes, y la segunda función describe el parámetro "modelo" pasado.  Los tipos de campo son tipos de datos Vertica.  Al transmitir y devolver datos, Vertica convierte automáticamente los valores a los tipos de datos necesarios para el lenguaje R. Puede ver la tabla de compatibilidad de tipos en la documentación de Vertica. <br><br>  Puede probar el funcionamiento de la función escrita para Vertica en los datos cargados en R studio: <br><br><pre> <code class="plaintext hljs">test.data = subset(mtcars.data, select = c('car_model', 'cyl', 'wt', 'gear')) test.params = list(model = mtcars.model.text) test.result = MtCarsAnalize(test.data, test.params)</code> </pre> <br><h2>  Conecte la biblioteca de características a Vertica </h2><br>  Guardamos todas las funciones anteriores en un archivo "mtcars_func.r" y lo subimos a uno de los servidores desde el clúster Vertica en "/ home / dbadmin". <br><br>  <b>Un punto importante:</b> en R Studio, debe configurar la opción para guardar la traducción de líneas en archivos en modo Posix (LF).  Esto se puede hacer en las opciones globales, sección Código, pestaña Guardar.  Si está trabajando en Windows, de manera predeterminada, el archivo se guardará con un retorno de carro y no podrá cargarse en Vertica. <br><br>  Nos conectamos al servidor desde el clúster Vertica, en el que guardamos el archivo y cargamos la biblioteca: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIBRARY</span></span> MtCarsLibs <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'/home/dbadmin/mtcars_func.r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-string"><span class="hljs-string">'R'</span></span>;</code> </pre> <br>  Ahora desde esta biblioteca puedes registrar la función R: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> TRANSFORM <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.MtCarsAnalize <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-string"><span class="hljs-string">'R'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'MtCarsAnalizeFactory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIBRARY</span></span> MtCarsLibs; <span class="hljs-keyword"><span class="hljs-keyword">GRANT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> TRANSFORM <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.MtCarsAnalize(<span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>;</code> </pre> <br><h2>  Funciones de llamada R en Vertica </h2><br>  Llamamos a la función R, pasándole el texto del modelo, que se guardó previamente como una función UDF: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MtCarsAnalize(car_model, cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> = public.MtCarsAnalizeModel()) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars;</code> </pre> <br><img src="https://habrastorage.org/webt/8a/om/ve/8aomvezlxe_-0n4gnyonxkr25om.jpeg"><br><br>  Se puede verificar que, al igual que en los casos anteriores, el pronóstico es 100% consistente con el estado real de las cosas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.*, p.predict, p.predict = c.am::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars c <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MtCarsAnalize(car_model, cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> = public.MtCarsAnalizeModel()) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars ) p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.car_model = p.car_model</code> </pre> <br>  <b>Tenga en cuenta que</b> las funciones de transformación en Vertica devuelven su propio conjunto de datos de los campos y registros definidos dentro de las funciones, sin embargo, pueden usarse en consultas si se envuelven en una subconsulta. <br><br>  Cuando las funciones R están conectadas, Vertica copia el código fuente a su instalación, que compila en código máquina.  El archivo R de origen cargado en el servidor después de conectarse a la biblioteca no es necesario para seguir trabajando.  La velocidad de las funciones, teniendo en cuenta la compilación binaria, es lo suficientemente alta como para trabajar con grandes conjuntos de datos, sin embargo, vale la pena recordar que todas las operaciones R se llevan a cabo en la memoria y existe el riesgo de intercambio si falta memoria del sistema operativo para satisfacer las necesidades de colaboración de Vertica y R . <br><br>  Si se llama a la función en la partición de los datos especificados en PARTITION BY para OVER, Vertica paraleliza la ejecución de cada partición en los servidores del clúster.  Por lo tanto, si un fabricante aún estuviera presente en el conjunto de datos además del modelo de máquina, puede especificarlo en PARTICIÓN POR y paralelizar el análisis para cada fabricante. <br><br><h2>  Otras oportunidades de aprendizaje automático de Vertica </h2><br>  Además de R, Vertica puede desarrollar sus propias funciones de transformación en C, Java y Python.  Cada idioma tiene sus propios matices y características de escritura y conexión con Vertica.  Junto con su propio ML, todo esto le da a Vertica una buena reserva para el análisis predictivo de datos. <br><br><h2>  Gracias y enlaces </h2><br>  Quiero agradecer sinceramente a mi amigo y colega Vlad Malofeev de Perm, quien me presentó a R y me ayudó a resolverlo en uno de nuestros proyectos conjuntos. <br><br>  Inicialmente, en un proyecto donde se realizó un pronóstico sobre condiciones difíciles para el futuro utilizando datos del año pasado, los desarrolladores intentaron utilizar SQL y Java.  Esto causó grandes dificultades teniendo en cuenta la calidad de estas fuentes y ralentizó en gran medida el desarrollo del proyecto.  Vlad llegó al proyecto con R, conectamos R con Vertica, condujo los datos al estudio y todo giró y giró maravillosamente de inmediato.  Literalmente en semanas, todo lo que duró meses fue rastrillado, salvando el proyecto del código complejo. <br><br>  Los datos de ejemplo con automóviles se pueden descargar desde el repositorio de GIT: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/vertica/Machine-Learning-Examples</code> </pre> <br>  y subir a Vertica: <br><br><pre> <code class="plaintext hljs">/opt/vertica/bin/vsql -d &lt;name of your database&gt; -f load_ml_data.sql</code> </pre> <br>  Si desea profundizar en ML y aprender a trabajar con R, le recomiendo un libro en ruso <b>"R en acción".</b>  <b>Análisis y visualización de datos en el lenguaje R "</b> .  Está escrito en un lenguaje humano simple y accesible y es adecuado para principiantes que no se han encontrado con el aprendizaje automático. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> puede ver información sobre cómo conectar la biblioteca R a Vertica. <br><br>  Para aquellos que ya han comenzado a aprender y usar ML en Python, vale la pena prestar atención al IDE Rodeo, este es un análogo de R Studio, porque sin un análisis de calidad interactivo es imposible.  Creo que todo lo descrito en este artículo bajo R de una manera similar se puede desarrollar en Python, incluido guardar el modelo en funciones UDF y desarrollar funciones de análisis para Vertica.  Si marca, no olvide darse de baja de los resultados en los comentarios, le agradeceré la información. <br><br>  Gracias por su tiempo y espero haber podido demostrar la simplicidad y las increíbles capacidades de la simbiosis de R y Vertica. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436306/">https://habr.com/ru/post/es436306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436296/index.html">explícito en detalle</a></li>
<li><a href="../es436298/index.html">Ideas de la mesa: vinilo virtual</a></li>
<li><a href="../es436300/index.html">9 mejores prácticas de seguridad en Kubernetes</a></li>
<li><a href="../es436302/index.html">Experiencia de sustitución real de importaciones utilizando el sistema de almacenamiento ruso AERODISK</a></li>
<li><a href="../es436304/index.html">Zimbra Collaboration Suite y la lucha contra el phishing</a></li>
<li><a href="../es436308/index.html">Rostelecom puede convertirse en un monopolista en el mercado de centros de datos</a></li>
<li><a href="../es436310/index.html">Como lo hizo Ivan Metrics, DevOps lo hizo. Objeto de influencia</a></li>
<li><a href="../es436312/index.html">Síntesis de voz de la red neuronal utilizando la arquitectura Tacotron 2, o "Obtener alineación o morir en el intento"</a></li>
<li><a href="../es436314/index.html">Robo-hotel japonés "disparó" la mitad de sus robots debido a los problemas que crean</a></li>
<li><a href="../es436316/index.html">Cómo las tarjetas inteligentes ayudan a impulsar proyectos de TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>