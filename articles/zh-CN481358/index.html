<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐱 👩‍👩‍👦 🧛🏿 C ++俄罗斯：过去的样子 🛵 🙅 🔩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果在剧本开始时说C ++代码挂在墙上，那么到最后，它肯定会让您大跌眼镜。 

 比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup） 
 
 从10月31日至11月1日，圣彼得堡举办了C ++俄罗斯Piter会议，这是JUG Ru集团组织的俄罗斯最大的编程会议之一。 受邀的演讲者包括C +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++俄罗斯：过去的样子</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>如果在剧本开始时说C ++代码挂在墙上，那么到最后，它肯定会让您大跌眼镜。</i> <i><br><br></i>  <i>比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup）</i> <i><br></i> <br> 从10月31日至11月1日，圣彼得堡举办了C ++俄罗斯Piter会议，这是JUG Ru集团组织的俄罗斯最大的编程会议之一。 受邀的演讲者包括C ++标准化委员会的成员，CppCon的演讲者，O'Reilly的著作的作者以及LLVM，libc ++和Boost等项目的维护者。 该会议面向有经验的C ++开发人员，他们希望加深他们的专业知识并交流现场交流的经验。 向学生，研究生和大学教授提供非常优惠的折扣。 <br><br> 明年四月已经可以参观莫斯科会议的版本，但是现在我们的学生会告诉您他们在上一届活动中学到了什么有趣的东西。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i><a href="https://vk.com/album-77278886_270140987">会议相册的</a>照片</i> <br><br><h2> 关于我们 </h2><br> 圣彼得堡高等经济学院的两名学生从事以下工作： <br><br><ul><li> 丽莎·瓦西连科（Lisa Vasilenko）是四年级的本科生，研究“编程语言”的方向，并将其作为“应用数学和计算机科学”课程的一部分。 大学一年级熟悉C ++语言，随后在行业实习中获得了使用C ++语言的经验。 对通用语言和函数式编程语言的热情尤其在会议的报告选择上留下了印记。 <br></li><li>  Danya Smirnov是硕士课程“数据编程和分析”的一年级学生。 在学校的时候，他用C ++编写了Olympiad问题，然后由于某种原因该语言在教育活动中不断浮出水面，从而成为主要的语言。 我决定参加会议，以增进我的知识并了解新的机会。 <br></li></ul><br> 在时事通讯中，教职员工经常分享与我们专业相关的教育事件的信息。  9月，我们看到了有关C ++ Russia的信息，并决定注册为侦听器。 这是我们参加此类会议的第一次经验。 <br><br><h2> 会议结构 </h2><br><ul><li><h3> 报告书 </h3></li></ul><br> 在两天的时间里，专家们阅读了30份报告，重点介绍了许多热门话题：用于解决应用问题的语言功能的巧妙应用，由于新标准而导致的语言更新，C ++设计的折衷以及在处理后果时的预防措施，有趣的项目体系结构示例，以及语言基础架构的某些引擎部分。 同时，进行了3​​场演出，大多数是俄语的2场表演和英语的1场表演。 <br><br><ul><li><h3> 讨论区 </h3></li></ul><br> 演讲结束后，所有未解决的问题和不完整的讨论都被转移到带有标记板的演讲者指定的交流区域。 在表演之间进行休息的一种好方法，可以使对话愉快。 <br><br><ul><li><h3> 闪电谈话和非正式讨论 </h3></li></ul><br> 如果要作简短报告，可以在标记板上注册一个晚上的闪电谈话，并有五分钟的时间来谈论有关会议主题的任何事情。 例如，快速介绍了C ++的消毒剂（事实证明它是新的），或者一个关于正弦曲线生成中的错误的故事，您只能听到但看不到。 <br><br> 另一种形式是“与灵魂委员会”的小组讨论。 在舞台上，有一些标准化委员会的成员，在放映机上有个壁炉（官方上是为了营造一种深情的气氛，但是“因为一切都着火了”的原因似乎更有趣），这些问题是关于C ++的标准和一般性的，没有激烈的技术讨论和轻描淡写。 事实证明，活着的人也坐在委员会中，他们可能不完全确定某些事情，或者可能不知道某些事情。 <br><br> 对于爱好爱好者来说，第三场比赛仍然存在-BOF会议“反对C ++”。 在会议开始之前，我们带一个Go爱好者，一个C ++爱好者，他们共同准备了100500张关于该主题的幻灯片（例如C ++中的程序包问题或Go中缺少泛型），然后他们在彼此之间和听众之间进行了热烈的讨论，听众试图一次理解两种观点。 如果大头目不营业，主持人会干预并调解双方。 这种格式令人上瘾：开始几小时后，仅完成了一半的幻灯片。 最后必须大大加快。 <br><br><ul><li><h3> 合作伙伴展台 </h3></li></ul><br> 会议的合作伙伴在大厅里代表他们-在展位上谈论当前的项目，提供实习和就业，举行测验和小型比赛，还颁发了不错的奖项。 但是，有些公司甚至提出要接受采访的初始阶段，这不仅对那些来听报告的人有用。 <br><br><h2> 报告的技术细节 </h2><br> 我们这两天都听了报告。 有时很难从并行运行的报告中选择一份报告-我们同意共享和交流在休息期间获得的知识。 即使这样，似乎很多东西仍然丢失了。 在这里，我们想谈谈一些我们认为最有趣的报告的内容 <br><br><h3> 通过编译器优化的角度来看C ++中的异常Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">演示</a>幻灯片</i> <br><br> 顾名思义，Roman以LLVM为例研究了处理异常的方法。 同时，对于那些在工作中不使用Clang的人来说，该报告仍然可以对如何潜在地优化代码有所了解。 这是因为编译器的开发人员和相应的标准库相互通信，并且许多成功的解决方案可能会重合。 <br><br> 因此，要处理异常，您需要执行许多操作：调用处理代码（如果有）或释放当前级别的资源，然后将堆栈展开得更高。 所有这些导致了这样一个事实，即编译器添加了可能引发调用的其他指令。 因此，如果实际上没有引起异常，则程序仍将开始执行不必要的操作。 为了以某种方式减少开销成本，LLVM提供了几种启发式方法来确定不需要添加异常处理代码或可以减少“不必要”指令数量的情况。 <br><br> 演讲者考虑了其中的十几种，并展示了它们有助于加快程序执行速度的情况以及这些方法不适用的情况。 <br><br> 因此，罗曼·鲁斯亚耶夫（Roman Rusyaev）带领听众得出结论：包含异常工作的代码绝不能总是以零开销执行，并给出以下提示： <br><br><ul><li> 开发库时，原则上应该放弃异常； </li><li> 如果您仍然需要例外，则应尽可能添加noexcept（和const）修饰符，以便编译器可以进行尽可能多的优化。 </li></ul><br> 总体而言，发言者重申了这样一种观点，即最好将例外情况减到最少或将其全部放弃。 <br><br> 该报告幻灯片位于： <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">[“通过LLVM编译器优化的棱镜实现C ++异常”]</a> <br><br><h3> 生成器，协程和其他解开大脑的甜味，Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">演示</a>幻灯片</i> <br><br> 这次会议上许多致力于C ++ 20创新的报告之一，不仅被色彩斑presentation的演示文稿所记住，而且还清楚地标明了收集处理逻辑中存在的问题（例如，回调循环）。 <br><br>  Adi Shavit强调了以下内容：当前可用的方法遍历整个集合，并且不提供对某些内部中间状态的访问（或在回调的情况下提供，但具有许多不愉快的副作用，例如相同的Callback Hell）。 看起来好像有迭代器，但是使用它们并不是那么顺利：没有通用的入口和出口点（开始→结束与rbegin→递归等），目前尚不清楚我们将迭代多少？ 从C ++ 20开始，解决了这些问题！ <br><br> 第一种选择：范围。 由于迭代器之上的包装器，我们为迭代的开始和结束以及组成的可能性提供了一个公共接口。 所有这些使构建完整的数据处理管道变得很容易。 但是，并非所有事情都那么顺利：计算逻辑的一部分在特定迭代器的实现内部，该迭代器会使感知和调试的代码复杂化。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">演示</a>幻灯片</i> <br><br> 好吧，在这种情况下，协程在C ++ 20中添加了（其行为类似于Python中的生成器的函数）：可以通过返回一些当前值同时保持中间状态来延迟执行。 因此，我们不仅实现了数据出现时的处理，而且将所有逻辑封装在特定的协程内部。 <br><br> 但美中不足的是：目前它们仅得到现有编译器的部分支持，并且实现的程度也不如我们希望的那样准确：例如，协程中不应使用链接和临时对象。 另外，对协程可能有一些限制，此列表中不包括constexpr函数，构造函数/析构函数以及main。 <br><br> 因此，协程通过数据处理逻辑的简单性解决了很大一部分问题，但是它们的当前实现需要改进。 <br><br> 材料： <br><br><ul><li> 带有C ++俄罗斯的幻灯片- <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">[“生成器，协程和其他令人愉悦的甜味”]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">CppCon 2019的视频报告</a> </li></ul><br><h3>  Yandex.Taxi，Anton Polukhin的C ++技巧 </h3><br> 在他的专业活动中，有时您必须实现纯粹的辅助性工作：内部接口和某些库的API之间的包装，日志记录或解析。 但是，通常不需要任何其他优化。 但是，如果这些组件在Runet的某些最受欢迎的服务中使用，该怎么办？ 在这种情况下，您将不得不每小时仅处理1 TB的日志！ 然后，每一毫秒都是至关重要的，因此您必须诉诸各种技巧-Anton Polukhin谈到了它们。 <br><br> 也许最有趣的示例是指针到实现（pimpl）模式的实现。 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br> 在此示例中，首先要摆脱外部库的头文件-它将更快地编译，并且可以保护自己免受可能的名称冲突和其他类似错误的影响。 <br><br> 好的，将#include移到.cpp文件：您需要包装API的前向声明以及std :: unique_ptr。 现在，我们有了动态分配和其他不愉快的事情，例如分散在堆中的数据和减少的保证。 通过所有这些，std :: aligned_storage可以提供帮助。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br> 唯一的问题：您需要为每个包装指定大小和对齐方式-我们将使用参数&lt;T，SizeT，AlignmentT&gt;制作我们的pimpl模板，使用一些任意值，并向析构函数添加一个检查我们猜到的一切： <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br> 由于在析构函数的处理过程中已经确定了T，因此该代码将被正确地反汇编，并且在编译阶段将以错误的形式出现，它将显示需要输入的必要大小和对齐值。 因此，以另外一次编译为代价，我们摆脱了包装类的动态分配，通过实现将API隐藏在.cpp文件中，还获得了更适合处理器缓存的设计。 <br><br> 日志和解析似乎不那么令人印象深刻，因此在本评论中将不会提及。 <br><br> 报告幻灯片可在以下链接获得： <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">[“ C ++出租车技巧”]</a> <br><br><h3> 保持代码干燥的现代技术，BjörnFahller </h3><br> 在这次演讲中，BjörnFahller展示了几种处理样式缺陷的方法，例如重复的条件检查： <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br> 熟悉吗？ 使用最新标准中出现的几种强大的C ++技术，您可以优雅地实现相同的功能，而不会造成丝毫性能损失。 比较： <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br> 要处理无限数量的支票，系统会立即要求您使用可变参数模板和折叠表达式。 假设我们要检查几个变量与enum'a state_type元素的相等性。 首先想到的是编写is_any_of helper函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br> 这样的中间结果令人失望。 到目前为止，代码尚未变得可读： <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br> 非类型模板参数将有助于稍微改善这种情况。 在他们的帮助下，我们将枚举的枚举元素转移到模板参数列表中： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br> 在非典型模板参数（C ++ 17）中使用auto时，该方法可以简单地推广到不仅与state_type元素进行比较，而且还与可以用作非类型模板参数的基本类型进行比较： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br> 通过这些增量改进，可以实现所需的粗略检查语法： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br> 在此示例中，推论指南用于将所需的模板结构参数提示给知道构造函数自变量类型的编译器。 <br><br> 更有趣。  Bjorn讲授除了==之外，还对比较运算符进行泛化，然后对任意运算进行泛化。 与用例一起，说明了诸如no_unique_address属性（C ++ 20）和lambda函数（C ++ 20）中的模板参数之类的功能。  （是的，现在lambda语法更容易记住-这些是四对连续的各种括号。）使用函数作为构造器部件的最终解决方案确实使我感到振奋，更不用说在lambda微积分的最佳传统中使用元组表达式了。 <br><br> 最后，别忘了掩饰一下： <br><br><ul><li> 回想一下，lambdas是免费的constexpr； </li><li> 添加完善的转发并查看其在lambda闭包中应用于参数包的丑陋语法； </li><li> 让我们为编译器提供更多的条件无条件优化选项。 </li><li> 由于有明显的lambda返回值，因此我们将在模板中提供更清晰的错误输出。 这将迫使编译器在实际调用模板函数之前进行更多检查-在类型检查阶段。 </li></ul><br> 有关详细信息，请参阅讲座材料： <br><br><ul><li> 报告幻灯片： <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[使代码保持干燥的现代技术]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Github源代码</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">作者的博客文章</a> </li></ul><br><h2> 我们的印象 </h2><br> 我们第一次参加C ++ Russia就是因为它的丰富性。  C ++俄罗斯给人的印象是情感活动，学习与现场交流之间的界限几乎不明显。 从演讲者的心情到活动合作伙伴的竞赛，一切都有助于进行激烈的讨论。 会议的内容包括报告，涵盖了相当广泛的主题，包括C ++创新，大型项目实践中的示例以及意识形态体系结构方面的考虑。 但是剥夺事件的社会组成部分的注意力将是不公平的，这不仅有助于克服与​​C ++有关的语言障碍。 <br><br> 我们感谢会议的组织者有机会参加这样的活动！ <br> 您可以<a href="https://habr.com/ru/company/jugru/blog/480584/">在JUG Ru博客上</a>看到组织者关于C ++ Russia的过去，现在和将来的帖子。 <br><br> 感谢您的阅读，我们希望对事件的重述对您有所帮助！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481358/">https://habr.com/ru/post/zh-CN481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481348/index.html">Pentest活动目录。 第一部分</a></li>
<li><a href="../zh-CN481350/index.html">谁在普列塞茨克国际机场工作</a></li>
<li><a href="../zh-CN481352/index.html">DBA：从没有PK的表中清除克隆记录</a></li>
<li><a href="../zh-CN481354/index.html">TelegramBot。 基本功能。 分开飞，肉饼分开。 （第二部分）</a></li>
<li><a href="../zh-CN481356/index.html">谢谢，2019</a></li>
<li><a href="../zh-CN481360/index.html">本周结果：Rambler和Twitch同意，将在俄罗斯联邦引入电子劳务，Facebook将创建自己的操作系统</a></li>
<li><a href="../zh-CN481362/index.html">Docker Web应用程序的SSL证书</a></li>
<li><a href="../zh-CN481364/index.html">敏感家庭正在取代智能家居</a></li>
<li><a href="../zh-CN481366/index.html">RICE：产品经理的轻重缓急</a></li>
<li><a href="../zh-CN481368/index.html">相机盲测：iPhone，Pixel，三星和华为</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>