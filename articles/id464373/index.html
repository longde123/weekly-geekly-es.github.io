<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÄ üëá üç∞ Edge-to-edge di Android: melakukannya dengan benar üö¢ üçü üöµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Google I / O 2019 yang lalu membawa banyak inovasi yang sensasional, banyak di antaranya akan memengaruhi industri pengembangan seluler di tahun-tahun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Edge-to-edge di Android: melakukannya dengan benar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/464373/">  Google I / O 2019 yang lalu membawa banyak inovasi yang sensasional, banyak di antaranya akan memengaruhi industri pengembangan seluler di tahun-tahun mendatang.  Tidak kalah menarik untuk mengikuti tren yang muncul.  Pertama, tombol kontrol mekanis turun dalam sejarah, layar smartphone menjadi lebih besar dan bingkai samping menjadi lebih tidak mencolok.  Gerakan menggantikan tombol sistem di layar, menyisakan lebih banyak ruang untuk konsumsi konten.  Aplikasi ditampilkan pada seluruh permukaan layar yang terlihat, dari bawah ke bingkai atas, tanpa membatasi diri Anda ke batas bersyarat dari bilah status dan panel navigasi.  Kita berada di ambang era Edge-to-Edge. <br><br><img src="https://habrastorage.org/webt/xu/3i/ny/xu3inyrvy6ruyd_uj5j5l97pnf0.png"><br><a name="habracut"></a><br>  Apa itu Edge-to-Edge?  Dipahami secara harfiah, ini berarti bahwa aplikasi Anda harus ditampilkan pada seluruh permukaan layar yang terlihat, dari bawah ke bingkai atas, tanpa membatasi diri ke bilah status dan tombol navigasi yang lebih rendah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/119/459/053/11945905307bf673c909e4a75a270ba0.jpg"></div><br>  <i>Edge-to-edge pada contoh shell sistem Android.</i> <br><br>  Ketika berbicara tentang Android, ide sederhana masih jauh dari mudah diimplementasikan.  Pada artikel ini, kita akan berbicara tentang bagaimana memaksimalkan penggunaan semua ruang yang tersedia di layar perangkat apa pun, terlepas dari pabrikan, versi sistem, dan beragam pengaturan yang disukai pabrikan perangkat dari Kerajaan Tengah (dan tidak hanya) untuk menyenangkan pengguna.  Kode yang disajikan dalam artikel ini diuji pada lebih dari 30 perangkat oleh kami secara pribadi, dan pada 231 perangkat yang berbeda oleh 100 ribu pengguna aplikasi kami. <br><br>  Masalah membuat antarmuka tepi-ke-tepi bukanlah hal baru dalam dirinya sendiri dan relevan jauh sebelum I / O 2019. Tentunya, Anda masing-masing akan ingat bagaimana Anda pertama kali mencari sesuatu di Google dari kategori: <i>"status bar transparan android"</i> atau <i>"gradien status bar android" "</i> . <br><br>  Kriteria utama untuk aplikasi agar sesuai dengan judul edge-to-edge adalah: <br><br><ul><li>  Status Bar transparan; </li><li>  Panel Navigasi transparan. </li></ul><br>  Baca lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">material.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/18b/3a3/a2018b3a34a0d61b30d940f2c50c44fe.png"></div><br>  <i>Aplikasi Deezer Tidak Khawatir Tentang Kepatuhan Edge-to-Edge</i> <i><br></i> <br>  Penting untuk dicatat bahwa kita tidak berbicara tentang menghapusnya sepenuhnya, seperti dalam " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode layar penuh</a> ".  Kami memberikan kesempatan kepada pengguna untuk melihat informasi sistem yang penting dan menggunakan navigasi yang familier. <br><br>  Persyaratan yang sama pentingnya untuk solusi adalah skalabilitas dan ekstensibilitas.  Ada beberapa yang lain: <br><br><ul><li>  Geser layar dengan benar di atas keyboard tanpa merusak dukungan untuk bendera AdjustResize dari Aktivitas; </li><li>  Hindari overlay Bar Status dan Bar Navigasi pada elemen UI aplikasi, sambil menampilkan latar belakang yang sesuai di bawahnya; </li><li>  Bekerja pada semua perangkat dengan versi Android saat ini dan terlihat identik. </li></ul><br><h1>  Sedikit teori </h1><br>  Mungkin secara tak terduga membutuhkan banyak waktu untuk menemukan solusi untuk tugas yang tampaknya sederhana ini, yang tidak akan mudah bagi manajer proyek untuk menjelaskan.  Dan ketika QA masih menemukan smartphone yang naas, di mana layar Anda tidak terlihat "sesuai dengan kanon" ... <br>  Dalam proyek kami, kami keliru beberapa kali.  Hanya sebulan kemudian, setelah melalui serangkaian uji coba yang panjang, apakah kami menyelesaikan masalah itu untuk selamanya. <br><br>  Pertama-tama, Anda perlu memahami cara Android menggambar panel sistem.  Dimulai dengan Android 5.0, API yang nyaman disediakan untuk bekerja dengan inden sistem sepanjang tepi horizontal layar.  Mereka disebut WindowInsets, dan pada gambar di bawah ini berwarna merah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/f76/d86/bd4f76d86dd3508a88edf9618eab7a1b.png"></div><br>  Selain itu, pengembang dari tim Android telah menambahkan pendengar yang memungkinkan Anda berlangganan perubahan indentasi ini, misalnya, saat papan ketik muncul.  Sebenarnya, WindowInsets adalah margin dari file layout Anda dari tepi layar.  Saat mengubah ukuran Aktivitas Anda (mode layar terbagi, tampilan keyboard), Inset juga akan berubah.  Jadi, untuk mendukung edge-to-edge, kita perlu memastikan bahwa indentasi ini tidak ada.  Layar dengan null WindowInsets akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/197/cca/01d/197cca01df6de4ab8707131a70f8c993.png"></div><br><h1>  Implementasi </h1><br>  Dalam implementasi kami, kami akan secara aktif beroperasi di Window dan benderanya. <br>  Semua contoh akan ditulis dalam Kotlin, tetapi Anda dapat dengan mudah mengimplementasikannya di Jawa, menggunakan utilitas alih-alih fungsi ekstensi. <br><br>  Hal pertama yang harus dilakukan dengan elemen tata letak root adalah mengatur flag secara eksplisit: <br><br><pre><code class="kotlin hljs">android:fitsSystemWindows=<span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Ini diperlukan untuk memastikan bahwa Tampilan root digambar di bawah elemen sistem, serta untuk pengukuran Inset yang benar saat berlangganan perubahannya. <br>  Sekarang kita beralih ke hal yang paling penting - kita menghapus batas layar!  Namun, ini harus dilakukan dengan sangat hati-hati.  Dan inilah alasannya: <br><br><ol><li>  Mengalahkan Inset yang lebih rendah, kami berisiko kehilangan reaksi jendela terhadap tampilan keyboard: ada lusinan tips tentang StackOverflow untuk mengatur ulang Inset atas, tetapi yang lebih rendah diam diam.  Karena itu, NavigationBar tidak sepenuhnya transparan.  Saat mengatur ulang Inset yang lebih rendah, flag AdjustResize berhenti berfungsi. <br><br>  <b>Solusi:</b> Setiap kali Anda mengubah Inset, tentukan apakah ketinggian keyboard yang lebih rendah terdapat di dalamnya dan setel ulang saja sebaliknya. </li><li>  Ketika Anda mengatur ulang Inset, bagian-bagian Tampilan yang terlihat akan jatuh di bawah Bilah Status dan Bilah Navigasi.  Menurut konsep Desain Material (dan akal sehat), tidak ada elemen aktif yang harus ditempatkan di area sistem.  Artinya, di area ini tidak boleh ada tombol, bidang untuk memasukkan teks, kotak centang, dll. <br><br>  <b>Solusi:</b> kami akan menambahkan pendengar ke pendengar sehingga ketika mengubah WindowInsets, terjemahkan indentasi sistem ke Aktivitas, dan tanggapi secara internal dengan mengatur bantalan dan margin yang benar untuk Tampilan. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/73e/10e/3bd73e10ee50b6e2ae8a2da1b1bb2808.png"></div><br>  Perilaku ini seharusnya tidak diizinkan (Bilah Alat merayapi di Bilah Status). <br><br>  Fungsi <i>removeSystemInsets ()</i> terlihat seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeSystemInsets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ViewCompat.setOnApplyWindowInsetsListener(view) { _, insets -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = calculateDesiredBottomInset( view, insets.systemWindowInsetTop, insets.systemWindowInsetBottom, listener ) ViewCompat.onApplyWindowInsets( view, insets.replaceSystemWindowInsets(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset) ) } }</code> </pre><br>  Fungsi <i>calculDesiredBottomInset () menghitung</i> Inset bawah dengan atau tanpa keyboard, tergantung pada konfigurasi perangkat saat ini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateDesiredBottomInset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, topInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasKeyboard = isKeyboardAppeared(view, bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) bottomInset <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> listener(topInset, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desiredBottomInset }</code> </pre><br>  Gunakan metode <i>isKeyboardAppeared ()</i> untuk memeriksa ketinggian keyboard <i>.</i>  Kami memercayai hipotesis bahwa keyboard tidak dapat menempati kurang dari seperempat dari ketinggian layar.  Jika diinginkan, Anda dapat memodifikasi logika verifikasi sesuka Anda. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyboardAppeared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = bottomInset / resourdisplayMetrics.heightPixels.toDouble() &gt; .<span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre> <br>  Metode <i>removeSystemInsets ()</i> menggunakan pendengar.  Sebenarnya, ini hanya typealias untuk ekspresi lambda.  Kode lengkapnya: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> OnSystemBarsSizeChangedListener = (statusBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, navigationBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span></code> </pre> <br>  Langkah selanjutnya adalah mengatur transparansi ke bilah sistem: <br><br><pre> <code class="kotlin hljs">window.statusBarColor = Color.TRANSPARENT window.navigationBarColor = Color.TRANSPARENT</code> </pre> <br>  Setelah mengkompilasi semua hal di atas, kami memperoleh metode berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { InsetUtil.removeSystemInsets(window.decorView, listener) window.navigationBarColor = Color.TRANSPARENT window.statusBarColor = Color.TRANSPARENT }</code> </pre> <br>  Sekarang, untuk mengaktifkan mode ujung ke ujung dari Aktivitas yang diinginkan, Anda hanya perlu memanggil fungsi berikut dalam metode <i>onCreate ()</i> : <br><br><pre> <code class="kotlin hljs">setWindowTransparency { statusBarSize, navigationBarSize -&gt; <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Jadi, dalam waktu kurang dari 30 baris kode, kami telah mencapai efek "ujung-ke-ujung", sementara tidak melanggar prinsip-prinsip UX dan tanpa menghilangkan pengguna kontrol sistem yang biasa.  Implementasi seperti itu mungkin terlihat sederhana dan sepele bagi seseorang, tetapi itu yang memastikan operasi aplikasi Anda yang andal di perangkat apa pun. <br>  Anda dapat mencapai efek "ujung ke ujung" dalam sekitar seratus cara yang berbeda (jumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kiat semacam itu</a> tentang StackOverflow adalah konfirmasi yang jelas tentang hal ini), tetapi banyak di antaranya mengarah ke perilaku yang salah pada versi Android yang berbeda, atau tidak memperhitungkan parameter akun seperti kebutuhan untuk menampilkan lama. daftar, atau pecahkan ukuran layar saat menampilkan keyboard. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/955/a21/a0a/955a21a0a5422a4463fa0908c0427990.gif"></div><br><hr><br><h1>  Terbang di salep </h1><br>  Solusi yang dijelaskan dalam artikel ini cocok untuk semua perangkat saat ini.  Sebenarnya berarti perangkat di Android Lollipop (5.0) dan lebih tinggi.  Bagi mereka, solusi di atas akan bekerja dengan sempurna.  Tetapi untuk versi Android yang lebih lama, Anda akan membutuhkan implementasi Anda sendiri, karena tidak ada yang diketahui tentang WindowInsets pada masa itu. <br><br>  Berita baiknya adalah bahwa pada Android KitKat (4.4), transparansi panel sistem masih didukung.  Tetapi versi yang lebih lama tidak mendukung keindahan semacam itu sama sekali, Anda bahkan tidak dapat mencobanya. <br><br>  Mari kita fokus pada pergeseran Insets di Android 4.4.  Ini dapat dilakukan dalam metode <i>fitSystemWindows ()</i> .  Dengan demikian, elemen utama dalam tata letak Anda harus berupa wadah dengan metode fitSystemWindows yang ditimpa yang berisi implementasi yang persis sama dengan pendengar kami dalam contoh untuk versi Android saat ini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KitkatTransparentSystemBarsFrame</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyleAttr: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = -<span class="hljs-number"><span class="hljs-number">1</span></span> ) : FrameLayout(context, attrs, defStyleAttr), KitkatTransparentSystemBarsContainer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onSystemInsetsChangedListener: OnSystemInsetsChangedListener = { _, _ -&gt; } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fitSystemWindows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(insets: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Rect</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { insets ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = InsetUtil.calculateDesiredBottomInset( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, insets.top, insets.bottom, onSystemInsetsChangedListener ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.fitSystemWindows(Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset)) }</code> </pre><br>  Pada perangkat dengan Android 4.4, hanya sebagian transparansi yang bekerja melalui pengaturan bendera yang transparan: <br><br><pre> <code class="kotlin hljs">window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION )</code> </pre> <br>  Bendera ini membuat bilah sistem transparan, menambahkan sedikit gradien pada mereka, yang, sayangnya, tidak dapat dihapus.  Namun, gradien dapat diubah menjadi bilah warna transparan menggunakan pustaka ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/jgilfelt/SystemBarTint</a> .  Dia telah membantu kami lebih dari sekali di masa lalu.  Perubahan terbaru dibuat ke perpustakaan 5 tahun yang lalu, jadi itu hanya akan mengungkapkan daya tariknya ke kota retrograde sejati. <br><br>  Seluruh proses penandaan untuk Kitkat akan terlihat seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparencyKitkat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( rootView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KitkatTransparentSystemBarsContainer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemBarsSizeChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { rootView.onSystemBarsSizeChangedListener = listener window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION ) }</code> </pre> <br>  Dengan mengingat hal ini, kami menulis metode universal yang dapat membuat bilah sistem transparan (atau setidaknya tembus), terlepas dari aplikasi mana yang berjalan pada perangkat dengan versi Android mana: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP -&gt; setWindowTransparency(::updateMargins) Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT -&gt; setWindowTransparencyKitkat(root_container, ::updateMargins) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*do nothing*/</span></span> } }</code> </pre><br>  Di bawah spoiler di bawah ini, Anda dapat melihat bagaimana sampel yang disajikan dalam artikel terlihat pada beberapa perangkat bermasalah: <br><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar</b> <div class="spoiler_text">  Huawei Honor 8, Android 7.0 <br><br><img src="https://habrastorage.org/webt/vb/iq/vb/vbiqvbaw6ncicr9zaramjgp7rw4.png"><br><br>  Xiaomi Redmi Note 4, Android 6.1 <br><br><img src="https://habrastorage.org/webt/oa/qz/09/oaqz09dbvoqd9lvdrqmvd_db2lq.png"><br><br>  HTC Desire Dual Sim, Android 4.4.2 <br><br><img src="https://habrastorage.org/webt/qa/tj/og/qatjogphzqsrtj59iep-bnnqdyw.png"><br><br>  Samsung J3, Android 7.0 <br><br><img src="https://habrastorage.org/webt/_u/tm/gj/_utmgjk86esswybhkri_ropcghw.jpeg"><br><br>  M3 Meizu, Android 5.1 <br><br><img src="https://habrastorage.org/webt/5m/9b/7f/5m9b7f0wc6g3vodq2jimsaqichm.jpeg"><br><br>  Asus Zenfone 3 Max, Android 6.0 <br><br><img src="https://habrastorage.org/webt/ye/t5/9l/yet59l_2qgcqsdbnps2jgwgvx3g.jpeg"><br><br>  Umi Rome, Android 5.0 <br><br><img src="https://habrastorage.org/webt/qn/th/zp/qnthzp8jdtsobkl2t5c_et3iada.png"><br><br>  Nexus 5X, Android 8.0 <br><br><img src="https://habrastorage.org/webt/t7/9j/mo/t79jmolqrgeimm_0ylppf3nwwrk.png"><br><br>  Samsung Galaxy S8, Android 9.0 <br><br><img src="https://habrastorage.org/webt/to/cg/ab/tocgabznqxu36_wp1-d9aou0hbe.jpeg"><br></div></div><br><hr><br>  Sebagai kesimpulan, saya ingin mengatakan bahwa solusi untuk tugas yang tampaknya sederhana seperti pengaturan transparansi untuk elemen-elemen dari sistem UI dapat menyeret Anda di sepanjang berbagai macam jebakan dan pada akhirnya tidak mengarah pada hasil yang diinginkan, tetapi justru akan menyebabkan bug yang tidak menyenangkan.  Untung Anda memiliki artikel ini sekarang. <br><br>  Anda dapat menemukan daftar lengkap program dan contoh pekerjaan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori git</a> kami. <br><br>  Materi ini terinspirasi oleh laporan Chris Banes "Menjadi tukang jendela utama". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_mGDMVRO3iE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Saya mengucapkan terima kasih kepada Surf studio dan Evgeny Saturov atas bantuannya dalam mempersiapkan materi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464373/">https://habr.com/ru/post/id464373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464361/index.html">Intel Quartz Canyon - NUC untuk Profesional</a></li>
<li><a href="../id464365/index.html">Security Week 34: kerentanan luar biasa di Windows</a></li>
<li><a href="../id464367/index.html">Dan lain-lain 0day Eskalasi Privilege Lokal Klien Windows Steam</a></li>
<li><a href="../id464369/index.html">Blocker mana yang Anda gunakan? Hasil</a></li>
<li><a href="../id464371/index.html">/etc/resolv.conf untuk opsi Kubernetes, ndots: 5, karena ini dapat mempengaruhi kinerja aplikasi</a></li>
<li><a href="../id464375/index.html">Cara kerja mesin pencari</a></li>
<li><a href="../id464377/index.html">Hacker assembler kotor 6502</a></li>
<li><a href="../id464381/index.html">Perjalanan ke Alaska, atau KDD'19 melalui mata seorang saksi mata</a></li>
<li><a href="../id464383/index.html">Bagaimana saya menertibkan suatu proyek di mana ada hutan langsung (pengaturan tslint, lebih cantik, dll)</a></li>
<li><a href="../id464385/index.html">Python sebagai kasus akhir C ++. Bagian 1/2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>