<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üë®üèæ‚Äçüéì ‚ùé Resolvendo um Crackme simples para Sega Mega Drive üìó üë®‚Äçüë©‚Äçüë¶ ‚Ü™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal 





 Apesar da minha grande experi√™ncia em reverter jogos para o Sega Mega Drive , nunca decidi decifrar e eles n√£o me apareceram na Int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolvendo um Crackme simples para Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Ol√° pessoal </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Apesar da minha grande experi√™ncia em reverter jogos para o <code>Sega Mega Drive</code> , nunca decidi decifrar e eles n√£o me apareceram na Internet.  Mas, outro dia, houve um crackie engra√ßado que queria resolver.  Partilho com voc√™ a decis√£o ... <a name="habracut"></a></p><br><h2 id="opisanie">  Descri√ß√£o do produto </h2><br><p>  A descri√ß√£o da tarefa e o rum em si podem ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">baixados aqui</a> . </p><br><p>  Apesar do fato de a lista de recursos indicar Hydra, o padr√£o de fato entre as ferramentas para depura√ß√£o e revers√£o de jogos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Sega</a> √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Smd Ida Tools</a> .  Tem tudo o que voc√™ precisa para resolver este creme: </p><br><ul><li>  Carregador de rum para Ida </li><li>  Depurador </li><li>  Ver e alterar a mem√≥ria RAM / VDP </li><li>  Exibir informa√ß√µes quase completas no VDP </li></ul><br><p>  Colocamos a vers√£o mais recente nos plugins do Ide e come√ßamos a ver o que temos. </p><br><h2 id="reshenie">  Solu√ß√£o </h2><br><p>  O lan√ßamento de qualquer jogo Shogi come√ßa com a execu√ß√£o do vetor <code>Reset</code> .  Um ponteiro para ele pode ser encontrado no segundo DWORD desde o in√≠cio do rum. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Vemos algumas fun√ß√µes n√£o identificadas come√ßando no endere√ßo <code>0x27A</code> .  Vamos ver o que h√° l√°. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  <code>VBLANK</code> minha pr√≥pria experi√™ncia, direi que isso geralmente parece a fun√ß√£o de esperar pela interrup√ß√£o do <code>VBLANK</code> .  Vamos ver onde mais existem chamadas para a vari√°vel <code>byte_FF0026</code> : </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Vemos que o bit zero √© apenas definido na interrup√ß√£o <code>VBLANK</code> .  Ent√£o, chamamos a vari√°vel <code>vblank_ready</code> , e a fun√ß√£o em que est√° marcada √© <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Em seguida, a fun√ß√£o <code>sub_60E</code> √© chamada pelo c√≥digo.  Vamos ver o que h√° l√°: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  O que o primeiro comando grava no <code>VDP_CTRL</code> √© o comando de controle <code>VDP</code> .  Para descobrir o que ela est√° fazendo, mantemos esse comando e pressionamos a tecla <code>J</code> : </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Vemos que a entrada no <code>CRAM</code> (o local onde as paletas est√£o armazenadas) √© inicializada.  Isso significa que todo o c√≥digo de fun√ß√£o subsequente simplesmente define algum tipo de paleta inicial.  Consequentemente, a fun√ß√£o pode ser chamada de <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Vemos que algum comando √© novamente transferido para <code>VDP_CTRL</code> , depois pressione <code>J</code> e descobrimos que esse comando inicializa a grava√ß√£o na mem√≥ria de v√≠deo: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Al√©m disso, para entender o que √© transferido para a mem√≥ria de v√≠deo, n√£o faz sentido.  Portanto, simplesmente chamamos a fun√ß√£o <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Quase o mesmo acontece aqui como na fun√ß√£o anterior, portanto, sem entrar em detalhes, simplesmente chamamos a fun√ß√£o <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  J√° existe mais c√≥digo.  Al√©m disso, outra fun√ß√£o √© chamada nessa fun√ß√£o.  Vamos dar uma olhada - em <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Vemos que, no registro <code>D0</code> o comando para <code>VDP_CTRL</code> , em <code>D1</code> - o valor com o qual <code>VRAM</code> ser√° preenchido, e em <code>D2</code> e <code>D3</code> - a largura e a altura do preenchimento (porque ocorre dois ciclos: interno e externo).  Chame a fun√ß√£o fill_vram_by_addr. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Voltamos √† fun√ß√£o anterior.  Depois que o valor no registro <code>D0</code> for transmitido como um comando para <code>VDP_CTRL</code> , pressione a tecla <code>J</code> no valor.  Temos: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Novamente, com a experi√™ncia de reverter jogos para a Sega, posso dizer que esse comando inicializa a grava√ß√£o de blocos de mapeamento.  Os endere√ßos que come√ßam em <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> em 90% dos casos ser√£o endere√ßos de regi√µes com esses mesmos mapeamentos.  O que s√£o mapeamentos: <br>  esses s√£o os valores com os quais voc√™ pode especificar onde exibir esse ou aquele bloco na tela (um bloco √© um quadrado de <code>8x8</code> pixels). </p><br><p>  Portanto, a fun√ß√£o pode ser chamada como <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  O primeiro comando inicializa o registro no endere√ßo <code>$F000</code> .  Uma observa√ß√£o: entre os endere√ßos do " <em>mapeamento</em> ", ainda existe uma regi√£o onde a tabela de sprites est√° armazenada (essas s√£o suas posi√ß√µes, blocos para os quais apontam etc.) Descubra qual regi√£o √© respons√°vel pelo que pode ser depurado.  Mas, por enquanto, n√£o precisamos disso, ent√£o vamos chamar a fun√ß√£o <code>init_other_mappings</code> . </p><br><p>  Al√©m disso, vemos que nessa fun√ß√£o duas vari√°veis ‚Äã‚Äãs√£o inicializadas: <code>word_FF000A</code> e <code>word_FF000C</code> .  Pela minha pr√≥pria experi√™ncia (sim, ele decide), direi que se duas vari√°veis ‚Äã‚Äãestiverem pr√≥ximas no espa√ßo de endere√ßo e estiverem associadas ao mapeamento, na maioria dos casos elas ser√£o as coordenadas de algum objeto (por exemplo, um sprite).  Portanto, sugiro cham√°-los de <code>sprite_pos_x</code> e <code>sprite_pos_y</code> .  O erro em <code>x</code> e <code>y</code> permitido, pois  ainda mais na depura√ß√£o, ser√° f√°cil de corrigir. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Como o loop vai al√©m no c√≥digo, podemos assumir que conclu√≠mos a inicializa√ß√£o b√°sica.  Agora voc√™ pode ver a interrup√ß√£o do <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  Vemos que duas vari√°veis ‚Äã‚Äãest√£o aumentando (o que √© estranho, na lista de links para cada uma delas est√° absolutamente vazia).  Mas, como s√£o atualizados uma vez por quadro, voc√™ pode cham√°-los de <code>timer1</code> e <code>timer2</code> . </p><br><p>  Em seguida, a fun√ß√£o <code>sub_2FE</code> √© <code>sub_2FE</code> .  Vamos ver o que h√° l√°: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  E l√° - trabalhe com a porta <code>IO_CT1_DATA</code> (respons√°vel pelo primeiro joystick).  O endere√ßo da porta √© carregado no registro <code>A0</code> e passado para a fun√ß√£o <code>sub_310</code> .  N√≥s vamos l√°: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Minha experi√™ncia me ajuda novamente.  Se voc√™ vir o c√≥digo que funciona com o joystick e duas vari√°veis ‚Äã‚Äãna mem√≥ria, uma armazena as <code>pressed keys</code> e a segunda mant√©m as <code>held keys</code> , ou seja,  apenas pressione e segure as teclas.  Ent√£o, vamos chamar essas vari√°veis: <code>pressed_keys</code> e <code>held_keys</code> .  E ent√£o a fun√ß√£o pode ser chamada como <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Chame a fun√ß√£o como <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Loop do manipulador </h2><br><p>  Agora tudo parece muito mais claro: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Portanto, esse ciclo responde √†s teclas pressionadas e executa as a√ß√µes correspondentes.  Vamos analisar cada uma das fun√ß√µes chamadas no loop. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  H√° muito c√≥digo.  Vamos come√ßar com a primeira fun√ß√£o chamada: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Ela n√£o faz nada - pode parecer t√£o a princ√≠pio.  O retorno da fun√ß√£o atual √© <code>rts</code> .  Mas porque  somente saltos ( <code>bsr</code> ) ocorrem nele, o que significa que os <code>rts</code> nos retornam de volta ao loop do manipulador.  Eu chamaria essa fun√ß√£o como <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Em seguida, vemos a chamada para a vari√°vel <code>word_FF000E</code> .  Ele n√£o √© usado em nenhum lugar, exceto na fun√ß√£o atual e, a princ√≠pio, o objetivo dela n√£o estava claro para mim.  Mas, se voc√™ observar com aten√ß√£o, podemos assumir que essa vari√°vel √© necess√°ria apenas para um pequeno atraso entre o processamento de pressionamentos de tecla.  ( <em>Ele j√° est√° mal implementado neste rum, mas acho que sem essa vari√°vel seria muito pior</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  A seguir, temos uma grande quantidade de c√≥digo que de alguma forma processa as <code>sprite_pos_y</code> e <code>sprite_pos_y</code> , que podem falar apenas de uma coisa - isso √© necess√°rio para exibir o sprite de sele√ß√£o em torno do caractere selecionado no alfabeto. </p><br><p>  Portanto, agora voc√™ pode nomear com seguran√ßa a fun√ß√£o como <code>update_selection</code> .  Vamos seguir em frente. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  O c√≥digo verifica se os bits de algumas teclas pressionadas est√£o configuradas e chama determinadas fun√ß√µes.  Vamos olhar para eles. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Algum tipo de magia xam√¢nica.  Primeiro, o <code>WORD</code> √© obtido da vari√°vel <code>word_FF0018</code> , em seguida, uma instru√ß√£o interessante √© executada: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Este comando simplesmente salta para a instru√ß√£o a seguir. </p><br><p>  Em seguida √© outra m√°gica: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  O valor no registro <code>D0</code> √© colocado no topo da pilha.  Vale ressaltar que, para Shogi, como para alguns <code>x86</code> , o endere√ßo de retorno da fun√ß√£o quando √© chamada √© colocado no topo da pilha.  Consequentemente, a primeira instru√ß√£o coloca um endere√ßo no topo e a segunda a levanta da pilha e faz uma transi√ß√£o ao longo dela.  <u>Bom truque</u> . </p><br><p>  Agora voc√™ precisa entender qual √© esse valor na vari√°vel, que passa por isso.  Mas primeiro, vamos chamar essa vari√°vel <code>jmp_addr</code> . </p><br><p>  E as fun√ß√µes ser√£o chamadas assim: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Descubra onde essa vari√°vel √© preenchida.  N√≥s olhamos para a lista de refer√™ncias: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  H√° apenas um lugar para gravar nessa vari√°vel.  Vamos olhar para ele. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Aqui, dependendo da coordenada do sprite (lembre-se de que esse √© provavelmente o endere√ßo do caractere selecionado), esse ou aquele valor √© inserido.  Vemos a seguinte se√ß√£o de c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  O valor existente √© deslocado para a direita em 4 bits, um novo valor √© colocado no byte baixo e o resultado √© inserido na vari√°vel novamente.  Em teoria, nossa vari√°vel <code>jmp_addr</code> armazena os caracteres que podemos inserir na tela de introdu√ß√£o de teclas.  Observe tamb√©m que o tamanho da vari√°vel √© <code>WORD</code> . </p><br><p>  De fato, a fun√ß√£o <code>sub_3A4</code> pode ser chamada de <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Agora, temos apenas uma fun√ß√£o restante no loop, que n√£o √© reconhecida.  E √© chamado <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Seu c√≥digo se assemelha ao c√≥digo da fun√ß√£o <code>update_jmp_addr</code> , somente no final temos uma <code>sub_45E</code> fun√ß√£o <code>sub_45E</code> .  Vamos olhar l√°. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Vemos que o n√∫mero <code>#$4B1E2003</code> inserido no registro <code>D0</code> , que √© ent√£o enviado para <code>VDP_CTRL</code> , o que significa que estamos lidando com outro comando de controle <code>VDP</code> .  Pressionamos <code>J</code> , recebemos um comando de registro na regi√£o com o mapeamento de <code>$Cxxx</code> . </p><br><p>  Em seguida, o c√≥digo funciona com a vari√°vel <code>byte_FF0014</code> , que n√£o √© usada em nenhum lugar, exceto na fun√ß√£o atual.  Se voc√™ observar atentamente como √© usado, notar√° que o n√∫mero m√°ximo que pode ser instalado nele √© <code>4</code> .  Eu suponho que esse seja o comprimento atual da chave inserida.  Vamos conferir. </p><br><h4 id="zapuskaem-otladchik">  Execute o depurador </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Usarei</a> o depurador da <code>Smd Ida Tools</code> , mas, em ess√™ncia, alguns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Gens KMod</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Gens ReRecording</a> ser√£o suficientes.  O principal √© que existe um recurso com a exibi√ß√£o de endere√ßos na mem√≥ria. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Minha teoria foi confirmada.  Portanto, a vari√°vel <code>byte_FF0014</code> agora pode ser <code>key_length</code> . </p><br><p>  H√° outra vari√°vel: <code>dword_FF0010</code> , que tamb√©m √© usada apenas na fun√ß√£o atual, e seu conte√∫do, ap√≥s adicionar ao comando inicial em <code>D0</code> (lembre-se, esse era o n√∫mero <code>#$4B1E2003</code> ), √© enviado para <code>VDP_CTRL</code> .  Sem pensar <code>add_to_vdp_cmd</code> , <code>add_to_vdp_cmd</code> a vari√°vel <code>add_to_vdp_cmd</code> . </p><br><p>  Ent√£o, o que essa fun√ß√£o faz?  Eu suponho que ela desenhe o caractere inserido.  Verificar isso √© simples - iniciando o depurador e comparando o estado antes de chamar a fun√ß√£o <code>sub_45E</code> e depois: </p><br><p>  Para: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Depois: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  Eu estava certo - esta fun√ß√£o desenha o caractere inserido.  N√≥s o chamamos de <code>do_draw_input_char</code> , e a fun√ß√£o que o chama ( <code>sub_414</code> ) √© <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  O que agora </h2><br><p>  Vamos verificar agora que a vari√°vel que chamamos de <code>jmp_addr</code> realmente armazena a chave inserida.  Usaremos o mesmo <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Como voc√™ pode ver, a conjectura era verdadeira.  O que isso nos d√°?  Podemos pular para qualquer endere√ßo.  Mas qual?  Na lista de fun√ß√µes, todas s√£o ordenadas, afinal: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Ent√£o comecei a rolar o c√≥digo at√© encontrar o seguinte: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  O olho treinado viu a sequ√™ncia de <code>$4E, $75</code> no final de bytes n√£o alocados.  Este √© o c√≥digo de opera√ß√£o da instru√ß√£o <code>rts</code> , ou seja,  retornar da fun√ß√£o.  Portanto, esses bytes n√£o alocados podem ser o c√≥digo de alguma fun√ß√£o.  Vamos tentar design√°-los como um c√≥digo, pressione <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Obviamente, este √© um c√≥digo de fun√ß√£o.  Voc√™ tamb√©m pode pressionar <code>P</code> para tornar o c√≥digo uma fun√ß√£o.  Lembre-se deste nome: <code>sub_D3C</code> . </p><br><p>  Ent√£o surge o pensamento: e se voc√™ pular no <code>sub_D3C</code> ?  Parece bom, embora um √∫nico salto aqui obviamente n√£o seja suficiente, porque  n√£o havia mais links para a vari√°vel <code>word_FF0020</code> . </p><br><p>  Ent√£o outro pensamento veio a mim: e se procur√°ssemos outro c√≥digo n√£o alocado?  Abra a caixa de di√°logo <code>Binary search</code> (Alt + B), digite a sequ√™ncia <code>4E 75</code> , marque a caixa <code>Find all occurrences</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Clique em <code></code> para iniciar a pesquisa, obtemos os seguintes resultados. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Pelo menos mais dois lugares no rum podem conter um c√≥digo de fun√ß√£o, voc√™ precisa verific√°-los.  Clicamos na primeira das op√ß√µes, rolamos um pouco para cima e novamente vemos uma sequ√™ncia de bytes indefinidos.  Denot√°-los como uma fun√ß√£o?  Sim  Pressione <code>P</code> onde os bytes come√ßam: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Legal!  Agora temos a fun√ß√£o <code>sub_34C</code> .  Tentamos repetir a mesma coisa com a √∫ltima das op√ß√µes encontradas, e ... temos uma chatice.  Existem tantos bytes antes de <code>4E 75</code> que n√£o est√° claro onde a fun√ß√£o √© iniciada.  E, obviamente, nem todos esses bytes acima s√£o c√≥digo, porque  muitos bytes duplicados. </p><br><h3 id="opredelyaem-nachalo-funkcii">  Determine o in√≠cio da fun√ß√£o </h3><br><p>  Ser√° mais f√°cil encontrar o in√≠cio da fun√ß√£o se descobrirmos onde os dados terminam.  Como fazer isso?  Na verdade, n√£o √© nada complicado: </p><br><ol><li>  Torcemos antes do in√≠cio dos dados (haver√° um link para eles a partir do c√≥digo) </li><li>  Seguimos o link e procuramos um ciclo no qual o tamanho desses dados deve aparecer </li><li>  Marque a matriz </li></ol><br><p>  Ent√£o, executamos o primeiro par√°grafo ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... e imediatamente vemos que, em um ciclo da nossa matriz, 4 bytes de dados s√£o copiados por vez (porque <code>move.l</code> ) para <code>VDP_DATA</code> .  Em seguida, vemos o n√∫mero <code>2047</code> .  A princ√≠pio, pode parecer que o tamanho final da matriz seja <code>2047 * 4</code> , mas o loop baseado em <code>dbf</code> executa mais uma itera√ß√£o, porque  O √∫ltimo valor comparado n√£o √© <code>0</code> , mas <code>-1</code> . </p><br><p>  Total: o tamanho da matriz √© <code>2048 * 4 = 8192</code> .  Indique bytes como uma matriz.  Para fazer isso, clique em <code>*</code> e especifique o tamanho: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Torcemos at√© o final da matriz e vemos l√° bytes, que s√£o exatamente os bytes do c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Agora temos a fun√ß√£o <code>sub_2D86</code> e temos tudo para resolver esse problema!  Vamos ver o que a fun√ß√£o rec√©m-criada faz. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  E apenas coloca o valor <code>#$4147</code> no registrador <code>D1</code> e chama a fun√ß√£o <code>sub_34C</code> .  D√™ uma olhada nela. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  Vemos que aqui o valor da vari√°vel <code>word_FF0020</code> √© <code>word_FF0020</code> .  Se voc√™ olhar para os links para ele, veremos outro local onde o registro nesta vari√°vel est√° ocorrendo, e este ser√° exatamente o local em que eu gostaria de pular a vari√°vel <code>jmp_addr</code> .  Isso confirma o palpite de que <code>sub_D3C</code> definitivamente precisa pular para <code>sub_D3C</code> . </p><br><p>  Mas o que aconteceu a seguir foi muito pregui√ßoso para eu entender, ent√£o joguei o rum no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GHIDRA</a> , encontrei essa fun√ß√£o e observei o c√≥digo descompilado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Vemos que a vari√°vel com o nome estranho <code>in_D1w</code> e tamb√©m a vari√°vel <code>DAT_00ff0020</code> , que lembra com seu endere√ßo a <code>word_FF0020</code> mencionada anteriormente. </p><br><p>  <code>in_D1w</code> nos diz que esse valor √© obtido do registro <code>D1</code> , ou melhor, da metade mais jovem do WORD e define o registro <code>D1</code> fun√ß√£o que o passa.  Lembra-se de <code>#$4147</code> ?  Portanto, voc√™ precisa designar esse registro como o argumento de entrada para a fun√ß√£o. </p><br><p>  Para fazer isso, na janela com o c√≥digo descompilado, clique com o bot√£o direito do mouse no nome da fun√ß√£o e selecione o item de menu <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Para indicar que a fun√ß√£o aceita um argumento atrav√©s de um registro espec√≠fico, a saber, n√£o pelo m√©todo padr√£o da conven√ß√£o de chamada atual, √© necess√°rio marcar a <code>Use Custom Storage</code> e clicar no √≠cone com um <u>sinal de mais verde</u> : </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Uma posi√ß√£o para o novo argumento de entrada √© exibida.  Clicamos duas vezes e obtemos uma caixa de di√°logo indicando o tipo e o meio do argumento: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  No c√≥digo descompilado, vemos que <code>in_D1w</code> √© do tipo <code>ushort</code> , o que significa que o especificaremos no campo type.  Em seguida, clique no bot√£o <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Uma posi√ß√£o aparecer√° para indicar o meio do argumento, precisamos especificar o registro <code>D1w</code> em <code>Location</code> e clique em <code>OK</code> : </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  O c√≥digo descompilado ter√° o formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  <code>param_1</code> que nosso valor <code>param_1</code> √© constante, passado pela fun√ß√£o de chamada e √© igual a <code>#$4147</code> .  Ent√£o, qual deve ser o valor de <code>DAT_00ff0020</code> ?  Consideramos: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Porque  <code>xor</code> - a opera√ß√£o √© revers√≠vel, todos os n√∫meros constantes podem ser discutidos entre si e obter o valor desejado da vari√°vel <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Acontece que o valor da vari√°vel deve ser <code>0x4553</code> .  Parece que eu j√° vi um lugar onde esse valor √© definido ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Conclus√µes e decis√£o </h2><br><p>  Chegamos aos seguintes resultados: </p><br><ol><li>  Primeiro voc√™ precisa pular para o endere√ßo <code>0x0D3C</code> , para isso, digite o c√≥digo <code>0D3C</code> </li><li>  V√° para a fun√ß√£o <code>0x2D86</code> , que define o valor de <code>D1</code> para registrar <code>#$4147</code> , para isso, √© necess√°rio inserir o c√≥digo <code>2D86</code> </li></ol><br><p>  Experimentalmente, descobrimos a tecla que precisa ser pressionada para verificar a tecla inserida: <code>B</code>  Tentamos: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Obrigada </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448500/">https://habr.com/ru/post/pt448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448488/index.html">Medo e √≥dio DevSecOps</a></li>
<li><a href="../pt448490/index.html">Como iniciar a transforma√ß√£o do DevOps</a></li>
<li><a href="../pt448492/index.html">O que √© DevOps</a></li>
<li><a href="../pt448496/index.html">.NET Core no Linux, DevOps a cavalo</a></li>
<li><a href="../pt448498/index.html">"R√∫ssia 404": quanto de Internet gr√°tis resta para viver</a></li>
<li><a href="../pt448504/index.html">Eles coletaram para todos "Habrom" o livro de refer√™ncia "Por quem foi emitido ..." para passaportes. Download para a sa√∫de</a></li>
<li><a href="../pt448506/index.html">Matrix tem 20 anos: como Wachowski criou o cyberpunk, que determinou a agenda de toda uma gera√ß√£o</a></li>
<li><a href="../pt448510/index.html">Acer em 2019: e se voc√™ remover todas as moscas dos laptops para jogos</a></li>
<li><a href="../pt448516/index.html">Evolua ou crie uma base para rob√¥s na plataforma ARDUINO, e direcionamos sensores e v√≠deo para um computador via smartphone</a></li>
<li><a href="../pt448518/index.html">Como ver um buraco negro?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>