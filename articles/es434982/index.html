<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüéì üôãüèº üõ´ Perspectiva: MultiClet S1 ‚ô£Ô∏è üö∂üèΩ üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entonces, es hora de hablar sobre la pr√≥xima generaci√≥n de procesadores multicelulares: MultiClet S1. Si es la primera vez que escuchas sobre ellos, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perspectiva: MultiClet S1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434982/"><img src="https://habrastorage.org/webt/fx/3k/yv/fx3kyvqsb8hquivzhowomntx-xe.jpeg"><br><br>  Entonces, es hora de hablar sobre la pr√≥xima generaci√≥n de procesadores multicelulares: MultiClet S1.  Si es la primera vez que escuchas sobre ellos, aseg√∫rate de revisar la historia y la ideolog√≠a de la arquitectura en estos art√≠culos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"¬øQu√© es un procesador multicelular?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Multiclet R1 - las primeras pruebas"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Compilador C / C ++ basado en LLVM para procesadores multicelulares: ¬øser o no ser?"</a> </li></ul><br>  Por el momento, el nuevo procesador est√° en desarrollo, pero los primeros resultados ya han aparecido y puede evaluar de lo que ser√° capaz. <br><a name="habracut"></a><br>  Comencemos con los cambios m√°s importantes: caracter√≠sticas b√°sicas. <br><br><h2>  Caracteristicas </h2><br>  Est√° previsto alcanzar los siguientes indicadores: <br><br><ol><li>  N√∫mero de celdas: 64 </li><li>  Proceso t√©cnico: 28 nm. </li><li>  Frecuencia de reloj: 1.6 GHz </li><li>  El tama√±o de la memoria en el chip: 8 MB </li><li>  √Årea de cristal: 40 mm <sup>2</sup> </li><li>  Consumo de energ√≠a: 6 W </li></ol><br>  Los n√∫meros reales se anunciar√°n en funci√≥n de los resultados de las pruebas de muestras fabricadas en 2019.  Adem√°s de las caracter√≠sticas del chip en s√≠, el procesador admitir√° hasta 16 GB de RAM est√°ndar DDR4 3200MHz, bus PCI Express y PLL. <br><br>  Cabe se√±alar que el proceso de fabricaci√≥n de 28 nm es el rango dom√©stico m√°s bajo que no requiere permisos especiales para su uso, por lo que fue √©l quien fue elegido.  Seg√∫n el n√∫mero de celdas, se consideraron diferentes opciones: 128 y 256, pero con un aumento en el √°rea del cristal, aumenta el porcentaje de rechazos.  Nos instalamos en 64 c√©lulas y, en consecuencia, en un √°rea relativamente peque√±a, que dar√° un mayor rendimiento de cristales adecuados en la placa.  Es posible un mayor desarrollo en el marco del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICS (sistema en el caso)</a> , donde ser√° posible combinar varios cristales de 64 c√©lulas en un caso. <br><br>  Hay que decir que el prop√≥sito y el uso del procesador est√°n cambiando radicalmente.  S1 no ser√° un microprocesador dise√±ado para incrustar, como lo fueron P1 y R1, sino un acelerador de c√°lculos.  Al igual que GPGPU, se puede insertar una placa basada en S1 en la placa base PCI Express de una PC normal y usarla para el procesamiento de datos. <br><br><h2>  Arquitectura </h2><br>  En S1, el "multicelda" es ahora la unidad computacional m√≠nima: un conjunto de 4 celdas que ejecuta una cierta secuencia de comandos.  Al principio, se plane√≥ combinar multiceldas en grupos llamados cl√∫ster para la ejecuci√≥n conjunta de comandos: un cl√∫ster ten√≠a que contener 4 multiceldas, en total hab√≠a 4 cl√∫steres separados en el cristal.  Sin embargo, cada c√©lula tiene una conexi√≥n completa con todas las otras c√©lulas en el grupo, y con un aumento en el grupo de enlaces se vuelve demasiado, lo que complica enormemente el dise√±o topol√≥gico del microcircuito y reduce sus caracter√≠sticas.  Por lo tanto, decidieron abandonar la divisi√≥n de conglomerados, ya que la complicaci√≥n no justifica los resultados.  Adem√°s, para obtener el m√°ximo rendimiento, es m√°s beneficioso ejecutar c√≥digo en paralelo en cada multicelda.  Total, ahora el procesador contiene 16 multiceldas separadas. <br><br>  Un multicelda, aunque consta de 4 celdas, difiere de un R1 de 4 celdas, en el que cada celda tiene su propia memoria, su propio bloque de comandos de muestra, su propia ALU.  S1 est√° organizado de manera un poco diferente.  ALU tiene 2 partes: un bloque aritm√©tico de coma flotante y un bloque aritm√©tico de enteros.  Cada celda tiene un bloque de enteros separado, pero solo hay dos bloques con un punto flotante en una celda m√∫ltiple y, por lo tanto, dos pares de celdas los dividen entre s√≠.  Esto se hizo principalmente para reducir el √°rea del cristal: la aritm√©tica de coma flotante de 64 bits, en contraste con la aritm√©tica de enteros, ocupa mucho espacio.  Tener dicha ALU en cada celda result√≥ ser redundante: los comandos de recuperaci√≥n no proporcionan carga de ALU y est√°n inactivos.  Mientras se reduce la cantidad de bloques de ALU y se mantiene el ritmo de recuperaci√≥n de comandos y datos, como lo ha demostrado la pr√°ctica, el tiempo total para resolver problemas pr√°cticamente no cambia o cambia ligeramente, y los bloques de ALU se cargan completamente.  Adem√°s, la aritm√©tica de coma flotante no se usa con tanta frecuencia como con un entero. <br><br>  En el siguiente diagrama se muestra una vista esquem√°tica de los bloques de procesadores R1 y S1.  Aqu√≠: <br><br><ul><li>  CU (Unidad de control) - unidad de b√∫squeda de instrucciones </li><li>  ALU <sub>FX</sub> - unidad l√≥gica aritm√©tica de aritm√©tica de enteros </li><li>  ALU <sub>FP</sub> - Unidad l√≥gica aritm√©tica de aritm√©tica de coma flotante </li><li>  DMS (Data Memory Scheduler) - unidad de control de memoria de datos </li><li>  DM - memoria de datos </li><li>  PMS (Program Memory Scheduler) - unidad de control de memoria de programa </li><li>  PM - memoria de programa </li></ul><br><img src="https://habrastorage.org/webt/6t/4n/dp/6t4ndpu7d_koh8rpn8dmx0-b7ho.png"><br><br>  Diferencias arquitect√≥nicas S1: <br><br><ol><li>  Los equipos ahora pueden acceder a los resultados del equipo de los p√°rrafos anteriores.  Este es un cambio muy importante que le permite acelerar significativamente las transiciones al bifurcar el c√≥digo.  Los procesadores P1 y R1 no tuvieron m√°s remedio que escribir los resultados deseados en la memoria e inmediatamente volver a leerlos con los primeros comandos en el nuevo p√°rrafo.  Incluso cuando se usa la memoria en un chip, las operaciones de escritura y lectura toman de 2 a 5 ciclos cada una, lo que se puede guardar simplemente refiri√©ndose al resultado del comando del p√°rrafo anterior </li><li>  La escritura en la memoria y los registros ahora ocurre inmediatamente, y no al final de un p√°rrafo, lo que le permite comenzar a escribir comandos antes del final del p√°rrafo.  Como resultado, se reduce el tiempo de inactividad potencial entre p√°rrafos. </li><li>  El sistema de comando ha sido optimizado, a saber: <br><ul><li>  Se agreg√≥ aritm√©tica de enteros de 64 bits: suma, resta, multiplicaci√≥n de n√∫meros de 32 bits, que devuelve un resultado de 64 bits. </li><li>  El m√©todo de lectura desde la memoria ha cambiado: ahora para <b>cualquier</b> comando, simplemente puede especificar la direcci√≥n desde la que desea leer los datos como argumento, mientras se conserva el orden de ejecuci√≥n de los comandos de lectura y escritura. <br><br>  Tambi√©n hizo obsoleto un comando de lectura de memoria separado.  En cambio, el comando de valor de carga se usa en el interruptor de <b>carga</b> (anteriormente, <b>get</b> ), especificando la direcci√≥n en la memoria como argumento: <br><br><pre><code class="plaintext hljs">.data foo: .long 0x1234 .text habr: load_l foo ;      foo load_l [foo] ;    0x1234 add_l [foo], 0xABCD ;       ;   complete</code> </pre> <br></li><li>  Se ha agregado un formato de comando que permite usar 2 argumentos constantes. <br>  Anteriormente, pod√≠a especificar una constante solo como un segundo argumento, el primer argumento siempre debe ser un enlace al resultado en el cambio.  El cambio se aplica a todos los equipos de dos argumentos.  El campo constante siempre es de 32 bits, por lo que este formato permite, por ejemplo, generar constantes de 64 bits con un comando. <br><br>  Fue: <br><br><pre> <code class="plaintext hljs">load_l 0x12345678 patch_q @1, 0xDEADBEEF</code> </pre><br>  Se convirti√≥ en: <br><br><pre> <code class="plaintext hljs">patch_q 0x12345678, 0xDEADBEEF</code> </pre> <br></li><li>  Tipos de datos vectoriales modificados y complementados. <br>  Lo que sol√≠a llamarse tipos de datos "empaquetados" ahora se puede llamar con seguridad vectorial.  En P1 y R1, las operaciones en n√∫meros empaquetados solo tomaron una constante como el segundo argumento, es decir, al sumar, cada elemento del vector se agreg√≥ con el mismo n√∫mero, y esto no se pudo aplicar de manera inteligente.  Ahora, se pueden aplicar operaciones similares a dos vectores completos.  Adem√°s, esta forma de trabajar con vectores es totalmente coherente con el mecanismo de vectores en LLVM, que ahora permite al compilador generar c√≥digo utilizando tipos de vectores. <br><br><pre> <code class="plaintext hljs">patch_q 0x00010002, 0x00030004 patch_q 0x00020003, 0x00040005 mul_ps @1, @2 ;  - 00020006000C0014</code> </pre><br></li></ul><br></li><li>  Banderas del procesador eliminadas. <br><br>  Como resultado, se eliminaron unos 40 equipos basados ‚Äã‚Äã√∫nicamente en los valores de las banderas.  Esto ha reducido significativamente el n√∫mero de equipos y, en consecuencia, el √°rea del cristal.  Y toda la informaci√≥n necesaria ahora se almacena directamente en la celda del interruptor. <br><br><ul><li>  Al comparar con cero, en lugar de la bandera de cero, ahora solo se usa el valor en el interruptor </li><li>  En lugar de la bandera de signo, ahora se usa un bit correspondiente al tipo de comando: s√©ptimo para byte, 15 para corto, 31 para largo, 63 para quad.  Debido al hecho de que el personaje se multiplica hasta el bit 63, independientemente del tipo, puede comparar n√∫meros de diferentes tipos: <br><br><pre> <code class="plaintext hljs">.data long: .long -0x1000 byte: .byte -0x10 .text habr: a := load_b [byte] ;     0xFFFFFFFFFFFFFFF0, ;   byte 7    63. b := loadu_b [byte] ;     0x00000000000000F0, ; ..  loadu_b    c := load_l [long] ;     0xFFFFFFFFFFFFF000. ge_l @a, @c ;   "  "  1: ;   31 ,   . lt_s @a, @b ; 1, .. b     complete</code> </pre><br></li><li>  La bandera de transporte ya no es necesaria, ya que hay aritm√©tica de 64 bits. </li></ul><br></li><li>  El tiempo de transici√≥n de un p√°rrafo a otro se redujo a 1 medida (en lugar de 2-3 en R1) </li></ol><br><h2>  Compilador basado en LLVM </h2><br>  El compilador de lenguaje C para S1 es similar a R1, y dado que la arquitectura no ha cambiado fundamentalmente, los problemas descritos en el art√≠culo anterior, desafortunadamente, no han desaparecido. <br><br>  Sin embargo, en el proceso de implementaci√≥n del nuevo sistema de comando, la cantidad de c√≥digo de salida disminuy√≥ por s√≠ solo, simplemente debido a la actualizaci√≥n del sistema de comando.  Adem√°s, hay muchas m√°s optimizaciones menores que reducir√°n la cantidad de instrucciones en el c√≥digo, algunas de las cuales ya se han realizado (por ejemplo, generar constantes de 64 bits con una sola instrucci√≥n).  Pero hay optimizaciones a√∫n m√°s serias que deben hacerse, y se pueden construir en orden ascendente de eficiencia y complejidad de implementaci√≥n: <br><br><ol><li>  La capacidad de generar todos los comandos de dos argumentos con dos constantes. <br><br>  Generar una constante de 64 bits a trav√©s de patch_q es solo un caso especial, pero necesitamos uno general.  De hecho, el objetivo de esta optimizaci√≥n es permitir que los equipos sustituyan solo el primer argumento como una constante, ya que el segundo argumento siempre podr√≠a ser una constante, y esto se ha implementado durante mucho tiempo.  Este no es un caso muy frecuente, pero, por ejemplo, cuando necesita llamar a una funci√≥n y escribir la direcci√≥n de retorno desde la parte superior de la pila, puede <br><br><pre> <code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre><br>  optimizar a <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre><br></li><li>  La capacidad de sustituir el acceso a la memoria a trav√©s de un argumento en cualquier comando. <br>  Por ejemplo, si necesita agregar dos n√∫meros de la memoria, puede <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre><br>  optimizar a <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Esta optimizaci√≥n es una extensi√≥n de la anterior, sin embargo, el an√°lisis ya es necesario aqu√≠: tal reemplazo solo puede llevarse a cabo si los valores cargados se usan solo una vez en este comando de adici√≥n y en ning√∫n otro lugar.  Si el resultado de la lectura se usa incluso en solo dos comandos, es m√°s rentable leer de la memoria una vez como un comando separado, y en los otros dos referirse a √©l a trav√©s del interruptor. <br></li><li>  Optimizaci√≥n de la transferencia de registros virtuales entre unidades base. <br>  Para R1, la transferencia de todos los registros virtuales se realiz√≥ a trav√©s de la memoria, lo que da lugar a una gran cantidad de lecturas y escrituras en la memoria, pero simplemente no hab√≠a otra forma de transferir datos entre p√°rrafos.  S1 le permite acceder a los resultados de los comandos de los p√°rrafos anteriores, por lo tanto, en teor√≠a, se pueden eliminar muchas operaciones de memoria, lo que dar√≠a el mayor efecto entre todas las optimizaciones.  Sin embargo, este enfoque todav√≠a est√° limitado por el cambio: no m√°s de 63 resultados anteriores, lejos de cada transferencia del registro virtual se puede implementar de esta manera.  C√≥mo hacer esto no es una tarea trivial, y a√∫n no se ha realizado un an√°lisis de las posibilidades para resolverlo.  Las fuentes del compilador pueden aparecer en el dominio p√∫blico, por lo que si alguien tiene ideas y desea unirse al desarrollo, puede hacerlo. <br></li></ol><br><h2>  Puntos de referencia </h2><br>  Dado que el procesador a√∫n no se ha lanzado en el chip, es dif√≠cil evaluar su rendimiento real.  Sin embargo, el c√≥digo del n√∫cleo RTL ya est√° listo, lo que significa que puede realizar una evaluaci√≥n mediante simulaci√≥n o FPGA.  Para ejecutar los siguientes puntos de referencia, utilizamos una simulaci√≥n usando el programa ModelSim para calcular el tiempo de ejecuci√≥n exacto (en medidas).  Dado que es dif√≠cil simular todo el cristal y lleva mucho tiempo, por lo tanto, se simul√≥ una multicelda y el resultado se multiplic√≥ por 16 (si la tarea est√° dise√±ada para subprocesamiento m√∫ltiple), ya que cada multicelda puede funcionar de manera completamente independiente de las dem√°s. <br><br>  Al mismo tiempo, se realiz√≥ el modelado multicelda en Xilinx Virtex-6 para probar el rendimiento del c√≥digo del procesador en hardware real. <br><br><h4>  Coremark </h4><br>  CoreMark: un conjunto de pruebas para una evaluaci√≥n integral del rendimiento de los microcontroladores y procesadores centrales, as√≠ como de sus compiladores C.  Como puede ver, el procesador S1 no es ni uno ni el otro.  Sin embargo, est√° destinado a ejecutar c√≥digo de arbitraje absoluto, es decir,  cualquiera que pueda estar ejecut√°ndose en el procesador central.  Por lo tanto, CoreMark es adecuado para evaluar el rendimiento de S1 no peor. <br><br>  CoreMark contiene trabajo con listas vinculadas, matrices, una m√°quina de estado y c√°lculo de suma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRC</a> .  En general, la mayor parte del c√≥digo resulta ser estrictamente secuencial (lo que prueba la resistencia del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelismo de hardware</a> multicelular) y con muchas ramas, por lo que las capacidades del compilador juegan un papel importante en el rendimiento final.  El c√≥digo compilado contiene bastantes p√°rrafos cortos y, a pesar del hecho de que la velocidad de transici√≥n entre ellos ha aumentado, la ramificaci√≥n incluye trabajar con memoria, lo que nos gustar√≠a evitar al m√°ximo. <br><br>  Tarjeta de puntuaci√≥n de CoreMark: <br><table><tbody><tr><th></th><th>  Multiclet R1 (compilador llvm) </th><th>  <b>Multiclet S1 (compilador llvm)</b> </th><th>  Elbrus-4C (R500 / E) </th><th>  Texas Inst.  BRAZO AM5728 Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  A√±o de fabricaci√≥n </td><td>  2015 </td><td>  <b>2019</b> </td><td>  2014 </td><td>  2018 </td><td>  2016 </td><td>  2017 </td></tr><tr><td>  Frecuencia de reloj, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  700 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Puntuaci√≥n general de CoreMark </td><td>  59 </td><td>  <b>18356</b> </td><td>  1214 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr><tr><td>  Coremark / MHz </td><td>  0,59 </td><td>  <b>11,47</b> </td><td>  5.05 </td><td>  10,53 </td><td>  10.95 </td><td>  40,47 </td></tr></tbody></table><br>  El resultado de una multicelda es 1147, o 0.72 / MHz, que es m√°s alto que el de R1.  Esto habla de las ventajas de desarrollar arquitectura multicelular en el nuevo procesador. <br><br><h4>  Wheatstone </h4><br>  Piedra de afilar: un conjunto de pruebas para medir el rendimiento del procesador cuando se trabaja con n√∫meros de coma flotante.  Aqu√≠ la situaci√≥n es mucho mejor: el c√≥digo tambi√©n es secuencial, pero sin una gran cantidad de ramas y con buena concurrencia interna. <br><br>  Whetstone consta de muchos m√≥dulos, lo que le permite medir no solo el resultado general, sino tambi√©n el rendimiento de cada m√≥dulo espec√≠fico: <br><br><ol><li>  Elementos de la matriz </li><li>  Matriz como par√°metro </li><li>  Saltos condicionales </li><li>  Aritm√©tica de enteros </li><li>  Funciones trigonom√©tricas (tan, sin, cos) </li><li>  Llamadas de procedimiento </li><li>  Referencias de matriz </li><li>  Funciones est√°ndar (sqrt, exp, log) </li></ol><br>  Se dividen en categor√≠as: los m√≥dulos 1, 2 y 6 miden el rendimiento de las operaciones de coma flotante (l√≠neas MFLOPS1-3);  m√≥dulos 5 y 8 - funciones matem√°ticas (COS MOPS, EXP MOPS);  m√≥dulos 4 y 7 - aritm√©tica de enteros (FIXPT MOPS, EQUAL MOPS);  m√≥dulo 3 - saltos condicionales (IF MOPS).  En la tabla a continuaci√≥n, la segunda fila de MWIPS es un indicador general. <br><br>  A diferencia de CoreMark, Whetstone se comparar√° en un n√∫cleo o, como en nuestro caso, en un multicelda.  Dado que el n√∫mero de n√∫cleos es muy diferente en diferentes procesadores, entonces, para la pureza del experimento, consideramos los indicadores por megahercio. <br><br>  Tarjeta de puntuaci√≥n de piedra de afilar: <br><table><tbody><tr><th>  CPU </th><th>  MultiClet R1 </th><th>  <b>MultiClet S1</b> </th><th>  Core i7 4820K </th><th>  BRAZO v8-A53 </th></tr><tr><td>  Frecuencia, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  3900 </td><td>  1300 </td></tr><tr><td>  MWIPS / MHz </td><td>  0,311 </td><td>  <b>0,343</b> </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  0,157 </td><td>  <b>0,156</b> </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  0,153 </td><td>  <b>0.111</b> </td><td>  0,308 </td><td>  0.241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  0,029 </td><td>  <b>0,124</b> </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  0,018 </td><td>  <b>0.008</b> </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  0.008 </td><td>  <b>0.005</b> </td><td>  0,014 </td><td>  0.004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  0,714 </td><td>  <b>0.116</b> </td><td>  0,998 </td><td>  1.197 </td></tr><tr><td>  SI MOPS / MHz </td><td>  0,081 </td><td>  <b>0,196</b> </td><td>  1.504 </td><td>  1.436 </td></tr><tr><td>  MOPS IGUALES / MHz </td><td>  0.143 </td><td>  <b>0,149</b> </td><td>  0.251 </td><td>  0.439 </td></tr></tbody></table><br>  Whetstone contiene operaciones computacionales mucho m√°s directas que CoreMark (que es muy notable cuando se mira el c√≥digo a continuaci√≥n), por lo que es importante recordar aqu√≠: la cantidad de ALU de punto flotante se reduce a la mitad.  Sin embargo, la velocidad de c√°lculo casi no se vio afectada, en comparaci√≥n con R1. <br><br>  Algunos m√≥dulos encajan muy bien en una arquitectura multicelular.  Por ejemplo, el m√≥dulo 2 cuenta muchos valores en un ciclo, y gracias al soporte total de n√∫meros de punto flotante de doble precisi√≥n por parte del procesador y el compilador, despu√©s de la compilaci√≥n, obtenemos p√°rrafos grandes y hermosos que realmente revelan las capacidades computacionales de una arquitectura multicelular: <br><br><div class="spoiler">  <b class="spoiler_title">P√°rrafo grande y hermoso para 120 equipos.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pa: SR4 := loadu_q [#SP + 16] SR5 := loadu_q [#SP + 8] SR6 := loadu_l [#SP + 4] SR7 := loadu_l [#SP] setjf_l @0, @SR7 SR8 := add_l @SR6, 0x8 SR9 := add_l @SR6, 0x10 SR10 := add_l @SR6, 0x18 SR11 := loadu_q [@SR6] SR12 := loadu_q [@SR8] SR13 := loadu_q [@SR9] SR14 := loadu_q [@SR10] SR15 := add_d @SR11, @SR12 SR11 := add_d @SR15, @SR13 SR15 := sub_d @SR11, @SR14 SR11 := mul_d @SR15, @SR5 SR15 := add_d @SR12, @SR11 SR12 := sub_d @SR15, @SR13 SR15 := add_d @SR14, @SR12 SR12 := mul_d @SR15, @SR5 SR15 := sub_d @SR11, @SR12 SR16 := sub_d @SR12, @SR11 SR17 := add_d @SR11, @SR12 SR11 := add_d @SR13, @SR15 SR13 := add_d @SR14, @SR11 SR11 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR11 SR15 := add_d @SR17, @SR11 SR16 := add_d @SR14, @SR13 SR13 := div_d @SR16, @SR4 SR14 := sub_d @SR15, @SR13 SR15 := mul_d @SR14, @SR5 SR14 := add_d @SR12, @SR15 SR12 := sub_d @SR14, @SR11 SR14 := add_d @SR13, @SR12 SR12 := mul_d @SR14, @SR5 SR14 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR11, @SR14 SR11 := add_d @SR13, @SR15 SR14 := mul_d @SR11, @SR5 SR11 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR13, @SR11 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR4 := loadu_q @SR4 SR5 := loadu_q @SR5 SR6 := loadu_q @SR6 SR7 := loadu_q @SR7 SR15 := mul_d @SR13, @SR5 SR8 := loadu_q @SR8 SR9 := loadu_q @SR9 SR10 := loadu_q @SR10 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR17 SR14 := mul_d @SR13, @SR5 SR5 := add_d @SR16, @SR14 SR13 := add_d @SR11, @SR5 SR5 := div_d @SR13, @SR4 wr_q @SR15, @SR6 wr_q @SR12, @SR8 wr_q @SR14, @SR9 wr_q @SR5, @SR10 complete</code> </pre><br></div></div><br><h4>  popcnt </h4><br>  Para reflejar las caracter√≠sticas de la arquitectura en s√≠ (independientemente del compilador), mediremos algo escrito en ensamblador teniendo en cuenta todas las caracter√≠sticas de la arquitectura.  Por ejemplo, contar bits de unidad en un n√∫mero de 512 bits (popcnt).  Para mayor claridad, tomaremos los resultados de una multicelda, para que puedan compararse con R1. <br><br>  Tabla de comparaci√≥n, el n√∫mero de ciclos de reloj por ciclo de c√°lculo de 32 bits: <br><table><tbody><tr><th>  Algoritmo </th><th>  Multiclet r1 </th><th>  Multiclet S1 (una multicelda) </th></tr><tr><td>  Bithacks </td><td>  5.0 </td><td>  2.625 </td></tr></tbody></table><br>  Aqu√≠ se usaron nuevas instrucciones vectoriales actualizadas, lo que nos permiti√≥ reducir a la mitad el n√∫mero de instrucciones en comparaci√≥n con el mismo algoritmo implementado en el ensamblador R1.  La velocidad del trabajo, respectivamente, aument√≥ en casi 2 veces. <br><br><div class="spoiler">  <b class="spoiler_title">popcnt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bithacks: b0 := patch_q 0x1, 0x1 v0 := loadu_q [v] v1 := loadu_q [v+8] v2 := loadu_q [v+16] v3 := loadu_q [v+24] v4 := loadu_q [v+32] v5 := loadu_q [v+40] v6 := loadu_q [v+48] v7 := loadu_q [v+56] b1 := patch_q 0x55555555, 0x55555555 i00 := slr_pl @v0, @b0 i01 := slr_pl @v1, @b0 i02 := slr_pl @v2, @b0 i03 := slr_pl @v3, @b0 i04 := slr_pl @v4, @b0 i05 := slr_pl @v5, @b0 i06 := slr_pl @v6, @b0 i07 := slr_pl @v7, @b0 b2 := patch_q 0x33333333, 0x33333333 i10 := and_q @i00, @b1 i11 := and_q @i01, @b1 i12 := and_q @i02, @b1 i13 := and_q @i03, @b1 i14 := and_q @i04, @b1 i15 := and_q @i05, @b1 i16 := and_q @i06, @b1 i17 := and_q @i07, @b1 b3 := patch_q 0x2, 0x2 i20 := sub_pl @v0, @i10 i21 := sub_pl @v1, @i11 i22 := sub_pl @v2, @i12 i23 := sub_pl @v3, @i13 i24 := sub_pl @v4, @i14 i25 := sub_pl @v5, @i15 i26 := sub_pl @v6, @i16 i27 := sub_pl @v7, @i17 i30 := and_q @i20, @b2 i31 := and_q @i21, @b2 i32 := and_q @i22, @b2 i33 := and_q @i23, @b2 i34 := and_q @i24, @b2 i35 := and_q @i25, @b2 i36 := and_q @i26, @b2 i37 := and_q @i27, @b2 i40 := slr_pl @i20, @b3 i41 := slr_pl @i21, @b3 i42 := slr_pl @i22, @b3 i43 := slr_pl @i23, @b3 i44 := slr_pl @i24, @b3 i45 := slr_pl @i25, @b3 i46 := slr_pl @i26, @b3 i47 := slr_pl @i27, @b3 b4 := patch_q 0x4, 0x4 i50 := and_q @i40, @b2 i51 := and_q @i41, @b2 i52 := and_q @i42, @b2 i53 := and_q @i43, @b2 i54 := and_q @i44, @b2 i55 := and_q @i45, @b2 i56 := and_q @i46, @b2 i57 := and_q @i47, @b2 i60 := add_pl @i50, @i30 i61 := add_pl @i51, @i31 i62 := add_pl @i52, @i32 i63 := add_pl @i53, @i33 i64 := add_pl @i54, @i34 i65 := add_pl @i55, @i35 i66 := add_pl @i56, @i36 i67 := add_pl @i57, @i37 b5 := patch_q 0xf0f0f0f, 0xf0f0f0f i70 := slr_pl @i60, @b4 i71 := slr_pl @i61, @b4 i72 := slr_pl @i62, @b4 i73 := slr_pl @i63, @b4 i74 := slr_pl @i64, @b4 i75 := slr_pl @i65, @b4 i76 := slr_pl @i66, @b4 i77 := slr_pl @i67, @b4 b6 := patch_q 0x1010101, 0x1010101 i80 := add_pl @i70, @i60 i81 := add_pl @i71, @i61 i82 := add_pl @i72, @i62 i83 := add_pl @i73, @i63 i84 := add_pl @i74, @i64 i85 := add_pl @i75, @i65 i86 := add_pl @i76, @i66 i87 := add_pl @i77, @i67 b7 := patch_q 0x18, 0x18 i90 := and_q @i80, @b5 i91 := and_q @i81, @b5 i92 := and_q @i82, @b5 i93 := and_q @i83, @b5 i94 := and_q @i84, @b5 i95 := and_q @i85, @b5 i96 := and_q @i86, @b5 i97 := and_q @i87, @b5 iA0 := mul_pl @i90, @b6 iA1 := mul_pl @i91, @b6 iA2 := mul_pl @i92, @b6 iA3 := mul_pl @i93, @b6 iA4 := mul_pl @i94, @b6 iA5 := mul_pl @i95, @b6 iA6 := mul_pl @i96, @b6 iA7 := mul_pl @i97, @b6 iB0 := slr_pl @iA0, @b7 iB1 := slr_pl @iA1, @b7 iB2 := slr_pl @iA2, @b7 iB3 := slr_pl @iA3, @b7 iB4 := slr_pl @iA4, @b7 iB5 := slr_pl @iA5, @b7 iB6 := slr_pl @iA6, @b7 iB7 := slr_pl @iA7, @b7 wr_q @iB0, c wr_q @iB1, c+8 wr_q @iB2, c+16 wr_q @iB3, c+24 wr_q @iB4, c+32 wr_q @iB5, c+40 wr_q @iB6, c+48 wr_q @iB7, c+56 complete</code> </pre><br></div></div><br><h4>  Ethereum </h4><br>  Los puntos de referencia son, por supuesto, buenos, pero tenemos una tarea espec√≠fica: hacer un acelerador de c√≥mputo, y ser√≠a bueno saber c√≥mo maneja las tareas del mundo real.  Las criptomonedas modernas son las m√°s adecuadas para dicha verificaci√≥n, porque los algoritmos de miner√≠a se ejecutan en muchos dispositivos diferentes y, por lo tanto, pueden servir como punto de referencia para la comparaci√≥n.  Comenzamos con Ethereum y el algoritmo Ethash, que se ejecuta directamente en el dispositivo de miner√≠a. <br><br>  La elecci√≥n de Ethereum se debi√≥ a las siguientes consideraciones.  Como saben, los algoritmos como Bitcoin se implementan de manera muy eficiente mediante chips ASIC especializados, por lo que el uso de procesadores o tarjetas de video para extraer Bitcoin y sus clones se vuelve econ√≥micamente desventajoso debido al bajo rendimiento y al alto consumo de energ√≠a.  La comunidad de mineros, en un intento de alejarse de esta situaci√≥n, est√° desarrollando criptomonedas en otros principios algor√≠tmicos, centr√°ndose en el desarrollo de algoritmos que utilizan procesadores de uso general o tarjetas de video para la miner√≠a.  Es probable que esta tendencia contin√∫e en el futuro.  Ethereum es la criptomoneda m√°s famosa basada en este enfoque.  La herramienta principal para extraer Ethereum son las tarjetas de video, que en t√©rminos de eficiencia (hashrate / TDP) est√°n significativamente (varias veces) por delante de los procesadores de prop√≥sito general. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethash</a> es un llamado algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vinculado a la memoria</a> , es decir.  su tiempo de c√°lculo est√° limitado principalmente por la cantidad y la velocidad de la memoria, y no por la velocidad de los c√°lculos en s√≠.  Ahora para la miner√≠a Ethereum, las tarjetas de video son las m√°s adecuadas, pero su capacidad para realizar simult√°neamente muchas operaciones no ayuda mucho, y a√∫n descansan en la velocidad de RAM, lo que se demuestra claramente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> .  A partir de ah√≠, puede tomar una fotograf√≠a que ilustre el funcionamiento del algoritmo para explicar por qu√© sucede esto. <br><br><img src="https://habrastorage.org/webt/y-/gg/t5/y-ggt5p2hd3w2vn1hzddmhwmq3u.png"><br><br>  El art√≠culo desglosa el algoritmo en 6 puntos, pero se pueden distinguir 3 etapas para obtener a√∫n m√°s evidencia: <br><br><ol><li>  Inicio: SHA-3 (512) para calcular la mezcla 0 original de 128 bytes (punto 1) </li><li>  Nuevo c√°lculo de 64 veces de la matriz Mix al leer los siguientes 128 bytes y mezclarlos con los anteriores a trav√©s de la funci√≥n de mezcla, para un total de 8 kilobytes (p√°rrafos 2-4) </li><li>  Finalizaci√≥n y verificaci√≥n del resultado. </li></ol><br>  La lectura de 128 bytes aleatorios de RAM lleva mucho m√°s tiempo del que parece.  Si toma la tarjeta gr√°fica MSI RX 470, que tiene 2048 dispositivos inform√°ticos y un ancho de banda de memoria m√°ximo de 211.2 GB / s, para equipar cada dispositivo necesita 1 / (211.2 GB / (128 b * 2048)) = 1241 ns, o aproximadamente 1496 ciclos a una frecuencia dada.  Dado el tama√±o de la funci√≥n de mezcla, podemos suponer que lleva m√°s tiempo leer la memoria de una tarjeta de video que volver a calcular la informaci√≥n recibida.  Como resultado, la etapa 2 del algoritmo lleva mucho tiempo, mucho m√°s que las etapas 1 y 3, que finalmente tienen poco efecto en el rendimiento, a pesar de que contienen m√°s c√°lculos (principalmente en SHA-3).  Simplemente puede ver el hashrate de esta tarjeta de video: 26.375 megachashes / s te√≥rico (limitado solo por el ancho de banda de la memoria) versus 24 megachehes / s real, es decir, las etapas 1 y 3 toman solo el 10% del tiempo. <br><br>  En S1, los 16 multiceldas pueden funcionar en paralelo y en c√≥digo diferente.  Adem√°s, se instalar√° RAM de doble canal, a lo largo de un canal para 8 multiceldas.  En la etapa 2 del algoritmo Ethash, nuestro plan es el siguiente: un multicelda lee 128 bytes de la memoria y comienza a contarlos, luego el siguiente lee la memoria y los relata, y as√≠ sucesivamente hasta el octavo, es decir.  una multicelda, despu√©s de leer 128 bytes de memoria, tiene 7 * [tiempo de lectura de 128 bytes] para recalcular la matriz.  Se supone que dicha lectura tomar√° 16 ciclos, es decir.  Se dan 112 medidas para el recuento.  Calcular la funci√≥n de mezcla requiere aproximadamente el mismo ciclo de reloj, por lo que S1 est√° cerca de la relaci√≥n ideal de ancho de banda de memoria con respecto al rendimiento del procesador.  Como el tiempo no se desperdicia en la segunda etapa, las partes restantes del algoritmo deben optimizarse tanto como sea posible, porque realmente afectan el rendimiento. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evaluar la velocidad de c√°lculo SHA-3 (Keccak), se desarroll√≥ y prob√≥ un programa en C, en funci√≥n del cual se est√° creando actualmente su versi√≥n √≥ptima en ensamblador. </font><font style="vertical-align: inherit;">La programaci√≥n de la evaluaci√≥n muestra que un multicelda realiza el c√°lculo SHA-3 (Keccak) en 1550 ciclos de reloj. </font><font style="vertical-align: inherit;">Por lo tanto, el tiempo total para calcular un hash por una multicelda ser√° 1550 + 64 * (16 + 112) = 9742 ciclos. </font><font style="vertical-align: inherit;">Con una frecuencia de 1.6 GHz y 16 multiceldas paralelas, la tasa de hash del procesador ser√° de 2.6 MHash / s.</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acelerador </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MultiClet S1 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 980 Ti </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX 470 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX Vega 64 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1060 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1080 Ti </font></font></th></tr><tr><td>  Precio </td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 650 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 180 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 500 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 300 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tasa de hash </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25.8 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 43.5 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55 MHash / s </font></font></td></tr><tr><td>  TDP </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 295 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashrate / TDP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,21 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tecnolog√≠a de proceso </font></font></td><td>  28 nm </td><td>  28 nm </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se utiliza MultiClet S1 como herramienta de miner√≠a, se pueden instalar 20 o m√°s procesadores en las placas. </font><font style="vertical-align: inherit;">En este caso, el hashrate de dicha placa ser√° igual o superior a los hashrates de las tarjetas de video existentes, mientras que el consumo de energ√≠a de una placa con S1 ser√° la mitad, incluso que el de las tarjetas de video con est√°ndares topogr√°ficos de 16 y 14 nm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusi√≥n, debo decir que la tarea principal ahora es la fabricaci√≥n de una placa multiprocesador para un minero de criptomonedas multicelular y un minero de supercomputaci√≥n. </font><font style="vertical-align: inherit;">Se planea lograr la competitividad debido al peque√±o consumo de energ√≠a y la arquitectura, que es muy adecuada para la computaci√≥n arbitraria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procesador a√∫n est√° en desarrollo, pero ya puede comenzar a programar en ensamblador, as√≠ como evaluar la versi√≥n actual del compilador. </font><font style="vertical-align: inherit;">Ya existe un SDK m√≠nimo que contiene ensamblador, enlazador, compilador y modelo funcional, en el que puede iniciar y probar sus programas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434982/">https://habr.com/ru/post/es434982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../486150/index.html">Desarrollo de la esfera inform√°tica en Eslovaquia. Beneficios laborales para j√≥venes profesionales.</a></li>
<li><a href="../486156/index.html">Como ense√±√©, y luego escrib√≠ un manual de entrenamiento en Python</a></li>
<li><a href="../486158/index.html">Visualizaci√≥n de traducci√≥n autom√°tica neural (modelos seq2seq con mecanismo de atenci√≥n)</a></li>
<li><a href="../486164/index.html">Coronavirus 2019-nCoV. Preguntas frecuentes sobre protecci√≥n respiratoria y desinfecci√≥n</a></li>
<li><a href="../486174/index.html">Tengo cero rotaci√≥n</a></li>
<li><a href="../es434984/index.html">¬øPor qu√© odio el ORM elocuente?</a></li>
<li><a href="../es434986/index.html">Conceptos b√°sicos de la biblioteca est√°ndar de C ++</a></li>
<li><a href="../es434992/index.html">Actualizaci√≥n de IDA Pro. Depurador para Sega Mega Drive (parte 1)</a></li>
<li><a href="../es434994/index.html">Android: Crear sabores din√°micos de productos y firmar configuraciones</a></li>
<li><a href="../es434996/index.html">C√≥mo compart√≠ la ubicaci√≥n a trav√©s de la API de VK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>