<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 🚯 🧛🏿 平衡的二进制搜索树：在Julia上的实现 🥅 🍞 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="G.M.工作的插图 Adelson-Welsky和E.M. 兰迪斯1962 


 搜索树是用于有序存储和简单搜索项目的数据结构。 二进制搜索树被广泛使用，其中每个节点只有两个孩子。 在本文中，我们考虑了两种组织二叉搜索树的方法：Adelson-Welsky和Landis算法（AVL树）和弱化AVL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>平衡的二进制搜索树：在Julia上的实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>  <em>G.M.工作的插图</em>  <em>Adelson-Welsky和E.M.</em>  <em>兰迪斯1962</em> </p><br><p> 搜索树是用于有序存储和简单搜索项目的数据结构。  <em>二进制</em>搜索树被广泛使用，其中每个节点只有两个孩子。 在本文中，我们考虑了两种组织二叉搜索树的方法：Adelson-Welsky和Landis算法（AVL树）和弱化AVL树（WAVL树）。 </p><a name="habracut"></a><br><p> 让我们从定义开始。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二进制树</a>由<em>节点</em>组成，每个节点以<em>键-值</em>对的形式（或在简单情况下，仅值）形式存储一条<em>记录</em> ，并且最多有两个<em>子级</em> 。 后代节点通过<em>左右</em>区分，并且满足密钥排序的条件：左子节点的密钥不再多，右子节点的密钥不小于父节点的密钥。 另外，服务信息可以存储在（并且通常存储在）节点中，例如，到父节点的链接或其他数据。 特殊情况是树进入<em>的根节点</em> ，以及不存储任何信息<em>的空节点</em> 。 两个后代都为空的节点称为<em>树叶</em> 。 具有所有后代的节点形成一个<em>子树</em> 。 因此，每个节点都是子树的根或叶。 </p><br><p>此定义使您可以构建用于存储节点和树本身的简单结构。 我们假定一个空节点的特殊值为<code>Nothing</code>类型。 然后，在节点中存储对右后代和左后代以及对父代的引用就足够了。 用于存储树的结构仅包含指向根节点的链接。 </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># K -   # V -    mutable struct BSTNode{K, V} key::K value::V left::Union{Nothing, BSTNode{K,V}} right::Union{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} end mutable struct BST{K, V} root::BSTNode{K,V} end</span></span></code> </pre> <br><p> 在这种情况下，出现了如何表示一棵空树的问题。 为此，我们使用《算法：构造和分析》一书中的方法，将不是根的而是作为其父节点的虚拟节点作为入口插入到树中。 要创建这样的节点，请将构造函数添加到BSTNode结构描述中： </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> BSTNode{K, V} key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function BSTNode{K,V}() where {K,V} node = new{K,V}() node.parent = node node.left = node.right = nothing return node end #    - function BSTNode{K,V}(key, value) where {K, V} node = new{K,V}() node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end BSTNode() = BSTNode{Any, Any}() #     ! struct BST{K, V} entry::BSTNode{K,V} BST{K,V}() where {K,V} = new{K,V}(BSTNode{K,V}()) end BST() = BST{Any, Any}() Base.isempty(bst::BST) = bst.entry.left == nothing</span></span></code> </pre> <br><p> 在这种情况下，可以使<code>BST</code>结构保持不变，因为 链接到入口点的链接将不再需要更改。 此外，我们假设树的根节点紧接输入节点的左右后代。 </p><br><p> 自然，需要搜索树的主要操作是搜索元素。 由于左子键不多，右子键不小于父键，因此元素搜索过程的编写非常简单：从树的根开始，将输入键与当前节点的键进行比较； 如果键匹配，则返回值；否则，根据键的顺序转到左或右子树。 如果它们同时到达一个空节点-树中没有键，则引发异常。 </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.getindex()    #      tree[key] function Base.getindex(bst::BST{K,V}, key) where {K,V} key = convert(K, key) node = bst.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><p> 通过键搜索元素显然需要<em>O</em> （ <em>h</em> ）时间，其中<em>h</em>是树的高度，即 从根到叶的最大距离。 可以很容易地计算出一个高度为<em>h</em>的二叉树如果<em>人口稠密</em> ，最多可以包含2 <sup>h +1 1</sup> -1个节点。 除了非常极端的一层之外，所有节点都具有两个后代。 另外，很明显，任何预先给定的键序列都可以导致这种密集的树。 这给出了一种在树中搜索元素的非常乐观的渐近行为，其时间为<em>O</em> （log <sub>2</sub> <em>N</em> ），其中<em>N</em>是元素的数量。 </p><br><p> 自然地，需要以一种满足键顺序的条件的方式来构造用于将元素添加到搜索树的算法。 让我们编写一个通过键插入元素的简单实现： </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.setindex!()    #       tree[key] = value function Base.setindex!(bst::BST{K,V}, val::SV, key::SK) where {K, V} key, value = convert(K, key), convert(V, val) parent = bst.entry.left #   -     if parent == nothing newnode.parent = bst.entry bst.entry.left = bst.entry.right = newnode return val end key_found = false while !key_found if key &lt; parent.key if parent.left == nothing parent.left = BSTNode{K,V}(key, value) parent.left.parent = parent key_found = true else parent = parent.left end elseif key &gt; parent.key if parent.right == nothing parent.right = BSTNode{K,V}(key, value) newnode.parent = parent key_found = true else parent = parent.right end else key_found = true parent.value = value end end return val end</span></span></code> </pre> <br><p> 不幸的是，树的幼稚构造只能在随机输入数据上给出所需的结构，但实际上它们通常是相当结构化的。 在最坏的情况下，如果严格要求输入密钥的顺序（至少按升序，至少按降序排列），则幼稚树结构将始终在一个方向上发送新元素，实际上是收集线性列表。 很容易猜测元素的插入，即搜索将在<em>O</em> （ <em>N</em> ）期间以这种结构进行，这否定了构建复杂数据结构的所有努力。 </p><br><p> 结论：搜索树必须在构建过程中保持<em>平衡</em> ，即 在每个节点处对齐左右子树的高度。 有几种平衡方法。 最简单的是指定一定数量的插入或删除操作，此后将重新平衡树。 在这种情况下，树在平衡之前将处于相当“运行”的状态，因为在最坏的情况下，平衡将花费大约<em>O</em> （ <em>N</em> ）时间，但是后续操作将达到对数时间，直到达到插入/删除的特定阈值。 另一个选择是立即构建插入和删除算法，以使树始终保持平衡，这为任何操作提供了<em>保证的</em>时间复杂度<em>O</em> （log <sub>2</sub> <em>N</em> ）。 </p><br><p> 由于存在允许树``狂野''的算法，但是在那之后，可以在对数时间内在相当长的时间内执行操作，然后必须将树长时间恢复到平衡状态，才能区分元素插入/删除的<em>保证</em>和<em>摊销</em>时间。 对于使用二分搜索树的操作的某些实现，可以保证插入和删除<em>O</em> （log <sub>2</sub> <em>N</em> ）的复杂性，对于某些算法则可以分摊，从而降低<em>O</em> （ <em>N</em> ）。 </p><br><h3 id="algoritm-adelson-velskogo-i-landisa-avl">  Adelson-Welsky和Landis算法（AVL） </h3><br><p> 自平衡二进制搜索树的第一个实现是1962年由Adelson-Welsky和Landis提出的。 在现代文学中，关于姓氏首字母的这种结构称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AVL树</a> 。 该结构由以下属性描述： </p><br><ol><li> 顺序：对于任何节点，左子树顶部的键小于右子树顶部的键（如果后代不是空节点）。 </li><li> 高度增加：父节点的高度比其后代的最大高度大一。 空节点的高度可以认为等于零。 </li><li>  AVL平衡：对于任何节点，左右子树的高度相差不超过1。 </li></ol><br><p> 从这些属性可以得出，整棵树的高度是<em>O</em> （log <sub>2</sub> <em>N</em> ），其中<em>N</em>是存储在树中的记录数，这意味着该记录是在对数时间内搜索的。 为了在每次插入之后保持ABL平衡的状态，每次插入都需要进行<em>平衡</em>操作。 为了有效地执行此操作，每个节点都需要存储服务信息。 为简单起见，只需将节点的高度保持在那里。 </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> AVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment"># ,       255 # (  10^38 ) height::UInt8 key::K value::V left::Union{Nothing, AVLNode{K,V}} right::Union{Nothing, AVLNode{K,V}} parent::AVLNode{K,V} #   function AVLNode{K,V}() where {K,V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing return node end #    - function AVLNode{K,V}(key::SK, value::SV) where {K, V, SK&lt;:K, SV&lt;:V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end avlheight(node::Union{Nothing,AVLNode}) = node == nothing ? 0 : Int(node.height)</span></span></code> </pre> <br><h4 id="vstavka-zapisi"> 插入记录 </h4><br><p> 基本插入是根据标准算法完成的-向下浏览树，寻找可以插入新节点并插入的位置。 我们将编写包装器，以使用索引-1和1而不是左右索引来获取和替换子节点： </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> child(root::AVLNode, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> insert_child!(root::AVLNode{K,V}, newnode::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,AVLNode{K,V}}, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} newnode == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> || (newnode.parent = root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left = newnode <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right = newnode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p> 接下来，我们走到树上，查找是否违反条件2和3。接下来，我们考虑可能出现的选项（在图中，绿色表示更改高度的节点，正在处理的节点为其父节点）。 </p><br><p>  <strong>案例0</strong> <br> 插入后，节点的高度与姐妹节点的高度相同，比父节点的（旧）高度小1。 </p><br><p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br><p> 最好的情况是，无需进一步接触。 上方，您也无法观看，因为 那里什么都不会改变。 </p><br><p>  <strong>情况一</strong> <br> 在插入之前，结的高度等于姐妹结的高度。 插入将提升子树的根，并将节点的高度与父节点的高度进行比较。 </p><br><p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br><p> 在这种情况下，足以“提升”父节点，将其高度增加1。同时，您需要继续移至树的根，因为更改父节点的高度可能会导致违反条件2一级。 </p><br><p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height += by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height -= by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  <strong>情况二</strong> </p><br><p> 插入后，与子树的高度差变为2，而左子树“推”向上： </p><br><p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br><p> 可通过称为“简单旋转”的操作来解决该问题，该操作将树转换如下： </p><br><p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br><p> 一个简单的转弯就需要更改6个指针。 </p><br><p> 注意，在水平轴上的投影中，旋转前后的顶点<em>n</em> ， <em>p</em>和树<em>T</em> <sub>1</sub> - <em>T</em> <sub>3</sub>的顺序保持不变。 这是订购条件的满足。 如您所见，打开树后，不再需要平衡。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  <strong>情况3</strong> <br> 插入后，与子树的高度差变为2，右子树“推”上： </p><br><p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br><p> 在这种情况下，一个简单的转弯将不再有用，但是您可以绕着右后代进行简单的左转，这将导致情况2，该情况已经通过简单的向右转进行了处理。 </p><br><p> 为了减少节点的“重量”数，可以将两匝合并为一个操作，称为大匝或双匝。 然后，无需更改12个指针，只需10个指针即可。由于两次旋转，该树采用以下形式： </p><br><p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br><p> 如您所见，在两次转弯之后，也不需要进一步平衡树。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       funtion double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p> 因此，在将记录插入AVL树中时，需要在有关节点高度的信息中进行<em>O</em> （log <sub>2</sub> <em>N</em> ）个更改，并且最多进行两次旋转操作。 将所有内容组合到一个插入函数中。 它与基本插入的区别仅在于，在插入新节点之后，将<code>fix_insertion!()</code>函数，该函数将从新插入的节点传递到根，检查并在必要时更正余额。 </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left <span class="hljs-comment"><span class="hljs-comment">#   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 # true == 1, false == 0 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> <br><p>  <code>fix_insertion!()</code>函数从插入的父节点开始检查两个子节点之间的高度差。 如果它等于1-在情况1中，则需要提高节点的高度并向更高方向移动。 如果为零，则树是平衡的。 如果等于2-这是情况2或3，则需要应用适当的旋转，树将达到平衡状态。 </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#     -  , #   -  imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) #      0 - ..        while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 #       , # ..   dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end</span></span></code> </pre> <br><h4 id="udalenie-zapisi"> 删除记录 </h4><br><p> 移除比插入困难。 </p><br><p> 首先，考虑从二叉搜索树中通常删除条目。 </p><br><ol><li> 如果已删除的记录在工作表中，那么该记录将被简单地删除，此处的一切都很简单。 </li><li> 如果已删除的记录位于只有一个后代的节点中，则该后代及其所有子树都将放置在远程节点的位置。 </li><li> 如果有两个后代，则从树中提取最大子元素，或从左侧子树中搜索最小子元素（通过搜索树的属性，保证最大元素的节点不具有右后代，但最小子节点不向左，因此此删除很容易）代替已删除的记录。 </li></ol><br><p> 但是在那之后，树平衡可能会受到干扰，因此您需要从远程节点的父节点上来，进行恢复。 请注意，一开始就要确保所讨论的父级的后代之一将高度降低1。考虑到这一点，您需要考虑以下选项（更改高度的节点以红色显示，处理后的节点是红色的父级）： </p><br><p>  <strong>情况一</strong> <br> 零失衡。 因此，在删除之前，它是1模，现在子节点比父节点低2。 </p><br><p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br><p> 您需要将父节点降低1并继续向上移动。 </p><br><p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br><p>  <strong>情况二</strong> <br> 不平衡1模。 </p><br><p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br><p>  AVL条件已满足，您可以停止。 </p><br><p>  <strong>情况3</strong> <br> 不平衡2是模数，降序的姊妹节点具有不为零的不平衡。 </p><br><p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br><p> 我们可以通过简单的操作（如果T <sub>1</sub>低于T <sub>2</sub> ）或通过两次（否则）旋转来恢复平衡，就像在插入过程中那样。 子树的高度减小，即 在树上方可能会发生违规。 </p><br><p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br><p>  <strong>案例4</strong> <br> 不平衡2为模，姊妹节点不平衡为零。 </p><br><p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br><p> 简单旋转即可恢复平衡条件，而子树的高度不会改变-我们停止向上移动。 </p><br><p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br><div class="spoiler">  <b class="spoiler_title">钥匙取出码</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::AVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::AVLNode) node = start skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">2</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew = imbalance(n) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(prev_skew) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_skew == dir node = double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = rotate!(n, dir) prev_skew != <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.height -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="vzlyot-i-padenie-avl-derevev">  AVL树的兴衰 </h3><br><p> 经典AVL树的一个不太好的功能是删除记录的困难： 旋转可以将整个子树向下“重置”一级，然后在最坏的情况下，删除操作需要<em>O</em> （log <sub>2</sub> <em>N</em> ）树旋转-每次您在<code>fix_deletion!()</code>中上<code>fix_deletion!()</code>一级。 </p><br><p> 由于这种不太好的渐近行为，AVL树被1970年代出现的红黑树所取代，并且平衡条件较弱-从根到最远的叶子的路径不超过从根到最近的叶子的路径的两倍。 因此，在最坏的情况下，红黑树的高度为2log <sub>2</sub> <em>N</em> ，而AVL树的高度为1.44log <sub>2</sub> <em>N</em> ，但是删除一条记录最多需要进行三个简单的旋转。 因此，由于较高的树高而导致的搜索和插入可能会降低性能，但是如果插入时常插入删除点，则会有潜在的收益。 </p><br><h3 id="avl-nanosyat-otvetnyy-udar">  AVL反击 </h3><br><p> 事实证明，在添加或删除记录时，用于构建二分搜索树的“理想”算法应保证较小的高度（在经典AVL树的水平上）和固定的旋转数。 这尚未被发明，但在2015年发表了一项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作</a> ，提出了一种可以改善AVL和红黑树特性的结构。 这个想法更接近AVL树，但是放宽了平衡条件以允许更有效地删除记录。 称为“弱AVL树”（W（eak）AVL树）的结构的属性公式如下： </p><br><ol><li> 顺序：对于任何节点，左子树顶部的键小于右子树顶部的键（如果后代不是空节点）。 </li><li> 升序。 每个节点被分配一个等级。 所有空节点的等级为零，图纸的等级为1。父节点的等级严格大于子节点的等级。 </li><li>  ABL平衡不足：节点的等级与子节点的等级相差不超过2。 </li></ol><br><p> 事实证明，这种结构既包括经典AVL树又包括红黑树的属性。 特别是，如果引入<em>两个</em>子节点的等级不能与父节点的等级相差2的条件，我们将得到一个规则的AVL树，并且等级将与子树的高度完全匹配。 </p><br><p>  SAVL树的优点在于，略微减弱AVL条件可使删除记录的记录树平衡不超过两圈！ 树高估计为h &lt;min（1.44log <sub>2</sub> <em>M</em> ，2log <sub>2</sub> <em>N</em> ），其中<em>N</em>是树中的条目数， <em>M</em>是插入数，而红黑树的h &lt;2log <em>2N</em> 。  ,  -   ,       ,      . </p><br><p>  -             ,          .  -        . </p><br><h4 id="struktura-hraneniya">  . </h4><br><p>     -,  ""    "".  ,   : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> WAVLNode rank::<span class="hljs-built_in"><span class="hljs-built_in">UInt8</span></span> key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} parent::WAVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function WAVLNode{K,V}() where {K,V} node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing return node end #    - function WAVLNode{K,V}(key, value) where {K,V} key, value = convert(K, key), convert(V, value) node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end struct WAVLTree{K, V} entry::WAVLNode{K,V} WAVLTree{K,V}() where {K,V} = new{K,V}(WAVLNode{K,V}()) end function child(root::WAVLNode, side::Signed) if side == -1 root.left elseif side == 1 root.right else throw(ArgumentError("Expecting side=-1 to get the left child or side=1 to get the right child")) end end function Base.getindex(avlt::WAVLTree{K,V}, key) where {K,V} key = convert(K, key) node = avlt.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><h4 id="vstavka-zapisi-1">   </h4><br><p>    ,     -.  :      1    ,      —      ,          0 (  )  1 (    ).      <code>imbalance()</code> ,     ,  . </p><br><pre> <code class="julia hljs">wavlrank(node::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,WAVLNode}) = node == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(node.rank) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> imbalance(node::WAVLNode) rr, lr = wavlrank(node.right), wavlrank(node.left) skew = rr - lr diff = node.rank - max(rr, lr) skew, diff <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    ,           .  ,  ,    ,    ,    -,   - . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end # pivot       function double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end function Base.setindex!(avlt::AVLTree{K,V}, val, key) where {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left #   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> </div></div><br><h4 id="udalenie-zapisi-1">   </h4><br><p>    ,     —    -.        . </p><br><p> <strong> 0</strong> <br>       , ..: </p><br><ol><li>  1,     1   </li><li>  0,    2  ,     . <br>    . </li></ol><br><p> <strong> 1</strong> <br>     2 ( 0,   2   ). <br>    1   . </p><br><p> <strong> 2</strong> <br>  1,     2. </p><br><p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br><p>      1,  . </p><br><p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br><p> <strong> 3</strong> <br>  2 (     1, ..          ),         2  . </p><br><p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br><p>       ,    .  . </p><br><p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br><p> <strong> 4</strong> <br><img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br><p>  ,          ,      , ..      . </p><br><p>   —   T <sub>1</sub>  T <sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1. </p><br><p> <strong> 5</strong> <br><img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br><p> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::WAVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::WAVLNode) node = start skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> node.rank = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> diff == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew, prev_diff = imbalance(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_diff == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> prev_skew == <span class="hljs-number"><span class="hljs-number">0</span></span> n.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> prev_skew == dir double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rotate!(n, dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>      -. </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wavl = WAVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avl = AVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dd = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; x = trues(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       ~  julia&gt; for i = 1:1_000_000; dd[i] = avl[i] = wavl[i] = i * i; end julia&gt; for i=1:500_000 k = rand(1:1_000_000) x[k] = false delete!(avl, k) delete!(wavl, k) delete!(dd, k) end # ,     julia&gt; const y = Int[] julia&gt; for i in eachindex(x); if x[i] push!(y, i); end; end julia&gt; @btime let s = 0.0; for idx in y; s += dd[idx]; end; s; end 57.626 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += wavl[idx]; end; s; end 57.796 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += avl[idx]; end; s; end 53.884 ms (0 allocations: 0 bytes) 2.0238199367708794e17</span></span></code> </pre> <br><p> ,        ,    . , ,   -    ,   -,    . </p><br><h3 id="primenenie-derevev-poiska">    </h3><br><p>    —   ? <br>   —   ,   . ,   ,  . </p><br><p>           . </p><br><h4 id="uporyadochennoe-mnozhestvo">   </h4><br><p>    —   ,           .      <em>n</em> -   . ,     , ..  ,       . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th></tr></thead><tbody><tr><td>    </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td> <em>n</em> -  </td><td> <em>O</em> (log <em>N</em> )* </td><td> <em>O</em> (1) </td></tr></tbody></table></div><br><p> *         </p><br><h4 id="associativnyy-massiv">   </h4><br><p>   —   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th> - </th><th>  </th><th>   </th></tr></thead><tbody><tr><td> 搜寻 </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> )** </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>    </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr></tbody></table></div><br><p> *    <br> **     <em>O</em> (1),     ... </p><br><h4 id="ochered-s-prioritetami">    </h4><br><p>    ,       " — ".      ,    .   —     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th><th>  </th><th>  / </th></tr></thead><tbody><tr><td>   </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1)** </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr></tbody></table></div><br><p> *        <br> **  ,       </p><br><h3 id="vyvod"> 结论 </h3><br><p> ()    —       ,   , ,   , ,    .      —     , ..  ,         ,   . </p><br><h2 id="ssylki"> 参考文献 </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">nickme</a> </li><li> Rank-Balanced Trees by Bernhard Haeupler, Siddhartha Sen, Robert E. Tarjan // ACM Transactions on Algorithms | June 2015, Vol 11(4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pdf</a> </li><li> Goodrich MT, Tamassia R. Algorithm Design and Applications </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455172/">https://habr.com/ru/post/zh-CN455172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455160/index.html">通过LINQ进行全文搜索的实体框架6</a></li>
<li><a href="../zh-CN455164/index.html">Elena Balashova：“活动家提出了一个问题，即我们的GIS门户数据应该对OpenStreetMap开放”</a></li>
<li><a href="../zh-CN455166/index.html">Beeline路由器上的VPN绕过锁</a></li>
<li><a href="../zh-CN455168/index.html">ATtiny5上的492字节演示</a></li>
<li><a href="../zh-CN455170/index.html">用于字节访问SSD的新架构-工作原理</a></li>
<li><a href="../zh-CN455176/index.html">没有Redux是否有可能？</a></li>
<li><a href="../zh-CN455178/index.html">如果可以的话，赶上我。 导演版</a></li>
<li><a href="../zh-CN455184/index.html">250美元的3D打印机</a></li>
<li><a href="../zh-CN455186/index.html">MIT 3D打印机：每个模型最多10种材料</a></li>
<li><a href="../zh-CN455190/index.html">心肌细胞的3D打印</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>