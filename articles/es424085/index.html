<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö†Ô∏è üë®üèæ‚Äçüîß ü§≤ Estamos desarrollando el m√≥dulo procesador NIOS II para IDA Pro üë®‚Äçüëß üïµüèø üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Captura de pantalla de la interfaz IDA Pro Disassembler 

 IDA Pro es un famoso desensamblador que ha sido utilizado por investigadores de seguridad d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos desarrollando el m√≥dulo procesador NIOS II para IDA Pro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424085/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="imagen"></a> <br><br>  <i>Captura de pantalla de la interfaz IDA Pro Disassembler</i> <br><br>  IDA Pro es un famoso desensamblador que ha sido utilizado por investigadores de seguridad de la informaci√≥n en todo el mundo durante muchos a√±os.  Nosotros en Positive Technologies tambi√©n usamos esta herramienta.  Adem√°s, pudimos desarrollar nuestro propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dulo procesador de desensamblador para la arquitectura de microprocesador NIOS II</a> , lo que aumenta la velocidad y la conveniencia del an√°lisis de c√≥digo. <br><br>  Hoy contar√© sobre la historia de este proyecto y mostrar√© lo que sucedi√≥ al final. <a name="habracut"></a><br><br><h2>  Antecedentes </h2><br>  Todo comenz√≥ en 2016, cuando tuvimos que desarrollar nuestro propio m√≥dulo de procesador para analizar el firmware en una tarea.  El desarrollo se realiz√≥ desde cero en la <a href="">Gu√≠a de referencia del procesador cl√°sico Nios II</a> , que era la m√°s relevante.  En total, este trabajo tom√≥ alrededor de dos semanas. <br><br>  El m√≥dulo del procesador fue desarrollado para la versi√≥n IDA 6.9.  Para la velocidad, se eligi√≥ IDA Python.  En el lugar donde residen los m√≥dulos del procesador, el subdirectorio procs dentro del directorio de instalaci√≥n de IDA Pro, hay tres m√≥dulos Python: msp430, ebc, spu.  En ellos, puede ver c√≥mo se organiza el m√≥dulo y c√≥mo se puede implementar la funcionalidad b√°sica de desmontaje: <br><br><ul><li>  instrucciones de an√°lisis y operandos, </li><li>  su simplificaci√≥n y exhibici√≥n, </li><li>  crear compensaciones, referencias cruzadas, as√≠ como el c√≥digo y los datos a los que se refieren </li><li>  procesamiento de construcciones de interruptores, </li><li>  manejo de manipulaciones con la pila y las variables de la pila. </li></ul><br>  Aproximadamente dicha funcionalidad se implement√≥ en ese momento.  Afortunadamente, la herramienta fue √∫til en el proceso de trabajar en otra tarea, durante la cual, un a√±o despu√©s, fue utilizada y refinada activamente. <br><br>  Decid√≠ compartir la experiencia de crear el m√≥dulo procesador con la comunidad en los PHDays 8. La presentaci√≥n despert√≥ inter√©s (el informe del video fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicado</a> en el sitio web de PHDays), incluso el creador de IDA Pro Ilfak Gilfanov estuvo presente.  Una de sus preguntas fue si se implement√≥ el soporte para IDA Pro versi√≥n 7. En ese momento no estaba all√≠, pero despu√©s del rendimiento, promet√≠ hacer un lanzamiento apropiado del m√≥dulo.  Aqu√≠ es donde comenz√≥ la diversi√≥n. <br><br>  Ahora el √∫ltimo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual de Intel</a> , que se utiliz√≥ para verificar y verificar errores.  Revis√© significativamente el m√≥dulo, agregu√© una serie de nuevas caracter√≠sticas, incluida la resoluci√≥n de aquellos problemas que antes no se pod√≠an vencer.  Bueno, por supuesto, agregu√© soporte para la s√©ptima versi√≥n de IDA Pro.  Esto es lo que pas√≥. <br><br><h2>  Modelo de software NIOS II </h2><br>  NIOS II es un procesador de software desarrollado para Altera FPGA (ahora parte de Intel).  Desde el punto de vista de los programas, tiene las siguientes caracter√≠sticas: orden de bytes de little endian, espacio de direcciones de 32 bits, conjunto de instrucciones de 32 bits, es decir, 4 bytes, 32 registros generales y 32 de prop√≥sito especial se utilizan para codificar cada comando. <br><br><h2>  Desmontaje y referencias de c√≥digo </h2><br>  Entonces, abrimos un nuevo archivo en IDA Pro, con firmware para el procesador NIOS II.  Despu√©s de instalar el m√≥dulo, lo veremos en la lista de procesadores IDA Pro.  La elecci√≥n del procesador se muestra en la figura. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Supongamos que el m√≥dulo a√∫n no ha implementado ni siquiera un an√°lisis b√°sico de comandos.  Dado que cada comando toma 4 bytes, agrupamos los bytes en cuatro, luego todo se ver√° m√°s o menos as√≠. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  Despu√©s de implementar la funcionalidad b√°sica de decodificar instrucciones y operandos, mostrarlos en la pantalla y analizar las instrucciones de transferencia de control, el conjunto de bytes del ejemplo anterior se convierte al siguiente c√≥digo. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  Como se puede ver en el ejemplo, las referencias cruzadas tambi√©n se generan a partir de comandos de transferencia de control (en este caso, puede ver el salto condicional y la llamada al procedimiento). <br><br>  Una de las propiedades √∫tiles que se pueden implementar en los m√≥dulos del procesador son los comentarios de comandos.  Si deshabilita la salida de valores de byte y habilita la salida de comentarios, la misma secci√≥n de c√≥digo ya se ver√° as√≠. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Aqu√≠, si encontr√≥ por primera vez el c√≥digo de ensamblador de una nueva arquitectura para usted, utilizando comentarios puede comprender lo que est√° sucediendo.  Adem√°s, los ejemplos de c√≥digo estar√°n en la misma forma, con comentarios, para no mirar el manual de NIOS II, sino para comprender de inmediato lo que est√° sucediendo en la secci√≥n de c√≥digo, que se da como ejemplo. <br><br><h2>  Pseudoinstrucciones y simplificaci√≥n de comandos. </h2><br>  Algunos comandos de NIOS II son pseudo instrucciones.  No hay c√≥digos de operaci√≥n separados para tales equipos, y ellos mismos est√°n modelados como casos especiales de otros equipos.  En el proceso de desmontaje, se realiza la simplificaci√≥n de las instrucciones: el reemplazo de ciertas combinaciones con pseudoinstrucciones.  Las pseudoinstrucciones en NIOS II generalmente se pueden dividir en cuatro tipos: <br><br><ul><li>  cuando una de las fuentes es cero (r0) y puede eliminarse de la consideraci√≥n, </li><li>  cuando el equipo tiene un valor negativo y el equipo es reemplazado por el opuesto, </li><li>  cuando la condici√≥n se invierte, </li><li>  cuando el desplazamiento de 32 bits se ingresa en dos equipos en partes (el m√°s joven y el m√°s viejo) y esto se reemplaza por un comando. </li></ul><br>  Se implementaron los dos primeros tipos, ya que reemplazar la condici√≥n no da nada especial, y las compensaciones de 32 bits tienen m√°s opciones de las que se presentan en el manual. <br><br>  Por ejemplo, para la primera vista, considere el c√≥digo. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  Se ve que el uso del registro cero en los c√°lculos a menudo se encuentra aqu√≠.  Si observa detenidamente este ejemplo, notar√° que todos los comandos, excepto la transferencia de control, son opciones para simplemente ingresar valores en registros espec√≠ficos. <br><br>  Despu√©s de implementar el procesamiento de pseudo instrucciones, obtenemos la misma secci√≥n de c√≥digo, pero ahora parece m√°s legible, y en lugar de variaciones de los comandos o y add, obtenemos variaciones del comando mov. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Variables de la pila </h2><br>  La arquitectura NIOS II es compatible con la pila, y adem√°s del puntero de pila sp, tambi√©n hay un puntero al marco de pila fp.  Considere un ejemplo de un peque√±o procedimiento que usa una pila. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  Obviamente, el espacio est√° reservado para las variables locales en la pila.  Se puede suponer que el registro ra se almacena en la variable de pila y luego se restaura a partir de √©l. <br><br>  Despu√©s de agregar funcionalidad al m√≥dulo que rastrea los cambios en el puntero de la pila y crea variables de pila, el mismo ejemplo se ver√° as√≠. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Ahora el c√≥digo se ve un poco m√°s claro, y ya puede nombrar las variables de la pila y analizar su prop√≥sito siguiendo las referencias cruzadas.  La funci√≥n en el ejemplo es del tipo __fastcall y sus argumentos en los registros r4 y r5 se insertan en la pila para llamar a un subprocedimiento que es del tipo _stdcall. <br><br><h2>  N√∫meros y compensaciones de 32 bits </h2><br>  La peculiaridad de NIOS II es que en una operaci√≥n, es decir, al ejecutar un solo comando, es posible registrar como m√°ximo un valor directo de 2 bytes (16 bits) de tama√±o.  Por otro lado, los registros del procesador y el espacio de direcciones son de 32 bits, es decir, para el direccionamiento, se deben ingresar 4 bytes en el registro. <br><br>  Para resolver este problema, se utilizan desplazamientos de dos partes.  Se usa un mecanismo similar en los procesadores de PowerPC: el desplazamiento consta de dos partes, la m√°s antigua y la m√°s joven, y se ingresa en el registro mediante dos comandos.  En PowerPC, esto es lo siguiente. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  En este enfoque, los enlaces cruzados se forman a partir de ambos equipos, aunque de hecho, la direcci√≥n se configura en el segundo comando.  Esto a veces puede ser una molestia al contar el n√∫mero de referencias cruzadas. <br><br>  Las propiedades de desplazamiento para la parte m√°s antigua usan el tipo no est√°ndar HIGHA16, a veces se usa el tipo HIGH16, para la parte m√°s joven - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  No hay nada complicado en el c√°lculo de n√∫meros de dos partes de 32 bits.  Las dificultades surgen en la formaci√≥n de operandos como compensaciones para dos equipos separados.  Todo este procesamiento recae en el m√≥dulo del procesador.  No hay ejemplos de c√≥mo implementar esto (especialmente en Python) en el SDK de IDA. <br><br>  En el informe sobre PHDays, los sesgos se erigieron como un problema no resuelto.  Para resolver el problema, hicimos trampa: compensaci√≥n de 32 bits solo desde la parte m√°s joven, en la base.  La base se calcula como la parte m√°s antigua, desplazada a la izquierda 16 bits. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  Con este enfoque, se forma una referencia cruzada solo con el comando para ingresar la parte inferior del desplazamiento de 32 bits. <br><br>  La base es visible en las propiedades de desplazamiento y la propiedad est√° marcada para considerarla como un n√∫mero, de modo que no se forma una gran cantidad de referencias cruzadas a la direcci√≥n en s√≠, que tomamos como base. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  En el c√≥digo para NIOS II, se encuentra el siguiente mecanismo para ingresar n√∫meros de 32 bits en el registro.  Primero, la parte m√°s antigua del desplazamiento se ingresa en el registro con el comando movhi.  Entonces la parte m√°s joven se une.  Esto se puede hacer de tres maneras (mediante comandos): agregando addi, restando subi, l√≥gico OR ori. <br><br>  Por ejemplo, en la siguiente secci√≥n del c√≥digo, los registros se establecen en n√∫meros de 32 bits, que luego se ingresan en registros, argumentos antes de llamar a la funci√≥n. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  Despu√©s de agregar el c√°lculo de desplazamiento, obtenemos la siguiente representaci√≥n de este bloque de c√≥digo. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  El desplazamiento de 32 bits resultante se muestra junto al comando para ingresar su parte inferior.  Este ejemplo es bastante ilustrativo, e incluso podr√≠amos calcular f√°cilmente todos los n√∫meros de 32 bits en la mente simplemente agregando las partes menores y m√°s altas.  A juzgar por los valores, lo m√°s probable es que no sean sesgos. <br><br>  Considere el caso cuando se usa la resta al ingresar a la parte m√°s joven.  En este ejemplo, no ser√° posible determinar los n√∫meros finales de 32 bits (compensaciones) en el movimiento. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  Despu√©s de aplicar el c√°lculo de n√∫meros de 32 bits, obtenemos el siguiente formulario. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Aqu√≠ vemos que ahora, si la direcci√≥n est√° en el espacio de direcciones, se forma un desplazamiento en ella, y el valor que se form√≥ como resultado de la conexi√≥n de las partes menores y mayores ya no se muestra cerca.  Aqu√≠ obtuvieron un desplazamiento por la l√≠nea "22/10/08".  Para que el resto de las compensaciones apunten a direcciones v√°lidas, aumentemos un poco el segmento. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  Despu√©s de aumentar el segmento, obtenemos que ahora todos los n√∫meros calculados de 32 bits son compensaciones e indican direcciones v√°lidas. <br><br>  Se mencion√≥ anteriormente que hay otra opci√≥n para calcular las compensaciones cuando se usa un comando l√≥gico OR.  Aqu√≠ hay un c√≥digo de ejemplo donde se calculan dos compensaciones de esta manera. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  El que se eval√∫a en el registro r8 se empuja a la pila. <br><br>  Despu√©s de la conversi√≥n, est√° claro que en este caso los registros se configuran a las direcciones del comienzo de los procedimientos, es decir, la direcci√≥n del procedimiento se inserta en la pila. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Leer y escribir en relaci√≥n con la base </h2><br>  Antes de eso, consideramos los casos en que un n√∫mero de 32 bits ingresado usando dos comandos podr√≠a ser solo un n√∫mero y tambi√©n un desplazamiento.  En el siguiente ejemplo, la base se ingresa en la parte superior del registro, luego se lee o escribe en relaci√≥n con ella. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  Despu√©s de procesar tales situaciones, obtenemos el desplazamiento de las variables de los comandos de lectura y escritura.  Adem√°s, dependiendo de la dimensi√≥n de la operaci√≥n, se establece el tama√±o de la variable en s√≠. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Cambiar construcciones </h2><br>  Las construcciones de conmutadores que se encuentran en los archivos binarios pueden facilitar el an√°lisis.  Por ejemplo, por el n√∫mero de casos de selecci√≥n dentro de la construcci√≥n del conmutador, puede localizar el conmutador responsable de procesar un determinado protocolo o sistema de comando.  Por lo tanto, surge la tarea de reconocer el interruptor en s√≠ y sus par√°metros.  Considere la siguiente secci√≥n de c√≥digo. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  El hilo de ejecuci√≥n se detiene en la transici√≥n de registro jmp r2.  Adem√°s, hay bloques de c√≥digo a los que hay enlaces desde los datos, y al final de cada bloque hay un salto a la misma etiqueta.  Obviamente, esta es una construcci√≥n de interruptor y estos bloques individuales manejan casos espec√≠ficos de ella.  Arriba tambi√©n puede ver la verificaci√≥n del n√∫mero de casos y el salto predeterminado. <br><br>  Despu√©s de agregar el procesamiento del interruptor, este c√≥digo se ver√° as√≠. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Ahora se indica el salto en s√≠, la direcci√≥n de la tabla con desplazamientos, el n√∫mero de casos, as√≠ como cada caso con el n√∫mero correspondiente. <br><br>  La tabla en s√≠ con compensaciones a las opciones es la siguiente.  Para ahorrar espacio, se dan los primeros cinco elementos. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  De hecho, el procesamiento del conmutador consiste en volver a trav√©s del c√≥digo y buscar todos sus componentes.  Es decir, se describe un esquema de organizaci√≥n de cambio.  A veces puede haber excepciones en los esquemas.  Esta puede ser la raz√≥n de los casos en que los interruptores aparentemente claros no se reconocen en los m√≥dulos de procesador existentes.  Resulta que el interruptor real simplemente no cae dentro del esquema que se define dentro del m√≥dulo del procesador.  Todav√≠a hay opciones posibles cuando el circuito parece estar all√≠, pero hay otros equipos dentro de √©l que no est√°n involucrados en el circuito, o los equipos principales se reorganizan o se interrumpe por las transiciones. <br><br>  El m√≥dulo procesador NIOS II reconoce un interruptor con instrucciones "extra√±as" entre los comandos principales, as√≠ como con los lugares reorganizados de los comandos principales y con interrupciones que interrumpen el circuito.  Se utiliza una ruta de retorno a lo largo de la ruta de ejecuci√≥n, teniendo en cuenta las posibles transiciones que rompen el circuito, con la instalaci√≥n de variables internas que se√±alan diferentes estados del reconocedor.  Como resultado, se reconocen alrededor de 10 opciones de organizaci√≥n de conmutadores diferentes que se encuentran en el firmware. <br><br><h2>  Instrucci√≥n personalizada </h2><br>  Hay una caracter√≠stica interesante en la arquitectura NIOS II: la instrucci√≥n personalizada.  Da acceso a 256 instrucciones definidas por el usuario que son posibles en la arquitectura NIOS II.  En su trabajo, adem√°s de los registros de prop√≥sito general, la instrucci√≥n personalizada puede acceder a un conjunto especial de 32 registros personalizados.  Despu√©s de implementar la l√≥gica para analizar el comando personalizado, obtenemos el siguiente formulario. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  Puede notar que las dos √∫ltimas instrucciones tienen el mismo n√∫mero de instrucci√≥n y parecen realizar las mismas acciones. <br><br>  De acuerdo con las instrucciones personalizadas, hay un <a href="">manual por separado</a> .  Seg√∫n √©l, una de las opciones m√°s completas y actualizadas para el conjunto de instrucciones personalizadas es el conjunto de instrucciones NIOS II Floating Point Hardware 2 Component (FPH2) para trabajar con el punto flotante.  Despu√©s de implementar el an√°lisis de los comandos FPH2, el ejemplo se ver√° as√≠. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  De la mnemotecnia de los dos √∫ltimos equipos, nos aseguramos de que realmente realicen la misma acci√≥n: el comando fadds. <br><br><h2>  Transiciones por valor de registro </h2><br>  En el firmware bajo investigaci√≥n, a menudo se encuentra una situaci√≥n cuando se realiza un salto de acuerdo con el valor del registro, en el que se ingresa antes un desplazamiento de 32 bits, que determina el lugar del salto. <br><br>  Considere una pieza de c√≥digo. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  En la √∫ltima l√≠nea hay un salto en el valor del registro, mientras que est√° claro que antes de ingresar la direcci√≥n del procedimiento en el registro, que comienza en la primera l√≠nea del ejemplo.  En este caso, es obvio que el salto se realiza desde el principio. <br><br>  Despu√©s de agregar la funcionalidad de reconocimiento de saltos, se obtiene el siguiente formulario. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  Junto al comando jmp r8, se muestra la direcci√≥n donde se produce el salto si fuera posible calcular.  Tambi√©n se forma una referencia cruzada entre el equipo y la direcci√≥n donde tiene lugar el salto.  En este caso, el enlace es visible en la primera l√≠nea, el salto en s√≠ se realiza desde la √∫ltima l√≠nea. <br><br><h2>  Valor de registro de gp (puntero global), guardar y cargar </h2><br>  Es com√∫n usar un puntero global que est√° configurado para alguna direcci√≥n, y las variables se direccionan en relaci√≥n con √©l.  NIOS II utiliza el registro gp (puntero global) para almacenar el puntero global.  En alg√∫n momento, como regla, en los procedimientos de inicializaci√≥n del firmware, el valor de la direcci√≥n se ingresa en el registro gp.  El m√≥dulo procesador maneja esta situaci√≥n;  Para ilustrar esto, los siguientes son ejemplos de c√≥digo y la ventana de salida de IDA Pro cuando los mensajes de depuraci√≥n est√°n habilitados en el m√≥dulo del procesador. <br><br>  En este ejemplo, el m√≥dulo procesador encuentra y calcula el valor del registro gp en la nueva base de datos.  Al cerrar la base de datos idb, el valor de gp se almacena en la base de datos. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  Al cargar una base de datos idb existente y si el valor de gp ya se ha encontrado, se carga desde la base de datos, como se muestra en el mensaje de depuraci√≥n en el siguiente ejemplo. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Leer y escribir sobre gp </h2><br>  Las operaciones comunes son leer y escribir con un desplazamiento relativo al registro gp.  Por ejemplo, en el siguiente ejemplo, se realizan tres lecturas y un registro de este tipo. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Como ya obtuvimos el valor de la direcci√≥n que est√° almacenada en el registro gp, podemos abordar este tipo de lectura y escritura. <br><br>  Despu√©s de agregar el procesamiento para situaciones de lectura y escritura en relaci√≥n con el registro gp, obtenemos una imagen m√°s conveniente. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Aqu√≠ puede ver a qu√© variables se est√° accediendo, realizar un seguimiento de su uso e identificar su prop√≥sito. <br><br><h2>  Direccionamiento relativo a gp </h2><br>  Hay otro uso del registro gp para direccionar variables. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  Por ejemplo, aqu√≠ vemos que los registros est√°n configurados en relaci√≥n con el registro gp para algunas variables o √°reas de datos. <br><br>  Despu√©s de agregar funcionalidad que reconoce tales situaciones, se convierte en compensaciones y agrega referencias cruzadas, obtenemos el siguiente formulario. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Aqu√≠ ya puede ver qu√© √°reas relativas a los registros gp est√°n configuradas, y queda m√°s claro lo que est√° sucediendo. <br><br><h2>  Direccionamiento relativo a sp </h2><br>  De manera similar, en el siguiente ejemplo, los registros est√°n sintonizados en algunas √°reas de memoria, esta vez en relaci√≥n con el puntero de registro a la pila. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  Obviamente, los registros est√°n ajustados a algunas variables locales.  Tales situaciones (establecer argumentos en memorias intermedias locales antes de las llamadas a procedimientos) son bastante comunes. <br><br>  Despu√©s de agregar el procesamiento (convertir valores directos en compensaciones), obtenemos el siguiente formulario. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Ahora queda claro que despu√©s de la llamada al procedimiento, los valores se cargan desde aquellas variables cuyas direcciones se pasaron como par√°metros antes de la llamada a la funci√≥n. <br><br><h2>  Referencias cruzadas del c√≥digo a los campos de estructura </h2><br>  Definir estructuras y usarlas en IDA Pro puede facilitar el an√°lisis de c√≥digo. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  Al observar esta parte del c√≥digo, podemos entender que el campo field_8 se est√° incrementando y, posiblemente, es un contador de la ocurrencia de un evento.  Si los campos de lectura y escritura est√°n separados en el c√≥digo a una gran distancia, las referencias cruzadas pueden ayudar. <br><br>  Considere la estructura misma. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque el acceso a los campos de estructuras es, como vemos, no hay referencias cruzadas del c√≥digo a los elementos de las estructuras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de que se procesen tales situaciones, para nuestro caso todo se ver√° de la siguiente manera. </font></font><br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hay referencias cruzadas para estructurar campos de equipos espec√≠ficos que trabajan con estos campos. </font><font style="vertical-align: inherit;">Se crean referencias cruzadas hacia adelante y hacia atr√°s, y puede realizar un seguimiento mediante diversos procedimientos donde se leen los valores de los campos de estructura y d√≥nde se ingresan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Discrepancias entre manual y realidad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el manual, al decodificar algunos comandos, ciertos bits deben tomar valores estrictamente definidos. </font><font style="vertical-align: inherit;">Por ejemplo, para un comando de retorno de una excepci√≥n eret, los bits 22‚Äì26 deben ser 0x1E. </font></font><br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay un ejemplo de este comando de un firmware. </font></font><br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al abrir otro firmware en un lugar con un contexto similar, nos encontramos con una situaci√≥n diferente. </font></font><br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos bytes no se convirtieron autom√°ticamente en un comando, aunque hay un procesamiento de todos los comandos. </font><font style="vertical-align: inherit;">A juzgar por el entorno, e incluso una direcci√≥n similar, este deber√≠a ser el mismo equipo. </font><font style="vertical-align: inherit;">Miremos cuidadosamente los bytes. </font><font style="vertical-align: inherit;">Este es el mismo comando eret, con la excepci√≥n de que los bits 22‚Äì26 no son iguales a 0x1E, sino iguales a cero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos que arreglar un poco el an√°lisis de este comando. </font><font style="vertical-align: inherit;">Ahora no corresponde exactamente al manual, pero corresponde a la realidad.</font></font><br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Soporte IDA 7 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzando con IDA 7.0, la API proporcionada por Python IDA para scripts regulares ha cambiado bastante. En cuanto a los m√≥dulos de procesador, los cambios son colosales. A pesar de esto, el m√≥dulo del procesador NIOS II pudo rehacerse para la versi√≥n 7, y funcion√≥ con √©xito en √©l. </font></font><br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫nico momento incomprensible: cuando se carga un nuevo archivo binario bajo NIOS II en IDA 7, el an√°lisis autom√°tico inicial que est√° presente en IDA 6.9 no ocurre.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de la funcionalidad b√°sica de desmontaje, cuyos ejemplos se encuentran en el SDK, el m√≥dulo del procesador implementa muchas caracter√≠sticas diferentes que facilitan el trabajo del explorador de c√≥digo. </font><font style="vertical-align: inherit;">Est√° claro que todo esto se puede hacer manualmente, pero, por ejemplo, cuando hay miles y decenas de miles de compensaciones de diferentes tipos en un archivo binario con firmware de un par de megabytes, ¬øpor qu√© dedicar tiempo a esto? </font><font style="vertical-align: inherit;">Deje que el m√≥dulo procesador haga esto por nosotros. </font><font style="vertical-align: inherit;">Despu√©s de todo, ¬øc√≥mo son las caracter√≠sticas agradables de la navegaci√≥n r√°pida a trav√©s del c√≥digo estudiado usando referencias cruzadas! </font><font style="vertical-align: inherit;">Esto hace de IDA una herramienta tan conveniente y agradable como la conocemos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publicado por</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton Dorfman, Tecnolog√≠as positivas</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424085/">https://habr.com/ru/post/es424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424071/index.html">Teor√≠a de la felicidad. Termodin√°mica de la desigualdad de clase.</a></li>
<li><a href="../es424073/index.html">Ejecuci√≥n remota de c√≥digo en Microsoft JET Database Engine</a></li>
<li><a href="../es424077/index.html">Francia exige que el "derecho al olvido" sea global: lo que puede afectar</a></li>
<li><a href="../es424081/index.html">RESS - Nueva arquitectura para aplicaciones m√≥viles</a></li>
<li><a href="../es424083/index.html">Un servicio para comerciar en el intercambio Robinhood fue acusado de vender datos sobre aplicaciones de usuarios a operadores de alta frecuencia</a></li>
<li><a href="../es424087/index.html">Dispositivo Android controlado por Arduino controlado por Bluetooth - ciclo completo (parte 1)</a></li>
<li><a href="../es424089/index.html">Las conferencias son malvadas. O bien?</a></li>
<li><a href="../es424091/index.html">WiX.Py: recopilamos el paquete MSI "en tres l√≠neas"</a></li>
<li><a href="../es424093/index.html">Desde radio antigua hasta parlantes DIY: 12 canales de YouTube para un dispositivo ac√∫stico</a></li>
<li><a href="../es424099/index.html">Determinar la madurez de una sand√≠a usando Keras: un ciclo completo, de una idea a un programa en Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>