<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌛️ 👨🏾‍🌾 🤟🏿 Bereaksi kuis kontes parsing dari booth HeadHunter di HolyJs 2018 📰 👛 👉🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Pada 24-25 September, sebuah konferensi para pengembang front-end HolyJs berlangsung di Moskow https://holyjs-moscow.ru/ . Kami datang ke konferen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi kuis kontes parsing dari booth HeadHunter di HolyJs 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/431492/"><p>  Hai  Pada 24-25 September, sebuah konferensi para pengembang front-end HolyJs berlangsung di Moskow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://holyjs-moscow.ru/</a> .  Kami datang ke konferensi dengan stand kami di mana kami mengadakan kuis.  Ada kuis utama - 4 babak kualifikasi dan 1 putaran final, di mana Apple Watch dan konstruktor lego dimainkan.  Dan secara terpisah, kami melakukan kuis pengetahuan reaksi. </p><br><p>  Di bawah tugas kuis mengurai cat pada reaksi.  Opsi yang benar akan disembunyikan di bawah spoiler, jadi Anda tidak hanya dapat membaca analisisnya, tetapi juga memeriksa diri Anda sendiri :) </p><br><p><img src="https://habrastorage.org/webt/ot/wn/yq/otwnyqyymtf5t_yedi3aj2-wuau.jpeg" alt="gambar"></p><br><p>  Ayo pergi! </p><a name="habracut"></a><br><p>  Untuk kenyamanan, kami mengelompokkan pertanyaan menjadi beberapa bagian: </p><br><h3 id="sekciya-1-bazovoe-ponimanie-raboty-thissetstate-i-updating-lifecycle-komponenta">  Bagian 1. Pemahaman dasar operasi this.setState dan memperbarui siklus hidup komponen: </h3><br><p>  <strong>Pertanyaan 1.</strong> </p><br><pre><code class="plaintext hljs">      react-: 1) SetProps, SetState, ForceUpdate 2) ForceUpdate, SetState 3) ForceUpdate, SetState, Parent (re)render 4) ForceUpdate, SetState, directly call UpdateComponent</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  3) ForceUpdate, SetState, Parent (re) render </p></div></div><br><p>  <strong>Pertanyaan 2.</strong> </p><br><pre> <code class="plaintext hljs"> ,   this.setState({})  react 1)   ,  updating lifecycle 2)   ,    3) React    "Object cannot be empty" 4)    state  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  1) Komponen ditandai kotor, memperbarui siklus hidup disebut </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analisis pertanyaan 1 dan 2</b> <div class="spoiler_text"><p>  Untuk menjawab pertanyaan, kami akan menganalisis 2 bagian: <br>  1) Permintaan komponen sendiri untuk memperbarui siklus <br>  2) Permintaan di luar komponen </p><br><p>  Komponen itu sendiri memiliki 2 cara untuk memperbarui sendiri: <br>  1) this.setState dan this.forceUpdate.  Dalam hal ini, komponen akan ditandai kotor dan pada centang Rekonsiliasi, jika prioritas untuk rendering, siklus pembaruan akan dimulai. </p><br><p>  Fakta menarik: <code>this.setState({})</code> dan <code>this.forceUpdate</code> berbeda.  Ketika <code>this.setState({})</code> dipanggil, loop pembaruan penuh disebut, tidak seperti <code>this.forceUpdate</code> , ketika loop pembaruan dimulai tanpa metode shouldComponentUpdate.  Contoh karya <code>this.setState({})</code> dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://codesandbox.io/s/m5jz2701l9</a> (jika Anda mengganti setState dengan forceUpdate dalam contoh, Anda dapat melihat bagaimana perilaku komponen berubah). </p><br><p>  2) Ketika orang tua komponen dirender kembali, ia mengembalikan bagian vDOM, semua anak-anak yang perlu diperbarui, dan mereka juga akan disebut siklus hidup pembaruan penuh.  Penghitungan ulang lengkap dari subtree dapat dihindari dengan menjelaskan shouldComponentUpdate atau dengan mendefinisikan komponen sebagai PureComponent. </p></div></div><br><p>  <strong>Pertanyaan 3</strong> </p><br><pre> <code class="plaintext hljs">  Component  PureComponent (PC) 1) Component   ,    Pure 2) PC  SCU,  shallowEqual props  state 3) PC    ,    store 4)  PC    shouldComponentUpdate</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  2) PC mengimplementasikan SCU, melakukan props dangkal dan menyatakan </p><br><p>  Seperti yang kita bahas sebelumnya, ketika (kembali) merender induk, seluruh subtree akan dikirim ke siklus hidup yang diperbarui.  Bayangkan Anda telah memperbarui elemen root.  Dalam hal ini, sesuai dengan efek berantai, Anda harus memperbarui hampir seluruh pohon reaksi.  Untuk mengoptimalkan dan tidak mengirim pembaruan yang tidak perlu, pada reaksi ada metode <code>shouldComponentUpdate</code> , yang memungkinkan Anda untuk mengembalikan true jika komponen harus diperbarui, dan false jika tidak.  Untuk menyederhanakan perbandingan dalam reaksi, Anda dapat mewarisi dari <code>PureComponent</code> untuk bersiap-siap segera <code>shouldComponentUpdate</code> , yang membandingkan dengan referensi (jika menyangkut jenis objek) atau dengan nilai (jika ini tentang jenis nilai) semua alat peraga dan status yang masuk ke dalam komponen. </p></div></div><br><p>  <strong>Pertanyaan 4.</strong> </p><br><pre> <code class="plaintext hljs">this.setState(() =&gt; {}, () =&gt; {}) —       setState? 1) set   .    updating 2)       state 3) setState   1 </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  2) Fungsi kedua akan dipanggil setelah memperbarui keadaan </p><br><p>  Ada dua metode dalam React-lifecycle: <code>componentDidMount</code> untuk loop pemasangan dan componentDidUpdate untuk memperbarui, di mana Anda dapat menambahkan beberapa logika setelah memperbarui komponen.  Misalnya, buat permintaan http, buat beberapa perubahan gaya, dapatkan metrik elemen html, dan (dengan syarat) buat setState.  Jika Anda ingin mengambil tindakan setelah mengubah bidang tertentu dalam keadaan, maka dalam metode <code>componentDidUpdate</code> Anda harus menulis perbandingan: </p><br><pre> <code class="plaintext hljs">componentDidUpdate(prevProp, prevState) { if (prevState.foo !== this.state.foo) { // do awesome things here } }</code> </pre> <br><p>  Atau Anda dapat melakukannya dengan setState: </p><br><pre> <code class="plaintext hljs">setState( // set new foo {foo: 'baz'}, () =&gt; { // do awesome things here } );</code> </pre> <br><p>  Setiap pendekatan memiliki pro dan kontra (misalnya, jika Anda mengubah setState di beberapa tempat, mungkin lebih mudah untuk menulis suatu kondisi satu kali). </p></div></div><br><p>  <strong>Pertanyaan 5.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' onClick={() =&gt; console.log('foo')} /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  2) 2 </p></div></div><br><p>  <strong>Pertanyaan 6.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><p>  <strong>Pertanyaan 7.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analisis pertanyaan 5-7</b> <div class="spoiler_text"><p>  Pertanyaan 5–7 Diperlukan untuk hal yang sama - untuk memeriksa pemahaman tentang pekerjaan <code>PureComponent</code> dan memperbarui komponen saat pemindahan alat peraga.  Jika di dalam metode render kami meneruskan panggilan balik jsx, menjelaskan ini secara langsung dalam fungsi render: </p><br><pre> <code class="plaintext hljs">render () { return &lt;Button onClick={() =&gt; {}} /&gt;; }</code> </pre> <br><p>  Kemudian setiap render induk akan memperbarui handler klik yang diberikan.  Ini terjadi karena setiap render membuat fungsi baru dengan tautan unik, yang bila dibandingkan di PureComponent akan menunjukkan bahwa alat peraga baru tidak sama dengan yang lama dan Anda perlu memperbarui komponen.  Dalam kasus ketika semua pemeriksaan lulus dan shouldComponentUpdate mengembalikan false, pembaruan tidak terjadi. </p></div></div><br><h3 id="sekciya-2-keys-in-react">  Bagian 2. Kunci dalam Bereaksi </h3><br><p>  Analisis terperinci tentang kunci yang kami terbitkan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/company/hh/blog/352150/</a> </p><br><p>  <strong>Pertanyaan 1.</strong> </p><br><pre> <code class="plaintext hljs">    key,      ? 1)         key 2)    updating lifecycle 3)   key  4)    reconciliation</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  1) Hapus instance sebelumnya dan pasang yang baru saat mengubah kunci </p><br><p>  Tanpa menggunakan kunci, reaksi akan membandingkan daftar elemen berpasangan dari atas ke bawah.  Jika kita menggunakan kunci, perbandingan akan terjadi pada kunci yang sesuai.  Jika kunci baru telah muncul, maka komponen seperti itu tidak akan dibandingkan dengan siapa pun dan akan segera dibuat dari awal. <br>  Anda dapat menggunakan metode ini bahkan jika kita memiliki 1 elemen: kita dapat mengatur <code>&lt;A key="1" /&gt;</code> , dalam render berikutnya kita tentukan <code>&lt;A key="2" /&gt;</code> dan dalam hal ini reaksi akan menghapus <code>&lt;A key="1" /&gt;</code> dan buat dari awal <code>&lt;A key="2" /&gt;</code> . </p></div></div><br><p>  <strong>Pertanyaan 2.</strong> </p><br><pre> <code class="plaintext hljs">      this.prop.key? 1)  2)  3)   static getKey</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  2) Tidak </p><br><p>  Komponen dapat mempelajari kunci dari anak-anaknya, yang diberikan padanya sebagai alat bantu, tetapi tidak dapat mempelajari tentang kunci tersebut. </p></div></div><br><p>  <strong>Pertanyaan 3.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A key='1' /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  2) 2 </p><br><p>  Saat mengganti kunci, komponen akan dibuat ulang, sehingga render akan ditampilkan dua kali. </p></div></div><br><h3 id="sekciya-3-voprosy-po-jsx">  Bagian 3. Pertanyaan tentang jsx </h3><br><p>  <strong>Pertanyaan 1.</strong> </p><br><pre> <code class="plaintext hljs">  .           1)    prop / context 2)        3)  setParentProps 4)  static getParentRef</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  1) Callback dalam bentuk prop / konteks <br>  2) Penghapusan lapisan model dan bekerja melaluinya </p><br><p>  Ada dua jawaban yang benar.  Memilih salah satu dari mereka pada kuis akan menghitung poin Anda.  Pertanyaan ini untuk pengetahuan aliran data yang bereaksi.  Data dari atas ke bawah didistribusikan dalam bentuk alat peraga atau konteks, dapat berisi panggilan balik, yang dapat dipanggil komponen di bawah ini untuk memengaruhi kondisi sistem. <br>  Metode lain yang menggabungkan pemindahan model, konteks dan penyangga, adalah, misalnya, pengikatan re-redux. <br>  Perpustakaan ini mengambil model yang berasal dari react (redux).  Set redux.store di Provider, yang sebenarnya menetapkan store dalam konteks.  Kemudian pengembang menggunakan koneksi HOC, yang masuk ke dalam konteks, berlangganan untuk menyimpan (store.subscribe) perubahan, dan ketika toko berubah, menceritakan fungsi <code>mapStateToProps</code> .  Jika data telah berubah, itu menetapkan mereka dalam alat peraga ke objek yang dibungkus. <br>  Pada saat yang sama, connect memungkinkan Anda untuk menentukan <code>mapDispatchToProps</code> , tempat pengembang menentukan actionCreator yang perlu diteruskan ke komponen.  Kami, pada gilirannya, menerimanya dari luar (tanpa konteks), mengikat <code>actionCreators</code> ke toko (kami membungkusnya di store.dispatch) dan meneruskannya ke komponen yang dibungkus sebagai alat peraga. </p></div></div><br><p>  <strong>Pertanyaan 2.</strong> </p><br><pre> <code class="plaintext hljs">  props   jsx?     1)   2)   children</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  1) Dalam </p><br><p>  Anda dapat mentransfer ke siapa saja.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">&lt;Button icon={&lt;Icon kind='warning'/&gt;}&gt;&lt;/Button&gt;</code> </pre> <br><p>  Gambar tombol dengan ikon.  Pendekatan ini sangat mudah digunakan untuk meninggalkan komponen hak untuk mengontrol lokasi berbagai elemen relatif satu sama lain, daripada memilah satu penyangga anak-anak. </p></div></div><br><h3 id="sekciya-4-prodvinutoe-ponimanie-setstate">  Bagian 4. Advanced Memahami setState </h3><br><p>  Berikut adalah 3 pertanyaan yang sangat terkait: </p><br><p>  <strong>Pertanyaan 1.</strong> </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; ... this.setState({a: 'b'}); this.setState({a: this.state.a + 1}) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'a'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  3) Tidak cukup data </p></div></div><br><p>  <strong>Pertanyaan 2.</strong> </p><br><pre> <code class="plaintext hljs">this.state={a: 'a'} ... this.setState({a: 'b'}) this.setState(state =&gt; ({a: state.a + 1})) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'ab1'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  2) {a: 'b1'} </p></div></div><br><p>  <strong>Pertanyaan 3.</strong> </p><br><pre> <code class="plaintext hljs">   2 setState  componentDidUpdate  updating lifecycle   1) 1 2) 2 3) 3 4)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analisis pertanyaan 1-3</b> <div class="spoiler_text"><p>  Semua pekerjaan setState dijelaskan sepenuhnya di sini: <br>  1) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://reactjs.org/docs/react-component.html#setstate</a> <br>  2) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a> </p><br><p>  Faktanya adalah setState tidak terjadi secara serempak. <br>  Dan jika ada beberapa panggilan untuk setState berturut-turut, tergantung pada apakah kita berada di dalam metode siklus-reaksi, fungsi handler dari event-reaksi (onChange, onClick) atau tidak, pelaksanaan setState tergantung. <br>  Di dalam handler reaksi, setState bekerja dalam batch (perubahan digulir hanya setelah fungsi yang ditentukan pengguna dalam tumpukan panggilan selesai dan kami masuk ke fungsi yang disebut event handler dan metode siklus hidup kami).  Mereka berguling satu demi satu, jadi jika kita berada di dalam penangan reaksi, kita mendapatkan: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +   .       this.state.a // a: 'a' this.setState({a: this.state.a + 1}) // a: 'a1'</code> </pre> <br><p>  sejak perubahan terjadi batchevo. <br>  Tetapi pada saat yang sama, jika setState dipanggil di luar penangan reaksi: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +     this.state.a // a: 'b' this.setState({a: this.state.a + 1}) // a: 'b1' +    </code> </pre> <br><p>  Karena dalam kasus ini, perubahan akan digulirkan secara terpisah. </p></div></div><br><h3 id="sekciya-5-redux">  Bagian 5. Redux </h3><br><p>  <strong>Pertanyaan 1.</strong> </p><br><pre> <code class="plaintext hljs">    action,  () =&gt; {} ? 1) .  action      type 2) ,   action      type 3) ,    middleware   action 4) ,       dispatch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  3) Ya, Anda perlu mendefinisikan middleware khusus untuk tindakan semacam itu </p><br><p>  Ambil redux-thunk sebagai contoh paling sederhana.  Semua middleware adalah blok kode kecil: <br>  <a href="">https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L2-L9</a> </p><br><pre> <code class="plaintext hljs">return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); };</code> </pre> <br><p>  Bagaimana cara kerja middleware? <br>  Mereka mendapatkan kontrol sebelum aksi tiba di toko.  Oleh karena itu, tindakan yang telah ditimpa akan terlebih dahulu melalui rantai middleware. <br>  Setiap middleware menerima instance toko, metode selanjutnya, yang memungkinkan Anda untuk meneruskan tindakan lebih lanjut, dan tindakan itu sendiri. <br>  Jika middleware memproses tindakan kustom, seperti redux-thunk, maka jika tindakan adalah fungsi, itu tidak meneruskan tindakan lebih lanjut, tetapi "menenggelamkan" itu, alih-alih memanggil tindakan dengan metode pengiriman dan getState yang diteruskan ke sana. <br>  Apa yang akan terjadi jika redux-thunk melakukan tindakan selanjutnya, yang merupakan fungsi? <br>  Sebelum memanggil reduksi, toko memeriksa jenis tindakan.  Itu harus memenuhi ketentuan berikut: <br>  1) Itu harus menjadi objek <br>  2) Ini harus memiliki bidang tipe <br>  3) Bidang jenis harus dari tipe string </p><br><p>  Jika salah satu kondisi tidak terpenuhi, redux akan melempar kesalahan. </p></div></div><br><h3 id="bonusnye-voprosy">  Pertanyaan bonus: </h3><br><p>  <strong>Pertanyaan Bonus 1.</strong> </p><br><pre> <code class="plaintext hljs">  ? class Todos extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { return this.props.list.length - prevProps.list.length; } componentDidUpdate(a, b, c) { console.log(c); } ... } ReactDOM.render(&lt;Todos list={['a','b']} /&gt;, app); setTimeout(() =&gt; ReactDOM.render(&lt;Todos list={['a','b','a','b']} /&gt;, app), 0); a) 0 b) 1 c) 2 d) undefined</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawab dan parsing</b> <div class="spoiler_text"><p>  c) 2 </p><br><p>  <code>getSnapshotBeforeUpdate</code> adalah fungsi yang jarang digunakan dalam bereaksi yang memungkinkan Anda untuk mendapatkan snapshot, yang kemudian akan diteruskan ke componentDidUpdate.  Metode ini diperlukan untuk melakukan pra-perhitungan data tertentu berdasarkan yang dapat Anda buat, misalnya, mengambil permintaan. </p></div></div><br><p>  <strong>Pertanyaan Bonus 2.</strong> </p><br><pre> <code class="plaintext hljs">       2,5 ? function Input() { const [text, setText] = useState("World!"); useEffect( () =&gt; { let id = setTimeout(() =&gt; { setText("Hello " + text); }, 1000); return () =&gt; { clearTimeout(id); }; }, [text] ); return ( &lt;input value={text} onChange={e =&gt; { setText(e.target.value); }} /&gt; ); } a) "World!" b) "Hello World!" c) "Hello Hello World!" d)   </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  c) "Hello Hello World!" </p></div></div><br><p>  Ini sudah menjadi pertanyaan untuk mengetahui fitur-fitur baru dalam reaksi, itu bukan dalam kuis kami.  Mari kita coba di komentar untuk menjelaskan secara terperinci operasi kode dari pertanyaan terakhir :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431492/">https://habr.com/ru/post/id431492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431480/index.html">Magento merilis rilis platform utama baru - 2.3.0 GA</a></li>
<li><a href="../id431482/index.html">Dan kamu, Yota ...</a></li>
<li><a href="../id431486/index.html">Lalat yang tak terlihat: metode baru untuk mempelajari sistem saraf melalui depigmentasi jaringan</a></li>
<li><a href="../id431488/index.html">Modulasi suara</a></li>
<li><a href="../id431490/index.html">Eksternal - GUI untuk Golang</a></li>
<li><a href="../id431496/index.html">Bagaimana teknologi membantu guru kelas khusus</a></li>
<li><a href="../id431498/index.html">WebP akan segera mengambil alih web, tetapi itu tidak akan lama</a></li>
<li><a href="../id431500/index.html">Basis data dan Kubernet (laporan ulasan dan video)</a></li>
<li><a href="../id431502/index.html">Konferensi untuk pengembang iOS Kolesa Mobile 3.0. Laporan video</a></li>
<li><a href="../id431504/index.html">Phishing - bekerja. Kronik pencurian iPhone XS diikuti oleh pencurian data iCloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>