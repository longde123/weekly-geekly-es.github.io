<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÖÔ∏è üßëüèª ‚òùüèø Universelles DSL. Ist es m√∂glich? üë≤ ü•ù üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Sprache des Fachgebiets. Nicht mit allgemeinen Sprachkonstrukten √ºberladen. Gleichzeitig k√∂nnen Sie sehr komplexe Logik mit nur wenigen Zeilen imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Universelles DSL. Ist es m√∂glich?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/477902/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/rq/r6/gbrqr6yefzzlp8sboskriuwrne0.png"></div><br>  Die Sprache des Fachgebiets.  Nicht mit allgemeinen Sprachkonstrukten √ºberladen.  Gleichzeitig k√∂nnen Sie sehr komplexe Logik mit nur wenigen Zeilen implementieren.  Das alles ist DSL. <br><br>  F√ºr die Erstellung eines DSL muss der Entwickler jedoch qualifiziert sein.  Die regelm√§√üige Anwendung dieses Ansatzes wird zur Routine, eine andere Sprache zu entwickeln.  Die L√∂sung k√∂nnte darin bestehen, ein universelles Tool zu erstellen - eine Engine, die sich f√ºr v√∂llig unterschiedliche Aufgaben eignet und einfach zu modifizieren ist.  In diesem Artikel werden wir in C # die vom Standpunkt der Implementierung einfachste, aber gleichzeitig recht leistungsf√§hige Sprach-Engine entwickeln, mit der Sie ein ziemlich breites Spektrum von Problemen l√∂sen k√∂nnen. <a name="habracut"></a><br><br><h3>  Einleitung </h3><br><blockquote>  Es gibt zwei M√∂glichkeiten, ein Anwendungsprojekt zu entwickeln: es so einfach zu gestalten, dass es offensichtlich keine M√§ngel aufweist, oder es so komplex zu gestalten, dass es keine offensichtlichen M√§ngel aufweist.  C. E. R. Hoar (CAR Hoare) </blockquote>  In diesem Artikel m√∂chte ich eine der Entwicklungstechniken vorstellen, die mir und meinem Team helfen, mit der Komplexit√§t von Projekten umzugehen.  Zum anderen k√∂nnen Sie damit schnell Prototyp-Anwendungen entwickeln.  Die Entwicklung einer Programmiersprache erscheint auf den ersten Blick zu kompliziert.  So ist es, wenn wir √ºber ein universelles Werkzeug sprechen.  Wenn es darum geht, einen engen Themenbereich abzudecken, rechtfertigt sich die Entwicklung einer bestimmten Sprache h√§ufig. <br><br>  Einmal stand ich vor der Aufgabe, eine Implementierung einer industriellen Sprache (IEC 61131-3) zur Einbettung in Kundensoftware zu entwickeln.  Im Laufe dieser Arbeit habe ich mich f√ºr das Thema Dolmetscherstruktur interessiert und seitdem Dolmetscher f√ºr esoterische und wenig sprachliche Themen als Hobby geschrieben.  In Zukunft wurde ein Verst√§ndnis daf√ºr entwickelt, wie selbstgeschriebene Dolmetscher den Alltag vereinfachen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yh/j3/wl/yhj3wlkgasabptstq5toj3vasxc.jpeg"></div><br>  Das Hauptziel vern√ºnftiger Programmiersprachen besteht darin, den Programmier- und Leseprozess zu vereinfachen.  Das Schreiben in asm ist einfacher als in Maschinencodes, das Schreiben in C ist einfacher als in asm, in C # ist es noch einfacher und so weiter. <br><br>  Dies wird haupts√§chlich durch die popul√§rste Methode des Reduktionismus erreicht - Aufteilung einer komplexen Aufgabe in einfache und erkennbare Komponenten - Standardisierung ihrer Interaktion und einer bestimmten Syntax. <br><br>  Die Programmiersprache besteht aus einer Reihe von Operatoren, die im Wesentlichen die Grundlage f√ºr die Sprache, die grundlegenden Bausteine ‚Äã‚Äãund die Syntax bilden, die die Schreibweise f√ºr Kombinationen von Operatoren sowie die Standardbibliothek definieren.  Sequenzen elementarer Aktionen nach syntaktischen Regeln werden zu Funktionen gruppiert, Funktionen zu Klassen (sofern OOP vorhanden), Klassen zu Bibliotheken und diese wiederum zu Paketen zusammengefasst.  So sieht eine typische Mainstream-Sprache aus.  Im Prinzip reichen diese Techniken aus, um die meisten allt√§glichen Aufgaben zu l√∂sen.  Dies ist jedoch nicht die Grenze, da Sie einen Schritt weiter gehen k√∂nnen - zu einer h√∂heren Abstraktionsebene, und Sie m√ºssen die Grenzen der verwendeten Sprache √ºberschreiten, wenn sie keine Metaprogrammierung in Form von Makros unterst√ºtzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/r4/ky/skr4kym02scw_o_neotnxrtmamy.jpeg"></div><br>  Heutzutage beschr√§nken sich die meisten Projekte auf eine Kombination aus vorgefertigten Komponenten und einem unbedeutenden, selbstgeschriebenen Teil auf niedriger Ebene.  Die Kombination der Komponenten erfolgt normalerweise mit Hilfe einer universellen Programmiersprache - C #, Java, Python und anderen.  Obwohl diese Sprachen auf hoher Ebene sind, sind sie auch universell und enthalten daher notwendigerweise syntaktische Konstruktionen f√ºr Operationen auf niedriger Ebene, die Erstellung von Funktionen, Klassen, die Beschreibung verallgemeinerter Typen, die asynchrone Programmierung und vieles mehr.  Aus diesem Grund w√§chst die Aufgabe "Einmal ausf√ºhren, zweimal ausf√ºhren, dreimal ausf√ºhren" mit einer Vielzahl syntaktischer Konstruktionen und kann Hunderte von Codezeilen und mehr umfassen. <br><br>  Sie k√∂nnen die Wiederverwendung von Komponenten vereinfachen, wenn Sie die Technik des Reduktionismus wiederholen, jedoch bereits f√ºr genau diese Komponenten.  Dies wird durch die Entwicklung einer speziellen Sprache erreicht, die eine vereinfachte Syntax aufweist und ausschlie√ülich zur Beschreibung des Zusammenwirkens dieser Komponenten dient.  Dieser Ansatz wird als YaOP (sprachenorientierte Programmierung) bezeichnet, und Sprachen werden als DSL (dom√§nenspezifische Sprache - eine dom√§nenspezifische Sprache) bezeichnet. <br><br>  Aufgrund des Fehlens redundanter Konstruktionen k√∂nnen nur wenige Leitungen auf dem DSL eine recht komplexe Funktionalit√§t implementieren, was positive Konsequenzen hat: Die Entwicklungsgeschwindigkeit nimmt zu, die Anzahl der Fehler nimmt ab und die Systemtests werden vereinfacht. <br><br>  Bei erfolgreicher Anwendung kann dieser Ansatz die Flexibilit√§t des zu entwickelnden Produkts erheblich erh√∂hen, da kompakte Skripte geschrieben werden k√∂nnen, die das Verhalten des Systems definieren und erweitern.  Wie die Verbreitung dieses Ansatzes zeigt, kann es viele Anwendungen f√ºr diesen Ansatz geben, da DSL √ºberall verf√ºgbar ist.  Allgemeines HTML ist eine Dokumentbeschreibungssprache, SQL ist eine strukturierte Abfragesprache, JSON ist eine strukturierte Datenbeschreibungssprache, XAML, PostScript, Emacs Lisp, nnCron und viele andere. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/zo/ew/fwzoewmnmucf6kyeycclx_uibxa.jpeg"></div><br>  Bei allen Vorteilen hat DSL einen erheblichen Nachteil - hohe Anforderungen an den Systementwickler. <br><br>  Nicht jeder Entwickler hat das Wissen und die Erfahrung, auch eine primitive Sprache zu entwickeln.  Selbst eine kleinere Anzahl von Spezialisten kann eine ausreichend flexible und produktive Sprache entwickeln.  Es gibt noch andere Probleme.  Zu einem bestimmten Zeitpunkt in der Entwicklung der urspr√ºnglich festgelegten Funktionalit√§t reicht dies m√∂glicherweise nicht aus, und es ist erforderlich, Funktionen oder OOP zu erstellen.  Und wo es Funktionen gibt, kann eine Optimierung der Schwanzrekursion erforderlich sein, um auf Schleifen usw. zu verzichten.  Gleichzeitig muss die Abw√§rtskompatibilit√§t ber√ºcksichtigt werden, damit zuvor geschriebene Skripte weiterhin mit der neuen Version funktionieren. <br><br>  Ein weiteres Problem ist, dass eine Sprache, die zur L√∂sung eines Problems entwickelt wurde, f√ºr andere v√∂llig ungeeignet ist.  Daher muss ein neues DSL von Grund auf neu entwickelt werden, damit die Entwicklung neuer Sprachen zur Routine wird.  Dies verkompliziert wiederum die Wartung und reduziert die Wiederverwendung von Code, der f√ºr verschiedene DSL-Implementierungen und Projekte, die sie verwenden, schwierig zu teilen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/0z/cs/rz0zcsehkdtthonxqqhrci4yezu.jpeg"></div><br>  Der Ausweg besteht darin, ein DSL zu erstellen, um ein DSL aufzubauen.  Damit meine ich nicht RBNF, sondern eine Sprache, die mit eingebauten Mitteln auf die Sprache des Fachgebiets umgestellt werden kann.  Das Haupthindernis beim Erstellen einer flexiblen und umwandelbaren Sprache ist das Vorhandensein eines fest definierten Syntax- und Typensystems.  W√§hrend des gesamten Entwicklungszeitraums der Computerindustrie wurden mehrere flexible Sprachen ohne Syntax vorgeschlagen, die sich jedoch bis heute erhalten haben, und die Sprachen Forth und Lisp entwickeln sich weiterhin aktiv.  Das Hauptmerkmal dieser Sprachen ist, dass sie aufgrund ihrer Struktur und Homo-Ikonizit√§t das Verhalten des Interpreters aufgrund der eingebauten Mittel √§ndern und, falls erforderlich, syntaktische Konstruktionen analysieren k√∂nnen, die urspr√ºnglich nicht festgelegt wurden. <br><br>  Es gibt L√∂sungen f√ºr die Erweiterung der Syntax von Forth auf C oder Scheme.  "Fort" wird oft f√ºr die ungew√∂hnliche Postfix-Folge von Argumenten und Operationen kritisiert, die durch die Verwendung des Stacks zur √úbergabe von Argumenten vorgegeben wird.  ‚ÄûFort‚Äú hat jedoch Zugriff auf einen Textinterpreter. Auf diese Weise k√∂nnen Sie den umgekehrten Datensatz bei Bedarf vor dem Benutzer verbergen.  Und schlie√ülich ist dies Gewohnheitssache und entwickelt sich recht schnell. <br><br>  Die Lisp-Sprachfamilie basiert auf Makros, mit denen Sie bei Bedarf DSL eingeben k√∂nnen.  Der Zugriff auf den Interpreter und den Leser tr√§gt zur Implementierung metazyklischer Interpreter mit bestimmten Interpretationsmerkmalen bei.  Beispielsweise ist die Implementierung von Scheme lisp Racket als Entwicklungsumgebung f√ºr Sprachen positioniert und verf√ºgt √ºber Standardsprachen zum Erstellen von Webservern, Erstellen von GUI-Schnittstellen, Inferenzsprachen und anderen. <br><br>  Diese Flexibilit√§t macht diese Sprachen zu guten Kandidaten f√ºr die Rolle der universellen DSL-Engine. <br><br>  "Fort" und "Lisp" entwickeln sich haupts√§chlich als Mehrzwecksprachen, wenn auch als Nischensprachen. Sie st√ºtzen sich auf Funktionen, die f√ºr eine DSL-Sprache √ºberfl√ºssig sein k√∂nnen.  Gleichzeitig sind sie einfach zu implementieren, was bedeutet, dass Sie eine eingeschr√§nkte Version mit der M√∂glichkeit ihrer Erweiterung entwickeln k√∂nnen.  Auf diese Weise k√∂nnen Sie den Kern einer solchen Sprache mit kleinen √Ñnderungen (im Idealfall - ohne) f√ºr eine bestimmte Aufgabe wiederverwenden. <br><br>  Ich m√∂chte auch erw√§hnen, dass diese Sprachen nicht nur hervorragend zum Schreiben von Skripten geeignet sind, sondern auch f√ºr die interaktive Interaktion mit dem System √ºber REPL.  Dies kann zum einen zum Debuggen n√ºtzlich sein und zum anderen als benutzerzug√§ngliche Schnittstelle zum System dienen.  Es wird angenommen, dass die Textschnittstelle mit dem System in einigen F√§llen effektiver sein kann als die grafische, da sie viel einfacher zu implementieren und flexibler ist und dem Benutzer die Verallgemeinerung typischer Operationen in Funktionen usw. erm√∂glicht.  Ein auff√§lliges Beispiel f√ºr eine Textschnittstelle k√∂nnte Bash sein.  Und wenn die Sprache homo-ikonisch ist, kann ihre Konstruktion relativ einfach generiert und analysiert werden, und mit minimalem Aufwand kann eine Grafiksprache √ºber dem Interpreter implementiert werden - dies kann n√ºtzlich sein, wenn der Zielbenutzer weit vom Programmieren entfernt ist. <br><br>  Heutzutage werden XML- und JSON-Datenbeschreibungssprachen h√§ufig als DSL f√ºr die Konfiguration verwendet.  Dies ist nat√ºrlich eine gro√üartige Praxis, aber in einigen F√§llen reichen die Daten allein nicht aus, und Sie m√ºssen beispielsweise die Vorg√§nge an ihnen beschreiben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/_5/xm/hq_5xmmftlr1yj6xnsmn5-qzoo8.jpeg"></div><br>  In diesem Beitrag schlage ich vor, einen einfachen Interpreter f√ºr die Fort-Sprache zu erstellen und zu zeigen, wie diese angepasst werden kann, um bestimmte Probleme zu l√∂sen. <br><br>  Die Fort-Sprache wurde als am einfachsten zu implementierende und zu verwendende Sprache ausgew√§hlt, w√§hrend sie leistungsstark genug war, um sie als DSL f√ºr eine Reihe von Aufgaben zu verwenden.  Tats√§chlich ist das Herzst√ºck der Sprache der Adressinterpreter, der selbst im Assembler nur wenige Zeilen ben√∂tigt, und der Hauptteil der Implementierung liegt auf den Grundelementen, die umso universeller, schneller und flexibler sind, je universeller die Implementierung sein sollte.  Ein weiterer wichtiger Teil der Sprache ist der Textinterpreter, mit dem Sie mit dem Adressinterpreter interagieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/93/4s/uh934sq0-dwfzsmyjn2h5n0auvy.jpeg"></div><br><h3>  Adressdolmetscher </h3><br>  Das Grundelement der Fort-Sprache ist ein Wort, das durch Leerzeichen, Zeilenenden und Tabulatoren von anderen W√∂rtern und Atomen (Zahlen) getrennt ist. <br><br>  Ein Wort hat dieselbe Bedeutung und dieselben Eigenschaften wie eine Funktion aus anderen Sprachen, z. B. C. W√∂rter, die in der Implementierung verkabelt sind, dh mit denselben Mitteln wie der Interpreter implementiert sind, √§hneln Operatoren aus anderen Sprachen.  Tats√§chlich ist ein Programm in einer beliebigen Programmiersprache nichts anderes als eine Kombination aus Sprach- und Datenoperatoren.  Daher kann die Erstellung einer Programmiersprache als Definition von Operatoren und deren Kombination angesehen werden.  Dar√ºber hinaus bestimmen Sprachen wie C eine andere Schreibweise von Operatoren, die die Syntax der Sprache bestimmt.  In den meisten Sprachen ist das √Ñndern von Anweisungen normalerweise nicht m√∂glich. Beispielsweise k√∂nnen Sie die Syntax oder das Verhalten einer if-Anweisung nicht √§ndern. <br><br>  In der Sprache Fort haben alle Operatoren und ihre Kombinationen (Benutzerw√∂rter) die gleiche Schreibweise.  Fortw√∂rter sind in primitive und benutzerdefinierte W√∂rter unterteilt.  Sie k√∂nnen ein Wort definieren, das das Grundelement √ºberlastet und so das Verhalten der Grundelemente √§ndert.  Obwohl in Wirklichkeit das neu definierte Wort durch die anfangs definierten Grundelemente implementiert wird.  In unserer Implementierung ist die Funktion in C # das Grundelement.  Ein benutzerdefiniertes Wort besteht aus einer Liste von Adressen von W√∂rtern, die ausgef√ºhrt werden sollen.  Da es zwei Arten von W√∂rtern gibt, muss der Dolmetscher zwischen ihnen unterscheiden.  Die Trennung von Grundelementen und Benutzerw√∂rtern erfolgt √ºber dieselben Grundelemente. Jedes Benutzerwort beginnt mit einer DoList-Operation und endet mit einer Exit-Operation. <br><br>  Es ist m√∂glich, lange Zeit zu beschreiben, wie eine solche Trennung auftritt, dies ist jedoch leichter zu verstehen, wenn man die Ausf√ºhrungsreihenfolge des Interpreterprogramms studiert.  Dazu implementieren wir einen Minimalinterpreter, definieren ein einfaches Programm und sehen, wie es Schritt f√ºr Schritt ausgef√ºhrt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4l/uq/jw/4luqjwgysqj6iuchqkxdihjof8c.jpeg"></div><br>  Unsere Fort-Maschine besteht aus linearem Speicher, Datenstapel, R√ºcksprungstapel, Befehlszeiger, Wortzeiger.  Wir werden auch einen separaten Ort zur Aufbewahrung von Primitiven haben. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] Mem; <span class="hljs-comment"><span class="hljs-comment">//   public Stack&lt;int&gt; RS; //   public Stack&lt;object&gt; DS; //   public int IP; //   public int WP; //   public delegate void CoreCall(); public List&lt;CoreCall&gt; Core; //  </span></span></code> </pre> <br>  Das Wesentliche der Interpretation besteht darin, zur Adresse im Speicher zu navigieren und den dort angezeigten Befehl auszuf√ºhren.  Der gesamte Adressinterpreter - in unserem Fall das Herz der Sprache - wird in einer Funktion Next () definiert. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IP == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; WP = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Mem[IP++]; Core[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Mem[WP]](); } }</code> </pre><br>  Jedes Benutzerwort beginnt mit einem DoList-Befehl, dessen Aufgabe es ist, die aktuelle Interpretationsadresse auf dem Stapel zu speichern und die Interpretationsadresse des n√§chsten Wortes festzulegen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RS.Push(IP); IP = WP + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Verwenden Sie zum Verlassen des Wortes den Befehl Exit, mit dem die Adresse aus dem R√ºckgabestapel wiederhergestellt wird. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { IP = RS.Pop(); }</code> </pre><br>  Zur visuellen Demonstration des Interpreterprinzips f√ºhren wir einen Befehl ein, der n√ºtzliche Arbeit simuliert.  Nennen wir es Hallo (). <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hello</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); }</code> </pre><br>  Zun√§chst m√ºssen Sie den Computer initialisieren und die Grundelemente angeben, damit der Interpreter ordnungsgem√§√ü funktioniert.  Sie m√ºssen auch die Adressen der Grundelemente im Programmspeicher angeben. <br><br><pre> <code class="cs hljs">Mem = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; RS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); DS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); Core = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CoreCall&gt;(); Core.Add(Next); Core.Add(DoList); Core.Add(Exit); Core.Add(Hello); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opNext = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opDoList = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opExit = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opHello = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// core pointers Mem[opNext] = opNext; Mem[opDoList] = opDoList; Mem[opExit] = opExit; Mem[opHello] = opHello;</span></span></code> </pre><br>  Jetzt k√∂nnen wir ein einfaches Programm erstellen. In unserem Fall beginnt der Benutzercode bei Adresse 4 und besteht aus zwei Unterprogrammen.  Die erste Routine beginnt bei Adresse 7 und ruft die zweite Routine auf, die bei Adresse 4 beginnt und das Wort Hallo anzeigt. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// program Mem[4] = opDoList; // 3)    IP = 9   ,   IP = WP + 1 = 5 Mem[5] = opHello; // 4)     Mem[6] = opExit; // 5)   ,  IP = 9    Mem[7] = opDoList; // 1)     Mem[8] = 4; // 2)     4,  WP = 4 Mem[9] = opExit; // 6)   ,  IP = 0   </span></span></code> </pre><br>  Um das Programm auszuf√ºhren, m√ºssen Sie zuerst den Wert 0 im R√ºckgabestapel speichern, wodurch der Adressinterpreter den Interpretationszyklus unterbricht, den Einstiegspunkt festlegt und dann den Interpreter startet. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entryPoint = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    IP = 0; //  IP = 0,        WP = entryPoint; //  WP = 7      DoList(); //     ,  IP = 0    Next(); //   </span></span></code> </pre><br>  Wie beschrieben, werden in diesem Interpreter Grundelemente in einem separaten Speicher gespeichert.  Nat√ºrlich k√∂nnte es auch anders implementiert sein: Beispielsweise wurde im Programmspeicher ein Vertreter der Bedienerfunktion abgelegt.  Einerseits w√§re ein derartiger Dolmetscher nicht einfacher geworden, andererseits w√§re er deutlich langsamer gewesen, da jeder Schritt der Interpretation eine Typpr√ºfung, ein Casting und eine Ausf√ºhrung erfordern w√ºrde, wodurch mehr Operationen erhalten w√ºrden. <br><br>  Jedes Benutzerwort unseres Interpreters beginnt mit dem DoList-Grundelement, dessen Aufgabe es ist, die aktuelle Adresse der Interpretation zu speichern und zur n√§chsten Adresse zu wechseln.  Das Verlassen der Unterroutine wird durch die Exit-Operation ausgef√ºhrt, die die Adresse aus dem R√ºckgabestapel zur weiteren Interpretation wiederherstellt.  Tats√§chlich haben wir den gesamten Adressinterpreter beschrieben.  Um beliebige Programme auszuf√ºhren, reicht es aus, sie mit Primitiven zu erweitern.  Zun√§chst m√ºssen Sie sich jedoch mit einem Textinterpreter befassen, der eine Schnittstelle zum Adressinterpreter bietet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/fw/gt/qpfwgtzzyissc6ujdvq_eq3wdby.jpeg"></div><br><h3>  Textinterpreter </h3><br>  Die Fort-Sprache hat keine Syntax: In ihr geschriebene Programme sind W√∂rter, die durch Leerzeichen, Tabulatoren oder Zeilenenden getrennt sind.  Daher besteht die Aufgabe des Textinterpreters darin, den Eingabestream in W√∂rter (Token) zu unterteilen, einen Einstiegspunkt f√ºr sie zu finden, auszuf√ºhren oder in den Speicher zu schreiben.  Aber nicht alle Token unterliegen der Ausf√ºhrung.  Wenn der Interpreter das Wort nicht findet, versucht er es als numerische Konstante zu interpretieren.  Dar√ºber hinaus verf√ºgt der Textinterpreter √ºber zwei Modi: Interpretationsmodus und Programmiermodus.  Im Programmiermodus werden die Wortadressen nicht ausgef√ºhrt, sondern in den Speicher geschrieben, wodurch neue W√∂rter ermittelt werden. <br><br>  Kanonische Implementierungen des "Fort" kombinieren normalerweise ein W√∂rterbuch (W√∂rterbucheintrag) und einen Programmspeicher und definieren eine einzelne Codedatei in Form einer einfach verbundenen Liste.  In unserer Implementierung befindet sich nur ausf√ºhrbarer Code im Speicher, und die Einstiegspunkte von W√∂rtern werden in einer separaten Struktur gespeichert - einem W√∂rterbuch. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, List&lt;WordHeader&gt;&gt; Entries;</code> </pre> <br>  In diesem W√∂rterbuch wird die Entsprechung eines Wortes auf mehrere √úberschriften festgelegt. Sie k√∂nnen also eine beliebige Anzahl von Routinen mit demselben Namen definieren, diese Definition l√∂schen und die alte Definition verwenden.  Die gespeicherte alte Adresse erm√∂glicht es Ihnen auch, den Namen eines Wortes im W√∂rterbuch zu finden, selbst wenn es neu definiert wurde. Dies ist besonders n√ºtzlich, um einen Stack-Trace zu generieren oder um Fehler im Arbeitsspeicher zu beheben.  WordHeader ist eine Klasse, die eine Subroutineneintragsadresse und ein sofortiges Interpretationsflag speichert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WordHeader</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Address; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Immediate; }</code> </pre><br>  Das Direkt-Flag weist den Interpreter an, dass dieses Wort im Programmiermodus ausgef√ºhrt und nicht in den Speicher geschrieben werden soll.  Schematisch kann die Logik des Interpreters wie folgt dargestellt werden: Die rechte Hand ist JA, die linke ist NEIN. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vh/5t/pz/vh5tpzf-atkgovuyyqrqoeitfmo.jpeg"></div><br>  Wir werden TextReader verwenden, um den Eingabestream zu lesen, und TextWriter, um ihn auszugeben. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TextReader Input; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TextWriter Output;</code> </pre><br>  Die Implementierung des Interpreters gem√§√ü dem obigen Schema erfolgt in einem Interpreter () mit einer Funktion. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Interpreter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> word = ReadWord(Input); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(word)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// EOF var lookup = LookUp(word); if (IsEvalMode) { if (lookup != null) { Execute(lookup.Address); } else if (IsConstant(word)) { DS.Push(ParseNumber(word)); } else { DS.Clear(); Output.WriteLine($"The word {word} is undefined"); } } else { // program mode if (lookup != null) { if (lookup.Immediate) { Execute(lookup.Address); } else { AddOp(lookup.Address); } } else if (IsConstant(word)) { AddOp(LookUp("doLit").Address); AddOp(ParseNumber(word)); } else { IsEvalMode = true; DS.Clear(); Output.WriteLine($"The word {word} is undefined"); } } } }</span></span></code> </pre><br>  Die Interpretation erfolgt in einer Schleife, deren Ausgabe beim Erreichen des Endes des Eingabestreams (z. B. des Endes der Datei) ausgef√ºhrt wird, w√§hrend die ReadWord-Funktion eine leere Zeichenfolge zur√ºckgibt.  Die Aufgabe von ReadWord ist es, bei jedem Aufruf das n√§chste Wort zur√ºckzugeben. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadWord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextReader sr</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code = sr.Read(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (IsWhite((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)code) &amp;&amp; code &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { code = sr.Read(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!IsWhite((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)code) &amp;&amp; code &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { sb.Append((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)code); code = sr.Read(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsWhite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" \n\r\t"</span></span>.Any(ch =&gt; ch == c); }</code> </pre><br>  Nachdem das Wort gelesen wurde, wird versucht, es im W√∂rterbuch zu finden.  Bei Erfolg wird der Titel des Wortes zur√ºckgegeben, andernfalls null. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WordHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> word</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Entries.ContainsKey(word)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Entries[word].Last(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br>  Sie k√∂nnen anhand der ersten beiden Zeichen √ºberpr√ºfen, ob der eingegebene Wert eine Zahl ist.  Wenn das erste Zeichen eine Zahl ist, nehmen wir an, dass es eine Zahl ist.  Wenn das erste Zeichen ein "+" oder "-" ist und das zweite eine Ziffer, ist dies h√∂chstwahrscheinlich auch eine Zahl. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsConstant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> word</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsDigit(word[<span class="hljs-number"><span class="hljs-number">0</span></span>]) || (word.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; (word[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'+'</span></span> || word[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>) &amp;&amp; IsDigit(word[<span class="hljs-number"><span class="hljs-number">1</span></span>])); }</code> </pre><br>  Um eine Zeichenfolge in eine Zahl umzuwandeln, k√∂nnen Sie die Standardmethoden Int32.TryParse und Double.TryParse verwenden.  Da sich die Geschwindigkeit aus verschiedenen Gr√ºnden nicht unterscheidet, verwende ich eine benutzerdefinierte L√∂sung. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> factor = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>) { sign = <span class="hljs-number"><span class="hljs-number">-1</span></span>; str = str.Remove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) { str = str.Remove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = str.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str[i] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) { str = str.Remove(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntParseFast(str) * factor * sign; } factor *= <span class="hljs-number"><span class="hljs-number">0.1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntParseFast(str) * sign; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntParseFast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// An optimized int parse method. var result = 0; foreach (var c in value) { if (!(c &gt;= '0' &amp;&amp; c &lt;= '9')) return result; // error result = 10 * result + (c - 48); } return result; }</span></span></code> </pre><br>  Die ParseNumber-Methode kann sowohl Ganzzahlwerte als auch Gleitkommazahlen konvertieren, z. B. "1.618". <br><br>  Die Ausf√ºhrung des Wortes erfolgt auf die gleiche Weise wie bei der Ausf√ºhrung des Adressinterpreters.  Im Ausnahmefall wird ein Stack-Trace des Adressinterpreters gedruckt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address &lt; Core.Count) { <span class="hljs-comment"><span class="hljs-comment">// eval core Core[address](); // invoke core function } else { // eval word IP = 0; // set return address WP = address; // set eval address DoList(); // fake doList Next(); // run evaluator } } catch (Exception e) { Output.WriteLine(e.Message); var wpEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == WP)); var ipEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == SearchKnowAddress(IP))); Output.WriteLine($"WP = {WP:00000} - '{wpEntry.Key}', IP = {IP:00000} - '{ipEntry.Key}'"); if (RS.Any()) { Output.WriteLine("Stack trace..."); foreach (var a in RS) { var ka = SearchKnowAddress(a); var sEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == ka)); Output.WriteLine($"...{a:00000} -- {sEntry.Key}"); } RS.Clear(); DS.Clear(); } else if (address &lt; Core.Count) { var entry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == address)); Output.WriteLine($"Core word is {entry.Key}"); } IP = WP = 0; } }</span></span></code> </pre><br>  Wenn sich der Interpreter im Kompilierungsmodus befindet und das Wort nicht f√ºr die sofortige Ausf√ºhrung markiert ist, muss seine Adresse in den Speicher geschrieben werden. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddOp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)</span></span> { Mem[Here++] = op; }</code> </pre><br>  Die here-Variable speichert die Adresse der n√§chsten freien Zelle.  Da diese Variable als Variable der Fort-Sprache aus der Laufzeitumgebung heraus zug√§nglich sein muss, wird der Wert hier mit einem bestimmten Offset im Programmspeicher abgelegt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _hereShift; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Here { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Mem[_hereShift]; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; Mem[_hereShift] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre><br>  Um bei der Interpretation zwischen einer numerischen Konstante und einer Wortadresse zu unterscheiden, wird bei der Kompilierung vor jeder Konstante eine Kompilierung des doLit-Wortes erstellt, die den n√§chsten Wert im Speicher liest und auf den Datenstapel legt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoLit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DS.Push(Mem[IP++]); }</code> </pre><br>  Wir haben Adress- und Textinterpreter beschrieben, die Weiterentwicklung besteht darin, den Kern mit Atomen zu f√ºllen.  Verschiedene Versionen von "Fort" haben unterschiedliche Grundbegriffe. Die minimalistischste Implementierung ist vielleicht eForth, das nur 31 Grundelemente enth√§lt.  Da das Grundelement schneller ausgef√ºhrt wird als zusammengesetzte Benutzerw√∂rter, sind minimale Fort-Implementierungen normalerweise langsamer als ausf√ºhrliche Implementierungen.  Einen Vergleich der Wortmenge mehrerer Versionen von Interpreten finden Sie <a href="http://forthworks.com/forth/papers/compare.pdf">hier</a> . <br><br>  In dem hier beschriebenen Interpreter habe ich auch versucht, das W√∂rterbuch der Grundw√∂rter nicht unn√∂tig aufzublasen.  Um die Integration mit der .net-Plattform zu vereinfachen, habe ich mich entschlossen, Mathematik, Boolesche Operationen und nat√ºrlich Reflexion durch eine Reihe von Grundelementen zu implementieren.  Gleichzeitig fehlen hier einige der W√∂rter, die in Fort-Implementierungen h√§ufig primitiv sind, was eine Implementierung mit Hilfe des Interpreters impliziert. <br><br><div class="spoiler">  <b class="spoiler_title">Zum Zeitpunkt des Schreibens umfasst der Basissatz 68 W√∂rter.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Core SetCoreWord("nop", Nop); SetCoreWord("next", Next); SetCoreWord("doList", DoList); SetCoreWord("exit", Exit); SetCoreWord("execute", Execute); SetCoreWord("doLit", DoLit); SetCoreWord(":", BeginDefWord); SetCoreWord(";", EndDefWord, true); SetCoreWord("branch", Branch); SetCoreWord("0branch", ZBranch); SetCoreWord("here", GetHereAddr); SetCoreWord("quit", Quit); SetCoreWord("dump", Dump); SetCoreWord("words", Words); SetCoreWord("'", Tick); SetCoreWord(",", Comma); SetCoreWord("[", Lbrac, true); SetCoreWord("]", Rbrac); SetCoreWord("immediate", Immediate, true); // Mem SetCoreWord("!", WriteMem); SetCoreWord("@", ReadMem); SetCoreWord("variable", Variable); SetCoreWord("constant", Constant); // RW SetCoreWord(".", Dot); SetCoreWord(".s", DotS); SetCoreWord("cr", Cr); SetCoreWord("bl", Bl); SetCoreWord("word", ReadWord, true); SetCoreWord("s\"", ReadString, true); SetCoreWord("key", Key); // Comment SetCoreWord("(", Comment, true); SetCoreWord("\\", CommentLine, true); // .net mem SetCoreWord("null", Null); SetCoreWord("new", New); SetCoreWord("type", GetType); SetCoreWord("m!", SetMember); SetCoreWord("m@", GetMember); SetCoreWord("ms@", GetStaticMember); SetCoreWord("ms!", SetStaticMember); SetCoreWord("load-assembly", LoadAssembly); SetCoreWord("invk", invk); // Boolean SetCoreWord("true", True); SetCoreWord("false", False); SetCoreWord("and", And); SetCoreWord("or", Or); SetCoreWord("xor", Xor); SetCoreWord("not", Not); SetCoreWord("invert", Invert); SetCoreWord("=", Eql); SetCoreWord("&lt;&gt;", NotEql); SetCoreWord("&lt;", Less); SetCoreWord("&gt;", Greater); SetCoreWord("&lt;=", LessEql); SetCoreWord("&gt;=", GreaterEql); // Math SetCoreWord("-", Minus); SetCoreWord("+", Plus); SetCoreWord("*", Multiply); SetCoreWord("/", Devide); SetCoreWord("mod", Mod); SetCoreWord("1+", Inc); SetCoreWord("1-", Dec); // Stack SetCoreWord("drop", Drop); SetCoreWord("swap", Swap); SetCoreWord("dup", Dup); SetCoreWord("over", Over); SetCoreWord("rot", Rot); SetCoreWord("nrot", Nrot);</span></span></code> </pre><br></div></div><br>  Um neue Benutzerw√∂rter zu definieren, werden zwei Kernelw√∂rter verwendet: ":" und ";".  Das Wort ":" liest den Namen eines neuen Wortes aus dem Eingabestream, erstellt mit diesem Schl√ºssel einen Header, die Adresse des Basisworts doList wird zum Programmspeicher hinzugef√ºgt und der Interpreter wird in den Kompilierungsmodus versetzt.  Alle nachfolgenden W√∂rter werden mit Ausnahme der als unmittelbar gekennzeichneten W√∂rter zusammengestellt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginDefWord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AddHeader(ReadWord(Input)); AddOp(LookUp(<span class="hljs-string"><span class="hljs-string">"doList"</span></span>).Address); IsEvalMode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Die √úbersetzung endet mit dem Wort ‚Äû;‚Äú, das die Adresse des Wortes ‚Äûexit‚Äú in den Programmspeicher schreibt und in den Interpretationsmodus versetzt.  Jetzt k√∂nnen Sie benutzerdefinierte W√∂rter definieren, z. B. Schleifen, bedingte Anweisungen und andere. <br><br><pre> <code class="cs hljs">Eval(<span class="hljs-string"><span class="hljs-string">": ? @ . ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": allot here @ + here ! ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": if immediate doLit [ ' 0branch , ] , here @ 0 , ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": then immediate dup here @ swap - swap ! ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": else immediate [ ' branch , ] , here @ 0 , swap dup here @ swap - swap ! ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": begin immediate here @ ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": until immediate doLit [ ' 0branch , ] , here @ - , ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": again immediate doLit [ ' branch , ] , here @ - , ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": while immediate doLit [ ' 0branch , ] , here @ 0 , ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": repeat immediate doLit [ ' branch , ] , swap here @ - , dup here @ swap - swap ! ;"</span></span>); Eval(<span class="hljs-string"><span class="hljs-string">": // immediate [ ' \\ , ] ;"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C like comment</span></span></code> </pre><br>  Ich werde den Rest der Standardw√∂rter hier nicht beschreiben - es gibt gen√ºgend Informationen dazu im Netzwerk √ºber die entsprechenden thematischen Ressourcen.  Um mit der Plattform zu interagieren, habe ich 9 W√∂rter definiert: <br><br><ul><li>  "Null" - dr√ºckt Null auf den Stapel; </li><li>  ‚ÄúType‚Äù - verschiebt den Klassentyp auf den Stapel von ‚Äúword TrueForth.MyClass type‚Äù; </li><li>  ‚ÄûNeu‚Äú - Nimmt den Typ vom Stapel, erstellt eine Instanz der Klasse und platziert ihn auf dem Stapel. Eventuelle Konstruktorargumente sollten sich auch auf dem Stapel ‚ÄûWort TrueForth.MyClass Typ neu‚Äú befinden. </li><li>  "M!" - Nimmt eine Instanz eines Objekts, Feldnamens und Werts aus dem Stapel und weist dem angegebenen Feld einen Wert zu. </li><li>  "M @" - holt eine Instanz eines Objekts aus dem Stapel, den Feldnamen, und gibt den Wert des Felds an den Stapel zur√ºck; </li><li>  "Ms!" Und "ms @" - √§hnlich wie die vorherigen, aber f√ºr statische Felder muss anstelle einer Instanz ein Typ auf dem Stapel vorhanden sein. </li><li>  "Load-Assembly" - Nimmt vom Stapel, l√§sst ihn zur Assembly und l√§dt in den Speicher; </li><li>  "Invk" - Nimmt den Delegaten und die Argumente aus dem Stapel und nennt ihn "1133 word SomeMethod word TrueForth.MyClass type new m @ invk". </li></ul><br>  Ich habe die Hauptpunkte der Implementierung der Fort-Sprache beschrieben. Diese Implementierung versucht nicht, ANSI-Standards f√ºr die Sprache zu unterst√ºtzen, da ihre Aufgabe darin besteht, eine Engine zum Erstellen von DSL und keine Allzwecksprache zu implementieren.  In den meisten F√§llen reicht der entwickelte Interpreter aus, um eine einfache Sprache f√ºr das Fachgebiet zu erstellen. <br><br>  Es gibt verschiedene M√∂glichkeiten, den obigen Interpreter zu verwenden.  Beispielsweise k√∂nnen Sie eine Instanz des Interpreters erstellen und dann ein Initialisierungsskript an die Eingabe senden, in dem die erforderlichen W√∂rter ermittelt werden.  Letztere interagieren durch Reflektion mit dem System. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init4Th</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Interpreter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OForth(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(InitFile)) { Interpreter.Eval(File.ReadAllText(InitFile)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{InitFile}</span></span></span><span class="hljs-string">  !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre><br>  Beispiel f√ºr die Konfiguration des Berichtsverteilungssystems <br><br><pre> <code class="plaintext hljs">( *****   ***** ) word GetFReporter word ReportProvider.FlexReports.FReporterEntry type new m@ invk constant fr //       :  word ReportProvider.FlexReports.FDailyReport type new ; //       :  word AddReport fr m@ invk ; //          :  [ ' word , ] ; //   :  [ ' word , ] ; //   :  [ ' s" , ] ; //  ,      " :  ; //  :  dup [ ' word , ] swap word MailSql swap m! ; :  dup [ ' word , ] swap word XlsSql swap m! ; ( *****    ***** ) cr s"   " . cr cr    "  08:00  mail@tinkoff.ru   seizure.sql    ,    "  08:00  mail@tinkoff.ru   fixed-errors-top.sql   fixed-errors.sql         WO"  08:00  mail@tinkoff.ru   wo-wait-complect-dates.sql       "  07:30  mail@tinkoff.ru   top-previous-input-errors.sql   previous-input-errors.sql        "  10:00  mail@tinkoff.ru   collection-report.sql       BPM   "  08:00  mail@tinkoff.ru   bpm-inbox-report.sql       ScanDoc3   7 "  07:50  mail@tinkoff.ru   new-sd3-complects-prevew.sql   new-sd3-complects.sql  ( ******************************** ) cr s"  " . cr</code> </pre><br>  Sie k√∂nnen auch Folgendes tun: √úbergeben Sie vorgefertigte Objekte √ºber den Datenstapel an den Eingang des Interpreters und interagieren Sie dann √ºber den Interpreter mit ihnen.  Ich habe zum Beispiel die Ger√§teeinstellungen f√ºr den Empfang von Scans von Dokumenten, einen Scanner, eine Webcam oder ein virtuelles Ger√§t wiederhergestellt (zum Debuggen oder Trainieren).  In diesem Fall ist der Parametersatz, die Einstellungen, die Initialisierungsreihenfolge der verschiedenen Ger√§te sehr unterschiedlich und wird durch den Fort-Interpreter trivial gel√∂st. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpreter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OForth(); interpreter.DS.Push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Push current instance on DataStack interpreter.Eval("constant arctium"); // Define constant with the instance if (File.Exists(ConfigName)) { interpreter.Eval(File.ReadAllText(ConfigName)); }</span></span></code> </pre><br>  Die Konfiguration wird programmgesteuert generiert und sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="plaintext hljs">s" @device:pnp:\\?\usb#vid_2b16&amp;pid_6689&amp;mi_00#6&amp;1ef84f63&amp;0&amp;0000#{65e8773d-8f56-11d0-a3b9-00a0c9223196}\global" s" Doccamera" word Scanning.Devices.PhotoScanner.PhotoScannerDevice type new dup s" 3264x2448, FPS:20, BIT:24" swap word SetSnapshotMode swap m@ invk dup s" 1280x720, FPS:30, BIT:24" swap word SetPreviewMode swap m@ invk word SetActiveDevice arctium m@ invk</code> </pre><br>  √úbrigens werden die Skripte * .ps und * .pdf auf √§hnliche Weise generiert, da sowohl PostScript als auch Pdf im Wesentlichen eine Teilmenge des Fort sind, aber ausschlie√ülich zum Rendern von Dokumenten auf einem Bildschirm oder einem Drucker verwendet werden. <br><br>  Es ist genauso einfach, den interaktiven Modus f√ºr Konsolen und nicht nur f√ºr Anwendungen zu implementieren.  Dazu m√ºssen Sie zuerst das System √ºber das vorbereitete Skript initialisieren und dann die Interpretation starten, indem Sie den Interpreter auf die Standardeingabe STDIN setzen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpreter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OForth(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> InitFile = <span class="hljs-string"><span class="hljs-string">"Init.4th"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(InitFile)) { interpreter.Eval(File.ReadAllText(InitFile)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{InitFile}</span></span></span><span class="hljs-string">  !"</span></span>); } interpreter.Eval(Console.In); <span class="hljs-comment"><span class="hljs-comment">// Start interactive console</span></span></code> </pre><br>  Das Initialisierungsskript kann folgenderma√üen aussehen: <br><br><pre> <code class="plaintext hljs">( *****   ***** ) word ComplectBuilder.Program type constant main //     : mode! [ ' word , ] word Mode main ms! ; //    : init word Init main ms@ invk ; //  : load [ ' word , ] word LoadFile main ms@ invk ; //   : start word StartProcess main ms@ invk ; //   : count word Count main ms@ invk ; //   : all count ; //  ( *****  ***** ) init cr cr s"    ,     help" . cr cr ( *****  ***** ) : help s"         :" . cr s" load scandoc_test.csv 0 all start" . cr bl bl s" load scandoc_test.csv --    " . cr bl bl s" 0 all start --  ,  0      all " . cr cr s"     DEV TEST PROD:" . cr s" mode! DEV init" . cr s"     :" . cr s" word Mode main ms@ . cr" . cr ;</code> </pre><br>  Als Eingabe kann es nicht nur eine Konsole oder einen Text aus einer TextBox-Anwendung mit einer Benutzeroberfl√§che geben, sondern auch ein Netzwerk.  In diesem Fall k√∂nnen Sie eine einfache interaktive Steuerung, z. B. einen Dienst, zum Debuggen, Starten und Stoppen von Komponenten implementieren.  Die Einsatzm√∂glichkeiten sind durch die Vorstellungskraft des Entwicklers und die zu l√∂sende Aufgabe begrenzt.    ,     UI    -     . <br><br>         .      ,         ,       . <br><br>   ,   : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> word, MulticastDelegate action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(word) || word.Any(c =&gt; <span class="hljs-string"><span class="hljs-string">" \n\r\t"</span></span>.Any(cw =&gt; cw == c))) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"invalid format of word"</span></span>); } DS.Push(action); Eval(<span class="hljs-string"><span class="hljs-string">$": </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{word}</span></span></span><span class="hljs-string"> [ ' doLit , , ] invk ;"</span></span>); }</code> </pre><br>        DS.Push(action),       . ,  ,     [ ],  ,   .  ' Tick         ,      doLit,    ,           .  Comma ¬´,¬ª  doLit,     . <br><br>     ,      .     ,      : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WoConfItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ComplectType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Route; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Deal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsStampQuery; }</code> </pre><br>     ‚Äî   ,   : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WoConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OForth VM; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WoConfItem&gt; _conf; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WoConfig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> confFile</span></span></span><span class="hljs-function">)</span></span> { _conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;WoConfItem&gt;(); VM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OForth(); <span class="hljs-comment"><span class="hljs-comment">//      VM.Callback("new-conf", new Action(ClearConf)); VM.Callback("{", new Func&lt;WoConfItem&gt;(NewConf)); VM.Callback("}", new Action&lt;WoConfItem&gt;(AddConf)); VM.Callback("complect-type", new Func&lt;WoConfItem,string,WoConfItem&gt;(ConfComplectType)); VM.Callback("route", new Func&lt;WoConfItem,string,WoConfItem&gt;(ConfRoute)); VM.Callback("deal", new Func&lt;WoConfItem,string,WoConfItem&gt;(ConfDeal)); VM.Callback("is-stamp-query", new Func&lt;WoConfItem,bool,WoConfItem&gt;(ConfIsStampQuery)); //  ,   ,       var initScript = new StringBuilder(); initScript.AppendLine(": complect-type [ ' word , ] swap complect-type ;"); initScript.AppendLine(": route [ ' word , ] swap route ;"); initScript.AppendLine(": deal [ ' word , ] swap deal ;"); initScript.AppendLine(": is-stamp-query ' execute swap is-stamp-query ;"); VM.Eval(initScript.ToString()); //   WatchConfig(confFile); } private void ReadConfig(string path) { using (var reader = new StreamReader(File.OpenRead(path), Encoding.Default)) { VM.Eval(reader); } } readonly Func&lt;string, bool&gt; _any = s =&gt; s == "*"; public WoConfItem GetConf(string complectType, string routeId) { return _conf?.FirstOrDefault(cr =&gt; (cr.ComplectType == complectType || _any(cr.ComplectType)) &amp;&amp; (cr.Route == routeId || _any(cr.Route)) ); } public bool IsAllow(string complectType, string routeId) { return GetConf(complectType, routeId) != null; } void WatchConfig(string path) { var directory = Path.GetDirectoryName(path); var fileName = Path.GetFileName(path); //   ,     if (!File.Exists(path)) { if (!Directory.Exists(directory)) { Directory.CreateDirectory(directory); } var sb = new StringBuilder(); sb.AppendLine("\\ WO passport configuration"); sb.AppendLine("new-conf"); sb.AppendLine(""); sb.AppendLine("\\ Config rules"); sb.AppendLine("\\ { -- begin config item, } -- end config item, * -- match any values"); sb.AppendLine("\\ Example:"); sb.AppendLine("\\ { complect-type * route offer deal 100500 is-stamp-query true }"); sb.AppendLine(""); File.WriteAllText(path, sb.ToString(), Encoding.Default); } //   ReadConfig(path); //     var fsWatcher = new FileSystemWatcher(directory, fileName); fsWatcher.Changed += (sender, args) =&gt; { try { fsWatcher.EnableRaisingEvents = false; //        , //     ,   //     Thread.Sleep(1000); ReadConfig(path); } catch (Exception e) { Console.WriteLine(e); } finally { fsWatcher.EnableRaisingEvents = true; } }; fsWatcher.EnableRaisingEvents = true; } //  ,    void ClearConf() { _conf.Clear(); } void AddConf(WoConfItem conf) { _conf.Add(conf); } static WoConfItem NewConf() { return new WoConfItem(); } static WoConfItem ConfComplectType(WoConfItem conf, string complectType) { conf.ComplectType = complectType; return conf; } static WoConfItem ConfRoute(WoConfItem conf, string route) { conf.Route = route; return conf; } static WoConfItem ConfDeal(WoConfItem conf, string deal) { conf.Deal = deal; return conf; } static WoConfItem ConfIsStampQuery(WoConfItem conf, bool isStampQuery) { conf.IsStampQuery = isStampQuery; return conf; } }</span></span></code> </pre><br></div></div><br>  : <br><br><pre> <code class="plaintext hljs">\ WO passport configuration new-conf \ Config rules \ { -- begin config item, } -- end config item, * -- match any values \ Example: \ { complect-type * route offer deal 100500 is-stamp-query true } \ ***** offer ***** { complect-type offer route offer is-stamp-query false deal 5c18e87bfeed2b0b883fd4df } { complect-type KVK route offer is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type offer-cred route offer is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type offer-dep route offer is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type quick-meeting route offer is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type exica route offer is-stamp-query true deal 5d03a894e2f5850001435492 } { complect-type reissue route offer is-stamp-query true deal 5d03a894e2f5850001435492 } \ ***** offer-flow ***** { complect-type KVK route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type offer-cred route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type offer-dep route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 } { complect-type reissue route offer-flow is-stamp-query true deal 5d03a894e2f5850001435492 }</code> </pre><br> ,     ,       DSL   ‚Äî    . <br><br> ,          ¬´¬ª.          DSL. <br><br> ,     ,   ‚Äî ,   , ,    ,    ‚Äî      .        ,           . <br><br>   ‚Äî         ,             .  ‚Äî  ,       ‚Äî  ! <br><br>       <a href="">,  </a> . <br><br>   <a href="http://rigidus.ru/lrn/forth/jonesforth-1.html">    -</a> . <br><br>  Viel gl√ºck </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477902/">https://habr.com/ru/post/de477902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477886/index.html">Schulcurriculum zur Schaffung von virtueller und erweiterter Realit√§t</a></li>
<li><a href="../de477892/index.html">DevOps: 2019 Ergebnisse und n√§chste Vorhersage von der DevOps Community</a></li>
<li><a href="../de477894/index.html">work & dev fun (damentals) # 0. Was Sie erwartet und wie Sie einen angehenden Entwickler zu einem selbstbewussten Nachwuchs entwickeln k√∂nnen?</a></li>
<li><a href="../de477898/index.html">Einf√ºhrung in die kontextorientierte Kotlin-Programmierung</a></li>
<li><a href="../de477900/index.html">Primzahlen - wie gro√ü ist unsere Ohnmacht?</a></li>
<li><a href="../de477904/index.html">Programmgesteuertes Suchen nach gemeinsamem Code mit oEmbed</a></li>
<li><a href="../de477906/index.html">Slurm: 50% Rabatt auf Black Friday Online-Kurse</a></li>
<li><a href="../de477908/index.html">Puppetry 3: automatisiertes Testen ohne eine einzige Codezeile</a></li>
<li><a href="../de477910/index.html">Black Friday 2019 - VDS in Moskau und Amsterdam, Server mit GPU</a></li>
<li><a href="../de477912/index.html">Erste Eindr√ºcke vom 10,3-Zoll-PocketBook X-Reader mit E-Ink-Carta-Mobius-Bildschirm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>