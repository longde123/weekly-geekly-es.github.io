<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∫Ô∏è üôèüèº ü§∑üèΩ So funktioniert Microsoft Excel mit Zeilenh√∂hen üö£üèº üï¥üèø üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal langweile ich mich und beginne mit einem Debugger, mich mit verschiedenen Programmen zu besch√§ftigen. Dieses Mal fiel meine Wahl auf Excel un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Microsoft Excel mit Zeilenh√∂hen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435426/"><p> Manchmal langweile ich mich und beginne mit einem Debugger, mich mit verschiedenen Programmen zu besch√§ftigen.  Dieses Mal fiel meine Wahl auf Excel und ich wollte herausfinden, wie es mit Zeilenh√∂hen umgeht, was es speichert, wie es die H√∂he eines Zellbereichs ber√ºcksichtigt usw.  Ich habe Excel 2010 analysiert (excel.exe, 32 Bit, Version 14.0.4756.1000, SHA1 a805cf60a5542f21001b0ea5d142d1cd0ee00b28). </p><a name="habracut"></a><br><h2 id="nachnyom-s-teorii">  Beginnen wir mit der Theorie </h2><br><p>  Wenn Sie sich der VBA-Dokumentation f√ºr Microsoft Office zuwenden, k√∂nnen Sie sehen, dass die Zeilenh√∂he auf die eine oder andere Weise √ºber zwei Eigenschaften ermittelt werden kann: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Reihenh√∂he">RowHeight</a> - Gibt die H√∂he der ersten Zeile in dem angegebenen Bereich zur√ºck oder legt diese fest, gemessen in Punkten.  Lesen / Schreiben Double; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="H√∂he">H√∂he</a> - Gibt einen doppelten Wert zur√ºck, der die H√∂he des Bereichs in Punkten darstellt.  Schreibgesch√ºtzt. </li></ul><br><p>  Und wenn Sie auch hier suchen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Excel-Spezifikationen und Grenzen">Excel-Spezifikationen und Grenzwerte</a> .  Sie k√∂nnen feststellen, dass die maximale Zeilenh√∂he 409 Punkte betr√§gt.  Dies ist leider bei weitem nicht der einzige Fall, in dem offizielle Microsoft-Dokumente etwas irref√ºhrend sind.  Tats√§chlich wird im Excel-Code die maximale Zeilenh√∂he auf 2047 Pixel festgelegt, was 1535,25 Punkten entspricht.  Die maximale Schriftgr√∂√üe betr√§gt 409,55 Punkte.  Es ist unm√∂glich, eine Zeile mit solch gro√üer H√∂he zu erhalten, indem Sie sie einfach in VBA / Interop zuweisen. Sie k√∂nnen jedoch eine Zeile erstellen, die Cambria Math-Schriftart in der ersten Zelle festlegen und die Schriftgr√∂√üe auf 409,55 Punkte festlegen.  Dann berechnet Excel mit seinem gerissenen Algorithmus die Zeilenh√∂he basierend auf dem Zellenformat, erh√§lt eine Zahl √ºber 2047 Pixel (glauben Sie dem Wort) und setzt die Zeile auf die maximal m√∂gliche H√∂he.  Wenn Sie die H√∂he dieser Serie √ºber die Benutzeroberfl√§che erfragen, liegt Excel bei einer H√∂he von 409,5 Punkten. Wenn Sie jedoch die H√∂he der Serie √ºber VBA anfordern, erhalten Sie ehrliche 1535,25 Punkte, was 2047 Pixel entspricht.  Richtig, nach dem Speichern des Dokuments sinkt die H√∂he immer noch auf 409,5 Punkte.  Diese Manipulation kann hier in diesem Video beobachtet werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://recordit.co/ivnFEsELLI</a> </p><br><p>  Ich habe die Pixel im vorherigen Absatz aus einem bestimmten Grund erw√§hnt.  Excel speichert und berechnet die Gr√∂√üe von Zellen in Ganzzahlen (im Allgemeinen macht es alles so viel wie m√∂glich in Ganzzahlen).  Meistens sind dies Pixel multipliziert mit einem Faktor.  Interessanterweise speichert Excel die Skala des Erscheinungsbilds in Form eines gew√∂hnlichen Bruchs. Beispielsweise wird eine Skala von 75% als zwei Zahlen 3 und 4 gespeichert. Wenn die Zeile angezeigt werden soll, nimmt Excel die Zeilenh√∂he als ganzzahlige Anzahl von Pixeln, multipliziert mit 3 und dividiert von 4. Aber er wird diese Operation bereits ganz am Ende ausf√ºhren. Daraus entsteht der Effekt, dass alles in Bruchzahlen betrachtet wird.  Um dies zu √ºberpr√ºfen, schreiben Sie den folgenden Code in VBA: </p><br><pre><code class="vbscript hljs">w.Rows(<span class="hljs-number"><span class="hljs-number">1</span></span>).RowHeight = <span class="hljs-number"><span class="hljs-number">75.375</span></span> Debug.Print w.Rows(<span class="hljs-number"><span class="hljs-number">1</span></span>).Height</code> </pre> <br><p>  VBA wird 75 ausgeben, weil  75,375 Pixel sind 100,5 Pixel, und Excel kann es sich nicht leisten und l√§sst den Bruchteil auf 100 Pixel fallen.  Wenn VBA nach der Zeilenh√∂he in Punkten fragt, √ºbersetzt Excel 100 Pixel ehrlich in Punkte und gibt 75 zur√ºck. </p><br><p>  Im Prinzip haben wir bereits eine Klasse in C # geschrieben, die Informationen zur Zeilenh√∂he beschreibt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RowHeightInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//    ,   4. public ushort Flags { get; set; } //  }</span></span></code> </pre> <br><p>  Sie m√ºssen vorerst mein Wort nehmen, aber in Excel wird die Zeilenh√∂he auf diese Weise gespeichert.  Wenn also angegeben wird, dass die Zeilenh√∂he 75 Punkte betr√§gt, betr√§gt sie 100 in Pixel, dann werden 400 in Wert gespeichert. Ich habe nicht vollst√§ndig herausgefunden, was alle Bits in Flags bedeuten (es ist schwierig und lang, die Werte von Flags herauszufinden), aber ich wei√ü dass 0x4000 f√ºr Zeilen festgelegt wird, deren H√∂he manuell festgelegt wird, und 0x2000 - f√ºr ausgeblendete Zeilen festgelegt wird.  Im Allgemeinen entspricht Flags f√ºr sichtbare Zeilen mit einer manuell festgelegten H√∂he meistens 0x4005, und f√ºr Zeilen, in denen die H√∂he basierend auf der Flags-Formatierung berechnet wird, ist sie entweder 0xA oder 0x800E. </p><br><h2 id="sprashivaem-vysotu-ryada">  Wir fragen nach der Reihenh√∂he </h2><br><p>  Im Prinzip k√∂nnen Sie sich jetzt die Methode aus excel.exe ansehen, die die Zeilenh√∂he anhand ihres Index zur√ºckgibt (dank HexRays f√ºr den sch√∂nen Code): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __userpurge GetRowHeight@&lt;eax&gt;(<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowIndex@&lt;edx&gt;, SheetLayoutInfo *sheetLayoutInfo@&lt;esi&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag) { RowHeightInfo *rowHeightInfo; <span class="hljs-comment"><span class="hljs-comment">// eax int result; // ecx if ( sheetLayoutInfo-&gt;dword1A0 ) return sheetLayoutInfo-&gt;defaultFullRowHeightMul4 | (~(sheetLayoutInfo-&gt;defaultRowDelta2 &gt;&gt; 14 &lt;&lt; 15) &amp; 0x8000); if ( rowIndex &lt; sheetLayoutInfo-&gt;MinRowIndexNonDefault ) return sheetLayoutInfo-&gt;defaultFullRowHeightMul4 | (~(sheetLayoutInfo-&gt;defaultRowDelta2 &gt;&gt; 14 &lt;&lt; 15) &amp; 0x8000); if ( rowIndex &gt;= sheetLayoutInfo-&gt;MaxRowIndexNonDefault ) return sheetLayoutInfo-&gt;defaultFullRowHeightMul4 | (~(sheetLayoutInfo-&gt;defaultRowDelta2 &gt;&gt; 14 &lt;&lt; 15) &amp; 0x8000); rowHeightInfo = GetRowHeightCore(sheetLayoutInfo, rowIndex); if ( !rowHeightInfo ) return sheetLayoutInfo-&gt;defaultFullRowHeightMul4 | (~(sheetLayoutInfo-&gt;defaultRowDelta2 &gt;&gt; 14 &lt;&lt; 15) &amp; 0x8000); result = 0; if ( flag || !(rowHeightInfo-&gt;Flags &amp; 0x2000) ) result = rowHeightInfo-&gt;Value; if ( !(rowHeightInfo-&gt;Flags &amp; 0x4000) ) result |= 0x8000u; return result; }</span></span></code> </pre> <br><p>  Was dword1A0 ist, habe ich immer noch nicht herausgefunden.  konnte keinen Ort finden, an dem dieses Flag gesetzt ist :( <br>  Was auch f√ºr mich defaultRowDelta2 ist, bleibt ein R√§tsel.  Wenn Excel die Zeilenh√∂he basierend auf dem Format berechnet, wird sie als Summe zweier Zahlen dargestellt.  defaultRowDelta2 ist die zweite Zahl aus dieser Summe f√ºr die Standardzeilenh√∂he.  Der Wert des Flag-Parameters ist ebenfalls mysteri√∂s, weil  Wo immer ich einen Aufruf dieser Methode im Flag sah, wurde false √ºbergeben. <br>  Die SheetLayoutInfo-Klasse wird auch in dieser Methode angezeigt.  Ich habe es so genannt, weil es viele Informationen √ºber das Erscheinungsbild des Blattes enth√§lt.  In SheetLayoutInfo gibt es folgende Felder: </p><br><ul><li>  DefaultFullRowHeightMul4 - Standardzeilenh√∂he; </li><li>  MinRowIndexNonDefault - der Index der ersten Zeile, bei dem die H√∂he vom Standard abweicht; </li><li>  MaxRowIndexNonDefault - Index der Serie nach der letzten, bei der die H√∂he vom Standard abweicht; </li><li>  DefaultRowDelta2 ist der gleiche Teil der Summe der Standardzeilenh√∂he. </li><li>  GroupIndexDelta - dazu sp√§ter mehr </li></ul><br><p>  Grunds√§tzlich ist die Logik dieser Methode verst√§ndlich: </p><br><ol><li>  Wenn der Index der Reihe kleiner als der erste mit einer nicht standardm√§√üigen H√∂he ist, geben Sie den Standard zur√ºck. </li><li>  Wenn der Index der Reihe gr√∂√üer als der letzte mit einer nicht standardm√§√üigen H√∂he ist, geben Sie den Standard zur√ºck. </li><li>  Andernfalls erhalten wir das rowHeightInfo-Objekt f√ºr die Serie von der GetRowHeightCore-Methode. </li><li>  Wenn rowHeightInfo == null, wird die Standardzeilenh√∂he zur√ºckgegeben. </li><li>  Es gibt Magie mit Flags, aber im Allgemeinen geben wir zur√ºck, was in rowHeightInfo.Value steht, und setzen das 16. Bit in der Antwort, wenn die Zeilenh√∂he nicht manuell festgelegt wurde. </li></ol><br><p>  Wenn Sie diesen Code in C # umschreiben, erhalten Sie ungef√§hr Folgendes: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> HiddenRowMask = <span class="hljs-number"><span class="hljs-number">0x2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> CustomHeightMask = <span class="hljs-number"><span class="hljs-number">0x4000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> DefaultHeightMask = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ushort</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRowHeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex, SheetLayoutInfo sheetLayoutInfo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> defaultHeight = (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>) (sheetLayoutInfo.DefaultFullRowHeightMul4 | (~(sheetLayoutInfo.DefaultRowDelta2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">14</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>) &amp; DefaultHeightMask)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowIndex &lt; sheetLayoutInfo.MinRowIndexNonDefault) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultHeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowIndex &gt;= sheetLayoutInfo.MaxRowIndexNonDefault) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultHeight; RowHeightInfo rowHeightInfo = GetRowHeightCore(sheetLayoutInfo, rowIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowHeightInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultHeight; <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rowHeightInfo.Flags &amp; HiddenRowMask) == <span class="hljs-number"><span class="hljs-number">0</span></span>) result = rowHeightInfo.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rowHeightInfo.Flags &amp; CustomHeightMask) == <span class="hljs-number"><span class="hljs-number">0</span></span>) result |= DefaultHeightMask; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Jetzt k√∂nnen Sie einen Blick darauf werfen, was in GetRowHeightCore passiert: </p><br><pre> <code class="cpp hljs">RowHeightInfo *__<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRowHeightCore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SheetLayoutInfo *sheetLayoutInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex)</span></span></span><span class="hljs-function"> </span></span>{ RowHeightInfo *result; <span class="hljs-comment"><span class="hljs-comment">// eax RowsGroupInfo *rowsGroupInfo; // ecx int rowInfoIndex; // edx result = 0; if ( rowIndex &lt; sheetLayoutInfo-&gt;MinRowIndexNonDefault || rowIndex &gt;= sheetLayoutInfo-&gt;MaxRowIndexNonDefault ) return result; rowsGroupInfo = sheetLayoutInfo-&gt;RowsGroups[sheetLayoutInfo-GroupIndexDelta + (rowIndex &gt;&gt; 4)]; result = 0; if ( !rowsGroupInfo ) return result; rowInfoIndex = rowsGroupInfo-&gt;Indices[rowIndex &amp; 0xF]; if ( rowInfoIndex ) result = (rowsGroupInfo + 8 * (rowInfoIndex + rowsGroupInfo-&gt;wordBA + rowsGroupInfo-&gt;wordBC - rowsGroupInfo-&gt;wordB8)); return result; }</span></span></code> </pre> <br><ol><li>  Zu Beginn pr√ºft Excel erneut, ob der Index der Reihe zu den Zeilen mit ge√§nderter H√∂he geh√∂rt. Andernfalls wird null zur√ºckgegeben. </li><li>  Findet die gew√ºnschte Zeilengruppe. Wenn keine solche Gruppe vorhanden ist, wird null zur√ºckgegeben. </li><li>  Ruft den Index der Serie in der Gruppe ab. </li><li>  Au√üerdem findet es anhand des Index der Reihe das gew√ºnschte Objekt der RowHeightInfo-Klasse.  wordBA, wordBC, wordB8 - einige Konstanten.  Sie √§ndern sich nur mit der Geschichte.  Im Prinzip haben sie keinen Einfluss auf das Verst√§ndnis des Algorithmus. </li></ol><br><p>  Hier lohnt es sich, vom Thema abzuweichen und mehr √ºber RowsGroupInfo zu erz√§hlen.  Excel speichert RowHeightInfo in Gruppen von 16 Teilen, wobei die i-te Gruppe, dargestellt durch die RowsGroupInfo-Klasse, Informationen zu Zeilen von i √ó 16 bis einschlie√ülich i √ó 16 + 15 speichert. </p><br><p>  Informationen zur Zeilenh√∂he in RowsGroupInfo werden jedoch auf ungew√∂hnliche Weise gespeichert.  H√∂chstwahrscheinlich aufgrund der Notwendigkeit, den Verlauf in Excel zu pflegen. </p><br><p>  In RowsGroupInfo gibt es drei wichtige Felder: Indizes, HeightInfos und RowsCount. Das zweite Feld ist im obigen Code nicht sichtbar (sollte in dieser Zeile stehen: (rowsGroupInfo + 8 √ó (...)), da rowInfoIndex sehr unterschiedliche Werte annehmen kann Ich habe sogar mehr als 1000 gesehen und habe keine Ahnung, wie eine solche Struktur in der IDA festgelegt werden soll. Das Feld "RowsCount" wird im obigen Code nicht angezeigt, aber so viele wirklich nicht standardm√§√üige Zeilen werden in der Gruppe gespeichert. <br>  Dar√ºber hinaus gibt es in SheetLayoutInfo GroupIndexDelta - die Differenz zwischen dem realen Index der Gruppe und dem Index der ersten Gruppe mit einer ge√§nderten Zeilenh√∂he. </p><br><p>  Im Feld Indizes werden die RowHeightInfo-Offsets f√ºr jeden Index der Serie innerhalb der Gruppe gespeichert.  Sie werden dort in der Reihenfolge gespeichert, aber in HeightInfos RowHeightInfo werden sie bereits in der Reihenfolge der √Ñnderung gespeichert. </p><br><p>  Angenommen, wir haben ein neues leeres Blatt und irgendwie haben wir die H√∂he der Zeilennummer 23 ge√§ndert. Diese Zeile liegt in der zweiten Gruppe von 16 Zeilen, dann: </p><br><ol><li>  Excel ermittelt den Gruppenindex f√ºr diese Serie.  Im aktuellen Fall ist der Index 1 und √§ndert GroupIndexDelta = -1. </li><li>  Erstellt ein Objekt der RowsGroupInfo-Klasse f√ºr eine Reihe von Zeilen und f√ºgt es in sheetLayoutInfo-&gt; RowsGroups unter dem Index 0 ab (sheetLayoutInfo-&gt; GroupIndexDelta + 1). </li><li>  In RowsGroupInfo weist Excel Speicher f√ºr 16 4-Byte-Indizes f√ºr RowsCount, wordBA, wordBC und wordB8 usw. zu. </li><li>  Dann berechnet Excel den Index der Reihe in der Gruppe durch die bitweise UND-Operation (dies ist viel schneller als der Rest der Division): rowIndex &amp; 0xF.  Der gew√ºnschte Index in der Gruppe ist: 23 &amp; 0xF = 7; </li><li>  Danach erh√§lt Excel den Offset f√ºr Index 7: offset = Indices [7].  Wenn offset = 0 ist, weist Excel am Ende von RowsGroupInto 8 Bytes zu, erh√∂ht den RowsCount um eins und schreibt den neuen Offset in Indizes [7].  In jedem Fall schreibt Excel am Ende Informationen √ºber die neue Zeilenh√∂he und Flags am Versatz in die RowsGroupInfo. </li></ol><br><p>  Die RowsGroupInfo-Klasse in C # selbst w√ºrde folgenderma√üen aussehen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RowsGroupInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] Indices { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;RowHeightInfo&gt; HeightInfos { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RowsGroupInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[SheetLayoutInfo.MaxRowsCountInGroup]; HeightInfos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RowHeightInfo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SheetLayoutInfo.MaxRowsCountInGroup; i++) { Indices[i] = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } }</code> </pre> <br><p>  Die GetRowHeightCore-Methode w√ºrde folgenderma√üen aussehen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RowHeightInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRowHeightCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SheetLayoutInfo sheetLayoutInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowIndex &lt; sheetLayoutInfo.MinRowIndexNonDefault || rowIndex &gt;= sheetLayoutInfo.MaxRowIndexNonDefault) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; RowsGroupInfo rowsGroupInfo = sheetLayoutInfo.RowsGroups[sheetLayoutInfo.GroupIndexDelta + (rowIndex &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowsGroupInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowInfoIndex = rowsGroupInfo.Indices[rowIndex &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowInfoIndex != <span class="hljs-number"><span class="hljs-number">-1</span></span> ? rowsGroupInfo.HeightInfos[rowInfoIndex] : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><p>  Und so w√ºrde SetRowHeight aussehen (ich habe seinen Code aus excel.exe nicht aufgelistet): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRowHeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ushort</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newRowHeight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ushort</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, SheetLayoutInfo sheetLayoutInfo</span></span></span><span class="hljs-function">)</span></span> { sheetLayoutInfo.MaxRowIndexNonDefault = Math.Max(sheetLayoutInfo.MaxRowIndexNonDefault, rowIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); sheetLayoutInfo.MinRowIndexNonDefault = Math.Min(sheetLayoutInfo.MinRowIndexNonDefault, rowIndex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> realGroupIndex = rowIndex &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sheetLayoutInfo.RowsGroups.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { sheetLayoutInfo.RowsGroups.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); sheetLayoutInfo.GroupIndexDelta = -realGroupIndex; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sheetLayoutInfo.GroupIndexDelta + realGroupIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucketSize = -(sheetLayoutInfo.GroupIndexDelta + realGroupIndex); sheetLayoutInfo.RowsGroups.InsertRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowsGroupInfo[bucketSize]); sheetLayoutInfo.GroupIndexDelta = -realGroupIndex; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sheetLayoutInfo.GroupIndexDelta + realGroupIndex &gt;= sheetLayoutInfo.RowsGroups.Count) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucketSize = sheetLayoutInfo.GroupIndexDelta + realGroupIndex - sheetLayoutInfo.RowsGroups.Count + <span class="hljs-number"><span class="hljs-number">1</span></span>; sheetLayoutInfo.RowsGroups.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowsGroupInfo[bucketSize]); } RowsGroupInfo rowsGroupInfo = sheetLayoutInfo.RowsGroups[sheetLayoutInfo.GroupIndexDelta + realGroupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowsGroupInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { rowsGroupInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowsGroupInfo(); sheetLayoutInfo.RowsGroups[sheetLayoutInfo.GroupIndexDelta + realGroupIndex] = rowsGroupInfo; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowInfoIndex = rowsGroupInfo.Indices[rowIndex &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>]; RowHeightInfo rowHeightInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowInfoIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { rowHeightInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowHeightInfo(); rowsGroupInfo.HeightInfos.Add(rowHeightInfo); rowsGroupInfo.Indices[rowIndex &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>] = rowsGroupInfo.HeightInfos.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rowHeightInfo = rowsGroupInfo.HeightInfos[rowInfoIndex]; } rowHeightInfo.Value = newRowHeight; rowHeightInfo.Flags = flags; }</code> </pre> <br><h2 id="nemnogo-praktiki">  Ein bisschen √úbung </h2><br><p>  Nach dem obigen Beispiel sieht Excel mit einer √Ñnderung der H√∂he von Zeile 23 ungef√§hr so ‚Äã‚Äãaus (ich habe Zeile 23 auf eine H√∂he von 75 Punkten festgelegt): </p><br><div class="spoiler">  <b class="spoiler_title">sheetLayoutInfo</b> <div class="spoiler_text"><ul><li>  DefaultFullRowHeightMul4 = 80 </li><li>  DefaultRowDelta2 = 5 </li><li>  MaxRowIndexNonDefault = 24 </li><li>  MinRowIndexNonDefault = 23 </li><li>  GroupIndexDelta = -1 </li><li>  Anzahl der Zeilengruppen = 1 <br><ul><li>  [0] RowsGroupInfo </li><li>  HeightInfos Count = 1 <br><ul><li>  [0] RowHeightInfo </li><li>  Flags = 0x4005 </li><li>  Wert = 100 </li></ul></li><li>  Indizes <br><ul><li>  [0] = -1 </li><li>  [1] = -1 </li><li>  [2] = -1 </li><li>  [3] = -1 </li><li>  [4] = -1 </li><li>  [5] = -1 </li><li>  [6] = -1 </li><li>  [7] = 0 </li><li>  [8] = -1 </li><li>  [9] = -1 </li><li>  [10] = -1 </li><li>  [11] = -1 </li><li>  [12] = -1 </li><li>  [13] = -1 </li><li>  [14] = -1 </li><li>  [15] = -1 </li></ul></li></ul></li></ul></div></div><br>  Hier und im folgenden Beispiel werde ich eine schematische Darstellung des Aussehens der Daten im Excel-Speicher in Visual Studio aus selbstgeschriebenen Klassen erstellen, da ein direkter Speicherauszug aus dem Speicher nicht sehr informativ ist. <br>  Versuchen wir nun, Zeile 23 auszublenden. Setzen Sie dazu das 0x2000-Bit von Flags.  Wir werden die Erinnerung √§ndern, um zu leben.  Das Ergebnis ist in diesem Video zu sehen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://recordit.co/79vYIbwbzB</a> . <br>  Immer wenn Sie Zeilen ausblenden, macht Excel dasselbe. <br>  Stellen wir nun die Zeilenh√∂he nicht explizit ein, sondern √ºber das Zellenformat.  Lassen Sie die Schriftart in Zelle A20 eine H√∂he von 40 Punkten erreichen, dann betr√§gt die Zellenh√∂he in Punkten 45,75 und im Excel-Speicher ungef√§hr so: <br><div class="spoiler">  <b class="spoiler_title">sheetLayoutInfo</b> <div class="spoiler_text"><ul><li>  DefaultFullRowHeightMul4 = 80 </li><li>  DefaultRowDelta2 = 5 </li><li>  MaxRowIndexNonDefault = 24 </li><li>  MinRowIndexNonDefault = 20 </li><li>  GroupIndexDelta = -1 </li><li>  Anzahl der Zeilengruppen = 1 <br><ul><li>  [0] RowsGroupInfo </li><li>  HeightInfos Count = 2 <br><ul><li>  [0] RowHeightInfo </li><li>  Flags = 0x4005 </li><li>  Wert = 100 </li><li>  [1] RowHeightInfo </li><li>  Flags = 0x800E </li><li>  Wert = 244 </li></ul></li><li>  Indizes <br><ul><li>  [0] = -1 </li><li>  [1] = -1 </li><li>  [2] = -1 </li><li>  [3] = -1 </li><li>  [4] = 1 </li><li>  [5] = -1 </li><li>  [6] = -1 </li><li>  [7] = 0 </li><li>  [8] = -1 </li><li>  [9] = -1 </li><li>  [10] = -1 </li><li>  [11] = -1 </li><li>  [12] = -1 </li><li>  [13] = -1 </li><li>  [14] = -1 </li><li>  [15] = -1 </li></ul></li></ul></li></ul></div></div><br><p>  M√∂glicherweise stellen Sie fest, dass Excel die Zeilenh√∂he immer speichert, wenn dies nicht Standard ist.  Auch wenn die H√∂he nicht explizit festgelegt wird, sondern auf der Grundlage des Inhalts der Zellen oder des Formats berechnet wird, berechnet Excel sie dennoch einmal und ordnet das Ergebnis der entsprechenden Gruppe zu. </p><br><h2 id="razbiraemsya-so-vstavkoyudaleniem-ryadov">  Wir besch√§ftigen uns mit dem Einf√ºgen / L√∂schen von Zeilen </h2><br><p>  Es w√§re interessant zu analysieren, was beim Einf√ºgen / L√∂schen von Zeilen passiert.  Der entsprechende Code in excel.exe ist nicht schwer zu finden, aber es bestand kein Wunsch, ihn zu zerlegen. Sie k√∂nnen sich einen Teil davon ansehen: </p><br><div class="spoiler">  <b class="spoiler_title">sub_305EC930</b> <div class="spoiler_text"><p>  Das Flag a5 bestimmt, welche Operation gerade stattfindet. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __userpurge sub_305EC930@&lt;eax&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a1@&lt;eax&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a2@&lt;edx&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a3@&lt;ecx&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a4, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a5, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a6) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v6; <span class="hljs-comment"><span class="hljs-comment">// esi int v7; // ebx int v8; // edi int v9; // edx int v10; // ecx size_t v11; // eax _WORD *v12; // ebp size_t v13; // eax size_t v14; // eax int v15; // eax unsigned __int16 *v16; // ecx _WORD *v17; // eax _WORD *v18; // ecx int v19; // edx __int16 v20; // bx int v21; // eax _WORD *v22; // ecx int v24; // edx int v25; // eax int v26; // esi int v27; // ebx size_t v28; // eax int v29; // ebp size_t v30; // eax int v31; // esi size_t v32; // eax int v33; // eax unsigned __int16 *v34; // ecx int v35; // eax _WORD *v36; // edx _WORD *v37; // ecx int v38; // eax __int16 v39; // bx int v40; // eax _WORD *v41; // ecx int v42; // [esp+10h] [ebp-48h] int v43; // [esp+10h] [ebp-48h] int v44; // [esp+14h] [ebp-44h] char v45; // [esp+14h] [ebp-44h] int Dst[16]; // [esp+18h] [ebp-40h] int v47; // [esp+5Ch] [ebp+4h] int v48; // [esp+60h] [ebp+8h] v6 = a1; v7 = a1 &amp; 0xF; v8 = a2; if ( !a5 ) { v24 = a4 - a1; v25 = a1 - a3; v43 = a4 - v6; if ( v7 &gt;= v25 ) v7 = v25; v47 = a4 - v7; v26 = v6 - v7; v27 = v7 + 1; v48 = v27; if ( !v8 ) return v27; v28 = 4 * v24; if ( (4 * v24) &gt; 0x40 ) v28 = 64; v45 = v27 + v26; v29 = (v27 + v26) &amp; 0xF; memmove(Dst, (v8 + 4 * v29), v28); v30 = 4 * v27; if ( (4 * v27) &gt; 0x40 ) v30 = 64; v31 = v26 &amp; 0xF; memmove((v8 + 4 * (v47 &amp; 0xF)), (v8 + 4 * v31), v30); v32 = 4 * v43; if ( (4 * v43) &gt; 0x40 ) v32 = 64; memmove((v8 + 4 * v31), Dst, v32); if ( !a6 ) return v48; v33 = v29; if ( v29 &lt; v29 + v43 ) { v34 = (v8 + 4 * v29 + 214); do { Dst[v33++] = *v34 &gt;&gt; 15; v34 += 2; } while ( v33 &lt; v29 + v43 ); } v35 = (v45 - 1) &amp; 0xF; if ( v35 &gt;= v31 ) { v36 = (v8 + 4 * ((v27 + v47 - 1) &amp; 0xF) + 214); v37 = (v8 + 4 * ((v45 - 1) &amp; 0xF) + 214); v38 = v35 - v31 + 1; do { v39 = *v37 ^ (*v37 ^ *v36) &amp; 0x7FFF; v37 -= 2; *v36 = v39; v36 -= 2; --v38; } while ( v38 ); v27 = v48; } v40 = v31; if ( v31 &gt;= v31 + v43 ) return v27; v41 = (v8 + 4 * v31 + 214); do { *v41 = *v41 &amp; 0x7FFF | (LOWORD(Dst[v40++]) &lt;&lt; 15); v41 += 2; } while ( v40 &lt; v31 + v43 ); return v27; } v9 = a1 - a4; v10 = a3 - a1; v42 = a1 - a4; v48 = 16 - v7; if ( 16 - v7 &gt;= v10 ) v48 = v10; if ( !v8 ) return v48; v11 = 4 * v9; if ( (4 * v9) &gt; 0x40 ) v11 = 64; v12 = (v8 + 4 * (a4 &amp; 0xF)); v44 = a4 &amp; 0xF; memmove(Dst, v12, v11); v13 = 4 * v48; if ( (4 * v48) &gt; 0x40 ) v13 = 64; memmove(v12, (v8 + 4 * v7), v13); v14 = 4 * v42; if ( (4 * v42) &gt; 0x40 ) v14 = 64; memmove((v8 + 4 * ((a4 + v48) &amp; 0xF)), Dst, v14); if ( !a6 ) return v48; v15 = a4 &amp; 0xF; if ( v44 &lt; v44 + v42 ) { v16 = (v8 + 4 * v44 + 214); do { Dst[v15++] = *v16 &gt;&gt; 15; v16 += 2; } while ( v15 &lt; v44 + v42 ); } if ( v7 &lt; v48 + v7 ) { v17 = (v8 + 4 * v7 + 214); v18 = v12 + 107; v19 = v48; do { v20 = *v17 ^ (*v17 ^ *v18) &amp; 0x7FFF; v17 += 2; *v18 = v20; v18 += 2; --v19; } while ( v19 ); } v21 = a4 &amp; 0xF; if ( v44 &gt;= v44 + v42 ) return v48; v22 = (v8 + 4 * (v44 + v48) + 214); do { *v22 = *v22 &amp; 0x7FFF | (LOWORD(Dst[v21++]) &lt;&lt; 15); v22 += 2; } while ( v21 &lt; v44 + v42 ); return v48; }</span></span></code> </pre> </div></div><br><p>  Dar√ºber hinaus k√∂nnen Sie in der Erscheinung grob verstehen, was dort passiert, und der Rest wird durch indirekte Zeichen abgeschlossen. <br>  Wir versuchen, diese indirekten Merkmale zu identifizieren.  Stellen Sie zun√§chst die H√∂he f√ºr die Zeilen 16 bis einschlie√ülich 64 in zuf√§lliger Reihenfolge ein.  F√ºgen Sie dann vor der Zeile unter Index 39 eine neue Zeile ein.  Die neue Zeile kopiert die H√∂he der Zeile 38. <br>  Schauen wir uns die Informationen in den Gruppen von Serien vor und nach dem Hinzuf√ºgen einer Serie an. Ich habe die k√ºhnen Unterschiede hervorgehoben: </p><br><table><thead><tr><th>  Vor dem Hinzuf√ºgen einer Zeile </th><th>  Nach dem Hinzuf√ºgen einer Zeile </th></tr></thead><tbody><tr><td>  Verschiebungen in der ersten Gruppe: </td><td>  Verschiebungen in der ersten Gruppe: </td></tr><tr><td>  0E, 04, 07, 00, 05, 0A, 09, 0F, 03, 06, 08, 0D, 01, 0B, 0C, 02 </td><td>  0E, 04, 07, 00, 05, 0A, 09, 0F, 03, 06, 08, 0D, 01, 0B, 0C, 02 </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der ersten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der ersten Gruppe: </td></tr><tr><td>  05, 2B, 35, 45, 4B, 50, 5B, 6B, 7B, 8B, A5, AB, B0, B5, E0, 100 </td><td>  05, 2B, 35, 45, 4B, 50, 5B, 6B, 7B, 8B, A5, AB, B0, B5, E0, 100 </td></tr><tr><td>  Verschiebungen in der zweiten Gruppe: </td><td>  Verschiebungen in der zweiten Gruppe: </td></tr><tr><td>  06, 02, 0E, 09, 01, 07, <strong>0F, 0C</strong> , 00, 0A, 04, 0B, 03, 08, <strong>0D, 05</strong> </td><td>  06, 02, 0E, 09, 01, 07, <strong>0F, 05, 0C</strong> , 00, 0A, 04, 0B, 03, 08, <strong>0D</strong> </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der zweiten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der zweiten Gruppe: </td></tr><tr><td>  10, 15, 20, 25, 30, <strong>75</strong> , 85, 90, 9B, A0, C5, CB, D0, D5, E5, F0 </td><td>  10, 15, 20, 25, 30, <strong>F0</strong> , 85, 90, 9B, A0, C5, CB, D0, D5, E5, F0 </td></tr><tr><td>  Verschiebungen in der dritten Gruppe: </td><td>  Verschiebungen in der dritten Gruppe: </td></tr><tr><td>  0C, 08, 0E, 07, 0A, 01, 06, 0F, 09, 0D, 00, 05, 0B, 02, 04, <strong>03</strong> </td><td>  <strong>03</strong> , 0C, 08, 0E, 07, 0A, 01, 06, 0F, 09, 0D, 00, 05, 0B, 02, 04 </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der dritten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der dritten Gruppe: </td></tr><tr><td>  0B, 1B, 3B, <strong>40</strong> , 55, 60, 65, 70, 80, 95, BB, C0, DB, EB, F5, FB </td><td>  0B, 1B, 3B, <strong>75</strong> , 55, 60, 65, 70, 80, 95, BB, C0, DB, EB, F5, FB </td></tr><tr><td>  Offsets in der vierten Gruppe: </td><td>  Offsets in der vierten Gruppe: </td></tr><tr><td>  _ </td><td>  <strong>00</strong> </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der vierten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der vierten Gruppe: </td></tr><tr><td>  _ </td><td>  <strong>40</strong> </td></tr></tbody></table><br><p>  Dies wurde erwartet: Excel f√ºgt in die zweite Gruppe eine neue Zeile mit Index 7 (39 &amp; 0xF) ein, deren Versatz 0x05 ist, kopiert die Zeilenh√∂he bei Index 6, w√§hrend die letzte Zeile, die Versatz 05 war, zur n√§chsten verschoben wird Gruppe, und von dort wird die letzte Reihe in die vierte geschoben, etc. </p><br><p>  Nun wollen wir sehen, was passiert, wenn Sie die 29. Zeile l√∂schen. </p><br><table><thead><tr><th>  Vor dem Entfernen einer Zeile </th><th>  Nach dem Entfernen der Reihe </th></tr></thead><tbody><tr><td>  Verschiebungen in der ersten Gruppe: </td><td>  Verschiebungen in der ersten Gruppe: </td></tr><tr><td>  0E, 04, 07, 00, 05, 0A, 09, 0F, 03, 06, 08, 0D, 01, <strong>0B, 0C, 02</strong> </td><td>  0E, 04, 07, 00, 05, 0A, 09, 0F, 03, 06, 08, 0D, 01, <strong>0C, 02, 0B</strong> </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der ersten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der ersten Gruppe: </td></tr><tr><td>  05, 2B, 35, 45, 4B, 50, 5B, 6B, 7B, 8B, A5, <strong>AB</strong> , B0, B5, E0, 100 </td><td>  05, 2B, 35, 45, 4B, 50, 5B, 6B, 7B, 8B, A5, <strong>85</strong> , B0, B5, E0, 100 </td></tr><tr><td>  Verschiebungen in der zweiten Gruppe: </td><td>  Verschiebungen in der zweiten Gruppe: </td></tr><tr><td>  <strong>06</strong> , 02, 0E, 09, 01, 07, 0F, 05, 0C, 00, 0A, 04, 0B, 03, 08, 0D </td><td>  02, 0E, 09, 01, 07, 0F, 05, 0C, 00, 0A, 04, 0B, 03, 08, 0D, <strong>06</strong> </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der zweiten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der zweiten Gruppe: </td></tr><tr><td>  10, 15, 20, 25, 30, F0, <strong>85</strong> , 90, 9B, A0, C5, CB, D0, D5, E5, F0 </td><td>  10, 15, 20, 25, 30, F0, <strong>75</strong> , 90, 9B, A0, C5, CB, D0, D5, E5, F0 </td></tr><tr><td>  Verschiebungen in der dritten Gruppe: </td><td>  Verschiebungen in der dritten Gruppe: </td></tr><tr><td>  <strong>03</strong> , 0C, 08, 0E, 07, 0A, 01, 06, 0F, 09, 0D, 00, 05, 0B, 02, 04 </td><td>  0C, 08, 0E, 07, 0A, 01, 06, 0F, 09, 0D, 00, 05, 0B, 02, 04, <strong>03</strong> </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der dritten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der dritten Gruppe: </td></tr><tr><td>  0B, 1B, 3B, <strong>75</strong> , 55, 60, 65, 70, 80, 95, BB, C0, DB, EB, F5, FB </td><td>  0B, 1B, 3B, <strong>40</strong> , 55, 60, 65, 70, 80, 95, BB, C0, DB, EB, F5, FB </td></tr><tr><td>  Offsets in der vierten Gruppe: </td><td>  Offsets in der vierten Gruppe: </td></tr><tr><td>  00 </td><td>  00 </td></tr><tr><td>  Die Werte der Zeilenh√∂hen in der vierten Gruppe: </td><td>  Die Werte der Zeilenh√∂hen in der vierten Gruppe: </td></tr><tr><td>  <strong>40</strong> </td><td>  <strong>50</strong> </td></tr></tbody></table><br><p>  Wenn eine Zeile gel√∂scht wird, treten im Prinzip umgekehrte Operationen auf.  In diesem Fall bleibt die vierte Gruppe bestehen und der Wert der dortigen Zeilenh√∂he wird mit der Standardh√∂he mit dem entsprechenden Flag - 0x8005 gef√ºllt. </p><br><p>  Diese Daten reichen aus, um diesen Algorithmus in C # zu reproduzieren: </p><br><div class="spoiler">  <b class="spoiler_title">Insertrow</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SheetLayoutInfo sheetLayoutInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowIndex &gt;= sheetLayoutInfo.MaxRowIndexNonDefault) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; RowHeightInfo etalonRowHeightInfo = GetRowHeightCore(sheetLayoutInfo, rowIndex); RowHeightInfo newRowHeightInfo = etalonRowHeightInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? etalonRowHeightInfo.Clone() : CreateDefaultRowHeight(sheetLayoutInfo); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> realGroupIndex = (rowIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newRowInGroupIndex = (rowIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (groupIndex = realGroupIndex + sheetLayoutInfo.GroupIndexDelta; groupIndex &lt; sheetLayoutInfo.RowsGroups.Count; groupIndex++, newRowInGroupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupIndex == SheetLayoutInfo.MaxGroupsCount) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; RowsGroupInfo rowsGroupInfo = sheetLayoutInfo.RowsGroups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowsGroupInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((newRowHeightInfo.Flags &amp; CustomHeightMask) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; rowsGroupInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowsGroupInfo(); sheetLayoutInfo.RowsGroups[groupIndex] = rowsGroupInfo; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowInfoIndex = rowsGroupInfo.Indices[newRowInGroupIndex]; RowHeightInfo lastRowHeightInGroup; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowInfoIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span> || rowsGroupInfo.HeightInfos.Count &lt; SheetLayoutInfo.MaxRowsCountInGroup) { lastRowHeightInGroup = GetRowHeightCore(sheetLayoutInfo, ((groupIndex - sheetLayoutInfo.GroupIndexDelta) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span>); Array.Copy(rowsGroupInfo.Indices, newRowInGroupIndex, rowsGroupInfo.Indices, newRowInGroupIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>, SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span> - newRowInGroupIndex); rowsGroupInfo.HeightInfos.Add(newRowHeightInfo); rowsGroupInfo.Indices[newRowInGroupIndex] = rowsGroupInfo.HeightInfos.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = rowsGroupInfo.Indices[SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span>]; lastRowHeightInGroup = rowsGroupInfo.HeightInfos[lastIndex]; Array.Copy(rowsGroupInfo.Indices, newRowInGroupIndex, rowsGroupInfo.Indices, newRowInGroupIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>, SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span> - newRowInGroupIndex); rowsGroupInfo.HeightInfos[lastIndex] = newRowHeightInfo; rowsGroupInfo.Indices[newRowInGroupIndex] = lastIndex; } newRowHeightInfo = lastRowHeightInGroup ?? CreateDefaultRowHeight(sheetLayoutInfo); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((newRowHeightInfo.Flags &amp; CustomHeightMask) != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; groupIndex != SheetLayoutInfo.MaxGroupsCount) { SetRowHeight(((groupIndex - sheetLayoutInfo.GroupIndexDelta) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + newRowInGroupIndex, newRowHeightInfo.Value, newRowHeightInfo.Flags, sheetLayoutInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sheetLayoutInfo.MaxRowIndexNonDefault = Math.Min(sheetLayoutInfo.MaxRowIndexNonDefault + <span class="hljs-number"><span class="hljs-number">1</span></span>, SheetLayoutInfo.MaxRowsCount); } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Entferner entfernen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SheetLayoutInfo sheetLayoutInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowIndex &gt;= sheetLayoutInfo.MaxRowIndexNonDefault) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> realGroupIndex = rowIndex &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newRowInGroupIndex = rowIndex &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (groupIndex = realGroupIndex + sheetLayoutInfo.GroupIndexDelta; groupIndex &lt; sheetLayoutInfo.RowsGroups.Count; groupIndex++, newRowInGroupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupIndex &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { sheetLayoutInfo.RowsGroups.Insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); sheetLayoutInfo.GroupIndexDelta++; groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupIndex == SheetLayoutInfo.MaxGroupsCount) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newRowHeightInfo = groupIndex == SheetLayoutInfo.MaxGroupsCount - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : GetRowHeightCore(sheetLayoutInfo, (groupIndex - sheetLayoutInfo.GroupIndexDelta + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); RowsGroupInfo rowsGroupInfo = sheetLayoutInfo.RowsGroups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowsGroupInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newRowHeightInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || (newRowHeightInfo.Flags &amp; CustomHeightMask) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; rowsGroupInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowsGroupInfo(); sheetLayoutInfo.RowsGroups[groupIndex] = rowsGroupInfo; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newRowHeightInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { newRowHeightInfo = CreateDefaultRowHeight(sheetLayoutInfo); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowInfoIndex = rowsGroupInfo.Indices[newRowInGroupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowInfoIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = newRowInGroupIndex; i &lt; SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { rowsGroupInfo.Indices[i] = rowsGroupInfo.Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } rowsGroupInfo.HeightInfos.Add(newRowHeightInfo); rowsGroupInfo.Indices[SheetLayoutInfo.MaxRowsCountInGroup - <span class="hljs-number"><span class="hljs-number">1</span></span>] = rowsGroupInfo.HeightInfos.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = newRowInGroupIndex; i &lt; rowsGroupInfo.HeightInfos.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { rowsGroupInfo.Indices[i] = rowsGroupInfo.Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } rowsGroupInfo.Indices[rowsGroupInfo.HeightInfos.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>] = rowInfoIndex; rowsGroupInfo.HeightInfos[rowInfoIndex] = newRowHeightInfo; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rowIndex &lt;= sheetLayoutInfo.MinRowIndexNonDefault) { sheetLayoutInfo.MinRowIndexNonDefault = Math.Max(sheetLayoutInfo.MinRowIndexNonDefault - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Sie finden den gesamten obigen Code auf GitHub</strong></a> </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Dies ist nicht das erste Mal, dass Excel-Code von interessanten Tricks √ºberrascht wurde.  Diesmal habe ich herausgefunden, wie er Informationen √ºber die H√∂hen der Reihen speichert.  Wenn die Community interessiert ist, werde ich im n√§chsten Artikel zeigen, wie Excel die H√∂he des Zellbereichs ber√ºcksichtigt (Spoiler: Es gibt etwas √Ñhnliches wie die SQRT-Zerlegung, aber aus irgendeinem Grund ohne Summen-Caching). Dort k√∂nnen Sie sehen, wie die Skalierung in ganzen Zahlen angewendet wird . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435426/">https://habr.com/ru/post/de435426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435416/index.html">DIY Projekttechnik. Einf√ºhrungsteil</a></li>
<li><a href="../de435418/index.html">Verwenden von SQLite in Flutter</a></li>
<li><a href="../de435420/index.html">Die Zukunft der Verbrechensbek√§mpfung ist das Studium der Stammb√§ume</a></li>
<li><a href="../de435422/index.html">Wie erfahrene Leute im Silicon Valley</a></li>
<li><a href="../de435424/index.html">Parse & Android: Empfehlungen f√ºr Anf√§nger</a></li>
<li><a href="../de435428/index.html">Fernsteuerung des Fceux-Emulators mit Python</a></li>
<li><a href="../de435430/index.html">Die coolsten Nachrichten CES 2019</a></li>
<li><a href="../de435432/index.html">Neues Jahr, neuer GitHub: Unbegrenzte kostenlose private Repositories</a></li>
<li><a href="../de435436/index.html">5 Trends in der IT-Infrastruktur: Prognose f√ºr 2019</a></li>
<li><a href="../de435438/index.html">PHP: √Ñnderung der Datenbankstruktur in der Teamentwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>