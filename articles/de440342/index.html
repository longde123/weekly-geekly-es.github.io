<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏻 🌱 👨🏿‍🚒 Universeller C # -Code für NET und JavaScript 👧🏽 🤵🏼 👇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während meiner Arbeit bei GFRANQ Photo Service war ich 2013 an der Entwicklung eines gleichnamigen Webdienstes für die Veröffentlichung und Verarbeitu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Universeller C # -Code für NET und JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440342/"><p>  Während meiner Arbeit bei GFRANQ Photo Service war ich 2013 an der Entwicklung eines gleichnamigen Webdienstes für die Veröffentlichung und Verarbeitung von Fotos beteiligt.  Filter und Transformationen wurden in der Datei mit Parametern definiert, und die gesamte Verarbeitung wurde auf dem Server ausgeführt.  Während der Serviceentwicklung mussten diese Transformationen auf der Clientseite für die Vorschau unterstützt werden.  Laut Larry Wall ist Faulheit eine der Tugenden eines Programmierers.  Daher haben wir als wirklich faule Programmierer über die Möglichkeit nachgedacht, auf Server- und Clientseite denselben Code zu verwenden.  Die gesamte Entwicklung wurde in C # durchgeführt.  Nachdem wir die Bibliotheken recherchiert und einige Versuche unternommen hatten, kamen wir stolz zu dem Schluss, dass dies möglich war, und begannen, den universellen Code zu schreiben. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/gs/y0/irgsy0wvrqkk5ybw0elxt5nagfk.png"></div><p></p><br><p> Warum wird dieser Artikel benötigt?  In der Tat sind seit 2013 6 Jahre vergangen, und viele Technologien haben ihre Relevanz verloren, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Script #</a> .  Auf der anderen Seite sind neue erschienen.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bridge.NET</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blazor</a> basierend auf der ausgefallenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly</a> . </p><br><p>  Trotzdem können einige Ideen noch verwendet werden.  In diesem Artikel habe ich versucht, sie so detailliert wie möglich zu beschreiben.  Ich hoffe, dass die Erwähnung von Silverlight und Flash ein Lächeln mit einem Hauch von Nostalgie hervorruft und nicht den Wunsch, die alten Lösungen zu kritisieren.  Auf jeden Fall haben sie zur Entwicklung der Webbranche beigetragen. </p><a name="habracut"></a><br><h2 id="contents">  Inhalt </h2><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ziel</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung der Filter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung der Collagen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahl einer Plattform für die Fotoverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C # in Javascript übersetzen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorteile</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachteile</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Struktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alias ​​verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links zu Dateien</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweise zur .NET-Implementierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie entsorgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schloss verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichern von Masken im Speicher</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweise zur JavaScript-Implementierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minimierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Manuelle Minimierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatisierte Minimierung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debug- und Release-Modi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">crossOrigin-Eigenschaft</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierungen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden der vorberechneten Werte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konvertieren eines Bildes in ein Array von Pixeln</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codebeispiele</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemein</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkennen, ob eine Zeichenfolge eine Zahl ist</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ganzzahlige Division</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drehen und Spiegeln eines Bildes mithilfe von Canvas und Bitmap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchrones und asynchrones Laden von Bildern</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nur Skript #</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkennen des Typs und der Version eines Browsers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendern einer Strichpunktlinie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rotationsanimation</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><br><h2 id="goal">  Ziel </h2><br><p>  Die Herausforderung besteht darin, Fotocollage- und filterbasierte Fotobearbeitungsfunktionen auf der Clientseite und, wenn möglich, auch auf der Serverseite zu implementieren.  Zunächst werde ich erläutern, wie Filter und Collagen implementiert werden. </p><br><h3 id="description-of-filters">  Beschreibung der Filter </h3><br><p>  Im Rahmen unseres Projekts besteht <strong>ein Filter aus</strong> einer Reihe von Aktionen, die in Photoshop ausgeführt und auf ein bestimmtes Foto angewendet werden.  Nachfolgend finden Sie Beispiele für solche Aktionen: </p><br><ul><li>  Helligkeitsanpassung </li><li>  Kontrasteinstellung </li><li>  Sättigungseinstellung </li><li>  Anpassung der Farbkurven </li><li>  Maskierung in verschiedenen Modi </li><li>  Rahmung </li><li>  ... </li></ul><br><p>  Wir brauchen ein bestimmtes Format, um diese Aktionen zu beschreiben.  Sicher, es gibt gängige Formate wie JSON und XML, aber aus folgenden Gründen wurde beschlossen, ein eigenes Format zu erstellen: </p><br><ul><li>  Notwendigkeit einer plattformunabhängigen Codearchitektur (.NET, JavaScript, WinPhone usw.) </li><li>  Notwendigkeit eines einfachen nicht hierarchischen Filterformats, das das Schreiben eines Parsers erleichtert </li><li>  XML- und JSON-Daten verbrauchen mehr Speicher (in diesem speziellen Fall) </li></ul><br><p>  So sieht die Abfolge der Aktionen für den <strong>XPro Film-</strong> Filter aus: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y_/oy/ad/y_oyadt7qubbsa9an37h32ostqs.png"></div><br><p>  Neben der Bearbeitung eines Fotos mit einem Filter mussten wir das Bild zuschneiden und drehen.  Ja, ich wusste, dass es jQuery-Plugins zum Zuschneiden und Drehen von Bildern gibt, aber sie schienen überladen zu sein und von der universellen Architektur des Projekts abzuweichen. </p><br><h3 id="description-of-collages">  Beschreibung der Collagen </h3><br><p>  <strong>Eine Collage</strong> ist eine Anordnung mehrerer miniaturisierter Fotos zu einem ganzen Foto (mit oder ohne Maske).  Außerdem mussten Benutzer verfügbare Bilder per Drag &amp; Drop auf die Collage ziehen, ihre Position und ihren Maßstab ändern können.  Ihre Collage könnte folgendermaßen aussehen: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/250/1f8/0842501f87761a3c128b5f117719b10c.jpg"></div><br><p> Bei der Collagenfunktion wird ein einfaches Format zum Speichern von Rechtecken mit relativen Koordinaten von <code>0</code> bis <code>1</code> , den Adressen von Fotos und Bildänderungsdaten verwendet.  Relative Koordinaten werden verwendet, da dieselben clientseitigen Transformationen auf große Bilder auf der Serverseite angewendet werden. </p><br><h2 id="implementation">  Implementierung </h2><br><p>  Wir mussten die Plattform auswählen, auf der Benutzer mit Filtern und Collagen arbeiten können </p><br><h3 id="choosing-a-platform-for-photo-processing">  Auswahl einer Plattform für die Fotoverarbeitung </h3><br><p>  Es gibt verschiedene <strong>RIA-</strong> Technologien (Rich Internet Application) wie: </p><br><ul><li>  Adobe Flash </li><li>  Microsoft Silverlight </li><li>  HTML 5 + JavaScript </li><li>  Native Client </li></ul><br><p>  Aus offensichtlichen Gründen sind Flash und HTML die einzigen Technologien, die Beachtung verdienen, da der Rest nicht plattformübergreifend kompatibel ist.  Außerdem beginnt der Silverlight-Client zu sterben.  Obwohl ich das Konzept von wirklich mag <del>  Salz </del>  NaCl, leider wird diese Technologie nur vom Chrome-Browser unterstützt und es ist noch nicht bekannt, wann sie von anderen gängigen Browsern unterstützt wird (und jemals unterstützt wird).  <em>Hinweis von 2019: Es wird und der Name ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly</a> .</em> </p><br><p>  Die Wahl fiel auf die trendige und fortschrittliche HTML5-Plattform, deren Funktionalität derzeit von iOS im Gegensatz zu Flash unterstützt wird.  Diese Auswahl basiert auch auf der Tatsache, dass es viele Bibliotheken gibt, mit denen Sie den C # -Code in Javascript kompilieren können.  Sie können zu diesem Zweck auch Visual Studio verwenden.  Details sind unten angegeben. </p><br><h3 id="translating-c-into-javascript">  C # in Javascript übersetzen </h3><br><p>  HTML 5 + JavaScript wurde im vorherigen Abschnitt als Plattform ausgewählt.  Es bleibt also die Frage, ob es möglich ist, einen universellen C # -Code zu schreiben, der sowohl in .NET als auch in JavaScript kompiliert werden kann. </p><br><p>  So wurde eine Reihe von Bibliotheken gefunden, um die Aufgabe zu erfüllen: </p><br><ul><li>  Jsil </li><li>  Sharpkit </li><li>  Skript # </li><li>  Und einige andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> verfügbar. </li></ul><br><p>  Aus diesem Grund wurde beschlossen, <strong>Script #</strong> zu verwenden, da JSIL direkt mit Assemblys arbeitet und weniger reinen Code generiert (obwohl es eine größere Auswahl an C # -Sprachenfunktionen unterstützt). SharpKit ist ein kommerzielles Produkt.  Einen detaillierten Vergleich dieser Tools finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Frage zum Stackoverflow</a> . </p><br><p>  Zusammenfassend hat ScriptSharp im Vergleich zu manuell geschriebenem JavaScript die folgenden Vor- und Nachteile: </p><br><h4 id="advantages">  Vorteile </h4><br><ul><li>  Möglichkeit, einen universellen C # -Code zu schreiben, der in .NET und andere Plattformen (WinPhone, Mono) kompiliert werden kann </li><li>  Entwicklung in einer stark typisierten C # -Sprache, die OOP unterstützt </li><li>  Unterstützung für IDE-Funktionen (Autocompletion und Refactoring) </li><li>  Fähigkeit, die meisten Fehler in der Kompilierungsphase zu erkennen </li></ul><br><h4 id="disadvantages">  Nachteile </h4><br><ul><li>  Redundanz und Unregelmäßigkeit des generierten JavaScript-Codes (aufgrund von mscorlib). </li><li>  Unterstützung nur für ISO-2 (keine Funktionsüberladung oder Typ-, Erweiterungs- und generische Inferenz) </li></ul><br><h3 id="structure">  Struktur </h3><br><p>  Das Kompilieren desselben C # -Codes in .NET und Javascript kann durch das folgende Schema veranschaulicht werden: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/8ba/bce/32c/8babce32c532d3b3954cdabebabb0e06.png" width="70%" alt="C # -Übersetzung in .NET &amp; JavaScript-Schema"></div><br><p>  Obwohl .NET und HTML5 völlig unterschiedliche Technologien sind, haben sie auch ähnliche Funktionen.  Dies gilt auch für die Arbeit mit Grafiken.  Zum Beispiel unterstützt .NET <strong>Bitmap</strong> , JavaScript unterstützt das analoge <strong>Canvas</strong> .  Gleiches gilt für <strong>Grafiken</strong> , <strong>Kontext</strong> und Arrays von Pixeln.  Um alles in einem Code zu kombinieren, wurde beschlossen, die folgende Architektur zu entwickeln: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/89c/427/74c/89c42774cf90bdc873a0c34619cf7207.png" width="50%" alt="Allgemeiner .NET- und JavaScript-Grafikkontext"></div><br><p>  Natürlich ist es nicht auf zwei Plattformen beschränkt.  Im Anschluss ist geplant, Unterstützung für WinPhone und dann möglicherweise für Android und iOS hinzuzufügen. </p><br><p>  Es ist zu beachten, dass es zwei Arten von Grafikoperationen gibt: </p><br><ul><li>  <strong>Verwenden von API-Funktionen</strong> ( <code>DrawImage</code> , <code>Arc</code> , <code>MoveTo</code> , <code>LineTo</code> ).  Hohe Leistung und Unterstützung für die Hardwarebeschleunigung sind wichtige Wettbewerbsvorteile.  Der Nachteil ist, dass sie auf verschiedenen Plattformen unterschiedlich implementiert werden können. </li><li>  <strong>Pixel für Pixel.</strong>  Die Unterstützung der Implementierung von Effekten und die plattformübergreifende Abdeckung gehören zu den Vorteilen.  Der Nachteil ist die geringe Leistung.  Sie können die Nachteile jedoch durch Parallelisierung, Shader und vorberechnete Tabellen verringern (wir werden dies im nächsten Abschnitt zur Optimierung weiter erläutern). </li></ul><br><p>  Wie Sie sehen können, beschreibt die abstrakte Klasse <strong>Grafik</strong> alle Methoden zum Arbeiten mit Grafiken.  Diese Methoden sind für verschiedene Plattformen in der abgeleiteten Klasse implementiert.  Die folgenden Aliase wurden auch als Zusammenfassung von Bitmap- und Canvas-Klassen geschrieben.  Die WinPhone-Version verwendet auch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adaptermuster</a> . </p><br><h4 id="using-alias">  Alias ​​verwenden </h4><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP using System.Html; using System.Html.Media.Graphics; using System.Runtime.CompilerServices; using Bitmap = System.Html.CanvasElement; using Graphics = System.Html.Media.Graphics.CanvasContext2D; using ImageData = System.Html.Media.Graphics.ImageData; using Image = System.Html.ImageElement; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using Bitmap = System.Drawing.Bitmap; using Graphics = System.Drawing.Graphics; using ImageData = System.Drawing.Imaging.BitmapData; using Image = System.Drawing.Bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Leider ist es unmöglich, Aliase für unsichere Typen und Arrays zu erstellen, dh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alias ​​für Zeiger (Byte *) in C #</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]</code> </pre> <br><p>  Um eine schnelle Verarbeitung von Pixeln mit nicht verwaltetem C # -Code durchzuführen und ihn gleichzeitig in Script # zu kompilieren, haben wir mithilfe von Anweisungen das folgende Schema eingeführt: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP PixelArray data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET byte* data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Das Datenarray wird anschließend verwendet, um verschiedene Pixel-für-Pixel-Operationen (wie Maskierung, Fischaugen, Sättigungsanpassung usw.) sowohl parallelisiert als auch nicht parallelisiert zu implementieren. </p><br><h4 id="links-to-files">  Links zu Dateien </h4><br><p>  Der Lösung wird für jede Plattform ein separates Projekt hinzugefügt, aber natürlich können Mono, Script # und sogar Silverlight nicht auf die üblichen .NET-Assemblys verweisen.  Glücklicherweise verfügt Visual Studio über einen Mechanismus zum Hinzufügen von Links zu Dateien, mit dem Sie denselben Code in verschiedenen Projekten wiederverwenden können. </p><br><p>  Compiler-Direktiven ( <code>DOTNET</code> , <code>SCRIPTSHARP</code> ) werden in den Projekteigenschaften unter Bedingte Kompilierungssymbole definiert. </p><br><h3 id="notes-on-net-implementation">  Hinweise zur .NET-Implementierung </h3><br><p>  Die obigen Abstraktionen und Aliase haben uns geholfen, den C # -Code mit geringer Redundanz zu schreiben.  Außerdem möchte ich auf die Probleme mit .NET- und JavaScript-Plattformen hinweisen, mit denen wir bei der Entwicklung des Lösungscodes konfrontiert waren. </p><br><h4 id="using-dispose">  Verwenden Sie entsorgen </h4><br><p>  Beachten Sie, dass für die Aufnahme einer Instanz einer C # -Klasse, die die <code>IDisposable</code> Schnittstelle implementiert, die <strong><code>Dispose</code></strong> Methode <strong><code>Dispose</code></strong> oder die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Using-Anweisung</a> <code>IDisposable</code> werden muss.  In diesem Projekt sind diese Klassen Bitmap und Kontext.  Was ich oben gesagt habe, ist nicht nur die Theorie, sondern hat auch eine praktische Anwendung: Die Verarbeitung einer großen Anzahl großer Fotos (bis zu 2400 x 2400 dpi) auf ASP.NET Developer Server x86 führte zu einer Ausnahme wegen Speichermangels.  Das Problem wurde behoben, nachdem <code>Dispose</code> an den richtigen Stellen hinzugefügt wurde.  Einige weitere hilfreiche Hinweise zur Bildmanipulation finden Sie im folgenden Artikel. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">20 Fallstricke</a> bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Größenänderung von Bildern</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET-Speicherverlust:</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entsorgen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oder nicht entsorgen, das ist die 1-GB-Frage</a> . </p><br><h4 id="using-lock">  Schloss verwenden </h4><br><p>  In JavaScript gibt es einen Unterschied zwischen bereits hochgeladenen Bildern mit dem Tag <code>img</code> , für die Sie die Quelle und das <code>img</code> angeben können, und Canvas-Tags, auf denen Sie etwas zeichnen können.  In .NET werden diese Elemente durch dieselbe <code>Bitmap</code> Klasse dargestellt.  Daher verweisen Aliase Bitmap und Image in .NET auf dieselbe Klasse <code>System.Drawing.Bitmap</code> . Bitmap wie oben gezeigt. </p><br><p>  Trotzdem war diese Aufteilung in <code>img</code> und <code>canvas</code> in JavaScript auch in der .NET-Version sehr hilfreich.  Der Punkt ist, dass Filter vorinstallierte Masken aus verschiedenen Threads verwenden.  Daher ist das Sperrmuster erforderlich, um die Ausnahme während der Synchronisation zu vermeiden (das Bild wird mit der <strong>Sperre</strong> kopiert und das Ergebnis wird ohne Sperre verwendet): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloneImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Image image</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP Bitmap result = (Bitmap)Document.CreateElement("canvas"); result.Width = image.Width; result.Height = image.Height; Graphics context = (Graphics)result.GetContext(Rendering.Render2D); context.DrawImage(image, 0, 0); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Bitmap result; lock (image) result = new Bitmap(image); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><p>  Schließlich sollte die <strong>Sperre</strong> auch beim Zugriff auf die Eigenschaften eines synchronisierten Objekts verwendet werden (tatsächlich sind alle Eigenschaften Methoden). </p><br><h4 id="storing-masks-in-memory">  Speichern von Masken im Speicher </h4><br><p>  Um die Verarbeitung zu beschleunigen, werden beim Starten des Servers alle potenziell verwendeten Masken für Filter in den Speicher geladen.  Unabhängig vom Format der Maske verwendet die auf den Server hochgeladene Bitmap <code>4 * 2400 * 2400</code> oder <code>≈24 MB</code> Speicher (die maximale Bildgröße beträgt <code>2400 * 2400</code> ; die Anzahl der Bytes pro Pixel beträgt 4).  Alle Masken für Filter (≈30) und Collagen (40) verbrauchen 1,5 GB - das ist für den Server nicht viel;  Mit zunehmender Anzahl von Masken kann sich diese Menge jedoch erheblich erhöhen.  In Zukunft werden wir möglicherweise Komprimierungstechniken für im Speicher gespeicherte Masken (in den Formaten .jpg und .png) verwenden, gefolgt von einer Dekomprimierung, falls erforderlich.  Tatsächlich kann die Größe bis zu 300-mal reduziert werden.  Ein zusätzlicher Vorteil dieses Ansatzes besteht darin, dass das Kopieren der komprimierten Bilder im Vergleich zu großen Bildern schneller erfolgt.  <strong>Daher</strong> dauert der Sperrvorgang weniger lange und Threads werden seltener blockiert. </p><br><h3 id="notes-on-javascript-implementation">  Hinweise zur JavaScript-Implementierung </h3><br><h4 id="minification">  Minimierung </h4><br><p>  Ich habe mich aus folgendem Grund geweigert, den Begriff "Verschleierung" zu verwenden: Dieser Begriff ist kaum auf eine vollständig Open-Source-Sprache anwendbar, in unserem Fall JavaScript.  Die Anonymisierung von Bezeichnern kann jedoch die Lesbarkeit und Logik des Codes beeinträchtigen.  Und am wichtigsten ist, dass diese Technik die Größe des Skripts erheblich reduziert (die komprimierte Version ist ca. 80 KB groß). </p><br><p>  Es gibt zwei Ansätze zur JavaScript-Minimierung: </p><br><ul><li>  <strong>Manuelle Minimierung,</strong> die in der Generierungsphase mit ScriptSharp durchgeführt wird. </li><li>  <strong>Automatisierte Minimierung,</strong> die nach der Generierungsphase mit externen Tools wie Google Closure Compiler, Yui und anderen Tools durchgeführt wird. </li></ul><br><h5 id="manual-minification">  Manuelle Minimierung </h5><br><p>  Um die Namen von Methoden, Klassen und Attributen zu verkürzen, haben wir diese Syntax vor der Deklaration der oben genannten Entitäten verwendet.  Dies ist natürlich nicht erforderlich, wenn Sie mit Methoden arbeiten, die von externen Skripten und Klassen (öffentlich) aufgerufen werden. </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP &amp;&amp; !DEBUG [ScriptName("a0")] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Auf jeden Fall konnten lokale Variablen nicht minimiert werden.  Diese Konstrukte verschmutzen den Code und beeinträchtigen die Lesbarkeit des Codes, was ebenfalls ein schwerwiegender Nachteil ist.  Diese Technik kann jedoch die Menge des generierten JavaScript-Codes erheblich reduzieren und ihn ebenfalls durcheinander bringen. </p><br><p>  Ein weiterer Nachteil ist, dass Sie solche Kurznamen im Auge behalten müssen, wenn sie die Methoden- und Feldnamen umbenennen (insbesondere überschriebene Namen in den untergeordneten Klassen), da sich Script # in diesem Fall nicht um sich wiederholende Namen kümmert.  Es werden jedoch keine doppelten Klassen zugelassen. </p><br><p>  Übrigens wurde der entwickelten Version des Skripts # bereits eine Minimierungsfunktion für private und interne Methoden und Felder hinzugefügt. </p><br><h5 id="automated-minification">  Automatisierte Minimierung </h5><br><p>  Obwohl es viele Tools für die JavaScript-Minimierung gibt, habe ich den Google Closure Compiler für seine Marke und die gute Qualität der Komprimierung verwendet.  Der Nachteil des Minifizierungstools von Google besteht darin, dass CSS-Dateien nicht komprimiert werden können.  Im Gegensatz dazu begegnet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YUI</a> dieser Herausforderung erfolgreich.  Tatsächlich kann Script # auch Skripte minimieren, bewältigt diese Herausforderung jedoch viel schlechter als Google Closure. </p><br><p>  Das Minifizierungstool von Google verfügt über mehrere Komprimierungsstufen: Leerzeichen, einfache und erweiterte Funktionen.  Wir haben für das Projekt die Stufe "Einfach" gewählt.  Die erweiterte Stufe ermöglicht es uns zwar, die maximale Qualität der Komprimierung zu erreichen, erfordert jedoch Code, der so geschrieben ist, dass Methoden von außerhalb der Klasse zugänglich sind.  Diese Minimierung wurde teilweise manuell mit Script # durchgeführt. </p><br><h4 id="debug-and-release-modes">  Debug- und Release-Modi </h4><br><p>  Debug- und Release-Bibliotheken wurden wie folgt zu ASP.NET-Seiten hinzugefügt: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Gfranq.JavaScriptFilters.HtmlHelper.IsDebug</span></span></span><span class="hljs-tag">) { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span><span class="hljs-tag"> { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } %&gt;</span></span></code> </pre> <br><p>  In diesem Projekt haben wir sowohl Skripte als auch Filterbeschreibungsdateien minimiert. </p><br><h4 id="crossorigin-property">  crossOrigin-Eigenschaft </h4><br><p>  Um auf die Pixel eines bestimmten Bildes zugreifen zu können, müssen wir es zuerst in Leinwand konvertieren.  Dies kann jedoch zu einem CORS-Fehler (Cross Origin Request Security) führen.  In unserem Fall wurde das Problem wie folgt gelöst: </p><br><ul><li>  Festlegen des Attributs <code>crossOrigin = ''</code> auf der Serverseite. </li><li>  Hinzufügen eines bestimmten Headers zum HTTP-Paket auf der Serverseite. </li></ul><br><p>  Da ScriptSharp diese Eigenschaft für img-Elemente nicht unterstützt, wurde der folgende Code geschrieben: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Imported</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AdvImage</span></span> { [IntrinsicProperty] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CrossOrigin { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { } } }</code> </pre> <br><p>  Dann werden wir es so verwenden: </p><br><pre> <code class="plaintext hljs">((AdvImage)(object)result).CrossOrigin = "";</code> </pre> <br><p>  Mit dieser Technik können Sie dem Objekt jede Funktion ohne Kompilierungsfehler hinzufügen.  Insbesondere ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>wheelDelta</code> Eigenschaft</a> in ScriptSharp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noch nicht implementiert</a> (zumindest in Version 0.7.5).  Diese Eigenschaft gibt den Scrollradbetrag an, der zum Erstellen von Collagen verwendet wird.  Deshalb wurde es so implementiert.  Solch ein schmutziger Hack mit den Eigenschaften ist nicht gut;  Normalerweise müssen Sie Änderungen am Projekt vornehmen.  Aber nur zur Veranschaulichung, ich habe noch keinen Weg gefunden, ScriptSharp aus dem Quellcode zu kompilieren. </p><br><p>  Für solche Images muss der Server die folgenden Header in seinen Antwortheadern (in Global.asax) zurückgeben: </p><br><pre> <code class="cs hljs">Response.AppendHeader(<span class="hljs-string"><span class="hljs-string">"Access-Control-Allow-Origin"</span></span>, <span class="hljs-string"><span class="hljs-string">"\*"</span></span>);</code> </pre> <br><p>  Weitere Informationen zur Cross Origin Request Security finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://enable-cors.org/</a> . </p><br><h3 id="optimizations">  Optimierungen </h3><br><h4 id="using-the-precalculated-values">  Verwenden der vorberechneten Werte </h4><br><p>  Wir haben die Optimierung für einige Operationen wie die Anpassung von Helligkeit, Kontrast und Farbkurven über die vorläufige Berechnung der resultierenden Farbkomponenten (r, g, b) für alle möglichen Werte und die weitere Verwendung der erhaltenen Arrays verwendet, um die Farben von Pixeln direkt zu ändern .  Es ist zu beachten, dass diese Art der Optimierung nur für Operationen geeignet ist, bei denen die Farbe des resultierenden Pixels nicht durch benachbarte Pixel beeinflusst wird. </p><br><p>  Die Berechnung der resultierenden Farbkomponenten für alle möglichen Werte: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { r[i] = ActionFuncR(i); g[i] = ActionFuncG(i); b[i] = ActionFuncB(i); }</code> </pre> <br><p>  Verwendung vorberechneter Farbkomponenten: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { data[i] = r[data[i]]; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = g[data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]]; data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = b[data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]]; }</code> </pre> <br><p>  Wenn solche Tabellenoperationen einzeln ausgeführt werden, müssen keine Zwischenbilder berechnet werden. Sie können nur die Farbkomponenten-Arrays übergeben.  Da der Code sowohl auf Client- als auch auf Serverseite ziemlich schnell funktionierte, wurde beschlossen, die Implementierung dieser Optimierung beiseite zu legen.  Darüber hinaus verursachte die Optimierung unerwünschtes Verhalten.  Ich werde Ihnen jedoch eine Auflistung der Optimierung geben: </p><br><table><tbody><tr><td>  Originalcode </td><td>  Optimierter Code </td></tr><tr><td>  `` `cs <br>  // Berechnung der Werte für die erste Tabelle. <br>  für (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  }} <br>  // ... <br><br>  // Berechnung des resultierenden Zwischenbildes. <br>  für (int i = 0; i &lt;Datenlänge; i + = 4) <br>  { <br>  Daten [i] = r [Daten [i]]; <br>  Daten [i + 1] = g [Daten [i + 1]]; <br>  Daten [i + 2] = b [Daten [i + 2]]; <br>  }} <br>  // ... <br><br>  // Berechnung der Werte für die zweite Tabelle. <br>  für (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc2R (i); <br>  g [i] = ActionFunc2G (i); <br>  b [i] = ActionFunc2B (i); <br>  }} <br>  // ... <br><br>  // Berechnung des resultierenden Bildes. <br>  für (int i = 0; i &lt;Datenlänge; i + = 4) <br>  { <br>  Daten [i] = r [Daten [i]]; <br>  Daten [i + 1] = g [Daten [i + 1]]; <br>  Daten [i + 2] = b [Daten [i + 2]]; <br>  }} <br>  `` `` <br><br></td><td>  `` `cs <br>  // Berechnung der Werte für die erste Tabelle. <br>  für (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  }} <br>  // ... <br><br>  // Berechnung der Werte für die zweite Tabelle. <br>  tr = r.Clone (); <br>  tg = g.Clone (); <br>  tb = b.Clone (); <br>  für (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = tr [ActionFunc2R (i)]; <br>  g [i] = tg [ActionFunc2G (i)]; <br>  b [i] = tb [ActionFunc2B (i)]; <br>  }} <br>  // ... <br><br>  // Berechnung des resultierenden Bildes. <br>  für (int i = 0; i &lt;Datenlänge; i + = 4) <br>  { <br>  Daten [i] = r [Daten [i]]; <br>  Daten [i + 1] = g [Daten [i + 1]]; <br>  Daten [i + 2] = b [Daten [i + 2]]; <br>  }} <br>  `` `` <br><br></td></tr></tbody></table><br><p>  Aber auch das ist noch nicht alles.  Wenn Sie sich die Tabelle rechts ansehen, werden Sie feststellen, dass neue Arrays mit der <code>Clone</code> Methode erstellt werden.  Tatsächlich können Sie einfach die Zeiger auf das alte und das neue Array ändern, anstatt das Array selbst zu kopieren (dies erinnert an die Analogie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doppelten Pufferung</a> ). </p><br><h4 id="converting-an-image-to-an-array-of-pixels">  Konvertieren eines Bildes in ein Array von Pixeln </h4><br><p>  Der JavaScript-Profiler in Google Chrome hat ergeben, dass die Funktion <code>GetImageData</code> (mit der die <code>GetImageData</code> das <code>GetImageData</code> konvertiert wird) lange genug ausgeführt wird.  Diese Informationen finden Sie übrigens in verschiedenen Artikeln zur Canvas-Optimierung in JavaScript. </p><br><p>  Die Anzahl der Aufrufe dieser Funktion kann jedoch minimiert werden.  Wir können nämlich das gleiche Array von Pixeln für Pixel-für-Pixel-Operationen verwenden, analog zur vorherigen Optimierung. </p><br><h2 id="code-examples">  Codebeispiele </h2><br><p>  In den folgenden Beispielen werde ich die Codefragmente bereitstellen, die ich interessant und nützlich fand.  Damit der Artikel nicht zu lang wird, habe ich die Beispiele unter einem Spoiler versteckt. </p><br><h3 id="general">  Allgemein </h3><br><h4 id="detecting-whether-a-string-is-a-number">  Erkennen, ob eine Zeichenfolge eine Zahl ist </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNumeric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !SCRIPTSHARP return ((Number)int.Parse(n)).ToString() != "NaN"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> double number; return double.TryParse(n, out number); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><h4 id="integer-division">  Ganzzahlige Division </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = n / k; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP result = Math.Floor(n / k); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return result; }</span></span></code> </pre> <br><h4 id="rotating-and-flipping-an-image-using-canvas-and-bitmap">  Drehen und Spiegeln eines Bildes mithilfe von Canvas und Bitmap </h4><br><p>  Bitte beachten Sie, dass in HTML5 Leinwandbilder nur mit Matrizen um 90 und 180 Grad gedreht werden können, während .NET erweiterte Funktionen bietet.  Daher wurde eine geeignete genaue Funktion zum Arbeiten mit Pixeln geschrieben. </p><br><p>  Es ist auch erwähnenswert, dass eine seitliche 90-Grad-Drehung in der .NET-Version möglicherweise falsche Ergebnisse liefert.  Daher müssen Sie nach Verwendung der <code>RotateFlip</code> Funktion eine neue <code>Bitmap</code> <code>RotateFlip</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateFlip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap, RotFlipType rotFlipType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP int t, i4, j4, w, h, c; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipNone) return bitmap; GraphicsContext context; PixelArray data; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; for (int i = 0; i &lt; h; i++) { c = (i + 1) * w * 4 - 4; for (int j = 0; j &lt; w / 2; j++) { i4 = (i * w + j) * 4; j4 = j * 4; t = (int)data[i4]; data[i4] = data[c - j4]; data[c - j4] = t; t = (int)data[i4 + 1]; data[i4 + 1] = data[c - j4 + 1]; data[c - j4 + 1] = t; t = (int)data[i4 + 2]; data[i4 + 2] = data[c - j4 + 2]; data[c - j4 + 2] = t; t = (int)data[i4 + 3]; data[i4 + 3] = data[c - j4 + 3]; data[c - j4 + 3] = t; } } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone || rotFlipType == RotFlipType.Rotate180FlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; c = w * 4 - 4; int dlength4 = data.Length - 4; for (int i = 0; i &lt; data.Length / 4 / 2; i++) { i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone) j4 = i4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> j4 = (Math.Truncate((double)i / w) * w + (w - i % w)) * 4; t = (int)data[j4]; data[j4] = data[dlength4 - i4]; data[dlength4 - i4] = t; t = (int)data[j4 + 1]; data[j4 + 1] = data[dlength4 - i4 + 1]; data[dlength4 - i4 + 1] = t; t = (int)data[j4 + 2]; data[j4 + 2] = data[dlength4 - i4 + 2]; data[dlength4 - i4 + 2] = t; t = (int)data[j4 + 3]; data[j4 + 3] = data[dlength4 - i4 + 3]; data[dlength4 - i4 + 3] = t; } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { Bitmap tempBitmap = PrivateUtils.CreateCloneBitmap(bitmap); GraphicsContext tempContext = GraphicsContext.GetContext(tempBitmap); PixelArray temp = tempContext.GetPixelArray(); t = bitmap.Width; bitmap.Width = bitmap.Height; bitmap.Height = t; context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = tempBitmap.Width; h = tempBitmap.Height; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone || rotFlipType == RotFlipType.Rotate90FlipX) { c = w * h - w; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c - w * (i % h) + t) * 4; //j4 = (w * (h - 1 - i4 % h) + i4 / h) * 4; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone || rotFlipType == RotFlipType.Rotate270FlipX) { c = w - 1; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c + w * (i % h) - t) * 4; // j4 = w * (1 + i4 % h) - i4 / h - 1; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } context.PutImageData(); } return bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET Bitmap result = null; switch (rotFlipType) { case RotFlipType.RotateNoneFlipNone: result = bitmap; break; case RotFlipType.Rotate90FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate90FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate270FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate270FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone); result = bitmap; break; case RotFlipType.RotateNoneFlipX: bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX); result = bitmap; break; case RotFlipType.Rotate90FlipX: bitmap.RotateFlip(RotateFlipType.Rotate90FlipX); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipX: bitmap.RotateFlip(RotateFlipType.Rotate180FlipX); result = bitmap; break; case RotFlipType.Rotate270FlipX: bitmap.RotateFlip(RotateFlipType.Rotate270FlipX); result = new Image(bitmap); bitmap.Dispose(); break; } return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h4 id="synchronous-and-asynchronous-image-loading">  Synchrones und asynchrones Laden von Bildern </h4><br><p>  Beachten Sie, dass wir in der Script # -Version eine andere Funktion <code>CollageImageLoad</code> , die nach dem Laden eines Images aufgerufen wird, während diese Prozesse in der .NET-Version gleichzeitig stattfinden (aus einem Dateisystem oder dem Internet). </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CollageData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> smallMaskPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bigMaskPath, List&lt;CollageDataPart&gt; dataParts</span></span></span><span class="hljs-function">)</span></span> { SmallMaskImagePath = smallMaskPath; BigMaskImagePath = bigMaskPath; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP CurrentMask = PrivateUtils.CreateEmptyImage(); CurrentMask.AddEventListener("load", CollageImageLoad, false); CurrentMask.Src = CurrentMaskImagePath; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> CurrentMask = PrivateUtils.LoadBitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!CurrentMaskImagePath.Contains("http://") &amp;&amp; !CurrentMaskImagePath.Contains("https://")) CurrentMask = Bitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { var request = WebRequest.Create(CurrentMaskImagePath); using (var response = request.GetResponse()) using (var stream = response.GetResponseStream()) CurrentMask = (Bitmap)Bitmap.FromStream(stream); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DataParts = dataParts; }</span></span></code> </pre> </div></div><br><h3 id="script-only">  Nur Skript # </h3><br><h4 id="detecting-the-type-and-version-of-a-browser">  Erkennen des Typs und der Version eines Browsers </h4><br><p>  Diese Funktion wird verwendet, um die Drag &amp; Drop-Funktionen in verschiedenen Browsern zu bestimmen.  Ich habe versucht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modernizr</a> zu verwenden, aber es wurde zurückgegeben, dass Safari und (in meinem Fall eine Win-Version) IE9 es implementieren.  In der Praxis implementieren diese Browser Drag &amp; Drop-Funktionen nicht korrekt. </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BrowserVersion { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { DetectBrowserTypeAndVersion(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _browserVersion; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectBrowserTypeAndVersion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_browserDetected) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> userAgent = Window.Navigator.UserAgent.ToLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"opera"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Opera; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"chrome"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Chrome; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"safari"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Safari; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"firefox"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Firefox; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numberIndex = userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; _browser = BrowserType.IE; _browserVersion = userAgent.Substring(numberIndex, userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">';'</span></span>, numberIndex)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _browser = BrowserType.Unknown; _browserDetected = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> </div></div><br><h4 id="rendering-a-dash-dot-line">  Rendern einer Strichpunktlinie </h4><br><p>  Dieser Code wird für ein Rechteck zum Zuschneiden von Bildern verwendet.  Vielen Dank für die Ideen an alle, die diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frage zu stackoverflow beantwortet haben</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawDahsedLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GraphicsContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dashArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashArray == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) dashArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashCount = dashArray.Length; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = x2 - x1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dy = y2 - y1; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> xSlope = Math.Abs(dx) &gt; Math.Abs(dy); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> slope = xSlope ? dy / dx : dx / dy; context.MoveTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> distRemaining = Math.Sqrt(dx * dx + dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (distRemaining &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashLength = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Min(distRemaining, dashArray[dashIndex % dashCount]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> step = Math.Sqrt(dashLength * dashLength / (<span class="hljs-number"><span class="hljs-number">1</span></span> + slope * slope)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xSlope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += step; y1 += slope * step; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dy &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += slope * step; y1 += step; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashIndex % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) context.LineTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> context.MoveTo(x1, y1); distRemaining -= dashLength; dashIndex++; } }</code> </pre> </div></div><br><h4 id="rotation-animation">  Rotationsanimation </h4><br><p>  <code>setInterval</code> Funktion <code>setInterval</code> wird verwendet, um eine Bildrotationsanimation zu implementieren.  Beachten Sie, dass das Ergebnisbild während der Animation so berechnet wird, dass am Ende der Animation keine Verzögerungen auftreten. </p><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cw</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating &amp;&amp; !_flipping) { _rotating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _cw = cw; RotFlipType oldRotFlipType = _curRotFlipType; _curRotFlipType = RotateRotFlipValue(_curRotFlipType, _cw); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentStep = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stepCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(RotateFlipTimeSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span> / StepTimeTicks); Bitmap result = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _interval = Window.SetInterval(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentStep &lt; stepCount) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> absAngle = GetAngle(oldRotFlipType) + currentStep / stepCount * Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span> * (_cw ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); DrawRotated(absAngle); currentStep++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Window.ClearInterval(_interval); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Draw(result); _rotating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }, StepTimeTicks); result = GetCurrentTransformResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating) Draw(result); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawRotated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotAngle</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Save(); _resultContext._graphics.Translate(_result.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, _result.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.Rotate(-rotAngle); _resultContext._graphics.Translate(-_origin.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -_origin.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.DrawImage(_origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _resultContext.Restore(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Draw2(bitmap, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Width - bitmap.Width) / <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Height - bitmap.Height) / <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> </div></div><br><h2 id="conclusion">  Fazit </h2><br><p>  Dieser Artikel beschreibt, wie die C # -Sprache (Kombination von nicht verwaltetem Code und Kompilierung für JavaScript) verwendet werden kann, um eine wirklich plattformübergreifende Lösung zu erstellen.  Trotz des Fokus auf .NET und JavaScript ist das Kompilieren auf Android, iOS (mit Mono) und Windows Phone auch auf der Grundlage dieses Ansatzes möglich, der natürlich seine Tücken hat.  Der Code ist aufgrund seiner Universalität etwas redundant, beeinträchtigt jedoch nicht die Leistung, da Grafikvorgänge normalerweise erheblich länger dauern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440342/">https://habr.com/ru/post/de440342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440326/index.html">Kundenänderungsmanagement nach ADKAR-Modell</a></li>
<li><a href="../de440328/index.html">Die Wahrscheinlichkeit, ein Match zu gewinnen, mit der bekannten Wahrscheinlichkeit, einen Punkt II zu gewinnen</a></li>
<li><a href="../de440332/index.html">Datenbank in den Wolken: an wen und warum - die Meinung von Data Egret-Spezialisten</a></li>
<li><a href="../de440336/index.html">HTML haben wir verloren</a></li>
<li><a href="../de440338/index.html">So stellen Sie die Verfügbarkeit eines Webdienstes in der Cloud bei einem Ausfall des Rechenzentrums sicher</a></li>
<li><a href="../de440344/index.html">InterNyet - wie das Internet in der Sowjetunion erfunden wurde und warum es nicht funktionierte</a></li>
<li><a href="../de440350/index.html">Flying Bear Tornado 2 - ein neuer Bär ist angekommen</a></li>
<li><a href="../de440354/index.html">Digitale Ereignisse in Moskau vom 18. bis 24. Februar</a></li>
<li><a href="../de440356/index.html">Wie Habr hilft, Träume zu erfüllen und Bälle zu sammeln</a></li>
<li><a href="../de440358/index.html">Habro Selbstmord. Ländliche Disco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>