<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➕ 🖨️ 🌰 5 alasan mengapa Anda harus berhenti menggunakan System.Drawing di ASP.NET 🚚 🏞️ 🙍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel “5 Alasan Anda Harus Berhenti Menggunakan System.Drawing from ASP.NET” . 



 Yah, mer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 alasan mengapa Anda harus berhenti menggunakan System.Drawing di ASP.NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">“5 Alasan Anda Harus Berhenti Menggunakan System.Drawing from ASP.NET”</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="gambar"><br><br>  Yah, mereka berhasil.  Tim corefx akhirnya menyetujui <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">berbagai permintaan</a> dan termasuk System.Drawing dalam .NET Core. <a name="habracut"></a>  (artikel asli bertanggal Juli 2017) <br><br>  Paket <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">System.Drawing.Common</a> yang akan <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">datang</a> akan berisi sebagian besar fungsionalitas System.Drawing System dari .NET Framework dan dimaksudkan untuk digunakan sebagai opsi kompatibilitas bagi mereka yang ingin bermigrasi ke .NET Core tetapi tidak dapat melakukan ini karena ketergantungan.  Dari perspektif ini, Microsoft melakukan hal yang benar.  Gesekan perlu dikurangi karena adopsi .Net Core adalah tujuan yang lebih berharga. <br><br>  Di sisi lain, System.Drawing adalah salah satu area termiskin dan paling miskin dari .Net Framework dan banyak dari kita berharap bahwa implementasi .NET Core akan berarti lambatnya kematian System.Drawing.  Dan seiring dengan kematian ini harus menjadi kesempatan untuk melakukan sesuatu yang lebih baik. <br><br>  Misalnya, tim Mono membuat pembungkus yang kompatibel dengan .NET untuk pustaka grafis <a href="https://skia.org/" rel="nofollow">Skia</a> lintas platform Google, yang disebut <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp</a> .  Untuk mempermudah instalasi, Nuget telah banyak mendukung perpustakaan asli untuk setiap platform.  Skia adalah fitur lengkap dan kinerjanya melakukan System.Drawing. <br><br>  Tim <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp</a> juga telah melakukan pekerjaan luar biasa dengan mengulangi sebagian besar fungsionalitas System.Drawing, tetapi dengan API terbaik dan implementasi 100% C #.  Mereka masih belum siap untuk eksploitasi produktif, tetapi tampaknya mereka sudah cukup dekat dengan ini.  Peringatan kecil tentang perpustakaan ini, karena kita berbicara tentang penggunaan dalam aplikasi server: sekarang, dalam konfigurasi default, Paralel. Untuk digunakan di dalam untuk mempercepat beberapa operasi, yang berarti bahwa lebih banyak alur kerja dari kumpulan ASP.NET akan digunakan, akhirnya Akibatnya, <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">mengurangi throughput keseluruhan aplikasi</a> .  Saya berharap perilaku ini akan ditinjau sebelum rilis, tetapi bahkan sekarang sudah cukup untuk mengubah satu baris konfigurasi untuk membuatnya lebih cocok untuk digunakan di server. <br><br>  Dalam kasus apa pun, jika Anda menggambar, merencanakan, atau merender teks menjadi gambar dalam aplikasi di server, Anda harus serius mempertimbangkan mengubah System.Drawing apa pun, terlepas dari apakah Anda beralih ke .NET Core atau tidak. <br><br>  Untuk bagian saya, saya telah merakit pipa pemrosesan gambar berkinerja tinggi untuk .NET dan .NET Core, yang memberikan kualitas gambar yang tidak dapat disediakan oleh System.Drawing, dan melakukannya dalam arsitektur yang sangat skalabel yang dirancang khusus untuk digunakan pada server.  Sejauh ini, ini hanya untuk Windows, namun, cross-platform ada dalam rencana.  Jika Anda menggunakan System.Drawing (atau yang lain) untuk mengubah ukuran gambar di server, yang terbaik adalah mempertimbangkan <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> sebagai pengganti. <br><br>  Tetapi sebuah System.Drawing kebangkitan, yang membuat transisi lebih mudah bagi beberapa pengembang, kemungkinan akan membunuh sebagian besar momentum yang diterima proyek-proyek ini, karena pengembang dipaksa untuk mencari alternatif.  Sayangnya dalam ekosistem .NET, perpustakaan dan paket Microsoft akan selalu menang, tidak peduli seberapa unggul alternatifnya. <br><br>  Posting ini merupakan upaya untuk memperbaiki beberapa kesalahan perhitungan System.Drawing dengan harapan bahwa pengembang akan mengeksplorasi alternatif bahkan jika System.Drawing tetap menjadi pilihan. <br><br>  Saya akan mulai dengan <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">disclaimer yang</a> sering dikutip <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">dari</a> dokumentasi System.Drawing.  Penolakan ini telah dimunculkan beberapa kali dalam <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">diskusi tentang Github ketika membahas System.Drawing.Common</a> . <br><blockquote>  "Kelas dengan System. Menggambar namespace tidak didukung untuk digunakan di Windows atau layanan ASP.NET.  Mencoba menggunakan kelas-kelas ini dengan jenis aplikasi ini dapat menyebabkan masalah yang tidak terduga, seperti penurunan kinerja server dan kesalahan runtime. " </blockquote><br>  Seperti banyak dari Anda, saya membaca disclaimer ini sejak lama, dan kemudian saya melewatkannya dan masih menggunakan System.Drawing dalam aplikasi ASP.NET saya.  Mengapa  Karena aku suka bahaya.  Entah itu, atau tidak ada opsi lain yang ditemukan.  Dan tahukah Anda?  Tidak ada hal buruk yang terjadi.  Kemungkinan besar saya seharusnya tidak mengatakan ini, tetapi saya bertaruh bahwa banyak dari Anda telah mengalami hal yang sama.  Jadi mengapa tidak terus menggunakan System.Drawing atau pustaka berdasarkan itu? <br><br><h3>  Alasan # 1: Penjelas GDI </h3><br>  Jika Anda pernah mengalami masalah menggunakan System.Drawing di server, ini kemungkinan besar terjadi.  Jika tidak diuji, maka ini adalah salah satu penyebab yang paling mungkin. <br><br>  System.Drawing untuk sebagian besar adalah pembungkus tipis di sekitar Windows GDI + API.  Banyak objek System.Drawing didukung oleh <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">deskriptor GDI</a> , dan mereka memiliki batas kuantitatif pada sesi prosesor dan pengguna.  Jika ambang ini tercapai, Anda akan mendapatkan pengecualian "Kehabisan memori" dan / atau kesalahan 'generik' GDI +. <br><br>  Masalahnya adalah bahwa dalam. NET, pengumpulan sampah dan penghentian proses dapat menunda pelepasan deskriptor ini pada saat Anda mencapai batas, bahkan di bawah beban ringan.  Jika Anda lupa (atau tidak tahu apa yang Anda butuhkan) untuk memanggil Buang () pada objek yang berisi deskriptor seperti itu, Anda sangat berisiko menemukan kesalahan seperti itu di lingkungan Anda.  Dan seperti kebanyakan bug terkait dengan keterbatasan sumber daya atau kebocoran, kemungkinan besar situasi ini akan berhasil diuji dan menyengat Anda dalam operasi yang produktif.  Tentu, ini akan terjadi ketika aplikasi Anda berada di bawah beban terbesar, sehingga jumlah maksimum pengguna tahu tentang rasa malu Anda. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">Pembatasan prosesor dan sesi pengguna</a> bergantung pada versi sistem operasi, dan batas prosesor disesuaikan.  Tetapi versi tidak masalah, karena  Deskriptor GDI diwakili secara internal oleh tipe data USHORT, sehingga ada batasan ketat 65.536 deskriptor per sesi pengguna, dan bahkan aplikasi yang ditulis dengan baik berisiko mencapai batas ini di bawah beban yang cukup.  Ketika Anda percaya bahwa server yang lebih kuat akan memungkinkan Anda untuk melayani lebih banyak dan lebih banyak pengguna secara paralel pada satu contoh, risiko ini menjadi lebih nyata.  Dan sungguh, siapa yang ingin membuat perangkat lunak dengan batas skalabilitas yang terkenal? <br><br><h3>  Alasan # 2: Konkurensi </h3><br>  GDI + selalu memiliki masalah dengan konkurensi, meskipun banyak dari mereka terkait dengan <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">perubahan arsitektur di Windows7 / Windows Server 2008 R2</a> , Anda masih melihat beberapa di antaranya dalam versi baru.  Yang paling penting adalah <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">penguncian proses yang</a> diatur oleh GDI + selama operasi DrawImage ().  Jika Anda mengubah ukuran gambar di server menggunakan System.Drawing (atau perpustakaan yang membungkusnya), metode DrawImage () mungkin merupakan dasar dari kode ini. <br><br>  Terlebih lagi, ketika melakukan beberapa panggilan ke DrawImage () secara bersamaan, <b>semuanya</b> akan diblokir sampai <b>semuanya</b> dijalankan.  Sekalipun waktu respons bukan masalah bagi Anda (mengapa tidak? Apakah Anda membenci pengguna Anda?) Perlu diingat bahwa sumber daya memori apa pun yang terkait dengan permintaan ini dan semua deskriptor GDI yang dipegang oleh objek yang terkait dengan permintaan ini terkait dengan runtime.  Bahkan, tidak butuh terlalu banyak memuat di server untuk mulai menyebabkan masalah. <br><br>  Tentu saja, ada solusi untuk masalah khusus ini.  Misalnya, beberapa pengembang membuat proses eksternal untuk setiap operasi DrawImage ().  Namun pada kenyataannya, solusi semacam itu hanya menambah kerapuhan ekstra, yang seharusnya tidak Anda lakukan. <br><br><h3>  Alasan # 3: Memori </h3><br>  Pertimbangkan penangan ASP.NET yang menghasilkan bagan.  Dia harus melakukan sesuatu seperti ini: <br><br><ol><li>  Buat bitmap sebagai kanvas </li><li>  Gambarlah beberapa bentuk pada bitmap menggunakan pena dan / atau kuas </li><li>  Gambarlah teks menggunakan satu atau lebih font </li><li>  Simpan bitmap sebagai PNG ke MemoryStream </li></ol><br>  Katakanlah bagan itu mengukur 600 dengan 400 poin.  Ini adalah total 240.000 titik, dikalikan 4 byte untuk sebuah titik untuk format RGBA default, total 960.000 byte untuk bitmap, ditambah sedikit untuk menggambar objek dan buffer penyimpanan.  Biarkan 1MB untuk seluruh permintaan.  Kemungkinan besar Anda tidak akan mendapatkan masalah memori untuk skenario seperti itu, dan jika Anda mengalami sesuatu, maka kemungkinan besar Anda akan memiliki batasan pada jumlah deskriptor, yang saya sebutkan sebelumnya, karena gambar, kuas, pena, dan font memiliki deskriptor sendiri. <br><br>  Masalah sebenarnya datang ketika System.Drawing digunakan untuk tugas-tugas pencitraan.  System.Drawing terutama merupakan pustaka grafis, dan pustaka grafis biasanya dibangun dengan gagasan bahwa semuanya adalah bitmap dalam memori.  Ini bagus ketika Anda memikirkan hal-hal kecil.  Tetapi gambar bisa sangat besar, dan mereka semakin besar setiap hari, karena  kamera dengan banyak megapiksel terus-menerus semakin murah. <br><br>  Jika Anda mengambil pendekatan naif System.Drawing untuk membangun gambar, maka Anda mendapatkan sesuatu seperti ini untuk penangan ukuran: <br><br><ol><li>  Buat bitmap sebagai kanvas untuk gambar tujuan. </li><li>  Muat gambar asli ke dalam bitmap lain. </li><li>  Panggil DrawImage () dengan parameter "sumber gambar" untuk gambar tujuan, menggunakan pengubahan ukuran. </li><li>  Simpan bitmap target dalam format JPEG ke aliran memori. </li></ol><br>  Misalkan gambar target akan menjadi 600x400, seperti pada contoh sebelumnya, sekali lagi kita memiliki 1MB untuk <i>gambar target</i> dan aliran memori.  Tetapi mari kita asumsikan bahwa seseorang mengunggah gambar 24-megapiksel dari DSLR baru mereka yang mewah, maka kita membutuhkan 6000x4000 piksel dengan masing-masing 3 byte untuk masing-masing (72 MB) untuk bitmap sumber yang diterjemahkan dalam format RGB.  Dan kita akan menggunakan resampling HighQualityBicubic dari System.Drawing, karena itu hanya terlihat bagus.  Maka kita perlu memperhitungkan 6000x4000 poin lainnya dengan masing-masing 4 byte, untuk <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">konversi PRGBA yang terjadi di dalam metode yang disebut</a> , menambahkan 96mb tambahan memori yang digunakan.  Secara total, 169mb (!) Diperoleh untuk permintaan untuk mengonversi satu gambar. <br><br>  Sekarang bayangkan Anda memiliki lebih dari satu pengguna melakukan hal-hal seperti itu.  Sekarang ingat bahwa permintaan diblokir sampai semuanya dieksekusi sepenuhnya.  Berapa lama untuk kehabisan memori?  Dan bahkan jika Anda tidak khawatir bahwa Anda akan sepenuhnya menghabiskan semua yang tersedia, ingatlah bahwa ada banyak cara untuk lebih baik menggunakan memori server Anda daripada menahan banyak piksel.  Pertimbangkan efek tekanan memori pada bagian lain dari aplikasi / sistem: <br><br><ol><li>  Cache ASP.NET Dapat Mulai Membilas Item Yang Mahal Untuk Diciptakan </li><li>  Pengumpul sampah akan mulai lebih sering, memperlambat aplikasi </li><li>  Cache kernel IIS atau cache sistem file Windows dapat menghapus elemen yang berguna </li><li>  Kumpulan aplikasi dapat melebihi batas memori dan dapat dimulai kembali </li><li>  Windows dapat mulai menukar memori ke disk, memperlambat seluruh sistem </li></ol><br>  Anda benar-benar tidak menginginkan semua ini? <br><br>  Perpustakaan yang dirancang khusus untuk tugas pemrosesan gambar mendekati masalah ini dengan cara yang sangat berbeda.  Mereka tidak perlu memuat seluruh sumber atau gambar target ke dalam memori.  Jika Anda tidak akan menggambar di atasnya, Anda tidak perlu kanvas / bitmap.  Ini dilakukan lebih seperti ini: <br><br><ol><li>  Buat streaming untuk encoder JPEG dari gambar target </li><li>  Muat satu baris dari gambar asli dan kompres secara horizontal </li><li>  Ulangi sebanyak yang diperlukan untuk membentuk satu baris untuk file target </li><li>  Kompres garis yang dihasilkan secara vertikal </li><li>  Ulangi dari langkah 2 hingga semua baris file sumber diproses. </li></ol><br>  Dengan menggunakan metode ini, gambar yang sama dapat diproses menggunakan total memori 1MB, dan bahkan gambar yang jauh lebih besar akan membutuhkan sedikit peningkatan overhead. <br><br>  Saya tahu hanya satu. NET perpustakaan yang dioptimalkan oleh prinsip ini, dan saya akan memberi Anda petunjuk: ini bukan System.Drawing. <br><br><h3>  Alasan # 4: CPU </h3><br>  Efek samping lain dari System.Drawing menjadi lebih berorientasi grafis daripada berorientasi gambar adalah bahwa DrawImage () cukup tidak efisien dalam hal penggunaan CPU.  Saya membahas hal ini secara terperinci dalam <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">posting sebelumnya</a> , tetapi diskusi ini dapat diringkas oleh fakta-fakta berikut: <br><br><ul><li>  Di System.Drawing, konversi skala HighQualityBicubic hanya berfungsi dengan format PRGBA.  Di hampir semua skenario, ini berarti salinan tambahan dari gambar.  Tidak hanya menggunakan lebih banyak memori tambahan, tetapi juga membakar siklus prosesor untuk mengkonversi dan memproses saluran alfa tambahan. </li><li>  Bahkan setelah gambar dalam format aslinya, konversi skala HighQualityBicubic melakukan sekitar 4 kali lebih banyak perhitungan daripada yang diperlukan untuk mendapatkan hasil konversi yang benar. </li></ul><br>  Fakta-fakta ini menambahkan sejumlah besar siklus CPU yang terbuang.  Dalam lingkungan berawan dengan pembayaran per menit, ini secara langsung berkontribusi pada biaya hosting.  Dan tentu saja, waktu respons Anda akan berkurang. <br><br>  Dan pikirkan fakta bahwa tambahan listrik akan dihabiskan dan panas dihasilkan.  Penggunaan Anda atas System.Drawing untuk tugas pemrosesan gambar secara langsung memengaruhi pemanasan global.  Kamu adalah monster. <br><br><h3>  Alasan # 5: Pemrosesan gambar tampak rumit </h3><br>  Selain kinerja, System. Menggambar dengan berbagai cara mencegah gambar diproses dengan benar.  Menggunakan System.Drawing berarti hidup dengan output yang salah, atau mempelajari segala sesuatu tentang profil ICC, kuantisasi warna, orientasi exif, koreksi, dan banyak hal spesifik lainnya.  Ini adalah lubang kelinci, yang sebagian besar pengembang tidak punya waktu atau keinginan untuk mengeksplorasi. <br><br>  Perpustakaan seperti ImageResizer dan ImageProcessor telah mendapatkan banyak penggemar, mengurus beberapa detail ini, tetapi hati-hati, mereka memiliki System.Drawing di dalam, dan mereka datang bersama dengan semua bagasi yang saya jelaskan secara rinci dalam artikel ini. <br><br><h3>  Alasan bonus: Anda bisa melakukan yang lebih baik </h3><br>  Jika Anda, seperti saya, harus mengenakan kacamata pada suatu saat dalam hidup Anda, Anda mungkin ingat bagaimana ini adalah pertama kalinya Anda memakainya.  Saya pikir saya melihat secara normal, dan jika saya menyipit dengan benar, maka semuanya akan menjadi cukup jelas.  Tapi kemudian saya memakai kacamata ini, dan dunia menjadi jauh lebih rinci daripada yang bisa saya bayangkan. <br><br>  Sistem. Gambarnya hampir sama.  Ini melakukan hal yang benar jika Anda <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">mengisi pengaturan dengan benar</a> , tetapi Anda akan terkejut betapa jauh lebih baik gambar Anda dapat terlihat jika Anda menggunakan utilitas terbaik. <br><br>  Saya hanya akan meninggalkan ini di sini sebagai contoh.  Ini adalah System.Drawing terbaik yang bisa dilakukan dibandingkan dengan pengaturan MagicScaler default.  Mungkin aplikasi Anda akan mendapat manfaat dari mendapatkan poin ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="gambar"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="gambar"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Foto oleh Jakob Owens</a> <br><br>  Lihatlah sekeliling, jelajahi alternatif, dan tolong, atas nama cinta untuk anak kucing, berhenti menggunakan System.Drawing dalam ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482274/">https://habr.com/ru/post/id482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482262/index.html">Cara masuk ke Talend Open Studio</a></li>
<li><a href="../id482264/index.html">Brasil, ilmu hitam, Mortal Kombat, Mars dan 15.000 orang. Hasil tahun Ontiko</a></li>
<li><a href="../id482268/index.html">Struktur masa depan: bola Dyson, mesin bintang dan "bom lubang hitam"</a></li>
<li><a href="../id482270/index.html">Streaming WebRTC di dan sekitar realitas virtual</a></li>
<li><a href="../id482272/index.html">Memilih gudang data untuk Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../id482276/index.html">GOST R 57580. Dari tren hingga otomatisasi yang efisien</a></li>
<li><a href="../id482280/index.html">Bagaimana cosplay dilakukan. Kostum Jas Lanjutan Isaac Clarke dari Dead Space 2</a></li>
<li><a href="../id482282/index.html">Akhir dari era ARMv7 atau sedikit tentang porting game</a></li>
<li><a href="../id482284/index.html">"50 warna coklat" atau "Bagaimana kita bisa sampai ke sini"</a></li>
<li><a href="../id482288/index.html">Hadiah untuk pendengar yang penuh perhatian: buku audio yang disembunyikan di "celah" pada CD Audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>