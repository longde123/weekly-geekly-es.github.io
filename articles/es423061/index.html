<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° üëÇüèø üë©‚Äçüé§ ref locales y devoluciones de ref en C #: dificultades de rendimiento ü§∞ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üèÇüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde el principio, C # admiti√≥ pasar argumentos por valor o por referencia. Pero antes de la versi√≥n 7, el compilador de C # solo admit√≠a una forma d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ref locales y devoluciones de ref en C #: dificultades de rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423061/">  Desde el principio, C # admiti√≥ pasar argumentos por valor o por referencia.  Pero antes de la versi√≥n 7, el compilador de C # solo admit√≠a una forma de devolver un valor de un m√©todo (o propiedad): devoluci√≥n por valor.  En C # 7, la situaci√≥n ha cambiado con la introducci√≥n de dos nuevas caracter√≠sticas: devoluciones de ref y locales de ref.  M√°s informaci√≥n sobre ellos y su desempe√±o, debajo del corte. <br><br><img src="https://habrastorage.org/webt/gi/7e/dd/gi7eddufiqnmiqtmtby4nrkxclw.jpeg"><a name="habracut"></a><br><br><h2>  Razones </h2><br>  Existen muchas diferencias entre las matrices y otras colecciones en t√©rminos de Common Language Runtime.  Desde el principio, CLR admite matrices y se pueden considerar como una funcionalidad integrada.  El entorno CLR y el compilador JIT pueden funcionar con matrices, y tambi√©n tienen una caracter√≠stica m√°s: el indexador de matrices devuelve elementos por referencia y no por valor. <br><br>  Para demostrar esto, tendremos que recurrir al m√©todo prohibido: use el tipo de valor mutable: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Mutable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X =&gt; _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _x++; } } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutability</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ma = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)}; ma[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed! Assert.That(ma[0].X, Is.EqualTo(2)); var ml = new List&lt;Mutable&gt; {new Mutable(1)}; ml[0].IncrementX(); // X hasn't been changed! Assert.That(ml[0].X, Is.EqualTo(1)); }</span></span></code> </pre> <br>  La prueba tendr√° √©xito porque el indexador de matriz es significativamente diferente del indexador de lista. <br><br>  El compilador de C # da una instrucci√≥n especial al indexador de matriz: ldelema, que devuelve un enlace administrado a un elemento de esta matriz.  Esencialmente, un indexador de matriz devuelve un elemento por referencia.  Sin embargo, List no puede comportarse de la misma manera, porque en C # no fue posible * devolver un alias de estado interno.  Por lo tanto, el indexador de Lista devuelve un elemento por valor, es decir, devuelve una copia de este elemento. <br><br>  * Como veremos pronto, el indexador de listas a√∫n no puede devolver un elemento por referencia. <br><br>  Esto significa que ma [0] .IncrementX () llama al m√©todo que modifica el primer elemento de la matriz, mientras que ml [0] .IncrementX () llama al m√©todo que modifica la copia del elemento sin afectar la lista original. <br><br><h2>  Valores devueltos y variables locales de referencia: conceptos b√°sicos </h2><br>  El significado de estas funciones es muy simple: declarar el valor de referencia devuelto le permite devolver el alias de una variable existente, y la variable local de referencia puede almacenar dicho alias. <br><br>  1. Un ejemplo simple: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefLocalsAndRefReturnsBasics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Capture an alias to the first element into a local ref int first = ref array[0]; first = 42; Assert.That(array[0], Is.EqualTo(42)); // Local function that returns the first element by ref ref int GetByRef(int[] a) =&gt; ref a[0]; // Weird syntax: the result of a function call is assignable GetByRef(array) = -1; Assert.That(array[0], Is.EqualTo(-1)); }</span></span></code> </pre> <br>  2. Valores de referencia devueltos y modificador de solo lectura <br><br>  El valor de referencia devuelto puede devolver el alias del campo de instancia y, a partir de la versi√≥n 7.2 de C #, puede devolver el alias sin poder escribir en el objeto correspondiente utilizando el modificador de solo lectura de referencia: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationWentWrong</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Guid _guid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncapsulationWentWrong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-comment"><span class="hljs-comment">// Return an alias to the private field. No encapsulation any more. public ref int X =&gt; ref _x; // Return a readonly alias to the private field. public ref readonly Guid Guid =&gt; ref _guid; } [Test] public void NoEncapsulation() { var instance = new EncapsulationWentWrong(42); instance.X++; Assert.That(instance.X, Is.EqualTo(43)); // Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable // instance.Guid = Guid.Empty; }</span></span></code> </pre> <br><ul><li>  Los m√©todos y propiedades pueden devolver un "alias" del estado interno.  En este caso, el m√©todo de la tarea no debe definirse para la propiedad. </li><li>  La devoluci√≥n por referencia rompe la encapsulaci√≥n, ya que el cliente obtiene el control total sobre el estado interno del objeto. </li><li>  La devoluci√≥n a trav√©s de un enlace de solo lectura evita la copia innecesaria de tipos de valores, al tiempo que no permite que el cliente cambie el estado interno. </li><li>  Los enlaces de solo lectura se pueden usar para tipos de referencia, aunque esto no tiene mucho sentido en casos no est√°ndar. </li></ul><br>  3. Restricciones existentes.  Devolver un alias puede ser peligroso: usar un alias para una variable colocada en la pila despu√©s de que se complete el m√©todo bloquear√° la aplicaci√≥n.  Para que esta funci√≥n sea segura, el compilador de C # aplica varias restricciones: <br><br><ul><li>  No se puede devolver el enlace a la variable local. </li><li>  No se puede devolver una referencia a esto en las estructuras. </li><li>  Puede devolver un enlace a una variable ubicada en el mont√≥n (por ejemplo, a un miembro de la clase). </li><li>  Puede devolver un enlace a los par√°metros de ref / out. </li></ul><br>  Para obtener m√°s informaci√≥n, le recomendamos que consulte la excelente publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Safe to return rules para devoluciones de referencia</a> .  El autor del art√≠culo, Vladimir Sadov, es el creador de la funci√≥n de referencia de retorno para el compilador de C #. <br><br>  Ahora que tenemos una idea general de los valores de referencia devueltos y las variables locales referenciadas, veamos c√≥mo se pueden usar. <br><br><h2>  Uso de valores de referencia devueltos en indexadores </h2><br>  Para probar el impacto de estas funciones en el rendimiento, crearemos una colecci√≥n √∫nica e inmutable llamada NaiveImmutableList &lt;T&gt; y la compararemos con T [] y List para estructuras de diferentes tama√±os (4, 16, 32 y 48). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NaiveImmutableList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T[] _data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] data</span></span></span><span class="hljs-function">)</span></span> =&gt; (_data, _length) = (data, data.Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx] <span class="hljs-comment"><span class="hljs-comment">// R# 2017.3.2 is completely confused with this syntax! // =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]); { get { // Extracting 'throw' statement into a different // method helps the jitter to inline a property access. if ((uint)idx &gt;= (uint)_length) ThrowIndexOutOfRangeException(); return ref _data[idx]; } } private static void ThrowIndexOutOfRangeException() =&gt; throw new IndexOutOfRangeException(); } struct LargeStruct_48 { public int N { get; } private readonly long l1, l2, l3, l4, l5; public LargeStruct_48(int n) : this() =&gt; N = n; } // Other structs like LargeStruct_16, LargeStruct_32 etc</span></span></code> </pre> <br>  Se realiza una prueba de rendimiento para todas las colecciones y suma todos los N valores de propiedad para cada elemento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsCount = <span class="hljs-number"><span class="hljs-number">100</span></span>_000; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LargeStruct_48[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, elementsCount).Select(v =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeStruct_48(v)).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LargeStruct_48[] _array48 = CreateArray_48(); [BenchmarkCategory(<span class="hljs-string"><span class="hljs-string">"BigStruct_48"</span></span>)] [Benchmark(Baseline = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Using elementsCound but not array.Length to force the bounds check // on each iteration. for (int i = 0; i &lt; elementsCount; i++) { result = _array48[i].N; } return result; }</span></span></code> </pre> <br>  Los resultados son los siguientes: <br><br><img src="https://habrastorage.org/webt/2k/5t/6i/2k5t6iq-egji_4h7wp8zgizndws.png"><br><br>  Al parecer, algo est√° mal!  El rendimiento de nuestra colecci√≥n NaiveImmutableList &lt;T&gt; es el mismo que el de la Lista.  Que paso <br><br><h2>  Valores devueltos con modificador de solo lectura: c√≥mo funciona </h2><br>  Como puede ver, el indexador NaiveImmutableList &lt;T&gt; devuelve un enlace de solo lectura utilizando el modificador de solo lectura de referencia.  Esto est√° totalmente justificado, ya que queremos limitar la capacidad de los clientes para cambiar el estado subyacente de una colecci√≥n inmutable.  Sin embargo, las estructuras que utilizamos en la prueba de rendimiento no solo son legibles. <br><br>  Esta prueba nos ayudar√° a comprender el comportamiento b√°sico: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutabilityForNaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ml = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NaiveImmutableList&lt;Mutable&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)); ml[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed, right? Assert.That(ml[0].X, Is.EqualTo(2)); }</span></span></code> </pre> <br>  ¬°La prueba fall√≥!  Pero por que?  Debido a que la estructura de los "enlaces de solo lectura" es similar a la estructura de los modificadores y los campos de solo lectura con respecto a las estructuras: el compilador genera una copia protectora cada vez que se utiliza un elemento de estructura.  Esto significa que ml [0].  todav√≠a crea una copia del primer elemento, pero el indexador no lo hace: la copia se crea en el punto de la llamada. <br><br>  Este comportamiento en realidad tiene sentido.  El compilador de C # admite pasar argumentos por valor, por referencia y por "enlace de solo lectura" utilizando el modificador in (para obtener m√°s informaci√≥n, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El modificador in y las estructuras de solo lectura en C #</a> ("El modificador in y las estructuras de solo lectura en C # ")).  Ahora el compilador admite tres formas diferentes de devolver un valor de un m√©todo: por valor, por referencia y por enlace de solo lectura. <br><br>  Los enlaces de solo lectura son tan similares a los enlaces normales que el compilador usa el mismo InAttribute para distinguir entre sus valores de retorno: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ByReadonlyRef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _n;</code> </pre> <br>  En este caso, el m√©todo ByReadonlyRef compila eficientemente en: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InAttribute</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: IsReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ByReadonlyRef() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._n; }</code> </pre> <br>  La similitud entre el modificador in y el enlace de solo lectura significa que estas funciones no son muy adecuadas para estructuras regulares y pueden causar problemas de rendimiento.  Considere un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BigStruct { <span class="hljs-comment"><span class="hljs-comment">// Other fields public int X { get; } public int Y { get; } } private BigStruct _bigStruct; public ref readonly BigStruct GetBigStructByRef() =&gt; ref _bigStruct; ref readonly var bigStruct = ref GetBigStructByRef(); int result = bigStruct.X + bigStruct.Y;</span></span></code> </pre> <br>  Adem√°s de la sintaxis inusual al declarar una variable para bigStruct, el c√≥digo se ve bien.  El objetivo es claro: BigStruct regresa por referencia por razones de rendimiento.  Desafortunadamente, dado que la estructura de BigStruct se puede escribir, se crea una copia protectora cada vez que se accede al elemento. <br><br><h2>  Uso de valores de referencia devueltos en indexadores.  Intento n√∫mero 2 </h2><br>  Probemos el mismo conjunto de pruebas para estructuras de solo lectura de diferentes tama√±os: <br><br><img src="https://habrastorage.org/webt/8s/u5/je/8su5je3fe_-dhpjlf4f1bpeqoug.png"><br><br>  Ahora los resultados tienen mucho m√°s sentido.  El tiempo de procesamiento sigue aumentando para estructuras grandes, pero esto se espera, ya que el procesamiento de m√°s de 100 mil estructuras m√°s grandes lleva m√°s tiempo.  Pero ahora el tiempo de ejecuci√≥n para NaiveimmutableList &lt;T&gt; est√° muy cerca del tiempo T [] y mucho mejor que en el caso de List. <br><br><h2>  Conclusi√≥n </h2><br><ul><li>  Los valores de referencia devueltos deben manejarse con cuidado porque pueden romper la encapsulaci√≥n. </li><li>  Los valores de referencia devueltos con modificador de solo lectura solo son efectivos para estructuras de solo lectura.  En el caso de estructuras convencionales, pueden ocurrir problemas de rendimiento. </li><li>  Cuando se trabaja con estructuras grabables, los valores de referencia devueltos con el modificador de solo lectura crean una copia protectora cada vez que se usa la variable, lo que puede causar problemas de rendimiento. </li></ul><br>  Los valores de referencia devueltos y las variables locales referenciadas son funciones √∫tiles para los creadores de bibliotecas y los desarrolladores de c√≥digos de infraestructura.  Sin embargo, son muy peligrosos de usar en el c√≥digo de la biblioteca: para usar una colecci√≥n que devuelva elementos de manera efectiva utilizando un enlace de solo lectura, cada usuario de la biblioteca debe recordar: un enlace de solo lectura a una estructura grabable crea una copia protectora "en el punto de la llamada ".  En el mejor de los casos, esto negar√° un posible aumento de la productividad y, en el peor de los casos, provocar√° un grave deterioro si al mismo tiempo se realiza un gran n√∫mero de solicitudes a una variable local de referencia, de solo lectura. <br><br>  Los enlaces de solo lectura de PS aparecer√°n en BCL.  Los m√©todos de referencia de solo lectura para acceder a elementos en colecciones inmutables se presentaron en la siguiente solicitud para incluir los cambios en corefx repo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n de la propuesta de la API de ItemRef</a> ("Propuesta para incluir la API de ItemRef")).  Por lo tanto, es muy importante que todos comprendan las caracter√≠sticas del uso de estas funciones y c√≥mo y cu√°ndo deben aplicarse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423061/">https://habr.com/ru/post/es423061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423051/index.html">La lucha por los recursos, Parte 1: Los fundamentos de los grupos C</a></li>
<li><a href="../es423053/index.html">Estructura y solo lectura: c√≥mo evitar la degradaci√≥n del rendimiento</a></li>
<li><a href="../es423055/index.html">Analistas de Wall Street: "Apple nos hizo comer nuestros sombreros"</a></li>
<li><a href="../es423057/index.html">Python tambi√©n rechaza parcialmente los t√©rminos maestro / esclavo</a></li>
<li><a href="../es423059/index.html">Mejor de lo que dicen: tres elementos esenciales para que el pr√≥ximo MacBook sea una de las mejores computadoras port√°tiles de Apple</a></li>
<li><a href="../es423063/index.html">Epson WorkForce Pro: Cr√≥nicas de c√≥mo una impresi√≥n de oficina de inyecci√≥n de tinta "sac√≥ una manta" de un l√°ser y lo que sucedi√≥ hoy</a></li>
<li><a href="../es423065/index.html">El experto de Positive Technologies descubri√≥ la posibilidad de revelar claves de cifrado en Intel ME</a></li>
<li><a href="../es423067/index.html">Python Developer Tools de Microsoft. Empezando</a></li>
<li><a href="../es423069/index.html">Evento especial de Apple, septiembre de 2018 [archivo de traducci√≥n de texto]</a></li>
<li><a href="../es423071/index.html">No tengo miedo de tu NDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>