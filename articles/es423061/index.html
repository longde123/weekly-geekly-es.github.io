<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💡 👂🏿 👩‍🎤 ref locales y devoluciones de ref en C #: dificultades de rendimiento 🤰 🧑🏿‍🤝‍🧑🏽 🏂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde el principio, C # admitió pasar argumentos por valor o por referencia. Pero antes de la versión 7, el compilador de C # solo admitía una forma d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ref locales y devoluciones de ref en C #: dificultades de rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423061/">  Desde el principio, C # admitió pasar argumentos por valor o por referencia.  Pero antes de la versión 7, el compilador de C # solo admitía una forma de devolver un valor de un método (o propiedad): devolución por valor.  En C # 7, la situación ha cambiado con la introducción de dos nuevas características: devoluciones de ref y locales de ref.  Más información sobre ellos y su desempeño, debajo del corte. <br><br><img src="https://habrastorage.org/webt/gi/7e/dd/gi7eddufiqnmiqtmtby4nrkxclw.jpeg"><a name="habracut"></a><br><br><h2>  Razones </h2><br>  Existen muchas diferencias entre las matrices y otras colecciones en términos de Common Language Runtime.  Desde el principio, CLR admite matrices y se pueden considerar como una funcionalidad integrada.  El entorno CLR y el compilador JIT pueden funcionar con matrices, y también tienen una característica más: el indexador de matrices devuelve elementos por referencia y no por valor. <br><br>  Para demostrar esto, tendremos que recurrir al método prohibido: use el tipo de valor mutable: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Mutable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X =&gt; _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _x++; } } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutability</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ma = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)}; ma[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed! Assert.That(ma[0].X, Is.EqualTo(2)); var ml = new List&lt;Mutable&gt; {new Mutable(1)}; ml[0].IncrementX(); // X hasn't been changed! Assert.That(ml[0].X, Is.EqualTo(1)); }</span></span></code> </pre> <br>  La prueba tendrá éxito porque el indexador de matriz es significativamente diferente del indexador de lista. <br><br>  El compilador de C # da una instrucción especial al indexador de matriz: ldelema, que devuelve un enlace administrado a un elemento de esta matriz.  Esencialmente, un indexador de matriz devuelve un elemento por referencia.  Sin embargo, List no puede comportarse de la misma manera, porque en C # no fue posible * devolver un alias de estado interno.  Por lo tanto, el indexador de Lista devuelve un elemento por valor, es decir, devuelve una copia de este elemento. <br><br>  * Como veremos pronto, el indexador de listas aún no puede devolver un elemento por referencia. <br><br>  Esto significa que ma [0] .IncrementX () llama al método que modifica el primer elemento de la matriz, mientras que ml [0] .IncrementX () llama al método que modifica la copia del elemento sin afectar la lista original. <br><br><h2>  Valores devueltos y variables locales de referencia: conceptos básicos </h2><br>  El significado de estas funciones es muy simple: declarar el valor de referencia devuelto le permite devolver el alias de una variable existente, y la variable local de referencia puede almacenar dicho alias. <br><br>  1. Un ejemplo simple: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefLocalsAndRefReturnsBasics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Capture an alias to the first element into a local ref int first = ref array[0]; first = 42; Assert.That(array[0], Is.EqualTo(42)); // Local function that returns the first element by ref ref int GetByRef(int[] a) =&gt; ref a[0]; // Weird syntax: the result of a function call is assignable GetByRef(array) = -1; Assert.That(array[0], Is.EqualTo(-1)); }</span></span></code> </pre> <br>  2. Valores de referencia devueltos y modificador de solo lectura <br><br>  El valor de referencia devuelto puede devolver el alias del campo de instancia y, a partir de la versión 7.2 de C #, puede devolver el alias sin poder escribir en el objeto correspondiente utilizando el modificador de solo lectura de referencia: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationWentWrong</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Guid _guid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncapsulationWentWrong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-comment"><span class="hljs-comment">// Return an alias to the private field. No encapsulation any more. public ref int X =&gt; ref _x; // Return a readonly alias to the private field. public ref readonly Guid Guid =&gt; ref _guid; } [Test] public void NoEncapsulation() { var instance = new EncapsulationWentWrong(42); instance.X++; Assert.That(instance.X, Is.EqualTo(43)); // Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable // instance.Guid = Guid.Empty; }</span></span></code> </pre> <br><ul><li>  Los métodos y propiedades pueden devolver un "alias" del estado interno.  En este caso, el método de la tarea no debe definirse para la propiedad. </li><li>  La devolución por referencia rompe la encapsulación, ya que el cliente obtiene el control total sobre el estado interno del objeto. </li><li>  La devolución a través de un enlace de solo lectura evita la copia innecesaria de tipos de valores, al tiempo que no permite que el cliente cambie el estado interno. </li><li>  Los enlaces de solo lectura se pueden usar para tipos de referencia, aunque esto no tiene mucho sentido en casos no estándar. </li></ul><br>  3. Restricciones existentes.  Devolver un alias puede ser peligroso: usar un alias para una variable colocada en la pila después de que se complete el método bloqueará la aplicación.  Para que esta función sea segura, el compilador de C # aplica varias restricciones: <br><br><ul><li>  No se puede devolver el enlace a la variable local. </li><li>  No se puede devolver una referencia a esto en las estructuras. </li><li>  Puede devolver un enlace a una variable ubicada en el montón (por ejemplo, a un miembro de la clase). </li><li>  Puede devolver un enlace a los parámetros de ref / out. </li></ul><br>  Para obtener más información, le recomendamos que consulte la excelente publicación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Safe to return rules para devoluciones de referencia</a> .  El autor del artículo, Vladimir Sadov, es el creador de la función de referencia de retorno para el compilador de C #. <br><br>  Ahora que tenemos una idea general de los valores de referencia devueltos y las variables locales referenciadas, veamos cómo se pueden usar. <br><br><h2>  Uso de valores de referencia devueltos en indexadores </h2><br>  Para probar el impacto de estas funciones en el rendimiento, crearemos una colección única e inmutable llamada NaiveImmutableList &lt;T&gt; y la compararemos con T [] y List para estructuras de diferentes tamaños (4, 16, 32 y 48). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NaiveImmutableList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T[] _data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] data</span></span></span><span class="hljs-function">)</span></span> =&gt; (_data, _length) = (data, data.Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx] <span class="hljs-comment"><span class="hljs-comment">// R# 2017.3.2 is completely confused with this syntax! // =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]); { get { // Extracting 'throw' statement into a different // method helps the jitter to inline a property access. if ((uint)idx &gt;= (uint)_length) ThrowIndexOutOfRangeException(); return ref _data[idx]; } } private static void ThrowIndexOutOfRangeException() =&gt; throw new IndexOutOfRangeException(); } struct LargeStruct_48 { public int N { get; } private readonly long l1, l2, l3, l4, l5; public LargeStruct_48(int n) : this() =&gt; N = n; } // Other structs like LargeStruct_16, LargeStruct_32 etc</span></span></code> </pre> <br>  Se realiza una prueba de rendimiento para todas las colecciones y suma todos los N valores de propiedad para cada elemento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsCount = <span class="hljs-number"><span class="hljs-number">100</span></span>_000; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LargeStruct_48[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, elementsCount).Select(v =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeStruct_48(v)).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LargeStruct_48[] _array48 = CreateArray_48(); [BenchmarkCategory(<span class="hljs-string"><span class="hljs-string">"BigStruct_48"</span></span>)] [Benchmark(Baseline = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Using elementsCound but not array.Length to force the bounds check // on each iteration. for (int i = 0; i &lt; elementsCount; i++) { result = _array48[i].N; } return result; }</span></span></code> </pre> <br>  Los resultados son los siguientes: <br><br><img src="https://habrastorage.org/webt/2k/5t/6i/2k5t6iq-egji_4h7wp8zgizndws.png"><br><br>  Al parecer, algo está mal!  El rendimiento de nuestra colección NaiveImmutableList &lt;T&gt; es el mismo que el de la Lista.  Que paso <br><br><h2>  Valores devueltos con modificador de solo lectura: cómo funciona </h2><br>  Como puede ver, el indexador NaiveImmutableList &lt;T&gt; devuelve un enlace de solo lectura utilizando el modificador de solo lectura de referencia.  Esto está totalmente justificado, ya que queremos limitar la capacidad de los clientes para cambiar el estado subyacente de una colección inmutable.  Sin embargo, las estructuras que utilizamos en la prueba de rendimiento no solo son legibles. <br><br>  Esta prueba nos ayudará a comprender el comportamiento básico: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutabilityForNaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ml = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NaiveImmutableList&lt;Mutable&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)); ml[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed, right? Assert.That(ml[0].X, Is.EqualTo(2)); }</span></span></code> </pre> <br>  ¡La prueba falló!  Pero por que?  Debido a que la estructura de los "enlaces de solo lectura" es similar a la estructura de los modificadores y los campos de solo lectura con respecto a las estructuras: el compilador genera una copia protectora cada vez que se utiliza un elemento de estructura.  Esto significa que ml [0].  todavía crea una copia del primer elemento, pero el indexador no lo hace: la copia se crea en el punto de la llamada. <br><br>  Este comportamiento en realidad tiene sentido.  El compilador de C # admite pasar argumentos por valor, por referencia y por "enlace de solo lectura" utilizando el modificador in (para obtener más información, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El modificador in y las estructuras de solo lectura en C #</a> ("El modificador in y las estructuras de solo lectura en C # ")).  Ahora el compilador admite tres formas diferentes de devolver un valor de un método: por valor, por referencia y por enlace de solo lectura. <br><br>  Los enlaces de solo lectura son tan similares a los enlaces normales que el compilador usa el mismo InAttribute para distinguir entre sus valores de retorno: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ByReadonlyRef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _n;</code> </pre> <br>  En este caso, el método ByReadonlyRef compila eficientemente en: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InAttribute</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: IsReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ByReadonlyRef() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._n; }</code> </pre> <br>  La similitud entre el modificador in y el enlace de solo lectura significa que estas funciones no son muy adecuadas para estructuras regulares y pueden causar problemas de rendimiento.  Considere un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BigStruct { <span class="hljs-comment"><span class="hljs-comment">// Other fields public int X { get; } public int Y { get; } } private BigStruct _bigStruct; public ref readonly BigStruct GetBigStructByRef() =&gt; ref _bigStruct; ref readonly var bigStruct = ref GetBigStructByRef(); int result = bigStruct.X + bigStruct.Y;</span></span></code> </pre> <br>  Además de la sintaxis inusual al declarar una variable para bigStruct, el código se ve bien.  El objetivo es claro: BigStruct regresa por referencia por razones de rendimiento.  Desafortunadamente, dado que la estructura de BigStruct se puede escribir, se crea una copia protectora cada vez que se accede al elemento. <br><br><h2>  Uso de valores de referencia devueltos en indexadores.  Intento número 2 </h2><br>  Probemos el mismo conjunto de pruebas para estructuras de solo lectura de diferentes tamaños: <br><br><img src="https://habrastorage.org/webt/8s/u5/je/8su5je3fe_-dhpjlf4f1bpeqoug.png"><br><br>  Ahora los resultados tienen mucho más sentido.  El tiempo de procesamiento sigue aumentando para estructuras grandes, pero esto se espera, ya que el procesamiento de más de 100 mil estructuras más grandes lleva más tiempo.  Pero ahora el tiempo de ejecución para NaiveimmutableList &lt;T&gt; está muy cerca del tiempo T [] y mucho mejor que en el caso de List. <br><br><h2>  Conclusión </h2><br><ul><li>  Los valores de referencia devueltos deben manejarse con cuidado porque pueden romper la encapsulación. </li><li>  Los valores de referencia devueltos con modificador de solo lectura solo son efectivos para estructuras de solo lectura.  En el caso de estructuras convencionales, pueden ocurrir problemas de rendimiento. </li><li>  Cuando se trabaja con estructuras grabables, los valores de referencia devueltos con el modificador de solo lectura crean una copia protectora cada vez que se usa la variable, lo que puede causar problemas de rendimiento. </li></ul><br>  Los valores de referencia devueltos y las variables locales referenciadas son funciones útiles para los creadores de bibliotecas y los desarrolladores de códigos de infraestructura.  Sin embargo, son muy peligrosos de usar en el código de la biblioteca: para usar una colección que devuelva elementos de manera efectiva utilizando un enlace de solo lectura, cada usuario de la biblioteca debe recordar: un enlace de solo lectura a una estructura grabable crea una copia protectora "en el punto de la llamada ".  En el mejor de los casos, esto negará un posible aumento de la productividad y, en el peor de los casos, provocará un grave deterioro si al mismo tiempo se realiza un gran número de solicitudes a una variable local de referencia, de solo lectura. <br><br>  Los enlaces de solo lectura de PS aparecerán en BCL.  Los métodos de referencia de solo lectura para acceder a elementos en colecciones inmutables se presentaron en la siguiente solicitud para incluir los cambios en corefx repo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de la propuesta de la API de ItemRef</a> ("Propuesta para incluir la API de ItemRef")).  Por lo tanto, es muy importante que todos comprendan las características del uso de estas funciones y cómo y cuándo deben aplicarse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423061/">https://habr.com/ru/post/es423061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423051/index.html">La lucha por los recursos, Parte 1: Los fundamentos de los grupos C</a></li>
<li><a href="../es423053/index.html">Estructura y solo lectura: cómo evitar la degradación del rendimiento</a></li>
<li><a href="../es423055/index.html">Analistas de Wall Street: "Apple nos hizo comer nuestros sombreros"</a></li>
<li><a href="../es423057/index.html">Python también rechaza parcialmente los términos maestro / esclavo</a></li>
<li><a href="../es423059/index.html">Mejor de lo que dicen: tres elementos esenciales para que el próximo MacBook sea una de las mejores computadoras portátiles de Apple</a></li>
<li><a href="../es423063/index.html">Epson WorkForce Pro: Crónicas de cómo una impresión de oficina de inyección de tinta "sacó una manta" de un láser y lo que sucedió hoy</a></li>
<li><a href="../es423065/index.html">El experto de Positive Technologies descubrió la posibilidad de revelar claves de cifrado en Intel ME</a></li>
<li><a href="../es423067/index.html">Python Developer Tools de Microsoft. Empezando</a></li>
<li><a href="../es423069/index.html">Evento especial de Apple, septiembre de 2018 [archivo de traducción de texto]</a></li>
<li><a href="../es423071/index.html">No tengo miedo de tu NDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>