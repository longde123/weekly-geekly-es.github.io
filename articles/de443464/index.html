<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ üö≥ ü§æ Vollst√§ndige Anleitung zum Wechseln von Ausdr√ºcken in Java 12 üôáüèø üòÜ üë©üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der gute alte switch seit dem ersten Tag in Java. Wir alle benutzen es und sind daran gew√∂hnt - besonders an seine Macken. (√Ñrgert sich sonst noch jem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vollst√§ndige Anleitung zum Wechseln von Ausdr√ºcken in Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443464/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/lt/a6/pqlta6vh4m5bec2xrtku1smn7em.jpeg"></div><br><p> Der gute alte <code>switch</code> seit dem ersten Tag in Java.  Wir alle benutzen es und sind daran gew√∂hnt - besonders an seine Macken.  (√Ñrgert sich sonst noch jemand √ºber die <code>break</code> ?) Aber jetzt beginnt sich alles zu √§ndern: In Java 12 ist der <strong>Schalter</strong> anstelle eines Operators zu einem Ausdruck geworden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  <strong>Switch kann jetzt</strong> das Ergebnis seiner Arbeit zur√ºckgeben, das einer Variablen zugewiesen werden kann.  Sie k√∂nnen auch die Syntax im Lambda-Stil verwenden, mit der Sie den Durchgang f√ºr alle <code>case</code> entfernen <code>case</code> in denen keine <code>break</code> Anweisung vorhanden ist. </p><br><p>  In diesem Handbuch werde ich Ihnen alles erkl√§ren, was Sie √ºber Switch-Ausdr√ºcke in Java 12 wissen m√ºssen. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-obzor">  Vorschau </h2><br><p>  Gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorl√§ufigen Spezifikation der Sprache</a> werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Switch-Ausdr√ºcke</a> gerade erst in Java 12 implementiert. </p><br><p>  Dies bedeutet, dass dieses Steuerelementkonstrukt in zuk√ºnftigen Versionen der Sprachspezifikation ge√§ndert werden kann. </p><br><p>  Um die neue Version von <code>switch</code> Sie die <code>--enable-preview</code> sowohl w√§hrend des Kompilierens als auch w√§hrend des Programmstarts verwenden (Sie m√ºssen beim Kompilieren auch <code>--release 12</code> - note by the translator). </p><br><p>  Beachten Sie also, dass <strong>switch</strong> als Ausdruck derzeit nicht die endg√ºltige Syntax in Java 12 hat. </p><br><p>  Wenn Sie selbst damit spielen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten,</a> k√∂nnen Sie mein Java X-Demo-Projekt auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github besuchen</a> . </p><br><h2 id="problema-s-operatorami-v-switch">  Problem mit Anweisungen im Schalter </h2><br><p>  Bevor wir zu einem √úberblick √ºber die Innovationen bei <strong>Switch √ºbergehen</strong> , wollen wir kurz eine Situation bewerten.  Nehmen wir an, wir stehen vor einem "schrecklichen" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tern√§ren Boulean</a> und wollen ihn in einen normalen Boulean umwandeln.  Hier ist eine M√∂glichkeit, dies zu tun: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// don't forget to `break` or you're screwed! break; case FALSE: result = false; break; case FILE_NOT_FOUND: // intermediate variable for demo purposes; // wait for it... var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; default: // ... here we go: // can't declare another variable with the same name var ex2 = new IllegalArgumentException("Seriously?!"); throw ex2; }</span></span></code> </pre> <br><p>  Stimmen Sie zu, dass dies sehr unpraktisch ist.  Wie viele andere <strong>Schalteroptionen</strong> in "nature" berechnet das obige Beispiel einfach den Wert einer Variablen und weist ihn zu, aber die Implementierung wird umgangen (das Bezeichnerergebnis deklarieren und sp√§ter verwenden), wiederholt (my <code>break</code> 'und immer das Ergebnis von Copy-Pasta) und fehleranf√§llig (einen anderen Zweig vergessen? Oh!).  Es gibt eindeutig etwas zu verbessern. </p><br><p>  Versuchen wir, diese Probleme zu l√∂sen, indem wir den <strong>Schalter</strong> in einer separaten Methode platzieren: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException(<span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// without default branch, the method wouldn't compile default: throw new IllegalArgumentException("Seriously?!"); } }</span></span></code> </pre> <br><p>  Dies ist viel besser: Es gibt keine Dummy-Variable, es gibt keine <code>break</code> die den Code und die Compiler-Meldungen √ºber das Fehlen von <code>default</code> (auch wenn dies nicht erforderlich ist, wie in diesem Fall). </p><br><p>  Wenn Sie jedoch dar√ºber nachdenken, m√ºssen wir keine Methoden erstellen, um die umst√§ndliche Sprachfunktion zu umgehen.  Und dies auch ohne Ber√ºcksichtigung, dass ein solches Refactoring nicht immer m√∂glich ist.  Nein, wir brauchen eine bessere L√∂sung! </p><br><h2 id="predstavlyaem-switch-vyrazheniya">  Switch-Ausdr√ºcke einf√ºhren! </h2><br><p>  Wie ich am Anfang des Artikels gezeigt habe, k√∂nnen Sie das obige Problem ab Java 12 wie folgt l√∂sen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  Ich denke, das ist ziemlich offensichtlich: Wenn <code>ternartBool</code> <code>TRUE</code> , wird <code>result</code> 'auf <code>true</code> (mit anderen Worten, <code>TRUE</code> wird zu <code>true</code> ).  <code>FALSE</code> wird <code>false</code> . </p><br><p>  Es entstehen sofort zwei Gedanken: </p><br><ul><li>  <code>switch</code> kann ein Ergebnis haben; </li><li>  Was ist mit den Pfeilen? </li></ul><br><p>  Bevor ich mich mit den Details der neuen <strong>Switch-</strong> Funktionen befasse, werde ich zun√§chst auf diese beiden Hauptaspekte eingehen. </p><br><h3 id="vyrazhenie-ili-operator">  Ausdruck oder Aussage </h3><br><p>  Sie werden √ºberrascht sein, dass der <strong>Schalter</strong> jetzt ein Ausdruck ist.  Aber was war er vorher? </p><br><p>  Vor Java 12 war ein <strong>Switch</strong> ein Operator - ein zwingendes Konstrukt, das den Kontrollfluss reguliert. </p><br><p>  Stellen Sie sich die Unterschiede zwischen der alten und der neuen Version von <strong>switch</strong> als den Unterschied zwischen <code>if</code> und dem tern√§ren Operator vor.  Beide √ºberpr√ºfen den logischen Zustand und f√ºhren je nach Ergebnis eine Verzweigung durch. </p><br><p>  Der Unterschied besteht darin, dass der tern√§re Operator ein Ergebnis zur√ºckgibt, <code>if</code> nur der entsprechende Block ausgef√ºhrt wird: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) { result = doThis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = doThat(); } result = condition ? doThis() : doThat();</code> </pre> <br><p>  Das Gleiche gilt f√ºr <strong>switch</strong> : Wenn Sie vor Java 12 den Wert berechnen und das Ergebnis speichern m√∂chten, weisen Sie ihn entweder einer Variablen zu (und <code>break</code> dann ab) oder geben ihn von einer speziell f√ºr die <code>switch</code> erstellten Methode zur√ºck. </p><br><p>  Nun wird der gesamte Ausdruck der <strong>switch-Anweisung</strong> ausgewertet (der entsprechende Zweig wird zur Ausf√ºhrung ausgew√§hlt) und das Ergebnis der Berechnungen kann einer Variablen zugeordnet werden. </p><br><p>  Ein weiterer Unterschied zwischen dem Ausdruck und der Anweisung besteht darin, dass die <strong>switch-Anweisung</strong> , da sie Teil der Anweisung ist, im Gegensatz zur klassischen <strong>switch-Anweisung</strong> mit einem Semikolon enden muss. </p><br><h3 id="strelka-ili-dvoetochie">  Pfeil oder Doppelpunkt </h3><br><p>  Im Einf√ºhrungsbeispiel wurde die neue Syntax im Lambda-Stil mit einem Pfeil zwischen dem Etikett und dem laufenden Teil verwendet.  Es ist wichtig zu verstehen, dass es daf√ºr nicht erforderlich ist, <code>switch</code> als Ausdruck zu verwenden.  Das folgende Beispiel entspricht dem am Anfang des Artikels angegebenen Code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Seriously?!!?"</span></span>); };</code> </pre> <br><p>  Beachten Sie, dass Sie jetzt <code>break</code> mit einem Wert verwenden k√∂nnen!  Dies passt perfekt zu <code>switch</code> alten Stil, die <code>break</code> ohne Bedeutung verwenden.  In welchem ‚Äã‚ÄãFall bedeutet ein Pfeil einen Ausdruck anstelle eines Operators. Warum ist er hier?  Nur Hipster-Syntax? </p><br><p>  In der Vergangenheit markieren Doppelpunktmarkierungen einfach den Einstiegspunkt in den Anweisungsblock.  Ab diesem Punkt beginnt die Ausf√ºhrung des gesamten folgenden Codes, auch wenn ein anderes Label angetroffen wird.  Beim <code>switch</code> wissen wir, dass dies zum n√§chsten <code>case</code> (Durchfall): Das Falletikett bestimmt, wohin der Kontrollfluss springt.  Um es abzuschlie√üen, m√ºssen Sie <code>break</code> oder <code>return</code> . </p><br><p>  Die Verwendung des Pfeils bedeutet wiederum, dass nur der Block rechts davon ausgef√ºhrt wird.  Und kein "scheitern". </p><br><h2 id="podrobnee-ob-evolyucii-switch">  Mehr zur Entwicklung des Schalters </h2><br><h3 id="neskolko-metok-na-case">  Mehrere Tags auf Fall </h3><br><p>  Bisher hat jeder <code>case</code> nur ein Etikett.  Aber jetzt hat sich alles ge√§ndert - ein <code>case</code> kann mehreren Labels entsprechen: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// `default, case FILE_NOT_FOUND -&gt; ...` does not work // (neither does other way around), but that makes // sense because using only `default` suffices default -&gt; "insane"; };</span></span></code> </pre> <br><p>  Das Verhalten sollte offensichtlich sein: <code>TRUE</code> und <code>FALSE</code> f√ºhren zum gleichen Ergebnis - der Ausdruck "sane" wird ausgewertet. </p><br><p>  Dies ist eine ziemlich nette Neuerung, die die mehrfache Verwendung von <code>case</code> ersetzte, als ein Pass-Through-√úbergang zum n√§chsten <code>case</code> implementiert <code>case</code> . </p><br><h3 id="tipy-za-predelami-enum">  Typen au√üerhalb von Enum </h3><br><p>  Alle <code>switch</code> Beispiele in diesem Artikel verwenden <code>enum</code> .  Was ist mit anderen Typen?  Ausdr√ºcke und <code>switch</code> k√∂nnen auch mit <code>String</code> , <code>int</code> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ) <code>short</code> , <code>byte</code> , <code>char</code> und ihren Wrappern funktionieren.  Bisher hat sich hier nichts ge√§ndert, obwohl die Idee, Datentypen wie <code>float</code> und <code>long</code> immer noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">g√ºltig ist</a> (vom zweiten bis zum letzten Absatz). </p><br><h2 id="podrobnee-o-strelke">  Mehr zum Pfeil </h2><br><p>  Schauen wir uns zwei Eigenschaften an, die f√ºr die Pfeilform eines Trenndatensatzes spezifisch sind: </p><br><ul><li>  Fehlen eines End-to-End-√úbergangs zum n√§chsten <code>case</code> ; </li><li>  Bl√∂cke von Operatoren. </li></ul><br><h3 id="otsutstvie-skvoznogo-perehoda-k-sleduyuschemu-case">  Kein Durchgang zum n√§chsten Fall </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgendes</a> sagt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 325</a> dazu: </p><br><blockquote>  Das aktuelle Design der <code>switch</code> in Java ist eng mit Sprachen wie C und C ++ verwandt und unterst√ºtzt standardm√§√üig die End-to-End-Semantik.  Obwohl diese traditionelle Steuermethode h√§ufig zum Schreiben von Code auf niedriger Ebene n√ºtzlich ist (z. B. Parser f√ºr die Bin√§rcodierung), √ºberwiegen die Fehler dieses Ansatzes, da <code>switch</code> in Code h√∂herer Ebene verwendet wird, seine Flexibilit√§t. </blockquote><p>  Ich stimme voll und ganz zu und begr√º√üe die M√∂glichkeit, <strong>switch</strong> ohne Standardverhalten zu verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool was sane"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// in colon-form, if `ternaryBool` is `TRUE` or `FALSE`, // we would see both messages; in arrow-form, only one // branch is executed default -&gt; System.out.println("Bool was insane"); }</span></span></code> </pre> <br><p>  Es ist wichtig zu lernen, dass dies nichts damit zu tun hat, ob Sie <strong>switch</strong> als Ausdruck oder Anweisung verwenden.  Ausschlaggebend ist hier der Pfeil gegen den Doppelpunkt. </p><br><h3 id="bloki-operatorov">  Bedienerbl√∂cke </h3><br><p>  Wie bei Lambdas kann der Pfeil entweder auf einen Operator (wie oben) oder auf einen mit geschweiften Klammern hervorgehobenen Block zeigen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Bool.random()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool true"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// return with `break`, not `return` break true; } case FALSE -&gt; { System.out.println("Bool false"); break false; } case FILE_NOT_FOUND -&gt; { var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; } default -&gt; { var ex = new IllegalArgumentException("Seriously?!"); throw ex; } };</span></span></code> </pre> <br><p>  Bl√∂cke, die f√ºr mehrzeilige Operatoren erstellt werden m√ºssen, haben einen zus√§tzlichen Vorteil (der bei Verwendung eines Doppelpunkts nicht erforderlich ist). Um dieselben Variablennamen in verschiedenen Zweigen zu verwenden, erfordert der <code>switch</code> keine spezielle Verarbeitung. </p><br><p>  Wenn es Ihnen ungew√∂hnlich erschien, Bl√∂cke mit <code>break</code> anstatt <code>return</code> , dann machen Sie sich keine Sorgen - das verwirrte mich auch und schien seltsam.  Aber dann habe ich dar√ºber nachgedacht und bin zu dem Schluss gekommen, dass es sinnvoll ist, da es den alten Stil des <code>switch</code> Konstrukts <code>switch</code> , das <code>break</code> ohne Werte verwendet. </p><br><h2 id="podrobnee-o-vyrazheniyah-switch">  Erfahren Sie mehr √ºber switch-Anweisungen </h2><br><p>  Und zu guter Letzt die Besonderheiten der Verwendung von <code>switch</code> als Ausdruck: </p><br><ul><li>  mehrere Ausdr√ºcke; </li><li>  vorzeitige R√ºckkehr (vorzeitige <code>return</code> ); </li><li>  Abdeckung aller Werte. </li></ul><br><p>  Bitte beachten Sie, dass es keine Rolle spielt, welches Formular verwendet wird! </p><br><h3 id="mnozhestvennye-vyrazheniya">  Mehrere Ausdr√ºcke </h3><br><p>  Schalterausdr√ºcke sind mehrere Ausdr√ºcke.  Dies bedeutet, dass sie keinen eigenen Typ haben, sondern einer von mehreren Typen sein k√∂nnen.  Am h√§ufigsten werden Lambda-Ausdr√ºcke als solche Ausdr√ºcke verwendet: <code>s -&gt; s + " "</code> , kann <code>Function&lt;String, String&gt;</code> , kann aber auch <code>Function&lt;Serializable, Object&gt;</code> oder <code>UnaryOperator&lt;String&gt;</code> . </p><br><p>  Mithilfe von Schalterausdr√ºcken wird ein Typ durch die Interaktion zwischen dem Verwendungsort des <strong>Schalters</strong> und den Typen seiner Zweige bestimmt.  Wenn ein Schalterausdruck einer typisierten Variablen zugewiesen, als Argument √ºbergeben oder anderweitig in einem Kontext verwendet wird, in dem der genaue Typ bekannt ist (dies wird als Zieltyp bezeichnet), m√ºssen alle seine Zweige mit diesem Typ √ºbereinstimmen.  Folgendes haben wir bisher getan: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"insane"</span></span>; };</code> </pre> <br><p>  Infolgedessen wird <code>switch</code> der <code>result</code> vom Typ <code>String</code> zugewiesen.  Daher ist <code>String</code> der Zieltyp, und alle Zweige m√ºssen ein Ergebnis vom Typ <code>String</code> . </p><br><p>  Das gleiche passiert hier: </p><br><pre> <code class="java hljs">Serializable serializableMessage = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that we don't throw the exception! // but it's `Serializable`, so it matches the target type default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  Was wird jetzt passieren? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiler infers super type of `String` and // `IllegalArgumentException` ~&gt; `Serializable` var serializableMessage = switch (bool) { case TRUE, FALSE -&gt; "sane"; // note that we don't throw the exception! default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  (Zur Verwendung des var-Typs lesen Sie in unserem letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">26 Empfehlungen zur Verwendung des var-Typs in Java</a> - Anmerkung des √úbersetzers) </p><br><p>  Wenn der Zieltyp aufgrund der Tatsache, dass wir var verwenden, unbekannt ist, wird der Typ berechnet, indem der spezifischste Supertyp der von den Zweigen erstellten Typen ermittelt wird. </p><br><h3 id="ranniy-vozvrat">  Vorzeitige R√ºckkehr </h3><br><p>  Der Unterschied zwischen dem Ausdruck und der <code>switch</code> hat zur Folge, dass Sie mit <code>return</code> die <code>switch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// `return` is only possible from block case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  ... Sie k√∂nnen <code>return</code> in einem Ausdruck verwenden ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// this does not compile - error: // "return outside of enclosing switch expression" case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  Dies ist sinnvoll, unabh√§ngig davon, ob Sie einen Pfeil oder einen Doppelpunkt verwenden. </p><br><h3 id="pokrytie-vseh-variantov">  Alle Optionen abdecken </h3><br><p>  Wenn Sie <code>switch</code> als Operator verwenden, spielt es keine Rolle, ob alle Optionen abgedeckt sind oder nicht.  Nat√ºrlich k√∂nnen Sie den <code>case</code> versehentlich √ºberspringen und der Code funktioniert nicht richtig, aber der Compiler k√ºmmert sich nicht darum - Sie, Ihre IDE und Ihre Code-Analyse-Tools bleiben damit allein. </p><br><p>  Schalterausdr√ºcke versch√§rfen dieses Problem.  Wohin soll der Schalter gehen, wenn das gew√ºnschte Etikett fehlt?  Die einzige Antwort, die Java geben kann, ist die R√ºckgabe von <code>null</code> f√ºr Referenztypen und eines Standardwerts f√ºr Grundelemente.  Dies w√ºrde viele Fehler im Hauptcode verursachen. </p><br><p>  Um ein solches Ergebnis zu verhindern, kann Ihnen der Compiler helfen.  Bei switch-Anweisungen besteht der Compiler darauf, dass alle m√∂glichen Optionen abgedeckt sind.  Schauen wir uns ein Beispiel an, das zu einem Kompilierungsfehler f√ºhren kann: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compile error: // "the switch expression does not cover all possible input values" boolean result = switch (ternaryBool) { case TRUE -&gt; true; // no case for `FALSE` case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Die folgende L√∂sung ist interessant: Durch Hinzuf√ºgen des <code>default</code> wird der Fehler zwar behoben, dies ist jedoch nicht die einzige L√∂sung. Sie k√∂nnen dennoch <code>case</code> f√ºr <code>FALSE</code> hinzuf√ºgen. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiles without `default` branch because // all cases for `ternaryBool` are covered boolean result = switch (ternaryBool) { case TRUE -&gt; true; case FALSE -&gt; false; case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Ja, der Compiler kann endlich feststellen, ob alle Aufz√§hlungswerte abgedeckt sind (ob alle Optionen ausgesch√∂pft sind) und keine nutzlosen Standardwerte festlegen!  Lassen Sie uns einen Moment in stiller Dankbarkeit sitzen. </p><br><p>  Dies wirft jedoch immer noch eine Frage auf.  Was ist, wenn jemand einen verr√ºckten <strong>Bool</strong> nimmt und in einen Quaternion <strong>Boolean</strong> verwandelt, indem er einen vierten Wert hinzuf√ºgt?  Wenn Sie den switch-Ausdruck f√ºr den erweiterten <strong>Bool</strong> neu kompilieren, wird ein Kompilierungsfehler angezeigt (der Ausdruck ist nicht mehr vollst√§ndig).  Ohne Neukompilierung wird dies zu einem Laufzeitproblem.  Um dieses Problem zu beheben, wechselt der Compiler zum <code>default</code> , der sich wie der bisher verwendete verh√§lt und eine Ausnahme ausl√∂st. </p><br><p>  In Java 12 funktioniert das √úberspannen aller Werte ohne den <code>default</code> nur f√ºr <code>enum</code> . Wenn der <code>switch</code> in zuk√ºnftigen Versionen von Java jedoch leistungsf√§higer wird, kann er auch mit beliebigen Typen arbeiten.  Wenn Fallbezeichnungen nicht nur die Gleichheit √ºberpr√ºfen, sondern auch Vergleiche durchf√ºhren k√∂nnen (z. B. _ &lt;5 -&gt; ...), werden alle Optionen f√ºr numerische Typen abgedeckt. </p><br><h2 id="razmyshlenie">  Denken </h2><br><p>  Wir haben aus dem Artikel gelernt, dass Java 12 einen <code>switch</code> in einen Ausdruck verwandelt und ihm neue Funktionen verleiht: </p><br><ul><li>  jetzt kann ein <code>case</code> mehreren Etiketten entsprechen; </li><li>  Die neue Pfeilform <code>case ‚Ä¶ -&gt; ‚Ä¶</code> folgt der Syntax von Lambda-Ausdr√ºcken: <br><ul><li>  Einzeilige Operatoren oder Bl√∂cke sind zul√§ssig. </li><li>  der √úbergang zum n√§chsten <code>case</code> verhindert; </li></ul></li><li>  Jetzt wird der gesamte Ausdruck als Wert ausgewertet, der dann einer Variablen zugewiesen oder als Teil einer gr√∂√üeren Anweisung √ºbergeben werden kann. </li><li>  Mehrfachausdruck: Wenn der Zieltyp bekannt ist, m√ºssen alle Zweige diesem entsprechen.  Andernfalls wird ein bestimmter Typ definiert, der allen Zweigen entspricht. </li><li>  <code>break</code> kann einen Wert aus einem Block zur√ºckgeben; </li><li>  F√ºr einen <code>switch</code> mit <code>enum</code> √ºberpr√ºft der Compiler den Umfang aller seiner Werte.  Wenn die <code>default</code> fehlt, wird ein Zweig hinzugef√ºgt, der eine Ausnahme ausl√∂st. </li></ul><br><p>  Wohin wird es uns f√ºhren?  Erstens, da dies nicht die endg√ºltige Version von <code>switch</code> , haben Sie immer noch Zeit, Feedback zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amber-</a> Mailingliste zu hinterlassen, wenn Sie mit etwas nicht einverstanden sind. </p><br><p>  Unter der Annahme, dass der <strong>Schalter</strong> unver√§ndert bleibt, wird die Pfeilform meiner Meinung nach zur neuen Standardoption.  Ohne eine durchgehende Passage zum n√§chsten <code>case</code> und mit pr√§zisen Lambda-Ausdr√ºcken (es ist sehr nat√ºrlich, einen Fall und eine Anweisung in einer Zeile zu haben) sieht der <code>switch</code> viel kompakter aus und beeintr√§chtigt die Lesbarkeit des Codes nicht.  Ich bin mir sicher, dass ich nur dann einen Doppelpunkt verwenden werde, wenn ich durch den Durchgang gehen muss. </p><br><p>  Was denken Sie?  Zufrieden mit dem Ergebnis? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443464/">https://habr.com/ru/post/de443464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443452/index.html">Das russische Milit√§r wird ein eigenes geschlossenes Internet schaffen</a></li>
<li><a href="../de443456/index.html">Wir laden Sie f√ºr eine Woche zu Yandex NLP ein</a></li>
<li><a href="../de443458/index.html">6 unterhaltsame Systemfehler beim Betrieb von Kubernetes [und deren L√∂sung]</a></li>
<li><a href="../de443460/index.html">11 Antworten zu Yandex.Directory</a></li>
<li><a href="../de443462/index.html">Hacking-Kameras: Angriffsmethoden, Tools zur Suche nach Sicherheitsl√ºcken und Anti-Tracking</a></li>
<li><a href="../de443466/index.html">Entwicklungsk√∂nig</a></li>
<li><a href="../de443468/index.html">Welche Netzwerk√ºberwachungstools sind in der Version von Gartner f√ºhrend geworden?</a></li>
<li><a href="../de443470/index.html">Die Geschichte des Schreibens am Beispiel eines gro√üen Projekts</a></li>
<li><a href="../de443472/index.html">M√ºssen Sie in die Cloud gehen? 7 Tipps, wie man nichts vermasselt</a></li>
<li><a href="../de443476/index.html">Wie SimCity eine ganze Generation von Stadtplanern inspirierte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>