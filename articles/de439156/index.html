<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏄 👩‍👦‍👦 ♾ t1ha = Fast Positive Hash 🌿 🧑🏽 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fast die schnellste tragbare 64-Bit-Hash-Funktion mit anständiger Qualität. 


 Dies ist eine Übersetzung des Originalartikels von Leonid Yuriev . 
 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Fast Positive Hash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Fast die schnellste tragbare 64-Bit-Hash-Funktion mit anständiger Qualität. </p><br><p> Dies ist eine Übersetzung des Originalartikels von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Anstelle eines Haftungsausschlusses</b> <div class="spoiler_text"><p>  Ich werde die Definition von Hash-Funktionen zusammen mit der detaillierten Auflistung der Eigenschaften und Anforderungen für ihre kryptografische Anwendung weglassen und davon ausgehen, dass der Leser entweder über die erforderlichen Mindestkenntnisse verfügt oder diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nachlesen wird</a> .  Es sollte auch beachtet werden, dass ich im Folgenden über nicht-kryptografische (nicht für die Kryptografie geeignete) Hash-Funktionen sprechen werde, sofern nicht ausdrücklich anders angegeben. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalitäten</b> <div class="spoiler_text"><p>  Hashing wird in vielen Algorithmen verwendet, und fast immer ist die effizienteste (schnelle) Datenverarbeitung erforderlich, zusammen mit einem bestimmten Mindestmaß an Hashing-Qualität.  Hier bedeutet der Begriff „Qualität“ zunächst eine Art „Zufälligkeit“ (Stochastizität) in Bezug auf die Ausgangsdaten.  Etwas seltener werden zusätzliche Anforderungen gestellt, wie z. B. Widerstand gegen absichtliche Kollisionserzeugung oder Irreversibilität. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen langweiliger sein</b> <div class="spoiler_text"><p>  Aus Gründen der Klarheit ist es notwendig, das Konzept der „Qualität“ der Hash-Funktion und den Rest der Anforderungen etwas detaillierter zu definieren: <br>  Basisqualität und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lawineneffekt</a> : Durch Ändern eines oder mehrerer beliebiger Bits in einem beliebigen Satz von Quelldaten ändert sich jedes Bit des Ergebnisses mit einer Wahrscheinlichkeit von ½. </p><br><ul><li>  Irreversibilität oder erster Vorbildwiderstand: Die Unmöglichkeit, die Originaldaten oder einzelnen Bits aus dem Hash-Ergebnis zu erhalten. </li><li>  Widerstand gegen Kollisionen erster Ordnung und / oder Widerstand vor dem zweiten Bild: die Schwierigkeit, den Originaldatensatz zu finden / anzupassen, um ein bestimmtes Ergebnis oder einen Teil davon zu erhalten, auch wenn der ursprüngliche Datensatz bekannt ist. </li><li>  Widerstand gegen Kollisionen zweiter Ordnung: Die Schwierigkeit, zwei verschiedene Datensätze zu finden / anzupassen, die das gleiche Ergebnis oder eine Übereinstimmung eines signifikanten Teils ergeben würden. </li></ul></div></div><br><p>  Ohne lange Zitate der zugrunde liegenden Mathematik kann Folgendes zusammengefasst werden: </p><br><ul><li>  Das Erfüllen aller oben genannten Anforderungen bei gleichzeitiger Gewährleistung einer hohen Leistung ist ein ziemlich schwieriges Problem, dessen Lösung uns eine gute kryptografische Hash-Funktion geben würde.  Aber wir werden das noch nicht tun. </li><li>  Die Bereitstellung der Grundqualität erfordert eine ausreichend große Anzahl von ALU-Operationen.  Einfach ausgedrückt, Qualität geht immer Kompromisse mit der Geschwindigkeit ein. </li><li>  Um ein qualitativ hochwertiges Ergebnis mit einer Bitbreite zu erhalten, die größer als die Bitbreite von ALU-Operationen ist, muss die Anzahl der Mischungen und damit die grundlegenden ALU-Operationen um mehr als das Mehrfache erhöht werden. </li><li>  Im Allgemeinen <em>erfordert das Erstellen einer schnellen Hash-Funktion das Erreichen eines gewichteten Kompromisses zwischen Geschwindigkeit, Qualität und Ergebnisbitness</em> . </li></ul><br><p>  Daher kann ich sagen, dass <strong>t1ha</strong> als Ergebnis der Suche nach einem Kompromiss zwischen Qualität und Geschwindigkeit entstanden ist, wobei gleichzeitig die Fähigkeiten moderner Prozessoren und die bereits gefundenen Methoden (arithmetisch-logische Kombinationen) zum Mischen und Verteilen von Abhängigkeiten berücksichtigt wurden ( Lawineneffekt). </p><br><p>  Die Basisversion von <strong>t1ha</strong> ist eine der schnellsten portablen Hash-Funktionen zum <strong>Erstellen</strong> von Hash-Tabellen und anderen verwandten Anwendungen.  Die Basisversion von <strong>t1ha</strong> konzentriert sich auf 64-Bit-Little-Endian-Architekturen, verwendet einen 64-Bit-Salt-Wert (Seed) und erzeugt ein 64-Bit-Ergebnis, das die Verstärkung durch Schlüssellänge und Seed umfasst.  Es ist erwähnenswert, dass <strong>t1ha</strong> absichtlich so ausgelegt ist, dass es 0 für Null-Eingabedaten <strong>zurückgibt</strong> (ein Schlüssel mit einer Größe von Null und einem <strong>Startwert</strong> von Null). </p><br><div class="spoiler">  <b class="spoiler_title">Beantwortung der beliebtesten Fragen</b> <div class="spoiler_text"><p>  <strong>64-Bit-Operationen</strong> : Vielleicht sollte angemerkt werden, dass es die 64-Bit-Operationen sind, die Geschwindigkeit und Qualität bieten, ohne die Portabilität zu beeinträchtigen.  Je breiter die Ziffernkapazität von Rechenoperationen ist, desto mehr Lawineneffekte erzeugen sie und desto besser mischen sie die Daten.  Darüber hinaus ist die Datenverarbeitung bei sonst gleichen Bedingungen sicherlich um 8 Byte schneller als um 4. Auf der anderen Seite sind auf vielen modernen Prozessoren genau 64-Bit-Operationen nativ verfügbar und können mehr oder weniger angemessen in 32- übersetzt werden. Bit diejenigen.  Alle anderen Optionen, einschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIMD-</a> Vorgängen, zwingen uns, die Portabilität und / oder Geschwindigkeit auf nicht nativen Plattformen stark zu beeinträchtigen. </p><br><p>  <strong>64-Bit-Ergebnis</strong> : Um Hash-Tabellen zu erstellen, reicht in vielen Fällen ein Ergebnis mit geringerer Bitbreite aus.  Sogar 32 Bit können mehr als ausreichend sein.  Bei Verwendung von 64-Bit-Operationen ist das 64-Bit-Ergebnis jedoch natürlich.  Gleichzeitig können Sie mit einem 64-Bit-Hash-Ergebnis von ausreichend hoher Qualität schnell einen Vergleich auf Nichtgleichheit und mit guter Genauigkeit einen Vergleich auf Gleichheit durchführen. </p><br><p>  Die obige "Magie" des Ersetzens von Vergleichen kann unklar und unnötig erscheinen, oder sie kann <strong>die Geschwindigkeit des Hashings</strong> nur durch <strong>Datenlokalität um eine Größenordnung erhöhen</strong> , d. H. Weniger CPU-Cache-Verschmutzung.  Einfach ausgedrückt kann man eine Hash-Tabellenstruktur so erstellen, dass die berechneten Hash-Werte nebeneinander liegen (in Cache-Zeilen gepackt).  Die CPU würde dann nur dann die realen Daten erfassen, wenn die Hashwerte übereinstimmen.  In diesem Fall ermöglichen die <em>64-Bit-Werte von t1ha das bestmögliche Ergebnis</em> .  Davon abgesehen bieten 128 Bit keinen Vorteil mehr, während es immer möglich ist, weniger von 64 Bit zu nehmen. </p><br><p>  <strong>Vergleich mit HighwayHash</strong> : Ich habe gemischte Gefühle in Bezug auf dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inoffizielle Projekt von Google-Mitarbeitern</a> . </p><br><ol><li>  Einerseits hat es guten Code und eine ausgezeichnete technische Implementierung.  Andererseits ist <em>HighwayHash</em> als <em>möglicherweise</em> kryptografisch stark positioniert (mindestens gleich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SipHash</a> ).  In HighwayHash gibt es einige Manipulationen, mit denen wir erwarten können, dass das Ergebnis nicht schlecht wird.  Es gibt jedoch keine Beweise, die es uns erlauben würden, dies zuverlässig zu sagen.  Der vorgelegte Beweis für "Stärke" beruht auf den Ergebnissen statistischer Tests, die jedoch nicht reproduzierbar sind (irgendwann habe ich mir sogar einen etwas überflüssigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar</a> erlaubt). </li><li>  HighwayHash ist nur auf x86_64 mit AVX2 oder SSE41 sehr schnell.  Ist es nicht einfacher, nur die AES-NI- oder SHA-Beschleunigung zu verwenden? </li></ol><br><p>  Wenn alles gut geht, werden der t1ha-Suite zusätzliche Optionen hinzugefügt (hauptsächlich für die Ergebnisbitness) und für E2K optimiert.  Damit möchte ich das Thema Vergleiche mit HighwayHash abschließen. </p></div></div><br><hr><br><h2 id="quality">  Qualität </h2><br><p>  Die Bewertung der Qualität einer Hash-Funktion in allen Aspekten kann sehr schwierig sein.  Dies kann entweder analytisch oder durch Implementierung verschiedener statistischer Tests erfolgen.  Leider ist der analytische Ansatz für die Bewertung von Hash-Funktionen mit einem Kompromiss zwischen Qualität und Geschwindigkeit nicht sehr effektiv.  Darüber hinaus ist eine vergleichende analytische Bewertung solcher Funktionen tendenziell subjektiv. </p><br><p>  Im Gegensatz dazu können statistische Tests klare quantitative Schätzungen liefern.  Für solche Zwecke gibt es bewährte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testpakete</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMHasher</a> .  Für <em>t1ha</em> sind die Ergebnisse einfach - alle <strong>t1ha-Optionen</strong> bestehen alle Tests ohne Kommentare.  Andererseits sollte man nicht davon ausgehen, dass t1ha Eigenschaften aufweist, die über die für die Zielanwendung erforderlichen hinausgehen (Erstellen von Hash-Tabellen). </p><br><p>  Die Anzahl der Kollisionen auf allen Ebenen (Varianten) von <strong>t1ha</strong> entspricht dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geburtstagsparadoxon</a> .  Um es genau zu formulieren: Die Kollisionswahrscheinlichkeit in <strong>t1ha</strong> entspricht der Wahrscheinlichkeit des Zusammentreffens zufälliger diskreter Werte mit entsprechender Bitigkeit. <br>  Eine ähnliche Wahrscheinlichkeit von Kollisionen wird bei allen hochwertigen Hash-Funktionen beobachtet.  Dies ist jedoch nur eine Wahrscheinlichkeit, sodass die tatsächliche Anzahl von Kollisionen für jeden spezifischen Datensatz variieren kann. </p><br><p> Nach der Erstveröffentlichung dieses Artikels stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yves Orton fest</a> , dass das erste <code>t1ha1()</code> nicht immer das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strenge Lawinenkriterium erfüllt</a> .  Dieser Nachteil ist für gezielte Anwendungen von <code>t1ha1()</code> unbedeutend und aus praktischer Sicht nicht <code>t1ha1()</code> .  Dieser Nachteil wird jedoch in der nächsten Stufe / Variante <code>t1ha2()</code> beseitigt, die ursprünglich geplant war, um eine etwas höhere Qualität bereitzustellen.  Auf neuen Prozessoren, die aktuelle Versionen von Compilern verwenden, ist <code>t1ha2()</code> im Durchschnitt einen Zyklus schneller als <code>t1ha1()</code> , und in den übrigen Fällen kann es einen Zyklus langsamer sein.  Es ist erwähnenswert, dass <code>t1ha2()</code> zusätzlich einen Stream-Hashing-Modus und ein 128-Bit-Ergebnis bietet. </p><br><p>  Die Leser würden sich sicherlich über eine gründliche und gründliche Analyse der Qualität und / oder Stärke von <strong>t1ha freuen</strong> .  Basierend auf den Ziel- <strong>t1ha-</strong> Anwendungsbereichen scheint dies jedoch überflüssig zu sein.  Kurz gesagt, Geschwindigkeit war uns wichtiger, auch bei kurzen Tasten.  Daher wurde ein Mehrrundenmischen nicht berücksichtigt.  Die vorliegende <em>t1ha-</em> Version spart Zyklen und liefert ein 64-Bit-Ergebnis - es ist praktisch sinnlos, den gefundenen Kompromiss auf andere Weise als statistisch zu messen, und die Ergebnisse sind einfach gut. </p><br><div class="spoiler">  <b class="spoiler_title">In der Tat</b> <div class="spoiler_text"><p>  Ich bin gerade meinen Kollegen von Google gefolgt, wie sie ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">statistischen Beweise</a> liefern </p></div></div><br><hr><br><h2 id="benchmarks">  Benchmarks </h2><br><p>  In Bezug auf den Anspruch, " <em>der Schnellste</em> " zu sein.  Es ist wichtig zu beachten, dass es offensichtlich nicht wahrscheinlich ist, dass es eine Hash-Funktion gibt, die gleichzeitig nützlich und auf allen Plattformen / Architekturen die schnellste ist.  Verschiedene Prozessoren verfügen über unterschiedliche Befehlssätze und führen ähnliche Befehle mit unterschiedlichen Wirkungsgraden aus.  Offensichtlich kann die " <em>universell schnellste</em> " Funktion höchstwahrscheinlich nicht erstellt werden.  Es scheint jedoch akzeptabel, den Begriff "the <br>  am schnellsten »für eine Funktion, die portabel und gleichzeitig am schnellsten ist, zumindest auf der gängigsten Plattform (x86_64), während die Wahrscheinlichkeit gering ist, auf einem modernen Prozessor mit einem anständigen optimierenden Compiler zu verlieren. </p><br><p>  Der Quellcode des Projekts enthält einen Test, der sowohl die Richtigkeit des Ergebnisses überprüft als auch die Geschwindigkeit jeder implementierten Variante misst.  Gleichzeitig können auf x86 abhängig von den Fähigkeiten des Prozessors (und des Compilers) zusätzliche Funktionsvarianten überprüft und Messungen in Prozessorzyklen durchgeführt werden. </p><br><p>  Darüber hinaus enthält die Projektwebsite Tabellen mit den Ergebnissen von Leistungsmessungen über eine modifizierte Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMHasher von Reini Urban</a> .  Mit einem bestimmten Compiler kann man alle Zahlen überprüfen und / oder Ergebnisse auf einem bestimmten Prozessor erhalten. </p><br><p>  Hier können Sie t1ha mit einigen seiner engsten Konkurrenten vergleichen. </p><br><p>  <strong>Hashing</strong> von Kurztasten (Durchschnitt für 1..31 Bytes). <br>  <em>Schauen Sie sich die rechte Spalte "Cycles / Hash" an (kleiner ist besser)</em> : </p><br><table><thead><tr><th>  Funktion </th><th>  MiB / Sekunde </th><th>  Zyklen / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43.42 </td></tr><tr><td>  CityHash64 </td><td>  11041,72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808,92 </td><td>  46.33 </td></tr></tbody></table><br><p>  <strong>Hashing lange Schlüssel</strong> (256 Kb). <br>  <em>Schauen Sie sich die mittlere Spalte „MiB / Sekunde“ an (größer ist besser)</em> : </p><br><table><thead><tr><th>  Funktion </th><th>  MiB / Sekunde </th><th>  Zyklen / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041,72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Varianten von t1ha </h2><br><p>  Entwicklung von <strong>t1ha</strong> Das erste dieser Ziele bestand darin, eine schnelle tragbare Funktion von ausreichend hoher Qualität für die Erstellung von Hash-Tabellen zu erhalten. </p><br><p>  Dann wollten wir die schnellste Version der Hash-Funktion haben, die ein Ergebnis von vergleichbarer Qualität liefert, aber so weit wie möglich an die Zielplattform angepasst wurde.  Beispielsweise arbeitet die Basisversion von <strong>t1ha</strong> mit einer Little-Endian-Bytereihenfolge, weshalb für Big-Endian-Architekturen mit unvermeidlichem Leistungsverlust eine Konvertierung erforderlich ist.  Warum also nicht unnötige Vorgänge auf einer bestimmten Zielplattform loswerden?  Auf diese Weise wurden mehrere weitere Optionen hinzugefügt: </p><br><ul><li>  Vereinfachte Version für 32-Bit-Plattformen, sowohl für kleine als auch für große Endianer. </li><li>  Variante mit AES-NI-Anleitung, jedoch ohne AVX. </li><li>  Zwei Varianten mit den Anweisungen AES-NI und AVX. </li></ul><br><p>  Später wurde klar, dass mehr Optionen für verschiedene Anwendungen erforderlich sein würden, einschließlich unterschiedlicher Bitbreitenergebnisse, Qualitäts- und Haltbarkeitsanforderungen.  Diese Vielfalt erforderte eine ordnungsgemäße Systematisierung.  Dies wurde erreicht, indem das Namensschema geändert wurde, in dem das numerische Suffix die „Ebene“ der Funktion angibt: </p><br><ul><li>  <code>t1ha0()</code> - ist die schnellste Option für den aktuellen Prozessor. </li><li>  <code>t1ha1()</code> - ist die tragbare 64-Bit-Basisversion von t1ha. </li><li>  <code>t1ha2()</code> - ist eine tragbare 64-Bit-Version mit etwas mehr Bedenken <code>t1ha2()</code> Qualität. </li><li>  <code>t1ha3()</code> - ist eine schnelle tragbare 128-Bit-Version für Fingerabdrücke. </li><li>  usw. </li></ul><br><p>  In diesem Schema wird angenommen, dass <code>t1ha0()</code> ein Dispatcher ist, der die Umleitung abhängig von der Plattform und den Fähigkeiten des aktuellen Prozessors implementiert.  Zusätzlich kann die Verwendung der Suffixe "_le" und "_be" für eine explizite Wahl zwischen der Little-Endian- und der Big-Endian-Variante eingeführt werden.  So gibt es unter dem Schild „t1ha“ jetzt mehrere Hash-Funktionen, und diese Familie wird in Zukunft wachsen, einschließlich einer für das russische E2K „Elbrus“ optimierten Version. </p><br><p>  Eine allgemeine Vorstellung des aktuellen Satzes von Funktionen und ihrer Eigenschaften kann durch Betrachten der eingebauten Testausgabe ( <code>make check</code> ) erfasst werden.  Es ist anzumerken, dass alle Funktionen alle SM Hasher-Tests bestehen und die Leistung der AES-NI-Varianten je nach Prozessormodell stark variiert: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen über die interne Struktur</b> <div class="spoiler_text"><p>  Um ein wenig detaillierter zu werden, wird <strong>t1ha</strong> nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkle-Damgård-Schema</a> („Wipe-Pipe“ -Version) gebaut, wobei die Datengröße und der Startwert verstärkt werden.  Innerhalb der Hauptkomprimierungsschleife wird ein 256-Bit-Status mit derselben Größe des Eingabeblocks verwendet.  Darüber hinaus gibt es für jeden Datenoperanden zwei Injektionspunkte mit Kreuzbestäubung.  Nach Abschluss des Komprimierungszyklus wird der 256-Bit-Zustand auf 128 Bit komprimiert. </p><br><p>  Bei der Ausführung der oben genannten Aktionen werden 64-Bit-Operationen verwendet, die in den Mischern ARX (Add-Rotate-Xor) und MUX / MRX (Mul-Rotate-Xor) kombiniert sind.  Es ist wichtig, dass alle diese Berechnungen so erstellt werden, dass die Möglichkeit der parallelen Ausführung der meisten Vorgänge und des engen Packens von U-Ops sowohl in die Pipeline als auch in x86_64-Ausführungseinheiten gewährleistet ist.  Dadurch wird eine ausreichend gute Qualität mit nahezu maximaler Hash-Rate für lange Schlüssel erreicht. </p><br><p>  Es ist anzumerken, dass die Komprimierungsschleife nur für Blöcke mit ausreichender Größe ausgeführt wird.  Wenn weniger Daten vorhanden sind, besteht der 128-Bit-Zwischenzustand nur aus der Schlüsselgröße und dem Salt-Wert. </p><br><p>  Dann wird das verbleibende Ende der Daten in Teilen von 64 Bit abwechselnd mit den Hälften des 128-Bit-Zustands gemischt.  Schließlich wird der Zustand gemischt und gleichzeitig auf ein 64-Bit-Ergebnis komprimiert.  Ein wichtiges Merkmal von t1ha ist hier die Verwendung eines Mischers, der auf einer breiten Multiplikation basiert (128-Bit-Produkt von zwei 64-Bit-Multiplikatoren).  Dies ermöglicht eine gute Mischqualität mit einem guten Lawineneffekt und weniger Vorgängen.  Obwohl eine breite Multiplikation eine relativ teure Operation ist, ermöglichen weniger solcher Operationen t1ha, kurze Schlüssel in einer rekordarmen Anzahl von Prozessorzyklen zu verarbeiten. </p><br><p>  Es ist zu beachten, dass der Mischer, der auf einer breiten Multiplikation und einem exklusiven ODER basiert, nicht perfekt ist.  Obwohl <em>t1ha</em> alle <em>SMHasher-</em> Tests besteht, versteht der Autor die Konsequenzen der <em>Nichtinjektivität</em> .  Trotzdem scheint die resultierende Qualität rational ausreichend zu sein, und die Entwicklungspläne für die t1ha-Linie spiegeln bereits die Absicht wider, etwas höhere Qualitätsoptionen bereitzustellen. </p></div></div><br><p>  Weitere Informationen und Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  <em>Danke fürs Lesen!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439156/">https://habr.com/ru/post/de439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439142/index.html">Reifegradmodelle entwerfen</a></li>
<li><a href="../de439148/index.html">Arbeiten Sie mit nRF51822 mit ST-Link und Clion + OpenOCD</a></li>
<li><a href="../de439150/index.html">Wer sollte die Transaktionskosten bezahlen?</a></li>
<li><a href="../de439152/index.html">IT-Gehälter in der zweiten Jahreshälfte 2018: Laut Gehaltsrechner "My Circle"</a></li>
<li><a href="../de439154/index.html">Wie Freiberufler leben: Buchumschlagdesign, eigene Rucksackproduktion und Reisen</a></li>
<li><a href="../de439158/index.html">DataArt startet kostenlosen Service zur Verbesserung des Lebenslaufs von Enten</a></li>
<li><a href="../de439160/index.html">Stand des Algorithmus: Was passiert mit Indie-Entwicklern auf Steam?</a></li>
<li><a href="../de439162/index.html">So debuggen Sie Frontend und Backend: Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de439166/index.html">mmWave auf dem Weg zur Kommerzialisierung im Smartphone-Formfaktor</a></li>
<li><a href="../de439168/index.html">Client-Analysesysteme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>