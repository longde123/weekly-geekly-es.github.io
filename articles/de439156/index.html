<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÑ üë©‚Äçüë¶‚Äçüë¶ ‚ôæ t1ha = Fast Positive Hash üåø üßëüèΩ üïµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fast die schnellste tragbare 64-Bit-Hash-Funktion mit anst√§ndiger Qualit√§t. 


 Dies ist eine √úbersetzung des Originalartikels von Leonid Yuriev . 
 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Fast Positive Hash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Fast die schnellste tragbare 64-Bit-Hash-Funktion mit anst√§ndiger Qualit√§t. </p><br><p> Dies ist eine √úbersetzung des Originalartikels von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Anstelle eines Haftungsausschlusses</b> <div class="spoiler_text"><p>  Ich werde die Definition von Hash-Funktionen zusammen mit der detaillierten Auflistung der Eigenschaften und Anforderungen f√ºr ihre kryptografische Anwendung weglassen und davon ausgehen, dass der Leser entweder √ºber die erforderlichen Mindestkenntnisse verf√ºgt oder diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nachlesen wird</a> .  Es sollte auch beachtet werden, dass ich im Folgenden √ºber nicht-kryptografische (nicht f√ºr die Kryptografie geeignete) Hash-Funktionen sprechen werde, sofern nicht ausdr√ºcklich anders angegeben. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalit√§ten</b> <div class="spoiler_text"><p>  Hashing wird in vielen Algorithmen verwendet, und fast immer ist die effizienteste (schnelle) Datenverarbeitung erforderlich, zusammen mit einem bestimmten Mindestma√ü an Hashing-Qualit√§t.  Hier bedeutet der Begriff ‚ÄûQualit√§t‚Äú zun√§chst eine Art ‚ÄûZuf√§lligkeit‚Äú (Stochastizit√§t) in Bezug auf die Ausgangsdaten.  Etwas seltener werden zus√§tzliche Anforderungen gestellt, wie z. B. Widerstand gegen absichtliche Kollisionserzeugung oder Irreversibilit√§t. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen langweiliger sein</b> <div class="spoiler_text"><p>  Aus Gr√ºnden der Klarheit ist es notwendig, das Konzept der ‚ÄûQualit√§t‚Äú der Hash-Funktion und den Rest der Anforderungen etwas detaillierter zu definieren: <br>  Basisqualit√§t und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lawineneffekt</a> : Durch √Ñndern eines oder mehrerer beliebiger Bits in einem beliebigen Satz von Quelldaten √§ndert sich jedes Bit des Ergebnisses mit einer Wahrscheinlichkeit von ¬Ω. </p><br><ul><li>  Irreversibilit√§t oder erster Vorbildwiderstand: Die Unm√∂glichkeit, die Originaldaten oder einzelnen Bits aus dem Hash-Ergebnis zu erhalten. </li><li>  Widerstand gegen Kollisionen erster Ordnung und / oder Widerstand vor dem zweiten Bild: die Schwierigkeit, den Originaldatensatz zu finden / anzupassen, um ein bestimmtes Ergebnis oder einen Teil davon zu erhalten, auch wenn der urspr√ºngliche Datensatz bekannt ist. </li><li>  Widerstand gegen Kollisionen zweiter Ordnung: Die Schwierigkeit, zwei verschiedene Datens√§tze zu finden / anzupassen, die das gleiche Ergebnis oder eine √úbereinstimmung eines signifikanten Teils ergeben w√ºrden. </li></ul></div></div><br><p>  Ohne lange Zitate der zugrunde liegenden Mathematik kann Folgendes zusammengefasst werden: </p><br><ul><li>  Das Erf√ºllen aller oben genannten Anforderungen bei gleichzeitiger Gew√§hrleistung einer hohen Leistung ist ein ziemlich schwieriges Problem, dessen L√∂sung uns eine gute kryptografische Hash-Funktion geben w√ºrde.  Aber wir werden das noch nicht tun. </li><li>  Die Bereitstellung der Grundqualit√§t erfordert eine ausreichend gro√üe Anzahl von ALU-Operationen.  Einfach ausgedr√ºckt, Qualit√§t geht immer Kompromisse mit der Geschwindigkeit ein. </li><li>  Um ein qualitativ hochwertiges Ergebnis mit einer Bitbreite zu erhalten, die gr√∂√üer als die Bitbreite von ALU-Operationen ist, muss die Anzahl der Mischungen und damit die grundlegenden ALU-Operationen um mehr als das Mehrfache erh√∂ht werden. </li><li>  Im Allgemeinen <em>erfordert das Erstellen einer schnellen Hash-Funktion das Erreichen eines gewichteten Kompromisses zwischen Geschwindigkeit, Qualit√§t und Ergebnisbitness</em> . </li></ul><br><p>  Daher kann ich sagen, dass <strong>t1ha</strong> als Ergebnis der Suche nach einem Kompromiss zwischen Qualit√§t und Geschwindigkeit entstanden ist, wobei gleichzeitig die F√§higkeiten moderner Prozessoren und die bereits gefundenen Methoden (arithmetisch-logische Kombinationen) zum Mischen und Verteilen von Abh√§ngigkeiten ber√ºcksichtigt wurden ( Lawineneffekt). </p><br><p>  Die Basisversion von <strong>t1ha</strong> ist eine der schnellsten portablen Hash-Funktionen zum <strong>Erstellen</strong> von Hash-Tabellen und anderen verwandten Anwendungen.  Die Basisversion von <strong>t1ha</strong> konzentriert sich auf 64-Bit-Little-Endian-Architekturen, verwendet einen 64-Bit-Salt-Wert (Seed) und erzeugt ein 64-Bit-Ergebnis, das die Verst√§rkung durch Schl√ºssell√§nge und Seed umfasst.  Es ist erw√§hnenswert, dass <strong>t1ha</strong> absichtlich so ausgelegt ist, dass es 0 f√ºr Null-Eingabedaten <strong>zur√ºckgibt</strong> (ein Schl√ºssel mit einer Gr√∂√üe von Null und einem <strong>Startwert</strong> von Null). </p><br><div class="spoiler">  <b class="spoiler_title">Beantwortung der beliebtesten Fragen</b> <div class="spoiler_text"><p>  <strong>64-Bit-Operationen</strong> : Vielleicht sollte angemerkt werden, dass es die 64-Bit-Operationen sind, die Geschwindigkeit und Qualit√§t bieten, ohne die Portabilit√§t zu beeintr√§chtigen.  Je breiter die Ziffernkapazit√§t von Rechenoperationen ist, desto mehr Lawineneffekte erzeugen sie und desto besser mischen sie die Daten.  Dar√ºber hinaus ist die Datenverarbeitung bei sonst gleichen Bedingungen sicherlich um 8 Byte schneller als um 4. Auf der anderen Seite sind auf vielen modernen Prozessoren genau 64-Bit-Operationen nativ verf√ºgbar und k√∂nnen mehr oder weniger angemessen in 32- √ºbersetzt werden. Bit diejenigen.  Alle anderen Optionen, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIMD-</a> Vorg√§ngen, zwingen uns, die Portabilit√§t und / oder Geschwindigkeit auf nicht nativen Plattformen stark zu beeintr√§chtigen. </p><br><p>  <strong>64-Bit-Ergebnis</strong> : Um Hash-Tabellen zu erstellen, reicht in vielen F√§llen ein Ergebnis mit geringerer Bitbreite aus.  Sogar 32 Bit k√∂nnen mehr als ausreichend sein.  Bei Verwendung von 64-Bit-Operationen ist das 64-Bit-Ergebnis jedoch nat√ºrlich.  Gleichzeitig k√∂nnen Sie mit einem 64-Bit-Hash-Ergebnis von ausreichend hoher Qualit√§t schnell einen Vergleich auf Nichtgleichheit und mit guter Genauigkeit einen Vergleich auf Gleichheit durchf√ºhren. </p><br><p>  Die obige "Magie" des Ersetzens von Vergleichen kann unklar und unn√∂tig erscheinen, oder sie kann <strong>die Geschwindigkeit des Hashings</strong> nur durch <strong>Datenlokalit√§t um eine Gr√∂√üenordnung erh√∂hen</strong> , d. H. Weniger CPU-Cache-Verschmutzung.  Einfach ausgedr√ºckt kann man eine Hash-Tabellenstruktur so erstellen, dass die berechneten Hash-Werte nebeneinander liegen (in Cache-Zeilen gepackt).  Die CPU w√ºrde dann nur dann die realen Daten erfassen, wenn die Hashwerte √ºbereinstimmen.  In diesem Fall erm√∂glichen die <em>64-Bit-Werte von t1ha das bestm√∂gliche Ergebnis</em> .  Davon abgesehen bieten 128 Bit keinen Vorteil mehr, w√§hrend es immer m√∂glich ist, weniger von 64 Bit zu nehmen. </p><br><p>  <strong>Vergleich mit HighwayHash</strong> : Ich habe gemischte Gef√ºhle in Bezug auf dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inoffizielle Projekt von Google-Mitarbeitern</a> . </p><br><ol><li>  Einerseits hat es guten Code und eine ausgezeichnete technische Implementierung.  Andererseits ist <em>HighwayHash</em> als <em>m√∂glicherweise</em> kryptografisch stark positioniert (mindestens gleich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SipHash</a> ).  In HighwayHash gibt es einige Manipulationen, mit denen wir erwarten k√∂nnen, dass das Ergebnis nicht schlecht wird.  Es gibt jedoch keine Beweise, die es uns erlauben w√ºrden, dies zuverl√§ssig zu sagen.  Der vorgelegte Beweis f√ºr "St√§rke" beruht auf den Ergebnissen statistischer Tests, die jedoch nicht reproduzierbar sind (irgendwann habe ich mir sogar einen etwas √ºberfl√ºssigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar</a> erlaubt). </li><li>  HighwayHash ist nur auf x86_64 mit AVX2 oder SSE41 sehr schnell.  Ist es nicht einfacher, nur die AES-NI- oder SHA-Beschleunigung zu verwenden? </li></ol><br><p>  Wenn alles gut geht, werden der t1ha-Suite zus√§tzliche Optionen hinzugef√ºgt (haupts√§chlich f√ºr die Ergebnisbitness) und f√ºr E2K optimiert.  Damit m√∂chte ich das Thema Vergleiche mit HighwayHash abschlie√üen. </p></div></div><br><hr><br><h2 id="quality">  Qualit√§t </h2><br><p>  Die Bewertung der Qualit√§t einer Hash-Funktion in allen Aspekten kann sehr schwierig sein.  Dies kann entweder analytisch oder durch Implementierung verschiedener statistischer Tests erfolgen.  Leider ist der analytische Ansatz f√ºr die Bewertung von Hash-Funktionen mit einem Kompromiss zwischen Qualit√§t und Geschwindigkeit nicht sehr effektiv.  Dar√ºber hinaus ist eine vergleichende analytische Bewertung solcher Funktionen tendenziell subjektiv. </p><br><p>  Im Gegensatz dazu k√∂nnen statistische Tests klare quantitative Sch√§tzungen liefern.  F√ºr solche Zwecke gibt es bew√§hrte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testpakete</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMHasher</a> .  F√ºr <em>t1ha</em> sind die Ergebnisse einfach - alle <strong>t1ha-Optionen</strong> bestehen alle Tests ohne Kommentare.  Andererseits sollte man nicht davon ausgehen, dass t1ha Eigenschaften aufweist, die √ºber die f√ºr die Zielanwendung erforderlichen hinausgehen (Erstellen von Hash-Tabellen). </p><br><p>  Die Anzahl der Kollisionen auf allen Ebenen (Varianten) von <strong>t1ha</strong> entspricht dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geburtstagsparadoxon</a> .  Um es genau zu formulieren: Die Kollisionswahrscheinlichkeit in <strong>t1ha</strong> entspricht der Wahrscheinlichkeit des Zusammentreffens zuf√§lliger diskreter Werte mit entsprechender Bitigkeit. <br>  Eine √§hnliche Wahrscheinlichkeit von Kollisionen wird bei allen hochwertigen Hash-Funktionen beobachtet.  Dies ist jedoch nur eine Wahrscheinlichkeit, sodass die tats√§chliche Anzahl von Kollisionen f√ºr jeden spezifischen Datensatz variieren kann. </p><br><p> Nach der Erstver√∂ffentlichung dieses Artikels stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yves Orton fest</a> , dass das erste <code>t1ha1()</code> nicht immer das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strenge Lawinenkriterium erf√ºllt</a> .  Dieser Nachteil ist f√ºr gezielte Anwendungen von <code>t1ha1()</code> unbedeutend und aus praktischer Sicht nicht <code>t1ha1()</code> .  Dieser Nachteil wird jedoch in der n√§chsten Stufe / Variante <code>t1ha2()</code> beseitigt, die urspr√ºnglich geplant war, um eine etwas h√∂here Qualit√§t bereitzustellen.  Auf neuen Prozessoren, die aktuelle Versionen von Compilern verwenden, ist <code>t1ha2()</code> im Durchschnitt einen Zyklus schneller als <code>t1ha1()</code> , und in den √ºbrigen F√§llen kann es einen Zyklus langsamer sein.  Es ist erw√§hnenswert, dass <code>t1ha2()</code> zus√§tzlich einen Stream-Hashing-Modus und ein 128-Bit-Ergebnis bietet. </p><br><p>  Die Leser w√ºrden sich sicherlich √ºber eine gr√ºndliche und gr√ºndliche Analyse der Qualit√§t und / oder St√§rke von <strong>t1ha freuen</strong> .  Basierend auf den Ziel- <strong>t1ha-</strong> Anwendungsbereichen scheint dies jedoch √ºberfl√ºssig zu sein.  Kurz gesagt, Geschwindigkeit war uns wichtiger, auch bei kurzen Tasten.  Daher wurde ein Mehrrundenmischen nicht ber√ºcksichtigt.  Die vorliegende <em>t1ha-</em> Version spart Zyklen und liefert ein 64-Bit-Ergebnis - es ist praktisch sinnlos, den gefundenen Kompromiss auf andere Weise als statistisch zu messen, und die Ergebnisse sind einfach gut. </p><br><div class="spoiler">  <b class="spoiler_title">In der Tat</b> <div class="spoiler_text"><p>  Ich bin gerade meinen Kollegen von Google gefolgt, wie sie ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">statistischen Beweise</a> liefern </p></div></div><br><hr><br><h2 id="benchmarks">  Benchmarks </h2><br><p>  In Bezug auf den Anspruch, " <em>der Schnellste</em> " zu sein.  Es ist wichtig zu beachten, dass es offensichtlich nicht wahrscheinlich ist, dass es eine Hash-Funktion gibt, die gleichzeitig n√ºtzlich und auf allen Plattformen / Architekturen die schnellste ist.  Verschiedene Prozessoren verf√ºgen √ºber unterschiedliche Befehlss√§tze und f√ºhren √§hnliche Befehle mit unterschiedlichen Wirkungsgraden aus.  Offensichtlich kann die " <em>universell schnellste</em> " Funktion h√∂chstwahrscheinlich nicht erstellt werden.  Es scheint jedoch akzeptabel, den Begriff "the <br>  am schnellsten ¬ªf√ºr eine Funktion, die portabel und gleichzeitig am schnellsten ist, zumindest auf der g√§ngigsten Plattform (x86_64), w√§hrend die Wahrscheinlichkeit gering ist, auf einem modernen Prozessor mit einem anst√§ndigen optimierenden Compiler zu verlieren. </p><br><p>  Der Quellcode des Projekts enth√§lt einen Test, der sowohl die Richtigkeit des Ergebnisses √ºberpr√ºft als auch die Geschwindigkeit jeder implementierten Variante misst.  Gleichzeitig k√∂nnen auf x86 abh√§ngig von den F√§higkeiten des Prozessors (und des Compilers) zus√§tzliche Funktionsvarianten √ºberpr√ºft und Messungen in Prozessorzyklen durchgef√ºhrt werden. </p><br><p>  Dar√ºber hinaus enth√§lt die Projektwebsite Tabellen mit den Ergebnissen von Leistungsmessungen √ºber eine modifizierte Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMHasher von Reini Urban</a> .  Mit einem bestimmten Compiler kann man alle Zahlen √ºberpr√ºfen und / oder Ergebnisse auf einem bestimmten Prozessor erhalten. </p><br><p>  Hier k√∂nnen Sie t1ha mit einigen seiner engsten Konkurrenten vergleichen. </p><br><p>  <strong>Hashing</strong> von Kurztasten (Durchschnitt f√ºr 1..31 Bytes). <br>  <em>Schauen Sie sich die rechte Spalte "Cycles / Hash" an (kleiner ist besser)</em> : </p><br><table><thead><tr><th>  Funktion </th><th>  MiB / Sekunde </th><th>  Zyklen / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43.42 </td></tr><tr><td>  CityHash64 </td><td>  11041,72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808,92 </td><td>  46.33 </td></tr></tbody></table><br><p>  <strong>Hashing lange Schl√ºssel</strong> (256 Kb). <br>  <em>Schauen Sie sich die mittlere Spalte ‚ÄûMiB / Sekunde‚Äú an (gr√∂√üer ist besser)</em> : </p><br><table><thead><tr><th>  Funktion </th><th>  MiB / Sekunde </th><th>  Zyklen / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041,72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Varianten von t1ha </h2><br><p>  Entwicklung von <strong>t1ha</strong> Das erste dieser Ziele bestand darin, eine schnelle tragbare Funktion von ausreichend hoher Qualit√§t f√ºr die Erstellung von Hash-Tabellen zu erhalten. </p><br><p>  Dann wollten wir die schnellste Version der Hash-Funktion haben, die ein Ergebnis von vergleichbarer Qualit√§t liefert, aber so weit wie m√∂glich an die Zielplattform angepasst wurde.  Beispielsweise arbeitet die Basisversion von <strong>t1ha</strong> mit einer Little-Endian-Bytereihenfolge, weshalb f√ºr Big-Endian-Architekturen mit unvermeidlichem Leistungsverlust eine Konvertierung erforderlich ist.  Warum also nicht unn√∂tige Vorg√§nge auf einer bestimmten Zielplattform loswerden?  Auf diese Weise wurden mehrere weitere Optionen hinzugef√ºgt: </p><br><ul><li>  Vereinfachte Version f√ºr 32-Bit-Plattformen, sowohl f√ºr kleine als auch f√ºr gro√üe Endianer. </li><li>  Variante mit AES-NI-Anleitung, jedoch ohne AVX. </li><li>  Zwei Varianten mit den Anweisungen AES-NI und AVX. </li></ul><br><p>  Sp√§ter wurde klar, dass mehr Optionen f√ºr verschiedene Anwendungen erforderlich sein w√ºrden, einschlie√ülich unterschiedlicher Bitbreitenergebnisse, Qualit√§ts- und Haltbarkeitsanforderungen.  Diese Vielfalt erforderte eine ordnungsgem√§√üe Systematisierung.  Dies wurde erreicht, indem das Namensschema ge√§ndert wurde, in dem das numerische Suffix die ‚ÄûEbene‚Äú der Funktion angibt: </p><br><ul><li>  <code>t1ha0()</code> - ist die schnellste Option f√ºr den aktuellen Prozessor. </li><li>  <code>t1ha1()</code> - ist die tragbare 64-Bit-Basisversion von t1ha. </li><li>  <code>t1ha2()</code> - ist eine tragbare 64-Bit-Version mit etwas mehr Bedenken <code>t1ha2()</code> Qualit√§t. </li><li>  <code>t1ha3()</code> - ist eine schnelle tragbare 128-Bit-Version f√ºr Fingerabdr√ºcke. </li><li>  usw. </li></ul><br><p>  In diesem Schema wird angenommen, dass <code>t1ha0()</code> ein Dispatcher ist, der die Umleitung abh√§ngig von der Plattform und den F√§higkeiten des aktuellen Prozessors implementiert.  Zus√§tzlich kann die Verwendung der Suffixe "_le" und "_be" f√ºr eine explizite Wahl zwischen der Little-Endian- und der Big-Endian-Variante eingef√ºhrt werden.  So gibt es unter dem Schild ‚Äût1ha‚Äú jetzt mehrere Hash-Funktionen, und diese Familie wird in Zukunft wachsen, einschlie√ülich einer f√ºr das russische E2K ‚ÄûElbrus‚Äú optimierten Version. </p><br><p>  Eine allgemeine Vorstellung des aktuellen Satzes von Funktionen und ihrer Eigenschaften kann durch Betrachten der eingebauten Testausgabe ( <code>make check</code> ) erfasst werden.  Es ist anzumerken, dass alle Funktionen alle SM Hasher-Tests bestehen und die Leistung der AES-NI-Varianten je nach Prozessormodell stark variiert: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen √ºber die interne Struktur</b> <div class="spoiler_text"><p>  Um ein wenig detaillierter zu werden, wird <strong>t1ha</strong> nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkle-Damg√•rd-Schema</a> (‚ÄûWipe-Pipe‚Äú -Version) gebaut, wobei die Datengr√∂√üe und der Startwert verst√§rkt werden.  Innerhalb der Hauptkomprimierungsschleife wird ein 256-Bit-Status mit derselben Gr√∂√üe des Eingabeblocks verwendet.  Dar√ºber hinaus gibt es f√ºr jeden Datenoperanden zwei Injektionspunkte mit Kreuzbest√§ubung.  Nach Abschluss des Komprimierungszyklus wird der 256-Bit-Zustand auf 128 Bit komprimiert. </p><br><p>  Bei der Ausf√ºhrung der oben genannten Aktionen werden 64-Bit-Operationen verwendet, die in den Mischern ARX (Add-Rotate-Xor) und MUX / MRX (Mul-Rotate-Xor) kombiniert sind.  Es ist wichtig, dass alle diese Berechnungen so erstellt werden, dass die M√∂glichkeit der parallelen Ausf√ºhrung der meisten Vorg√§nge und des engen Packens von U-Ops sowohl in die Pipeline als auch in x86_64-Ausf√ºhrungseinheiten gew√§hrleistet ist.  Dadurch wird eine ausreichend gute Qualit√§t mit nahezu maximaler Hash-Rate f√ºr lange Schl√ºssel erreicht. </p><br><p>  Es ist anzumerken, dass die Komprimierungsschleife nur f√ºr Bl√∂cke mit ausreichender Gr√∂√üe ausgef√ºhrt wird.  Wenn weniger Daten vorhanden sind, besteht der 128-Bit-Zwischenzustand nur aus der Schl√ºsselgr√∂√üe und dem Salt-Wert. </p><br><p>  Dann wird das verbleibende Ende der Daten in Teilen von 64 Bit abwechselnd mit den H√§lften des 128-Bit-Zustands gemischt.  Schlie√ülich wird der Zustand gemischt und gleichzeitig auf ein 64-Bit-Ergebnis komprimiert.  Ein wichtiges Merkmal von t1ha ist hier die Verwendung eines Mischers, der auf einer breiten Multiplikation basiert (128-Bit-Produkt von zwei 64-Bit-Multiplikatoren).  Dies erm√∂glicht eine gute Mischqualit√§t mit einem guten Lawineneffekt und weniger Vorg√§ngen.  Obwohl eine breite Multiplikation eine relativ teure Operation ist, erm√∂glichen weniger solcher Operationen t1ha, kurze Schl√ºssel in einer rekordarmen Anzahl von Prozessorzyklen zu verarbeiten. </p><br><p>  Es ist zu beachten, dass der Mischer, der auf einer breiten Multiplikation und einem exklusiven ODER basiert, nicht perfekt ist.  Obwohl <em>t1ha</em> alle <em>SMHasher-</em> Tests besteht, versteht der Autor die Konsequenzen der <em>Nichtinjektivit√§t</em> .  Trotzdem scheint die resultierende Qualit√§t rational ausreichend zu sein, und die Entwicklungspl√§ne f√ºr die t1ha-Linie spiegeln bereits die Absicht wider, etwas h√∂here Qualit√§tsoptionen bereitzustellen. </p></div></div><br><p>  Weitere Informationen und Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  <em>Danke f√ºrs Lesen!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439156/">https://habr.com/ru/post/de439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439142/index.html">Reifegradmodelle entwerfen</a></li>
<li><a href="../de439148/index.html">Arbeiten Sie mit nRF51822 mit ST-Link und Clion + OpenOCD</a></li>
<li><a href="../de439150/index.html">Wer sollte die Transaktionskosten bezahlen?</a></li>
<li><a href="../de439152/index.html">IT-Geh√§lter in der zweiten Jahresh√§lfte 2018: Laut Gehaltsrechner "My Circle"</a></li>
<li><a href="../de439154/index.html">Wie Freiberufler leben: Buchumschlagdesign, eigene Rucksackproduktion und Reisen</a></li>
<li><a href="../de439158/index.html">DataArt startet kostenlosen Service zur Verbesserung des Lebenslaufs von Enten</a></li>
<li><a href="../de439160/index.html">Stand des Algorithmus: Was passiert mit Indie-Entwicklern auf Steam?</a></li>
<li><a href="../de439162/index.html">So debuggen Sie Frontend und Backend: Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de439166/index.html">mmWave auf dem Weg zur Kommerzialisierung im Smartphone-Formfaktor</a></li>
<li><a href="../de439168/index.html">Client-Analysesysteme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>