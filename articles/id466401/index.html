<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ƒï¸ ğŸŒ´ ğŸ¤ Sedikit matematika finansial: menghitung inflasi dan bunga ğŸ¥  ğŸ” ğŸ“£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya harus memeriksa perhitungan yang dibuat oleh utilitas publik kota saya. Ada masalah kontroversial, yang hanya bisa diselesaikan de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit matematika finansial: menghitung inflasi dan bunga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/"> Baru-baru ini, saya harus memeriksa perhitungan yang dibuat oleh utilitas publik kota saya.  Ada masalah kontroversial, yang hanya bisa diselesaikan dengan melakukan perhitungan yang benar.  Ke depan, saya akan mengatakan bahwa utilitas publik berpikir salah.  Oleh karena itu, di sini kita akan mempertimbangkan bagaimana menghitung dengan benar biaya inflasi dan 3% per tahun untuk hutang untuk kewajiban, menurut Hukum Perdata Ukraina. <br><br>  Bagian pertama menjelaskan perhitungan biaya inflasi, ini khusus untuk Ukraina. <br>  Bagian kedua (lebih besar) akan dikhususkan untuk masalah menghitung 3% per tahun.  Ini juga berlaku untuk Federasi Rusia, Belarus dan Kazakhstan, tetapi di negara-negara ini kurs tidak tetap, tetapi tergantung pada tingkat refinancing Bank Sentral.  Seluruh negara tidak melihat. <br><br>  Bagian kedua sangat dekat dengan menghitung bunga pada transaksi kredit biasa (pinjaman, pinjaman, pinjaman, dll). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="alt gambar"></div><br>  Pertama teori, pada akhirnya sedikit kode. <br><br>  Semua ini ada di bawah luka. <br><a name="habracut"></a><br>  Jadi, saya mendapatkan sebuah dokumen dari utilitas publik "Pernyataan akrual biaya inflasi dan 3% per tahun."  Saya sudah memeriksa, dan saya mengetahui bahwa itu dihitung menggunakan algoritma yang salah dan menarik, karena harus menerapkan persyaratan artikel dari Kode Sipil Ukraina. <br><br>  Apa yang harus dipertimbangkan ditulis dalam KUH Perdata Ukraina: <br><blockquote>  Artikel 625 dari Kode Sipil Ukraina.  â€œTanggung jawab atas pelanggaran kewajiban moneterâ€ <br>  2. Seorang debitur yang telah menunda pemenuhan kewajiban moneter, atas permintaan kreditor, wajib membayar jumlah utang dengan memperhitungkan indeks inflasi yang telah ditetapkan untuk seluruh periode penundaan, serta 3% per tahun dari jumlah yang terlambat ... </blockquote>  Berdasarkan angka utang, utilitas publik menghitung biaya inflasi dan 3% per tahun. <br><br><h2>  Biaya inflasi </h2><br>  Selanjutnya saya akan berbicara tentang algoritma perhitungan, dan bukan tentang angka-angka tertentu. <br><br>  Inflasi adalah proses yang ditandai dengan depresiasi mata uang, yaitu penurunan daya beli dan kenaikan harga secara umum.  Tidak termasuk inflasi, hasil akhir dari perhitungan arus kas sangat sewenang-wenang. <br><br>  Indeks Inflasi (II), atau Indeks Harga Konsumen (CPI), Indeks Harga Konsumen (CPI) - salah satu jenis indeks harga yang dibuat untuk mengukur tingkat harga rata-rata untuk barang dan jasa (keranjang konsumen) untuk periode tertentu dalam perekonomian. <br><br>  AI adalah indikator yang mencirikan dinamika tingkat harga umum untuk barang dan jasa yang diperoleh populasi untuk konsumsi non-produktif.  Ini adalah indeks pertumbuhan, yang menunjukkan berapa persen kenaikan harga rata-rata untuk periode yang ditinjau. <br><br>  Di Ukraina, AI dan CPI sama artinya <br><br>  Karena indeks harga adalah indeks berantai, untuk periode mengikuti satu demi satu, itu dihitung dengan mengalikan indikator, misalnya, 101% * 102% = (1,01 * 1,02) * 100% = 103,02%. <br><br>  AI dihitung oleh Komite Statistik Negara Ukraina dan diterbitkan dalam majalah resmi.  Angka-angka kunci ini dapat digunakan untuk menghitung ulang jumlah uang tunai. <br>  Apa yang dipikirkan pekerja komunal? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="Bagian dari dokumen tagihan utilitas"></div><br>  Tanggal penyelesaian terakhir adalah 7 Desember 2016. <br><br>  Mari kita lihat bagaimana pekerja komunal mendapat rasio biaya inflasi? <br><br>  Dapat dilihat dengan mata telanjang bahwa pada kolom ketiga (dan kelima), bukannya bilangan bulat 1, harus ada bilangan bulat 0. Bagaimana mereka mendapatkan bagian pecahan? <br><br>  <strong>September 2016.</strong> Bagian pecahan 0,028.  Jangka waktu pembayaran untuk September adalah 20 Oktober 2016. Bagian pecahan sesuai dengan indeks inflasi yang diterbitkan oleh Komite Statistik Negara, untuk Oktober 2016 - 102,8% <br><br>  <strong>Agustus 2016.</strong> Bagian pecahan 0,0465.  Jangka waktu pembayaran untuk Agustus adalah 20 September 2016. Bagian pecahan sesuai dengan indeks inflasi untuk September dikalikan dengan II untuk Oktober: 101,8% * 102,8% = 104,65%, atau dalam bentuk saham, 1,018 * 1,028 = 1,046504.  Utilitas publik dibulatkan menjadi 1,0465 dan mencetak nomor ini, meskipun unit harus diambil, karena pada kolom berikutnya mereka hanya mencetak jumlah biaya inflasi, dan bukan jumlah akumulasi. <br><br>  <strong>Juli 2016 dan sebelumnya.</strong>  Saya melakukan perhitungan ini dan mengembalikan algoritme.  Utilitas publik menggandakan indeks inflasi, mulai dari bulan setelah bulan penyediaan layanan (bulan dari tanggal jatuh tempo), dan berakhir dengan Oktober 2016. <br><br>  <strong>Titik awal</strong> hanya sebagian benar.  Seperti yang akan saya tunjukkan nanti, dalam kasus umum, perhitungan benar-benar perlu dimulai dari bulan ini, tetapi dalam kasus khusus kami, bulan pertama harus dilewati (menyamakan AI hingga 100%). <br><br>  <strong>Titik akhir dari</strong> perkalian.  Karena hari terakhir perhitungan adalah pada bulan Desember, dan Anda harus menyelesaikan bulan Desember, pada umumnya demikian.  Seperti yang akan saya tunjukkan nanti, dalam kasus khusus ini, Desember juga perlu dilewati (juga samakan AI hingga 100%).  Dan pada 7 Desember, AI Desember tidak punya waktu untuk menerbitkan. <br><br>  Mengapa November tidak diperhitungkan di mana pun?  Saya pikir mereka hanya lupa untuk memasukkannya ke dalam sistem. <br><br>  Sekarang mari kita lihat bagaimana cara menghitung indeks inflasi.  Sebagaimana <strong>diperlukan</strong> - dijelaskan dalam Surat Informasi Mahkamah Agung Ekonomi Ukraina No. 01-06 / 928/2012 tanggal 17.07.2012 [6]. <br><br>  Saya akan memberikan bagian dari paragraf: <br><blockquote>  Jumlah utang yang harus dibayar dari hari pertama hingga tanggal 15 bulan tersebut diindeks dengan memperhitungkan bulan ini, dan jika utang tersebut harus dibayar dari tanggal 16 hingga 31 pada bulan tersebut, perhitungan dimulai dari bulan berikutnya. <br><br>  Demikian pula, jika utang telah dilunasi dari 1 hingga 15 hari dalam sebulan, biaya inflasi dihitung tanpa memperhitungkan bulan ini, dan jika dari 16 hingga 31 hari dalam sebulan, biaya inflasi dihitung dengan memperhitungkan bulan ini. </blockquote>  Dalam kasus kami, jangka waktu pembayaran adalah hari ke-20 pada bulan tersebut setelah bulan pemberian layanan, yaitu  untuk penyediaan layanan pada bulan September, tanggal mulai penyelesaian adalah 21 Oktober 2016, dan batas waktunya adalah 7 Desember 2016. <br><br>  Yaitu  memang benar untuk mengatakan ini: untuk penyediaan layanan pada September 2016, pertimbangkan inflasi selama tiga bulan (lewati kursor atau siklus), dari Oktober hingga Desember, tetapi pada bulan pertama dan terakhir, ambil AI sama dengan 1 (100%), dan hanya memperhitungkan November. <br><br>  Pada November 2016, AI sebesar 101,8%, yaitu  koefisien harus 0,0180, bukan 0,0280.  Saya menulis tentang unit pemimpin sebelumnya. <br><br><h2>  3% per tahun </h2><br>  Mari kita lihat bagaimana layanan komunal menerima koefisien dan jumlah akrual 3% per tahun?  Ini adalah kolom kelima dalam tabel di atas. <br><br>  Seperti yang saya tulis sebelumnya, seharusnya tidak ada unit yang memimpin, harus ada 0. Kita melihat bagian fraksional, dan perhatikan bahwa itu entah bagaimana bulat mencurigakan - setiap bulan sebelumnya adalah 0,0025 lebih dari bulan saat ini. <br><br>  Dengan menggunakan perhitungan sederhana, dapat ditentukan bahwa utilitas publik, tanpa basa-basi lagi, dibagi 3% menjadi 12 bulan, menerima 0,0025, atau 0,25% per bulan, dan menghasilkan persentase ini untuk setiap bulan penundaan penuh dan tidak lengkap.  Ya, jika Anda melihat pada Oktober 2016, batas waktu pembayaran yang datang pada 21 November, dan perhitungan dilakukan pada 7 Desember, maka untuk bulan yang tidak lengkap mereka menghitung 0,25% yang sama. <br><br>  Pendekatan ini mengagumi keterusterangan brutal, tetapi, seperti yang akan saya tunjukkan nanti, matematika finansial tidak tahu algoritma seperti itu. <br><br>  Undang-undang Ukraina dan matematika keuangan tidak memberikan jawaban yang jelas untuk pertanyaan tentang cara menagih 3% per tahun?  Saya telah mencari beberapa buku tentang hal ini, tetapi buku-buku itu kuno, sejak tahun 2002.  Oleh karena itu, algoritme dari buku-buku tersebut akan dilengkapi dengan fakta bahwa google dapat dibuat dari artikel yang lebih modern dan barat.  [1] dicetak ulang pada tahun 2007, dan buku-buku berbahasa Rusia yang lebih baru tidak dapat ditemukan.  Mungkin karena matematika keuangan, sebagai sains, berasal dari waktu yang sangat lama, jauh sebelum munculnya komputer, konsep-konsep seperti "kredit" dan "bunga kredit" muncul beberapa ratus tahun yang lalu.  Dan algoritma tidak banyak berubah sejak tahun 2002. <br><br>  Tetapi pandangan Barat tentang masalahnya berbeda dari yang dijelaskan dalam buku-buku berbahasa Rusia.  Saya akan mengutip informasi pertama dari buku-buku berbahasa Rusia, dan kemudian dari artikel-artikel Barat, menunjukkan di mana mereka bertepatan. <br><br>  Apa yang tertulis di bawah ini merujuk pada kasus spesifik yang timbul 3% per tahun karena tunggakan, tetapi dapat digeneralisasi dengan perhitungan bunga pada hubungan kredit lainnya jika bunga tersebut diperoleh berdasarkan bunga sederhana daripada skema bunga majemuk. <br><br>  Menurut Art.  625 Hukum Perdata Ukraina perlu bertambah 3% per tahun sesuai dengan skema bunga sederhana.  Untuk menghitung jumlah bunga, jumlah utang (atau badan pinjaman, dalam kasus umum) harus dikalikan dengan suku bunga tahunan yang dinormalisasi sebesar 3% dan dikalikan dengan fraksi tahun (durasi dalam tahun) dengan jumlah keterlambatan tersebut.  Bagian ini mungkin lebih dari 1 jika penundaan lebih dari satu tahun. <br><br>  Durasi penundaan dinyatakan dalam hari.  Dalam kasus yang lebih umum, jangka waktu pinjaman <strong>dapat</strong> dinyatakan dalam hari (situasi ketika jangka waktu pinjaman dinyatakan dalam bulan dan tahun tidak dipertimbangkan di sini).  Dan tingkat tahunan 3% adalah tingkat normal bunga sederhana untuk tahun itu.  <strong>Oleh karena itu, Anda harus dapat membawa durasi keterlambatan (kredit) dalam hari ke durasi dalam tahun.</strong>  <strong>Ini bukan tugas sepele, karena panjang tahun tergantung pada jumlahnya.</strong> <br><br>  Durasi dalam berhari-hari adalah ukuran yang didefinisikan secara unik dari durasi kesenjangan kalender, berbeda dengan durasi dalam tahun.  Definisi yang terakhir membutuhkan klarifikasi dalam bentuk aturan untuk mengkonversi durasi dalam hitungan hari menjadi durasi dalam tahun.  Sejumlah metode standar untuk mengkonversi durasi dalam hitungan hari menjadi durasi dalam tahun didasarkan pada membagi jumlah hari dengan apa yang disebut <strong>"pembagi tahunan"</strong> .  Nilai paling umum dari pembagi tahunan adalah 360 dan 365 hari.  Dalam kasus yang paling sederhana, pembagi adalah angka konstan dan interval-independen.  Jumlah hari dalam suatu periode selalu bertindak sebagai dividen (pembilang dari pecahan). <br>  Dan Anda perlu memutuskan prosedur untuk menghitung persyaratan dalam beberapa hari.  Mari kita perhatikan dua contoh yang tidak masuk akal: <br><br><ol><li>  Klien menerima pinjaman jangka pendek dari bank dari 6 Desember 2018 hingga 7 Desember 2018.  Apa jangka waktu kontrak dan berapa hari yang saya perlukan untuk memperoleh bunga?  Jelas - 1 hari. </li><li>  Pelanggan memesan di muka layanan dari operator telekomunikasi, dengan masa berlaku di masa depan dari 6 Desember 2018 hingga 7 Desember 2018.  Apa jalur penyediaan layanan dan untuk berapa hari saya harus mengambil biaya berlangganan untuk layanan ini?  Jelas 2 hari. </li></ol><br>  Apa bedanya? <br><br>  Faktanya adalah bahwa hari itu bukan titik pada timeline, tetapi suatu interval yang dapat ditulis dalam dua cara (saya ingat bahwa kurung siku pada batas interval berarti bahwa titik tersebut dalam interval, kurung adalah titik bukan dalam interval): <br><br><ul><li>  [06.12.2018 00.00.00, 12/07/2018 00.00.00) - di sini batas kanan interval tidak termasuk dalam interval, </li><li>  [06/12/2018 00.00.00, 12/06/2018 23.59.59] - di sini batas kanan interval termasuk dalam interval. </li></ul><br>  Dalam kasus pertama (1), ketika interval waktu tidak diberikan secara eksplisit, tetapi dalam bentuk interval antara tanggal, jumlah hari yang tepat biasanya dihitung, termasuk hari pertama atau terakhir, tetapi tidak keduanya.  [4] mengatakan hal yang sama dengan kata lain: "Hari pinjaman dikeluarkan dan hari pembayaran dianggap satu hari." <br><br>  Metode ini menentukan waktu yang disebut tepat.  Hal ini juga dapat dengan mudah ditentukan jika kedua tanggal merujuk pada tahun yang sama dan kalender tersedia yang menunjukkan nomor seri setiap hari dalam setahun.  Maka itu cukup untuk mengurangkan nomor seri tanggal awal dari nomor seri tanggal akhir dan hasilnya akan memberikan durasi periode.  Dalam Oracle Database, Anda cukup mengurangi tanggal (tipe DATE) yang terpotong menjadi satu hari (dengan waktu yang dibuang), satu dari yang lain, perbedaannya adalah jumlah hari bilangan bulat. <br><br>  Dalam kasus kedua (2) kita berbicara tentang hari, jadi kita menghitung dua hari. <br><br>  Selanjutnya, saya melanjutkan dari fakta bahwa jumlah hari yang telah Anda tentukan, misalnya, dalam kasus layanan komunal, ketika batas waktu pembayaran adalah 20 September (yaitu ini adalah hari pembayaran terakhir yang dapat diterima), dan dibayarkan pada tanggal 21 September, yaitu. jelas bahwa keterlambatan harus diambil sama dengan 1 hari.  Jika Anda dihadapkan dengan indikasi interval tidak termasuk perbatasan kiri - hanya memindahkan perbatasan kiri satu hari ke kanan. <br><br>  Bagaimana kita menghitung jumlah hari dan pembilang fraksi?  Ada perhitungan yang tepat dan perkiraan perhitungan. <br><br><h3>  Penghitungan hari yang akurat </h3><br><h4>  Latihan berbahasa Rusia </h4><br>  Teks selanjutnya didasarkan pada [1]. <br><br>  Pilihan jumlah hari yang tepat dalam suatu periode sebagai pembagi, dan dua aturan paling umum diberikan sebagai penyebut pembagi tahunan 360 atau 365: <br><br>  <strong>Aturan (R1) ACT / 365.</strong>  Untuk aturan ini, durasi dalam hari dibagi dengan angka 365. Saya perhatikan bahwa panjang tahun kabisat adalah 366/365 = 1,00274, yang lebih dari satu.  Kesalahan aturan ACT / 365 akan menjadi lebih besar, lebih banyak tahun kabisat dalam suatu periode.  Oleh karena itu, nilai 3% per tahun yang diakibatkan oleh aturan ini akan lebih dari 3%. <br><br>  <strong>Aturan (R2) ACT / 360.</strong>  Ini adalah apa yang disebut "Aturan Perbankan", yang menurutnya, durasi dalam hari dibagi dengan 360. Aturan ini semakin menambah panjang kesenjangan tahunan.  Untuk tahun non-kabisat, panjangnya akan menjadi 365/360 = 1.01389, dan untuk tahun kabisat 366/360 = 1.01667.  Secara alami, semakin lama periode, semakin besar tingkat "perpanjangan" dalam beberapa tahun.  Aturan ini paling sering digunakan dalam perhitungan yang terkait dengan pasar uang, yaitu  hutang jangka pendek pasar, seperti deposito dengan bank, tagihan, surat berharga, sertifikat deposito, dll. Nilai 3% per tahun untuk tahun tersebut akan lebih besar daripada ketika menggunakan aturan sebelumnya. <br><br>  Dalam hal pembagi tahunan diterima sama dengan 360 hari, bunga yang diperoleh dengan menggunakan pembagi tersebut disebut <strong>biasa</strong> , atau <strong>komersial</strong> .  Jika pembagi diambil sama dengan 365 atau, seperti yang akan saya tunjukkan nanti, 366 hari, bunga disebut tepat. <br><br>  Jelas, persentase biasa lebih dari tepat. <br><br>  Meskipun aturan pertama lebih akurat daripada yang kedua, keduanya tidak cukup akurat. <br><br>  Untuk menghilangkan efek tahun kabisat pada hasil, ada dua aturan lain. <br><br>  <strong>Aturan (R3) ACT / 365, Jepang.</strong>  Perhitungan dilakukan dengan cara yang sama seperti untuk aturan ACT / 365, tetapi ketika menghitung durasi interval (pembilang fraksi), tanggal lompatan dikecualikan.  Pembagi tahunan tetap tidak berubah. <br><br>  Menurut Wiki: <br><blockquote>  Di banyak negara Eropa, hingga abad ke-18, tanggal 29 Februari dianggap sebagai hari yang tidak ada, tanggal yang tidak memiliki status hukum.  Seringkali, transaksi tidak dilakukan hari itu, pembayaran tidak dilakukan, mereka tidak diberikan dalam hutang, dll, karena ada masalah dengan sisi formal masalah dan penyelesaian kasus di pengadilan. </blockquote><br><br>  Cara lain terkait dengan perubahan pembagi yang sebenarnya. <br><br>  <strong>Aturan (R4) ACT / ACT dasar.</strong>  Kami membagi periode yang diinginkan menjadi tiga bagian: <br><br><ul><li>  bagian pertama, dari tanggal mulai hingga akhir tahun di mana tanggal mulai berada, </li><li>  bagian ketiga - dari awal tahun di mana tanggal akhir berada, hingga tanggal akhir, </li><li>  bagian kedua - 0 atau beberapa tahun kalender penuh antara bagian pertama dan ketiga. </li></ul><br>  Durasi bagian pertama dan ketiga diperoleh dengan membagi jumlah hari dengan pembagi tahunan 365 atau 366, tergantung pada apakah itu tahun kabisat?  Durasi periode kedua terdiri dari jumlah integer tahun kalender penuh, menurut definisi, terlepas dari apakah mereka melompat atau tidak.  Durasi dalam tahun dari seluruh periode diperoleh dengan menjumlahkan durasi dari tiga bagian, diwakili oleh tiga angka, di mana yang kedua adalah keseluruhan, dan yang pertama dan ketiga adalah fraksional. <br><br>  <strong>Aturan (R5) ACT / ACT "pendek" modifikasi, untuk periode kurang dari setahun.</strong>  Dalam hal ini, durasi dalam hari dibagi dengan pembagi tahunan 365 atau 366, tergantung pada apakah ada tanggal pada 29 Februari dalam periode pencarian?  Keunikan aturan pendek ACT / ACT adalah bahwa jika interval tidak sesuai dengan tahun kalender (ujungnya menjadi tahun tetangga), maka penerapan aturan dasar dan pendek akan menghasilkan hasil yang berbeda. <br><br><h4>  Praktek Barat </h4><br>  Dalam praktik Barat, aturan dijelaskan secara berbeda.  Seringkali aturan bahasa Rusia yang sama diberi nama yang berbeda, dan, lebih dari itu, tidak satu per satu. <br><br>  Informasi selanjutnya berdasarkan [2].  Ini Vicki, saya memeriksa semua sumber dan menggunakan informasi google lainnya: dalam aturan dengan jumlah hari yang tepat, semuanya benar, tetapi dalam aturan dengan perkiraan jumlah hari ada interpretasi lain dari aturan, dan sering kali mereka berubah seiring waktu, oleh karena itu, untuk menerapkan aturan, perkiraan jumlah hari artikel ini tidak cukup. <br><br>  <strong>Aturan (W1) Aktual / Aktual Aktual.</strong>  Aturan ini memberikan hasil yang sama dengan (R4) "ACT / ACT basic", tetapi dirumuskan secara berbeda: interval dibagi menjadi tahun kabisat dan tanpa kabisat, terlepas dari apakah mereka penuh atau tidak lengkap, lebih lanjut, jumlah hari yang jatuh ke dalam tahun kabisat, dibagi dengan 365, dan jumlah hari dalam tahun kabisat dibagi dengan 366, kedua angka tersebut dijumlahkan. <br><br>  Nama-nama lain dari aturan dalam praktik Barat: Aktual / Aktual, Act / Act, Actual / 365, Act / 365.  Ya, nama belakang sama dengan aturan (R1), meskipun esensi aturan berbeda. <br><br>  <strong>Aturan (W2) Aktual / 365 Diperbaiki.</strong>  Aturan ini persis mengulangi aturan (R1) ACT / 365 - jumlah hari dibagi dengan 365. <br><br>  Nama lain dari aturan dalam praktik Barat: Act / 365 Fixed, A / 365 Fixed, A / 365F, Bahasa Inggris. <br><br>  <strong>Aturan (W3) Sebenarnya / 360.</strong>  Aturan ini berulang (R2) ACT / 360 - jumlah hari yang tepat dibagi dengan 360. <br><br>  <strong>Aturan (W4) Sebenarnya / 364.</strong>  Jumlah hari dibagi 364. Tidak ada analog dalam praktik berbahasa Rusia. <br><br>  <strong>Aturan (W5) Sebenarnya / 365L.</strong>  Ini terdiri dari dua tweak: <br><ol><li>  Untuk pembayaran tahunan.  Jika tanggal 29 Februari dalam periode, maka jumlah hari dalam periode dibagi dengan pembagi tahunan 366, jika tidak, oleh 365. Dalam hal ini, itu bertepatan dengan aturan (R5) ACT / ACT â€œmodifikasi singkatâ€. </li><li>  Jika frekuensi pembayaran berbeda dengan tahunan.  Jika tanggal akhir adalah tahun kabisat (dan tidak harus sama dengan 29 Februari), maka pembagi tahunan adalah 366, jika tidak - 365. Dalam praktik berbahasa Rusia, ini tidak memiliki analog. </li></ol><br>  Nama lain adalah ISMA-Year. <br><br>  <strong>Aturan (W6) AFB Aktual / Aktual.</strong>  Ini terdiri dari dua tweak: <br><ol><li>  Utama, untuk periode kurang dari setahun: Jika tanggalnya adalah 29 Februari dalam periode tersebut, maka jumlah hari dalam periode tersebut dibagi dengan pembagi tahunan 366, jika tidak - oleh 365. Dalam hal ini, itu juga bertepatan dengan aturan "modifikasi pendek" R / ACT / ACT . </li><li>  Diperpanjang, untuk periode lebih dari satu tahun: satu tahun penuh bilangan bulat dihitung kembali dari tanggal akhir hingga tanggal mulai.  Untuk saldo kurang dari setahun, aturan utama berlaku.  Jumlah tahun penuh dan bagian tahun di bawah aturan dasar dirangkum. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada nuansa yang terkait dengan hitung mundur tahun lalu, jika hitung mundur dilakukan pada 28 Februari, dan setelah seluruh tahun penuh yang lalu, tahun itu adalah tahun kabisat. </font><font style="vertical-align: inherit;">Dalam hal ini, tanggal dan tahun yang lalu harus diadopsi pada tanggal 29 Februari. </font><font style="vertical-align: inherit;">Saya menambahkan bahwa pertanyaan juga muncul jika penghitungan mundur dilakukan dari 29 Februari, dan jumlah tahun penuh yang lalu bukan kelipatan empat, dan karenanya tahun sebelumnya bukan tahun kabisat. </font><font style="vertical-align: inherit;">Saya tidak masuk ke detail di sini. </font><font style="vertical-align: inherit;">Tapi Anda bisa merujuk ke tautan dari [2]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan "cherry on the cake," </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (W7) 1/1. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah hari dibagi dengan pembagi tahunan 365,25. </font><font style="vertical-align: inherit;">Digunakan untuk perhitungan yang berkaitan dengan inflasi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perkiraan hari dihitung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan yang tercantum di atas didasarkan pada durasi tepat dalam hari periode kalender. Namun, terkadang ada skema berdasarkan apa yang disebut penghitungan hari yang disederhanakan, atau perkiraan. Ide skema ini adalah untuk "menyamakan" durasi semua bulan hingga 30 hari. Dengan demikian, tahun akan terdiri dari 12 bulan 30 hari, yaitu dari 360 hari. Oleh karena itu, pembagi tahunan (penyebut fraksi) untuk aturan-aturan ini akan selalu 360, dan pembilangnya dihitung dengan cara khusus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena jumlah pasti hari pinjaman dalam kebanyakan kasus, tetapi tentu saja, tidak selalu, lebih besar dari nilai perkiraan (yang dapat dengan mudah diverifikasi dengan menentukan jumlah tahunan rata-rata hari dalam sebulan, yaitu 30,44), metode perhitungan bunga dengan jumlah hari pinjaman biasanya memberikan pertumbuhan lebih besar dari perkiraan. [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi paling sederhana dari aturan ini, yang disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peraturan Dasar 30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dijelaskan sebagai berikut (selanjutnya informasi pada buku [1] - praktik berbahasa Rusia): </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan Dasar 30/360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkiraan jumlah hari antara tanggal adalah</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1), </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana y, m, d - tahun, bulan dan hari pada tanggal kedua dan pertama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan ini muncul sebelum penciptaan perangkat komputasi pertama dan secara signifikan menghemat biaya operasi komputasi dalam praktik keuangan. </font><font style="vertical-align: inherit;">Meskipun sekarang kebutuhan untuk metode yang disederhanakan telah menghilang, namun, setelah mendapatkan pijakan dalam praktiknya, secara tradisional mereka kadang-kadang digunakan pada saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan berlaku dengan indikasi wajib modifikasi yang menunjukkan bagaimana menangani hari-hari terakhir bulan:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Latihan berbahasa Rusia </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diberikan oleh [1]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (R6) 30/360 ISDA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika d1 = 31, maka d1 '= 30, sebaliknya d1' = d1. </font><font style="vertical-align: inherit;">Jika d2 = 31 dan d1 '= 30, maka d2' = 30, sebaliknya d2 '= d2. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (R7) 30E / 360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika d1 = 31, maka d1 '= 30, sebaliknya d1' = d1. </font><font style="vertical-align: inherit;">Jika d2 = 31, maka d2 '= 30, sebaliknya d2' = d2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan ini adalah varian dari aturan ISDA 30/360, yang digunakan terutama di Eropa, karenanya label "E" atas nama aturan. </font><font style="vertical-align: inherit;">Ini berbeda dari aturan ISDA 30/360 hanya ketika tanggal kedua juga tanggal 31. </font><font style="vertical-align: inherit;">Versi Eropa selalu mengonversinya ke nomor 30, terlepas dari tanggal pertama. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (R8) 30/360 PSA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika d1 = 31 atau d1 adalah hari terakhir bulan Februari, maka d1 '= 30, sebaliknya d1' = d1. </font><font style="vertical-align: inherit;">Jika d2 = 31 dan d1 '= 30, maka d2' = 30, sebaliknya d2 '= d2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deskripsi aturan SIA 30/360 di [1] kemungkinan besar merupakan kesalahan, jadi saya tidak akan memberikannya di sini. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Praktek Barat </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diberikan sesuai dengan [2]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (W8) 30/360 Dasar Obligasi.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sama seperti (R6) 30/360 ISDA. Nama lain: 30A / 360. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (W9) 30E / 360.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sama seperti (R7) 30E / 360. Nama lain: 30/360 ICMA, 30S / 360, basis Eurobond (ISDA 2006), Bahasa Jerman Khusus. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (W10) 30E / 360 ISDA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika d1 adalah hari terakhir dalam sebulan, maka d1 '= 30. Jika d2 adalah hari terakhir BUKAN Februari, maka d2 '= 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama lain: 30E / 360 ISDA, basis Eurobond (ISDA 2000), Jerman. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (W11) 30/360 SIA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika d1 adalah hari terakhir bulan Februari dan d2 adalah hari terakhir bulan Februari, maka d2 '= 30. Jika d1 = 31 atau hari terakhir bulan Februari, maka d1 '= 30, sebaliknya d1' = d1. Jika d1 '= 30 dan d2 = 31, maka d2' = 30, sebaliknya d2 '= d1.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (R4) ACT / ACT, (W1) Aktual / Aktual ISDA, (W2) Aktual / 365 Tetap juga disebut "praktik bahasa Inggris." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan (R2) ACT / 360 dan (W3) Actual / 360 juga disebut "praktik Prancis". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peraturan (R7) 30E / 360, (W9) 30E / 360 dan (W10) 30E / 360 ISDA juga disebut "Praktek Jerman" atau "Praktek Jerman". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, dengan memperhitungkan bunga yang tepat dan biasa, serta jumlah hari yang tepat dan perkiraan untuk menghitung bunga, kami mendapatkan empat metode untuk menghitung bunga sederhana (nama-nama aturan ditunjukkan dalam praktik berbahasa Rusia):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bunga normal dengan jumlah hari persis (ACT / 360 - aturan perbankan), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persentase tepat dengan jumlah hari persis (ACT / 365, ACT / ACT), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bunga normal dengan perkiraan jumlah hari (30/360), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persentase yang tepat dengan perkiraan jumlah hari. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode pertama yang paling umum digunakan disebut aturan perbankan, lebih jarang yang kedua dan ketiga, dan hampir tidak pernah yang keempat [1]. Dan [4] mengatakan: "... pilihan perhitungan dengan bunga tepat dan perkiraan jumlah hari pinjaman tidak ada artinya dan tidak berlaku." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhitungan di atas dari perkiraan durasi periode dalam pecahan tahun menunjukkan non-triviality dan variasi aturan yang diterapkan. Aplikasi mereka (dan juga asal) tergantung pada negara, mata uang, jenis instrumen keuangan, asosiasi profesional, perjanjian. [1] </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KESIMPULAN:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagaimana saya menghitung 3% dalam kasus saya dengan utilitas publik di Ukraina?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis praktik peradilan penerapan Seni. 625 KUH Perdata Ukraina mengatakan bahwa metode (R1) ACT / 365 [3] biasanya digunakan, tetapi ini tidak dirumuskan dengan jelas. Saya pikir Anda masih perlu menerapkan (R4) ACT / ACT, dan inilah alasannya: jika Anda memperoleh 3% untuk tahun kabisat penuh menggunakan metode ACT / 365, maka jumlah bunga akan sama dengan 3,008219%, yang untuk utang (atau ukuran badan pinjaman) 1 juta unit moneter akan memberikan kelebihan CU 82,19 lebih dari 3%, yang ditentukan oleh tingkat bunga standar tahunan berdasarkan UU. Ini akan menjadi sangat penting dengan akrual bunga yang progresif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan sangat menghargai komentar, terutama dari karyawan bank. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber yang digunakan</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1) Bocharov, P.P., Kasimov, Yu.F. Matematika keuangan. Moskow: Gardariki, 2002 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Konvensi penghitungan hari,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3) Analisis penerapan seni. 625 KUH Perdata Ukraina dalam proses perdata, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua/ua/74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4) Chetyrkin E.M. Matematika finansial. Moskow: Case, 2005 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) Konvensi Penghitungan Hari dan Faktor Akrual, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docs.fincad.com/support/developerfunc/mathref/Daycount.htm</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6) Surat informasi dari Mahkamah Ekonomi Agung Ukraina No. 01-06 / 928/2012 tanggal 17.07.2012, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang kode kecil pada Oracle Database: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah paket yang saya buat untuk kasus khusus saya - ini menghitung biaya inflasi dan 3% per tahun untuk Ukraina.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada fungsi agregat di Oracle Database yang mengalikan nilai inflasi. </font><font style="vertical-align: inherit;">Oleh karena itu, saya menggunakan penjumlahan dari logaritma.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teks tersembunyi</font></font></b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466401/">https://habr.com/ru/post/id466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466379/index.html">Jalankan perangkat lunak "desktop" pada mikrokontroler</a></li>
<li><a href="../id466381/index.html">Bagaimana lampu LED Era berubah pada tahun 2019</a></li>
<li><a href="../id466383/index.html">Cryptocurrency Ocean: ulasan tentang 50 proyek teratas dengan CoinMarketCap</a></li>
<li><a href="../id466385/index.html">Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 1</a></li>
<li><a href="../id466397/index.html">Kami memprogram ulang kasir dan mencetaknya Keanu Reeves. Bagian 2. Perangkat lunak PC</a></li>
<li><a href="../id466403/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 35. Protokol Trunking DTP Dinamis</a></li>
<li><a href="../id466405/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 36. Protokol Saluran STP</a></li>
<li><a href="../id466407/index.html">Budaya Rekrutmen di Perusahaan Statistik Glassdoor Besar</a></li>
<li><a href="../id466409/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 37. STP: Pilihan Root Bridge, PortFast dan fitur penjaga BPDU. Bagian 1</a></li>
<li><a href="../id466413/index.html">Pertukaran situs untuk Bitrix dan 1C: menyelesaikan masalah utama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>