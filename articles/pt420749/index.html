<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎖️ ➡️ 💚 GitLab para projeto de entrega contínua em tecnologias InterSystems: Containers 👨🏾‍🏭 💏 🏎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo é uma continuação de um artigo sobre a organização dos processos de Integração Contínua / Entrega Contínua que automatizam a montagem, tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GitLab para projeto de entrega contínua em tecnologias InterSystems: Containers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intersystems/blog/420749/"><p>  Este artigo é uma continuação de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> sobre a organização dos processos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Integração Contínua</a> / Entrega Contínua que automatizam a montagem, teste e entrega de aplicativos aplicáveis ​​a soluções baseadas na plataforma InterSystems. </p><br><p>  Considere tópicos como: </p><br><ul><li>  Contentores 101 </li><li>  Contêineres em diferentes estágios do ciclo de desenvolvimento de software </li><li>  Entrega contínua com contêineres <a name="habracut"></a></li></ul><br><h1 id="konteynery-101">  Contentores 101 </h1><br><p>  Muitos artigos e livros foram escritos sobre contêineres e contêineres; portanto, aqui farei uma pequena introdução, que, no entanto, não afirma ser final.  Então, vamos começar. </p><br><p>  Contêineres, tecnicamente, é um método de virtualização no qual o kernel do sistema operacional suporta várias instâncias isoladas do espaço do usuário (contêineres), em vez de um.  Visualmente é assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/114/c21/985/114c21985549c134bf91685e2b15d1d3.jpg" alt="Docker vs VM"></p><br><p>  É importante observar que os contêineres não são máquinas virtuais. Aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom artigo</a> sobre suas diferenças. </p><br><h2 id="preimuschestva-konteynerov">  Benefícios do contêiner </h2><br><p>  Existem vários benefícios no uso de contêineres: </p><br><ul><li>  Portabilidade </li><li>  Eficácia </li><li>  Isolamento </li><li>  Leveza </li><li>  Imutabilidade </li></ul><br><h3 id="portativnost">  Portabilidade </h3><br><p>  O contêiner contém o aplicativo junto com todas as dependências.  Isso facilita a execução de aplicativos em vários ambientes, como servidores físicos, máquinas virtuais, ambientes de teste e ambientes de produtos e nuvens. </p><br><p>  Além disso, a portabilidade consiste no fato de que, depois que a imagem do Docker for montada e funcionar corretamente, ela funcionará em qualquer lugar se o Docker funcionar lá, ou seja,  nos servidores Windows, Linux e MacOS. </p><br><h3 id="effektivnost">  Eficácia </h3><br><p>  Ao trabalhar com aplicativos de máquinas virtuais, você realmente precisa de processos de SO, programas de sistema etc.?  Como regra, não, apenas o processo do seu aplicativo é interessante.  Os contêineres fornecem exatamente isso: apenas os processos claramente necessários são iniciados no contêiner e nada mais.  Como os contêineres não exigem um sistema operacional separado, eles usam menos recursos.  Uma máquina virtual costuma ocupar vários gigabytes, enquanto um contêiner pode ser tão pequeno quanto alguns megabytes, o que permite executar muito mais contêineres do que máquinas virtuais em um único servidor. </p><br><p> Como os contêineres têm um nível mais alto de utilização do servidor, menos hardware é necessário, resultando em custos mais baixos. </p><br><h3 id="izolyaciya">  Isolamento </h3><br><p>  Os contêineres isolam o aplicativo de todos os outros processos e, embora vários contêineres possam ser executados no mesmo servidor, eles podem ser completamente independentes um do outro.  Qualquer interação entre contêineres deve ser declarada explicitamente.  Se um contêiner falhar, ele não afetará outros contêineres e poderá ser reiniciado rapidamente.  A segurança também é aprimorada por esse isolamento.  Por exemplo, explorar uma vulnerabilidade de servidor da web em um host pode dar ao invasor acesso a todo o servidor, mas no caso de um contêiner, um invasor terá acesso apenas ao contêiner do servidor da web. </p><br><h3 id="lyogkost">  Leveza </h3><br><p>  Como os contêineres não exigem um sistema operacional separado, eles podem ser iniciados, parados ou reiniciados em questão de segundos, o que acelerará todos os processos relacionados, incluindo os processos de Integração Contínua.  Você pode começar a desenvolver mais rápido e não perder tempo configurando seu ambiente. </p><br><h3 id="neizmennost-immutability">  Imutabilidade </h3><br><p>  A infraestrutura imutável consiste em componentes imutáveis ​​que são substituídos para cada implantação e não são atualizados.  A consistência reduz a inconsistência e permite replicar e mover com facilidade e rapidez entre os diferentes estados do seu aplicativo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais sobre imutabilidade</a> . </p><br><h2 id="novye-vozmozhnosti">  Novos recursos </h2><br><p>  Todos esses benefícios permitem gerenciar sua infraestrutura e aplicativos de uma nova maneira. </p><br><h3 id="orkestraciya">  Orquestração </h3><br><p>  Máquinas virtuais e servidores ao longo do tempo geralmente ganham "personalidade", o que leva a muitas surpresas geralmente desagradáveis ​​no futuro.  Uma solução para esse problema é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">infraestrutura como código</a> (IoC) - gerenciamento de infraestrutura usando um modelo descritivo usando um sistema de controle de versão. </p><br><p>  Ao usar a IoC, a equipe de implantação do ambiente sempre traz o ambiente de destino para a mesma configuração, independentemente do estado inicial do ambiente.  Isso é possível configurando automaticamente um ambiente existente ou recriando o ambiente do zero. </p><br><p>  Usando a IoC, os desenvolvedores fazem alterações na descrição do ambiente.  Posteriormente, o ambiente de destino é modificado para um novo estado.  Se você precisar fazer alterações na quarta-feira, sua descrição será editada. </p><br><p>  Tudo isso é muito mais fácil de fazer com contêineres.  Desligar o contêiner e iniciar um novo leva alguns segundos, e alocar uma nova máquina virtual leva alguns minutos. </p><br><h3 id="masshtabirovanie">  Dimensionamento </h3><br><p>  As ferramentas de orquestração também podem fornecer escala horizontal com base na carga atual.  É possível executar quantos contêineres forem necessários no momento e dimensionar o aplicativo de acordo.  Tudo isso também reduz o custo do aplicativo. </p><br><h1 id="konteynery-na-raznyh-etapah-zhiznennogo-cikla-po">  Contêineres em diferentes estágios do ciclo de vida do software </h1><br><p>  Considere os benefícios dos contêineres em vários estágios do ciclo de vida do software. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/639/58e/062/63958e06271594a0c8fbe5a8e8785ca7.png" alt="Ciclo de vida do software"></p><br><h2 id="razrabotka">  Desenvolvimento </h2><br><p> A vantagem mais importante é a facilidade de iniciar o desenvolvimento.  Após a <a href="">instalação do Docker</a> , basta executar dois comandos: <code>docker pull</code> para carregar a imagem e <code>docker run</code> para iniciá-lo.  Todas as dependências já foram resolvidas no estágio de criação do aplicativo. </p><br><h2 id="otladka">  Depuração </h2><br><p>  Todos os ambientes são consistentes e suas definições existem; além disso, é fácil implantar o ambiente necessário.  É o suficiente para fazer o <code>docker pull</code> o contêiner de interesse e executá-lo. </p><br><h2 id="testirovanie--qa">  Teste / controle de qualidade </h2><br><p>  No caso de um erro, o ambiente do problema e as condições para reproduzir o erro podem ser transferidos com o contêiner.  Todas as alterações na infraestrutura são "documentadas".  O número de variáveis ​​está diminuindo - versões de bibliotecas, estruturas, SO ... É possível executar vários contêineres para paralelizar testes. </p><br><h2 id="dostavka">  Entrega </h2><br><p>  O uso de contêineres permite criar uma vez, além de usar contêineres, você precisa de um alto nível de automação dos processos de montagem e implantação.  A entrega do contêiner de um aplicativo pode ser mais segura devido ao isolamento adicional. </p><br><h1 id="continuous-delivery">  Entrega contínua </h1><br><p>  Vamos passar da teoria para a prática.  Aqui está uma visão geral da nossa solução de automação de montagem e entrega: </p><br><p><img src="https://habrastorage.org/webt/yv/dn/qc/yvdnqcgyrlswgft4-zhnm-2mabc.png" alt="CD"></p><br><p>  Podem ser distinguidos três estágios principais: </p><br><ul><li>  Assembléia </li><li>  Entrega </li><li>  Lançamento </li></ul><br><h2 id="sborka">  Assembléia </h2><br><p>  No artigo anterior, a montagem foi incremental - consideramos a diferença entre o ambiente atual e a nova base de código e alteramos nosso ambiente para que correspondesse à nova base de código.  Com contêineres, cada montagem está completa.  O resultado da compilação é uma imagem do Docker que pode ser executada em qualquer lugar. </p><br><h2 id="dostavka-1">  Entrega </h2><br><p>  Depois que nossa imagem é compilada e testada, ela é carregada no Docker Registry, um aplicativo especializado para hospedar a imagem do Docker.  Lá, ele pode substituir a imagem anterior pelo mesmo nome (tag).  Por exemplo, devido a uma nova confirmação na ramificação mestre, montamos uma nova imagem ( <code>MyProject/MyApp:master</code> ) e, se os testes forem aprovados, podemos atualizar a imagem no Docker Registry e todos que <code>MyProject/MyApp:master</code> download do <code>MyProject/MyApp:master</code> terão uma nova versão. </p><br><h2 id="zapusk">  Lançamento </h2><br><p>  Finalmente, a imagem deve ser iniciada.  Um sistema de CD, como o GitLab, pode gerenciar isso diretamente ou com a ajuda de um orquestrador especializado, mas o processo geralmente é o mesmo - algumas imagens são iniciadas, verificadas periodicamente quanto ao desempenho e atualizadas se uma nova versão se tornar disponível. </p><br><p>  Confira o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webinar</a> explicando essas etapas. </p><br><p>  Como alternativa, em termos de confirmação: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ced/48d/84c/ced48d84c0a2213b3bd9c2bda109146e.png"></p><br><p>  Em nossa configuração de entrega contínua, nós: </p><br><ul><li>  Confirmar código no repositório GitLab </li><li>  Coletamos a imagem </li><li>  Testando </li><li>  Publique uma nova imagem em nosso Docker Registry </li><li>  Atualize o contêiner antigo para a nova versão do Docker Registry </li></ul><br><p>  Para isso, precisamos: </p><br><ul><li>  Docker </li><li>  Registro do Docker </li><li>  Domínio registrado (opcional, mas desejável) </li><li>  Ferramentas GUI (opcional) </li></ul><br><h3 id="docker">  Docker </h3><br><p>  Primeiro de tudo, precisamos iniciar o Docker.  Eu recomendaria começar com um único servidor com uma versão comum do Linux, como Ubuntu, RHEL ou Suse.  Não recomendo começar com distribuições como CoreOS, RancherOS etc. - elas não são direcionadas a iniciantes.  <a href="">Lembre-se de mudar o driver de armazenamento para devicemapper</a> . </p><br><p>  Se falamos de implantações em larga escala, usando ferramentas de orquestração como Kubernetes, Rancher ou Swarm, você pode automatizar a maioria das tarefas, mas não as discutiremos (pelo menos na estrutura deste artigo). </p><br><h3 id="docker-registry">  Registro do Docker </h3><br><p>  Este é o primeiro contêiner que precisamos executar, é um aplicativo independente que permite armazenar e distribuir imagens do Docker.  Você precisa usar o Docker Registry se desejar: </p><br><ul><li>  Controle onde suas imagens são armazenadas </li><li>  Possuir um servidor de distribuição de imagens </li><li>  Integre o armazenamento e a distribuição de imagens no processo de desenvolvimento </li></ul><br><p>  Aqui está a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> sobre como iniciar e configurar o Docker Registry. </p><br><h3 id="podklyuchenie-docker-registry-i-gitlab">  Conecte o Docker Registry e o GitLab </h3><br><p>  Para conectar o Docker Registry ao GitLab, é necessário executar o Docker Registry com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte HTTPS</a> .  Uso o Let's Encrypt para obter certificados e segui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta instrução</a> para obter um certificado.  Após verificar se o Docker Registry está acessível via HTTPS (você pode verificá-lo no navegador), siga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estas instruções</a> para conectar o Docker Registry ao GitLab.  Essas instruções diferem dependendo da instalação do GitLab e da configuração necessária.  No meu caso, a instalação foi adicionar o certificado e a chave do Docker Registry ao <code>/etc/gitlab/ssl</code> , e estas linhas ao <code>/etc/gitlab/gitlab.rb</code> : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">registry_external_url</span></span> <span class="hljs-string"><span class="hljs-string">'https://docker.domain.com'</span></span> gitlab_rails [<span class="hljs-string"><span class="hljs-string">'registry_api_url'</span></span>] = <span class="hljs-string"><span class="hljs-string">"https://docker.domain.com"</span></span></code> </pre> <br><p>  Após <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reconfigurar o GitLab</a> , uma nova guia Registro apareceu, fornecendo informações sobre como nomear corretamente as imagens criadas para que elas apareçam aqui. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a54/6b0/f85/a546b0f853ab022249ef03232927461d.png"></p><br><h3 id="domen">  Domínio </h3><br><p>  Em nossa configuração de entrega contínua, criaremos automaticamente uma imagem para cada filial e, se a imagem passar nos testes, ela será publicada no Docker Registry e será iniciada automaticamente, para que nosso aplicativo seja implantado automaticamente em todas as ramificações, por exemplo: </p><br><ul><li>  Vários ramos de <code>&lt;featureName&gt;.docker.domain.com</code> em <code>&lt;featureName&gt;.docker.domain.com</code> </li><li>  Versão de teste em <code>master.docker.domain.com</code> </li><li>  Versão de <code>preprod.docker.domain.com</code> em <code>preprod.docker.domain.com</code> </li><li>  Versão do produto em <code>prod.docker.domain.com</code> </li></ul><br><p>  Para fazer isso, precisamos de um nome de domínio e um registro DNS curinga que redirecione as solicitações para <code>* .docker.domain.com</code> para o endereço IP de <code>docker.domain.com</code> .  Como alternativa, você pode usar várias portas. </p><br><h3 id="nginx">  Nginx </h3><br><p>  Como temos vários ambientes, precisamos redirecionar automaticamente solicitações para subdomínios para o contêiner correto.  Para isso, podemos usar o Nginx como um proxy reverso.  Aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guia</a> . </p><br><h3 id="gui-instrumenty">  Ferramentas GUI </h3><br><p>  Para começar a trabalhar com contêineres, você pode usar a linha de comandos ou uma das interfaces gráficas.  Existem muitos disponíveis, por exemplo: </p><br><ul><li>  Rancheiro </li><li>  Microbadger </li><li>  Portainer </li><li>  Interface simples do docker </li><li>  ... </li></ul><br><p>  Eles permitem criar contêineres e gerenciá-los a partir da GUI em vez da CLI.  Aqui está como Rancher se parece: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/574/485/d9c/574485d9c01d464510f79097f6b823b4.png" alt="Rancheiro"></p><br><h3 id="gitlab-runner">  Corredor do Gitlab </h3><br><p>  Como antes, para executar scripts em outros servidores, precisamos instalar o corredor GitLab.  Esta pergunta é descrita em detalhes em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . </p><br><p>  Observe que você precisa usar o executor Shell, não o Docker.  O Executor Docker é usado quando você precisa de algo da imagem, por exemplo, ao criar um aplicativo Android em um contêiner java, e você só precisa de apk.  No nosso caso, o artefato é o contêiner inteiro, e isso requer o executor Shell. </p><br><h1 id="konfiguraciya-continuous-delivery">  Configuração de entrega contínua </h1><br><p>  Agora que todos os componentes necessários estão configurados, você pode começar a criar uma configuração de entrega contínua. </p><br><h2 id="sborka-1">  Assembléia </h2><br><p>  Primeiro, precisamos montar uma imagem. </p><br><p>  Nosso código, como sempre, é armazenado no repositório, a configuração do CD no <code>gitlab-ci.yml</code> , mas além disso (para melhorar a segurança), armazenaremos vários arquivos relacionados à imagem no servidor de compilação. </p><br><h3 id="gitlabxml">  Gitlab.xml </h3><br><p>  Contém código de retorno de chamada para CD.  Foi desenvolvido em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> e está disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Esta é uma pequena biblioteca para baixar código, executar vários retornos de chamada e código de teste.  É preferível usar submodules git para incluir este projeto ou algo semelhante em seu repositório.  Os submódulos são melhores porque é mais fácil mantê-los atualizados.  Outra alternativa é criar uma versão no GitLab e baixá-la usando o comando ADD já em tempo de construção. </p><br><h3 id="iriskey">  iris.key </h3><br><p>  Chave de licença.  Ele pode ser carregado durante a montagem do contêiner e não armazenado no servidor.  Não é seguro armazenar a chave no repositório.  Você pode obter uma chave de avaliação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no WRC</a> ou experimentar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">InterSystems IRIS Experience</a> . </p><br><h3 id="pwdtxt">  pwd.txt </h3><br><p>  Arquivo contendo a senha padrão.  Novamente, armazenar a senha no repositório é bastante inseguro. </p><br><h3 id="load_ciscript">  load_ci.script </h3><br><p>  Um script que: </p><br><ul><li>  Inclui <a href="">autenticação de SO</a> no InterSystems IRIS </li><li>  Carrega GitLab.xml </li><li>  Inicializa as configurações de retorno de chamada do GitLab </li><li>  Carrega código </li></ul><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ##Class(Security.System).Get(<span class="hljs-string"><span class="hljs-string">"SYSTEM"</span></span>,.Properties) write:(<span class="hljs-string"><span class="hljs-string">'sc) $System.Status.GetErrorText(sc) set AutheEnabled = Properties("AutheEnabled") set AutheEnabled = $ZBOOLEAN(+AutheEnabled,16,7) set Properties("AutheEnabled") = AutheEnabled set sc = ##Class(Security.System).Modify("SYSTEM",.Properties) write:('</span></span>sc) $System.Status.GetErrorText(sc) zn <span class="hljs-string"><span class="hljs-string">"USER"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%SYSTEM.OBJ).Load(##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%File).ManagerDirectory() _ <span class="hljs-string"><span class="hljs-string">"GitLab.xml"</span></span>,<span class="hljs-string"><span class="hljs-string">"cdk"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"hooks"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Hooks/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"tests"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Tests/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.GitLab).load() halt</code> </pre> <br><p>  Observe que a primeira linha é intencionalmente deixada em branco.  Se esse script inicial for sempre o mesmo, você poderá salvá-lo no repositório. </p><br><h2 id="gitlab-ciyml">  gitlab-ci.yml </h2><br><p>  Agora, vamos para a configuração de entrega contínua: </p><br><pre> <code class="hljs bash">build image: stage: build tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - cp -r /InterSystems/mount ci - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ci - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt - mv temp.txt load_ci.script - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. - docker build --build-arg CI_PROJECT_DIR=<span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_DIR</span></span> -t docker.domain.com/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> .</code> </pre> <br><p>  O que está acontecendo aqui? </p><br><p>  Primeiro, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o processo de montagem da imagem</a> pode acessar apenas subdiretórios do diretório base - no nosso caso, o diretório raiz do repositório, você precisa copiar o diretório "secret" (que possui <code>GitLab.xml</code> , <code>iris.key</code> , <code>pwd.txt</code> e <code>load_ci.skript</code> ) para repositório clonado. </p><br><p>  Além disso, é necessário um usuário / senha para acessar o terminal, portanto os adicionaremos ao <code>load_ci.script</code> (para isso, precisamos de uma linha vazia no início do <code>load_ci.script</code> ). </p><br><p>  Por fim, criamos uma imagem do Docker e a denominamos: <code>docker.domain.com/test/docker:$CI_COMMIT_REF_NAME</code> </p><br><p>  onde <code>$CI_COMMIT_REF_NAME</code> é o nome da ramificação.  Observe: a primeira parte da tag da imagem deve corresponder ao nome do repositório no GitLab para que possa ser vista na guia Registro (instruções mais completas para a marcação correta estão disponíveis lá). </p><br><h3 id="dockerfile">  Dockerfile </h3><br><p>  A imagem do Docker é criada usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dockerfile</a> , aqui está: </p><br><pre> <code class="hljs mel">FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.613</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> ENV SRC_DIR=/tmp/src ENV CI_DIR=$SRC_DIR/ci ENV CI_PROJECT_DIR=$SRC_DIR COPY ./ $SRC_DIR RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/<span class="hljs-keyword"><span class="hljs-keyword">pwd</span></span>.txt \ &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME \ &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script \ &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly</code> </pre> <br><p>  As seguintes ações são executadas: </p><br><ul><li>  Tomamos a imagem do InterSystems IRIS como base.  Ele deve estar no seu Registro do Docker.  Se você nunca trabalhou com o Docker antes, tente <a href="">First Look: Docker</a> , que descreve como obter uma imagem IRIS da InterSystems, adicione-a ao Registro do Docker e inicie-a manualmente. </li><li>  Primeiro, copie nosso repositório (e o diretório "secreto") dentro do contêiner. </li><li>  Copie a chave de licença e <code>GitLab.xml</code> para o diretório <code>mgr</code> . </li><li>  Altere a senha para o valor de <code>pwd.txt</code> .  Observe que o <code>pwd.txt</code> é excluído durante esta operação. </li><li>  Inicia o InterSystems IRIS. </li><li>  O <code>load_ci.script</code> é <code>load_ci.script</code> . </li><li>  O InterSystems IRIS para. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Aqui está um log de construção parcial</b> <div class="spoiler_text"><pre> <code class="hljs perl">Running with gitlab-runner <span class="hljs-number"><span class="hljs-number">10.6</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> (a3543a27) on docker <span class="hljs-number"><span class="hljs-number">7</span></span>b21e0c4 Using Shell executor... Running on docker... Fetching changes... Removing ci/ Removing temp.txt HEAD is now at <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904 Build load_ci.script From http:<span class="hljs-regexp"><span class="hljs-regexp">//gitlab</span></span>.eduard.win/test/docker <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904..<span class="hljs-number"><span class="hljs-number">9753</span></span>a8d master -&gt; origin/master Checking out <span class="hljs-number"><span class="hljs-number">9753</span></span>a8db as master... Skipping Git submodules setup $ cp -r /InterSystems/mount ci $ cd ci $ echo <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt $ mv temp.txt load_ci.script $ cd .. $ docker build --build-arg CI_PROJECT_DIR=$CI_PROJECT_DIR -t docker.eduard.win/test/docker:$CI_COMMIT_REF_NAME . Sending build context to Docker daemon <span class="hljs-number"><span class="hljs-number">401.4</span></span>kB Step <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span>.<span class="hljs-number"><span class="hljs-number">1.613</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ---&gt; cd2e53e7f85<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV SRC_DIR=<span class="hljs-regexp"><span class="hljs-regexp">/tmp/src</span></span> ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">68</span></span>ba1cb00aff Step <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_DIR=$SRC_DIR/ci ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">6784</span></span>c34a9ee6 Step <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_PROJECT_DIR=$SRC_DIR ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">3757</span></span>fa88a28a Step <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : COPY ./ $SRC_DIR ---&gt; <span class="hljs-number"><span class="hljs-number">5515</span></span>e13741b<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/pwd.txt &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly ---&gt; Running in <span class="hljs-number"><span class="hljs-number">86526183</span></span>cf7c . Waited <span class="hljs-number"><span class="hljs-number">1</span></span> seconds <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> InterSystems IRIS to start This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement %SYS&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> %SYS&gt; Using <span class="hljs-string"><span class="hljs-string">'iris.cpf'</span></span> configuration file This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement <span class="hljs-number"><span class="hljs-number">1</span></span> alert(<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>) during startup. See messages.log <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. Starting IRIS Node: <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6, Instance: IRIS Username: Password: Load started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> Loading file /usr/irissys/mgr/GitLab.xml as xml Load finished successfully. USER&gt; USER&gt; [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Running init hooks: before [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Importing hooks dir /tmp/src/MyApp/Hooks/ [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.374</span></span>] Executing hook class: MyApp.Hooks.Global [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Importing dir /tmp/src/ Loading file /tmp/src/MyApp/Tests/TestSuite.cls as udl Compilation started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span> with qualifiers <span class="hljs-string"><span class="hljs-string">'c'</span></span> Compilation finished successfully in <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">194</span></span>s. Load finished successfully. [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.876</span></span>] Running init hooks: after [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.878</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.921</span></span>] Executing hook class: MyApp.Hooks.Global Removing intermediate container <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6 ---&gt; dea6b2123165 [Warning] One <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> more build-args [CI_PROJECT_DIR] were <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> consumed Successfully built dea6b2123165 Successfully tagged docker.domain.com/test/docker:master Job succeeded</code> </pre> </div></div><br><h2 id="zapusk-1">  Lançamento </h2><br><p>  Temos uma imagem, corra.  No caso de ramificações de recursos, você pode simplesmente destruir o contêiner antigo e iniciar um novo.  No caso do ambiente do produto, podemos iniciar o contêiner temporário primeiro e substituir o contêiner médio se os testes forem aprovados com êxito. </p><br><p>  Primeiro, o script para excluir o contêiner antigo. </p><br><pre> <code class="hljs ruby">destroy <span class="hljs-symbol"><span class="hljs-symbol">old:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">stage:</span></span> destroy <span class="hljs-symbol"><span class="hljs-symbol">tags:</span></span> - test <span class="hljs-symbol"><span class="hljs-symbol">script:</span></span> - docker stop iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> - docker rm -f iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Esse script destrói o contêiner em execução e sempre é bem-sucedido (por padrão, o Docker retorna um erro ao tentar parar / excluir um contêiner inexistente). </p><br><p>  Depois disso, lançamos um novo contêiner e o registramos como um ambiente. </p><br><pre> <code class="hljs powershell">run image: stage: run environment: name: <span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> url: http://<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win/index.html tags: - test script: - docker run <span class="hljs-literal"><span class="hljs-literal">-d</span></span> -<span class="hljs-literal"><span class="hljs-literal">-expose</span></span> <span class="hljs-number"><span class="hljs-number">52773</span></span> -<span class="hljs-literal"><span class="hljs-literal">-volume</span></span> /InterSystems/durable/<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG:</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> ISC_DATA_DIRECTORY=/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/sys -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> VIRTUAL_HOST=<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win -<span class="hljs-literal"><span class="hljs-literal">-name</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> docker.eduard.win/test/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> -<span class="hljs-literal"><span class="hljs-literal">-log</span></span> <span class="hljs-variable"><span class="hljs-variable">$ISC_PACKAGE_INSTALLDIR</span></span>/mgr/messages.log</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O contêiner Nginx</a> redireciona automaticamente as solicitações usando a <code>VIRTUAL_HOST</code> ambiente <code>VIRTUAL_HOST</code> para a porta especificada - nesse caso, 52773. </p><br><p>  Como é necessário armazenar alguns dados (senhas,% SYS, dados do aplicativo) no host no InterSystems IRIS, existe a funcionalidade <a href="">Durable% SYS</a> que permite armazenar dados no host, como: </p><br><ul><li>  <code>iris.cpf</code> é o principal arquivo de configuração. </li><li>  O <code>/csp</code> com arquivos de aplicativos da web. </li><li>  <code>/httpd/httpd.conf</code> com configuração privada do servidor Apache. </li><li>  O diretório <code>/mgr</code> no qual estão armazenados: <br><ul><li>  Bases de dados <code>IRISSYS</code> , <code>IRISTEMP</code> , <code>IRISAUDIT</code> , <code>IRIS</code> , <code>USER</code> . </li><li>  <code>IRIS.WIJ</code> . </li><li>  Diretório <code>/journal</code> armazena revistas. </li><li>  O diretório <code>/temp</code> para arquivos temporários. </li><li>  Registra <code>messages.log</code> , <code>journal.log</code> , <code>SystemMonitor.log</code> . </li></ul></li></ul><br><p>  Para ativar o Durable% SYS, é especificado o argumento do <code>volume</code> que <code>ISC_DATA_DIRECTORY</code> diretório <code>ISC_DATA_DIRECTORY</code> host e a variável <code>ISC_DATA_DIRECTORY</code> define o diretório para armazenar os arquivos Durable% SYS.  Este diretório não deve existir, será criado automaticamente. </p><br><p>  Assim, a arquitetura do nosso aplicativo em contêiner é a seguinte: </p><br><p><img src="https://habrastorage.org/webt/61/0q/ze/610qzezlqdilphfkapj5vac9t84.png" alt="arquitetura de aplicativo em contêiner"></p><br><p>  Para criar um aplicativo, precisamos pelo menos criar um banco de dados adicional (para salvar o código do aplicativo) e criar seu mapeamento na área de aplicativo.  Usei o escopo <code>USER</code> para armazenar dados do aplicativo, pois esse escopo foi adicionado ao Durable% SYS por padrão.  O código do aplicativo é armazenado em um contêiner para que possa ser atualizado. </p><br><p>  Com base no exposto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">% Installer</a> deve: </p><br><ul><li>  Criar área de <code>APP</code> / banco de dados </li><li>  Carregar código para a área <code>APP</code> </li><li>  Crie classes de mapeamento de nosso aplicativo na área <code>USER</code> </li><li>  Executar outra configuração (criei um aplicativo Web CSP e um aplicativo Web REST) </li></ul><br><div class="spoiler">  <b class="spoiler_title">Código% Instalador</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span> { Parameter Namespace = "APP"; /// See <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zsetup+<span class="hljs-number"><span class="hljs-number">1</span></span>^MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> XData Install [ XMLNamespace = INSTALLER ] { &lt;Manifest&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" Code="${Namespace}" Ensemble="" Data="IRISTEMP"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Database</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" Dir="/usr/irissys/mgr/${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span> File="${Dir}Form" Recurse="1" Flags="cdk" IgnoreErrors="1" /&gt; &lt;/Namespace&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="End Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping to USER" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="USER" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="no" Code="USER" Data="USER" Ensemble="0"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping Form package to USER namespace" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;ClassMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" Package="Form"/&gt; &lt;RoutineMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Routines</span></span>="Form" /&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;CSPApplication Url="/" Directory="${Dir}client" AuthenticationMethods="64" IsNamespaceDefault="false" <span class="hljs-keyword"><span class="hljs-keyword">Grant</span></span>="%ALL" Recurse="1" /&gt; &lt;/Namespace&gt; &lt;/Manifest&gt; } /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> generator whose code <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> XGL. /// Main setup <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> /// <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace")="TEMP3" /// <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Global</span></span>).setup(.vars) ClassMethod setup(ByRef pVars, pLogLevel <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %<span class="hljs-type"><span class="hljs-type">Integer</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, pInstaller <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Installer.Installer) <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status [ CodeMode = objectgenerator, <span class="hljs-type"><span class="hljs-type">Internal</span></span> ] { Quit ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(%Installer.Manifest).%Generate(%compiledclass, %code, "Install") } /// Entry <span class="hljs-type"><span class="hljs-type">point</span></span> ClassMethod onAfter() <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { try { <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> "START INSTALLER",! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace") = ..#Namespace <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Dir") = ..getDir() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..setup(.vars) <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..createWebApp() } catch ex { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ex.AsStatus() <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! } quit sc } /// Modify web app REST ClassMethod createWebApp(appName <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %String = "/forms") <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>:$e(appName)<span class="hljs-string"><span class="hljs-string">'="/" appName = "/" _ appName #dim sc As %Status = $$$OK new $namespace set $namespace = "%SYS" if '</span></span>##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Security</span></span>.Applications).<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>(appName) { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("AutheEnabled") = $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AutheUnauthenticated</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"NameSpace"</span></span></span><span class="bash">) = </span><span class="hljs-string"><span class="bash"><span class="hljs-string">"USER"</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"IsNameSpaceDefault"</span></span></span><span class="bash">) = $$</span></span>$<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("DispatchClass") = "Form.REST.Main" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("MatchRoles")=":" _ $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AllRoleName</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> sc = </span><span class="hljs-comment"><span class="bash"><span class="hljs-comment">##class(Security.Applications).Create(appName, .props) } quit sc } ClassMethod getDir() [ CodeMode = expression ] { ##class(%File).NormalizeDirectory($system.Util.GetEnviron("CI_PROJECT_DIR")) } }</span></span></span></span></code> </pre> </div></div><br><p>  Observo que, para criar um banco de dados que não esteja no host, uso o diretório <code>/usr/irissys/mgr</code> , pois a chamada <code>##class(%File).ManagerDirectory()</code> retorna o caminho para o diretório do Durable% SYS. </p><br><h2 id="testy">  Testes </h2><br><p>  Agora execute os testes. </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span> image: stage: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - docker <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> irissession iris -U USER <span class="hljs-string"><span class="hljs-string">"##class(isc.git.GitLab).test()"</span></span></code> </pre> <br><h2 id="dostavka-2">  Entrega </h2><br><p>  Após os testes, publicaremos nossa imagem no Docker Registry. </p><br><pre> <code class="hljs pgsql">publish image: stage: publish tags: - test script: - docker <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com -u <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> -p pass - docker push docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com/test/docker:$CI_COMMIT_REF_NAME</code> </pre> <br><p>  O login / senha pode ser passado usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">variáveis ​​secretas</a> . </p><br><p>  Agora a imagem é exibida no GitLab. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/0b3/56f/0640b356f33ea72491c91d55399a4670.png"></p><br><p>  E outros desenvolvedores podem fazer o download no Docker Registry.  Na guia Ambientes, todos os nossos ambientes estão disponíveis para visualização: </p><br><h1 id="vyvody">  Conclusões </h1><br><p>  Esta série de artigos discute abordagens comuns à integração contínua.  Automatizar a montagem, teste e entrega do seu aplicativo nas plataformas da InterSystems é possível e fácil de implementar. </p><br><p>  O uso de tecnologias de conteinerização ajudará a otimizar os processos de desenvolvimento e implantação de aplicativos.  A eliminação de inconsistências entre ambientes facilita o teste e a depuração.  A orquestração permite criar aplicativos escaláveis. </p><br><h1 id="ssylki">  Referências </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo anterior</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">InterSystems Community Series</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Código</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Código do Github</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420749/">https://habr.com/ru/post/pt420749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420731/index.html">Zabbix em esteróides: como funciona a plataforma de monitoramento unificado da Sbertech</a></li>
<li><a href="../pt420735/index.html">Convidamos você para o final da maratona Encontre-se na Digital no escritório do Mail.Ru Group</a></li>
<li><a href="../pt420737/index.html">Mini taça ai 2 ou quase AgarIO - o que poderia ser feito para vencer</a></li>
<li><a href="../pt420739/index.html">A caixa ainda está disponível: por que em 2018 você ainda precisa aprender idiomas</a></li>
<li><a href="../pt420741/index.html">Folha de dicas para programadores ou "procuraremos no Google por você"</a></li>
<li><a href="../pt420753/index.html">Front-end de microsserviço - uma abordagem moderna para a separação da frente</a></li>
<li><a href="../pt420757/index.html">Concurso de Programação: Comércio (Resultados)</a></li>
<li><a href="../pt420761/index.html">TypeScript 3.0</a></li>
<li><a href="../pt420763/index.html">KDD 2018, segundo dia, workshops</a></li>
<li><a href="../pt420765/index.html">Impressões do PDA Gemini. Colheitadeira de bolso com bota dupla ou brinquedo inútil?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>