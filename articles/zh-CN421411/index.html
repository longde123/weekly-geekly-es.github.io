<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😉 🤘🏼 🐳 Go模块简介 🤱🏽 ☝🏼 🚵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go编程语言的1.11版即将发布，将为模块带来实验性支持-一种新的Go依赖管理系统。 （注意翻译：发生了发布 ） 


 最近， 我已经写了一篇关于此的小文章 。 从那以后，有些事情发生了些微变化，并且我们离发行版越来越近了，所以在我看来，现在是时候撰写新文章了-让我们添加更多练习。 


 因此，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go模块简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  Go编程语言的1.11版即将发布，将为<em>模块</em>带来实验性支持-一种新的Go依赖管理系统。  （注意翻译：发生了<a href="">发布</a> ） </p><br><p> 最近， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我已经写了一篇关于此的小文章</a> 。 从那以后，有些事情发生了些微变化，并且我们离发行版越来越近了，所以在我看来，现在是时候撰写新文章了-让我们添加更多练习。 </p><br><p> 因此，这就是我们要做的事情：创建一个新程序包，然后发布一些版本以查看其工作方式。 </p><a name="habracut"></a><br><h2 id="sozdanie-modulya"> 模块创建 </h2><br><p>首先，创建我们的包。 我们称之为testmod。 重要信息： <strong>软件包目录应放置<em>在</em> <code>$GOPATH</code> ，因为在其中，默认情况下禁用了模块支持</strong> 。  Go模块是将来完全放弃<code>$GOPATH</code> 。 </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p> 我们的包很简单： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p> 该软件包已准备就绪，但尚未成为<em>模块</em> 。 让我们修复它。 </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p> 软件包目录中有一个名为<code>go.mod</code>的新文件，其内容如下： </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p> 有点，但这就是将我们的包变成<em>模块的原因</em> 。 </p><br><p> 现在我们可以将此代码推送到存储库中： </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p> 到目前为止，任何想使用我们软件包的人都可以申请<code>go get</code> ： </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p> 该命令将从<code>master</code>分支中获取最新代码。 此选项仍然有效，但是如果我们不再这样做，那就更好了，因为现在“有更好的方法”。 实际上，直接从<code>master</code>分支获取代码是危险的，因为我们永远无法确定软件包的作者没有做出会“破坏”我们代码的更改。 为了解决这个问题，发明了Go模块。 </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley"> 关于版本控制模块的一点题外话 </h2><br><p>  Go模块是版本控制的，另外，各个版本也有一些特殊性。 您将必须熟悉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语义版本控制</a>的概念。 </p><br><p> 此外，Go在查找版本时会使用存储库标签，并且某些版本与其余版本有所不同：例如，版本2和更高版本的导入路径必须与版本0和版本1不同（我们将介绍到此）。 </p><br><p> 默认情况下，Go下载最新<em>版本，该版本</em>在存储库中<em>具有</em>可用<em>的标记</em> 。 <br> 这是一项重要功能，因为在使用<code>master</code>分支时可以使用它。 </p><br><p> 对于我们来说，现在重要的是，在创建程序包的发行版时，我们需要在版本库中放置带有版本的标签。 </p><br><p> 来吧 </p><br><h2 id="delaem-svoy-pervyy-reliz"> 首次发布 </h2><br><p> 我们的包装已准备就绪，我们可以将其“推广”到全世界。 我们使用版本化标签来实现。 设置版本号为1.0.0： </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p> 这些命令在我的Github存储库中创建一个标记，将当前提交标记为1.0.0版。 </p><br><p>  Go并不坚持这样做，但是最好创建一个新的分支（“ v1”），我们可以将补丁发送到该分支。 </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p> 现在，我们可以在<code>master</code>分支中工作，而不必担心我们会破坏发行版。 </p><br><h2 id="ispolzovanie-nashego-modulya"> 使用我们的模块 </h2><br><p> 让我们使用创建的模块。 我们将编写一个简单的程序来导入我们的新包： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p> 到现在为止，您可以运行<code>go get github.com/robteix/testmod</code>来下载软件包，但是使用模块，它会变得更加有趣。 首先，我们需要在新程序中启用模块支持。 </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p> 如您所料，根据您​​先前阅读的内容，目录<code>go.mod</code>出现一个新的<code>go.mod</code>文件，其中的模块名称为： </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p> 当我们尝试将程序组合在一起时，情况变得更加有趣： </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p> 如您所见， <code>go</code>命令自动找到并下载了我们程序导入的包。 <br> 如果我们检查<code>go.mod</code>文件，我们将看到某些变化： </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p> 我们得到了另一个名为<code>go.sum</code>新文件，其中包含用于检查正确版本和文件的软件包的哈希值。 </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki"> 制作错误修复版本 </h2><br><p> 现在，假设我们在程序包中发现了一个问题：问候语中没有标点符号！ <br> 有些人会大怒，因为我们的友好问候已经不再那么友好了。 <br> 让我们修复此问题并发布新版本： </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p> 我们直接在<code>v1</code>分支中进行了此更改，因为它与我们接下来在<code>v2</code>分支中将要进行的操作无关，但是在现实生活中，也许您应该在<code>master</code>进行这些更改，然后将它们反向移植到<code>v1</code> 。 无论如何，此修复程序应位于<code>v1</code>分支中，我们需要将其标记为新版本。 </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley"> 模块更新 </h2><br><p> 默认情况下，Go不会在没有需求的情况下更新模块。  “那很好，”因为我们都希望构建的可预测性。 如果每次发布新版本时Go模块都会自动更新，我们将返回“ Go1.11之前的黑暗时代”。 但是不，我们需要<em>告诉</em> Go为我们更新模块。 </p><br><p> 我们将在我们的老朋友的帮助下做到这一点<code>go get</code> ： </p><br><ul><li><p> 运行<code>go get -u</code>以使用最新的<em>次要版本或补丁程序</em>版本（即，如果该版本可用，则命令将从1.0.0更新为1.0.1或更新为1.1.0）。 </p><br></li><li><p> 运行<code>go get -u=patch</code>以使用最新的修补程序版本（即，该软件包将更新为1.0.1，但<em>不会</em>更新为1.1.0） </p><br></li><li><p> 运行<code>go get package@version</code>升级到特定版本（例如， <code>github.com/robteix/testmod@v1.0.1</code> ） </p><br></li></ul><br><p> 此列表中没有办法升级到最新的<em>主要</em>版本。 我们很快就会看到，这样做有充分的理由。 </p><br><p> 由于我们的程序使用了软件包的1.0.0版本，并且我们刚刚创建了1.0.1版本，因此以下<em>任何</em>命令会将我们更新为1.0.1： </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p> 启动后（假设<code>go get -u</code> ），我们的<code>go.mod</code>已更改： </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii"> 主要版本 </h2><br><p> 根据语义版本控制的规范，主要版本<em>与</em>次要版本<em>不同</em> 。 主要版本可能会破坏向后兼容性。 从Go模块的角度来看，主要版本是一个完全<em>不同的包</em> 。 </p><br><p> 乍一看听起来很疯狂，但这是有道理的：两个不兼容的库版本是两个不同的库。 </p><br><p> 让我们对程序包进行重大更改。 假设随着时间的流逝，我们已经很清楚我们的API太简单了，对于我们用户的用例来说太局限了，因此我们需要更改<code>Hi()</code>函数以接受欢迎语言作为参数： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¡Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p> 使用我们的API的现有程序会中断，因为它们a）不会将语言作为参数传递，并且b）不会返回错误。 我们的新API不再与1.x版兼容，因此请符合2.0.0版。 </p><br><p> 我之前提到过某些版本具有功能，现在是这种情况。 <br>  <strong>版本2 <em>或更高版本</em>应更改导入路径。</strong> 现在这些是不同的库。 </p><br><p> 我们将通过在模块名称中添加新<em>版本的路径</em>来做到这一点。 </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p> 其他所有内容都相同：推送并放置一个标签，该标签为v2.0.0（并有选择地添加分支v2） </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii"> 主要版本更新 </h2><br><p> 即使我们发布了库的新不兼容版本，现有程序<em>也没有中断</em> ，因为它们继续使用版本1.0.1。 <br>  <code>go get -u</code> <em>将不会</em>下载版本2.0.0。 </p><br><p> 但是在某个时候，我（作为库用户）可能希望升级到2.0.0版本，因为例如，我是需要多种语言支持的用户之一。 </p><br><p> 要更新，我需要相应地更改程序： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p> 现在，当我运行<code>go build</code> ，它将“退出”并为我下载2.0.0版。 请注意，尽管导入路径现在以“ v2”结尾，但Go仍以其真实名称（“ testmod”）引用该模块。 </p><br><p> 正如我所说，主要版本在各个方面都是不同的软件包。 这两个Go模块没有以任何方式连接。 这意味着我们可以在一个二进制文件中有两个不兼容的版本： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p> 当依赖项依赖于同一库的不同版本时，这消除了依赖项管理的常见问题。 </p><br><h2 id="navodim-poryadok"> 我们把事情整理好 </h2><br><p> 让我们回到以前的版本，该版本仅使用testmod 2.0.0-如果现在检查<code>go.mod</code>的内容，我们会注意到： </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p> 默认情况下，除非您要求，Go不会从<code>go.mod</code>删除依赖<code>go.mod</code> 。 如果您有不再需要的依赖项并且想要清除它们，则可以使用新的<code>tidy</code>命令： </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p> 现在，我们只有真正使用的依赖项。 </p><br><h2 id="vendoring"> 贩卖 </h2><br><p> 默认情况下，转到模块忽略<code>vendor/</code>目录。 这个想法是逐步摆脱自动贩卖<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a></sup> 。 但是，如果我们仍然想将“分离的”依赖项添加到我们的版本控制中，则可以执行以下操作： </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p> 团队将在我们项目的根目录下创建<code>vendor/</code>目录，其中包含所有依赖项的源代码。 </p><br><p> 但是，默认情况下， <code>go build</code>仍会忽略此目录的内容。 如果要从<code>vendor/</code>目录收集依赖关系，则必须明确要求它。 </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p> 我假设许多想使用自动售货的开发人员将像往常一样在其计算机上运行<code>go build</code>并在其CI上使用<code>-mod vendor</code> 。 </p><br><p> 再次，Go模块正在从自动售货的想法转变为对那些不想直接依赖上游版本控制服务的用户使用代理作为模块。 </p><br><p> 有多种方法可以确保无法使用<code>go</code>网络（例如，使用<code>GOPROXY=off</code> ），但这是下一篇文章的主题。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 对于某些人来说，这篇文章可能看起来很复杂，但这是因为我试图一次解释很多。 现实是，Go模块今天通常很简单-我们像往常一样将包导入到我们的代码中，而<code>go</code>团队则为我们完成其余的工作。 在组装过程中将自动加载依赖项。 </p><br><p> 这些模块还消除了对<code>$GOPATH</code>的需要，这对于新的Go开发人员是一个绊脚石，他们在理解为什么要在特定目录中放置内容时遇到了麻烦。 </p><br><p><del> 自动售货（非正式地）已被弃用，以支持使用代理。 </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1个</a></sup> <br> 我可以撰写有关Go模块代理的单独文章。 </p><br><p> 注意事项： </p><br><p>  <sup>1</sup>我认为这是一个太大声的表达，有些人可能会觉得现在正在取消自动售货机。 事实并非如此。 自动售货仍在起作用，尽管与以前略有不同。 显然，人们希望用更好的东西来代替自动售货机，例如代理（不是事实）。 到目前为止，这仅仅是追求更好的解决方案。 除非找到合适的替代品（如果有），自动售货就不会消失。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421411/">https://habr.com/ru/post/zh-CN421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421399/index.html">Turla Cyber​​group Outlook后门分析</a></li>
<li><a href="../zh-CN421401/index.html">推荐系统剖析。 第二部分</a></li>
<li><a href="../zh-CN421403/index.html">安全周32：Fortnite-Android电视剧</a></li>
<li><a href="../zh-CN421407/index.html">9月13日在圣彼得堡举行技术会议-如何在后端进行重大更改</a></li>
<li><a href="../zh-CN421409/index.html">间谍内容：保守秘密</a></li>
<li><a href="../zh-CN421413/index.html">通过Java 8、9、10中的反射正确访问默认接口方法</a></li>
<li><a href="../zh-CN421415/index.html">魔术飞跃-悲伤的垃圾</a></li>
<li><a href="../zh-CN421417/index.html">吸咖啡者专用咖啡机，或Wacaco移动咖啡机</a></li>
<li><a href="../zh-CN421419/index.html">“泡沫”镍，不存在的蓝宝石和苏联副部长的颂歌：日本，美国和苏联的标志性OTTO SX-P1</a></li>
<li><a href="../zh-CN421421/index.html">LAppS：一个CPU上每秒有TLS的半百万1KB-WebSocket消息</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>