<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎙️ 🙋🏼 🤾🏻 Qt异步异步小部件库 👨🏿‍🌾 🧒🏼 ✊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="祝大家好。 我想谈谈我的qt-async项目，也许对某人来说似乎很有意思甚至有用。 

 长期以来，异步和多线程已被认真地包含在开发人员的日常生活中。 许多现代语言和库在设计时都考虑了异步使用。 C ++语言也在朝着这个方向缓慢发展-std ::线程，std :: promise /未来已经出现，它...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt异步异步小部件库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451722/">祝大家好。 我想谈谈我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-async</a>项目，也许对某人来说似乎很有意思甚至有用。 <br><br> 长期以来，异步和多线程已被认真地包含在开发人员的日常生活中。 许多现代语言和库在设计时都考虑了异步使用。  C ++语言也在朝着这个方向缓慢发展-std ::线程，std :: promise /未来已经出现，它们即将引入协程和网络。  Qt库也不会落后，它提供了类似的QThread，QRunnable，QThreadPool，QFuture等。 同时，我没有找到用于在Qt中显示异步操作的小部件（也许我看上去很糟，如果我弄错了，请更正）。 <br><br> 因此，我决定弥补这一缺点，并尝试自己实现这种小部件。 多线程开发是一项复杂但有趣的业务。 <br><a name="habracut"></a><br> 在继续执行小部件之前，您需要描述将以窗口形式呈现给用户的模型。 在其最一般的形式中，小部件的操作在我看来如下：在某个时间点，用户或系统启动异步操作。 此时，小部件将显示操作进度或仅显示操作指示。 用户可以选择取消操作。 接下来，以两种方式完成异步操作：发生错误并在我们的小部件中显示该错误，或​​者该小部件显示成功操作的结果。 <br><br> 因此，我们的模型可以处于以下三种状态之一： <br><br><ol><li> 进度-正在进行异步操作 </li><li> 错误-异步操作失败 </li><li> 值-异步操作成功完成 </li></ol><br> 在每种状态下，模型都必须存储相应的数据，因此我将其称为AsyncValue模型。 重要的是要注意，异步操作本身不是我们模型的一部分，它只会切换其状态。 事实证明，AsyncValue可以与任何异步库一起使用，遵循一个简单的用法模式： <br><br><ol><li> 在异步操作开始时，将AsuncValue设置为Progress </li><li> 最后-根据操作的成功，是错误还是价值 </li><li>  （可选）在操作过程中，如果用户有机会停止操作，则可以更新“进度”数据并收听“停止”标志。 </li></ol><br> 这是使用QRunnable的示意图示例： <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRunnable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QRunnable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyRunnable(AsyncValue&amp; value) : m_value(value) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> final </span></span>{ m_value.setProgress(...); <span class="hljs-comment"><span class="hljs-comment">// do calculation if (success) m_value.setValue(...); else m_value.setError(...); } private: AsyncValue&amp; m_value; }</span></span></code> </pre> <br> 使用std :: thread的相同方案： <br><br><pre> <code class="cpp hljs">AsyncValue value; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;value] () { value.setProgress(...); </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// do calculation if (success) value.setValue(...); else value.setError(...); });</span></span></span></span></span></span></code> </pre><br> 因此，该类的第一个版本可能如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ProgressType_t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = ValueType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ErrorType = ErrorType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ProgressType = ProgressType_t; <span class="hljs-comment"><span class="hljs-comment">// public API private: QReadWriteLock m_lock; std::variant&lt;ValueType, ErrorType, ProgressType&gt; m_value; };</span></span></code> </pre><br> 每个遇到支持多线程的类的人都知道，此类的接口与单线程类似物不同。 例如，在多线程向量中，size（）函数是无用的且危险的。 由于向量可以在另一个线程中修改，因此其结果可能立即变得无效。 <br><br>  AsyncValue类的用户应该能够访问类数据。 发行数据的副本可能很昂贵，ValueType / ErrorType / ProgressType的任何类型都可能很繁重。 发布指向内部数据的链接很危险-在任何时候它都可能变得无效。 提出以下解决方案： <br><br>  1.通过函数accessValue / accessError / accessProgress授予对数据的访问权限，在其中接收接收相应数据的lambda。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pred valuePred)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">QReadLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_value.index() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; valuePred(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(m_value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br> 因此，内部值的访问是通过引用进行的，并且处于读取锁定的状态。 即，访问时的链接不会变为无效。 <br><br>  2. accessValue函数中的AsyncValue用户可以记住指向内部数据的链接，前提是该用户已订阅stateChanged信号，并且在处理该信号之后，该不再必须使用此链接，因为 她将变得无效。 <br><br> 在这种情况下，始终保证AsyncValue使用者具有有效且方便的数据访问。 此解决方案有几种影响AsyncValue类的实现的后果。 <br><br> 首先，当状态改变时，我们的类应该发送信号，但同时它是模板。 我们必须添加一个基本的Qt类，在这里我们可以确定小部件更新其内容的信号，所有感兴趣的人都将更新与内部数据的链接。 <br><br><pre> <code class="cpp hljs">lass AsyncValueBase : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_DISABLE_COPY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AsyncValueBase)</span></span></span><span class="hljs-function"> signals: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br> 其次，应该阻止发送信号的时刻进行读取（以使AsyncValue直到每个人都处理完该信号后才能更改），并且<i>最重要的是</i> ，那一刻应该存在指向新旧数据的有效链接。 因为在发送信号的过程中，某些AsyncValue使用者仍然使用旧的链接，而处理信号的人则使用新的链接。 <br><br> 事实证明std :: variant不适合我们，我们必须将数据存储在动态内存中，以便新旧数据的地址不变。 <br><br> 一个小题外话。 <br><br> 您可以考虑不需要动态分配的AsyncValue类的其他实现： <br><br><ol><li> 仅向消费者提供AsyncValue内部数据的副本。 如我之前所写，如果数据很大，则这种解决方案可能不是最佳选择。 </li><li> 定义两个信号而不是一个：stateWillChange / stateDidChange。 迫使消费者在第一个信号处摆脱旧的链接，而在第二个信号处接受新的链接。 在我看来，这种方案使AsyncValue使用者过于复杂，因为 当拒绝访问AsyncValue时，它们具有时间间隔。 </li></ol><br> 获得setValue函数的以下示意性实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncValue::setValue(...) {  m_lock            {   m_lock          m_lock   }  stateChanged       m_lock   };</code> </pre><br> 如您所见，我们需要增加用于写入的m_lock锁，并将其返回以进行读取。 不幸的是，QReadWriteLock类没有这种支持。 您可以使用一对QMutex / QReadWriteLock实现所需的功能。 这是AsyncValue类的实现，非常接近于实际： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   AsyncValue enum class ASYNC_VALUE_STATE { VALUE, ERROR, PROGRESS }; Q_DECLARE_METATYPE(ASYNC_VALUE_STATE); //        class AsyncValueBase : public QObject { Q_OBJECT Q_DISABLE_COPY(AsyncValueBase) signals: void stateChanged(ASYNC_VALUE_STATE state); protected: explicit AsyncValueBase(ASYNC_VALUE_STATE state, QObject* parent = nullptr); //     PromoteToWriteLock/DemoteToReadLock QMutex m_writeLock; QReadWriteLock m_contentLock; //   ASYNC_VALUE_STATE m_state; }; template &lt;typename ValueType_t, typename ErrorType_t, typename ProgressType_t&gt; class AsyncValueTemplate : public AsyncValueBase { //  struct Content { std::unique_ptr&lt;ValueType_t&gt; value; std::unique_ptr&lt;ErrorType_t&gt; error; std::unique_ptr&lt;ProgressType+t&gt; progress; }; Content m_content; public: using ValueType = ValueType_t; using ErrorType = ErrorType_t; using ProgressType = ProgressType_t; //    template &lt;typename... Args&gt; void emplaceValue(Args&amp;&amp; ...arguments) { moveValue(std::make_unique&lt;ValueType&gt;(std::forward&lt;Args&gt;(arguments)...)); } //    void moveValue(std::unique_ptr&lt;ValueType&gt; value) { //       Content oldContent; //   emplaceXXX/moveXXX    QMutexLocker writeLocker(&amp;m_writeLock); { //       QWriteLocker locker(&amp;m_contentLock); //      oldContent = std::move(m_content); //    m_content.value = std::move(value); //    m_state = ASYNC_VALUE_STATE::VALUE; //     } //   emitStateChanged(); //    emplaceXXX/moveXXX  //    } //   value void emplaceError(Args&amp;&amp; ...arguments); void moveError(std::unique_ptr&lt;ErrorType&gt; error); void emplaceProgress(Args&amp;&amp; ...arguments); void moveProgress(std::unique_ptr&lt;ProgressType&gt; progress); template &lt;typename Pred&gt; bool accessValue(Pred valuePred) { //     QReadLocker locker(&amp;m_contentLock); //    if (m_state != ASYNC_VALUE_STATE::VALUE) return false; //      valuePred(*m_content.value); //     return true; } //  accessValue bool accessError(Pred errorPred) bool accessProgress(Pred progressPred) };</span></span></code> </pre><br> 对于那些不累也不迷路的人，我们继续。 <br><br> 如您所见，我们具有accessXXX函数，这些函数不会等到AsyncValue进入相应的状态，而只是返回false。 同步等待直到AsyncValue中出现值或错误有时会很有用。 实际上，我们需要一个std :: future :: get的类似物。 这是函数签名： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValuePred, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorPred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValuePred valuePred, ErrorPred errorPred)</span></span></span></span>;</code> </pre><br> 为了使此功能正常工作，我们需要一个条件变量-一个可以在一个线程中预期并在另一个线程中激活的同步对象。 在等待功能中，我们应该等待，当将AsyncValue的状态从“进度”更改为“值”或“错误”时，我们应该通知等待者。 <br><br> 向AsyncValue类添加另一个字段（在极少数情况下使用wait函数时是必需的）使我想到-该字段可以设为可选字段吗？ 答案很明显，如果您存储std :: unique_ptr并在必要时创建它，当然是可能的。 出现第二个问题-是否可以使该字段为可选字段而不进行动态分配。 谁在乎，请看下面的代码。 主要思想如下：第一个等待调用在堆栈上创建一个QWaitCondition结构，并将其指针写入AsyncValue，随后的等待调用仅检查指针是否不为空，使用该指针的结构，如果指针为空，请参见上文中的第一个等待调用。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValueBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     QWaitCondition waitValue; //   wait quint16 subWaiters = 0; //  wait     QWaitCondition waitSubWaiters; }; //    Waiter* m_waiter = nullptr; }; template &lt;typename ValuePred, typename ErrorPred&gt; void wait(ValuePred valuePred, ErrorPred errorPred) { //   -      if (access(valuePred, errorPred)) return; //  AsyncValue   QMutexLocker writeLocker(&amp;m_writeLock); //     if (access(valuePred, errorPred)) return; //    wait  if (!m_waiter) { //  Waiter   Waiter theWaiter; //       if SCOPE_EXIT { //     wait, //    theWaiter if (m_waiter-&gt;subWaiters &gt; 0) { //    subWaiters   do { m_waiter-&gt;waitSubWaiters.wait(&amp;m_writeLock); } while (m_waiter-&gt;subWaiters != 0); } //   wait  , //       Waiter m_waiter = nullptr; }; //    Waiter  AsyncValue //    wait   m_waiter = &amp;theWaiter; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } //   wait   else { //       else SCOPE_EXIT { //      m_waiter-&gt;subWaiters -= 1; //     -&gt;   wait if (m_waiter-&gt;subWaiters == 0) m_waiter-&gt;waitSubWaiters.wakeAll(); }; //      m_waiter-&gt;subWaiters += 1; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } }</span></span></code> </pre><br> 如前所述，AsyncValue没有用于异步计算的方法，因此不会绑定到特定的库。 而是使用自由函数以一种或另一种方式实现异步。 以下是在线程池上计算AsyncValue的示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AsyncValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ProgressArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncValueRunThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QThreadPool *pool, AsyncValueType&amp; value, Func&amp;&amp; func, ProgressArgs&amp;&amp; ...progressArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    auto progress = std::make_unique&lt;typename AsyncValueType::ProgressType&gt;(std::forward&lt;ProgressArgs&gt;(progressArgs)...); //    auto progressPtr = progress.get(); //    AsyncValue if (!value.startProgress(std::move(progress))) return false; QtConcurrent::run(pool, [&amp;value, progressPtr, func = std::forward&lt;Func&gt;(func)](){ SCOPE_EXIT { //     AsyncValue,    value.completeProgress(progressPtr); }; //  AsyncValue func(*progressPtr, value); }); return true; }</span></span></code> </pre><br> 该库还实现了两个类似的功能：用于处理网络请求的asyncValueRunNetwork和用于对新创建的线程执行操作的asyncValueRunThread。 库用户可以轻松创建自己的函数，并在那里使用它们在其他地方使用的那些异步工具。 <br><br> 为了提高安全性，已使用另一个AsyncTrackErrorsPolicy模板类扩展了AsyncValue类，该类允许您响应AsyncValue的滥用。 例如，这是AsyncTrackErrorsPolicy :: inProgressWhileDestruct函数的默认实现，如果在异步操作运行时销毁AsyncValue，则将调用该函数的默认实现： <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inProgressWhileDestruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Q_ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Destructing value while it's in progress"</span></span>); }</code> </pre><br> 至于小部件，它们的实现非常简单明了。  AsyncWidget是一个容器，其中包含一个小部件以显示错误或进度，或一个值，具体取决于当前AsyncValue处于何种状态。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createValueWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType&amp; value, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createErrorWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorType&amp; error, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgressWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProgressType&amp; progress, QWidget* parent)</span></span></span></span>;</code> </pre><br> 用户只能重新定义第一个功能，以显示值，其他两个则具有默认实现。 <br><br> 事实证明， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-async</a>库很紧凑，但同时却非常有用。 使用以前具有同步功能和静态GUI的AsyncValue / AsyncWidget，将使您的应用程序变得更现代且响应更快。 <br><br> 对于那些已阅读完奖金-视频演示应用程序的人 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aTXOpmVRXq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451722/">https://habr.com/ru/post/zh-CN451722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451708/index.html">如何准备对个人数据进行ILV检查：完整指南</a></li>
<li><a href="../zh-CN451710/index.html">夏季居民的互联网。 我们在4G网络中获得最高速度。 第2部分。选择外部天线</a></li>
<li><a href="../zh-CN451716/index.html">使用面向开发人员的英特尔工具提高软件性能。 天体物体的数值模拟</a></li>
<li><a href="../zh-CN451718/index.html">创建语音助手</a></li>
<li><a href="../zh-CN451720/index.html">FIAS通过即兴（SQLXMLBULKLOAD）的方式将FIAS加载到MSSQLSERVER上的数据库中。 不需要怎么做（可能）</a></li>
<li><a href="../zh-CN451724/index.html">Skyrmion到Skyrmion不和谐：铁弹性体中的三维极性Skyrmion</a></li>
<li><a href="../zh-CN451726/index.html">在国外找工作：给IT专业人员的7个简单技巧</a></li>
<li><a href="../zh-CN451728/index.html">RESTinio是一个异步HTTP服务器。 异步的</a></li>
<li><a href="../zh-CN451738/index.html">对文章“ DeViSE：深度视觉语义嵌入模型”的简短评论</a></li>
<li><a href="../zh-CN451742/index.html">在DotNext 2019 Piter的前一天。 免费广播公告</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>