<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå°Ô∏è üê∑ üë©‚Äçüè≠ Otimiza√ß√£o da renderiza√ß√£o de uma cena do desenho animado da Disney "Moana". Partes 4 e 5 üç¨ üïù üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu tenho um ramo pbrt, que eu uso para testar novas id√©ias, implementar id√©ias interessantes de artigos cient√≠ficos e, em geral, estudar tudo o que no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o da renderiza√ß√£o de uma cena do desenho animado da Disney "Moana". Partes 4 e 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="imagem"></div><br>  Eu tenho um ramo pbrt, que eu uso para testar novas id√©ias, implementar id√©ias interessantes de artigos cient√≠ficos e, em geral, estudar tudo o que normalmente resulta em uma nova edi√ß√£o do livro <em>Renderiza√ß√£o com Base F√≠sica</em> .  Diferente do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pbrt-v3</a> , que nos esfor√ßamos para manter o mais pr√≥ximo poss√≠vel do sistema descrito no livro, neste t√≥pico podemos mudar qualquer coisa.  Hoje veremos como mudan√ßas mais radicais no sistema reduzir√£o significativamente o uso de mem√≥ria na cena com a ilha do desenho animado da Disney <em>"Moana"</em> . <br><br>  Nota sobre a metodologia: nos tr√™s posts anteriores, todas as estat√≠sticas foram medidas para a vers√£o WIP (Work In Progress) da cena com a qual trabalhei antes de seu lan√ßamento.  Neste artigo, passaremos para a vers√£o final, que √© um pouco mais complicada. <br><br>  Ao renderizar a √∫ltima cena da ilha a partir de <em>Moana</em> , 81 GB de RAM foram usados ‚Äã‚Äãpara armazenar a descri√ß√£o da cena para pbrt-v3.  Atualmente, o pbrt-next usa 41 GB - cerca da metade.  Para obter esse resultado, bastava fazer pequenas altera√ß√µes que se espalharam por v√°rias centenas de linhas de c√≥digo. <br><a name="habracut"></a><br><h2>  Primitivos reduzidos </h2><br>  Lembremos que no pbrt <code>Primitive</code> h√° uma combina√ß√£o de geometria, seu material, a fun√ß√£o de radia√ß√£o (se for uma fonte de luz) e registros sobre o ambiente dentro e fora da superf√≠cie.  No pbrt-v3, o <code>GeometricPrimitive</code> armazena o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">afirmado anteriormente</a> , a maior parte do tempo <code>areaLight</code> √© <code>nullptr</code> , e o <code>MediumInterface</code> cont√©m um par de <code>nullptr</code> .  Assim, no pbrt-next, adicionei uma op√ß√£o <code>Primitive</code> chamada <code>SimplePrimitive</code> , que armazena apenas ponteiros para geometria e material.  Onde poss√≠vel, √© usado <code>GeometricPrimitive</code> poss√≠vel, em vez de <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  Para inst√¢ncias de objetos n√£o animados, agora temos o <code>TransformedPrimitive</code> , que armazena apenas um ponteiro para o primitivo e a transforma√ß√£o, o que economiza cerca de 500 bytes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espa√ßo desperdi√ßado</a> que a inst√¢ncia <code>AnimatedTransform</code> adicionou ao renderizador <code>TransformedPrimitive</code> pbrt-v3. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Existe <code>AnimatedPrimitive</code> caso voc√™ precise de uma convers√£o animada para pbrt-next.) <br><br>  Ap√≥s todas essas altera√ß√µes, as estat√≠sticas relatam que apenas 7,8 GB s√£o usados ‚Äã‚Äãno <code>Primitive</code> , em vez de 28,9 GB no pbrt-v3.  Embora tenha sido √≥timo economizarmos 21 GB, n√£o √© apenas a diminui√ß√£o que poder√≠amos esperar de estimativas anteriores;  retornaremos a essa discrep√¢ncia no final desta parte. <br><br><h2>  Geometria reduzida </h2><br>  Al√©m disso, o pbrt-next reduziu significativamente a quantidade de mem√≥ria ocupada pela geometria: o espa√ßo usado para tri√¢ngulos de malha diminuiu de 19,4 GB para 9,9 GB e o espa√ßo de armazenamento para curvas de 1,4 para 1,1 GB.  Pouco mais da metade dessa economia veio da simplifica√ß√£o da classe <code>Shape</code> b√°sica. <br><br>  No pbrt-v3, o <code>Shape</code> traz v√°rios membros que s√£o transportados para todas as implementa√ß√µes do <code>Shape</code> - esses s√£o v√°rios aspectos convenientes para acessar nas implementa√ß√µes do <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Para entender por que essas vari√°veis-membro causam problemas, ser√° √∫til entender como as malhas triangulares s√£o representadas no pbrt.  Primeiro, h√° a classe <code>TriangleMesh</code> , que armazena os v√©rtices e os buffers de √≠ndice para toda a malha: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Cada tri√¢ngulo na malha √© representado pela classe <code>Triangle</code> , que herda de <code>Shape</code> .  A id√©ia √© manter o <code>Triangle</code> o menor poss√≠vel: eles armazenam apenas um ponteiro para a malha da qual fazem parte e um ponteiro para o deslocamento no buffer do √≠ndice no qual os √≠ndices de seus v√©rtices come√ßam: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Quando as implementa√ß√µes do <code>Triangle</code> precisam encontrar as posi√ß√µes de seus v√©rtices, ele executa a indexa√ß√£o correspondente para obt√™-las no <code>TriangleMesh</code> . <br><br>  O problema com o <code>Shape</code> pbrt-v3 √© que os valores armazenados s√£o os mesmos para todos os tri√¢ngulos da malha, portanto, √© melhor salv√°-los de cada malha inteira no <code>TriangleMesh</code> e conceder ao <code>Triangle</code> acesso a uma √∫nica c√≥pia dos valores comuns. <br><br>  Esse problema foi corrigido no pbrt-next: a classe <code>Shape</code> b√°sica no pbrt-next n√£o cont√©m esses membros e, portanto, cada <code>Triangle</code> tem 24 bytes a menos.  A <code>Curve</code> geometria usa uma estrat√©gia semelhante e tamb√©m se beneficia de uma forma mais compacta. <br><br><h2>  Buffers de tri√¢ngulo compartilhado </h2><br>  Apesar de a cena da ilha <em>Moana fazer</em> uso extensivo da instancia√ß√£o de objetos para repetir explicitamente a geometria, fiquei curioso com a frequ√™ncia com que a reutiliza√ß√£o de buffers de √≠ndice, buffers de coordenadas de textura e assim por diante √© usada para v√°rias malhas de tri√¢ngulo. <br><br>  Eu escrevi uma classe pequena que mistura esses buffers ap√≥s o recebimento e os armazena no cache, e modifiquei o <code>TriangleMesh</code> para que ele verifique o cache e use a vers√£o j√° salva de qualquer buffer redundante necess√°rio.  O ganho foi muito bom: consegui me livrar de 4,7 GB de volume em excesso, o que √© muito mais do que eu esperava. <br><br><h2>  Falha no std :: shared_ptr </h2><br>  Ap√≥s todas essas altera√ß√µes, as estat√≠sticas relatam cerca de 36 GB de mem√≥ria alocada conhecida e, no in√≠cio da renderiza√ß√£o, o <code>top</code> indica o uso de 53 GB.  Assuntos. <br><br>  Eu tinha medo de outra s√©rie de execu√ß√µes lentas de <code>massif</code> para descobrir qual mem√≥ria alocada est√° faltando nas estat√≠sticas, mas uma carta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arseny Kapulkin</a> apareceu na minha caixa de entrada.  Arseny me explicou que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minhas estimativas anteriores</a> do uso da mem√≥ria <code>GeometricPrimitive</code> estavam muito erradas.  Eu tive que descobrir por um longo tempo, mas ent√£o percebi;  muito obrigado a Arseny por apontar o erro e explica√ß√µes detalhadas. <br><br>  Antes de escrever para Arseny, imaginei a implementa√ß√£o de <code>std::shared_ptr</code> seguinte maneira: nessas linhas, existe um descritor comum que armazena a contagem de refer√™ncia e um ponteiro para o pr√≥prio objeto colocado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Sugeri ent√£o que a inst√¢ncia <code>shared_ptr</code> apenas aponta para ela e a usa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  Em suma, presumi que <code>sizeof(shared_ptr&lt;&gt;)</code> √© igual ao tamanho do ponteiro e que 16 bytes de espa√ßo extra s√£o desperdi√ßados em cada ponteiro compartilhado. <br><br>  Mas isso n√£o √© verdade. <br><br>  Na implementa√ß√£o do meu sistema, o descritor comum tem 32 bytes de tamanho e 16 bytes de <code>sizeof(shared_ptr&lt;&gt;)</code> .  Portanto, <code>GeometricPrimitive</code> , que consiste principalmente em <code>std::shared_ptr</code> , √© cerca de duas vezes maior que minhas estimativas.  Se voc√™ est√° se perguntando por que isso aconteceu, essas duas postagens de Stack Overflow explicam os motivos em detalhes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> . <br><br>  Em quase todos os casos de uso de <code>std::shared_ptr</code> no pbrt-next, eles n√£o precisam ser ponteiros compartilhados.  Enquanto fazia hackers malucos, substitu√≠ tudo o que pude por <code>std::unique_ptr</code> , que na verdade tem o mesmo tamanho que um ponteiro comum.  Por exemplo, aqui est√° a apar√™ncia do <code>SimplePrimitive</code> agora: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  A recompensa acabou sendo maior do que eu esperava: o uso da mem√≥ria no in√≠cio da renderiza√ß√£o diminuiu de 53 GB para 41 GB - uma economia de 12 GB, completamente inesperada alguns dias atr√°s, e o volume total √© quase a metade do usado pelo pbrt-v3.  √ìtimo! <br><br>  Na pr√≥xima parte, finalmente concluiremos esta s√©rie de artigos - examinamos a velocidade de renderiza√ß√£o no pbrt-next e discutimos id√©ias de outras maneiras de reduzir a quantidade de mem√≥ria necess√°ria para essa cena. <br><br><h2>  Parte 5 </h2><br>  Para resumir esta s√©rie de artigos, come√ßaremos explorando a velocidade de renderiza√ß√£o da cena da ilha a partir do desenho animado da Disney <em>"Moana"</em> em pbrt-next - o ramo pbrt que eu uso para testar novas id√©ias.  Faremos mudan√ßas mais radicais do que √© poss√≠vel no pbrt-v3, que deve aderir ao sistema descrito em nosso livro.  Conclu√≠mos com uma discuss√£o de √°reas para melhorias adicionais, do mais simples ao um pouco extremo. <br><br><h2>  Tempo de renderiza√ß√£o </h2><br>  A Pbrt-next fez muitas altera√ß√µes nos algoritmos de transfer√™ncia de luz, incluindo altera√ß√µes na amostragem BSDF e melhorias nos algoritmos de roleta russa.  Como resultado, ele rastreia mais raios do que o pbrt-v3 para renderizar essa cena; portanto, n√£o √© poss√≠vel comparar diretamente o tempo de execu√ß√£o desses dois renderizadores.  A velocidade geralmente √© pr√≥xima, com uma exce√ß√£o importante: ao renderizar uma cena da ilha de <em>Moana</em> , mostrada abaixo, o pbrt-v3 gasta 14,5% do tempo de execu√ß√£o pesquisando texturas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ptex</a> .  Isso costumava parecer bastante normal para mim, mas o pbrt-next gasta apenas 2,2% do tempo de execu√ß√£o.  Tudo isso √© muito interessante. <br><br>  Depois de estudar as estat√≠sticas, obtemos <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Como vemos no pbrt-v3, a textura ptex √© lida em disco, em m√©dia, a cada 34 pesquisas de textura.  No pbrt-next, ele √© lido somente ap√≥s cada 244 pesquisas - ou seja, a E / S do disco diminuiu cerca de 7 vezes.  Sugeri que isso acontecesse porque o pbrt-next calcula as diferen√ßas de raio para raios indiretos e isso leva ao acesso a n√≠veis mais altos de texturas MIP, o que, por sua vez, cria uma s√©rie mais integrada de acessos ao cache de textura ptex, reduz o n√∫mero de falhas de cache e, portanto, o n√∫mero de opera√ß√µes de E / S <sup>2</sup> .  Uma breve verifica√ß√£o confirmou meu palpite: quando a diferen√ßa do feixe foi desativada, a velocidade do ptex ficou muito pior. <br><br>  O aumento na velocidade do ptex n√£o afetou apenas o custo da computa√ß√£o e da E / S.  Em um sistema com 32 CPUs, o pbrt-v3 foi acelerado apenas 14,9 vezes ap√≥s analisar a descri√ß√£o da cena.  O pbrt geralmente mostra uma escala paralela linear pr√≥xima, ent√£o me decepcionou.  Devido ao n√∫mero muito menor de conflitos durante bloqueios no ptex, a vers√£o pbrt-next foi 29,2 vezes mais r√°pida em um sistema com 32 CPUs e 94,9 vezes mais r√°pida em um sistema com 96 CPUs - voltamos aos indicadores que nos conv√™m. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Ra√≠zes da cena da ilha de Moana renderizada por pbrt com uma resolu√ß√£o de 2048x858 a 256 amostras por pixel.</i>  <i>O tempo total de renderiza√ß√£o em uma inst√¢ncia do Google Compute Engine com 96 CPUs virtuais com uma frequ√™ncia de 2 GHz em pbrt-next √© de 41 min 22 s.</i>  <i>A acelera√ß√£o devido ao multithreading durante a renderiza√ß√£o foi de 94,9 vezes.</i>  <i>(N√£o entendo direito o que est√° acontecendo com o mapeamento de bump.)</i> <br><br><h2>  Trabalhe para o futuro </h2><br>  Diminuir a quantidade de mem√≥ria usada em cenas t√£o complexas √© uma experi√™ncia emocionante: economizar alguns gigabytes com uma pequena altera√ß√£o √© muito mais agrad√°vel do que dezenas de megabytes economizados em uma cena mais simples.  Tenho uma boa lista do que espero aprender no futuro, se o tempo permitir.  Aqui est√° uma r√°pida vis√£o geral. <br><br><h3>  Mem√≥ria de buffer tri√¢ngulo decrescente adicional </h3><br>  Mesmo com o uso repetido de buffers que armazenam os mesmos valores para v√°rias malhas de tri√¢ngulo, muita mem√≥ria ainda √© usada sob os buffers de tri√¢ngulo.  Aqui est√° um detalhamento do uso de mem√≥ria para v√°rios tipos de buffers de tri√¢ngulo na cena: <br><br><table><thead><tr><th>  Tipo </th><th>  A mem√≥ria </th></tr></thead><tbody><tr><td>  Itens de linha </td><td>  2,5 GB </td></tr><tr><td>  Normal </td><td>  2,5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  √çndices </td><td>  252 MB </td></tr></tbody></table><br>  Entendo que nada pode ser feito com as posi√ß√µes dos v√©rtices transmitidos, mas para outros dados h√° economia.  Existem muitos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos de representa√ß√µes de vetores normais em uma forma eficiente de mem√≥ria</a> que fornece v√°rias vantagens e desvantagens entre o tamanho da mem√≥ria / n√∫mero de c√°lculos.  O uso de uma das representa√ß√µes de 24 ou 32 bits reduzir√° o espa√ßo ocupado pelos normais para 663 MB e 864 MB, o que economizar√° mais de 1,5 GB de RAM. <br><br>  Nesta cena, a quantidade de mem√≥ria usada para armazenar coordenadas de textura e buffers de √≠ndice √© surpreendentemente pequena.  Suponho que isso aconteceu devido √† presen√ßa de muitas plantas geradas processualmente na cena e porque todas as varia√ß√µes do mesmo tipo de planta t√™m a mesma topologia (e, portanto, o buffer de √≠ndice) com parametriza√ß√£o (e, portanto, as coordenadas UV).  Por sua vez, reutilizar buffers correspondentes √© bastante eficiente. <br><br>  Para outras cenas, a amostragem de coordenadas UV de 16 bits de texturas ou o uso de valores flutuantes de meia precis√£o, dependendo da faixa de valores, pode ser bastante adequado.  Parece que nesta cena, todos os valores das coordenadas da textura s√£o zero ou um, o que significa que eles podem ser representados por um <em>bit</em> - ou seja, √© poss√≠vel reduzir a mem√≥ria ocupada em 32 vezes.  Esse estado de coisas provavelmente surgiu devido ao uso do formato ptex para texturiza√ß√£o, o que elimina a necessidade de atlas de UV.  Dada a pequena quantidade atualmente ocupada pelas coordenadas de textura, a implementa√ß√£o dessa otimiza√ß√£o n√£o √© particularmente necess√°ria. <br><br>  O pbrt sempre usa n√∫meros inteiros de 32 bits para buffers de √≠ndice.  Para malhas pequenas com menos de 256 v√©rtices, apenas 8 bits por √≠ndice s√£o suficientes e, para malhas com menos de 65.536 v√©rtices, 16 bits podem ser usados.  Alterar o pbrt para adapt√°-lo a este formato n√£o ser√° muito dif√≠cil.  Se desej√°ssemos otimizar ao m√°ximo, poder√≠amos selecionar exatamente quantos bits forem necess√°rios para representar o intervalo necess√°rio nos √≠ndices, enquanto o pre√ßo seria aumentar a complexidade de encontrar seus valores.  Apesar do fato de que agora apenas um quarto de gigabyte de mem√≥ria √© usado para √≠ndices de v√©rtices, essa tarefa n√£o parece muito interessante em compara√ß√£o com outras. <br><br><h3>  Uso de mem√≥ria de constru√ß√£o de pico BVH </h3><br>  Anteriormente, n√£o discutimos ainda outro detalhe do uso da mem√≥ria: imediatamente antes da renderiza√ß√£o, ocorre um pico de curto prazo de 10 GB de mem√≥ria usada adicionalmente.  Isso acontece quando o BVH (grande) de toda a cena √© constru√≠do.  O c√≥digo para construir o BVH do renderizador pbrt √© escrito para ser executado em duas fases: primeiro, ele cria um BVH com a <a href="">representa√ß√£o tradicional</a> : dois ponteiros filhos para cada n√≥.  Ap√≥s a constru√ß√£o da √°rvore, ela √© convertida em <a href="">um esquema eficiente de mem√≥ria,</a> no qual o primeiro filho do n√≥ est√° localizado diretamente atr√°s dele na mem√≥ria, e o deslocamento para o segundo filho √© armazenado como um n√∫mero inteiro. <br><br>  Essa separa√ß√£o era necess√°ria do ponto de vista do ensino dos alunos - era muito mais f√°cil entender os algoritmos para a constru√ß√£o de BVH sem o caos associado √† necessidade de converter a √°rvore em uma forma compacta durante o processo de constru√ß√£o.  No entanto, o resultado √© esse pico no uso da mem√≥ria;  levando em considera√ß√£o sua influ√™ncia na cena, a elimina√ß√£o desse problema parece atraente. <br><br><h3>  Converter ponteiros em n√∫meros inteiros </h3><br>  Em v√°rias estruturas de dados, existem muitos ponteiros de 64 bits que podem ser representados como n√∫meros inteiros de 32 bits.  Por exemplo, cada <code>SimplePrimitive</code> cont√©m um ponteiro para um <code>Material</code> .  A maioria dos casos de <code>Material</code> √© comum a muitos primitivos na cena e nunca h√° mais do que alguns milhares;  portanto, podemos armazenar um √∫nico vetor <code>vector</code> global <code>vector</code> todos os materiais: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  e apenas armazene deslocamentos inteiros de 32 bits para esse vetor no <code>SimplePrimitive</code> , o que nos economiza 4 bytes.  O mesmo truque pode ser usado com um ponteiro para o <code>TriangleMesh</code> em cada <code>Triangle</code> , assim como em muitos outros lugares. <br><br>  Ap√≥s essa mudan√ßa, haver√° uma ligeira redund√¢ncia no acesso aos pr√≥prios sinais, e o sistema se tornar√° um pouco menos compreens√≠vel para os alunos que tentam entender seu trabalho;  al√©m disso, esse √© provavelmente o caso quando, no contexto do pbrt, √© melhor manter a implementa√ß√£o um pouco mais compreens√≠vel, embora √† custa da otimiza√ß√£o incompleta do uso da mem√≥ria. <br><br><h3>  Alojamento baseado em arenas (√°reas) </h3><br>  Para cada <code>Triangle</code> individual e primitivo, √© feita uma chamada separada para <code>new</code> (realmente <code>make_unique</code> , mas √© o mesmo).  Essas aloca√ß√µes de mem√≥ria levam ao uso de contabilidade de recursos adicionais, ocupando cerca de cinco gigabytes de mem√≥ria, n√£o contabilizados nas estat√≠sticas.  Como a vida √∫til de todos esses canais √© a mesma - at√© a renderiza√ß√£o estar conclu√≠da -, podemos nos livrar dessa contabilidade adicional selecionando-os na <a href="">arena</a> da <a href="">mem√≥ria</a> . <br><br><h3>  Tabela c√°qui </h3><br>  Minha √∫ltima ideia √© terr√≠vel, e pe√ßo desculpas por isso, mas ela me intrigou. <br><br>  Cada tri√¢ngulo na cena possui uma carga extra de pelo menos dois ponteiros de tabela: um para <code>Triangle</code> e outro para <code>SimplePrimitive</code> .  Isso √© 16 bytes.  A cena da ilha de <em>Moana</em> possui um total de 146 162 124 tri√¢ngulos √∫nicos, o que adiciona quase 2,2 GB de ponteiros redimension√°veis ‚Äã‚Äãde tabela. <br><br>  E se n√£o tiv√©ssemos uma classe base abstrata para <code>Shape</code> e cada implementa√ß√£o de geometria n√£o herdasse nada?  Isso nos pouparia espa√ßo em ponteiros vtable, mas, √© claro, ao passar um ponteiro para uma geometria, n√£o saber√≠amos que tipo de geometria √©, ou seja, seria in√∫til. <br><br>  Acontece que nas modernas CPUs x86 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, apenas 48 bits de ponteiros de 64 bits</a> s√£o realmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usados</a> .  Portanto, existem 16 bits extras que podemos emprestar para armazenar algumas informa√ß√µes ... por exemplo, como a geometria que estamos apontando.  Por sua vez, adicionando um pouco de trabalho, podemos voltar √† possibilidade de criar um an√°logo de chamadas para fun√ß√µes virtuais. <br><br>  Veja como isso acontecer√°: primeiro, definimos uma estrutura <code>ShapeMethods</code> que cont√©m ponteiros para fun√ß√µes, como por exemplo <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Cada implementa√ß√£o de geometria implementar√° uma fun√ß√£o de restri√ß√£o, uma fun√ß√£o de interse√ß√£o e assim por diante, recebendo um an√°logo <code>this</code> ponteiro como o primeiro argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Ter√≠amos uma tabela global de estruturas <code>ShapeMethods</code> na qual o <em>en√©simo</em> elemento seria para um tipo de geometria com o √≠ndice <em>n</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Ao criar geometria, codificamos seu tipo em alguns dos bits n√£o utilizados do ponteiro de retorno.  Ent√£o, levando em conta o ponteiro para a geometria cuja chamada espec√≠fica queremos executar, extra√≠mos esse √≠ndice de tipo do ponteiro e o usamos como um √≠ndice em <code>shapeMethods</code> para encontrar o ponteiro de fun√ß√£o correspondente.  Essencialmente, implementar√≠amos o vtable manualmente, processando a expedi√ß√£o por n√≥s mesmos.  Se fiz√©ssemos isso tanto para geometria quanto para primitivas, salvar√≠amos 16 bytes por <code>Triangle</code> , mas, ao mesmo tempo, fizemos um caminho bastante dif√≠cil. <br><br>  Suponho que esse tipo de invas√£o para implementar o gerenciamento de fun√ß√µes virtuais n√£o seja novo, mas n√£o consegui encontrar links para ele na Internet.  Aqui est√° a p√°gina da Wikipedia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ponteiros</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tags</a> , mas trata de coisas como contagem de links.  Se voc√™ conhece um link melhor, envie-me uma carta. <br><br>  Ao compartilhar esse truque estranho, posso terminar a s√©rie de postagens.  Mais uma vez, muito obrigado √† Disney por publicar esta cena.  Foi incrivelmente divertido trabalhar com;  as engrenagens na minha cabe√ßa continuam girando. <br><br><h2>  Anota√ß√µes </h2><br><ol><li>  No final, o pbrt-next rastreia mais raios nessa cena do que o pbrt-v3, o que provavelmente explica o aumento no n√∫mero de opera√ß√µes de pesquisa. </li><li>  As diferen√ßas de raio para raios indiretos no pbrt-next s√£o calculadas usando o mesmo <a href="">hack</a> usado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extens√£o do cache de textura</a> para o pbrt-v3. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417939/">https://habr.com/ru/post/pt417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417929/index.html">Trecho do livro ‚ÄúUm dia na vida do c√©rebro. Neurobiologia da consci√™ncia do amanhecer ao anoitecer ‚Äù</a></li>
<li><a href="../pt417931/index.html">T√©cnicas de reten√ß√£o de jogadores: exemplos de jogos de diferentes g√™neros</a></li>
<li><a href="../pt417933/index.html">Semana 27 de seguran√ßa: iPhone falso e pre√ßo de seguran√ßa</a></li>
<li><a href="../pt417935/index.html">Memorandos sobre Intelig√™ncia Artificial, Aprendizado de M√°quina, Aprendizado Profundo e Big Data</a></li>
<li><a href="../pt417937/index.html">As pessoas "de ferro" est√£o criando software?</a></li>
<li><a href="../pt417941/index.html">Onde a √°gua na chaleira desaparece?</a></li>
<li><a href="../pt417943/index.html">Sem servidor e reagir 2: presteza e sem fraude</a></li>
<li><a href="../pt417945/index.html">Quais ferramentas a sonda solar da Parker possui</a></li>
<li><a href="../pt417947/index.html">Visualiza√ß√£o de dados para seu projeto da web</a></li>
<li><a href="../pt417949/index.html">Como eu escrevi a biblioteca C ++ 11 padr√£o ou por que o impulso √© t√£o assustador? Cap√≠tulo 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>