<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♈️ 🍩 🤞🏾 Weitere Funktionen mit Mustern in C # 8.0 👨🏿‍🚒 ⛰️ 👼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In jüngerer Zeit wurde Visual Studio 2019 Preview 2 veröffentlicht. Damit stehen Ihnen einige zusätzliche C # 8.0-Funktionen zum Ausprobieren zur Verf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Weitere Funktionen mit Mustern in C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/440530/"><p>  In jüngerer Zeit wurde Visual Studio 2019 Preview 2 veröffentlicht. Damit stehen Ihnen einige zusätzliche C # 8.0-Funktionen zum Ausprobieren zur Verfügung.  Dies ist hauptsächlich ein Vergleich mit der Stichprobe, obwohl ich am Ende auf einige andere Neuigkeiten und Änderungen eingehen werde. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel ist in Englisch.</a> </p><br><img src="https://habrastorage.org/webt/_p/dm/49/_pdm493ww_lspasjjtw5abi-eoa.jpeg"><a name="habracut"></a><br><br>  Vielen Dank für die Übersetzung unseres MSP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lev Bulanov</a> . <br><br><h2></h2><p>  Mehr Muster an mehr Orten </p><br><p>  Als der Mustervergleich in C # 7.0 erschien, stellten wir fest, dass in Zukunft eine Zunahme der Anzahl von Mustern an mehr Stellen erwartet wird.  Diese Zeit ist gekommen!  Wir fügen so genannte rekursive Muster sowie eine kompaktere Form von <strong>Switch-</strong> Ausdrücken hinzu, die als <strong>Switch-</strong> Ausdrücke bezeichnet werden (Sie haben es erraten). </p><br><p>  Hier ist ein einfaches Beispiel für C # 7.0-Muster: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre> <br><p></p><h2>  Ausdrücke wechseln </h2><br><p>  Beachten Sie zunächst, dass viele <strong>Schalterausdrücke in</strong> Fallkörpern tatsächlich nicht viel interessante Arbeit leisten.  Oft erstellen alle einfach einen Wert, indem sie ihn entweder einer Variablen zuweisen oder zurückgeben (wie oben angegeben).  In all diesen Situationen scheint der Schalter fehl am Platz zu sein.  Dies ähnelt einer fünfzig Jahre alten Sprachfunktion. </p><br><p>  Wir beschlossen, dass es Zeit war, ein Formular für die <strong>switch-Anweisung</strong> hinzuzufügen.  Dies gilt für das folgende Beispiel: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre> <br><p>  Es gibt einige Dinge, die sich im Vergleich zu switch-Anweisungen geändert haben.  Lassen Sie uns sie auflisten: </p><br><ul><li>  Das Schlüsselwort <strong>switch</strong> lautet "infix" zwischen dem getesteten Wert und der Liste der <strong>{...}</strong> Fälle.  Dies macht es kompositorischer mit anderen Ausdrücken und erleichtert auch die visuelle Unterscheidung von der switch-Anweisung. </li><li>  Das <strong>case-</strong> Schlüsselwort und das <strong>case-</strong> Symbol: wurden durch den Lambda-Pfeil ersetzt <strong>=&gt;</strong> kurz. </li><li>  <strong>Die Standardeinstellung</strong> für die Kürze wurde durch das <strong>_-</strong> Reset-Muster ersetzt. </li><li>  Körper sind Ausdrücke.  Das Ergebnis des ausgewählten Körpers wird zum Ergebnis der switch-Anweisung. </li></ul><br><p>  Da der Ausdruck wichtig sein oder eine Ausnahme auslösen muss, löst ein ausgewählter Ausdruck, der ohne Übereinstimmung endet, eine Ausnahme aus.  Der Compiler warnt Sie, wenn dies passieren kann, zwingt Sie jedoch nicht, alle select-Anweisungen mit der Funktion catch-all zu beenden. </p><br><p>  Da unsere <strong>Display-</strong> Methode jetzt aus einer einzelnen return-Anweisung besteht, können wir sie für den Ausdruck vereinfachen: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Unabhängig von den Formatierungsempfehlungen sollten diese äußerst klar und präzise sein.  Mit der Kürze können Sie den Schalter wie oben beschrieben "tabellarisch" formatieren, wobei sich Muster und Körper in derselben Zeile befinden und <strong>=&gt;</strong> untereinander angeordnet sind. </p><br><p>  Übrigens planen wir, die Verwendung eines Kommas nach dem letzten Fall gemäß allen anderen "durch Kommas in geschweiften Klammern getrennten Listen" in C # zuzulassen, dies ist jedoch in Vorschau 2 noch nicht zulässig. </p><br><h2></h2><p>  Mustereigenschaften </p><br><p>  Apropos Kürze: Muster werden plötzlich zu den schwierigsten Elementen von Auswahlausdrücken.  Lassen Sie uns etwas dagegen tun. </p><br><p>  Beachten Sie, dass der select-Ausdruck ein Muster vom Typ <strong>Point p</strong> (zweimal) verwendet und im ersten <strong>Fall</strong> zusätzliche Bedingungen hinzugefügt <strong>werden müssen</strong> . </p><br><p>  In C # 8.0 fügen wir dem Mustertyp zusätzliche optionale Elemente hinzu, sodass das Muster selbst tiefer in den Wert eintauchen kann, der dem Muster zugeordnet ist.  Sie können es zu einem Eigenschaftsmuster machen, indem Sie <strong>{...}</strong> mit verschachtelten Mustern hinzufügen und Werte auf die verfügbaren Eigenschaften oder Felder anwenden.  Auf diese Weise können wir den Schalterausdruck wie folgt umschreiben: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  In beiden Fällen wird weiterhin überprüft, ob <strong>o</strong> <strong>Punkt ist</strong> .  Im ersten Fall wird das Muster der Konstanten <strong>0</strong> rekursiv auf die Eigenschaften <strong>X</strong> und <strong>Y der</strong> Variablen <strong>p</strong> angewendet, um zu prüfen, ob sie diesen Wert haben.  Somit können wir die <strong>Wann-</strong> Bedingung in diesem und anderen ähnlichen Fällen beseitigen. </p><br><p>  Im zweiten Fall wird das <strong>var-</strong> Muster jeweils auf <strong>X</strong> und <strong>Y</strong> angewendet.  Denken Sie daran, dass das <strong>var-</strong> Muster in C # 7.0 immer erfolgreich ist und deklarieren Sie einfach eine neue Variable, die den Wert enthält.  <strong>X</strong> und <strong>y</strong> enthalten also int-Werte für <strong>pX</strong> und <strong>pY</strong> . </p><br><p>  Wir verwenden <strong>p</strong> nie und können es hier tatsächlich überspringen: </p><br><pre> <code class="cs hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre> <br><p>  Eines bleibt für alle Arten von Mustern gleich, einschließlich Eigenschaftsmuster. Dies ist eine Voraussetzung dafür, dass der Wert ungleich Null ist.  Dies eröffnet die Möglichkeit, das Muster "leere" Eigenschaften <strong>{}</strong> als kompaktes Muster "ungleich Null" zu verwenden.  Zum Beispiel.  Wir könnten den Fallback durch die folgenden zwei Fälle ersetzen: </p><br><pre> <code class="cs hljs"> {} =&gt; o.ToString(), <span class="hljs-literal"><span class="hljs-literal">null</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre> <br><p>  <strong>{}</strong> Behandelt die verbleibenden Nicht-Null-Objekte, und <strong>Null</strong> erhält Nullen, sodass der Schalter vollständig ist und der Compiler sich nicht über fehlende Werte beschwert. </p><br><h2></h2><p>  Positionsmuster </p><br><p>  Das Eigenschaftsmuster verkürzt den zweiten <strong>Punkt</strong> nicht <strong>.</strong>  Sie müssen sich darüber keine Sorgen machen, Sie können noch mehr tun. </p><br><p>  Beachten Sie, dass die <strong>Point-</strong> Klasse eine <strong>Deconstruct-</strong> Methode hat, den sogenannten Deconstructor.  In C # 7.0 können Sie mit Dekonstruktoren einen Wert "dekonstruieren", wenn er zugewiesen ist, sodass Sie beispielsweise schreiben können: </p><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre> <br><p>  C # 7.0 hat die Dekonstruktion nicht in Muster integriert.  Dies ändert sich mit Positionsmustern, die eine zusätzliche Möglichkeit darstellen, Mustertypen in C # 8.0 zu erweitern.  Wenn der übereinstimmende Typ ein Tupeltyp ist oder einen Dekonstruktor hat, können wir Positionsmuster als kompakte Methode verwenden, um rekursive Muster anzuwenden, ohne die Eigenschaften benennen zu müssen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y) =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Nach dem Abgleichen des Objekts mit <strong>Point</strong> wird der Dekonstruktor angewendet und die verschachtelten Muster werden auf die resultierenden Werte angewendet. </p><br><p>  Dekonstruktoren sind nicht immer angemessen.  Sie sollten nur zu den Typen hinzugefügt werden, bei denen wirklich klar ist, welcher der Werte welcher ist.  Für die <strong>Point-</strong> Klasse können Sie beispielsweise annehmen, dass der erste Wert <strong>X</strong> und der zweite <strong>Y ist</strong> , sodass der obige Schalterausdruck klar und leicht zu lesen ist. </p><br><h2></h2><p>  Tupelmuster </p><br><p>  Ein sehr nützlicher Sonderfall von Positionsmustern ist ihre Anwendung auf Tupel.  Wenn die switch-Anweisung direkt auf den Tupelausdruck angewendet wird, können wir sogar den zusätzlichen Satz von Klammern weglassen, wie in <strong>switch (x, y, z)</strong> anstelle von <strong>switch ((x, y, z))</strong> . </p><br><p>  Tupelmuster eignen sich hervorragend zum gleichzeitigen Testen mehrerer Eingaben.  Hier ist eine einfache Implementierung der Zustandsmaschine: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  Natürlich könnten wir <strong>hasKey</strong> in das Tupel aufnehmen, anstatt <strong>when-</strong> Klauseln zu verwenden - dies ist Geschmackssache: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  Im Allgemeinen sehen Sie, dass rekursive Muster und Schalterausdrücke zu einer klareren und deklarativeren Programmlogik führen können. </p><br><h2></h2><p>  Weitere Funktionen von C # 8.0 in Vorschau 2 </p><br><p>  Trotz der Tatsache, dass in VS 2019 Preview 2 die Hauptfunktionen für die Arbeit mit Mustern am wichtigsten sind, gibt es einige kleinere, die Sie hoffentlich auch nützlich und interessant finden.  Ich werde nicht auf Details eingehen, sondern nur eine kurze Beschreibung von jedem geben. </p><br><h4></h4><p>  Anzeigen verwenden </p><br><p>  Bei der Verwendung von C # erhöhen Bediener immer die Verschachtelung, was sehr ärgerlich und schlecht lesbar sein kann.  In einfachen Fällen, in denen Sie die Ressource nur am Ende des Bereichs löschen müssen, werden Deklarationen verwendet.  Verwenden von Deklarationen sind einfach Deklarationen lokaler Variablen mit dem Schlüsselwort <strong>using</strong> vor sich, und ihr Inhalt wird am Ende des aktuellen Anweisungsblocks platziert.  Daher anstelle von: </p><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre> <br><p>  Du kannst einfach schreiben </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre> <br><h4></h4><p>  Einweg-Ref-Strukturen </p><br><p>  Ref-Strukturen wurden in C # 7.2 eingeführt, und es scheint hier keinen Platz zu geben, um sie zu wiederholen.  Dennoch ist etwas zu beachten: Sie weisen einige Einschränkungen auf, z. B. die Unmöglichkeit, Schnittstellen zu implementieren.  Ref-Strukturen können jetzt verwendet werden, ohne die <strong>IDisposable-</strong> Schnittstelle zu implementieren, indem einfach die darin enthaltene <strong>Dispose-</strong> Methode verwendet wird. </p><br><h4></h4><p>  Statische lokale Funktionen </p><br><p>  Wenn Sie sicherstellen möchten, dass für Ihre lokale Funktion keine Laufzeitkosten für das Erfassen (Referenzieren) von Variablen aus dem Bereich anfallen, können Sie sie als statisch deklarieren.  Dann verhindert der Compiler die Verknüpfung zu allem, was in den umschließenden Funktionen deklariert ist - mit Ausnahme anderer statischer lokaler Funktionen! </p><br><h4></h4><p>  Änderungen gegenüber der Vorschau 1 </p><br><p>  Die Hauptfunktionen von Vorschau 1 waren nullbare Referenztypen und asynchrone Streams.  Beide Funktionen haben sich in Vorschau 2 etwas geändert. Wenn Sie sie also verwenden, ist es hilfreich, Folgendes zu wissen. </p><br><h4></h4><p>  Nullable Referenztypen </p><br><p>  Wir haben weitere Optionen zum Verwalten von nullbaren Warnungen sowohl an der Quelle (über die <strong>Warnanweisungen #nullable</strong> und <strong>#pragma</strong> ) als auch auf Projektebene <strong>hinzugefügt</strong> .  Wir haben auch das Abonnement für die Projektdatei in <strong>&lt;NullableContextOptions&gt; enable &lt;/ NullableContextOptions&gt; geändert</strong> . </p><br><h4></h4><p>  Asynchrone Threads </p><br><p>  Wir haben die Form der <strong>IAsyncEnumerable &lt;T&gt;</strong> -Schnittstelle geändert, die <strong>der</strong> Compiler erwartet.  Dies führt dazu, dass der Compiler nicht mit der in .NET Core 3.0 Preview 1 bereitgestellten Schnittstelle synchronisiert wird, was zu Problemen führen kann.  .NET Core 3.0 Preview 2 wird jedoch bald veröffentlicht und die Synchronisierung wird zurückgegeben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440530/">https://habr.com/ru/post/de440530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440520/index.html">So erhalten Sie die Google Developers-Zertifizierung: Mobile Web Specialist</a></li>
<li><a href="../de440522/index.html">Erfahrung in der Implementierung einer virtuellen Telefonanlage. Kommunikation und Software in verschiedenen Körben</a></li>
<li><a href="../de440524/index.html">Überschreiben oder Reduzieren der Stufe 80: Der Pfad vom Switch-Case zu den Klassen</a></li>
<li><a href="../de440526/index.html">Die japanische Stadt wendet sich nach massiver Schneeverwehung der digitalen Technologie zu</a></li>
<li><a href="../de440528/index.html">"Zeig mir deine Turnschuhe und ich sage dir, wer du bist": Neuer Podcast zu thematischen Medienprojekten</a></li>
<li><a href="../de440534/index.html">Übersetzung des politisch korrekten Wortschatzes vom Englischen ins Russische</a></li>
<li><a href="../de440536/index.html">Wie Facebook Project Infer hilft, Fehler in mobilen Anwendungen vor der Bereitstellung zu finden</a></li>
<li><a href="../de440540/index.html">Die Reddit-Kapitalisierung erreichte 3 Milliarden US-Dollar, nachdem 300 Millionen US-Dollar investiert worden waren</a></li>
<li><a href="../de440542/index.html">Vuex - übermäßiger Einsatz von Gettern in der Anwendung. Fehler beim Parsen</a></li>
<li><a href="../de440544/index.html">Blazor 0.8.0 experimentelle Version jetzt verfügbar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>