<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 💒 🥖 Mencoba preload (PHP 7.4) dan RoadRunner 💃🏻 🔏 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Kami sering menulis dan berbicara tentang kinerja PHP: bagaimana kami menghadapinya secara umum, bagaimana kami menghemat $ 1 juta keti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencoba preload (PHP 7.4) dan RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Halo, Habr! <br><br>  Kami sering menulis dan berbicara tentang kinerja PHP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana kami menghadapinya secara</a> umum, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana kami menghemat</a> $ 1 juta ketika beralih ke PHP 7.0, dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerjemahkan</a> berbagai bahan tentang topik ini.  Hal ini disebabkan oleh fakta bahwa jumlah pengguna produk kami meningkat, dan penskalaan backend PHP dengan besi sangat mahal - kami memiliki 600 server dengan PHP-FPM.  Karena itu, menginvestasikan waktu dalam pengoptimalan bermanfaat bagi kami. <br><br>  Sebelumnya, kami berbicara terutama tentang cara yang biasa dan sudah mapan dalam bekerja dengan produktivitas.  Tetapi komunitas PHP bersiaga!  JIT akan muncul di PHP 8, preload akan muncul di PHP 7.4, dan kerangka kerja di luar inti pengembangan PHP akan dikembangkan, yang menganggap bahwa PHP berfungsi sebagai daemon.  Sudah waktunya untuk bereksperimen dengan sesuatu yang baru dan melihat apa yang dapat memberi kita. <br><br>  Karena rilis PHP 8 masih jauh, dan kerangka kerja asinkron kurang cocok untuk tugas-tugas kami (mengapa - saya akan katakan di bawah), hari ini kami akan fokus pada preload, yang akan muncul dalam PHP 7.4, dan kerangka kerja untuk mengutilisasi PHP - RoadRunner. <br><br>  Ini adalah versi teks laporan saya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo PHP Meetup # 3</a> .  Video semua pidato yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kumpulkan di pos ini</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php, dan cara-cara serupa untuk menjalankan skrip PHP dan permintaan proses (yang dijalankan oleh sebagian besar situs dan layanan; untuk kesederhanaan, saya akan menyebutnya PHP "klasik") bekerja berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa-apa yang dibagikan</a> dalam pengertian luas istilah: <br><br><ul><li>  negara tidak mencari-cari antara pekerja PHP; <br></li><li>  negara tidak mencari-cari di antara berbagai permintaan. <br></li></ul><br>  Pertimbangkan ini dengan contoh skrip sederhana: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Untuk setiap permintaan, skrip dieksekusi dari baris pertama ke baris terakhir: walaupun faktanya inisialisasi, kemungkinan besar, tidak akan berbeda dari permintaan ke permintaan dan berpotensi dilakukan sekali (menghemat sumber daya), Anda masih harus mengulanginya untuk setiap permintaan.  Kami tidak bisa hanya mengambil dan menyimpan variabel (misalnya, <code>$app</code> ) antara permintaan karena kekhasan cara kerja PHP "klasik". <br><br>  Bagaimana jadinya jika kita melampaui lingkup PHP "klasik"?  Sebagai contoh, skrip kami dapat berjalan terlepas dari permintaan, menginisialisasi dan memiliki loop permintaan di dalamnya, di dalamnya ia akan menunggu yang berikutnya, memprosesnya dan mengulangi loop tanpa membersihkan lingkungan (selanjutnya saya akan menyebut solusi ini "PHP sebagai daemon "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Kami tidak hanya dapat menyingkirkan inisialisasi yang diulang untuk setiap permintaan, tetapi juga menyimpan daftar kota satu kali ke variabel <code>$cities</code> dan menggunakannya dari berbagai permintaan tanpa mengakses di mana pun kecuali memori (ini adalah cara tercepat untuk mendapatkan data). <br><br>  Kinerja solusi semacam itu berpotensi jauh lebih tinggi daripada PHP "klasik".  Tetapi biasanya peningkatan produktivitas tidak diberikan secara gratis - Anda harus membayar sejumlah harga untuk itu.  Mari kita lihat apa yang ada dalam kasus kita. <br><br>  Untuk melakukan ini, mari kita sedikit mempersulit skrip kita dan alih-alih menampilkan variabel <code>$name</code> , kita akan mengisi array: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  Dalam kasus PHP "klasik", tidak akan ada masalah yang muncul - di akhir kueri, variabel <code>$name</code> akan dihancurkan dan setiap permintaan berikutnya akan berfungsi seperti yang diharapkan.  Dalam hal memulai PHP sebagai daemon, setiap permintaan akan menambahkan kota lain ke variabel ini, yang akan mengarah pada pertumbuhan array yang tidak terkontrol hingga memori habis pada mesin. <br><br>  Secara umum, tidak hanya memori yang dapat diakhiri - beberapa kesalahan lain dapat terjadi yang akan menyebabkan kematian proses.  Dengan masalah seperti itu, PHP "klasik" menangani secara otomatis.  Dalam kasus memulai PHP sebagai daemon, kita perlu memonitor daemon ini, me-restart itu jika crash. <br><br>  Kesalahan jenis ini tidak menyenangkan, tetapi ada solusi efektif untuk mereka.  Jauh lebih buruk jika, karena kesalahan, skrip tidak jatuh, tetapi secara tak terduga mengubah nilai beberapa variabel (misalnya, ini menghapus array <code>$cities</code> ).  Dalam hal ini, semua permintaan berikutnya akan berfungsi dengan data yang salah. <br><br><blockquote>  Untuk meringkas, lebih mudah untuk menulis kode untuk "klasik" PHP (PHP-FPM, Apache mod_php dan sejenisnya) - itu membebaskan kita dari sejumlah masalah dan kesalahan.  Tetapi untuk ini kami membayar dengan kinerja. </blockquote><br>  Dari contoh di atas, kita melihat bahwa di beberapa bagian kode, PHP menghabiskan sumber daya yang tidak bisa dihabiskan (atau terbuang sekali) dalam memproses setiap permintaan yang "klasik".  Ini adalah area-area berikut: <br><br><ul><li>  koneksi file (termasuk, memerlukan, dll.); <br></li><li>  inisialisasi (kerangka kerja, perpustakaan, wadah DI, dll); <br></li><li>  meminta data dari penyimpanan eksternal (alih-alih disimpan dalam memori). <br></li></ul><br>  PHP telah ada selama bertahun-tahun dan bahkan mungkin menjadi populer berkat model kerja ini.  Selama waktu ini, banyak metode dengan berbagai tingkat keberhasilan dikembangkan untuk memecahkan masalah yang dijelaskan.  Saya menyebutkan beberapa di antaranya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya sebelumnya.  Hari ini kita akan membahas dua solusi yang cukup baru untuk komunitas: preload dan RoadRunner. <br><br><h2>  Preload </h2><br>  Dari tiga poin yang tercantum di atas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preload</a> dirancang untuk menangani overhead pertama saat menghubungkan file.  Pada pandangan pertama, ini mungkin tampak aneh dan tidak berarti, karena PHP sudah memiliki OPcache, yang dibuat hanya untuk tujuan ini.  Untuk memahami esensi, mari kita profil nyata dengan bantuan <code>perf</code> , di mana OPcache diaktifkan, dengan hit rate sama dengan 100%. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Meskipun OPcache, kami melihat bahwa <code>persistent_compile_file</code> mengambil 5,84% dari waktu eksekusi kueri. <br><br>  Untuk memahami mengapa ini terjadi, kita dapat melihat sumber-sumber <a href="">zend_accel_load_script</a> .  Dapat dilihat dari mereka bahwa, meskipun ada OPcache, dengan setiap panggilan untuk <code>include/require</code> tanda tangan kelas dan fungsi disalin dari memori bersama ke memori proses pekerja, dan berbagai pekerjaan tambahan dilakukan.  Dan pekerjaan ini harus dilakukan untuk setiap permintaan, karena pada akhirnya memori dari proses pekerja dihapus. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Ini diperparah oleh sejumlah besar panggilan sertakan / mengharuskan yang biasanya kita buat dalam satu permintaan.  Misalnya, Symfony 4 menyertakan sekitar 310 file sebelum mengeksekusi baris kode pertama yang bermanfaat.  Terkadang ini terjadi secara implisit: untuk membuat turunan dari kelas A, di bawah ini, PHP akan memuat secara otomatis semua kelas lainnya (B, C, D, E, F, G).  Dan terutama dalam hal ini, ketergantungan Composer yang menyatakan fungsi menonjol: untuk memastikan bahwa fungsi-fungsi ini akan tersedia selama pelaksanaan kode pengguna, Komposer selalu dipaksa untuk menghubungkannya terlepas dari penggunaan, karena PHP tidak memiliki fungsi pengisian otomatis dan mereka tidak dapat dimuat pada saat panggilan. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Bagaimana preload bekerja </h3><br>  Preload memiliki satu pengaturan utama, opcache.preload, di mana jalur ke skrip PHP dilewatkan.  Script ini akan dieksekusi satu kali ketika memulai PHP-FPM / Apache /, dll., Dan semua tanda tangan kelas, metode dan fungsi yang akan dideklarasikan dalam file ini akan tersedia untuk semua skrip yang memproses permintaan dari baris pertama eksekusi mereka (penting Catatan: ini tidak berlaku untuk variabel dan konstanta global - nilainya akan diatur ulang ke nol setelah akhir fase preload).  Anda tidak lagi perlu menyertakan / mengharuskan panggilan dan fungsi tanda tangan / kelas salin dari memori bersama ke memori proses: semuanya dinyatakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dapat diubah</a> dan karena ini semua proses dapat merujuk ke lokasi memori yang sama yang memuatnya. <br><br>  Biasanya kelas dan fungsi yang kita butuhkan ada di file yang berbeda dan tidak nyaman untuk menggabungkannya menjadi satu skrip preload.  Tetapi ini tidak perlu dilakukan: karena preload adalah skrip PHP biasa, kita bisa menggunakan include / require atau opcache_compile_file () dari skrip preload untuk semua file yang kita butuhkan.  Selain itu, karena semua file ini akan dimuat sekali, PHP akan dapat membuat optimasi tambahan yang tidak dapat dilakukan saat kami secara terpisah menghubungkan file-file ini pada saat permintaan.  PHP membuat optimasi hanya dalam kerangka setiap file yang terpisah, tetapi dalam kasus preload, untuk semua kode yang dimuat dalam fase preload. <br><br><h3>  Prapuat patokan awal </h3><br>  Untuk menunjukkan dalam praktiknya manfaat preload, saya mengambil satu titik akhir Badoo yang terikat CPU.  Backend kami umumnya ditandai dengan beban yang terikat CPU.  Fakta ini adalah jawaban untuk pertanyaan mengapa kami tidak mempertimbangkan kerangka kerja asinkron: mereka tidak memberikan keuntungan apa pun dalam kasus beban yang terikat CPU dan pada saat yang sama semakin menyulitkan kode (perlu ditulis secara berbeda), serta untuk bekerja dengan jaringan, disk, dll. diperlukan driver asinkron khusus. <br><br>  Untuk sepenuhnya menghargai manfaat preload, untuk percobaan saya unduh dengan semua file yang diperlukan skrip uji saat bekerja, dan memuatnya dengan kemiripan beban produksi normal menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wrk2</a> - analog lebih maju dari Apache Benchmark, tetapi sama sederhana . <br><br>  Untuk mencoba preload, Anda harus meningkatkan ke PHP 7.4 (kami sekarang memiliki PHP 7.2).  Saya mengukur kinerja PHP 7.2, PHP 7.4 tanpa preload dan PHP 7.4 dengan preload.  Hasilnya adalah gambar seperti itu: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Jadi, transisi dari PHP 7.2 ke PHP 7.4 memberikan + 10% ke kinerja di titik akhir kami, dan preload memberi 10% lagi dari atas. <br><br>  Dalam kasus preload, hasilnya akan sangat tergantung pada jumlah file yang terhubung dan kompleksitas dari logika yang dapat dieksekusi: jika banyak file terhubung dan logikanya sederhana, preload akan memberikan lebih banyak daripada jika ada beberapa file dan logikasinya rumit. <br><br><h3>  Nuansa preload </h3><br>  Apa yang meningkatkan produktivitas biasanya memiliki kerugian.  Preload memiliki banyak nuansa, yang akan saya berikan di bawah ini.  Semuanya perlu diperhitungkan, tetapi hanya satu (pertama) yang bisa menjadi fundamental. <br><br><h4>  Ubah - mulai ulang </h4><br>  Karena semua file preload dikompilasi hanya pada startup, ditandai sebagai tidak dapat diubah dan tidak dikompilasi ulang di masa depan, satu-satunya cara untuk menerapkan perubahan pada file-file ini adalah me-restart (memuat atau me-restart) PHP-FPM / Apache /, dll. <br><br>  Dalam kasus pemuatan ulang, PHP mencoba memulai ulang seakurat mungkin: permintaan pengguna tidak akan terputus, namun demikian, ketika fase preload sedang berlangsung, semua permintaan baru akan menunggu sampai selesai.  Jika tidak ada banyak kode dalam preload, ini mungkin tidak menimbulkan masalah, tetapi jika Anda mencoba mengunduh seluruh aplikasi, itu akan dipenuhi dengan peningkatan waktu respons yang signifikan selama restart. <br><br>  Juga, restart (terlepas dari apakah itu memuat ulang atau restart) memiliki fitur penting - sebagai akibat dari tindakan ini, OPcache dihapus.  Artinya, semua permintaan setelah itu akan berfungsi dengan cache opcode yang dingin, yang dapat meningkatkan waktu respons lebih banyak lagi. <br><br><h4>  Karakter yang tidak ditentukan </h4><br>  Untuk preload untuk memuat kelas, semua yang bergantung padanya harus ditentukan hingga saat ini.  Untuk kelas di bawah ini, ini berarti bahwa semua kelas lain (B, C, D, E, F, G), variabel <code>$someGlobalVar</code> dan SOME_CONST konstan harus tersedia sebelum mengkompilasi kelas ini.  Karena skrip preload hanyalah kode PHP biasa, kita dapat mendefinisikan autoloader.  Dalam hal ini, semua yang terhubung dengan kelas lain akan dimuat olehnya secara otomatis.  Tetapi ini tidak bekerja dengan variabel dan konstanta: kita sendiri harus memastikan bahwa mereka didefinisikan pada saat kelas ini dideklarasikan. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Untungnya, preload berisi alat yang cukup untuk memahami apakah Anda mendapatkan sesuatu atau tidak.  Pertama, ini adalah pesan peringatan dengan informasi tentang apa yang gagal dimuat dan alasannya: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Kedua, preload menambahkan bagian terpisah ke hasil fungsi opcache_get_status (), yang menunjukkan apa yang berhasil dimuat pada fase preload: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Bidang kelas / optimasi konstan </h4><br>  Seperti yang saya tulis di atas, preload menyelesaikan nilai-nilai bidang / konstanta kelas dan menyimpannya.  Ini memungkinkan Anda untuk mengoptimalkan kode: selama pemrosesan permintaan, data sudah siap dan tidak perlu diturunkan dari data lain.  Tetapi ini dapat menyebabkan hasil yang tidak jelas, yang ditunjukkan oleh contoh berikut: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  Hasilnya adalah situasi yang berlawanan dengan intuisi: kelihatannya konstanta harus sama, karena salah satu dari mereka diberi nilai yang lain, tetapi dalam kenyataannya tidak demikian.  Hal ini disebabkan oleh fakta bahwa konstanta global, berbeda dengan konstanta / bidang kelas, secara paksa dihapus setelah fase preload berakhir, sementara konstanta / bidang kelas diselesaikan dan disimpan.  Ini mengarah pada fakta bahwa selama pelaksanaan permintaan kita harus mendefinisikan konstanta global lagi, sebagai akibatnya ia bisa mendapatkan nilai yang berbeda. <br><br><h4>  Tidak dapat mendeklarasikan ulang someFunc () </h4><br>  Dalam kasus kelas, situasinya sederhana: biasanya kita tidak secara eksplisit menghubungkannya, tetapi menggunakan autoloader.  Ini berarti bahwa jika kelas didefinisikan dalam fase preload, maka autoloader tidak akan dieksekusi selama permintaan dan kami tidak akan mencoba untuk menghubungkan kelas ini untuk kedua kalinya. <br><br>  Situasinya berbeda dengan fungsi: kita harus menghubungkannya secara eksplisit.  Ini dapat mengarah pada situasi di mana dalam skrip preload kami akan menghubungkan semua file yang diperlukan dengan fungsi, dan selama permintaan kami akan mencoba melakukannya lagi (contoh khasnya adalah bootloader Komposer: selalu akan mencoba untuk menghubungkan semua file dengan fungsi).  Dalam hal ini, kami mendapatkan kesalahan: fungsi telah ditentukan dan tidak dapat didefinisikan ulang. <br><br>  Masalah ini dapat diselesaikan dengan berbagai cara.  Dalam kasus Komposer, Anda dapat, misalnya, menghubungkan semua yang ada dalam fase preload, dan tidak menghubungkan apa pun yang terkait dengan Komposer selama permintaan.  Solusi lain adalah tidak menghubungkan file dengan fungsi secara langsung, tetapi untuk melakukan ini melalui file proxy dengan cek untuk function_exists (), seperti, misalnya, Guzzle HTTP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> . <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 belum dirilis secara resmi (belum) </h4><br>  Nuansa ini akan menjadi tidak relevan setelah beberapa waktu, tetapi sejauh ini versi PHP 7.4 belum secara resmi dirilis dan tim PHP dalam catatan rilis secara eksplisit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> : "Tolong JANGAN menggunakan versi ini dalam produksi, ini adalah versi tes awal."  Selama percobaan kami dengan preload, kami menemukan beberapa bug, kami memperbaikinya sendiri dan bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirim</a> sesuatu ke hulu.  Untuk menghindari kejutan, lebih baik menunggu rilis resmi. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RoadRunner</a> adalah daemon yang ditulis dalam Go, yang, di satu sisi, menciptakan pekerja PHP dan memonitor mereka (mulai / berakhir / restart sesuai kebutuhan), dan di sisi lain, menerima permintaan dan meneruskannya ke pekerja ini.  Dalam hal ini, pekerjaannya tidak berbeda dengan pekerjaan PHP-FPM (di mana ada juga proses master yang memonitor pekerja).  Namun masih ada perbedaan.  Kuncinya adalah bahwa RoadRunner tidak menyetel ulang status skrip setelah penyelesaian kueri. <br><br>  Jadi, jika kita mengingat daftar sumber daya apa yang dihabiskan untuk PHP "klasik", RoadRunner memungkinkan Anda untuk menangani semua poin (preload, seperti yang kita ingat, hanya dengan yang pertama): <br><br><ul><li>  koneksi file (termasuk, memerlukan, dll.); <br></li><li>  inisialisasi (kerangka kerja, perpustakaan, wadah DI, dll); <br></li><li>  meminta data dari penyimpanan eksternal (alih-alih disimpan dalam memori). <br></li></ul><br>  Contoh Hello World RoadRunner terlihat seperti ini: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Kami akan mencoba titik akhir kami saat ini, yang kami uji dengan preload, untuk berjalan di RoadRunner tanpa modifikasi, memuatnya dan mengukur kinerja.  Tidak ada modifikasi - karena jika tidak patokan tidak akan sepenuhnya jujur. <br><br>  Mari kita coba untuk mengadaptasi contoh Hello World untuk ini. <br><br>  Pertama, seperti yang saya tulis di atas, kami tidak ingin pekerja jatuh jika terjadi kesalahan.  Untuk melakukan ini, kita perlu membungkus semuanya dalam try..catch global.  Kedua, karena skrip kami tidak tahu apa-apa tentang Zend Diactoros, untuk jawabannya kami perlu mengonversi hasilnya.  Untuk ini kami menggunakan fungsi-ob_.  Ketiga, skrip kami tidak tahu apa-apa tentang sifat permintaan PSR-7.  Solusinya adalah mengisi lingkungan PHP standar dari entitas ini.  Dan keempat, skrip kami mengharapkan permintaan untuk mati dan seluruh negara akan dihapus.  Karena itu, dengan RoadRunner kita perlu melakukan pembersihan ini sendiri. <br><br>  Dengan demikian, versi Hello World awal berubah menjadi seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  RoadRunner Benchmarks </h3><br>  Nah, saatnya untuk meluncurkan tolok ukur. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Hasilnya tidak memenuhi harapan: RoadRunner memungkinkan Anda untuk lebih banyak faktor yang menyebabkan kerugian kinerja daripada preload, tetapi hasilnya lebih buruk.  Mari kita cari tahu mengapa ini terjadi, seperti biasa, dengan menjalankan perf untuk ini. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  Dalam hasil perf, kita melihat phar_compile_file.  Ini karena kami menyertakan beberapa file selama eksekusi skrip, dan karena OPcache tidak diaktifkan (RoadRunner menjalankan skrip sebagai CLI, di mana OPcache dimatikan secara default), file-file ini dikompilasi lagi dengan setiap permintaan. <br><br>  Edit konfigurasi RoadRunner - aktifkan OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Hasil ini sudah lebih seperti yang kami harapkan: RoadRunner mulai menunjukkan lebih banyak kinerja daripada preload.  Tapi mungkin kita akan bisa mendapatkan lebih banyak lagi! <br><br>  Tampaknya tidak ada yang lebih aneh dengan perf - mari kita lihat kode PHP.  Cara termudah untuk membuat profil adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phpspy</a> : tidak memerlukan modifikasi kode PHP - Anda hanya perlu menjalankannya di konsol.  Mari kita lakukan ini dan buat grafik nyala: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Karena kami sepakat untuk tidak mengubah logika aplikasi kami untuk kemurnian percobaan, kami tertarik pada cabang tumpukan yang terkait dengan pekerjaan RoadRunner: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  Bagian utama adalah memanggil fread (), hampir tidak ada yang bisa dilakukan dengan ini.  Tetapi kita melihat beberapa cabang lain di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , kecuali untuk ketakutan itu sendiri.  Anda dapat memahami maknanya dengan melihat kode sumber: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Menjadi jelas bahwa RoadRunner sedang mencoba untuk membuat objek permintaan yang sesuai dengan PSR-7 menggunakan array serial.  Jika kerangka kerja Anda bekerja dengan objek permintaan PSR-7 secara langsung (misalnya, Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak berfungsi</a> ), maka ini sepenuhnya dibenarkan.  Dalam kasus lain, PSR-7 menjadi tautan tambahan sebelum permintaan dikonversi ke aplikasi Anda.  Mari kita hapus tautan perantara ini dan lihat kembali hasilnya: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  Skrip tes cukup mudah, jadi saya berhasil memeras sebagian besar kinerja - + 17% dibandingkan dengan PHP murni (saya ingat preload memberi + 10% pada skrip yang sama). <br><br><h3>  Nuansa RoadRunner </h3><br>  Secara umum, penggunaan RoadRunner adalah perubahan yang lebih serius dari sekadar dimasukkannya preload, sehingga nuansa di sini bahkan lebih signifikan. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     «»    —      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Kesimpulan </h2><br> ,    «» PHP,   ,     preload       RoadRunner. <br><br> PHP  «»   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 — 845 RPS; <br></li><li> PHP 7.4 — 931 RPS; <br></li><li> RoadRunner   — 987 RPS; <br></li><li> PHP 7.4 + preload — 1030 RPS; <br></li><li> RoadRunner   — 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472528/">https://habr.com/ru/post/id472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472516/index.html">Yandex.Translator untuk Linux pada Python + GTK3</a></li>
<li><a href="../id472520/index.html">Kit pelatihan dari video - dengan cepat dan efisien</a></li>
<li><a href="../id472522/index.html">Buku "Pengembangan API yang berkelanjutan. Keputusan yang tepat dalam lanskap teknologi yang berubah ”</a></li>
<li><a href="../id472524/index.html">Ruang, kisi, dan tata letak</a></li>
<li><a href="../id472526/index.html">3D melambung tinggi: komposit baru untuk aerospace telah dibuat, yang telah mengurangi massa bagian sebesar 20%</a></li>
<li><a href="../id472530/index.html">Video surveillance di Moskow: realitas dan prospek saat ini</a></li>
<li><a href="../id472532/index.html">Tautan bantuan yang berguna untuk pemasar</a></li>
<li><a href="../id472534/index.html">Mereka bangun! (Novel N.-F., bagian 1 dari 2)</a></li>
<li><a href="../id472536/index.html">Smart IdReader SDK - menanamkan pengakuan dalam proyek-proyek dalam Python dan PHP</a></li>
<li><a href="../id472540/index.html">Mereka bangun! (n.- kisah, bagian 2, dan yang terakhir)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>