<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß üé¶ ü¶ì Fuzzing Style 1989 üâê üò™ üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit Beginn des Jahres 2019 ist es gut, sich an die Vergangenheit zu erinnern und √ºber die Zukunft nachzudenken. Lassen Sie uns 30 Jahre zur√ºckblicken ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fuzzing Style 1989</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435484/">  Mit Beginn des Jahres 2019 ist es gut, sich an die Vergangenheit zu erinnern und √ºber die Zukunft nachzudenken.  Lassen Sie uns 30 Jahre zur√ºckblicken und √ºber die ersten wissenschaftlichen Artikel zum Thema Fuzzing nachdenken: <a href="">‚ÄûEine empirische Studie zur Zuverl√§ssigkeit von UNIX-Dienstprogrammen‚Äú</a> und die anschlie√üende Arbeit <a href="">‚ÄûRevision of Fuzzing‚Äú von 1995</a> des gleichen Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Barton Miller</a> . <br><br>  In diesem Artikel werden wir versuchen, Fehler in modernen Versionen von Ubuntu Linux zu finden, indem wir <b>dieselben Tools</b> wie in den urspr√ºnglichen Fuzzing-Arbeiten verwenden.  Sie m√ºssen die Originaldokumente nicht nur zum Kontext, sondern auch zum Verst√§ndnis lesen.  Sie erwiesen sich in Bezug auf Schwachstellen und Exploits f√ºr die kommenden Jahrzehnte als sehr prophetisch.  Aufmerksame Leser k√∂nnen das Datum der Ver√∂ffentlichung des Originalartikels bemerken: 1990.  Noch aufmerksamer wird das Urheberrecht in den Quellenkommentaren sein: 1989. <br><a name="habracut"></a><br>
<h1>  Kurzer R√ºckblick </h1><br>  F√ºr diejenigen, die die Dokumente nicht gelesen haben (obwohl dies wirklich getan werden sollte), enth√§lt dieser Abschnitt eine kurze Zusammenfassung und einige ausgew√§hlte Zitate. <br><br>  <a href="">Das Fuzzing-Programm</a> generiert zuf√§llige Zeichenstr√∂me mit der M√∂glichkeit, nur druckbare oder nicht druckbare Zeichen zu generieren.  Es wird ein bestimmter Anfangswert (Seed) verwendet, um reproduzierbare Ergebnisse zu erzielen, die modernen Fuzzern h√§ufig fehlen.  Auf den getesteten Programmen wird eine Reihe von Skripten ausgef√ºhrt, die auf das Vorhandensein grundlegender Speicherausz√ºge pr√ºfen.  H√§nge werden manuell erkannt.  Adapter bieten zuf√§llige Eingaben f√ºr interaktive Programme (Artikel von 1990), Netzwerkdienste (1995) und grafische X-Anwendungen (1995). <br><br>  In einem Artikel aus dem Jahr 1990 wurden vier Prozessorarchitekturen (i386, CVAX, Sparc, 68020) und f√ºnf Betriebssysteme (4.3 BSD, SunOS, AIX, Xenix, Dynix) getestet.  In einem Artikel von 1995 eine √§hnliche Auswahl an Plattformen.  Im ersten Artikel fallen je nach Plattform 25-33% der Dienstprogramme aus.  In einem nachfolgenden Artikel liegen diese Zahlen zwischen 9% und 33%, wobei GNU (unter SunOS) und Linux die niedrigste Ausfallrate aufweisen. <br><br>  Ein Artikel aus dem Jahr 1990 kam zu dem Schluss, dass 1) Programmierer keine Array-Grenzen oder Fehlercodes √ºberpr√ºfen, 2) Makros das Lesen und Debuggen von Code erschweren und 3) die C-Sprache sehr unsicher ist.  Die extrem unsichere Funktion und das Typsystem C wurden besonders erw√§hnt. W√§hrend des Tests fanden die Autoren Jahre vor ihrer Massenausnutzung Schwachstellen im Format String.  Der Artikel schlie√üt mit einer Umfrage unter Benutzern, wie oft sie Fehler beheben oder melden.  Es stellte sich heraus, dass das Melden von Fehlern schwierig war und wenig Interesse daran bestand, sie zu beheben. <br><br>  In einem Artikel aus dem Jahr 1995 wird Open Source-Software erw√§hnt und erl√§utert, warum sie weniger Fehler aufweist.  Zitat: <br><br><blockquote>  Als wir die Ursachen der Fehler untersuchten, trat ein beunruhigendes Ph√§nomen auf: Viele der 1990 gemeldeten Fehler (etwa 40%) sind 1995 noch in ihrer genauen Form vorhanden.  ... <br><br>  Die hier verwendeten Methoden sind einfach und meist automatisiert.  Es ist schwer zu verstehen, warum Entwickler diese einfache und kostenlose Quelle nicht verwenden, um die Zuverl√§ssigkeit zu erh√∂hen. </blockquote><br>  Erst in 15 bis 20 Jahren wird die Fuzzing-Technik zur Standardpraxis f√ºr gro√üe Anbieter. <br><br>  Es scheint mir auch, dass diese Erkl√§rung von 1990 zuk√ºnftige Ereignisse vorsieht: <br><br><blockquote>  Oft wird der lakonische Programmierstil C auf das √Ñu√üerste gebracht, die Form hat Vorrang vor der richtigen Funktion.  Die M√∂glichkeit eines √úberlaufs im Eingabepuffer ist eine potenzielle Sicherheitsl√ºcke, wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">j√ºngste Internet-Wurm</a> gezeigt hat. </blockquote><br><h1>  Testmethodik </h1><br>  Gl√ºcklicherweise stellt Dr. Barton 30 Jahre sp√§ter immer noch den <a href="">vollst√§ndigen Quellcode, die Skripte und die Daten zur Verf√ºgung, um seine Ergebnisse zu reproduzieren</a> : ein lobenswertes Beispiel, dem andere Forscher folgen sollten.  Skripte funktionieren ohne Probleme, und das Fuzzing-Tool erforderte nur geringf√ºgige √Ñnderungen zum Kompilieren und Ausf√ºhren. <br><br>  F√ºr diese Tests haben wir <a href="">Skripte und Eingaben aus dem fuzz-1995-basic-Repository verwendet</a> , da es die neueste Liste der <a href="">getesteten Anwendungen gibt</a> .  Laut <a href="">README</a> sind hier die gleichen zuf√§lligen Eingaben wie in der urspr√ºnglichen Studie.  Die folgenden Ergebnisse f√ºr modernes Linux werden <b>genau mit demselben Fuzzing-Code und denselben Eingabedaten</b> wie in den Originalartikeln erhalten.  Nur die Liste der zu testenden Dienstprogramme hat sich ge√§ndert. <br><br><h1>  Dienstprogramm √§ndert sich √ºber 30 Jahre </h1><br>  Offensichtlich haben sich in den letzten 30 Jahren einige √Ñnderungen an Linux-Softwarepaketen ergeben, obwohl einige bew√§hrte Dienstprogramme ihren Stammbaum seit Jahrzehnten beibehalten haben.  Wo immer m√∂glich, haben wir moderne Versionen derselben Programme aus einem Artikel von 1995 √ºbernommen.  Einige Programme sind nicht mehr verf√ºgbar, wir haben sie ersetzt.  Begr√ºndung f√ºr alle Ersetzungen: <br><br><ul><li>  <code>cfe</code> ‚á® <code>cc1</code> : Entspricht dem C-Pr√§prozessor aus dem Artikel von 1995. </li><li>  <code>dbx</code> ‚á® <code>gdb</code> : Entspricht dem Debugger von 1995. </li><li>  <code>ditroff</code> ‚á® <code>groff</code> : <code>ditroff</code> nicht mehr verf√ºgbar. </li><li>  <code>dtbl</code> ‚á® <code>gtbl</code> : Entspricht GNU Troff des alten Dienstprogramms <code>dtbl</code> . </li><li>  <code>clisp</code> ‚á® <code>clisp</code> : Die Standardimplementierung von lisp. </li><li>  <code>more</code> ‚á® <code>less</code> : Weniger ist mehr! </li><li>  <code>prolog</code> ‚á® <code>swipl</code> : Es gibt zwei Optionen f√ºr Prolog: SWI Prolog und GNU Prolog.  SWI Prolog ist vorzuziehen, da es sich um eine √§ltere und vollst√§ndigere Implementierung handelt. </li><li>  <code>awk</code> ‚á® <code>gawk</code> : GNU-Version von <code>awk</code> . </li><li>  <code>cc</code> ‚á® <code>gcc</code> : Der Standard-C-Compiler. </li><li>  <code>compress</code> ‚á® <code>gzip</code> : GZip ist der konzeptionelle Nachkomme des alten Unix-Dienstprogramms <code>compress</code> . </li><li>  <code>lint</code> ‚á® <code>splint</code> : <code>lint</code> unter der GPL umgeschrieben. </li><li>  <code>/bin/mail</code> ‚á® <code>/usr/bin/mail</code> : √Ñquivalentes Dienstprogramm auf andere Weise. </li><li>  <code>f77</code> ‚á® <code>fort77</code> : Es gibt zwei Varianten des Fortan77-Compilers: GNU Fortran und Fort77.  Die erste wird f√ºr Fortran 90 und die zweite f√ºr Fortran77-Unterst√ºtzung empfohlen.  Das <code>f2c</code> Programm <code>f2c</code> aktiv unterst√ºtzt, seine Liste der √Ñnderungen wird seit 1989 beibehalten. </li></ul><br><h1>  Ergebnisse </h1><br>  Die Fuzzing-Technik von 1989 findet 2018 immer noch Fehler.  Aber es gibt einige Fortschritte. <br><br>  Um den Fortschritt zu messen, ben√∂tigen Sie eine Grundlage.  Gl√ºcklicherweise gibt es ein solches Framework f√ºr Linux-Dienstprogramme.  Obwohl Linux zum Zeitpunkt des urspr√ºnglichen Artikels im Jahr 1990 noch nicht existierte, startete ein zweiter Test 1995 den gleichen Fuzzing-Code f√ºr Dienstprogramme aus der Slackware 2.1.0-Distribution von 1995.  Die entsprechenden Ergebnisse sind in <a href="">Tabelle 3 des Artikels von 1995 (S. 7-9) angegeben</a> .  Im Vergleich zu kommerziellen Wettbewerbern sieht GNU / Linux sehr gut aus: <br><br><blockquote>  Der Prozentsatz der Dienstprogrammabst√ºrze in der kostenlosen Linux-Version von UNIX war mit 9% am zweith√∂chsten. </blockquote><br>  Vergleichen wir also die Linux-Dienstprogramme von 1995 und 2018 mit den Fuzzing-Tools von 1989: <br><br><table><tbody><tr><th></th><th>  Ubuntu 18.10 (2018) </th><th>  Ubuntu 18.04 (2018) </th><th>  Ubuntu 16.04 (2016) </th><th>  Ubuntu 14.04 (2014) </th><th>  Slackware 2.1.0 (1995) </th></tr><tr><td>  Abst√ºrze </td><td>  1 (f77) </td><td>  1 (f77) </td><td>  2 (f77, ul) </td><td>  2 (swipl, f77) </td><td>  4 (ul, flex, indent, gdb) </td></tr><tr><td>  Friert ein </td><td>  1 (Zauber) </td><td>  1 (Zauber) </td><td>  1 (Zauber) </td><td>  2 (Zauber, Einheiten) </td><td>  1 (ctags) </td></tr><tr><td>  Insgesamt getestet </td><td>  81 </td><td>  81 </td><td>  81 </td><td>  81 </td><td>  55 </td></tr><tr><td>  Fehler / Einfrieren,% </td><td>  2% </td><td>  2% </td><td>  4% </td><td>  5% </td><td>  9% </td></tr></tbody></table><br>  √úberraschenderweise ist die Anzahl der Abst√ºrze und Einfrierungen von Linux selbst unter der neuesten Version von Ubuntu immer noch gr√∂√üer als Null.  Daher ruft <code>f77</code> das Programm <code>f77</code> mit einem Segmentierungsfehler auf, und das <code>f77</code> h√§ngt an zwei Versionen der <code>f77</code> . <br><br><h1>  Welche Fehler? </h1><br>  Ich konnte die Grundursache einiger Fehler manuell herausfinden.  Einige Ergebnisse, wie z. B. ein Fehler in glibc, waren unerwartet, w√§hrend andere, z. B. sprintf mit einer festen Puffergr√∂√üe, vorhersehbar waren. <br><br><h3>  Ul Versagen </h3><br>  Der Fehler in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ul</a> ist eigentlich ein Fehler in glibc.  Insbesondere wurde es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> (eine andere Person fand es in <code>ul</code> ) im Jahr 2016 gemeldet.  Laut Bug-Tracker ist der Fehler immer noch nicht behoben.  Da der Fehler unter Ubuntu 18.04 und h√∂her nicht reproduziert werden kann, wird er auf Verteilungsebene behoben.  Nach den Kommentaren zum Bug-Tracker zu urteilen, kann das Hauptproblem sehr ernst sein. <br><br><h3>  Absturz f77 </h3><br>  Das Programm f77 ist im Paket fort77 enthalten, das selbst ein Shell-Skript f√ºr <code>f2c</code> , den Quell√ºbersetzer von Fortran77 nach C. Das Debuggen von f2c zeigt, dass ein Fehler auftritt, wenn die <code>errstr</code> Funktion eine zu lange Fehlermeldung druckt.  Der <a href="">f2c-Quellcode</a> zeigt, dass die sprintf-Funktion verwendet wird, um eine Zeichenfolge variabler L√§nge in einen Puffer fester Gr√∂√üe zu schreiben: <br><br><pre> <code class="plaintext hljs">errstr(const char *s, const char *t) #endif { char buff[100]; sprintf(buff, s, t); err(buff); }</code> </pre> <br>  Es scheint, dass dieser Code seit der Erstellung von <code>f2c</code> erhalten geblieben ist.  Das Programm hat seit mindestens 1989 eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschichte des Wandels</a> .  1995 wurde der Fortran77-Compiler beim erneuten Fuzzing nicht getestet, da das Problem sonst fr√ºher gefunden worden w√§re. <br><br><h3>  Zauber einfrieren </h3><br>  Ein gro√üartiges Beispiel f√ºr einen klassischen Deadlock.  <code>spell</code> <code>ispell</code> durch eine Pipe.  <code>spell</code> liest den Text zeilenweise und erzeugt einen <code>ispell</code> mit der Gr√∂√üe der Zeile in <code>ispell</code> .  <code>ispell</code> liest jedoch maximal <code>BUFSIZ/2</code> Bytes gleichzeitig (4096 Bytes auf meinem System) und gibt einen Blockierungsdatensatz aus, um sicherzustellen, dass der Client Validierungsdaten erhalten hat, die bisher verarbeitet wurden.  Zwei verschiedene <code>ispell</code> zwangen den <code>spell</code> , eine Zeichenfolge mit mehr als 4096 Zeichen f√ºr <code>ispell</code> zu schreiben, was zu einem Deadlock f√ºhrte: Der <code>spell</code> wartet darauf, dass <code>ispell</code> die gesamte Zeichenfolge liest, w√§hrend <code>ispell</code> auf den <code>spell</code> wartet, um <code>spell</code> best√§tigen, dass die urspr√ºnglichen Rechtschreibkorrekturen gelesen wurden. <br><br><h3>  Einheiten aufh√§ngen </h3><br>  Auf den ersten Blick scheint es eine Endlosschleifenbedingung zu geben.  Der Hang scheint in <code>libreadline</code> und nicht in <code>units</code> , obwohl neuere Versionen von <code>units</code> nicht unter diesem Fehler leiden.  Das √Ñnderungsprotokoll zeigt an, dass eine Eingabefilterung hinzugef√ºgt wurde, die dieses Problem versehentlich beheben k√∂nnte.  Eine gr√ºndliche Untersuchung der Gr√ºnde w√ºrde jedoch den Rahmen dieses Blogs sprengen.  Vielleicht ist der Weg, <code>libreadline</code> aufzuh√§ngen, <code>libreadline</code> noch da. <br><br><h3>  Swipl Absturz </h3><br>  Der Vollst√§ndigkeit halber m√∂chte ich den <code>swipl</code> Absturz erw√§hnen, obwohl ich ihn nicht sorgf√§ltig untersucht habe, da der Fehler seit langem behoben wurde und von ziemlich hoher Qualit√§t zu sein scheint.  Fehler ist eigentlich eine Anweisung (d. H. Eine, die niemals passieren sollte), die beim Konvertieren von Zeichen aufgerufen wird: <br><br> <code>[Thread 1] pl-fli.c:2495: codeToAtom: Assertion failed: chrcode &gt;= 0 <br> C-stack trace labeled "crash": <br> [0] __assert_fail+0x41 <br> [1] PL_put_term+0x18e <br> [2] PL_unify_text+0x1c4 <br> ‚Ä¶</code> <br> <br>  Der Absturz ist immer schlimm, aber zumindest hier kann das Programm einen Fehler melden, der fr√ºh und laut abst√ºrzt. <br><br><h1>  Fazit </h1><br>  In den letzten 30 Jahren war das Fuzzing ein einfacher und zuverl√§ssiger Weg, um Fehler zu finden.  Obwohl in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Bereich</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktive Forschung betrieben wird</a> , findet selbst der Fuzzer von vor 30 Jahren erfolgreich Fehler in modernen Linux-Dienstprogrammen. <br><br>  Der Autor der Originalartikel sagte die Sicherheitsprobleme voraus, die C in den kommenden Jahrzehnten verursachen w√ºrde.  Er argumentiert √ºberzeugend, dass unsicherer Code zu einfach in C zu schreiben ist und nach M√∂glichkeit vermieden werden sollte.  Insbesondere zeigen die Artikel, dass Fehler auch bei einfachster Phaseneinstellung auftreten, und solche Tests sollten in die Standardpraxis der Softwareentwicklung einbezogen werden.  Leider wird dieser Rat seit Jahrzehnten nicht mehr befolgt. <br><br>  Ich hoffe, Ihnen hat diese 30-j√§hrige Retrospektive gefallen.  Warten Sie auf den n√§chsten Fuzzing in 2000-Artikel, in dem wir untersuchen, wie robust Windows 10-Anwendungen im Vergleich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu ihren Windows NT / 2000-Entsprechungen sind, wenn sie mit Fuzzer getestet werden</a> .  Ich denke, die Antwort ist vorhersehbar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435484/">https://habr.com/ru/post/de435484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435468/index.html">React Tutorial Teil 7: Inline-Stile</a></li>
<li><a href="../de435470/index.html">React Tutorial, Teil 8: Fortsetzung der Arbeit an einer TODO-Anwendung, Einf√ºhrung in die Komponenteneigenschaften</a></li>
<li><a href="../de435476/index.html">Mkcert: g√ºltige HTTPS-Zertifikate f√ºr localhost</a></li>
<li><a href="../de435480/index.html">Microsoft und Kroger werden Amazon einen Kampf auf dem Gebiet geben ... den Handel mit Lebensmitteln</a></li>
<li><a href="../de435482/index.html">Zirkon-Highlight: vDSO (virtuelles dynamisches gemeinsames Objekt)</a></li>
<li><a href="../de435488/index.html">Verspottet, stummelt und spioniert im Spock Framework</a></li>
<li><a href="../de435490/index.html">Google Steuer√§nderungen im Jahr 2019</a></li>
<li><a href="../de435494/index.html">Nahtloser Client-Server</a></li>
<li><a href="../de435496/index.html">Tesla klagte wegen eines Unfalls, bei dem Fahrer und Beifahrer des Modells S starben</a></li>
<li><a href="../de435498/index.html">vCloud Director Extender: Migration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>