<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê© üë©üèø‚Äçü§ù‚Äçüë®üèæ üñåÔ∏è Le livre Kafka Streams en action. Applications et microservices en temps r√©el ¬ª ü§∂üèø üíÜüèæ ü•ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Ce livre convient √† tout d√©veloppeur qui souhaite comprendre le traitement en streaming. Comprendre la programmation distribu√©e v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre Kafka Streams en action. Applications et microservices en temps r√©el ¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457756/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/na/mw/fb/namwfbeornc4ba8jkaodlvjlm68.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Ce livre convient √† tout d√©veloppeur qui souhaite comprendre le traitement en streaming.  Comprendre la programmation distribu√©e vous aidera √† mieux comprendre Kafka et Kafka Streams.  Ce serait bien de conna√Ætre le framework Kafka lui-m√™me, mais ce n'est pas n√©cessaire: je vais vous dire tout ce dont vous avez besoin.  Gr√¢ce √† ce livre, les d√©veloppeurs Kafka exp√©riment√©s, comme les novices, apprendront √† cr√©er des applications de streaming int√©ressantes √† l'aide de la biblioth√®que Kafka Streams.  Les d√©veloppeurs Java interm√©diaires et de haut niveau familiaris√©s avec des concepts tels que la s√©rialisation apprendront √† appliquer leurs comp√©tences pour cr√©er des applications Kafka Streams.  Le code source du livre est √©crit en Java 8 et utilise essentiellement la syntaxe des expressions lambda de Java 8, donc la possibilit√© de travailler avec des fonctions lambda (m√™me dans un autre langage de programmation) vous est utile. <br><a name="habracut"></a><br><h3>  Extrait.  5.3.  Op√©rations d'agr√©gation et de fen√™tres </h3><br>  Dans cette section, nous passons aux parties les plus prometteuses de Kafka Streams.  Jusqu'√† pr√©sent, nous avons couvert les aspects suivants des flux Kafka: <br><br><ul><li>  cr√©er une topologie de traitement; </li><li>  utilisation de l'√©tat dans les applications de streaming; </li><li>  √©tablir des connexions de flux de donn√©es; </li><li>  diff√©rences entre les flux d'√©v√©nements (KStream) et les flux de mise √† jour (KTable). </li></ul><br>  Dans les exemples suivants, nous allons rassembler tous ces √©l√©ments.  De plus, vous serez initi√© aux op√©rations sur les fen√™tres - une autre grande fonctionnalit√© des applications de streaming.  Notre premier exemple sera l'agr√©gation simple. <br><br>
<h3>  5.3.1.  Agr√©gation des ventes d'actions par industrie </h3><br>  L'agr√©gation et le regroupement sont des outils essentiels pour travailler avec des donn√©es en streaming.  L'examen des dossiers individuels sur une base d'admission n'est souvent pas suffisant.  Pour extraire des informations suppl√©mentaires des donn√©es, leur regroupement et leur combinaison sont n√©cessaires. <br><br>  Dans cet exemple, vous devez essayer la combinaison d'un trader intrajournalier qui doit suivre le volume des ventes d'actions de soci√©t√©s dans plusieurs secteurs.  En particulier, vous vous int√©ressez aux cinq soci√©t√©s qui r√©alisent les plus grandes parts de ventes dans chaque industrie. <br><br>  Pour une telle agr√©gation, vous aurez besoin de plusieurs des √©tapes suivantes pour traduire les donn√©es sous la forme souhait√©e (en termes g√©n√©raux). <br><br><ol><li>  Cr√©ez une source th√©matique qui publie des informations brutes sur les transactions boursi√®res.  Nous devrons mapper un objet de type StockTransaction √† un objet de type ShareVolume.  Le fait est que l'objet StockTransaction contient des m√©tadonn√©es de vente, et nous n'avons besoin que de donn√©es sur le nombre d'actions vendues. </li><li>  Groupez les donn√©es de volume de partage par symboles boursiers.  Apr√®s avoir regroup√© par symboles, vous pouvez r√©duire ces donn√©es en sous-totaux des ventes d'actions.  Il convient de noter que la m√©thode KStream.groupBy renvoie une instance de type KGroupedStream.  Et vous pouvez obtenir une instance de KTable en appelant la m√©thode KGroupedStream.reduce plus tard. </li></ol><br><blockquote>  <b>Qu'est-ce que l'interface KGroupedStream</b> <br><br>  Les m√©thodes KStream.groupBy et KStream.groupByKey renvoient une instance de KGroupedStream.  KGroupedStream est une repr√©sentation interm√©diaire du flux d'√©v√©nements apr√®s regroupement par cl√©.  Il n'est pas du tout destin√© √† fonctionner directement avec lui.  Au lieu de cela, KGroupedStream est utilis√© pour les op√©rations d'agr√©gation, dont le r√©sultat est toujours KTable.  Et comme le r√©sultat des op√©rations d'agr√©gation est KTable et qu'elles utilisent le stockage d'√©tat, il est possible que toutes les mises √† jour en cons√©quence ne soient pas envoy√©es plus loin dans le pipeline. <br><br>  La m√©thode KTable.groupBy renvoie un KGroupedTable similaire - une repr√©sentation interm√©diaire du flux de mises √† jour regroup√©es par cl√©. </blockquote><br>  Prenons une courte pause et regardons la fig.  5.9, qui montre ce que nous avons accompli.  Cette topologie devrait d√©j√† vous √™tre famili√®re. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9v/p3/ne/9vp3ne2cqpquhvlkmjo6wncqwsm.png" alt="image"></div><br>  Voyons maintenant le code de cette topologie (il se trouve dans le fichier src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listing 5.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8w/cz/lz/8wczlzab4gf5y7sjluyyu2f1vdi.png" alt="image"></div><br>  Le code donn√© diff√®re par sa bri√®vet√© et un grand volume d'actions effectu√©es sur plusieurs lignes.  Dans le premier param√®tre de la m√©thode builder.stream, vous pouvez remarquer quelque chose de nouveau par vous-m√™me: la valeur du type √©num√©r√© AutoOffsetReset.EARLIEST (il existe √©galement LATEST), d√©finie √† l'aide de la m√©thode Consumed.withOffsetResetPolicy.  En utilisant ce type √©num√©r√©, vous pouvez sp√©cifier une strat√©gie de r√©initialisation des d√©calages pour chacun de KStream ou KTable; il a priorit√© sur le param√®tre de r√©initialisation des d√©calages de la configuration. <br><br><blockquote>  <b>GroupByKey et GroupBy</b> <br><br>  L'interface KStream propose deux m√©thodes de regroupement des enregistrements: GroupByKey et GroupBy.  Les deux renvoient KGroupedTable, vous pourriez donc avoir une question l√©gitime: quelle est la diff√©rence entre eux et quand utiliser lequel? <br><br>  La m√©thode GroupByKey est utilis√©e lorsque les cl√©s de KStream sont d√©j√† non vides.  Et surtout, l'indicateur ¬´n√©cessite une nouvelle partition¬ª n'a jamais √©t√© d√©fini. <br><br>  La m√©thode GroupBy suppose que vous avez modifi√© les cl√©s de regroupement, donc l'indicateur de re-partitionnement est d√©fini sur true.  Effectuer des connexions, des agr√©gations, etc. apr√®s la m√©thode GroupBy entra√Ænera un re-partitionnement automatique. <br>  R√©sum√©: Vous devez utiliser GroupByKey plut√¥t que GroupBy dans la mesure du possible. </blockquote><br>  Ce que font les m√©thodes mapValues ‚Äã‚Äãet groupBy est compr√©hensible, alors jetez un ≈ìil √† la m√©thode sum () (elle se trouve dans le fichier src / main / java / bbejeck / model / ShareVolume.java) (Listing 5.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/va/bb/e5/vabbe54p2ntwmyk1yllak6s4m4q.png" alt="image"></div><br>  La m√©thode ShareVolume.sum renvoie le sous-total du volume des ventes d'actions et le r√©sultat de toute la cha√Æne de calcul est un objet KTable &lt;String, ShareVolume&gt;.  Vous comprenez maintenant quel r√¥le joue KTable.  Lorsque les objets ShareVolume arrivent, la derni√®re mise √† jour actuelle est enregistr√©e dans le KTable correspondant.  Il est important de ne pas oublier que toutes les mises √† jour sont refl√©t√©es dans le pr√©c√©dent shareVolumeKTable, mais toutes ne sont pas envoy√©es plus loin. <br><br>  De plus, avec l'aide de ce tableau, nous effectuons une agr√©gation (par le nombre d'actions vendues) afin d'obtenir les cinq soci√©t√©s avec les ventes d'actions les plus √©lev√©es dans chaque industrie.  Nos actions dans ce cas seront similaires aux actions lors de la premi√®re agr√©gation. <br><br><ol><li>  Effectuez une autre op√©ration groupBy pour regrouper des objets ShareVolume individuels par secteur. </li><li>  Passez √† r√©sumer les objets ShareVolume.  Cette fois, l'objet d'agr√©gation est une file d'attente prioritaire de taille fixe.  Seules cinq soci√©t√©s avec le plus grand nombre d'actions vendues sont conserv√©es dans une telle file d'attente de taille fixe. </li><li>  Affichez les lignes du paragraphe pr√©c√©dent dans une valeur de cha√Æne et retournez les cinq meilleures ventes par le nombre d'actions par industrie. </li><li>  √âcrivez les r√©sultats sous forme de cha√Æne dans la rubrique. </li></ol><br>  Dans la fig.  5.10 montre un graphique de la topologie du mouvement des donn√©es.  Comme vous pouvez le voir, le deuxi√®me cycle de traitement est assez simple. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4q/3p/j5/4q3pj5lkggxqnu6lpcmtgo52dqq.png" alt="image"></div><br>  Maintenant, apr√®s avoir bien compris la structure de ce deuxi√®me cycle de traitement, vous pouvez vous r√©f√©rer √† son code source (vous le trouverez dans le fichier src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listing 5.4). <br><br>  Il existe une variable fixedQueue dans cet initialiseur.  Il s'agit d'un objet personnalis√© - un adaptateur pour java.util.TreeSet, qui est utilis√© pour suivre les r√©sultats les plus √©lev√©s dans l'ordre d√©croissant du nombre de parts vendues. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/03/mn/nm/03mnnmhuvjpivozqptxxzpkdrmu.png" alt="image"></div><br>  Vous avez d√©j√† rencontr√© des appels √† groupBy et mapValues, nous ne nous arr√™terons donc pas sur eux (nous appelons la m√©thode KTable.toStream, car la m√©thode KTable.print est d√©conseill√©e).  Mais vous n'avez pas encore vu la version KTable de la m√©thode d'agr√©gat (), nous allons donc passer un peu de temps √† en discuter. <br><br>  Comme vous vous en souvenez, KTable se distingue par le fait que les enregistrements avec les m√™mes cl√©s sont consid√©r√©s comme des mises √† jour.  KTable remplace l'ancien enregistrement par le nouveau.  L'agr√©gation se d√©roule de la m√™me mani√®re: les derniers enregistrements avec une cl√© sont agr√©g√©s.  Lorsqu'un enregistrement arrive, il est ajout√© √† une instance de la classe FixedSizePriorityQueue √† l'aide d'un additionneur (le deuxi√®me param√®tre de l'appel √† la m√©thode d'agr√©gation), mais si un autre enregistrement avec la m√™me cl√© existe d√©j√†, l'ancien enregistrement est supprim√© √† l'aide du soustracteur (le troisi√®me param√®tre de l'appel √† la m√©thode d'agr√©gation). <br><br>  Cela signifie que notre agr√©gateur, FixedSizePriorityQueue, n'agr√®ge pas toutes les valeurs avec une seule cl√©, mais stocke la somme mobile des quantit√©s N des types de stocks les plus vendus.  Chaque entr√©e contient le nombre total d'actions vendues jusqu'√† pr√©sent.  KTable vous fournira des informations sur les actions des soci√©t√©s qui sont actuellement les plus vendues; l'agr√©gation continue de chaque mise √† jour n'est pas requise. <br><br>  Nous avons appris √† faire deux choses importantes: <br><br><ul><li>  regrouper les valeurs dans KTable par une cl√© qui leur est commune; </li><li>  Effectuez des op√©rations utiles telles que la convolution et l'agr√©gation sur ces valeurs group√©es. </li></ul><br>  La capacit√© d'effectuer ces op√©rations est importante pour comprendre la signification des donn√©es qui transitent par l'application Kafka Streams et d√©terminer quelles informations elles contiennent. <br><br>  Nous avons √©galement rassembl√© certains des concepts cl√©s discut√©s plus haut dans ce livre.  Au chapitre 4, nous avons parl√© de l'importance d'un √©tat local √† s√©curit√© int√©gr√©e pour une application de streaming.  Le premier exemple de ce chapitre a montr√© pourquoi l'√âtat local est si important - il permet de suivre les informations que vous avez d√©j√† vues.  L'acc√®s local √©vite les retards r√©seau, rendant l'application plus productive et r√©sistante aux erreurs. <br><br>  Lorsque vous effectuez une op√©ration de convolution ou d'agr√©gation, vous devez sp√©cifier le nom du magasin d'√©tat.  Les op√©rations de convolution et d'agr√©gation renvoient une instance de KTable, et KTable utilise un magasin d'√©tat pour remplacer les anciens r√©sultats par de nouveaux.  Comme vous l'avez vu, toutes les mises √† jour ne sont pas envoy√©es plus loin dans le pipeline, ce qui est important, car les op√©rations d'agr√©gation sont con√ßues pour obtenir les informations finales.  Si l'√©tat local n'est pas appliqu√©, KTable enverra en outre tous les r√©sultats d'agr√©gation et de convolution. <br><br>  Ensuite, nous examinons l'ex√©cution d'op√©rations telles que l'agr√©gation, dans une p√©riode de temps sp√©cifique - les op√©rations dites de fen√™trage. <br><br><h3>  5.3.2.  Op√©rations de fen√™tre </h3><br>  Dans la section pr√©c√©dente, nous avons introduit la convolution et l'agr√©gation ¬´roulante¬ª.  L'application a effectu√© une convolution continue des ventes d'actions avec l'agr√©gation subs√©quente des cinq actions les plus vendues. <br><br>  Parfois, une telle agr√©gation continue et convolution des r√©sultats est n√©cessaire.  Et parfois, vous devez effectuer des op√©rations uniquement sur une p√©riode de temps donn√©e.  Par exemple, calculez combien de transactions boursi√®res ont √©t√© effectu√©es avec des actions d'une entreprise particuli√®re au cours des 10 derni√®res minutes.  Ou combien d'utilisateurs ont cliqu√© sur une nouvelle banni√®re publicitaire au cours des 15 derni√®res minutes.  Une application peut effectuer de telles op√©rations plusieurs fois, mais avec des r√©sultats li√©s uniquement √† des intervalles de temps sp√©cifi√©s (fen√™tres de temps). <br><br><h3>  Comptage des transactions d'√©change par acheteur </h3><br>  Dans l'exemple suivant, nous serons engag√©s dans le suivi des transactions de change pour plusieurs commer√ßants - soit de grandes organisations, soit de simples financiers intelligents. <br><br>  Il y a deux raisons possibles √† ce suivi.  L'un d'eux est la n√©cessit√© de savoir ce que les leaders du march√© ach√®tent / vendent.  Si ces grands acteurs et investisseurs avertis voient des opportunit√©s par eux-m√™mes, il est logique de suivre leur strat√©gie.  La deuxi√®me raison est le d√©sir de remarquer tout signe possible de transactions ill√©gales utilisant des informations privil√©gi√©es.  Pour ce faire, vous devrez analyser la corr√©lation des fortes hausses des ventes avec les communiqu√©s de presse importants. <br><br>  Un tel suivi comprend des √©tapes telles que: <br><br><ul><li>  cr√©er un flux pour la lecture du sujet des transactions boursi√®res; </li><li>  regroupement des enregistrements entrants par ID client et symbole boursier du stock.  Un appel √† la m√©thode groupBy renvoie une instance de la classe KGroupedStream; </li><li>  KGroupedStream.windowedBy renvoie un flux de donn√©es d√©limit√© par une fen√™tre temporaire, qui permet l'agr√©gation de fen√™tres.  Selon le type de fen√™tre, TimeWindowedKStream ou SessionWindowedKStream est renvoy√©; </li><li>  Comptage des transactions pour une op√©ration d'agr√©gation.  Le flux de donn√©es de fen√™tre d√©termine si un enregistrement particulier est pris en compte dans ce calcul; </li><li>  √©crire des r√©sultats dans une rubrique ou les afficher sur la console pendant le d√©veloppement. </li></ul><br>  La topologie de cette application est simple, mais son image visuelle ne fait pas de mal.  Jetez un oeil √† la photo.  5.11. <br><br>  De plus, nous consid√©rerons la fonctionnalit√© des op√©rations de fen√™tre et le code correspondant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/bd/fi/1hbdfi2s0x4x4up8kkcomwg_omq.png" alt="image"></div><br><h3>  Types de fen√™tres </h3><br>  Il existe trois types de fen√™tres dans Kafka Streams: <br><br><ul><li>  session </li><li>  Tumbling (tumbling); </li><li>  glissement / "saut" (glissement / saut). </li></ul><br>  Le choix d√©pend des besoins de l'entreprise.  Les fen√™tres "Tumbling" et "jumping" sont limit√©es dans le temps, tandis que les restrictions de session sont associ√©es aux actions de l'utilisateur - la dur√©e de la ou des sessions est d√©termin√©e uniquement par le comportement actif de l'utilisateur.  L'essentiel est de ne pas oublier que tous les types de fen√™tres sont bas√©s sur les horodatages des enregistrements et non sur l'heure syst√®me. <br><br>  Ensuite, nous impl√©mentons notre topologie avec chacun des types de fen√™tres.  Le code complet ne sera donn√© que dans le premier exemple, rien ne changera pour les autres types de fen√™tres, √† l'exception du type d'op√©ration de fen√™tre. <br><br><h3>  Fen√™tres de session </h3><br>  Les fen√™tres de session sont tr√®s diff√©rentes de tous les autres types de fen√™tres.  Ils sont limit√©s non pas tant par le temps que par l'activit√© de l'utilisateur (ou l'activit√© de l'entit√© que vous souhaitez suivre).  Les fen√™tres de session sont d√©limit√©es par des p√©riodes d'inactivit√©. <br><br>  La figure 5.12 illustre le concept des fen√™tres de session.  Une session plus petite fusionnera avec la session √† sa gauche.  Et la session de droite sera s√©par√©e, car elle suit une longue p√©riode d'inactivit√©.  Les fen√™tres de session sont bas√©es sur les actions de l'utilisateur, mais appliquent des horodatages √† partir des enregistrements pour d√©terminer √† quelle session l'enregistrement appartient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/c7/z5/jsc7z525p9wrj_tlmrfa5e3vj_u.png" alt="image"></div><br><br><h3>  Utilisation des fen√™tres de session pour suivre les transactions Exchange </h3><br>  Nous utiliserons des fen√™tres de session pour capturer des informations sur les transactions d'√©change.  L'impl√©mentation des fen√™tres de session est pr√©sent√©e dans le Listing 5.5 (qui se trouve dans src / main / java / bbejeck / chapter_5 / CountingWindowingAndKTableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/vq/va/vsvqvaqddc3hgy-77fpniuwcbxm.png" alt="image"></div><br>  Vous avez d√©j√† rencontr√© la plupart des op√©rations de cette topologie, il n'est donc pas n√©cessaire de les consid√©rer ici √† nouveau.  Mais il y a plusieurs nouveaux √©l√©ments que nous allons discuter maintenant. <br><br>  Pour toute op√©ration groupBy, une sorte d'op√©ration d'agr√©gation (agr√©gation, convolution ou comptage) est g√©n√©ralement effectu√©e.  Vous pouvez effectuer une agr√©gation cumulative avec un total cumul√© ou une agr√©gation de fen√™tres, dans laquelle les enregistrements sont pris en compte dans une fen√™tre de temps donn√©e. <br><br>  Le code du Listing 5.5 compte le nombre de transactions dans les fen√™tres de session.  Dans la fig.  5.13 ces actions sont analys√©es √©tape par √©tape. <br><br>  En appelant windowedBy (SessionWindows. With (vingt secondes). Jusqu'√† (quinze minutes)), nous cr√©ons une fen√™tre de session avec un intervalle d'inactivit√© de 20 secondes et un intervalle de r√©tention de 15 minutes.  Un intervalle d'inactivit√© de 20 secondes signifie que l'application inclura tout enregistrement qui arrive dans les 20 secondes suivant la fin ou le d√©but de la session en cours dans la session en cours (active). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/mk/qv/jhmkqvxrrnrd5mxavzltcu-uglq.png" alt="image"></div><br>  Ensuite, nous indiquons quelle op√©ration d'agr√©gation effectuer dans la fen√™tre de session - dans ce cas, comptez.  Si l'enregistrement entrant tombe en dehors de l'intervalle d'inactivit√© (de chaque c√¥t√© du cachet de date / heure), l'application cr√©e une nouvelle session.  Un intervalle de sauvegarde signifie le maintien d'une session pendant un certain temps et permet des donn√©es en retard qui vont au-del√† de la p√©riode d'inactivit√© de la session mais peuvent toujours √™tre attach√©es.  De plus, le d√©but et la fin d'une nouvelle session r√©sultant de la fusion correspondent √† l'horodatage le plus ancien et le plus r√©cent. <br><br>  Examinons quelques entr√©es de la m√©thode count pour voir comment les sessions fonctionnent (tableau 5.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p-/_f/pn/p-_fpnxaicjsj0ivwzrcxthi77g.png" alt="image"></div><br>  Lors de la r√©ception des enregistrements, nous recherchons les sessions d√©j√† existantes avec la m√™me cl√©, l'heure de fin est inf√©rieure √† la date / heure actuelle - l'intervalle d'inactivit√© et l'heure de d√©but sont sup√©rieures √† la date / heure actuelle + intervalle d'inactivit√©.  Dans cet esprit, quatre enregistrements de la table.  5.1 fusionner en une seule session comme suit. <br><br>  1. L'enregistrement 1 vient en premier, donc l'heure de d√©but est √©gale √† l'heure de fin et est 00:00:00. <br><br>  2. Vient ensuite l'enregistrement 2, et nous recherchons des sessions qui se terminent au plus t√¥t √† 23:59:55 et commencent au plus tard √† 00:00:35.  Recherchez l'enregistrement 1 et combinez les sessions 1 et 2. Prenez l'heure de d√©but de la session 1 (plus t√¥t) et l'heure de fin de la session 2 (plus tard), de sorte que notre nouvelle session commence √† 00:00:00 et se termine √† 00:00:15. <br><br>  3. L'enregistrement 3 arrive, nous recherchons des sessions entre 00:00:30 et 00:01:10 et n'en trouvons aucune.  Ajoutez une deuxi√®me session pour la cl√© 123-345-654, FFBE, commen√ßant et se terminant √† 00:00:50. <br><br>  4. L'enregistrement 4 arrive et nous recherchons des sessions entre 23:59:45 et 00:00:25.  Cette fois, il y a deux sessions - 1 et 2. Les trois sessions sont combin√©es en une seule, avec une heure de d√©but de 00:00:00 et une heure de fin de 00:00:15. <br><br>  D'apr√®s ce qui est dit dans cette section, il convient de se rappeler les nuances importantes suivantes: <br><br><ul><li>  Les sessions ne sont pas des fen√™tres de taille fixe.  La dur√©e d'une session est d√©termin√©e par l'activit√© dans une p√©riode de temps donn√©e; </li><li>  Les horodatages dans les donn√©es d√©terminent si un √©v√©nement tombe dans une session existante ou dans une p√©riode d'inactivit√©. </li></ul><br>  Plus loin, nous discuterons du type de fen√™tres suivant - les fen√™tres de "saut p√©rilleux". <br><br><h3>  Fen√™tres √† bascule </h3><br>  Les fen√™tres ¬´tumbling¬ª capturent les √©v√©nements qui se produisent dans une certaine p√©riode de temps.  Imaginez que vous devez capturer toutes les transactions d'√©change d'une entreprise toutes les 20 secondes, afin de collecter tous les √©v√©nements de cette p√©riode.  √Ä la fin de l'intervalle de 20 secondes, la fen√™tre ¬´bascule¬ª et passe √† un nouvel intervalle d'observation de 20 secondes.  La figure 5.14 illustre cette situation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sb/jh/gesbjhkrk4wfpsj94edv21lcgzk.png" alt="image"></div><br>  Comme vous pouvez le voir, tous les √©v√©nements re√ßus au cours des 20 derni√®res secondes sont inclus dans la fen√™tre.  √Ä la fin de cette p√©riode, une nouvelle fen√™tre est cr√©√©e. <br><br>  Le listing 5.6 montre le code qui illustre l'utilisation de fen√™tres tumbling pour capturer les transactions d'√©change toutes les 20 secondes (vous pouvez le trouver dans src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/gw/ba/ejgwbaxfd9vzmdok1u6vl7gqjt4.png" alt="image"></div><br>  Gr√¢ce √† cette petite modification de l'appel √† la m√©thode TimeWindows.of, vous pouvez utiliser la fen√™tre tumbling.  Dans cet exemple, il n'y a aucun appel √† la m√©thode until (), √† la suite de quoi l'intervalle de sauvegarde par d√©faut de 24 heures sera utilis√©. <br><br>  Enfin, il est temps de passer √† la derni√®re des options de fen√™tre - saut de fen√™tres. <br><br><h3>  Fen√™tres coulissantes ("sautantes") </h3><br>  Les fen√™tres coulissantes / ¬´sautillantes¬ª sont similaires au ¬´culbutage¬ª, mais avec une l√©g√®re diff√©rence.  Les fen√™tres coulissantes n'attendent pas la fin de l'intervalle de temps avant de cr√©er une nouvelle fen√™tre pour g√©rer les √©v√©nements r√©cents.  Ils commencent de nouveaux calculs apr√®s un intervalle d'attente plus court que la dur√©e de la fen√™tre. <br><br>  Pour illustrer les diff√©rences entre les fen√™tres ¬´saut p√©rilleux¬ª et ¬´sautant¬ª, revenons √† l'exemple du calcul des op√©rations de change.  Notre objectif, comme pr√©c√©demment, est de compter le nombre de transactions, mais nous ne voudrions pas attendre tout le temps avant de mettre √† jour le compteur.  Au lieu de cela, nous mettrons √† jour le compteur √† des intervalles plus courts.  Par exemple, nous continuerons √† compter le nombre de transactions toutes les 20 secondes, mais √† mettre √† jour le compteur toutes les 5 secondes, comme le montre la Fig.  5.15.  Dans le m√™me temps, nous avons trois fen√™tres de r√©sultats avec des donn√©es qui se chevauchent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/rz/km/f_rzkmhyoxehblurxwysauk3j2k.png" alt="image"></div><br>  Le listing 5.7 montre le code pour sp√©cifier les fen√™tres coulissantes (il peut √™tre trouv√© dans src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/xr/hn/oaxrhnrcxi78qoylbaatcegq__q.png" alt="image"></div><br> ¬´¬ª     ¬´¬ª      advanceBy().       15 . <br><br>     ,      .  ,  ,         : <br><br><ul><li>       ,   ; </li><li> ¬´¬ª          ; </li><li>   ¬´¬ª  ,            . </li></ul><br>   ,   KTable   KStream  . <br><br><h3> 5.3.3.   KStream  KTable </h3><br>   4      KStream.      KTable  KStream.       . KStream ‚Äî  ,  KTable ‚Äî   ,                KTable. <br><br>                .    ,        . <br><br><ol><li>   KTable        KStream      ,   ,    . </li><li>   KTable,       .   KTable     . </li><li>            . </li></ol><br>  ,     . <br><br><h3>  KTable  KStream </h3><br>   KTable  KStream   . <br><br><ol><li>   KTable.toStream(). </li><li>     KStream.map     ,      Windowed  TransactionSummary. </li></ol><br>        (     src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/_b/9f/jx_b9frqyde6wj2yvo5nk3palwq.png" alt="image"></div><br>     KStream.map,       KStream       . <br><br>    ,      KTable    . <br><br><h3>  KTable    </h3><br>  ,    KTable     (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/g5/2w/vbg52wycfxm6ojk2jgpkochuvii.png" alt="image"></div><br>  ,    Serde   ,      Serde.     EARLIEST      . <br><br>        ‚Äî . <br><br><h3>         </h3><br>     .      ,         (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/8r/zw/nk8rzwzgk7qtaxv0uq3p_sjaipm.png" alt="image"></div><br>   leftJoin  .       4,  JoinWindow  ,     KStream-KTable     KTable    .      :     KTable,  .  :    KTable   KStream    . <br><br>           KStream. <br><br><h3> 5.3.4.  GlobalKTable </h3><br>   ,          .   4      KStream,     ‚Äî  KStream  KTable.                 .      ,   Kafka Streams   .   ,          ,     (    4,   ¬´  ¬ª  4.2.4). <br><br><h3>      </h3><br>     ‚Äî       ,       ;            .  ,               ,           . <br><br><h3>       </h3><br>      ,    ,  ,             .     Kafka Streams   GlobalKTable. <br><br>  GlobalKTable ,         .         ,         ,      .    GlobalKTable     .          . <br><br><h3>   KStream   GlobalKTable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la sous-section 5.3.2, nous avons proc√©d√© √† l'agr√©gation des fen√™tres des transactions d'√©change par les clients. </font><font style="vertical-align: inherit;">Les r√©sultats de cette agr√©gation ressemblaient √† ceci:</font></font><br><br><pre><code class="plaintext hljs">{customerId='074-09-3705', stockTicker='GUTM'}, 17 {customerId='037-34-5184', stockTicker='CORK'}, 16</code> </pre> <br>  Bien que ces r√©sultats soient conformes √† l'objectif, il serait plus pratique d'afficher √©galement le nom du client et le nom complet de l'entreprise.  Pour ajouter le nom d'un client et le nom d'une entreprise, vous pouvez effectuer des connexions normales, mais vous devrez effectuer deux mappages de cl√©s et re-partitionner.  Avec GlobalKTable, vous pouvez √©viter le co√ªt de telles op√©rations. <br><br>  Pour ce faire, nous allons utiliser l'objet countStream du Listing 5.11 (le code correspondant peut √™tre trouv√© dans le fichier src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java), en le connectant avec deux objets GlobalKTable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ds/zj/etdszjjzni9snwmxxbi21xph8e4.png" alt="image"></div><br>  Nous en avons d√©j√† discut√© auparavant, donc je ne le r√©p√©terai pas.  Mais je note que le code dans la fonction toStream (). Map est abstrait dans l'objet fonction pour des raisons de lisibilit√© au lieu de l'expression lambda int√©gr√©e. <br><br>  L'√©tape suivante consiste √† d√©clarer deux instances de GlobalKTable (le code affich√© peut √™tre trouv√© dans src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listing 5.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ca/gd/utcagdf_iab9zjefezaiy2dxt80.png" alt="image"></div><br><br>  Notez que les noms de rubrique sont d√©crits √† l'aide de types √©num√©r√©s. <br><br>  Maintenant que nous avons pr√©par√© tous les composants, il reste √† √©crire le code de la connexion (qui se trouve dans le fichier src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listing 5.13). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/yr/oe/avyroeehcpkzq9rzeiqlernoum8.png" alt="image"></div><br>  Bien qu'il existe deux compos√©s dans ce code, ils sont organis√©s en cha√Æne, car aucun de leurs r√©sultats n'est utilis√© s√©par√©ment.  Les r√©sultats sont affich√©s √† la fin de toute l'op√©ration. <br><br>  Lorsque vous d√©marrez l'op√©ration de connexion ci-dessus, vous obtiendrez les r√©sultats suivants: <br><br><pre> <code class="plaintext hljs">{customer='Barney, Smith' company="Exxon", transactions= 17}</code> </pre> <br>  L'essence n'a pas chang√©, mais ces r√©sultats semblent plus clairs. <br><br>  En comptant le chapitre 4, vous avez d√©j√† vu plusieurs types de connexions en action.  Ils sont r√©pertori√©s dans le tableau.  5.2.  Ce tableau refl√®te la connectivit√© pertinente √† la version 1.0.0 de Kafka Streams;  quelque chose va changer dans les prochaines versions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_u/ka/gh/_ukaghteoopcpk9i5ljf4cjrwju.png" alt="image"></div><br>  En conclusion, je vous rappelle l'essentiel: vous pouvez connecter des flux d'√©v√©nements (KStream) et des flux de mise √† jour (KTable) en utilisant l'√©tat local.  De plus, si la taille des donn√©es de r√©f√©rence n'est pas trop grande, vous pouvez utiliser l'objet GlobalKTable.  GlobalKTable r√©plique toutes les sections sur chacun des n≈ìuds de l'application Kafka Streams, garantissant ainsi la disponibilit√© de toutes les donn√©es quelle que soit la section √† laquelle la cl√© correspond. <br><br>  Ensuite, nous verrons la possibilit√© de flux Kafka, gr√¢ce auxquels vous pouvez observer les changements d'√©tat sans consommer les donn√©es du sujet Kafka. <br><br><h3>  5.3.5.  Statut de la demande </h3><br>  Nous avons d√©j√† effectu√© plusieurs op√©rations impliquant l'√©tat et toujours restituer les r√©sultats √† la console (√† des fins de d√©veloppement) ou les √©crire dans le sujet (pour une op√©ration industrielle).  Lorsque vous √©crivez des r√©sultats dans un sujet, vous devez utiliser le consommateur Kafka pour les afficher. <br><br>  La lecture des donn√©es de ces sujets peut √™tre consid√©r√©e comme une sorte de vues mat√©rialis√©es.  Pour nos t√¢ches, nous pouvons utiliser la d√©finition d'une vue mat√©rialis√©e de Wikipedia: ¬´... un objet de base de donn√©es physique contenant les r√©sultats d'une requ√™te.  Par exemple, il peut s'agir d'une copie locale des donn√©es supprim√©es, ou d'un sous-ensemble des lignes et / ou colonnes d'une table ou des r√©sultats de jointure, ou d'un tableau crois√© dynamique obtenu √† l'aide de l'agr√©gation ¬ª(https://en.wikipedia.org/wiki/Materialized_view). <br><br>  Kafka Streams vous permet √©galement d'effectuer des requ√™tes interactives sur les magasins d'√©tat, ce qui vous permet de lire directement ces vues mat√©rialis√©es.  Il est important de noter que la demande au magasin d'√©tat est de la nature d'une op√©ration en lecture seule.  Gr√¢ce √† cela, vous ne pouvez pas avoir peur de rendre accidentellement l'√©tat d'une application incoh√©rente lors du traitement des donn√©es. <br><br>  La possibilit√© d'interroger directement les magasins d'√©tat est importante.  Cela signifie que vous pouvez cr√©er des applications - des tableaux de bord sans avoir √† recevoir au pr√©alable les donn√©es d'un consommateur Kafka.  Il augmente l'efficacit√© de l'application, car il n'est pas n√©cessaire d'enregistrer √† nouveau les donn√©es: <br><br><ul><li>  En raison de la localisation des donn√©es, vous pouvez y acc√©der rapidement; </li><li>  La duplication des donn√©es est exclue, car elles ne sont pas √©crites sur un stockage externe. </li></ul><br>  La chose principale dont je voudrais que vous vous souveniez: vous pouvez ex√©cuter directement les requ√™tes d'√©tat depuis l'application.  Vous ne pouvez pas surestimer les opportunit√©s que cela vous offre.  Au lieu de consommer des donn√©es de Kafka et de stocker des enregistrements dans la base de donn√©es pour l'application, vous pouvez interroger les magasins d'√©tat avec le m√™me r√©sultat.  Les demandes directes aux magasins d'√©tat signifient moins de code (pas de consommateur) et moins de logiciel (pas besoin d'une table de base de donn√©es pour stocker les r√©sultats). <br><br>  Nous avons couvert une quantit√© consid√©rable d'informations dans ce chapitre, nous allons donc arr√™ter temporairement notre discussion sur les requ√™tes interactives aux magasins d'√âtat.  Mais ne vous inqui√©tez pas: au chapitre 9, nous allons cr√©er une application simple - un panneau d'informations avec des requ√™tes interactives.  Pour d√©montrer les requ√™tes interactives et les possibilit√©s de les ajouter aux applications Kafka Streams, il utilisera certains des exemples de ce chapitre et des pr√©c√©dents. <br><br><h3>  R√©sum√© </h3><br><ul><li>  Les objets KStream repr√©sentent des flux d'√©v√©nements comparables aux insertions de base de donn√©es.  Les objets KTable repr√©sentent des flux de mise √† jour, ils sont plus similaires aux mises √† jour de la base de donn√©es.  La taille de l'objet KTable n'augmente pas; les anciens enregistrements sont remplac√©s par de nouveaux. </li><li>  Les objets KTable sont requis pour les op√©rations d'agr√©gation. </li><li>  √Ä l'aide des op√©rations de fen√™tre, vous pouvez diviser les donn√©es agr√©g√©es en paniers de temps. </li><li>  Gr√¢ce aux objets GlobalKTable, vous pouvez acc√©der aux donn√©es de r√©f√©rence n'importe o√π dans l'application, ind√©pendamment de la section. </li><li>  Les connexions entre les objets KStream, KTable et GlobalKTable sont possibles. </li></ul><br>  Jusqu'√† pr√©sent, nous nous sommes concentr√©s sur la cr√©ation d'applications Kafka Streams √† l'aide du DSL de haut niveau KStream.  Bien qu'une approche de haut niveau vous permette de cr√©er des programmes soign√©s et concis, son utilisation est un compromis certain.  Travailler avec DSL KStream signifie augmenter la concision du code en r√©duisant le degr√© de contr√¥le.  Dans le chapitre suivant, nous allons examiner l'API de bas niveau des n≈ìuds de gestionnaire et essayer d'autres compromis.  Les programmes deviendront plus longs qu'ils ne l'√©taient jusqu'√† pr√©sent, mais nous aurons la possibilit√© de cr√©er presque tous les n≈ìuds de traitement dont nous pourrions avoir besoin. <br><br>  ‚Üí Plus de d√©tails sur le livre peuvent √™tre trouv√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br><br>  ‚Üí Pour Khabrozhiteley 25% de r√©duction sur le coupon - <b>Kafka Streams</b> <br><br>  ‚Üí Lors du paiement de la version papier du livre, un livre √©lectronique est envoy√© par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457756/">https://habr.com/ru/post/fr457756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457744/index.html">Cr√©ation d'un syst√®me d'extension sur la biblioth√®que Qt - Partie 2</a></li>
<li><a href="../fr457746/index.html">M√©t√©orologie et vols</a></li>
<li><a href="../fr457750/index.html">Travailler avec JSON RPC dans Symfony 4</a></li>
<li><a href="../fr457752/index.html">Pas des rovers lunaires et pas des farceurs. Que savons-nous des robots √† Fukushima</a></li>
<li><a href="../fr457754/index.html">State et T-killers</a></li>
<li><a href="../fr457758/index.html">Les ing√©nieurs sauvent les gens perdus dans la for√™t, mais la for√™t ne s'est pas encore rendue</a></li>
<li><a href="../fr457760/index.html">Comment rendre les conteneurs encore plus isol√©s: un examen des technologies de bac √† sable pour conteneurs</a></li>
<li><a href="../fr457762/index.html">R√®gle CCD: avec quoi il est mang√©</a></li>
<li><a href="../fr457764/index.html">10 erreurs de PO jeune (partie II)</a></li>
<li><a href="../fr457766/index.html">Nous g√©n√©rons des niveaux de tuiles et cachons des carr√©s au joueur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>