<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🎤 🙋🏻 👡 Serialisasi di Jawa. Tidak sesederhana itu 💿 👇🏽 📌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serialisasi adalah proses yang menerjemahkan suatu objek ke dalam urutan byte, yang kemudian dapat dipulihkan sepenuhnya. Mengapa ini dibutuhkan?  Fak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serialisasi di Jawa. Tidak sesederhana itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431524/"><img src="https://habrastorage.org/webt/az/3t/pd/az3tpdhy1ajhximnq7nsjbxvsdy.png"><br><br>  <strong>Serialisasi</strong> adalah proses yang menerjemahkan suatu objek ke dalam urutan byte, yang kemudian dapat dipulihkan sepenuhnya.  Mengapa ini dibutuhkan? <a name="habracut"></a>  Faktanya adalah, selama eksekusi program normal, umur maksimum objek apa pun diketahui - dari peluncuran program hingga akhirnya.  Serialisasi memungkinkan Anda untuk memperluas kerangka kerja ini dan "memberi kehidupan" pada objek dengan cara yang sama antara peluncuran program. <br><br>  Bonus tambahan untuk semuanya adalah pelestarian lintas platform.  Apa pun sistem operasi yang Anda miliki, serialisasi menerjemahkan objek menjadi aliran byte, yang dapat dipulihkan pada OS apa pun.  Jika Anda perlu mentransfer objek melalui jaringan, Anda bisa membuat serial objek, menyimpannya ke file dan mentransfernya melalui jaringan ke penerima.  Dia akan dapat memulihkan objek yang diterima.  Serialisasi juga memungkinkan Anda untuk secara jarak jauh memanggil metode (Java RMI) yang ada di mesin yang berbeda dengan, mungkin, sistem operasi yang berbeda, dan bekerja dengan mereka seolah-olah mereka berada di mesin proses panggilan java. <br><br>  Menerapkan mekanisme serialisasi cukup sederhana.  Kelas Anda perlu mengimplementasikan antarmuka <strong><em>Serializable</em></strong> .  Antarmuka ini adalah pengidentifikasi yang tidak memiliki metode, tetapi memberitahu jvm bahwa objek dari kelas ini dapat diserialisasi.  Karena mekanisme serialisasi terhubung ke sistem input / output dasar dan menerjemahkan objek ke dalam aliran byte, untuk menjalankannya Anda perlu membuat aliran output <em>OutputStream</em> , kemas dalam <em>ObjectOutputStream</em> dan panggil metode <em>writeObject ().</em>  Untuk mengembalikan objek, Anda perlu mengemas <em>InputStream</em> ke dalam <em>ObjectInputStream</em> dan memanggil metode <em>readObject ().</em> <br><br>  Selama proses serialisasi, bersama dengan objek serializable, grafik objeknya disimpan.  Yaitu  semua objek yang terkait dengan ini, objek dari kelas lain juga akan bersambung dengan itu. <br><br>  Pertimbangkan contoh membuat cerita bersambung dari objek Person kelas. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Home</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String home; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Home</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String home)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.home = home; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> home; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countOfNiva; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String fatherName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Home home; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countOfNiva, String fatherName, Home home)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.countOfNiva = countOfNiva; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fatherName = fatherName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.home = home; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Person{"</span></span> + <span class="hljs-string"><span class="hljs-string">"name='"</span></span> + name + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", countOfNiva="</span></span> + countOfNiva + <span class="hljs-string"><span class="hljs-string">", fatherName='"</span></span> + fatherName + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", home="</span></span> + home + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Home home = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Home(<span class="hljs-string"><span class="hljs-string">"Vishnevaia 1"</span></span>); Person igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Igor"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Raphael"</span></span>, home); Person renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Raphael"</span></span>, home); <span class="hljs-comment"><span class="hljs-comment">//      ObjectOutputStream ObjectOutputStream objectOutputStream = new ObjectOutputStream( new FileOutputStream("person.out")); objectOutputStream.writeObject(igor); objectOutputStream.writeObject(renat); objectOutputStream.close(); //       ObjectInputStream ObjectInputStream objectInputStream = new ObjectInputStream( new FileInputStream("person.out")); Person igorRestored = (Person) objectInputStream.readObject(); Person renatRestored = (Person) objectInputStream.readObject(); objectInputStream.close(); //    ByteArrayOutputStream ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream2 = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream2.writeObject(igor); objectOutputStream2.writeObject(renat); objectOutputStream2.flush(); //    ByteArrayInputStream ObjectInputStream objectInputStream2 = new ObjectInputStream( new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); Person igorRestoredFromByte = (Person) objectInputStream2.readObject(); Person renatRestoredFromByte = (Person) objectInputStream2.readObject(); objectInputStream2.close(); System.out.println("Before Serialize: " + "\n" + igor + "\n" + renat); System.out.println("After Restored From Byte: " + "\n" + igorRestoredFromByte + "\n" + renatRestoredFromByte); System.out.println("After Restored: " + "\n" + igorRestored + "\n" + renatRestored); } }</span></span></code> </pre> <br>  <strong>Kesimpulan:</strong> <br><br><pre> <code class="java hljs">Before Serialize: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">355</span></span>da254} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">355</span></span>da254} After Restored From Byte: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} After Restored: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae}</code> </pre> <br>  Dalam contoh ini, kelas <em>Home</em> dibuat untuk menunjukkan bahwa ketika membuat serial objek objek, grafik objeknya di-serialisasi dengannya.  Kelas <em>Home</em> juga harus mengimplementasikan antarmuka <em>Serializable</em> , jika tidak <em>java.io.NotSerializableException</em> akan terjadi.  Contoh ini juga menjelaskan serialisasi menggunakan kelas <em>ByteArrayOutputStream</em> . <br><br>  Kesimpulan yang menarik dapat diambil dari hasil eksekusi program: <em>ketika mengembalikan objek yang memiliki referensi ke objek yang sama sebelum serialisasi, objek ini akan dikembalikan hanya sekali</em> .  Ini dapat dilihat pada tautan yang sama pada objek setelah pemulihan: <br><br><pre> <code class="java hljs">After Restored From Byte: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} After Restored: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae}</code> </pre> <br>  Namun, juga terlihat bahwa ketika merekam dengan dua aliran keluaran (kami memiliki <em>ObjectInputStream</em> dan <em>ByteArrayOutputStream</em> ), objek <em>rumah</em> akan dibuat ulang, meskipun faktanya itu sudah dibuat sebelumnya di salah satu aliran.  Kami melihat ini di berbagai alamat objek <em>rumah yang</em> diterima dalam dua aliran.  Ternyata jika Anda membuat serial dengan satu aliran output, lalu mengembalikan objek, maka kami memiliki jaminan memulihkan jaringan objek secara lengkap tanpa duplikat yang tidak perlu.  Tentu saja, selama eksekusi program keadaan objek dapat berubah, tetapi ini adalah hati nurani programmer. <br><br>  <strong>Masalah</strong> <br><br>  Contoh ini juga menunjukkan bahwa ketika memulihkan objek, <em>ClassNotFoundException</em> dapat terjadi.  Apa alasannya?  Faktanya adalah bahwa kita dapat dengan mudah membuat serial objek dari kelas <em>Person</em> ke file, mentransfernya melalui jaringan ke teman kita, yang dapat mengembalikan objek dengan aplikasi lain di mana kelas <em>Person</em> tidak ada. <br><br>  <strong>Serialisasi.</strong>  <strong>Bagaimana membuat?</strong> <br><br>  Bagaimana jika Anda ingin mengelola serialisasi sendiri?  Misalnya, objek Anda menyimpan nama pengguna dan kata sandi pengguna.  Anda perlu membuat cerita bersambung untuk transmisi lebih lanjut melalui jaringan.  Melewati kata sandi dalam hal ini sangat tidak bisa diandalkan.  Bagaimana cara mengatasi masalah ini?  Ada dua cara.  Pertama, gunakan kata kunci <strong><em>sementara</em></strong> .  Kedua, alih-alih mewujudkan minat <em>Serializable</em> , gunakan ekstensi - antarmuka yang dapat <em><strong>dieksternalisasi</strong></em> .  Pertimbangkan contoh metode pertama dan kedua untuk membandingkannya. <br><br>  <strong>Cara pertama - Serialisasi menggunakan transient</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logon</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String login; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transient</span></span> String password; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String login, String password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.login = login; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.password = password; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Logon{"</span></span> + <span class="hljs-string"><span class="hljs-string">"login='"</span></span> + login + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", password='"</span></span> + password + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Logon igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"IgorIvanovich"</span></span>, <span class="hljs-string"><span class="hljs-string">"Khoziain"</span></span>); Logon renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-string"><span class="hljs-string">"2500RUB"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + igor); System.out.println(renat); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); out.writeObject(igor); out.writeObject(renat); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); igor = (Logon) in.readObject(); renat = (Logon) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + igor); System.out.println(renat); } }</code> </pre> <br>  <strong>Kesimpulan:</strong> <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} After: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>}</code> </pre> <br>  <strong>Cara kedua - Serialisasi dengan implementasi antarmuka Externalizable</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logon</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Externalizable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String login; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String password; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String login, String password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.login = login; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.password = password; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeExternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectOutput out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ out.writeObject(login); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Logon{"</span></span> + <span class="hljs-string"><span class="hljs-string">"login='"</span></span> + login + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", password='"</span></span> + password + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readExternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectInput in)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ login = (String) in.readObject(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Logon igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"IgorIvanovich"</span></span>, <span class="hljs-string"><span class="hljs-string">"Khoziain"</span></span>); Logon renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-string"><span class="hljs-string">"2500RUB"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + igor); System.out.println(renat); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); out.writeObject(igor); out.writeObject(renat); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); igor = (Logon) in.readObject(); renat = (Logon) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + igor); System.out.println(renat); } }</code> </pre> <br>  <strong>Kesimpulan:</strong> <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} After: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>}</code> </pre> <br>  Perbedaan pertama antara dua opsi yang menarik perhatian Anda adalah ukuran kode.  Saat mengimplementasikan antarmuka <em>Externalizable</em> , kita perlu mengganti dua metode: <em><strong>writeExternal ()</strong></em> dan <strong><em>readExternal ()</em></strong> .  Dalam metode <em>writeExternal ()</em> , kami menunjukkan bidang mana yang akan diserialisasi dan bagaimana, di <em>readExternal ()</em> cara membacanya.  Saat menggunakan kata <em>transient,</em> kami secara eksplisit menunjukkan bidang atau bidang mana yang tidak perlu diserialisasi.  Kami juga mencatat bahwa dalam metode kedua, kami secara eksplisit membuat konstruktor default, apalagi yang publik.  Mengapa ini dilakukan?  Mari kita coba jalankan kode tanpa konstruktor ini.  Dan lihat hasilnya: <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} Exception in thread <span class="hljs-string"><span class="hljs-string">"main"</span></span> java.io.InvalidClassException: Logon; no valid constructor at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:<span class="hljs-number"><span class="hljs-number">169</span></span>) at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:<span class="hljs-number"><span class="hljs-number">874</span></span>) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">2043</span></span>) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">1573</span></span>) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">431</span></span>) at Logon.main(Logon.java:<span class="hljs-number"><span class="hljs-number">45</span></span>)</code> </pre> <br>  Kami mendapat pengecualian <em>java.io.InvalidClassException</em> .  Apa alasannya?  Jika Anda mengikuti jejak stack, Anda bisa menemukan bahwa ada garis-garis di konstruktor dari kelas <em>ObjectStreamClass</em> : <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (externalizable) { cons = getExternalizableConstructor(cl); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cons = getSerializableConstructor(cl);</code> </pre> <br>  Untuk antarmuka <em>Externalizable</em> , metode konstruktor <em>getExternalizableConstructor ()</em> akan dipanggil <em>,</em> di dalamnya melalui <em>Reflection</em> kita akan mencoba untuk mendapatkan konstruktor default dari kelas yang kita pulihkan objeknya.  Jika kami tidak dapat menemukannya, atau tidak tersedia untuk <em>umum</em> , maka kami mendapatkan pengecualian.  Anda dapat mengatasi situasi ini sebagai berikut: jangan membuat konstruktor secara eksplisit di kelas dan mengisi bidang menggunakan setter dan dapatkan nilai dengan getter.  Kemudian, ketika mengkompilasi kelas, konstruktor default akan dibuat, yang akan tersedia untuk <em>getExternalizableConstructor ()</em> .  Untuk <em>Serializable,</em> metode <em>getSerializableConstructor ()</em> mendapatkan konstruktor dari kelas <em>Object</em> dan mencari kelas yang diinginkan darinya, jika tidak menemukannya, kita akan mendapatkan <em>ClassNotFoundException</em> .  Ternyata perbedaan utama antara <em>Serializable</em> dan <em>Externalizable</em> adalah bahwa yang pertama tidak memerlukan konstruktor untuk membuat pemulihan objek.  Ini hanya akan pulih sepenuhnya dari byte.  Untuk yang kedua, selama restorasi, sebuah objek pertama akan dibuat menggunakan konstruktor pada titik deklarasi, dan kemudian nilai bidangnya dari byte yang diterima selama serialisasi akan ditulis ke dalamnya.  Secara pribadi, saya lebih suka metode pertama, itu jauh lebih sederhana.  Selain itu, bahkan jika kita masih perlu mengatur perilaku serialisasi, kita tidak dapat menggunakan <em>Externalizable</em> , serta mengimplementasikan <em>Serializable</em> dengan menambahkan (tanpa mengesampingkan) metode <em>writeObject ()</em> dan <em>readObject ()</em> ke dalamnya.  Tetapi agar mereka “bekerja”, tanda tangan mereka harus diperhatikan dengan ketat. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Talda</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Talda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String description)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.description = description; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectOutputStream stream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ stream.defaultWriteObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Our writeObject"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectInputStream stream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ stream.defaultReadObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Our readObject"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Talda{"</span></span> + <span class="hljs-string"><span class="hljs-string">"name='"</span></span> + name + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", description='"</span></span> + description + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Talda partizanka = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Talda(<span class="hljs-string"><span class="hljs-string">"Partizanka"</span></span>, <span class="hljs-string"><span class="hljs-string">"Viiiski"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + partizanka); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Talda.out"</span></span>)); out.writeObject(partizanka); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Talda.out"</span></span>)); partizanka = (Talda) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + partizanka); } }</code> </pre> <br>  <strong>Kesimpulan:</strong> <br><br><pre> <code class="java hljs">Before: Talda{name=<span class="hljs-string"><span class="hljs-string">'Partizanka'</span></span>, description=<span class="hljs-string"><span class="hljs-string">'Viiiski'</span></span>} Our writeObject Our readObject After: Talda{name=<span class="hljs-string"><span class="hljs-string">'Partizanka'</span></span>, description=<span class="hljs-string"><span class="hljs-string">'Viiiski'</span></span>}</code> </pre> <br>  Di dalam metode kami yang ditambahkan, <em>defaultWriteObject ()</em> dan <em>defaultReadObject ()</em> dipanggil.  Mereka bertanggung jawab atas serialisasi default, seolah-olah itu berfungsi tanpa metode yang kami tambahkan. <br><br>  Sebenarnya, ini hanya puncak gunung es, jika Anda terus mempelajari mekanisme serialisasi, maka dengan tingkat probabilitas yang tinggi, Anda dapat menemukan lebih banyak nuansa, menemukan yang kami katakan: "Serialisasi ... tidak begitu sederhana." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431524/">https://habr.com/ru/post/id431524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431512/index.html">Sebuah studi kecil tentang sifat-sifat U-net sederhana, jaringan konvolusional klasik untuk segmentasi</a></li>
<li><a href="../id431514/index.html">Wawancara untuk pewawancara</a></li>
<li><a href="../id431516/index.html">Suatu hari dalam kehidupan seorang Penasihat Keuangan</a></li>
<li><a href="../id431518/index.html">Microsoft Connect (); Pertemuan di Moskow</a></li>
<li><a href="../id431520/index.html">Memprediksi churn pengguna menggunakan metode RFM</a></li>
<li><a href="../id431526/index.html">Pengaruh korup: bagaimana Stasi membela Jerman Timur dari video game</a></li>
<li><a href="../id431528/index.html">Jenius matematika misterius dan penulis mempromosikan solusi masalah permutasi</a></li>
<li><a href="../id431530/index.html">Buka pelajaran "Desain Material Android: pembaruan ikhtisar"</a></li>
<li><a href="../id431532/index.html">Memristor terdiri dari bagian tebal 2 nm</a></li>
<li><a href="../id431534/index.html">Identitas Masalah Di Antara Pengembang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>