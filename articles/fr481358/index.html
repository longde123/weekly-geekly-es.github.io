<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏼 🧜🏾 ‼️ C ++ Russie: comment c'était 🕺🏻 🖖🏻 👩‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si au début de la pièce vous dites que le code C ++ est accroché au mur, alors à la fin il devrait certainement vous tirer dans le pied. 

 Bjarne Str...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Russie: comment c'était</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>Si au début de la pièce vous dites que le code C ++ est accroché au mur, alors à la fin il devrait certainement vous tirer dans le pied.</i> <i><br><br></i>  <i>Bjarne Stroustrup</i> <i><br></i> <br>  Du 31 octobre au 1er novembre, Saint-Pétersbourg a accueilli la conférence C ++ Russia Piter, l'une des plus grandes conférences de programmation en Russie organisée par le groupe JUG Ru.  Parmi les conférenciers invités figurent des membres du comité de normalisation C ++, des conférenciers de CppCon, des auteurs de livres de O'Reilly, ainsi que des responsables de projets tels que LLVM, libc ++ et Boost.  La conférence s'adresse aux développeurs C ++ expérimentés qui souhaitent approfondir leur expertise et échanger leurs expériences en communication en direct.  Les étudiants, étudiants diplômés et professeurs d'université bénéficient de remises très agréables. <br><br>  L'édition de Moscou de la conférence peut être visitée dès avril de l'année prochaine, mais pour l'instant nos étudiants vous diront quelles choses intéressantes ils ont apprises lors du dernier événement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i>Photo de <a href="https://vk.com/album-77278886_270140987">l'album</a> de <a href="https://vk.com/album-77278886_270140987">la conférence</a></i> <br><br><h2>  À propos de nous </h2><br>  Deux étudiants de l'École supérieure d'économie de Saint-Pétersbourg ont travaillé sur ce poste: <br><br><ul><li>  Lisa Vasilenko est une étudiante de premier cycle de 4e année qui étudie la direction des «langages de programmation» dans le cadre du programme «Mathématiques appliquées et informatique».  Connaissant le langage C ++ en première année d'université, il a par la suite acquis une expérience de travail avec lui lors de stages dans l'industrie.  La passion des langages de programmation en général et de la programmation fonctionnelle en particulier a marqué le choix des rapports lors de la conférence. <br></li><li>  Danya Smirnov est une étudiante de première année du programme de maîtrise «Programmation et analyse des données».  Alors qu'il était encore à l'école, il a écrit les problèmes de l'Olympiade en C ++, puis il est arrivé que le langage apparaissait constamment dans les activités éducatives et devenait par conséquent le principal outil de travail.  J'ai décidé de participer à la conférence afin d'enrichir mes connaissances et de découvrir de nouvelles opportunités. <br></li></ul><br>  Dans le bulletin d'information, les professeurs partagent souvent des informations sur les événements éducatifs liés à notre spécialité.  En septembre, nous avons vu des informations sur C ++ Russia et avons décidé de nous inscrire comme auditeurs.  Il s'agit de notre première expérience de participation à de telles conférences. <br><br><h2>  Structure de la conférence </h2><br><ul><li><h3>  Rapports </h3></li></ul><br>  Au cours de deux jours, les experts ont lu 30 rapports mettant en évidence de nombreux sujets d'actualité: applications pleines d'esprit des fonctionnalités du langage pour résoudre les problèmes appliqués, mises à jour linguistiques à venir en raison de la nouvelle norme, compromis dans la conception C ++ et précautions lors de l'utilisation de leurs conséquences, exemples d'architecture de projet intéressante, ainsi que certaines parties du moteur de l'infrastructure linguistique.  Dans le même temps, 3 représentations ont eu lieu, le plus souvent deux en russe et une en anglais. <br><br><ul><li><h3>  Zones de discussion </h3></li></ul><br>  Après le discours, toutes les questions sans réponse et les discussions incomplètes ont été transférées dans des zones de communication spécialement désignées avec des conférenciers équipés de panneaux de signalisation.  Un bon moyen de passer la pause entre les performances pour une conversation agréable. <br><br><ul><li><h3>  Lightning Talks et discussions informelles </h3></li></ul><br>  Si vous souhaitez rédiger un court rapport, vous pouvez vous inscrire à une soirée Lightning Talk sur un tableau indicateur et disposer de cinq minutes pour parler de tout ce qui concerne le sujet de la conférence.  Par exemple, une introduction rapide aux désinfectants pour C ++ (qui s'est avéré être nouveau pour certains) ou une histoire sur un bug dans la génération d'une sinusoïde que vous pouvez seulement entendre mais pas voir. <br><br>  Un autre format est la table ronde «Avec le comité de l'âme».  Sur la scène, il y a des membres du comité de normalisation, sur le projecteur - une cheminée (officiellement - pour créer une atmosphère émouvante, mais la raison «parce que tout est en feu» semble plus drôle), des questions - sur la vision standard et générale du C ++, sans discussions techniques passionnées et holivars.  Il s'est avéré que des personnes vivantes siègent également au comité, qui ne sont peut-être pas complètement sûres de quelque chose ou peuvent ne pas savoir quelque chose. <br><br>  Pour les passionnés d'Holivar, le troisième événement est resté: la session BOF «Go Again C ++».  Nous prenons un amoureux de Go, un amoureux de C ++, avant le début de la session, ils préparent ensemble 100500 diapositives sur le sujet (comme des problèmes avec les packages en C ++ ou le manque de génériques en Go), puis ils discutent avec eux-mêmes et le public, et le public essaie de comprendre deux points de vue à la fois .  Si l'holivar ne démarre pas, le modérateur intervient et réconcilie les parties.  Ce format crée une dépendance: quelques heures après le début, seulement la moitié des diapositives ont été achevées.  La fin a dû être fortement accélérée. <br><br><ul><li><h3>  Stands partenaires </h3></li></ul><br>  Les partenaires de la conférence étaient représentés dans les halls - ils ont parlé des projets en cours sur les stands, proposé des stages et des emplois, organisé des quiz et de petits concours, et ont également joué de beaux prix.  Cependant, certaines entreprises ont même proposé de passer par les premières étapes des entretiens, ce qui peut être utile pour ceux qui ne sont pas seulement venus écouter les reportages. <br><br><h2>  Détails techniques des rapports </h2><br>  Nous avons écouté les rapports les deux jours.  Parfois, il était difficile de choisir un rapport parmi ceux qui fonctionnaient en parallèle - nous avons convenu de partager et d'échanger les connaissances acquises pendant les pauses.  Et même ainsi, il semble que beaucoup a été perdu.  Ici, nous aimerions parler du contenu de certains rapports qui nous ont semblé les plus intéressants <br><br><h3>  Exceptions en C ++ à travers le prisme des optimisations du compilateur, Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Diapositive de présentation</a></i> <br><br>  Comme son nom l'indique, Roman a envisagé de travailler avec des exceptions en utilisant le LLVM comme exemple.  Dans le même temps, pour ceux qui n'utilisent pas Clang dans leur travail, le rapport peut toujours donner une idée de la façon dont le code peut potentiellement être optimisé.  En effet, les développeurs de compilateurs et des bibliothèques standard correspondantes communiquent entre eux et de nombreuses solutions réussies peuvent coïncider. <br><br>  Ainsi, pour gérer l'exception, vous devez effectuer de nombreuses actions: appeler le code de traitement (le cas échéant) ou libérer des ressources au niveau actuel et dérouler la pile plus haut.  Tout cela conduit au fait que le compilateur ajoute des instructions supplémentaires pour potentiellement lancer des appels.  Par conséquent, si une exception n'est en fait pas provoquée, le programme commencera toujours à effectuer des actions inutiles.  Afin de réduire en quelque sorte les frais généraux, LLVM a plusieurs heuristiques pour déterminer les situations où vous n'avez pas besoin d'ajouter un code de gestion des exceptions ou vous pouvez réduire le nombre d'instructions "inutiles". <br><br>  L'orateur en examine une dizaine et montre à la fois les situations où elles permettent d'accélérer l'exécution du programme, et celles où ces méthodes ne sont pas applicables. <br><br>  Ainsi, Roman Rusyaev conduit l'auditoire à la conclusion que le code contenant du travail avec des exceptions ne peut en aucun cas toujours être exécuté avec une surcharge zéro, et donne les conseils suivants: <br><br><ul><li>  lors du développement de bibliothèques, vous devez abandonner les exceptions en principe; </li><li>  si vous avez encore besoin d'exceptions, dans la mesure du possible, cela vaut la peine d'ajouter des modificateurs noexcept (et const) afin que le compilateur optimise autant que possible. </li></ul><br>  De manière générale, l'orateur a réitéré le point de vue selon lequel il vaut mieux utiliser les exceptions au minimum, voire les abandonner. <br><br>  Les diapositives du rapport sont disponibles sur: <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">[«Exceptions C ++ via le prisme de l'optimisation du compilateur LLVM»]</a> <br><br><h3>  Générateurs, coroutines et autres douceurs cérébrales, Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Diapositive de présentation</a></i> <br><br>  L'un des nombreux rapports de cette conférence consacrée aux innovations du C ++ 20 a été retenu non seulement par sa présentation colorée, mais aussi par sa désignation claire des problèmes avec la logique de traitement de la collection (pour, boucle de rappel). <br><br>  Adi Shavit souligne les points suivants: les méthodes actuellement disponibles parcourent toute la collection et ne donnent pas accès à un état intermédiaire interne (ou donnent dans le cas des rappels, mais avec beaucoup d'effets secondaires désagréables, comme le même Callback Hell).  Il semblerait qu'il y ait des itérateurs, mais tout ne va pas si bien avec eux: il n'y a pas de points d'entrée et de sortie communs (début → fin versus rbegin → rend et ainsi de suite), on ne sait pas combien allons-nous répéter?  À partir de C ++ 20, ces problèmes sont résolus! <br><br>  La première option: les plages.  En raison du wrapper au-dessus des itérateurs, nous obtenons une interface commune pour le début et la fin de l'itération, ainsi que la possibilité de composition.  Tout cela facilite la construction de pipelines de traitement de données à part entière.  Mais tout n'est pas si fluide: une partie de la logique des calculs se trouve à l'intérieur de l'implémentation d'un itérateur spécifique, ce qui peut compliquer le code de perception et de débogage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Diapositive de présentation</a></i> <br><br>  Eh bien, dans ce cas, des coroutines ont été ajoutées en C ++ 20 (fonctions dont le comportement est similaire aux générateurs en Python): l'exécution peut être retardée en renvoyant une valeur courante tout en conservant un état intermédiaire.  Ainsi, nous réalisons non seulement le travail avec les données telles qu'elles apparaissent, mais nous encapsulons également toute la logique à l'intérieur d'une coroutine particulière. <br><br>  Mais il y a une mouche dans la pommade: pour le moment, ils ne sont que partiellement pris en charge par les compilateurs existants, et ils ne sont pas non plus implémentés aussi précisément que nous le souhaiterions: par exemple, les liens et les objets temporaires ne devraient pas être utilisés dans les coroutines.  De plus, il existe certaines restrictions sur ce qui peut être des coroutines, et les fonctions constexpr, les constructeurs / destructeurs et les principaux ne sont pas inclus dans cette liste. <br><br>  Ainsi, les coroutines résolvent une partie importante des problèmes de simplicité de la logique de traitement des données, mais leurs implémentations actuelles nécessitent un raffinement. <br><br>  Matériaux: <br><br><ul><li>  Slides with C ++ Russia - <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">["Générateurs, coroutines et autres douceurs cérébrales"]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">Reportage vidéo de CppCon 2019</a> </li></ul><br><h3>  Astuces C ++ de Yandex.Taxi, Anton Polukhin </h3><br>  Dans son activité professionnelle, il faut parfois implémenter des choses purement auxiliaires: un wrapper entre l'interface interne et l'API d'une bibliothèque, la journalisation ou l'analyse.  Cependant, il n'y a généralement pas besoin d'optimisation supplémentaire.  Mais que faire si ces composants sont utilisés dans certains des services les plus populaires de Runet?  Dans une telle situation, vous devrez traiter des téraoctets par heure de journaux seuls!  Ensuite, chaque milliseconde compte et vous devez donc recourir à diverses astuces - Anton Polukhin en a parlé. <br><br>  L'exemple le plus intéressant est peut-être l'implémentation du modèle pointeur vers implémentation (pimpl). <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br>  Dans cet exemple, vous voulez d'abord vous débarrasser des fichiers d'en-tête des bibliothèques externes - il se compilera plus rapidement et vous pourrez vous protéger contre d'éventuels conflits de noms et d'autres erreurs similaires. <br><br>  Ok, déplacé #include dans le fichier .cpp: vous avez besoin de la déclaration directe de l'API encapsulée, ainsi que de std :: unique_ptr.  Nous avons maintenant des allocations dynamiques et d'autres choses désagréables, comme des données dispersées sur un tas et des garanties réduites.  Avec tout cela, std :: aligné_storage peut vous aider. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br>  Le seul problème: nous devons définir la taille et l'alignement de chaque wrapper - nous allons créer notre modèle de bouton avec les paramètres &lt;T, SizeT, AlignmentT&gt;, utiliser des valeurs arbitraires et ajouter au destructeur une vérification que nous avons tout deviné: <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br>  Puisque T a déjà été déterminé lors du traitement du destructeur, ce code sera démonté correctement et au stade de la compilation sous forme d'erreurs, il affichera la taille nécessaire et les valeurs d'alignement qui doivent être saisies.  Ainsi, au prix d'un début de compilation supplémentaire, nous nous débarrassons de l'allocation dynamique des classes encapsulées, masquons l'API dans un fichier .cpp avec l'implémentation, et obtenons également une conception plus adaptée à la mise en cache par le processeur. <br><br>  La journalisation et l'analyse semblaient moins impressionnantes et ne seront donc pas mentionnées dans cette revue. <br><br>  Les diapositives du rapport sont disponibles sur le lien: <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">[«Trucs de taxi C ++»]</a> <br><br><h3>  Techniques modernes pour garder votre code SEC, Björn Fahller </h3><br>  Dans cet exposé, Björn Fahller montre plusieurs façons différentes de traiter les défauts stylistiques tels que les vérifications conditionnelles répétées: <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br>  Est-ce familier?  En utilisant plusieurs techniques C ++ puissantes qui sont apparues dans les normes récentes, vous pouvez implémenter gracieusement la même fonctionnalité sans la moindre perte de performances.  Comparez: <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br>  Pour traiter un nombre illimité de vérifications, vous êtes immédiatement invité à utiliser des modèles variadiques et des expressions de repli.  Supposons que nous voulons vérifier l'égalité de plusieurs variables avec l'élément enum'a state_type.  La première chose qui me vient à l'esprit est d'écrire la fonction d'assistance is_any_of: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br>  Un tel résultat intermédiaire est décevant.  Jusqu'à présent, le code ne devient pas lisible: <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br>  Les paramètres de modèle non-type aideront à améliorer un peu la situation.  Avec leur aide, nous transférons les éléments énumérés enum vers la liste des paramètres du modèle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br>  En utilisant auto dans un paramètre de modèle non typique (C ++ 17), l'approche est simplement généralisée aux comparaisons non seulement avec les éléments state_type, mais aussi avec les types primitifs qui peuvent être utilisés comme paramètres de modèle non-type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br>  Grâce à ces améliorations incrémentielles, la syntaxe superficielle souhaitée pour la vérification est obtenue: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br>  Dans cet exemple, le guide de déduction sert à inviter les paramètres de structure de modèle souhaités à un compilateur qui connaît les types d'arguments du constructeur. <br><br>  Plus intéressant.  Bjorn apprend à généraliser le code résultant pour les opérateurs de comparaison en plus de ==, puis pour les opérations arbitraires.  Avec l'exemple d'utilisation, des fonctionnalités telles que l'attribut no_unique_address (C ++ 20) et les paramètres de modèle dans les fonctions lambda (C ++ 20) sont expliquées.  (Oui, maintenant la syntaxe lambd est encore plus facile à retenir - ce sont quatre paires consécutives de parenthèses de toutes sortes.) La solution finale utilisant des fonctions comme parties constructeurs me réchauffe vraiment l'âme, sans parler de l'expression de tuple dans les meilleures traditions du calcul lambda. <br><br>  Au final, n'oubliez pas de mettre un gloss: <br><br><ul><li>  Rappelez-vous que les lambdas sont constexpr gratuitement; </li><li>  Ajoutez une transmission parfaite et regardez sa syntaxe laide appliquée au pack de paramètres dans la fermeture lambda; </li><li>  Donnons au compilateur plus d'options pour les optimisations avec noexcept conditionnel; </li><li>  Nous nous occuperons d'une sortie d'erreur plus claire dans les modèles en raison des valeurs de retour explicites des lambdas.  Cela obligera le compilateur à effectuer plus de vérifications avant d'appeler réellement la fonction de modèle - au stade de la vérification de type. </li></ul><br>  Pour plus de détails, reportez-vous aux supports de cours: <br><br><ul><li>  Diapositives de rapport: <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[Techniques modernes pour garder votre code au sec]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Code source Github</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">Article de blog de l'auteur</a> </li></ul><br><h2>  Nos impressions </h2><br>  Notre première participation à C ++ Russia était connue pour sa richesse.  Il y avait une impression de C ++ Russia comme un événement émotionnel, où la frontière entre l'apprentissage et la communication en direct n'est presque pas perceptible.  Tout, de l'humeur des intervenants aux compétitions des partenaires de l'événement, est propice à des discussions animées.  Le contenu de la conférence, qui se compose de rapports, couvre un assez large éventail de sujets, y compris les innovations C ++, des exemples tirés de la pratique de grands projets et des considérations architecturales idéologiques.  Mais il serait injuste de priver l'attention de la composante sociale de l'événement, ce qui aide à surmonter les barrières linguistiques par rapport non seulement au C ++. <br><br>  Nous remercions les organisateurs de la conférence de l'opportunité de participer à un tel événement! <br>  Vous pouvez voir le post des organisateurs sur le passé, le présent et l'avenir de C ++ Russia <a href="https://habr.com/ru/company/jugru/blog/480584/">sur le blog JUG Ru</a> . <br><br>  Merci d'avoir lu, et nous espérons que notre récit des événements s'est avéré utile! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481358/">https://habr.com/ru/post/fr481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481348/index.html">Pentest Active Directory. Partie 1</a></li>
<li><a href="../fr481350/index.html">Qui travaille au cosmodrome de Plesetsk</a></li>
<li><a href="../fr481352/index.html">DBA: effacement des enregistrements de clone d'une table sans PK</a></li>
<li><a href="../fr481354/index.html">TelegramBot. La fonctionnalité de base. Mouches séparément, côtelettes séparément. (2e partie)</a></li>
<li><a href="../fr481356/index.html">Merci, 2019</a></li>
<li><a href="../fr481360/index.html">Les résultats de la semaine: Rambler et Twitch ont convenu, le travail électronique sera introduit en Fédération de Russie et Facebook créera son propre système d'exploitation</a></li>
<li><a href="../fr481362/index.html">Certificat SSL pour l'application web Docker</a></li>
<li><a href="../fr481364/index.html">La maison sensible remplace les maisons intelligentes</a></li>
<li><a href="../fr481366/index.html">RICE: Priorisation facile pour les chefs de produit</a></li>
<li><a href="../fr481368/index.html">Test aveugle de l'appareil photo: iPhone, Pixel, Samsung et Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>