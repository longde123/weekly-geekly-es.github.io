<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∏Ô∏è üë©üèº‚Äçüîß üí™ Algoritmos de processamento inteligente de strings no ClickHouse üîë üêª ‚ú≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O ClickHouse encontra constantemente tarefas de processamento de string. Por exemplo, pesquisando, calculando as propriedades de cadeias UTF-8 ou algo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de processamento inteligente de strings no ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  O ClickHouse encontra constantemente tarefas de processamento de string.  Por exemplo, pesquisando, calculando as propriedades de cadeias UTF-8 ou algo mais ex√≥tico, seja uma pesquisa que diferencia mai√∫sculas de min√∫sculas ou uma pesquisa de dados compactados. </p><br><p> Tudo come√ßou com o fato de a gerente de desenvolvimento da ClickHouse, Lyosha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">o6CuFl2Q,</a> ter nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">procurado</a> na Faculdade de Ci√™ncias da Computa√ß√£o da Higher School of Economics e oferecido um grande n√∫mero de t√≥picos para trabalhos e diplomas.  Quando vi ‚ÄúAlgoritmos de processamento inteligente de cadeias de caracteres no ClickHouse‚Äù (eu, uma pessoa interessada em v√°rios algoritmos, inclusive os experimentais), imediatamente montei planos para obter o diploma mais bacana.  Minha alegria e express√£o podem ser descritas da seguinte forma: </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  A ClickHouse pensou cuidadosamente na organiza√ß√£o do armazenamento de dados na mem√≥ria - em colunas.  No final de cada coluna, h√° um preenchimento de 15 bytes para leitura segura de um registro de 16 bytes.  Por exemplo, o ColumnString armazena seq√º√™ncias terminadas nulas junto com deslocamentos.  √â muito conveniente trabalhar com essas matrizes. </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p>  Tamb√©m existem ColumnFixedString, ColumnConst e LowCardinality, mas n√£o falaremos sobre eles hoje em detalhes.  O ponto principal nesse momento √© que o design para leitura segura de caudas √© simplesmente bonito, e a localidade dos dados tamb√©m desempenha um papel importante no processamento. </p><br><h2 id="poisk-po-podstrokam">  Pesquisa por Substring </h2><br><p>  Provavelmente, voc√™ conhece muitos algoritmos diferentes para encontrar uma substring em uma string.  Vamos falar sobre aqueles que s√£o usados ‚Äã‚Äãno ClickHouse.  Primeiro, apresentamos algumas defini√ß√µes: </p><br><ol><li>  palheiro - a linha em que estamos olhando;  tipicamente comprimento √© indicado por <em>n</em> . </li><li>  agulha - a string ou express√£o regular que estamos procurando;  o comprimento ser√° indicado por <em>m</em> . </li></ol><br><p>  Depois de estudar um grande n√∫mero de algoritmos, posso dizer que existem 2 (no m√°ximo 3) tipos de algoritmos de pesquisa de substring.  A primeira √© a cria√ß√£o, de uma forma ou de outra, de estruturas de sufixos.  O segundo tipo s√£o algoritmos baseados em compara√ß√£o de mem√≥ria.  H√° tamb√©m o algoritmo Rabin-Karp, que usa hashes, mas √© bastante √∫nico em seu tipo.  O algoritmo mais r√°pido n√£o existe, tudo depende do tamanho do alfabeto, do comprimento da agulha, do palheiro e da frequ√™ncia de ocorr√™ncia. </p><br><p>  Leia sobre diferentes algoritmos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  E aqui est√£o os algoritmos mais populares: </p><br><ol><li>  Knut - Morris - Pratt, </li><li>  Boyer - Moore, </li><li>  Boyer - Moore - Horspool, </li><li>  Rabin - Carp, </li><li>  Frente e verso (usado na glibc chamado ‚Äúmemmem‚Äù), </li><li>  BNDM </li></ol><br><p>  A lista continua.  Na ClickHouse, tentamos honestamente tudo, mas no final decidimos por uma vers√£o mais extraordin√°ria. </p><br><h4 id="algoritm-volnickogo">  Algoritmo de Volnitsky </h4><br><p>  O algoritmo foi publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog do</a> programador Leonid Volnitsky no final de 2010.  √â um pouco remanescente do algoritmo Boyer-Moore-Horspool, apenas uma vers√£o aprimorada. </p><br><p>  Se <em>m &lt;4</em> , o algoritmo de pesquisa padr√£o √© usado.  Salve todas as agulhas de bigrams (2 bytes consecutivos) do final em uma tabela de hash com endere√ßamento aberto de tamanho <em>| Sigma |</em>  <em><sup>2</sup></em> elementos (na pr√°tica, s√£o 2 <sup>16</sup> elementos), onde os deslocamentos deste bigram ser√£o os valores e o pr√≥prio bigram ser√° o hash e o √≠ndice ao mesmo tempo.  A posi√ß√£o inicial estar√° na posi√ß√£o <em>m - 2</em> desde o in√≠cio do palheiro.  Seguimos o palheiro com uma etapa de <em>m - 1</em> , observamos o pr√≥ximo bigram desta posi√ß√£o no palheiro e consideramos todos os valores do bigram na tabela de hash.  Em seguida, compararemos dois peda√ßos de mem√≥ria com o algoritmo de compara√ß√£o usual.  A cauda restante ser√° processada pelo mesmo algoritmo. </p><br><p>  A etapa <em>m-1 √©</em> escolhida de tal maneira que, se houver uma ocorr√™ncia de agulha no palheiro, consideraremos definitivamente o bigram dessa entrada - garantindo assim que retornemos a posi√ß√£o da entrada no palheiro.  A primeira ocorr√™ncia √© garantida pelo fato de adicionarmos √≠ndices do final √† tabela de hash pelo bigram.  Isso significa que, quando formos da esquerda para a direita, primeiro consideraremos os bigrams a partir do final da linha (talvez inicialmente considerando bigrams completamente desnecess√°rios) e, em seguida, mais perto do in√≠cio. </p><br><p> Considere um exemplo.  Deixe o palheiro de corda ser <code>abacabaac</code> e agulha igual a <code>aaca</code> .  A tabela de hash ser√° <code>{aa : 0, ac : 1, ca : 2}</code> . </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Vemos o bigram <code>ac</code> .  Na agulha, substitu√≠mos na igualdade: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  N√£o corresponde.  Ap√≥s <code>ac</code> n√£o h√° entradas na tabela de hash, avan√ßamos na etapa 3: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  N√£o h√° bigrams <code>ba</code> na tabela de hash, v√° em frente: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  H√° um bigram <code>ca</code> na agulha, olhamos para o deslocamento e encontramos a entrada: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  O algoritmo tem muitas vantagens.  Em primeiro lugar, voc√™ n√£o precisa alocar mem√≥ria na pilha, e 64 KB na pilha n√£o s√£o algo transcendental agora.  Em segundo lugar, 2 <sup>16</sup> √© um n√∫mero excelente para fazer o m√≥dulo do processador;  estas s√£o apenas instru√ß√µes movzwl (ou, como brincamos, "movsvl") e a fam√≠lia. </p><br><p>  Em m√©dia, esse algoritmo provou ser o melhor.  Pegamos os dados do Yandex.Metrica, os pedidos s√£o quase reais.  Uma velocidade de fluxo, mais √© melhor, KMP: algoritmo Knut - Morris - Pratt, BM: Boyer - Moore, BMH: Boyer - Moore - Horspool. </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p>  Para n√£o ser infundado, o algoritmo pode funcionar em tempo quadr√°tico: </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p>  √â usado na fun√ß√£o de <code>position(Column, ConstNeedle)</code> e tamb√©m atua como uma otimiza√ß√£o para pesquisas de express√µes regulares. </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam">  Pesquisa de express√µes regulares </h2><br><p>  Mostraremos como o ClickHouse otimiza as pesquisas de express√µes regulares.  Muitas express√µes regulares cont√™m uma substring dentro, que deve estar dentro de um palheiro.  Para n√£o construir uma m√°quina de estados finitos e compar√°-la, isolaremos essas substrings. </p><br><p>  Fazer isso √© bem simples: todos os colchetes de abertura aumentam o n√≠vel de aninhamento, os colchetes de fechamento diminuem;  tamb√©m existem caracteres espec√≠ficos para express√µes regulares (por exemplo, '.', '*', '?', '\ w' etc.).  Precisamos obter todas as substrings no n√≠vel 0. Considere um exemplo: <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p>  N√≥s o dividimos naquelas substrings que devem estar no palheiro a partir da express√£o regular, ap√≥s o qual selecionamos o comprimento m√°ximo, procuramos candidatos e verificamos com o mecanismo de express√£o regular RE2 usual.  Na imagem acima, h√° uma express√£o regular, √© processada pelo mecanismo RE2 usual a 736 MB / s, o Hyperscan (um pouco mais tarde) gerencia 1,6 GB / s, e gerenciamos 1,69 GB / s por n√∫cleo, juntamente com a descompress√£o LZ4.  Em geral, essa otimiza√ß√£o est√° na superf√≠cie e acelera bastante a busca por express√µes regulares, mas geralmente n√£o √© implementada em ferramentas, o que me surpreende bastante. </p><br><p>  A palavra-chave LIKE tamb√©m √© otimizada usando esse algoritmo, somente ap√≥s LIKE uma express√£o regular muito simplificada pode aparecer em %%%%%% (substring arbitr√°rio) e <code>_</code> (caractere arbitr√°rio). </p><br><p>  Infelizmente, nem todas as express√µes regulares est√£o sujeitas a essas otimiza√ß√µes; por exemplo, a partir do <code>yandex|google</code> , √© imposs√≠vel extrair explicitamente substrings que devem ocorrer no palheiro.  Portanto, criamos uma solu√ß√£o completamente diferente. </p><br><h2 id="poisk-po-mnogim-podstrokam">  Procure por muitas substrings </h2><br><p>  O problema √© que h√° muita agulha e quero entender se pelo menos uma delas est√° inclu√≠da no palheiro.  Existem m√©todos bastante cl√°ssicos para essa pesquisa, por exemplo, o algoritmo Aho-Korasik.  Mas ele n√£o foi muito r√°pido para a nossa tarefa.  Falaremos sobre isso um pouco mais tarde. </p><br><p><del>  Lesha </del>  O ClickHouse adora solu√ß√µes n√£o padronizadas, por isso decidimos tentar algo diferente e, talvez, criar um novo algoritmo de pesquisa.  E eles fizeram. </p><br><p>  Examinamos o algoritmo de Volnitsky e o modificamos para que ele comece a procurar muitas substrings de uma s√≥ vez.  Para fazer isso, voc√™ s√≥ precisa adicionar os bigrams de todas as linhas e armazenar, al√©m de um √≠ndice de linhas na tabela de hash.  A etapa ser√° selecionada de pelo menos todos os comprimentos da agulha menos 1 para garantir novamente a propriedade de que, se houver uma ocorr√™ncia, veremos seu bigrama.  A tabela de hash aumentar√° para 128 KB (linhas com mais de 255 s√£o processadas pelo algoritmo padr√£o, consideraremos n√£o mais que 256 agulhas).  Sou muito pregui√ßoso, ent√£o aqui est√° um exemplo da apresenta√ß√£o (leia da esquerda para a direita de cima para baixo): </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p>  Come√ßamos a analisar como esse algoritmo se comporta em compara√ß√£o com outros (as linhas s√£o obtidas de dados reais).  E para um pequeno n√∫mero de linhas, ele faz tudo (a velocidade e a descarga s√£o indicadas - cerca de 2,5 GB / s). </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p>  Ent√£o ficou interessante.  Por exemplo, com um grande n√∫mero de bigrams semelhantes, perdemos para alguns concorrentes.  √â compreens√≠vel - come√ßamos a comparar muitos peda√ßos de mem√≥ria e a degradar. </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p>  Voc√™ n√£o pode acelerar muito se o comprimento m√≠nimo da agulha for grande o suficiente.  Obviamente, temos mais oportunidades de pular peda√ßos inteiros de palheiro sem pagar nada por isso. </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p>  O ponto de inflex√£o come√ßa em algum lugar nas linhas 13-15.  Cerca de 97% das solicita√ß√µes que vi no cluster tinham menos de 15 linhas: </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p>  Bem, uma imagem muito assustadora - 41 linhas, muitos bigrams repetidos: </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p>  Como resultado, no ClickHouse (19.5), implementamos as seguintes fun√ß√µes atrav√©s deste algoritmo: </p><br><p>  - <code>multiSearchAny(h, [n_1, ..., n_k])</code> - 1, se pelo menos uma das agulhas estiver no palheiro. <br>  - <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> - a posi√ß√£o mais √† esquerda da entrada no palheiro (de um) ou 0, se n√£o encontrado. <br>  - <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> - o √≠ndice de agulha mais √† esquerda, encontrado no palheiro;  0 se n√£o for encontrado. <br>  - <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> - todas as primeiras posi√ß√µes de todas as agulhas, retorna uma matriz. </p><br><p>  Os sufixos s√£o -UTF8 (n√£o normalizamos), -CaseInsensitive (adicionamos 4 bigrams com mai√∫sculas e min√∫sculas), -CaseInsensitiveUTF8 (existe uma condi√ß√£o em que letras mai√∫sculas e min√∫sculas devem ter o mesmo n√∫mero de bytes).  Veja a implementa√ß√£o <a href="">aqui</a> . </p><br><p>  Depois disso, nos perguntamos se poder√≠amos fazer algo semelhante com muitas express√µes regulares.  E eles encontraram uma solu√ß√£o que j√° estava estragada nos benchmarks. </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam">  Pesquise por muitas express√µes regulares </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Hyperscan</a> √© uma biblioteca da Intel que pesquisa imediatamente muitas express√µes regulares.  Ele usa heur√≠stica para isolar subpalavras das express√µes regulares sobre as quais escrevemos, e muitos SIMDs para procurar o aut√¥mato Glushkov (o algoritmo parece ser chamado de Teddy). </p><br><p>  Em geral, tudo est√° nas melhores tradi√ß√µes para obter o m√°ximo da busca por express√µes regulares.  A biblioteca realmente faz o que √© declarado em suas fun√ß√µes. </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p>  Felizmente, no meu m√™s de desenvolvimento na ClickHouse, fui capaz de superar o desenvolvimento de 12 anos em uma classe decente de consultas e estou muito satisfeito com isso. </p><br><p>  No Yandex, a biblioteca Hyperscan tamb√©m √© usada no antispam.  A julgar pelas cr√≠ticas, ela calmamente processa milhares de express√µes regulares e as procura rapidamente. </p><br><p>  A biblioteca tem v√°rias desvantagens.  A primeira √© a quantidade n√£o documentada de mem√≥ria consumida e um recurso estranho que o palheiro deve ter menos de 2 <sup>32</sup> bytes.  A segunda - voc√™ n√£o pode retornar as primeiras posi√ß√µes de gra√ßa, os √≠ndices de agulha mais √† esquerda, etc. E a terceira menos - existem alguns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erros</a> inesperados.  Portanto, na ClickHouse, implementamos as seguintes fun√ß√µes usando o Hyperscan: </p><br><p>  - <code>multiMatchAny(h, [n_1, ..., n_k])</code> - 1, se pelo menos uma das agulhas surgir com palheiro. <br>  - <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> - qualquer √≠ndice da agulha que <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> palheiro. </p><br><p>  Estamos interessados, mas como voc√™ pode pesquisar n√£o exatamente, mas aproximadamente?  E veio com v√°rias solu√ß√µes. </p><br><h2 id="priblizhyonnyy-poisk">  Pesquisa aproximada </h2><br><p>  O padr√£o na pesquisa aproximada √© a dist√¢ncia de Levenshtein - o n√∫mero m√≠nimo de caracteres que podem ser substitu√≠dos, adicionados e removidos para obter uma sequ√™ncia b de comprimento n de uma sequ√™ncia a de comprimento m.  Infelizmente, o ing√™nuo algoritmo de programa√ß√£o din√¢mica funciona para <em>O (mn)</em> ;  as melhores mentes do ShAD podem faz√™-lo em <em>O (mn / log max (n, m))</em> ;  √© f√°cil pensar em <em>O ((n + m) ‚ãÖ alfa)</em> , onde <em>alfa</em> √© a resposta;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a ci√™ncia</a> pode fazer isso por <em>O ((alfa - | n - m |) min (m, n, alfa) + m + n)</em> (o algoritmo √© simples, leia pelo menos no SHAD) ou, se for um pouco mais claro, por <em>O (alfa ^ 2 + m + n)</em> .  Ainda h√° um sinal de menos: √© provavelmente imposs√≠vel livrar-se do tempo quadr√°tico no pior dos casos polinomialmente - Peter Indik escreveu um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> muito poderoso sobre isso. </p><br><p>  H√° um exerc√≠cio: imagine que, ao substituir um personagem √† dist√¢ncia de Levenshtein, voc√™ pague uma multa n√£o dois, mas dois;  ent√£o crie um algoritmo para <em>O ((n + m) log (n + m))</em> . </p><br><p>  Ainda n√£o funciona, por muito tempo e caro.  Mas, com a ajuda de tal dist√¢ncia, fizemos a detec√ß√£o de erros de digita√ß√£o nas consultas. </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p>  Al√©m da dist√¢ncia de Levenshtein, h√° uma dist√¢ncia de Hamming.  Tamb√©m com ele tudo est√° muito ruim, mas um pouco melhor do que com a dist√¢ncia de Levenshtein.  Ele n√£o leva em considera√ß√£o a remo√ß√£o de caracteres, mas considera apenas para duas linhas do mesmo comprimento o n√∫mero de caracteres nos quais eles diferem.  Portanto, se usarmos a dist√¢ncia para cadeias de comprimento m &lt;n, somente na busca pelas subseq√º√™ncias mais pr√≥ximas. </p><br><p>  Como calcular uma matriz de discrep√¢ncias (uma matriz d de n - m + 1 elementos, em que d [i] √© o n√∫mero de caracteres diferentes no i-√©simo do in√≠cio da sobreposi√ß√£o) para o <em>log O (| Sigma | (n + m) (n + m) )</em> ?  Primeiro, fa√ßa <em>| Sigma |</em>  m√°scaras de bit indicando se esse s√≠mbolo √© igual ao considerado.  Em seguida, calculamos a resposta para cada uma das m√°scaras Sigma e adicionamos - obtemos a resposta original. </p><br><p>  Considere um exemplo.  <code>abba</code> , substring <code>ba</code> , alfabeto bin√°rio.  Temos duas m√°scaras <code>1001, 01</code> e <code>0110, 10</code> . </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p>  Obtemos o array [0, 1, 2] - esta √© quase a resposta correta.  Mas observe que, para cada letra, o n√∫mero de correspond√™ncias √© apenas o produto escalar de uma agulha bin√°ria fixa e de todos os substratos do palheiro.  E para isso, √© claro, h√° uma transforma√ß√£o r√°pida de Fourier! </p><br><p>  Para quem n√£o sabe: a FFT pode multiplicar dois polin√¥mios de graus <em>m &lt;n</em> em um tempo <em>O (n log n)</em> , desde que o trabalho com os coeficientes seja realizado por unidade de tempo.  As convolu√ß√µes s√£o muito semelhantes aos produtos escalares.  √â suficiente duplicar os coeficientes do primeiro polin√¥mio e expandir e suplementar o segundo com o n√∫mero necess√°rio de zeros; ent√£o, obtemos todos os produtos escalares de uma string bin√°ria e todos os substrings da outra em <em>O (n log n)</em> - algum tipo de m√°gica!  Mas acredite, isso √© absolutamente real, e √†s vezes as pessoas fazem isso. </p><br><p>  Mas n√£o no ClickHouse.  Para n√≥s, trabalhando com | Sigma |  = 30 j√° √© grande e a FFT n√£o √© o algoritmo pr√°tico mais agrad√°vel para o processador ou, como dizem nas pessoas comuns, "a constante √© grande". </p><br><p>  Portanto, decidimos analisar outras m√©tricas.  Chegamos √† bioinform√°tica, onde as pessoas usam dist√¢ncia de n-grama.  De fato, tomamos todos os n-gramas de palheiro e agulha, considere 2 multisets com esses n-gramas.  Ent√£o pegamos a diferen√ßa sim√©trica e dividimos pela soma das cardinalidades de dois multisets com n-gramas.  Temos um n√∫mero de 0 a 1 - quanto mais pr√≥ximo de 0, mais as linhas s√£o semelhantes.  Considere um exemplo em que <em>n = 4</em> : </p><br><pre> <code class="plaintext hljs">abcda ‚Üí {abcd, bcda}; Size = 2 bcdab ‚Üí {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p>  Como resultado, fizemos uma dist√¢ncia de 4 gramas e mantivemos um monte de id√©ias do SSE l√°, al√©m de enfraquecermos levemente a implementa√ß√£o dos hashes crc32 de byte duplo. </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p>  Confira a <a href="">implementa√ß√£o</a> .  Cuidado: c√≥digo muito atraente e otimizado para compiladores. </p><br><p>  Aconselho especialmente que voc√™ preste aten√ß√£o ao <a href="">truque sujo</a> para converter letras min√∫sculas para pontos de c√≥digo ASCII e russo. </p><br><p>  - <code>ngramDistance(haystack, needle)</code> - retorna um n√∫mero de 0 a 1;  quanto mais pr√≥ximo de 0, mais linhas s√£o semelhantes entre si. <br>  - -UTF8, -CaseInsensitive, -CaseInsensitiveUTF8 (invas√£o suja para russos e ASCII). </p><br><p>  O Hyperscan tamb√©m n√£o fica parado - possui funcionalidade para pesquisa aproximada: voc√™ pode procurar linhas que parecem express√µes regulares pela dist√¢ncia constante de Levenshtein.  √â criado <em>um</em> aut√¥mato √† <em>dist√¢ncia + 1</em> , que √© interconectado pela exclus√£o, substitui√ß√£o ou inser√ß√£o de um caractere, ou seja, ‚Äúfino‚Äù, ap√≥s o qual o algoritmo usual para verificar se um aut√¥mato aceita uma linha espec√≠fica √© aplicado.  No ClickHouse, n√≥s os implementamos com os seguintes nomes: </p><br><p>  - <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> - semelhante ao multiMatchAny, apenas com dist√¢ncia. <br>  - <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> - semelhante ao multiMatchAnyIndex, apenas com dist√¢ncia. </p><br><p>  Com o aumento da <em>dist√¢ncia, a</em> velocidade come√ßa a diminuir bastante, mas ainda permanece em um n√≠vel bastante decente. </p><br><p>  Conclua a pesquisa e comece a processar cadeias UTF-8.  Havia tamb√©m muitas coisas interessantes. </p><br><h2 id="obrabotka-utf-8-strok">  Processamento de linha UTF-8 </h2><br><p>  Admito que foi dif√≠cil romper o limite de implementa√ß√µes ing√™nuas em cadeias codificadas em UTF-8.  Foi especialmente dif√≠cil estragar o SIMD.  Vou compartilhar algumas id√©ias sobre como fazer isso. </p><br><p>  Lembre-se de como √© uma sequ√™ncia UTF-8 v√°lida: </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p>  Vamos tentar calcular o comprimento do ponto de c√≥digo pelo primeiro byte.  √â aqui que come√ßa a m√°gica.  Novamente, escrevemos algumas propriedades: </p><br><p>  - Come√ßando em 0xC <em>e em 0xD</em> tem 2 bytes <br>  - 0xC2 = 11 <u>0</u> 00010 <br>  - 0xDF = 11 <u>0</u> 11111 <br>  - 0xE0 = 111 <u>0</u> 0000 <br>  - 0xF4 = 1111 <u>0</u> 100, n√£o h√° nada al√©m de 0xF4, mas se houvesse 0xF8, haveria uma hist√≥ria diferente <br>  - Resposta 7 menos a posi√ß√£o do primeiro zero do final, se n√£o for um caractere ASCII </p><br><p>  N√≥s calculamos o comprimento: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p>  Felizmente, temos em estoque instru√ß√µes que podem calcular o n√∫mero de zero bits, come√ßando pelos mais significativos. </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p>  Computar bitScanReverse: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p>  Vamos tentar calcular o comprimento de uma string UTF-8 por pontos de c√≥digo via SIMD.  Para fazer isso, observe cada byte como um n√∫mero assinado e observe as seguintes propriedades: </p><br><p>  - 0xBF = -65 <br>  - 0x80 = -128 <br>  - 0xC2 = -62 <br>  - 0x7F = 127 <br>  - todos os primeiros bytes est√£o em [0xC2, 0x7F] <br>  - todos os bytes que n√£o s√£o o primeiro est√£o em [0x80, 0xBF] </p><br><p>  O algoritmo √© bastante simples.  Compare cada byte com -65 e, se for maior que esse n√∫mero, adicione um.  Se queremos usar o SIMD, essa √© a carga usual de 16 bytes do fluxo de entrada.  Depois, h√° uma compara√ß√£o de bytes, que no caso de um resultado positivo fornecer√° o byte 0xFF e, no caso de um negativo - 0x00.  Em seguida, a instru√ß√£o <code>pmovmskb</code> , que coletar√° os bits altos de cada byte do registro.  Ent√£o o n√∫mero de sublinhados aumenta, usamos o intr√≠nseco para a instru√ß√£o <code>popcnt</code> SSE4.  O esquema deste algoritmo pode ser ilustrado por um exemplo: </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p>  Acontece que, juntamente com a descompress√£o, o processamento por n√∫cleo ser√° de aproximadamente 1,5 GB / s. </p><br><p>  As fun√ß√µes s√£o chamadas: </p><br><p>  - <code>lengthUTF8(string)</code> - retorna o comprimento de uma string UTF-8 codificada corretamente, algo √© considerado inv√°lido, uma exce√ß√£o n√£o √© lan√ßada. </p><br><p>  Fomos mais longe porque quer√≠amos ainda mais fun√ß√µes com o processamento de string UTF-8.  Por exemplo, verificando a validade e convertendo para uma express√£o UTF-8 v√°lida. </p><br><p>  Para verificar a validade, usei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/cyb70289/utf8/</a> , adaptado para ClickHouse (na verdade, apenas alterei o processamento das caudas) e obtive velocidade de 1,22 GB / s em compara√ß√£o com 900 MB / s para o algoritmo ing√™nuo .  N√£o descreverei o pr√≥prio algoritmo, √© bastante complicado para a percep√ß√£o. </p><br><p>  - <code>isValidUTF8(string)</code> - retorna 1 se a string estiver codificada corretamente com UTF-8, caso contr√°rio, 0. <br>  - <code>toValidUTF8(string)</code> - substitui caracteres UTF-8 inv√°lidos pelo caractere   (U + FFFD).  Todos os caracteres inv√°lidos consecutivos s√£o recolhidos em um caractere de substitui√ß√£o.  Nenhuma ci√™ncia de foguetes. </p><br><p>  Em geral, nas linhas UTF-8, devido ao esquema est√°tico n√£o t√£o agrad√°vel, √© sempre dif√≠cil criar algo que seja bem otimizado. </p><br><h2 id="chto-dalshe">  O que vem a seguir? </h2><br><p>  Deixe-me lembr√°-lo de que essa foi minha tese.  Claro, eu a defendi por 10/10.  J√° fomos com ela para o Highload ++ Siberia (embora me parecesse que ela era de pouco interesse para algu√©m).  Assista a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o</a> .  Gostei que a parte pr√°tica da tese resultasse em muitas pesquisas interessantes.  E aqui est√° o pr√≥prio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diploma</a> .  Tem muitos erros de digita√ß√£o, porque ningu√©m leu.  :) </p><br><p>  Como parte da prepara√ß√£o do diploma, fiz v√°rios outros trabalhos semelhantes (os links levam a solicita√ß√µes de pool): </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√£o concat otimizada 2 vezes</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criou o formato python mais simples para solicita√ß√µes</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LZ4 acelerado em 4%</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fiz um √≥timo trabalho no SIMD for ARM e PPC64LE</a> ; <br>  - E ele aconselhou alguns estudantes do FCS com diplomas na ClickHouse. </p><br><p>  No final, descobriu-se que, na minha experi√™ncia, <del>  todo m√™s Lesha tentava me cantar </del>  ClickHouse √© o sistema mais agrad√°vel para escrever c√≥digo de alto desempenho, onde h√° documenta√ß√£o, coment√°rios, excelente suporte a desenvolvedores e devops.  ClickHouse √© incr√≠vel, realmente.  Cansado de mudar os formatos JSON?  Venha para Lesha e pe√ßa uma tarefa de qualquer n√≠vel - ele a fornecer√° para voc√™ e, no fim de semana, voc√™ ter√° grande prazer em escrever c√≥digo. </p><br><p>  Mas com todas as conquistas do ClickHouse e seu design, provavelmente n√£o se trata delas.  N√£o principalmente neles. </p><br><p>  Passei 4 anos de gradua√ß√£o no FCS, em junho me formei no HSE com honras, trabalhei por um ano e meio em uma equipe incr√≠vel em Yandex, tendo me inspirado.  Sem experi√™ncia total todo esse tempo <del>  e ferro </del>  Nada escrito no post teria funcionado.  FCN √© muito legal, se voc√™ aproveitar ao m√°ximo.  Agrade√ßo a Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ivan_puzyrevskiy</a> , Ignat Kolesnichenko, Gleb Evstropov e Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">maxim_babenko</a> por se encontrarem em minha divertida aventura na FCN.  E tamb√©m obrigado a todos os professores que me ensinaram alguma coisa. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466183/">https://habr.com/ru/post/pt466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466165/index.html">Como a intelig√™ncia artificial ajuda a gerenciar projetos</a></li>
<li><a href="../pt466169/index.html">Oferta especial para estudantes trabalhadores da JetBrains</a></li>
<li><a href="../pt466171/index.html">Cinco raz√µes para escolher o JUG.EKB</a></li>
<li><a href="../pt466179/index.html">fform: React & JSONSchema - flexibilidade m√°xima</a></li>
<li><a href="../pt466181/index.html">Python de C (API C)</a></li>
<li><a href="../pt466187/index.html">Editor de l√≥gica visual para Unity3d. Parte 2</a></li>
<li><a href="../pt466191/index.html">A principal coisa sobre a batalha pela neutralidade da rede nos EUA √© a cronologia dos eventos e o estado atual das coisas</a></li>
<li><a href="../pt466193/index.html">Feed autom√°tico personalizado do MailChimp a partir do feed RSS</a></li>
<li><a href="../pt466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../pt466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>