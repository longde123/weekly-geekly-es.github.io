<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç† üñäÔ∏è ‚úãüèº Algorithmen zur Erkennung von Bildumrissen üóØÔ∏è üöç üòº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel stellt die vier h√§ufigsten Algorithmen zur Schleifenerkennung vor. 

 Die ersten beiden, n√§mlich der Algorithmus zum Verfolgen von Quadrat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmen zur Erkennung von Bildumrissen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  Der Artikel stellt die vier h√§ufigsten Algorithmen zur Schleifenerkennung vor. <br><br>  Die ersten beiden, n√§mlich der Algorithmus zum Verfolgen von Quadraten und Verfolgen der Umgebung von Moore, sind einfach zu implementieren und werden daher h√§ufig zur Bestimmung der Kontur eines bestimmten Musters verwendet.  Leider weisen beide Algorithmen mehrere Schw√§chen auf, die <b>es</b> aufgrund ihrer besonderen Art der Nachbarschaft <b>unm√∂glich machen,</b> die Kontur einer gro√üen Klasse von Mustern <b>zu</b> erkennen. <br><br>  Diese Algorithmen ignorieren alle <b><i>‚ÄûL√∂cher‚Äú</i></b> im Muster.  Wenn wir beispielsweise ein Muster √§hnlich dem in <b><i>Abbildung 1</i></b> gezeigten haben, ist die von den Algorithmen erkannte Schaltung √§hnlich der in <b><i>Abbildung 2</i></b> gezeigten (der Umriss wird durch blaue Pixel angezeigt).  In einigen Anwendungsbereichen ist dies durchaus akzeptabel, in anderen Bereichen, beispielsweise bei der Zeichenerkennung, ist jedoch die Erkennung der internen Teile eines Musters erforderlich, um alle R√§ume zu finden, die ein bestimmtes Zeichen unterscheiden.  ( <b><i>Abbildung 3</i></b> zeigt den ‚Äûvollst√§ndigen‚Äú Umriss des Musters.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="Bild"></div><br><br>  Um eine vollst√§ndige Kontur zu erhalten, ist es daher erforderlich, zuerst den <b><i>"Lochsuch"</i></b> -Algorithmus zu verwenden, der die L√∂cher in einem gegebenen Muster bestimmt, und dann den Konturerkennungsalgorithmus auf jedes Loch anzuwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="Bild"></div><a name="habracut"></a><br><h2>  Was ist Konnektivit√§t? </h2><br>  In digitalen Bildern mit Bin√§rwerten kann ein Pixel einen der folgenden Werte haben: 1 - wenn es Teil des Musters ist, oder 0 - wenn es Teil des Hintergrunds ist, d.h.  keine Abstufung von Grau.  (Wir gehen davon aus, dass Pixel mit einem Wert von 1 schwarz und Pixel mit einem Wert von 0 wei√ü sind.) <br><br>  Um <b><i>Objekte</i></b> in einem digitalen Muster zu identifizieren, m√ºssen wir Gruppen von schwarzen Pixeln finden, die miteinander ‚Äûverbunden‚Äú sind.  Mit anderen Worten, die <b><i>Objekte</i></b> in einem gegebenen digitalen Muster sind die <b><i>verbundenen Komponenten</i></b> dieses Musters. <br><br>  Im allgemeinen Fall ist eine <b><i>verbundene Komponente</i></b> ein Satz schwarzer Pixel <b>P</b> , so dass f√ºr jedes Pixelpaar <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle 2 Pixel <b><i>in der Sequenz nebeneinander</i></b> sind ‚ÄûNachbarn‚Äú. <br><br>  Eine wichtige Frage stellt sich: <b><i>Wann k√∂nnen wir sagen, dass 2 Pixel ‚ÄûNachbarn‚Äú sind?</i></b>  Da wir quadratische Pixel verwenden, ist die Antwort auf die vorherige Frage aus folgendem Grund nicht trivial: Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quadratischen Tessellation haben</a> Pixel eine gemeinsame Kante oder einen gemeinsamen Scheitelpunkt oder nichts gemeinsam.  Jedes Pixel hat 8 Pixel gemeinsam;  solche Pixel bilden die "Moore-Nachbarschaft" dieses Pixels.  Sollten wir "Nachbar" -Pixel betrachten, die nur einen gemeinsamen Scheitelpunkt haben?  Oder m√ºssen zwei Pixel eine gemeinsame Kante haben, um als ‚ÄûNachbarn‚Äú betrachtet zu werden? <br><br>  Es gibt also zwei Arten von Konnektivit√§t: 4-Verbundenheit und 8-Verbundenheit. <br><br><h4>  4-Verbindung </h4><br>  Wann k√∂nnen wir sagen, dass ein bestimmter Satz schwarzer Pixel <b><i>4-fach verbunden ist?</i></b>  Zun√§chst m√ºssen Sie das Konzept eines <b><i>4-Nachbarn</i></b> (auch als <b><i>direkter Nachbar bezeichnet</i></b> ) definieren: <br><br>  <b>4-Nachbarn-Definition</b> : Ein Pixel <b>Q</b> ist ein <b><i>4-Nachbarn eines</i></b> gegebenen Pixels <b>P,</b> wenn <b>Q</b> und <b>P</b> eine gemeinsame Kante haben.  Die 4 Nachbarn des Pixels <b>P</b> (bezeichnet als <b>P2, P4, P6</b> und <b>P8</b> ) sind in <b><i>2</i></b> unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Definition einer 4-verbundenen Komponente</b> : Die Menge der schwarzen Pixel <b>P</b> ist eine <b><i>4-verbundene Komponente,</i></b> wenn f√ºr jedes Paar von Pixeln <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle zwei Pixel, die <b><i>in der Sequenz</i></b> <b><i>benachbart</i></b> sind <b><i>,</i></b> sind <b><i>4 Nachbarn</i></b> <br><br><h4>  Beispiele f√ºr 4-verbundene Muster </h4><br>  Die folgenden Diagramme zeigen Beispiele f√ºr 4 verbundene Muster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8-Verbindung </h4><br>  Wann kann ich sagen, dass ein bestimmter Satz schwarzer Pixel mit <b><i>8 verbunden ist</i></b> ?  Zun√§chst m√ºssen wir das Konzept eines <b><i>8-Nachbarn</i></b> (auch <b><i>indirekter Nachbar genannt</i></b> ) definieren: <br><br>  <b>8-Nachbarn-Definition</b> : Ein Pixel <b>Q</b> ist ein <b><i>8-Nachbarn</i></b> (oder nur ein <b><i>Nachbar</i></b> ) eines gegebenen Pixels <b>P,</b> wenn <b>Q</b> und <b>P</b> eine gemeinsame Kante oder einen gemeinsamen Scheitelpunkt haben.  Die 8 Nachbarn eines gegebenen Pixels <b>P</b> bilden die Moore-Nachbarschaft dieses Pixels. <br><br>  <b>Definition einer 8-verbundenen Komponente</b> : Die Menge der schwarzen Pixel <b>P</b> ist eine <b><i>8-verbundene Komponente</i></b> (oder nur eine <b><i>verbundene Komponente</i></b> ), wenn f√ºr jedes Paar von Pixeln <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass :: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle zwei Pixel, die <b><i>in dieser Sequenz</i></b> <b><i>benachbart</i></b> sind <b><i>,</i></b> sind <b><i>8 Nachbarn</i></b> <br><br>  <b>Hinweis</b> : Alle 4-verbundenen Muster sind 8-verbunden, d. H.  4-verbundene Muster sind eine Teilmenge der vielen 8-verbundenen Muster.  Andererseits kann ein 8-verbundenes Muster nicht 4-verbunden sein. <br><br><h4>  Beispiel f√ºr ein 8-verkn√ºpftes Muster </h4><br>  Das folgende Diagramm zeigt ein Muster, das 8-fach, aber nicht 4-fach verbunden ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Ein Beispiel f√ºr ein nicht mit 8 verbundenes Muster: </h4><br>  Das folgende Diagramm zeigt ein Beispiel eines Musters, das nicht mit 8 verbunden ist, d.h.  bestehend aus mehr als einer verbundenen Komponente (das Diagramm zeigt drei verbundene Komponenten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Square Trace-Algorithmus </h2><br><h4>  Idee </h4><br>  Die Idee hinter dem Square-Tracing-Algorithmus ist sehr einfach.  Dies kann auf die Tatsache zur√ºckgef√ºhrt werden, dass der Algorithmus einer der ersten Versuche war, die Kontur eines bin√§ren Musters zu erfassen. <br><br>  Um zu verstehen, wie es funktioniert, braucht man ein wenig Fantasie ... <br><br>  Angenommen, wir haben ein digitales Muster, beispielsweise eine Gruppe schwarzer Pixel auf einem Hintergrund wei√üer Pixel, d.h.  auf dem Gitter;  Finde das schwarze Pixel und deklariere es als unser " <b>anf√§ngliches</b> " Pixel.  (Das Finden des " <b>anf√§nglichen</b> " Pixels kann auf viele verschiedene Arten implementiert werden. Wir beginnen in der unteren linken Ecke des Rasters und scannen jede Pixelspalte von unten nach oben, von der linken Spalte nach rechts, bis wir auf ein schwarzes Pixel sto√üen. Wir erkl√§ren es als " <b>initial</b> ". ".) <br><br>  Stellen Sie sich nun vor, Sie sind ein Marienk√§fer, der auf dem Startpixel steht (siehe <b><i>Abbildung 1</i></b> unten).  Um den Umriss eines Musters zu erhalten, m√ºssen Sie Folgendes tun: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Die schwarzen Pixel, die Sie eingekreist haben, bilden den Umriss des Musters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Ein wichtiger Aspekt des Square-Trace-Algorithmus ist der ‚ÄûRichtungssinn‚Äú.  Drehungen nach links und rechts werden relativ zum aktuellen Standort ausgef√ºhrt, was davon abh√§ngt, wie Sie zum aktuellen Pixel gelangt sind.  Um die richtigen Bewegungen auszuf√ºhren, m√ºssen Sie daher Ihre Richtung verfolgen. <br><br><h4>  Algorithmus </h4><br>  Das Folgende ist eine formale Beschreibung des Quadratverfolgungsalgorithmus: <br><br>  Eingabe: Quadratische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> <b>T</b> , die die verbundene Komponente <b>P der</b> schwarzen Zellen enth√§lt. <br><br>  Ausgabe: Zeile <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> von Randpixeln, d.h.  Kontur. <br><br>  Starten Sie <br><br><ul><li>  Definieren Sie <b>B</b> als leere Menge. </li><li>  Scannen Sie die Zellen <b>T</b> von unten nach oben und von links nach rechts, bis ein schwarzes Pixel <b>s</b> von <b>P gefunden wird</b> . </li><li>  F√ºgen Sie <b>s</b> in <b>B ein.</b> </li><li>  Machen Sie das aktuelle Pixel <b>p zum</b> Anfangspixel <b>s</b> . </li><li>  Biegen Sie links ab, d.h.  Gehe zum benachbarten Pixel links von <b>p</b> . </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li><li>  W√§hrend <b>p</b> nicht gleich <b>s ist</b> , f√ºhren Sie aus <br><br>  Wenn das aktuelle Pixel <b>p</b> schwarz ist <br><ul><li>  f√ºge <b>p</b> in <b>B ein</b> und drehe dich nach links (gehe zum benachbarten Pixel links von <b>p</b> ). </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li></ul><br>  sonst <br><ul><li>  Biegen Sie rechts ab (gehen Sie zum n√§chsten Pixel rechts von <b>p</b> ). </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li></ul><br>  Ende des "Bye" -Zyklus </li></ul><br>  Das Ende <br><br>  <b>Hinweis: Die</b> Konzepte "links" und "rechts" sollten nicht in Bezug auf die Seite oder den Leser ber√ºcksichtigt werden, sondern in Bezug auf die Richtung des Eintritts in das "aktuelle" Pixel w√§hrend des Scannens. <br><br><h4>  Demonstration </h4><br>  Das Folgende ist eine animierte Demonstration, wie der Quadratverfolgungsalgorithmus den Umriss eines Musters erkennt.  Vergessen Sie nicht, dass sich der Marienk√§fer in Pixel bewegt.  Beachten Sie, wie sich die Richtung √§ndert, wenn Sie nach links und rechts abbiegen.  Drehungen nach links und rechts werden relativ zur aktuellen Richtung in einem Pixel ausgef√ºhrt, d.h.  Marienk√§fer Orientierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Analyse </h4><br>  Es stellt sich heraus, dass die F√§higkeiten des Square-Trace-Algorithmus sehr begrenzt sind.  Er ist nicht in der Lage, die Konturen einer gro√üen Familie von Mustern zu erkennen, die in realen Anwendungen h√§ufig auftreten. <br><br>  Dies ist haupts√§chlich auf die Tatsache zur√ºckzuf√ºhren, dass Links- und Rechtsdrehungen Pixel nicht ber√ºcksichtigen, die sich ‚Äûentlang‚Äú befinden <br>  Diagonalen ‚Äúvom aktuellen Pixel. <br><br>  Schauen wir uns die verschiedenen Muster mit unterschiedlicher Konnektivit√§t an und sehen, warum der Square-Trace-Algorithmus fehlschl√§gt.  Dar√ºber hinaus werden wir M√∂glichkeiten untersuchen, um die F√§higkeiten des Algorithmus zu verbessern und ihn auch mit Mustern funktionieren zu lassen, die eine besondere Art von Konnektivit√§t aufweisen. <br><br><h4>  Stoppkriterium </h4><br>  Eine der Schw√§chen des Algorithmus ist die Wahl eines Stoppkriteriums.  Mit anderen Worten, wann h√∂rt ein Algorithmus auf, ausgef√ºhrt zu werden? <br><br>  In der urspr√ºnglichen Beschreibung des Quadratverfolgungsalgorithmus besteht die Abschlussbedingung darin, das <b>Anfangspixel</b> ein zweites Mal zu treffen.  Es stellt sich heraus, dass der Algorithmus, wenn er von einem solchen Kriterium abh√§ngt, die Konturen einer gro√üen Familie von Mustern nicht erkennen kann. <br><br>  Das Folgende ist eine animierte Demo, die erkl√§rt, wie der Algorithmus aufgrund der Auswahl eines schlechten Stoppkriteriums die genaue Kontur des Musters nicht erkennen kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Wie Sie sehen k√∂nnen, kann die Verbesserung des Stoppkriteriums ein guter Anfang sein, um die Gesamtleistung des Algorithmus zu verbessern.  Es gibt zwei effektive Alternativen f√ºr ein vorhandenes Abschaltkriterium: <br><br>  a) Stoppen Sie nur, indem Sie das Startpixel <b><i>n-</i></b> mal besuchen, wobei n mindestens 2 ODER ist <br><br>  b) Halten Sie an, nachdem Sie das Startpixel ein zweites Mal getroffen haben, so wie wir es urspr√ºnglich getroffen haben. <br><br>  Dieses Kriterium wurde von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jacob Eliosoff</a> vorgeschlagen, daher werden wir es das <b><i>Kriterium nennen, um Jacob aufzuhalten</i></b> . <br><br>  Das √Ñndern des Stoppkriteriums verbessert im Allgemeinen die Effektivit√§t des Quadratverfolgungsalgorithmus, erm√∂glicht jedoch nicht die √úberwindung anderer Schw√§chen, die es bei Mustern mit speziellen Konnektivit√§tstypen aufweist. <br><br>  Der Square Tracing-Algorithmus kann die Kontur einer Musterfamilie mit einer Konnektivit√§t von 8 nicht erkennen, die KEINE Konnektivit√§t von 4 aufweist. <br><br>  Das Folgende ist eine animierte Demonstration, wie der Square-Trace-Algorithmus (mit Jacobs Stoppkriterium) den korrekten Umriss eines Musters mit Konnektivit√§t 8 ohne Konnektivit√§t 4 nicht erkennt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Ist dieser Algorithmus v√∂llig nutzlos? </h2><br>  Wenn Sie die obige Analyse lesen, denken Sie wahrscheinlich, dass der Square-Trace-Algorithmus die Umrisse der meisten Muster nicht erkennt.  Aber es stellt sich heraus.  dass es eine spezielle Familie von Mustern gibt, in denen der Pfad vom Quadratverfolgungsalgorithmus vollst√§ndig erkannt wird. <br><br>  Sei <b>P</b> die Menge schwarzer Pixel mit Konnektivit√§t 4 im Raster.  Lassen Sie die wei√üen Pixel des Gitters, d.h.  Die Hintergrundpixel <b>W</b> haben auch eine Konnektivit√§t von 4. Es stellt sich heraus, dass unter solchen Bedingungen des Musters und seines Hintergrunds bewiesen werden kann, dass der Quadratverfolgungsalgorithmus (mit dem Jacob-Stopp-Kriterium) die Bestimmung der Kontur immer erfolgreich handhabt. <br><br>  Unten ist der Beweis, dass in dem Fall, in dem sowohl das Muster als auch die Hintergrundpixel 4 verbunden sind, der Quadratverfolgungsalgorithmus die Kontur korrekt bestimmt, wenn das Jacob-Stopp-Kriterium verwendet wird. <br><br>  Beweis <br>  <b>Gegeben</b> : Das Muster <b>P ist</b> derart, dass alle Pixel des Musters (d. H. Schwarz) und die Hintergrundpixel (d. H. Wei√ü) W eine Konnektivit√§t von 4 haben. <br><br>  <b>Erste Beobachtung</b> <br><br>  Da der Satz wei√üer Pixel W eine Konnektivit√§t von 4 hat, bedeutet dies, dass das Muster keine ‚Äû <b><i>L√∂cher</i></b> ‚Äú enthalten kann (informell ausgedr√ºckt bedeuten ‚Äû <b><i>L√∂cher</i></b> ‚Äú Gruppen wei√üer Pixel, die vollst√§ndig von schwarzen Pixeln des Musters umgeben sind). <br><br>  Das Vorhandensein eines ‚Äû <b><i>Lochs</i></b> ‚Äú im Muster f√ºhrt zur Trennung der Gruppe wei√üer Pixel von den verbleibenden wei√üen Pixeln.  Viele wei√üe Pixel verlieren jedoch die Konnektivit√§t 4. <br><br>  <i>Abbildung 2</i> und <b><i>Abbildung 3</i></b> unten zeigen zwei Arten von ‚Äû <b><i>L√∂chern</i></b> ‚Äú, die in einem Muster mit Konnektivit√§t 4 auftreten k√∂nnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Zweite Beobachtung</b> <br><br>  Zwei beliebige schwarze Pixel eines Musters M√úSSEN eine gemeinsame Seite haben. <br><br>  Angenommen, zwei schwarze Pixel haben nur einen gemeinsamen Scheitelpunkt.  Um die Eigenschaft der 4-Verbundenheit des Musters zu erf√ºllen, muss es einen Pfad geben, der diese beiden Pixel verbindet, so dass alle zwei benachbarten Pixel auf diesem Pfad eine Konnektivit√§t von 4 haben. Dies ergibt jedoch ein Muster √§hnlich dem in <b><i>Abbildung 3</i></b> .  Mit anderen Worten f√ºhrt dies zu einer Trennung der wei√üen Pixel.  <b><i>Fig. 4</i></b> unten zeigt ein typisches Muster, das die Annahme erf√ºllt, dass die Pixel in dem Muster und im Hintergrund 4-fach verbunden sind, d.h.  haben keine " <b><i>L√∂cher</i></b> " und alle zwei schwarzen Pixel haben eine gemeinsame Seite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Es ist n√ºtzlich, solche Muster wie folgt darzustellen: <br><br>  Zuerst betrachten wir die Grenzpixel, d.h.  Umriss des Musters.  Wenn wir dann jedes Grenzpixel als 4 Kanten mit Einheitsl√§nge betrachten, werden wir sehen, dass einige dieser Kanten mit benachbarten wei√üen Pixeln gemeinsam sind.  Wir werden solche Kanten <b><i>Grenzkanten nennen</i></b> . <br><br>  Solche Begrenzungskanten k√∂nnen als Kanten eines Polygons betrachtet werden.  Auf dem <b><i>Bild</i></b> <b><i><br></i></b>  <b><i>In 5</i></b> unten wird diese Idee am Beispiel eines Polygons demonstriert, das dem Muster aus <b><i>4</i></b> oben entspricht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Wenn wir alle m√∂glichen ‚ÄûKonfigurationen‚Äú von Grenzpixeln betrachten, die in solchen Mustern auftreten k√∂nnen, werden wir sehen, dass es zwei einfache F√§lle gibt, die in <b><i>Abbildung 6</i></b> und <b><i>Abbildung 7</i></b> unten dargestellt sind. <br><br>  Die Grenzpixel k√∂nnen Vielfache dieser F√§lle oder andere Anordnungen sein, d.h.  die Drehungen und Wendungen dieser beiden F√§lle.  Grenzrippen sind blau als <b>E1, E2, E3</b> und <b>E4</b> markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Dritte Beobachtung</b> <br><br>  In den beiden oben genannten F√§llen wird der Square-Trace-Algorithmus unabh√§ngig von dem von uns gew√§hlten Anfangspixel und in die Richtung, in die er <b>f√§llt</b> , niemals <b>"zur√ºckgehen" (Backtrack)</b> , sondern niemals zweimal <b>durch die</b> <b>Grenzkante "gehen" (Backtrack).</b> nur wenn es den Rand kein zweites Mal verfolgt) und niemals die Grenzkante verfehlt.  Probieren Sie es aus! <br><br>  Hier m√ºssen zwei Konzepte gekl√§rt werden: <br><br>  a) Der Algorithmus <b>"geht zur√ºck"</b> , wenn er vor dem Verfolgen des gesamten Randes zur√ºckkehrt, um ein bereits besuchtes Pixel zu besuchen, und <br><br>  b) F√ºr jede <b><i>Begrenzungsrippe</i></b> gibt es zwei M√∂glichkeiten, <b>‚Äûdurch sie hindurchzugehen‚Äú</b> , n√§mlich ‚Äûnach innen‚Äú und ‚Äûnach au√üen‚Äú (wobei ‚Äûnach innen‚Äú die Bewegung des entsprechenden Polygons nach innen und ‚Äûnach au√üen‚Äú - nach au√üen des Polygons bedeutet). <br><br>  Wenn der Algorithmus au√üerdem "nach innen" durch eine der Grenzkanten geht, geht er "nach au√üen" durch die n√§chste Grenzkante, d. H.  Der Square-Trace-Algorithmus sollte nicht in der Lage sein, zwei aufeinanderfolgende Kanten auf dieselbe Weise zu durchlaufen. <br><br>  <b>Letzte Beobachtung</b> <br><br>  Jedes Muster hat eine <b>gerade Anzahl von</b> <b>Begrenzungskanten</b> . <br><br>  Wenn Sie sich das Polygon aus <b><i>Abbildung 5</i></b> ansehen, sehen Sie Folgendes: <br><br>  Wenn wir von dem im Diagramm markierten Scheitelpunkt <b>S ausgehen</b> und den Grenzkanten folgen m√∂chten, bis wir wieder <b>S</b> erreichen, stellen wir fest, dass wir dabei eine gerade Anzahl von Grenzkanten √ºberschreiten.  Wir k√∂nnen jede Grenzkante als ‚ÄûSchritt‚Äú in eine separate Richtung betrachten.  Dann muss es f√ºr jeden ‚ÄûSchritt‚Äú rechts einen entsprechenden ‚ÄûSchritt‚Äú links geben, wenn wir in die Ausgangsposition zur√ºckkehren m√∂chten.  Gleiches gilt f√ºr vertikale ‚ÄûStufen‚Äú.  Daher m√ºssen die ‚ÄûSchritte‚Äú entsprechende Paare haben, und dies erkl√§rt, warum jedes dieser Muster eine gerade Anzahl von Grenzkanten aufweist. <br><br>  Wenn der Algorithmus zum Verfolgen von Quadraten ein zweites Mal durch die <b>anf√§ngliche Grenzkante</b> (des anf√§nglichen Pixels) eintritt, wird er dies in <b>der gleichen</b> Richtung wie beim ersten Mal tun. <br><br>  Der Grund daf√ºr ist, dass der Algorithmus zum zweiten Mal auf die gleiche Weise wie in die anf√§ngliche Grenzkante durchl√§uft, da es zwei M√∂glichkeiten gibt, durch die Grenzkante zu gehen, und der Algorithmus sich abwechselnd nach innen und au√üen bewegt und es eine gerade Anzahl von Grenzkanten gibt erster. <br><br><h4>  Fazit </h4><br>  Im Fall eines 4-verbundenen Musters und Hintergrunds erkennt der Quadratverfolgungsalgorithmus den gesamten Rand, d.h.  Kontur, Muster und h√∂rt nach einer einzelnen Spur auf zu arbeiten, d.h.  es wird nicht erneut verfolgt, da es beim zweiten Erreichen der <b>anf√§nglichen Grenzkante</b> auf dieselbe Weise wie beim ersten Mal eingegeben wird.  Folglich bestimmt der Quadratverfolgungsalgorithmus mit dem Stoppkriterium von Jacob den Z√§hler eines Musters korrekt, vorausgesetzt, dass sowohl das Muster als auch der Hintergrund 4-fach verbunden sind. <br><br><h2>  Verfolgung der Umgebung von Moore </h2><br><h4>  Idee </h4><br>  Die Idee hinter der Moore-Neighbor-Verfolgung ist einfach;  Bevor wir es erkl√§ren, m√ºssen wir ein wichtiges Konzept erkl√§ren: <b><i>die Moore-Nachbarschaft eines</i></b> Pixels. <br><br><h4>  Die Nachbarschaft von Moore </h4><br>  Die Moore-Nachbarschaft eines Pixels <b>P</b> ist ein Satz von 8 Pixeln mit einem gemeinsamen Scheitelpunkt oder einer gemeinsamen Kante mit diesem Pixel.  Solche Pixel, n√§mlich <b>P1, P2, P3, P4, P5, P6, P7 und P8</b> , sind in <b><i>Fig. 1 gezeigt</i></b> . <br><br>  Das Viertel Moore (auch <b><i>8-Nachbarn</i></b> oder <b><i>indirekte Nachbarn genannt</i></b> ) ist ein wichtiges Konzept, auf das in der Literatur h√§ufig Bezug genommen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Jetzt sind wir bereit, uns mit der Idee vertraut zu machen, die der Spur der Umgebung von Moore zugrunde liegt. <br><br>  Es sei ein digitales Muster vorhanden, d.h.  eine Gruppe schwarzer Pixel auf einem Hintergrund wei√üer Pixel, d.h.  auf dem Gitter;  Finden Sie das schwarze Pixel und deklarieren Sie es zum " <b>anf√§nglichen</b> " Pixel.  (Es gibt verschiedene M√∂glichkeiten, das ‚Äû <b>anf√§ngliche</b> ‚Äú Pixel zu finden, aber wir beginnen wie zuvor in der unteren linken Ecke und scannen alle Pixelspalten der Reihe nach, bis wir das erste schwarze Pixel finden, das wir als ‚Äû <b>initial</b> ‚Äú deklarieren.) <br><br>  Stellen Sie sich nun erneut vor, Sie sind ein Marienk√§fer, der auf dem Startpixel steht (siehe <b><i>Abbildung 2</i></b> unten).  Ohne Verlust der Verallgemeinerung erkennen wir den Umriss, indem wir uns im Uhrzeigersinn um das Muster bewegen.  (Egal f√ºr welche Richtung wir uns entscheiden, die Hauptsache ist, sie st√§ndig im Algorithmus zu verwenden). <br><br>  Die allgemeine Idee ist folgende: Jedes Mal, wenn wir zum schwarzen Pixel <b>P</b> gelangen, kehren wir zu dem wei√üen Pixel zur√ºck, in dem wir zuvor standen.  Dann gehen <b>wir</b> um das Pixel <b>P</b> im Uhrzeigersinn herum und besuchen jedes Pixel in seiner N√§he von Moore, bis wir zum schwarzen Pixel gelangen.  Der Algorithmus wird beendet, wenn das Startpixel das Startpixel ein zweites Mal erreicht. <br><br>  Diese schwarzen Pixel, die der Algorithmus besucht hat, bilden den Umriss des Musters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algorithmus </h4><br>  Das Folgende ist eine formale Beschreibung des Moore-Nachbarschaftsverfolgungsalgorithmus: <br><br>  Eingabe: Quadratische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> <b>T,</b> die eine verbundene Komponente <b>P</b> schwarzer Zellen enth√§lt. <br><br>  Ausgabe: Zeile <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) von</b> Grenzpixeln, d.h.  Kontur. <br><br>  Bezeichne mit <b>M (a)</b> die Moore-Nachbarschaft von Pixel <b>a</b> . <br><br>  Sei <b>p</b> das aktuelle Randpixel. <br><br>  Sei <b>c</b> das aktuell betrachtete Pixel, d.h.  <b>c</b> ist in <b>M (p)</b> . <br><br>  Starten Sie <br><br><ul><li>  Definieren Sie <b>B</b> als leere Menge. </li><li>  Scannen Sie die Zellen <b>T</b> von unten nach oben und von links nach rechts, bis wir ein schwarzes Pixel <b>s</b> von <b>P finden.</b> </li><li>  F√ºgen Sie <b>s</b> in <b>B ein.</b> </li><li>  Wir setzen den Punkt <b>s</b> als den aktuellen Grenzpunkt <b>p</b> , d.h.  <b>p = s</b> </li><li>  Gehen wir zur√ºck, d.h.  Gehen wir weiter zu dem Pixel, von dem wir zu <b>s gekommen sind</b> . </li><li>  Sei <b>c das</b> n√§chste Pixel im Uhrzeigersinn in <b>M (p)</b> . </li><li>  W√§hrend <b>c</b> nicht gleich <b>s ist</b> , f√ºhren Sie aus <br><br><ul><li>  wenn <b>c</b> schwarz ist <br><ul><li>  F√ºgen Sie <b>c</b> in <b>B ein</b> </li><li>  wir setzen <b>p = c</b> </li><li>  gehe zur√ºck (verschiebe das aktuelle Pixel <b>c</b> zu dem Pixel, von dem wir zu <b>p gekommen sind</b> ) </li></ul><br>  sonst <br><ul><li>  Bewegen Sie das aktuelle Pixel <b>c</b> in <b>M (p)</b> zum n√§chsten Pixel im Uhrzeigersinn. </li></ul><br>  Ende des Tsch√ºss-Zyklus </li></ul></li></ul><br>  Das Ende <br><br><h4>  Demonstration </h4><br>  Das Folgende ist eine animierte Demonstration, wie Moores Nachbarschaftsspur die Musterkonturerkennung durchf√ºhrt.  (Wir haben beschlossen, den Umriss im Uhrzeigersinn zu verfolgen.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Analyse </h4><br>  Die Hauptschw√§che bei der Verfolgung der Umgebung von Moore liegt in der Wahl der Stoppkriterien. <br><br>  In der urspr√ºnglichen Beschreibung des Algorithmus zum Verfolgen der Umgebung von Moore besteht das Stoppkriterium darin, das <b>Anfangspixel</b> ein zweites Mal zu treffen.  √Ñhnlich wie beim Quadratverfolgungsalgorithmus stellt sich heraus, dass die Verfolgung der Umgebung von Moore unter Verwendung dieses Kriteriums die Konturen einer gro√üen Familie von Mustern nicht erkennen kann. <br><br>  Das Folgende ist eine animierte Demo, die erkl√§rt, warum der Algorithmus aufgrund der Auswahl eines schlechten Stoppkriteriums den genauen Umriss des Musters nicht finden kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Wie Sie sehen k√∂nnen, kann die Verbesserung des Stoppkriteriums ein guter Anfang sein, um die Gesamtleistung der Ablaufverfolgung zu verbessern.  Es gibt zwei effektive Alternativen f√ºr das Abschaltkriterium, √§hnlich dem Jacob-Abschaltkriterium. <br><br>  Die Verwendung des Jacob-Kriteriums verbessert die Effektivit√§t der Verfolgung der Umgebung von Moore erheblich und macht es zum besten Algorithmus zur Bestimmung der Kontur eines Musters, unabh√§ngig von seiner Konnektivit√§t. <br><br>  Der Grund daf√ºr liegt haupts√§chlich darin, dass der Algorithmus die gesamte Moore-Nachbarschaft des Grenzpixels √ºberpr√ºft, um nach dem n√§chsten Grenzpixel zu suchen.  Im Gegensatz zum quadratischen Trace-Algorithmus, der sich nur nach links und rechts dreht und die Pixel "diagonal" verfehlt, kann die Nachbarschaftsspur von Moore immer die √§u√üere Grenze einer verbundenen Komponente erkennen.  Der Grund ist folgender: F√ºr jedes <b><i>8-verbundene</i></b> (oder einfach <b><i>verbundene</i></b> ) Muster liegt das <b>n√§chste</b> Randpixel in der Moore-Nachbarschaft des aktuellen Randpixels.  Da die Nachbarschaftsspur von Moore jedes der Pixel in der Nachbarschaft von Moore des aktuellen Grenzpixels √ºberpr√ºft, muss sie das n√§chste Grenzpixel erkennen. <br><br>  Wenn die Verfolgung der Nachbarschaft von Moore das erste Pixel ein zweites Mal auf dieselbe Weise wie beim ersten Mal erreicht, bedeutet dies, dass eine <b>vollst√§ndige</b> <b>Au√üenkontur des</b> Musters erkannt wurde, und wenn der Algorithmus nicht gestoppt wird, erkennt er erneut dieselbe Kontur. <br><br><h2>  Radialer Scan </h2><br>  Der Radial Sweep-Algorithmus ist ein Konturerkennungsalgorithmus, der in einigen B√ºchern diskutiert wird.  Trotz des komplexen Namens ist die zugrunde liegende Idee sehr einfach.  Tats√§chlich stellt sich heraus, dass der Radial-Sweep-Algorithmus <b>mit der</b> Spur von Moores Umgebung <b>identisch ist</b> .  Man k√∂nnte fragen: "Warum erw√§hnen wir ihn √ºberhaupt?" <br><br>  Wenn Sie die Umgebung von Moore verfolgen, suchen Sie in der N√§he von Moore nach dem aktuellen Grenzpixel in einer bestimmten Richtung (wir haben die Richtung im Uhrzeigersinn gew√§hlt), bis ein schwarzes Pixel gefunden wird.  Sie deklariert dieses Pixel dann als aktuelles Grenzpixel und f√§hrt fort. <br><br>  Der Radial-Scan-Algorithmus macht dasselbe.  Andererseits bietet es eine interessante M√∂glichkeit, das n√§chste schwarze Pixel in der Moore-Nachbarschaft eines bestimmten Grenzpixels zu finden. <br><br>  Die Methode basiert auf der folgenden Idee: <br><br>  Jedes Mal, wenn wir ein neues Grenzpixel finden, machen Sie es zum aktuellen Pixel <b>P</b> und zeichnen Sie <b>ein imagin√§res Liniensegment</b> , das <b>P</b> mit dem <b>vorherigen</b> Grenzpixel verbindet.  Dann <b>drehen</b> wir <b>das</b> Segment relativ zu <b>P</b> im Uhrzeigersinn, bis es auf ein schwarzes Pixel in der Moore-Nachbarschaft von Pixel <b>P</b> st√∂√üt.  Die Drehung der Linie ist identisch mit der √úberpr√ºfung jedes Pixels in der N√§he von Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben eine animierte Demonstration erstellt, wie der Radial-Scan-Algorithmus funktioniert und wie es aussieht, als w√ºrde man die Umgebung von Moore nachzeichnen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wann stoppt der Radial-Sweep-Algorithmus? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns das Verhalten des Algorithmus anhand der folgenden Stoppkriterien erkl√§ren ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stoppkriterium 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie den Radial-Scan-Algorithmus abgeschlossen, wenn er das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Pixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein zweites Mal besucht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten finden Sie eine animierte Demo, aus der hervorgeht, warum das Unterbrechungskriterium korrekt ge√§ndert wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erw√§hnenswert, dass bei Verwendung dieses Stoppkriteriums in beiden Algorithmen die Wirksamkeit des Radial-Scan-Algorithmus mit der Verfolgung der Umgebung von Moore identisch ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Square-Trace-Algorithmus und im Moore-Nachbarschafts-Trace haben wir festgestellt, dass die Verwendung des Jacob-Stop-Kriteriums die Leistung beider Algorithmen erheblich verbessert. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jacob Stop - </font><font style="vertical-align: inherit;">Kriterium</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfordert , </font><font style="vertical-align: inherit;">dass die Ausf√ºhrung des </font><font style="vertical-align: inherit;">Algorithmus angehalten , </font><font style="vertical-align: inherit;">wenn Besuch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum zweiten Mal in der gleichen Richtung wie die erste Zeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider k√∂nnen wir das Jacob-Stop-Kriterium nicht im Radial-Sweep-Algorithmus verwenden. Der Grund ist, dass der Radial-Scan-Algorithmus das Konzept nicht definiert</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die "Richtung", in der es auf das Grenzpixel trifft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit anderen Worten, es ist nicht klar, in welche ‚ÄûRichtung‚Äú der Algorithmus in das Grenzpixel gefallen ist (und seine Definition ist nicht trivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher m√ºssen wir ein anderes Stoppkriterium vorschlagen, das nicht von der Richtung abh√§ngt, in der ein bestimmtes Pixel getroffen wird, wodurch die Effektivit√§t des Radial-Scan-Algorithmus verbessert werden kann ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stoppkriterium 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, jedes Mal, wenn der Algorithmus ein neues Grenzpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erkennt </font><font style="vertical-align: inherit;">, wird es in eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzpixeln </font><font style="vertical-align: inherit;">eingef√ºgt </font><font style="vertical-align: inherit;">: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; und als aktuelles Randpixel deklariert. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 betrachten</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anf√§ngliche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel). Dies bedeutet, dass wir das vorherige Randpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes aktuellen Randpixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i kennen</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (F√ºr das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 angenommen</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein imagin√§res Pixel, das keinem der Pixel auf dem Gitter entspricht, das dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Reihe der </font><font style="vertical-align: inherit;">Grenzpixel zugewandt ist </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angesichts der obigen Annahmen k√∂nnen wir die Abbruchkriterien bestimmen , </font><font style="vertical-align: inherit;">wie folgt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausf√ºhrung des </font><font style="vertical-align: inherit;">Algorithmus wird </font><font style="vertical-align: inherit;">beendet , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) der aktuelle Grenzpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuvor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als ein Pixel erf√ºllt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (wobei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in der Reihe der Randpixel, und </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit anderen Worten, der Algorithmus beendet die Ausf√ºhrung, wenn er das Grenzpixel P in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekunde besucht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal, wenn das Grenzpixel vor P (in der Reihe der Grenzpixel) zum zweiten Mal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dasselbe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel ist, das vor P war, als P zum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal besucht wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Bedingung des Stoppkriteriums erf√ºllt ist und der Algorithmus nicht heruntergefahren wird, erkennt der Radial-Scan-Algorithmus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die gleiche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenze ein zweites Mal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Leistung des Radial-Sweep-Algorithmus mit diesem Stoppkriterium √§hnelt der Leistung der Verfolgung der Moore-Nachbarschaft mit dem Jacob-Stoppkriterium.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theo Pavlidis Algorithmus </font></font></h2><br><h4>  Idee </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Algorithmus ist einer der neuesten von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorgeschlagenen Algorithmen zur Schleifenerkennung </font><font style="vertical-align: inherit;">. Er zitierte es in seinem 1982 erschienenen Buch </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmen f√ºr Grafik und Bildverarbeitung</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Kapitel 7, Abschnitt 5). Es ist nicht so einfach wie der Algorithmus zum Verfolgen von Quadraten oder der Umgebung von Moore, aber es ist nicht so kompliziert (dies ist typisch f√ºr die meisten Kantenerkennungsalgorithmen). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diesen Algorithmus nicht auf die gleiche Weise erkl√§ren, wie es in seinem Buch getan wurde. Unser Ansatz ist leichter zu verstehen und vermittelt eine Vorstellung von der allgemeinen Idee, die dem Algorithmus zugrunde liegt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Verlust der Verallgemeinerung haben wir uns entschlossen, die Schleife im Uhrzeigersinn zu durchlaufen, um der Reihenfolge aller anderen im Artikel vorgestellten Algorithmen zu entsprechen. Auf der anderen Seite w√§hlte Pavlidis die Richtung gegen den Uhrzeigersinn. Dies hat keinen Einfluss auf die Leistung des Algorithmus. Der einzige Unterschied ist die relative Richtung der Bewegungen, die wir ausf√ºhren, wenn wir die Kontur umgehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommen wir nun zur Idee ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir an, wir haben ein digitales Muster, d. H. eine Gruppe schwarzer Pixel auf einem Hintergrund wei√üer Pixel, d.h. auf dem Gitter; Finden Sie das schwarze Pixel und deklarieren Sie es zum " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anf√§nglichen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " Pixel. Sie k√∂nnen </font><font style="vertical-align: inherit;">auf verschiedene Arten </font><font style="vertical-align: inherit;">nach dem " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " -Pixel </font><font style="vertical-align: inherit;">suchen </font><font style="vertical-align: inherit;">, beispielsweise wie oben beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font><b><font style="vertical-align: inherit;">Initiale</font></b><font style="vertical-align: inherit;"> zu finden</font></font><b><font style="vertical-align: inherit;"></font></b>     .     <b></b> ,   ,       : <br><br> <b>  ,       </b> <br><br>            <b></b>   :      ,     .  ,    <b></b>    ,       (¬´¬ª    ,      <b> </b> ). <br><br>  ,    ,   <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgangspixel,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie in gezeigt </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten. W√§hrend der Ausf√ºhrung des Algorithmus sind wir nur an drei Pixeln vor Ihnen interessiert, d. H. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1 dargestellt</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Wir werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als das </font><font style="vertical-align: inherit;">Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ihnen bezeichnen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel links von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel rechts von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie beim Square-Trace-Algorithmus ist das Wichtigste beim Pavlidis-Algorithmus der ‚ÄûOrientierungssinn‚Äú. Drehungen nach links und rechts beziehen sich auf die aktuelle Position. Dies h√§ngt davon ab, wie Sie das aktuelle Pixel eingegeben haben. Um die richtigen Bewegungen auszuf√ºhren, ist es daher wichtig, Ihre aktuelle Ausrichtung im Auge zu behalten. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabh√§ngig davon, wie Sie sich befinden, werden die Pixel P1, P2 und P3 wie oben beschrieben bestimmt.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit Hilfe </font><font style="vertical-align: inherit;">dieser Informationen sind wir bereit , um </font><font style="vertical-align: inherit;">den Algorithmus zu erkl√§ren ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Mal , </font><font style="vertical-align: inherit;">wenn Sie auf dem aktuellen Randpixel stehen (das ist </font><font style="vertical-align: inherit;">die erste </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anf√§ngliche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel), wie folgt vorgehen: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √ºberpr√ºfen Sie </font><font style="vertical-align: inherit;">die Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das aktuelle Grenzpixel und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewegen Sie sich einen Schritt vorw√§rts und machen Sie dann einen Schritt nach links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um bei P1 zu sein (die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihenfolge der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegungen ist sehr wichtig). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figur 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten veranschaulicht diesen Fall. </font><font style="vertical-align: inherit;">Der Weg zu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist blau dargestellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und nur wenn P1 wei√ü ist, √ºberpr√ºfen wir P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 zum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuellen Grenzpixel und gehen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Schritt vorw√§rts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 zu sein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Fall ist in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dargestellt. </font><font style="vertical-align: inherit;">Der Pfad, dem Sie auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folgen m√ºssen, </font><font style="vertical-align: inherit;">wird blau angezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wenn sowohl P1 als auch P2 wei√ü sind, √ºberpr√ºfen Sie P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 als</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuelles Randpixel und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewegen Sie sich einen Schritt nach rechts und dann einen Schritt nach links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie in Abbildung 4 unten gezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drei einfache Regeln f√ºr drei einfache F√§lle. Wie Sie sehen k√∂nnen, ist es wichtig, bei Kurvenfahrten die Richtung im Auge zu behalten, da alle Bewegungen relativ zur aktuellen Ausrichtung ausgef√ºhrt werden. Aber anscheinend haben wir etwas vergessen? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn alle drei Pixel vor uns wei√ü sind?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann drehen wir uns (stehen am aktuellen Grenzpixel) um 90 Grad im Uhrzeigersinn, um einen neuen Satz von drei Pixeln vor uns zu sehen. Dann machen wir die gleiche Pr√ºfung f√ºr diese neuen Pixel. Sie k√∂nnen immer noch die Frage bleibt: Was passiert , </font><font style="vertical-align: inherit;">wenn alle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drei Pixel werden wei√ü?! Dann drehen wir uns wieder um 90 Grad im Uhrzeigersinn und stehen am selben Pixel. Bevor Sie die gesamte Nachbarschaft von Moores Pixel √ºberpr√ºfen, k√∂nnen Sie dreimal drehen (jedes Mal um 90 Grad im Uhrzeigersinn).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dreimal drehen, ohne jemals schwarze Pixel zu finden, bedeutet dies, dass wir auf einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isolierten Pixel stehen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das mit keinem anderen schwarzen Pixel verbunden ist. Aus diesem Grund k√∂nnen Sie mit dem Algorithmus dreimal drehen und dann die Ausf√ºhrung abschlie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Aspekt: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann schlie√üt der Algorithmus die Ausf√ºhrung ab?</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Algorithmus endet in zwei F√§llen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) wie oben erw√§hnt. Mit dem Algorithmus k√∂nnen Sie dreimal drehen (jedes Mal um 90 Grad im Uhrzeigersinn), nachdem die Ausf√ºhrung abgeschlossen und das Pixel als isoliert deklariert wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Wenn das aktuelle Grenzpixel das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel ist,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schlie√üt der Algorithmus die Ausf√ºhrung ab, indem er ‚Äûdeklariert‚Äú, dass er den Musterumriss erkannt hat.</font></font><br><br><h4>  Algorithmus </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende ist eine formale Beschreibung des Pavlidis-Algorithmus: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabe: Quadratische </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tessellation </font></font></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die eine verbundene Komponente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarzen Zellen enth√§lt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabe: Zeile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzpixeln, d.h. </font><font style="vertical-align: inherit;">Kontur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitionen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bezeichne mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p das</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuelle Grenzpixel, d.h. </font><font style="vertical-align: inherit;">das Pixel, auf dem wir stehen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie folgt: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(siehe auch Abbildung 1 oben)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel vor Ihnen, das an das Pixel angrenzt, auf dem Sie stehen, d. H. </font><font style="vertical-align: inherit;">mit Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> ‚Äî  ,   <b>P2</b> . </li><li> <b>P3</b> ‚Äî  ,   <b>P2</b> . </li><li>  <b>¬´¬ª</b>            . </li></ul><br>  Starten Sie <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beenden Sie das Programm und deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p als </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isoliertes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sonst </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um 90 Grad im Uhrzeigersinn drehen und dabei auf das aktuelle Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p stehen</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Ende der Wiederholungsschleife)</font></font></li></ul><br>  Das Ende <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende ist eine animierte Demonstration, wie der Pavlidis-Algorithmus die Kontur eines bestimmten Musters erkennt. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass wir in Pixeln gehen; </font><font style="vertical-align: inherit;">Beachten Sie, wie sich die Ausrichtung √§ndert, wenn Sie nach links oder rechts drehen. </font><font style="vertical-align: inherit;">Um den Algorithmus so detailliert wie m√∂glich zu erkl√§ren, haben wir alle m√∂glichen F√§lle aufgenommen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Analyse </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie der Meinung sind, dass der Pavlidis-Algorithmus ideal zum Erkennen von Musterkonturen ist, sollten Sie Ihre Meinung √§ndern ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Algorithmus ist wirklich etwas komplizierter als beispielsweise die Verfolgung der Umgebung von Moore, in der es keine Sonderf√§lle gibt, die eine separate Verarbeitung erfordern, aber er kann die Konturen eines gro√üen nicht bestimmen Eine Familie von Mustern mit einer bestimmten Art von Konnektivit√§t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus funktioniert sehr gut bei 4-verbundenen Mustern. Das Problem tritt auf, wenn einige 8-verbundene Muster verfolgt werden, die nicht 4-verbunden sind. Das Folgende ist eine animierte Demonstration, wie der Pavlidis-Algorithmus den korrekten Umriss eines 8-verbundenen Musters (kein 4-verbundenes) nicht erkennt - er √ºberspringt den gr√∂√üten Teil der Grenze.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei einfache M√∂glichkeiten, einen Algorithmus zu √§ndern, um seine Leistung erheblich zu verbessern. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Ersetzen Sie das Stoppkriterium</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstatt den Algorithmus zu vervollst√§ndigen, wenn er das Startpixel ein zweites Mal besucht, k√∂nnen Sie ihn beenden, wenn er das Startpixel ein drittes oder sogar viertes Mal besucht. Dies verbessert die Gesamtleistung des Algorithmus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODER </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Gehen Sie zur Quelle des Problems, n√§mlich bevor Sie das Startpixel ausw√§hlen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt eine wichtige Einschr√§nkung hinsichtlich der Richtung, in der die Eingabe in das Startpixel durchgef√ºhrt wird. Im Wesentlichen m√ºssen Sie das Startpixel eingeben, damit das Pixel links von Ihnen wei√ü ist, wenn Sie darauf stehen. Der Grund f√ºr die Einf√ºhrung dieser Einschr√§nkung ist folgender: Da wir immer die drei Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns in betrachten</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer bestimmten Reihenfolge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºberspringen wir in einigen Mustern das Grenzpixel, das direkt links vom Anfangspixel liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die Gefahr, dass nicht nur das linke Nachbarpixel im Anfangspixel fehlt, sondern auch das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel direkt darunter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (wie in der Analyse gezeigt). Zus√§tzlich wird in einigen Mustern ein Pixel √ºbersprungen, das dem Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten entspricht. Daher nehmen wir an, dass das Startpixel in einer solchen Richtung getroffen werden muss, dass die Pixel, die den </font><font style="vertical-align: inherit;">in </font><b><i><font style="vertical-align: inherit;">5</font></i></b><font style="vertical-align: inherit;"> unten </font><font style="vertical-align: inherit;">gezeigten </font><font style="vertical-align: inherit;">Pixeln </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R entsprechen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">wei√ü sind.</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall werden Muster wie das in der Demonstration gezeigte korrekt erkannt und die Wirksamkeit des Pavlidis-Algorithmus wird erheblich verbessert. </font><font style="vertical-align: inherit;">Andererseits kann es schwierig sein, ein Anfangspixel zu finden, das diese Anforderungen erf√ºllt, und in vielen F√§llen ist es unm√∂glich, ein solches Pixel zu finden. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie eine alternative Methode zur Verbesserung des Pavlidis-Algorithmus verwenden, n√§mlich die Fertigstellung des Algorithmus nach dem dritten Besuch des Startpunkts.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467611/">https://habr.com/ru/post/de467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467599/index.html">3D-Grafik-Rendering mit OpenGL</a></li>
<li><a href="../de467605/index.html">Alles was Sie brauchen ist URL</a></li>
<li><a href="../de467607/index.html">Gest√§ndnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verr√ºckt wird</a></li>
<li><a href="../de467617/index.html">Kaspresso: das Autotest-Framework, auf das Sie gewartet haben</a></li>
<li><a href="../de467619/index.html">Aquafor Kr√ºge sind ein gutes Beispiel daf√ºr, wie Filter f√ºr die Wasseraufbereitung nicht ausgelegt werden k√∂nnen</a></li>
<li><a href="../de467621/index.html">Elasticsearch Moskau Treffen in Ozon</a></li>
<li><a href="../de467623/index.html">Native reagieren: Erstellen eines animierten Eingabefelds mithilfe der animierten API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>