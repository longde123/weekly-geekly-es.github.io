<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍠 🖊️ ✋🏼 Algorithmen zur Erkennung von Bildumrissen 🗯️ 🚍 😼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel stellt die vier häufigsten Algorithmen zur Schleifenerkennung vor. 

 Die ersten beiden, nämlich der Algorithmus zum Verfolgen von Quadrat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmen zur Erkennung von Bildumrissen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  Der Artikel stellt die vier häufigsten Algorithmen zur Schleifenerkennung vor. <br><br>  Die ersten beiden, nämlich der Algorithmus zum Verfolgen von Quadraten und Verfolgen der Umgebung von Moore, sind einfach zu implementieren und werden daher häufig zur Bestimmung der Kontur eines bestimmten Musters verwendet.  Leider weisen beide Algorithmen mehrere Schwächen auf, die <b>es</b> aufgrund ihrer besonderen Art der Nachbarschaft <b>unmöglich machen,</b> die Kontur einer großen Klasse von Mustern <b>zu</b> erkennen. <br><br>  Diese Algorithmen ignorieren alle <b><i>„Löcher“</i></b> im Muster.  Wenn wir beispielsweise ein Muster ähnlich dem in <b><i>Abbildung 1</i></b> gezeigten haben, ist die von den Algorithmen erkannte Schaltung ähnlich der in <b><i>Abbildung 2</i></b> gezeigten (der Umriss wird durch blaue Pixel angezeigt).  In einigen Anwendungsbereichen ist dies durchaus akzeptabel, in anderen Bereichen, beispielsweise bei der Zeichenerkennung, ist jedoch die Erkennung der internen Teile eines Musters erforderlich, um alle Räume zu finden, die ein bestimmtes Zeichen unterscheiden.  ( <b><i>Abbildung 3</i></b> zeigt den „vollständigen“ Umriss des Musters.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="Bild"></div><br><br>  Um eine vollständige Kontur zu erhalten, ist es daher erforderlich, zuerst den <b><i>"Lochsuch"</i></b> -Algorithmus zu verwenden, der die Löcher in einem gegebenen Muster bestimmt, und dann den Konturerkennungsalgorithmus auf jedes Loch anzuwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="Bild"></div><a name="habracut"></a><br><h2>  Was ist Konnektivität? </h2><br>  In digitalen Bildern mit Binärwerten kann ein Pixel einen der folgenden Werte haben: 1 - wenn es Teil des Musters ist, oder 0 - wenn es Teil des Hintergrunds ist, d.h.  keine Abstufung von Grau.  (Wir gehen davon aus, dass Pixel mit einem Wert von 1 schwarz und Pixel mit einem Wert von 0 weiß sind.) <br><br>  Um <b><i>Objekte</i></b> in einem digitalen Muster zu identifizieren, müssen wir Gruppen von schwarzen Pixeln finden, die miteinander „verbunden“ sind.  Mit anderen Worten, die <b><i>Objekte</i></b> in einem gegebenen digitalen Muster sind die <b><i>verbundenen Komponenten</i></b> dieses Musters. <br><br>  Im allgemeinen Fall ist eine <b><i>verbundene Komponente</i></b> ein Satz schwarzer Pixel <b>P</b> , so dass für jedes Pixelpaar <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle 2 Pixel <b><i>in der Sequenz nebeneinander</i></b> sind „Nachbarn“. <br><br>  Eine wichtige Frage stellt sich: <b><i>Wann können wir sagen, dass 2 Pixel „Nachbarn“ sind?</i></b>  Da wir quadratische Pixel verwenden, ist die Antwort auf die vorherige Frage aus folgendem Grund nicht trivial: Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quadratischen Tessellation haben</a> Pixel eine gemeinsame Kante oder einen gemeinsamen Scheitelpunkt oder nichts gemeinsam.  Jedes Pixel hat 8 Pixel gemeinsam;  solche Pixel bilden die "Moore-Nachbarschaft" dieses Pixels.  Sollten wir "Nachbar" -Pixel betrachten, die nur einen gemeinsamen Scheitelpunkt haben?  Oder müssen zwei Pixel eine gemeinsame Kante haben, um als „Nachbarn“ betrachtet zu werden? <br><br>  Es gibt also zwei Arten von Konnektivität: 4-Verbundenheit und 8-Verbundenheit. <br><br><h4>  4-Verbindung </h4><br>  Wann können wir sagen, dass ein bestimmter Satz schwarzer Pixel <b><i>4-fach verbunden ist?</i></b>  Zunächst müssen Sie das Konzept eines <b><i>4-Nachbarn</i></b> (auch als <b><i>direkter Nachbar bezeichnet</i></b> ) definieren: <br><br>  <b>4-Nachbarn-Definition</b> : Ein Pixel <b>Q</b> ist ein <b><i>4-Nachbarn eines</i></b> gegebenen Pixels <b>P,</b> wenn <b>Q</b> und <b>P</b> eine gemeinsame Kante haben.  Die 4 Nachbarn des Pixels <b>P</b> (bezeichnet als <b>P2, P4, P6</b> und <b>P8</b> ) sind in <b><i>2</i></b> unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Definition einer 4-verbundenen Komponente</b> : Die Menge der schwarzen Pixel <b>P</b> ist eine <b><i>4-verbundene Komponente,</i></b> wenn für jedes Paar von Pixeln <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle zwei Pixel, die <b><i>in der Sequenz</i></b> <b><i>benachbart</i></b> sind <b><i>,</i></b> sind <b><i>4 Nachbarn</i></b> <br><br><h4>  Beispiele für 4-verbundene Muster </h4><br>  Die folgenden Diagramme zeigen Beispiele für 4 verbundene Muster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8-Verbindung </h4><br>  Wann kann ich sagen, dass ein bestimmter Satz schwarzer Pixel mit <b><i>8 verbunden ist</i></b> ?  Zunächst müssen wir das Konzept eines <b><i>8-Nachbarn</i></b> (auch <b><i>indirekter Nachbar genannt</i></b> ) definieren: <br><br>  <b>8-Nachbarn-Definition</b> : Ein Pixel <b>Q</b> ist ein <b><i>8-Nachbarn</i></b> (oder nur ein <b><i>Nachbar</i></b> ) eines gegebenen Pixels <b>P,</b> wenn <b>Q</b> und <b>P</b> eine gemeinsame Kante oder einen gemeinsamen Scheitelpunkt haben.  Die 8 Nachbarn eines gegebenen Pixels <b>P</b> bilden die Moore-Nachbarschaft dieses Pixels. <br><br>  <b>Definition einer 8-verbundenen Komponente</b> : Die Menge der schwarzen Pixel <b>P</b> ist eine <b><i>8-verbundene Komponente</i></b> (oder nur eine <b><i>verbundene Komponente</i></b> ), wenn für jedes Paar von Pixeln <b>p <sub>i</sub></b> und <b>p <sub>j</sub></b> in <b>P</b> eine Folge von Pixeln <b><i>p <sub>i</sub> , ..., p <sub>j vorhanden ist,</sub></i></b> so dass :: <br><br>  a) alle Pixel in der Sequenz befinden sich in der Menge <b>P</b> , d.h.  sind schwarz und <br><br>  b) Alle zwei Pixel, die <b><i>in dieser Sequenz</i></b> <b><i>benachbart</i></b> sind <b><i>,</i></b> sind <b><i>8 Nachbarn</i></b> <br><br>  <b>Hinweis</b> : Alle 4-verbundenen Muster sind 8-verbunden, d. H.  4-verbundene Muster sind eine Teilmenge der vielen 8-verbundenen Muster.  Andererseits kann ein 8-verbundenes Muster nicht 4-verbunden sein. <br><br><h4>  Beispiel für ein 8-verknüpftes Muster </h4><br>  Das folgende Diagramm zeigt ein Muster, das 8-fach, aber nicht 4-fach verbunden ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Ein Beispiel für ein nicht mit 8 verbundenes Muster: </h4><br>  Das folgende Diagramm zeigt ein Beispiel eines Musters, das nicht mit 8 verbunden ist, d.h.  bestehend aus mehr als einer verbundenen Komponente (das Diagramm zeigt drei verbundene Komponenten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Square Trace-Algorithmus </h2><br><h4>  Idee </h4><br>  Die Idee hinter dem Square-Tracing-Algorithmus ist sehr einfach.  Dies kann auf die Tatsache zurückgeführt werden, dass der Algorithmus einer der ersten Versuche war, die Kontur eines binären Musters zu erfassen. <br><br>  Um zu verstehen, wie es funktioniert, braucht man ein wenig Fantasie ... <br><br>  Angenommen, wir haben ein digitales Muster, beispielsweise eine Gruppe schwarzer Pixel auf einem Hintergrund weißer Pixel, d.h.  auf dem Gitter;  Finde das schwarze Pixel und deklariere es als unser " <b>anfängliches</b> " Pixel.  (Das Finden des " <b>anfänglichen</b> " Pixels kann auf viele verschiedene Arten implementiert werden. Wir beginnen in der unteren linken Ecke des Rasters und scannen jede Pixelspalte von unten nach oben, von der linken Spalte nach rechts, bis wir auf ein schwarzes Pixel stoßen. Wir erklären es als " <b>initial</b> ". ".) <br><br>  Stellen Sie sich nun vor, Sie sind ein Marienkäfer, der auf dem Startpixel steht (siehe <b><i>Abbildung 1</i></b> unten).  Um den Umriss eines Musters zu erhalten, müssen Sie Folgendes tun: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Die schwarzen Pixel, die Sie eingekreist haben, bilden den Umriss des Musters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Ein wichtiger Aspekt des Square-Trace-Algorithmus ist der „Richtungssinn“.  Drehungen nach links und rechts werden relativ zum aktuellen Standort ausgeführt, was davon abhängt, wie Sie zum aktuellen Pixel gelangt sind.  Um die richtigen Bewegungen auszuführen, müssen Sie daher Ihre Richtung verfolgen. <br><br><h4>  Algorithmus </h4><br>  Das Folgende ist eine formale Beschreibung des Quadratverfolgungsalgorithmus: <br><br>  Eingabe: Quadratische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> <b>T</b> , die die verbundene Komponente <b>P der</b> schwarzen Zellen enthält. <br><br>  Ausgabe: Zeile <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> von Randpixeln, d.h.  Kontur. <br><br>  Starten Sie <br><br><ul><li>  Definieren Sie <b>B</b> als leere Menge. </li><li>  Scannen Sie die Zellen <b>T</b> von unten nach oben und von links nach rechts, bis ein schwarzes Pixel <b>s</b> von <b>P gefunden wird</b> . </li><li>  Fügen Sie <b>s</b> in <b>B ein.</b> </li><li>  Machen Sie das aktuelle Pixel <b>p zum</b> Anfangspixel <b>s</b> . </li><li>  Biegen Sie links ab, d.h.  Gehe zum benachbarten Pixel links von <b>p</b> . </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li><li>  Während <b>p</b> nicht gleich <b>s ist</b> , führen Sie aus <br><br>  Wenn das aktuelle Pixel <b>p</b> schwarz ist <br><ul><li>  füge <b>p</b> in <b>B ein</b> und drehe dich nach links (gehe zum benachbarten Pixel links von <b>p</b> ). </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li></ul><br>  sonst <br><ul><li>  Biegen Sie rechts ab (gehen Sie zum nächsten Pixel rechts von <b>p</b> ). </li><li>  Update <b>p</b> , d.h.  es wird das aktuelle Pixel. </li></ul><br>  Ende des "Bye" -Zyklus </li></ul><br>  Das Ende <br><br>  <b>Hinweis: Die</b> Konzepte "links" und "rechts" sollten nicht in Bezug auf die Seite oder den Leser berücksichtigt werden, sondern in Bezug auf die Richtung des Eintritts in das "aktuelle" Pixel während des Scannens. <br><br><h4>  Demonstration </h4><br>  Das Folgende ist eine animierte Demonstration, wie der Quadratverfolgungsalgorithmus den Umriss eines Musters erkennt.  Vergessen Sie nicht, dass sich der Marienkäfer in Pixel bewegt.  Beachten Sie, wie sich die Richtung ändert, wenn Sie nach links und rechts abbiegen.  Drehungen nach links und rechts werden relativ zur aktuellen Richtung in einem Pixel ausgeführt, d.h.  Marienkäfer Orientierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Analyse </h4><br>  Es stellt sich heraus, dass die Fähigkeiten des Square-Trace-Algorithmus sehr begrenzt sind.  Er ist nicht in der Lage, die Konturen einer großen Familie von Mustern zu erkennen, die in realen Anwendungen häufig auftreten. <br><br>  Dies ist hauptsächlich auf die Tatsache zurückzuführen, dass Links- und Rechtsdrehungen Pixel nicht berücksichtigen, die sich „entlang“ befinden <br>  Diagonalen “vom aktuellen Pixel. <br><br>  Schauen wir uns die verschiedenen Muster mit unterschiedlicher Konnektivität an und sehen, warum der Square-Trace-Algorithmus fehlschlägt.  Darüber hinaus werden wir Möglichkeiten untersuchen, um die Fähigkeiten des Algorithmus zu verbessern und ihn auch mit Mustern funktionieren zu lassen, die eine besondere Art von Konnektivität aufweisen. <br><br><h4>  Stoppkriterium </h4><br>  Eine der Schwächen des Algorithmus ist die Wahl eines Stoppkriteriums.  Mit anderen Worten, wann hört ein Algorithmus auf, ausgeführt zu werden? <br><br>  In der ursprünglichen Beschreibung des Quadratverfolgungsalgorithmus besteht die Abschlussbedingung darin, das <b>Anfangspixel</b> ein zweites Mal zu treffen.  Es stellt sich heraus, dass der Algorithmus, wenn er von einem solchen Kriterium abhängt, die Konturen einer großen Familie von Mustern nicht erkennen kann. <br><br>  Das Folgende ist eine animierte Demo, die erklärt, wie der Algorithmus aufgrund der Auswahl eines schlechten Stoppkriteriums die genaue Kontur des Musters nicht erkennen kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Wie Sie sehen können, kann die Verbesserung des Stoppkriteriums ein guter Anfang sein, um die Gesamtleistung des Algorithmus zu verbessern.  Es gibt zwei effektive Alternativen für ein vorhandenes Abschaltkriterium: <br><br>  a) Stoppen Sie nur, indem Sie das Startpixel <b><i>n-</i></b> mal besuchen, wobei n mindestens 2 ODER ist <br><br>  b) Halten Sie an, nachdem Sie das Startpixel ein zweites Mal getroffen haben, so wie wir es ursprünglich getroffen haben. <br><br>  Dieses Kriterium wurde von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jacob Eliosoff</a> vorgeschlagen, daher werden wir es das <b><i>Kriterium nennen, um Jacob aufzuhalten</i></b> . <br><br>  Das Ändern des Stoppkriteriums verbessert im Allgemeinen die Effektivität des Quadratverfolgungsalgorithmus, ermöglicht jedoch nicht die Überwindung anderer Schwächen, die es bei Mustern mit speziellen Konnektivitätstypen aufweist. <br><br>  Der Square Tracing-Algorithmus kann die Kontur einer Musterfamilie mit einer Konnektivität von 8 nicht erkennen, die KEINE Konnektivität von 4 aufweist. <br><br>  Das Folgende ist eine animierte Demonstration, wie der Square-Trace-Algorithmus (mit Jacobs Stoppkriterium) den korrekten Umriss eines Musters mit Konnektivität 8 ohne Konnektivität 4 nicht erkennt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Ist dieser Algorithmus völlig nutzlos? </h2><br>  Wenn Sie die obige Analyse lesen, denken Sie wahrscheinlich, dass der Square-Trace-Algorithmus die Umrisse der meisten Muster nicht erkennt.  Aber es stellt sich heraus.  dass es eine spezielle Familie von Mustern gibt, in denen der Pfad vom Quadratverfolgungsalgorithmus vollständig erkannt wird. <br><br>  Sei <b>P</b> die Menge schwarzer Pixel mit Konnektivität 4 im Raster.  Lassen Sie die weißen Pixel des Gitters, d.h.  Die Hintergrundpixel <b>W</b> haben auch eine Konnektivität von 4. Es stellt sich heraus, dass unter solchen Bedingungen des Musters und seines Hintergrunds bewiesen werden kann, dass der Quadratverfolgungsalgorithmus (mit dem Jacob-Stopp-Kriterium) die Bestimmung der Kontur immer erfolgreich handhabt. <br><br>  Unten ist der Beweis, dass in dem Fall, in dem sowohl das Muster als auch die Hintergrundpixel 4 verbunden sind, der Quadratverfolgungsalgorithmus die Kontur korrekt bestimmt, wenn das Jacob-Stopp-Kriterium verwendet wird. <br><br>  Beweis <br>  <b>Gegeben</b> : Das Muster <b>P ist</b> derart, dass alle Pixel des Musters (d. H. Schwarz) und die Hintergrundpixel (d. H. Weiß) W eine Konnektivität von 4 haben. <br><br>  <b>Erste Beobachtung</b> <br><br>  Da der Satz weißer Pixel W eine Konnektivität von 4 hat, bedeutet dies, dass das Muster keine „ <b><i>Löcher</i></b> “ enthalten kann (informell ausgedrückt bedeuten „ <b><i>Löcher</i></b> “ Gruppen weißer Pixel, die vollständig von schwarzen Pixeln des Musters umgeben sind). <br><br>  Das Vorhandensein eines „ <b><i>Lochs</i></b> “ im Muster führt zur Trennung der Gruppe weißer Pixel von den verbleibenden weißen Pixeln.  Viele weiße Pixel verlieren jedoch die Konnektivität 4. <br><br>  <i>Abbildung 2</i> und <b><i>Abbildung 3</i></b> unten zeigen zwei Arten von „ <b><i>Löchern</i></b> “, die in einem Muster mit Konnektivität 4 auftreten können: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Zweite Beobachtung</b> <br><br>  Zwei beliebige schwarze Pixel eines Musters MÜSSEN eine gemeinsame Seite haben. <br><br>  Angenommen, zwei schwarze Pixel haben nur einen gemeinsamen Scheitelpunkt.  Um die Eigenschaft der 4-Verbundenheit des Musters zu erfüllen, muss es einen Pfad geben, der diese beiden Pixel verbindet, so dass alle zwei benachbarten Pixel auf diesem Pfad eine Konnektivität von 4 haben. Dies ergibt jedoch ein Muster ähnlich dem in <b><i>Abbildung 3</i></b> .  Mit anderen Worten führt dies zu einer Trennung der weißen Pixel.  <b><i>Fig. 4</i></b> unten zeigt ein typisches Muster, das die Annahme erfüllt, dass die Pixel in dem Muster und im Hintergrund 4-fach verbunden sind, d.h.  haben keine " <b><i>Löcher</i></b> " und alle zwei schwarzen Pixel haben eine gemeinsame Seite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Es ist nützlich, solche Muster wie folgt darzustellen: <br><br>  Zuerst betrachten wir die Grenzpixel, d.h.  Umriss des Musters.  Wenn wir dann jedes Grenzpixel als 4 Kanten mit Einheitslänge betrachten, werden wir sehen, dass einige dieser Kanten mit benachbarten weißen Pixeln gemeinsam sind.  Wir werden solche Kanten <b><i>Grenzkanten nennen</i></b> . <br><br>  Solche Begrenzungskanten können als Kanten eines Polygons betrachtet werden.  Auf dem <b><i>Bild</i></b> <b><i><br></i></b>  <b><i>In 5</i></b> unten wird diese Idee am Beispiel eines Polygons demonstriert, das dem Muster aus <b><i>4</i></b> oben entspricht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Wenn wir alle möglichen „Konfigurationen“ von Grenzpixeln betrachten, die in solchen Mustern auftreten können, werden wir sehen, dass es zwei einfache Fälle gibt, die in <b><i>Abbildung 6</i></b> und <b><i>Abbildung 7</i></b> unten dargestellt sind. <br><br>  Die Grenzpixel können Vielfache dieser Fälle oder andere Anordnungen sein, d.h.  die Drehungen und Wendungen dieser beiden Fälle.  Grenzrippen sind blau als <b>E1, E2, E3</b> und <b>E4</b> markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Dritte Beobachtung</b> <br><br>  In den beiden oben genannten Fällen wird der Square-Trace-Algorithmus unabhängig von dem von uns gewählten Anfangspixel und in die Richtung, in die er <b>fällt</b> , niemals <b>"zurückgehen" (Backtrack)</b> , sondern niemals zweimal <b>durch die</b> <b>Grenzkante "gehen" (Backtrack).</b> nur wenn es den Rand kein zweites Mal verfolgt) und niemals die Grenzkante verfehlt.  Probieren Sie es aus! <br><br>  Hier müssen zwei Konzepte geklärt werden: <br><br>  a) Der Algorithmus <b>"geht zurück"</b> , wenn er vor dem Verfolgen des gesamten Randes zurückkehrt, um ein bereits besuchtes Pixel zu besuchen, und <br><br>  b) Für jede <b><i>Begrenzungsrippe</i></b> gibt es zwei Möglichkeiten, <b>„durch sie hindurchzugehen“</b> , nämlich „nach innen“ und „nach außen“ (wobei „nach innen“ die Bewegung des entsprechenden Polygons nach innen und „nach außen“ - nach außen des Polygons bedeutet). <br><br>  Wenn der Algorithmus außerdem "nach innen" durch eine der Grenzkanten geht, geht er "nach außen" durch die nächste Grenzkante, d. H.  Der Square-Trace-Algorithmus sollte nicht in der Lage sein, zwei aufeinanderfolgende Kanten auf dieselbe Weise zu durchlaufen. <br><br>  <b>Letzte Beobachtung</b> <br><br>  Jedes Muster hat eine <b>gerade Anzahl von</b> <b>Begrenzungskanten</b> . <br><br>  Wenn Sie sich das Polygon aus <b><i>Abbildung 5</i></b> ansehen, sehen Sie Folgendes: <br><br>  Wenn wir von dem im Diagramm markierten Scheitelpunkt <b>S ausgehen</b> und den Grenzkanten folgen möchten, bis wir wieder <b>S</b> erreichen, stellen wir fest, dass wir dabei eine gerade Anzahl von Grenzkanten überschreiten.  Wir können jede Grenzkante als „Schritt“ in eine separate Richtung betrachten.  Dann muss es für jeden „Schritt“ rechts einen entsprechenden „Schritt“ links geben, wenn wir in die Ausgangsposition zurückkehren möchten.  Gleiches gilt für vertikale „Stufen“.  Daher müssen die „Schritte“ entsprechende Paare haben, und dies erklärt, warum jedes dieser Muster eine gerade Anzahl von Grenzkanten aufweist. <br><br>  Wenn der Algorithmus zum Verfolgen von Quadraten ein zweites Mal durch die <b>anfängliche Grenzkante</b> (des anfänglichen Pixels) eintritt, wird er dies in <b>der gleichen</b> Richtung wie beim ersten Mal tun. <br><br>  Der Grund dafür ist, dass der Algorithmus zum zweiten Mal auf die gleiche Weise wie in die anfängliche Grenzkante durchläuft, da es zwei Möglichkeiten gibt, durch die Grenzkante zu gehen, und der Algorithmus sich abwechselnd nach innen und außen bewegt und es eine gerade Anzahl von Grenzkanten gibt erster. <br><br><h4>  Fazit </h4><br>  Im Fall eines 4-verbundenen Musters und Hintergrunds erkennt der Quadratverfolgungsalgorithmus den gesamten Rand, d.h.  Kontur, Muster und hört nach einer einzelnen Spur auf zu arbeiten, d.h.  es wird nicht erneut verfolgt, da es beim zweiten Erreichen der <b>anfänglichen Grenzkante</b> auf dieselbe Weise wie beim ersten Mal eingegeben wird.  Folglich bestimmt der Quadratverfolgungsalgorithmus mit dem Stoppkriterium von Jacob den Zähler eines Musters korrekt, vorausgesetzt, dass sowohl das Muster als auch der Hintergrund 4-fach verbunden sind. <br><br><h2>  Verfolgung der Umgebung von Moore </h2><br><h4>  Idee </h4><br>  Die Idee hinter der Moore-Neighbor-Verfolgung ist einfach;  Bevor wir es erklären, müssen wir ein wichtiges Konzept erklären: <b><i>die Moore-Nachbarschaft eines</i></b> Pixels. <br><br><h4>  Die Nachbarschaft von Moore </h4><br>  Die Moore-Nachbarschaft eines Pixels <b>P</b> ist ein Satz von 8 Pixeln mit einem gemeinsamen Scheitelpunkt oder einer gemeinsamen Kante mit diesem Pixel.  Solche Pixel, nämlich <b>P1, P2, P3, P4, P5, P6, P7 und P8</b> , sind in <b><i>Fig. 1 gezeigt</i></b> . <br><br>  Das Viertel Moore (auch <b><i>8-Nachbarn</i></b> oder <b><i>indirekte Nachbarn genannt</i></b> ) ist ein wichtiges Konzept, auf das in der Literatur häufig Bezug genommen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Jetzt sind wir bereit, uns mit der Idee vertraut zu machen, die der Spur der Umgebung von Moore zugrunde liegt. <br><br>  Es sei ein digitales Muster vorhanden, d.h.  eine Gruppe schwarzer Pixel auf einem Hintergrund weißer Pixel, d.h.  auf dem Gitter;  Finden Sie das schwarze Pixel und deklarieren Sie es zum " <b>anfänglichen</b> " Pixel.  (Es gibt verschiedene Möglichkeiten, das „ <b>anfängliche</b> “ Pixel zu finden, aber wir beginnen wie zuvor in der unteren linken Ecke und scannen alle Pixelspalten der Reihe nach, bis wir das erste schwarze Pixel finden, das wir als „ <b>initial</b> “ deklarieren.) <br><br>  Stellen Sie sich nun erneut vor, Sie sind ein Marienkäfer, der auf dem Startpixel steht (siehe <b><i>Abbildung 2</i></b> unten).  Ohne Verlust der Verallgemeinerung erkennen wir den Umriss, indem wir uns im Uhrzeigersinn um das Muster bewegen.  (Egal für welche Richtung wir uns entscheiden, die Hauptsache ist, sie ständig im Algorithmus zu verwenden). <br><br>  Die allgemeine Idee ist folgende: Jedes Mal, wenn wir zum schwarzen Pixel <b>P</b> gelangen, kehren wir zu dem weißen Pixel zurück, in dem wir zuvor standen.  Dann gehen <b>wir</b> um das Pixel <b>P</b> im Uhrzeigersinn herum und besuchen jedes Pixel in seiner Nähe von Moore, bis wir zum schwarzen Pixel gelangen.  Der Algorithmus wird beendet, wenn das Startpixel das Startpixel ein zweites Mal erreicht. <br><br>  Diese schwarzen Pixel, die der Algorithmus besucht hat, bilden den Umriss des Musters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algorithmus </h4><br>  Das Folgende ist eine formale Beschreibung des Moore-Nachbarschaftsverfolgungsalgorithmus: <br><br>  Eingabe: Quadratische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tessellation</a> <b>T,</b> die eine verbundene Komponente <b>P</b> schwarzer Zellen enthält. <br><br>  Ausgabe: Zeile <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) von</b> Grenzpixeln, d.h.  Kontur. <br><br>  Bezeichne mit <b>M (a)</b> die Moore-Nachbarschaft von Pixel <b>a</b> . <br><br>  Sei <b>p</b> das aktuelle Randpixel. <br><br>  Sei <b>c</b> das aktuell betrachtete Pixel, d.h.  <b>c</b> ist in <b>M (p)</b> . <br><br>  Starten Sie <br><br><ul><li>  Definieren Sie <b>B</b> als leere Menge. </li><li>  Scannen Sie die Zellen <b>T</b> von unten nach oben und von links nach rechts, bis wir ein schwarzes Pixel <b>s</b> von <b>P finden.</b> </li><li>  Fügen Sie <b>s</b> in <b>B ein.</b> </li><li>  Wir setzen den Punkt <b>s</b> als den aktuellen Grenzpunkt <b>p</b> , d.h.  <b>p = s</b> </li><li>  Gehen wir zurück, d.h.  Gehen wir weiter zu dem Pixel, von dem wir zu <b>s gekommen sind</b> . </li><li>  Sei <b>c das</b> nächste Pixel im Uhrzeigersinn in <b>M (p)</b> . </li><li>  Während <b>c</b> nicht gleich <b>s ist</b> , führen Sie aus <br><br><ul><li>  wenn <b>c</b> schwarz ist <br><ul><li>  Fügen Sie <b>c</b> in <b>B ein</b> </li><li>  wir setzen <b>p = c</b> </li><li>  gehe zurück (verschiebe das aktuelle Pixel <b>c</b> zu dem Pixel, von dem wir zu <b>p gekommen sind</b> ) </li></ul><br>  sonst <br><ul><li>  Bewegen Sie das aktuelle Pixel <b>c</b> in <b>M (p)</b> zum nächsten Pixel im Uhrzeigersinn. </li></ul><br>  Ende des Tschüss-Zyklus </li></ul></li></ul><br>  Das Ende <br><br><h4>  Demonstration </h4><br>  Das Folgende ist eine animierte Demonstration, wie Moores Nachbarschaftsspur die Musterkonturerkennung durchführt.  (Wir haben beschlossen, den Umriss im Uhrzeigersinn zu verfolgen.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Analyse </h4><br>  Die Hauptschwäche bei der Verfolgung der Umgebung von Moore liegt in der Wahl der Stoppkriterien. <br><br>  In der ursprünglichen Beschreibung des Algorithmus zum Verfolgen der Umgebung von Moore besteht das Stoppkriterium darin, das <b>Anfangspixel</b> ein zweites Mal zu treffen.  Ähnlich wie beim Quadratverfolgungsalgorithmus stellt sich heraus, dass die Verfolgung der Umgebung von Moore unter Verwendung dieses Kriteriums die Konturen einer großen Familie von Mustern nicht erkennen kann. <br><br>  Das Folgende ist eine animierte Demo, die erklärt, warum der Algorithmus aufgrund der Auswahl eines schlechten Stoppkriteriums den genauen Umriss des Musters nicht finden kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Wie Sie sehen können, kann die Verbesserung des Stoppkriteriums ein guter Anfang sein, um die Gesamtleistung der Ablaufverfolgung zu verbessern.  Es gibt zwei effektive Alternativen für das Abschaltkriterium, ähnlich dem Jacob-Abschaltkriterium. <br><br>  Die Verwendung des Jacob-Kriteriums verbessert die Effektivität der Verfolgung der Umgebung von Moore erheblich und macht es zum besten Algorithmus zur Bestimmung der Kontur eines Musters, unabhängig von seiner Konnektivität. <br><br>  Der Grund dafür liegt hauptsächlich darin, dass der Algorithmus die gesamte Moore-Nachbarschaft des Grenzpixels überprüft, um nach dem nächsten Grenzpixel zu suchen.  Im Gegensatz zum quadratischen Trace-Algorithmus, der sich nur nach links und rechts dreht und die Pixel "diagonal" verfehlt, kann die Nachbarschaftsspur von Moore immer die äußere Grenze einer verbundenen Komponente erkennen.  Der Grund ist folgender: Für jedes <b><i>8-verbundene</i></b> (oder einfach <b><i>verbundene</i></b> ) Muster liegt das <b>nächste</b> Randpixel in der Moore-Nachbarschaft des aktuellen Randpixels.  Da die Nachbarschaftsspur von Moore jedes der Pixel in der Nachbarschaft von Moore des aktuellen Grenzpixels überprüft, muss sie das nächste Grenzpixel erkennen. <br><br>  Wenn die Verfolgung der Nachbarschaft von Moore das erste Pixel ein zweites Mal auf dieselbe Weise wie beim ersten Mal erreicht, bedeutet dies, dass eine <b>vollständige</b> <b>Außenkontur des</b> Musters erkannt wurde, und wenn der Algorithmus nicht gestoppt wird, erkennt er erneut dieselbe Kontur. <br><br><h2>  Radialer Scan </h2><br>  Der Radial Sweep-Algorithmus ist ein Konturerkennungsalgorithmus, der in einigen Büchern diskutiert wird.  Trotz des komplexen Namens ist die zugrunde liegende Idee sehr einfach.  Tatsächlich stellt sich heraus, dass der Radial-Sweep-Algorithmus <b>mit der</b> Spur von Moores Umgebung <b>identisch ist</b> .  Man könnte fragen: "Warum erwähnen wir ihn überhaupt?" <br><br>  Wenn Sie die Umgebung von Moore verfolgen, suchen Sie in der Nähe von Moore nach dem aktuellen Grenzpixel in einer bestimmten Richtung (wir haben die Richtung im Uhrzeigersinn gewählt), bis ein schwarzes Pixel gefunden wird.  Sie deklariert dieses Pixel dann als aktuelles Grenzpixel und fährt fort. <br><br>  Der Radial-Scan-Algorithmus macht dasselbe.  Andererseits bietet es eine interessante Möglichkeit, das nächste schwarze Pixel in der Moore-Nachbarschaft eines bestimmten Grenzpixels zu finden. <br><br>  Die Methode basiert auf der folgenden Idee: <br><br>  Jedes Mal, wenn wir ein neues Grenzpixel finden, machen Sie es zum aktuellen Pixel <b>P</b> und zeichnen Sie <b>ein imaginäres Liniensegment</b> , das <b>P</b> mit dem <b>vorherigen</b> Grenzpixel verbindet.  Dann <b>drehen</b> wir <b>das</b> Segment relativ zu <b>P</b> im Uhrzeigersinn, bis es auf ein schwarzes Pixel in der Moore-Nachbarschaft von Pixel <b>P</b> stößt.  Die Drehung der Linie ist identisch mit der Überprüfung jedes Pixels in der Nähe von Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben eine animierte Demonstration erstellt, wie der Radial-Scan-Algorithmus funktioniert und wie es aussieht, als würde man die Umgebung von Moore nachzeichnen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wann stoppt der Radial-Sweep-Algorithmus? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns das Verhalten des Algorithmus anhand der folgenden Stoppkriterien erklären ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stoppkriterium 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie den Radial-Scan-Algorithmus abgeschlossen, wenn er das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Pixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein zweites Mal besucht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten finden Sie eine animierte Demo, aus der hervorgeht, warum das Unterbrechungskriterium korrekt geändert wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erwähnenswert, dass bei Verwendung dieses Stoppkriteriums in beiden Algorithmen die Wirksamkeit des Radial-Scan-Algorithmus mit der Verfolgung der Umgebung von Moore identisch ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Square-Trace-Algorithmus und im Moore-Nachbarschafts-Trace haben wir festgestellt, dass die Verwendung des Jacob-Stop-Kriteriums die Leistung beider Algorithmen erheblich verbessert. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jacob Stop - </font><font style="vertical-align: inherit;">Kriterium</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfordert , </font><font style="vertical-align: inherit;">dass die Ausführung des </font><font style="vertical-align: inherit;">Algorithmus angehalten , </font><font style="vertical-align: inherit;">wenn Besuch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum zweiten Mal in der gleichen Richtung wie die erste Zeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider können wir das Jacob-Stop-Kriterium nicht im Radial-Sweep-Algorithmus verwenden. Der Grund ist, dass der Radial-Scan-Algorithmus das Konzept nicht definiert</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die "Richtung", in der es auf das Grenzpixel trifft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit anderen Worten, es ist nicht klar, in welche „Richtung“ der Algorithmus in das Grenzpixel gefallen ist (und seine Definition ist nicht trivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher müssen wir ein anderes Stoppkriterium vorschlagen, das nicht von der Richtung abhängt, in der ein bestimmtes Pixel getroffen wird, wodurch die Effektivität des Radial-Scan-Algorithmus verbessert werden kann ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stoppkriterium 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, jedes Mal, wenn der Algorithmus ein neues Grenzpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erkennt </font><font style="vertical-align: inherit;">, wird es in eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzpixeln </font><font style="vertical-align: inherit;">eingefügt </font><font style="vertical-align: inherit;">: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; und als aktuelles Randpixel deklariert. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 betrachten</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anfängliche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel). Dies bedeutet, dass wir das vorherige Randpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes aktuellen Randpixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i kennen</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Für das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 angenommen</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein imaginäres Pixel, das keinem der Pixel auf dem Gitter entspricht, das dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Reihe der </font><font style="vertical-align: inherit;">Grenzpixel zugewandt ist </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angesichts der obigen Annahmen können wir die Abbruchkriterien bestimmen , </font><font style="vertical-align: inherit;">wie folgt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausführung des </font><font style="vertical-align: inherit;">Algorithmus wird </font><font style="vertical-align: inherit;">beendet , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) der aktuelle Grenzpixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuvor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als ein Pixel erfüllt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (wobei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in der Reihe der Randpixel, und </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit anderen Worten, der Algorithmus beendet die Ausführung, wenn er das Grenzpixel P in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekunde besucht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal, wenn das Grenzpixel vor P (in der Reihe der Grenzpixel) zum zweiten Mal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dasselbe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel ist, das vor P war, als P zum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal besucht wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Bedingung des Stoppkriteriums erfüllt ist und der Algorithmus nicht heruntergefahren wird, erkennt der Radial-Scan-Algorithmus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die gleiche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenze ein zweites Mal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Leistung des Radial-Sweep-Algorithmus mit diesem Stoppkriterium ähnelt der Leistung der Verfolgung der Moore-Nachbarschaft mit dem Jacob-Stoppkriterium.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theo Pavlidis Algorithmus </font></font></h2><br><h4>  Idee </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Algorithmus ist einer der neuesten von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorgeschlagenen Algorithmen zur Schleifenerkennung </font><font style="vertical-align: inherit;">. Er zitierte es in seinem 1982 erschienenen Buch </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmen für Grafik und Bildverarbeitung</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Kapitel 7, Abschnitt 5). Es ist nicht so einfach wie der Algorithmus zum Verfolgen von Quadraten oder der Umgebung von Moore, aber es ist nicht so kompliziert (dies ist typisch für die meisten Kantenerkennungsalgorithmen). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diesen Algorithmus nicht auf die gleiche Weise erklären, wie es in seinem Buch getan wurde. Unser Ansatz ist leichter zu verstehen und vermittelt eine Vorstellung von der allgemeinen Idee, die dem Algorithmus zugrunde liegt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Verlust der Verallgemeinerung haben wir uns entschlossen, die Schleife im Uhrzeigersinn zu durchlaufen, um der Reihenfolge aller anderen im Artikel vorgestellten Algorithmen zu entsprechen. Auf der anderen Seite wählte Pavlidis die Richtung gegen den Uhrzeigersinn. Dies hat keinen Einfluss auf die Leistung des Algorithmus. Der einzige Unterschied ist die relative Richtung der Bewegungen, die wir ausführen, wenn wir die Kontur umgehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommen wir nun zur Idee ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir an, wir haben ein digitales Muster, d. H. eine Gruppe schwarzer Pixel auf einem Hintergrund weißer Pixel, d.h. auf dem Gitter; Finden Sie das schwarze Pixel und deklarieren Sie es zum " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anfänglichen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " Pixel. Sie können </font><font style="vertical-align: inherit;">auf verschiedene Arten </font><font style="vertical-align: inherit;">nach dem " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " -Pixel </font><font style="vertical-align: inherit;">suchen </font><font style="vertical-align: inherit;">, beispielsweise wie oben beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font><b><font style="vertical-align: inherit;">Initiale</font></b><font style="vertical-align: inherit;"> zu finden</font></font><b><font style="vertical-align: inherit;"></font></b>     .     <b></b> ,   ,       : <br><br> <b>  ,       </b> <br><br>            <b></b>   :      ,     .  ,    <b></b>    ,       («»    ,      <b> </b> ). <br><br>  ,    ,   <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgangspixel,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie in gezeigt </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten. Während der Ausführung des Algorithmus sind wir nur an drei Pixeln vor Ihnen interessiert, d. H. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1 dargestellt</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Wir werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als das </font><font style="vertical-align: inherit;">Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ihnen bezeichnen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel links von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel rechts von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie beim Square-Trace-Algorithmus ist das Wichtigste beim Pavlidis-Algorithmus der „Orientierungssinn“. Drehungen nach links und rechts beziehen sich auf die aktuelle Position. Dies hängt davon ab, wie Sie das aktuelle Pixel eingegeben haben. Um die richtigen Bewegungen auszuführen, ist es daher wichtig, Ihre aktuelle Ausrichtung im Auge zu behalten. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabhängig davon, wie Sie sich befinden, werden die Pixel P1, P2 und P3 wie oben beschrieben bestimmt.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit Hilfe </font><font style="vertical-align: inherit;">dieser Informationen sind wir bereit , um </font><font style="vertical-align: inherit;">den Algorithmus zu erklären ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Mal , </font><font style="vertical-align: inherit;">wenn Sie auf dem aktuellen Randpixel stehen (das ist </font><font style="vertical-align: inherit;">die erste </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anfängliche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel), wie folgt vorgehen: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , überprüfen Sie </font><font style="vertical-align: inherit;">die Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das aktuelle Grenzpixel und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewegen Sie sich einen Schritt vorwärts und machen Sie dann einen Schritt nach links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um bei P1 zu sein (die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihenfolge der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegungen ist sehr wichtig). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figur 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten veranschaulicht diesen Fall. </font><font style="vertical-align: inherit;">Der Weg zu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist blau dargestellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und nur wenn P1 weiß ist, überprüfen wir P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 zum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuellen Grenzpixel und gehen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Schritt vorwärts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 zu sein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Fall ist in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dargestellt. </font><font style="vertical-align: inherit;">Der Pfad, dem Sie auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folgen müssen, </font><font style="vertical-align: inherit;">wird blau angezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wenn sowohl P1 als auch P2 weiß sind, überprüfen Sie P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 als</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuelles Randpixel und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewegen Sie sich einen Schritt nach rechts und dann einen Schritt nach links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie in Abbildung 4 unten gezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drei einfache Regeln für drei einfache Fälle. Wie Sie sehen können, ist es wichtig, bei Kurvenfahrten die Richtung im Auge zu behalten, da alle Bewegungen relativ zur aktuellen Ausrichtung ausgeführt werden. Aber anscheinend haben wir etwas vergessen? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn alle drei Pixel vor uns weiß sind?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann drehen wir uns (stehen am aktuellen Grenzpixel) um 90 Grad im Uhrzeigersinn, um einen neuen Satz von drei Pixeln vor uns zu sehen. Dann machen wir die gleiche Prüfung für diese neuen Pixel. Sie können immer noch die Frage bleibt: Was passiert , </font><font style="vertical-align: inherit;">wenn alle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drei Pixel werden weiß?! Dann drehen wir uns wieder um 90 Grad im Uhrzeigersinn und stehen am selben Pixel. Bevor Sie die gesamte Nachbarschaft von Moores Pixel überprüfen, können Sie dreimal drehen (jedes Mal um 90 Grad im Uhrzeigersinn).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dreimal drehen, ohne jemals schwarze Pixel zu finden, bedeutet dies, dass wir auf einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isolierten Pixel stehen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das mit keinem anderen schwarzen Pixel verbunden ist. Aus diesem Grund können Sie mit dem Algorithmus dreimal drehen und dann die Ausführung abschließen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Aspekt: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann schließt der Algorithmus die Ausführung ab?</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Algorithmus endet in zwei Fällen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) wie oben erwähnt. Mit dem Algorithmus können Sie dreimal drehen (jedes Mal um 90 Grad im Uhrzeigersinn), nachdem die Ausführung abgeschlossen und das Pixel als isoliert deklariert wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Wenn das aktuelle Grenzpixel das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangspixel ist,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schließt der Algorithmus die Ausführung ab, indem er „deklariert“, dass er den Musterumriss erkannt hat.</font></font><br><br><h4>  Algorithmus </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende ist eine formale Beschreibung des Pavlidis-Algorithmus: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabe: Quadratische </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tessellation </font></font></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die eine verbundene Komponente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarzen Zellen enthält. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabe: Zeile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzpixeln, d.h. </font><font style="vertical-align: inherit;">Kontur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitionen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bezeichne mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p das</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuelle Grenzpixel, d.h. </font><font style="vertical-align: inherit;">das Pixel, auf dem wir stehen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie folgt: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(siehe auch Abbildung 1 oben)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Pixel vor Ihnen, das an das Pixel angrenzt, auf dem Sie stehen, d. H. </font><font style="vertical-align: inherit;">mit Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> —  ,   <b>P2</b> . </li><li> <b>P3</b> —  ,   <b>P2</b> . </li><li>  <b>«»</b>            . </li></ul><br>  Starten Sie <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beenden Sie das Programm und deklarieren Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p als </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isoliertes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sonst </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um 90 Grad im Uhrzeigersinn drehen und dabei auf das aktuelle Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p stehen</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Ende der Wiederholungsschleife)</font></font></li></ul><br>  Das Ende <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende ist eine animierte Demonstration, wie der Pavlidis-Algorithmus die Kontur eines bestimmten Musters erkennt. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass wir in Pixeln gehen; </font><font style="vertical-align: inherit;">Beachten Sie, wie sich die Ausrichtung ändert, wenn Sie nach links oder rechts drehen. </font><font style="vertical-align: inherit;">Um den Algorithmus so detailliert wie möglich zu erklären, haben wir alle möglichen Fälle aufgenommen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Analyse </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie der Meinung sind, dass der Pavlidis-Algorithmus ideal zum Erkennen von Musterkonturen ist, sollten Sie Ihre Meinung ändern ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Algorithmus ist wirklich etwas komplizierter als beispielsweise die Verfolgung der Umgebung von Moore, in der es keine Sonderfälle gibt, die eine separate Verarbeitung erfordern, aber er kann die Konturen eines großen nicht bestimmen Eine Familie von Mustern mit einer bestimmten Art von Konnektivität. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus funktioniert sehr gut bei 4-verbundenen Mustern. Das Problem tritt auf, wenn einige 8-verbundene Muster verfolgt werden, die nicht 4-verbunden sind. Das Folgende ist eine animierte Demonstration, wie der Pavlidis-Algorithmus den korrekten Umriss eines 8-verbundenen Musters (kein 4-verbundenes) nicht erkennt - er überspringt den größten Teil der Grenze.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei einfache Möglichkeiten, einen Algorithmus zu ändern, um seine Leistung erheblich zu verbessern. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Ersetzen Sie das Stoppkriterium</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstatt den Algorithmus zu vervollständigen, wenn er das Startpixel ein zweites Mal besucht, können Sie ihn beenden, wenn er das Startpixel ein drittes oder sogar viertes Mal besucht. Dies verbessert die Gesamtleistung des Algorithmus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODER </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Gehen Sie zur Quelle des Problems, nämlich bevor Sie das Startpixel auswählen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt eine wichtige Einschränkung hinsichtlich der Richtung, in der die Eingabe in das Startpixel durchgeführt wird. Im Wesentlichen müssen Sie das Startpixel eingeben, damit das Pixel links von Ihnen weiß ist, wenn Sie darauf stehen. Der Grund für die Einführung dieser Einschränkung ist folgender: Da wir immer die drei Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uns in betrachten</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer bestimmten Reihenfolge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> überspringen wir in einigen Mustern das Grenzpixel, das direkt links vom Anfangspixel liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die Gefahr, dass nicht nur das linke Nachbarpixel im Anfangspixel fehlt, sondern auch das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel direkt darunter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (wie in der Analyse gezeigt). Zusätzlich wird in einigen Mustern ein Pixel übersprungen, das dem Pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unten entspricht. Daher nehmen wir an, dass das Startpixel in einer solchen Richtung getroffen werden muss, dass die Pixel, die den </font><font style="vertical-align: inherit;">in </font><b><i><font style="vertical-align: inherit;">5</font></i></b><font style="vertical-align: inherit;"> unten </font><font style="vertical-align: inherit;">gezeigten </font><font style="vertical-align: inherit;">Pixeln </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R entsprechen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">weiß sind.</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall werden Muster wie das in der Demonstration gezeigte korrekt erkannt und die Wirksamkeit des Pavlidis-Algorithmus wird erheblich verbessert. </font><font style="vertical-align: inherit;">Andererseits kann es schwierig sein, ein Anfangspixel zu finden, das diese Anforderungen erfüllt, und in vielen Fällen ist es unmöglich, ein solches Pixel zu finden. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie eine alternative Methode zur Verbesserung des Pavlidis-Algorithmus verwenden, nämlich die Fertigstellung des Algorithmus nach dem dritten Besuch des Startpunkts.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467611/">https://habr.com/ru/post/de467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467599/index.html">3D-Grafik-Rendering mit OpenGL</a></li>
<li><a href="../de467605/index.html">Alles was Sie brauchen ist URL</a></li>
<li><a href="../de467607/index.html">Geständnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verrückt wird</a></li>
<li><a href="../de467617/index.html">Kaspresso: das Autotest-Framework, auf das Sie gewartet haben</a></li>
<li><a href="../de467619/index.html">Aquafor Krüge sind ein gutes Beispiel dafür, wie Filter für die Wasseraufbereitung nicht ausgelegt werden können</a></li>
<li><a href="../de467621/index.html">Elasticsearch Moskau Treffen in Ozon</a></li>
<li><a href="../de467623/index.html">Native reagieren: Erstellen eines animierten Eingabefelds mithilfe der animierten API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>