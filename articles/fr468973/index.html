<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üòÉ ü§æüèø R√©seau de neurones pour classer les images satellites √† l'aide de Tensorflow en Python üë©üèª‚Äç‚öñÔ∏è üëàüèª ‚ôéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'une instruction √©tape par √©tape pour la classification des images multispectrales du satellite Landsat 5. Aujourd'hui, dans un certain nom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©seau de neurones pour classer les images satellites √† l'aide de Tensorflow en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/468973/"><img src="https://habrastorage.org/webt/uq/qc/uz/uqqcuz2dhxwps1cueikg6ceigja.jpeg"><br><br>  Il s'agit d'une instruction √©tape par √©tape pour la classification des images multispectrales du satellite Landsat 5. Aujourd'hui, dans un certain nombre de domaines, l'apprentissage profond domine comme un outil pour r√©soudre des probl√®mes complexes, y compris g√©ospatiaux.  J'esp√®re que vous connaissez les jeux de donn√©es satellitaires, en particulier Landsat 5 TM.  Si vous √™tes un peu familier avec les algorithmes d'apprentissage automatique, cela vous aidera √† apprendre rapidement ce manuel.  Et pour ceux qui ne comprennent pas, il suffira de savoir qu'en fait, le machine learning consiste √† √©tablir des relations entre plusieurs caract√©ristiques (un ensemble d'attributs X) d'un objet avec son autre propri√©t√© (valeur ou √©tiquette, la variable cible Y).  Nous alimentons le mod√®le avec de nombreux objets pour lesquels les caract√©ristiques et la valeur de l'indicateur / classe cible de l'objet (donn√©es √©tiquet√©es) sont connues et le formons afin qu'il puisse pr√©dire la valeur de la variable cible Y pour les nouvelles donn√©es (non marqu√©es). <br><a name="habracut"></a><br>  Quel est le principal probl√®me de l'imagerie satellite? <br><br>  Deux ou plusieurs classes d'objets (par exemple, b√¢timents, terrains vacants et puits de fondation) dans les images satellite peuvent avoir les m√™mes caract√©ristiques spectrales de la valeur, par cons√©quent, au cours des vingt derni√®res ann√©es, leur classification a √©t√© une t√¢che difficile. <br><br>  Pour cette raison, il est possible d'utiliser des mod√®les classiques d'apprentissage automatique avec et sans professeur, mais leur qualit√© sera loin d'√™tre id√©ale.  Ils ont toujours les m√™mes inconv√©nients.  Prenons un exemple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/16c/5b7/15b16c5b76906f81f27374daa8558806.jpg"><br><br>  Si vous utilisez une ligne verticale comme classificateur et la d√©placez le long de l'axe X, la classification des images de maisons ne sera pas facile.  Les donn√©es sont r√©parties de sorte qu'il est impossible de les s√©parer en classes en utilisant une seule ligne verticale (dans de tels cas, il est dit que "les objets de classes diff√©rentes ne sont pas lin√©airement s√©parables").  Mais cela ne signifie pas que les maisons ne peuvent pas du tout √™tre class√©es! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/ea7/7a0/cc4ea77a0f9f4713ea6a49b7885d31c2.gif"><br><br>  Utilisons la ligne rouge pour s√©parer les deux classes.  Dans ce cas, le classificateur a identifi√© la plupart des maisons, mais une maison n'a pas √©t√© affect√©e √† sa classe et trois autres arbres ont √©t√© attribu√©s par erreur aux "maisons".  Afin de ne manquer aucune maison, vous pouvez utiliser le classificateur sous la forme d'une ligne bleue.  Ensuite, tout sera couvert √† la maison, c'est-√†-dire que nous disons que la m√©trique de rappel (pl√©nitude) est √©lev√©e.  Cependant, toutes les valeurs classifi√©es ne se sont pas av√©r√©es √™tre des maisons, c'est-√†-dire qu'en m√™me temps, nous avons obtenu une faible valeur de la m√©trique de pr√©cision.  Si nous utilisons la ligne verte, alors toutes les images class√©es comme maisons seront vraiment des maisons, c'est-√†-dire que le classificateur affichera une grande pr√©cision.  Dans ce cas, la pl√©nitude sera moindre, car les trois maisons ne seront pas comptabilis√©es.  Dans la plupart des cas, nous devons trouver un compromis entre pr√©cision et exhaustivit√©. <br><br>  Ce probl√®me des maisons et des arbres est similaire au probl√®me des b√¢timents, des terrains vagues et des fosses.  La priorit√© des mesures de classification de l'imagerie satellite peut varier selon la t√¢che.  Par exemple, si vous devez vous assurer que tous les territoires b√¢tis sont class√©s comme des b√¢timents sans exception, et que vous √™tes pr√™t √† accepter la pr√©sence de pixels d'autres classes avec des signatures similaires, qui seront √©galement class√©s comme des b√¢timents, alors vous aurez besoin d'un mod√®le avec une grande exhaustivit√©.  Et s'il est plus important pour vous de classer un b√¢timent, sans ajouter de pixels d'autres classes, et que vous √™tes pr√™t √† abandonner la classification des territoires mixtes, choisissez alors un classifieur de grande pr√©cision.  Dans le cas des maisons et des arbres, le mod√®le habituel utilisera la ligne rouge, en maintenant un √©quilibre entre pr√©cision et exhaustivit√©. <br><br><h2>  Donn√©es utilis√©es </h2><br>  Comme signes, nous utiliserons les valeurs de six plages (bande 2 - bande 7) de l'image de Landsat 5 TM, et essayer de pr√©dire la classe de d√©veloppement binaire.  Pour la formation et les tests, des donn√©es multispectrales (images et couche avec une classe de construction binaire) avec Landsat 5 pour 2011 pour Bangalore seront utilis√©es.  Et pour la pr√©diction seront utilis√©es les donn√©es multispectrales Landsat 5 obtenues en 2005 √† Hyderabad. <br>  Puisque nous utilisons des donn√©es balis√©es pour l'enseignement, cela s'appelle l'enseignement avec l'enseignant. <br><br><img src="https://habrastorage.org/webt/c4/nx/71/c4nx71fzbix6rhp4fb1-ofdupjm.jpeg"><br><br>  <i>Donn√©es d'entra√Ænement multispectrales et couche binaire correspondante avec d√©veloppement.</i> <br><br>  Pour cr√©er un r√©seau de neurones, nous utiliserons Python - la biblioth√®que Google Tensorflow.  Nous aurons √©galement besoin de ces biblioth√®ques: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>pyrsgis</i></a> - pour lire et √©crire GeoTIFF. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>scikit-learn</i></a> - pour le pr√©traitement des donn√©es et l'√©valuation de la pr√©cision. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>numpy</i></a> - pour les op√©rations de base avec des tableaux. <br></li></ol><br>  Et maintenant, sans plus tarder, √©crivons le code. <br><br>  Placez les trois fichiers dans un r√©pertoire, √©crivez le chemin et les noms des fichiers d'entr√©e dans le script, puis lisez les fichiers GeoTIFF. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> raster os.chdir(<span class="hljs-string"><span class="hljs-string">"E:\\yourDirectoryName"</span></span>) mxBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_raw.tif'</span></span> builtupBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_builtup.tif'</span></span> mxHyderabad = <span class="hljs-string"><span class="hljs-string">'l5_Hyderabad2011_raw.tif'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read the rasters as array ds1, featuresBangalore = raster.read(mxBangalore, bands='all') ds2, labelBangalore = raster.read(builtupBangalore, bands=1) ds3, featuresHyderabad = raster.read(mxHyderabad, bands='all')</span></span></code> </pre> <br>  Le module <code>raster</code> du package <code>pyrsgis</code> lit les donn√©es de g√©olocalisation GeoTIFF et les valeurs num√©riques (DN) sous forme de tableaux NumPy s√©par√©s.  Si vous √™tes int√©ress√© par les d√©tails, lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Maintenant, nous affichons la taille des donn√©es lues. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  R√©sultat: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1318</span></span>, <span class="hljs-number"><span class="hljs-number">1056</span></span></code> </pre> <br>  Comme vous pouvez le voir, les images de Bangalore ont le m√™me nombre de lignes et de colonnes que dans la couche binaire (correspondant au b√¢timent).  Le nombre de couches dans les images multispectrales √† Bangalore et Hyderabad co√Øncide √©galement.  Le mod√®le apprendra √† d√©cider quels pixels appartiennent au b√¢timent et lesquels ne le font pas, sur la base des valeurs correspondantes pour les 6 spectres.  Par cons√©quent, les images multispectrales doivent avoir le m√™me nombre de caract√©ristiques (plages) r√©pertori√©es dans le m√™me ordre. <br><br>  Maintenant, nous transformons les tableaux en deux dimensions, o√π chaque ligne repr√©sente un pixel distinct, car cela est n√©cessaire au fonctionnement de la plupart des algorithmes d'apprentissage automatique.  Nous le ferons en utilisant le module de <code>pyrsgis</code> paquet <code>pyrsgis</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/176/b91/d69176b91e9758291e1faae6c25486e5.jpg"><br>  <i>Sch√©ma de restructuration des donn√©es.</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis.convert <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> changeDimension featuresBangalore = changeDimension(featuresBangalore) labelBangalore = changeDimension (labelBangalore) featuresHyderabad = changeDimension(featuresHyderabad) nBands = featuresBangalore.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] labelBangalore = (labelBangalore == <span class="hljs-number"><span class="hljs-number">1</span></span>).astype(int) print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  R√©sultat: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Dans la septi√®me ligne, nous avons extrait tous les pixels avec une valeur de 1. Cela permet d'√©viter les probl√®mes avec les pixels sans information (NoData), qui ont souvent des valeurs extr√™mement √©lev√©es ou faibles. <br>  Nous allons maintenant diviser les donn√©es en √©chantillons d'apprentissage et de validation.  Cela est n√©cessaire pour que le mod√®le ne voit pas les donn√©es de test et fonctionne aussi bien avec les nouvelles informations.  Sinon, le mod√®le sera recycl√© et ne fonctionnera bien que sur les donn√©es de formation. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split xTrain, xTest, yTrain, yTest = train_test_split(featuresBangalore, labelBangalore, test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>) print(xTrain.shape) print(yTrain.shape) print(xTest.shape) print(yTest.shape)</code> </pre> <br>  R√©sultat: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">2519025</span></span>,) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>,) test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span></code> </pre> <br>  signifie que les donn√©es sont divis√©es en formation et validation dans un rapport de 60/40. <br>  De nombreux algorithmes d'apprentissage automatique, y compris les r√©seaux de neurones, ont besoin de donn√©es normalis√©es.  Cela signifie qu'ils doivent √™tre r√©partis dans une plage donn√©e (dans ce cas, de 0 √† 1).  Par cons√©quent, pour r√©pondre √† cette exigence, nous normalisons les sympt√¥mes.  Cela peut √™tre fait en extrayant la valeur minimale puis en la divisant par l'√©cart (la diff√©rence entre les valeurs maximale et minimale).  √âtant donn√© que l'ensemble de donn√©es Landsat est de huit bits, les valeurs minimale et maximale seront 0 et 255 (2 <sup>‚Å∏</sup> = 256 valeurs). <br><br>  Notez que pour la normalisation, il est toujours pr√©f√©rable de calculer les valeurs minimale et maximale en fonction des donn√©es.  Pour simplifier la t√¢che, nous respecterons la plage de huit bits par d√©faut. <br><br>  Une autre √©tape du traitement pr√©liminaire est la transformation de la matrice des signes de deux dimensions en trois dimensions, de sorte que le mod√®le per√ßoit chaque ligne comme un pixel s√©par√© (un objet d'apprentissage s√©par√©). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/d0f/aa8/965d0faa8e8c7b4787c10823cf038d20.jpg"><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Normalise the data xTrain = xTrain / 255.0 xTest = xTest / 255.0 featuresHyderabad = featuresHyderabad / 255.0 # Reshape the data xTrain = xTrain.reshape((xTrain.shape[0], 1, xTrain.shape[1])) xTest = xTest.reshape((xTest.shape[0], 1, xTest.shape[1])) featuresHyderabad = featuresHyderabad.reshape((featuresHyderabad.shape[0], 1, featuresHyderabad.shape[1])) # Print the shape of reshaped data print(xTrain.shape, xTest.shape, featuresHyderabad.shape)</span></span></code> </pre> <br>  R√©sultat: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br>  Tout est pr√™t, assemblons notre mod√®le avec des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">keras</a> .  Pour commencer, utilisons le mod√®le s√©quentiel, en ajoutant des couches les unes apr√®s les autres.  Nous aurons une couche d'entr√©e avec un nombre de n≈ìuds √©gal au nombre de plages ( <code>nBands</code> ) - dans notre cas il y en a 6. Nous utiliserons √©galement une couche cach√©e avec 14 n≈ìuds et la <code>ReLu</code> activation <code>ReLu</code> .  La derni√®re couche se compose de deux n≈ìuds pour d√©finir une classe de construction binaire avec la <code>softmax</code> activation <code>softmax</code> , qui convient pour afficher un r√©sultat cat√©goris√©.  En savoir plus sur les fonctions d'activation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-comment"><span class="hljs-comment"># Define the parameters of the model model = keras.Sequential([ keras.layers.Flatten(input_shape=(1, nBands)), keras.layers.Dense(14, activation='relu'), keras.layers.Dense(2, activation='softmax')]) # Define the accuracy metrics and parameters model.compile(optimizer="adam", loss="sparse_categorical_crossentropy", metrics=["accuracy"]) # Run the model model.fit(xTrain, yTrain, epochs=2)</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/9cd/5ec/d8a9cd5ec53c57d671d77b0c46bfb17e.png"><br>  <i>Architecture de r√©seau neuronal</i> <br><br>  Comme mentionn√© √† la ligne 10, nous sp√©cifions <code>adam</code> comme optimiseur de mod√®le (il y en a plusieurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> ).  Dans ce cas, nous utiliserons l'entropie crois√©e comme fonction de perte (fr. <code>categorical-sparse-crossentropy</code> entropie crois√©e <code>categorical-sparse-crossentropy</code> - plus d'informations √† ce sujet sont √©crites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Pour √©valuer la qualit√© du mod√®le, nous utiliserons la m√©trique de <code>accuracy</code> . <br><br>  Enfin, nous commencerons √† former notre mod√®le pour deux √©poques (ou it√©rations) sur <code>xTrain</code> et <code>yTrain</code> .  Cela prendra un certain temps, selon la taille des donn√©es et la puissance de traitement.  Voici ce que vous verrez apr√®s la compilation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/3fc/c47/dfa3fcc47572b2fd20c5252ba4da1e50.png"><br><br>  Pr√©disons les valeurs des donn√©es de validation que nous stockons s√©par√©ment et calculons diverses mesures de pr√©cision. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusion_matrix, precision_score, recall_score <span class="hljs-comment"><span class="hljs-comment"># Predict for test data yTestPredicted = model.predict(xTest) yTestPredicted = yTestPredicted[:,1] # Calculate and display the error metrics yTestPredicted = (yTestPredicted&gt;0.5).astype(int) cMatrix = confusion_matrix(yTest, yTestPredicted) pScore = precision_score(yTest, yTestPredicted) rScore = recall_score(yTest, yTestPredicted) print("Confusion matrix: for 14 nodes\n", cMatrix) print("\nP-Score: %.3f, R-Score: %.3f" % (pScore, rScore))</span></span></code> </pre> <br>  La fonction <code>softmax</code> g√©n√®re des colonnes s√©par√©es pour les valeurs de probabilit√© pour chaque classe.  Nous utilisons uniquement les valeurs de la premi√®re classe ("il y a un b√¢timent"), comme on peut le voir sur la sixi√®me ligne du code ci-dessus.  L'√©valuation du travail des mod√®les d'analyse g√©ospatiale n'est pas si simple, contrairement √† d'autres probl√®mes classiques d'apprentissage automatique.  Il sera injuste de s'appuyer sur une erreur totale g√©n√©ralis√©e.  La cl√© d'un mod√®le r√©ussi est la disposition spatiale.  Ainsi, la matrice de confusion, la pr√©cision et l'exhaustivit√© peuvent donner une id√©e plus correcte de la qualit√© du mod√®le. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/3d8/bf3/3993d8bf36a5f4165b60f39e36e5c566.jpg"><br>  <i>Ainsi, la console affiche la matrice d'erreur, la pr√©cision et l'exhaustivit√©.</i> <br><br>  Comme vous pouvez le voir dans la matrice de confusion, il existe des milliers de pixels li√©s aux b√¢timents, mais class√©s diff√©remment, et vice versa.  Cependant, leur part du volume total de donn√©es n'est pas trop importante.  La pr√©cision et l'exhaustivit√© des donn√©es d'essai ont d√©pass√© le seuil de 0,8. <br><br>  Vous pouvez passer plus de temps et effectuer plusieurs it√©rations pour trouver le nombre optimal de couches cach√©es, le nombre de n≈ìuds dans chaque couche cach√©e, ainsi que le nombre d'√©poques pour atteindre la pr√©cision souhait√©e.  Au besoin, des indices de t√©l√©d√©tection comme NDBI ou NDWI peuvent √™tre utilis√©s comme caract√©ristiques.  Lorsque vous atteignez la pr√©cision souhait√©e, utilisez le mod√®le pour pr√©dire le d√©veloppement en fonction des nouvelles donn√©es et exporter le r√©sultat vers GeoTIFF.  Pour de telles t√¢ches, vous pouvez utiliser un mod√®le similaire avec des modifications mineures. <br><br><pre> <code class="python hljs">predicted = model.predict(feature2005) predicted = predicted[:,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">#Export raster prediction = np.reshape(predicted, (ds.RasterYSize, ds.RasterXSize)) outFile = 'Hyderabad_2011_BuiltupNN_predicted.tif' raster.export(prediction, ds3, filename=outFile, dtype='float')</span></span></code> </pre> <br>  Veuillez noter que nous exportons GeoTIFF avec des valeurs de probabilit√© pr√©dites, et non avec leur version seuil binaris√©e.  Plus tard dans l'environnement SIG, nous pouvons d√©finir la valeur de seuil d'une couche de type float, comme indiqu√© dans la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/sk/ka/kz/skkakzxokrbkvrgulcvm0vkuwua.jpeg"><br>  <i>Couche b√¢tie d'Hyderabad pr√©vue par le mod√®le √† partir de donn√©es multispectrales.</i> <br><br>  La pr√©cision du mod√®le a d√©j√† √©t√© mesur√©e avec pr√©cision et rappel.  Vous pouvez √©galement effectuer des v√©rifications traditionnelles (par exemple, en utilisant le coefficient kappa) sur une nouvelle couche pr√©dite.  En plus des difficult√©s susmentionn√©es avec la classification des images satellite, d'autres limitations √©videntes incluent l'impossibilit√© de pr√©voir des images bas√©es sur des images prises √† diff√©rents moments de l'ann√©e et dans diff√©rentes r√©gions, car elles auront des signatures spectrales diff√©rentes. <br><br>  Le mod√®le d√©crit dans cet article a l'architecture la plus simple pour les r√©seaux de neurones.  De meilleurs r√©sultats peuvent √™tre obtenus avec des mod√®les plus complexes, y compris les r√©seaux de neurones convolutionnels.  Le principal avantage d'une telle classification est son √©volutivit√© (applicabilit√©) apr√®s la formation du mod√®le. <br><br>  Les donn√©es utilis√©es et tout le code sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468973/">https://habr.com/ru/post/fr468973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468961/index.html">Comment se d√©barrasser de la routine dans la vie pour 560 $? Ou comment vivre, pas vivre</a></li>
<li><a href="../fr468963/index.html">Sauvegarde, pi√®ce √† la demande des lecteurs: pr√©sentation d'UrBackup, BackupPC, AMANDA</a></li>
<li><a href="../fr468967/index.html">"Technologie" d'obtention d'√©quations de dynamique de TAU. Et pourquoi l‚Äôidentification du syst√®me est nul, et les r√®gles de la ¬´physique honn√™te¬ª</a></li>
<li><a href="../fr468969/index.html">Cr√©ez des utilisateurs Google √† partir de PowerShell via l'API</a></li>
<li><a href="../fr468971/index.html">√âcriture en Java pour Nintendo DS</a></li>
<li><a href="../fr468989/index.html">March√© de l'UEBA meurt - Longue vie √† l'UEBA</a></li>
<li><a href="../fr468991/index.html">Personnages de sprites modulaires et leur animation</a></li>
<li><a href="../fr468993/index.html">Oculus Quest se connecte √† un PC et voit les mains</a></li>
<li><a href="../fr468995/index.html">Politique d'ouverture: comment les utilisateurs influencent le projet</a></li>
<li><a href="../fr468997/index.html">Le mentorat - un incontournable ou un bon bonus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>