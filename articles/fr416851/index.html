<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèª üôãüèΩ üê® Hibernate - de quoi les didacticiels sont muets üò´ üë®‚Äçüë©‚Äçüë¶ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article ne couvrira pas les bases d'Hibernate (comment d√©finir une entit√© ou √©crire une requ√™te de crit√®res). Ici, je vais essayer de parler de po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hibernate - de quoi les didacticiels sont muets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Cet article ne couvrira pas les bases d'Hibernate (comment d√©finir une entit√© ou √©crire une requ√™te de crit√®res).  Ici, je vais essayer de parler de points plus int√©ressants qui sont vraiment utiles dans le travail.  Informations sur lesquelles je n'ai pas rencontr√© en un seul endroit. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="image"><br><a name="habracut"></a><br>  Je ferai une r√©servation tout de suite.  Tout ce qui suit est vrai pour Hibernate 5.2.  Des erreurs sont √©galement possibles du fait que j'ai mal compris quelque chose.  Si vous trouvez - √©crivez. <br><br><h2>  Probl√®mes de mappage d'un mod√®le d'objet dans un relationnel </h2><br>  Mais commen√ßons par les bases de l'ORM.  ORM - mapping objet-relationnel - en cons√©quence, nous avons des mod√®les relationnels et objet.  Et lors de l'affichage les uns des autres, il y a des probl√®mes que nous devons r√©soudre nous-m√™mes.  Prenons-les √† part. <br><br>  Pour illustrer cela, prenons l'exemple suivant: nous avons l'entit√© ¬´Utilisateur¬ª, qui peut √™tre un Jedi ou un avion d'attaque.  Les Jedi doivent avoir de la force et la sp√©cialisation des avions d'attaque.  Voici un diagramme de classes. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="image"><br><br><h3>  Probl√®me 1. H√©ritage et requ√™tes polymorphes. </h3><br>  Il existe un h√©ritage dans le mod√®le objet, mais pas dans le mod√®le relationnel.  En cons√©quence, c'est le premier probl√®me - comment mapper correctement l'h√©ritage au mod√®le relationnel. <br><br>  Hibernate propose 3 options pour afficher un tel mod√®le d'objet: <br><br><ol><li>  Tous les h√©ritiers sont dans le m√™me tableau: <br>  <b>@Inheritance (strat√©gie = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="image"><br><br>  Dans ce cas, les champs communs et les champs des h√©ritiers se trouvent dans une seule table.  En utilisant cette strat√©gie, nous √©vitons les jointures lors de la s√©lection des entit√©s.  Parmi les inconv√©nients, il convient de noter que, premi√®rement, nous ne pouvons pas d√©finir la restriction ¬´NOT NULL¬ª pour la colonne ¬´force¬ª dans le mod√®le relationnel, et deuxi√®mement, nous perdons la troisi√®me forme normale.  (une d√©pendance transitive d'attributs non cl√©s appara√Æt: force et disque). <br><br>  Soit dit en passant, y compris pour cette raison, il existe 2 fa√ßons de sp√©cifier une contrainte de champ non nulle - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">NotNull</a> est responsable de la validation;  @Column (nullable = true) - responsable de la contrainte non null dans la base de donn√©es. <br><br>  √Ä mon avis, c'est la meilleure fa√ßon de mapper un mod√®le objet sur un mod√®le relationnel. <br></li><li>  Les champs sp√©cifiques √† l'entit√© se trouvent dans une table distincte. <br><br>  <b>@Inheritance (strat√©gie = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="image"><br><br>  Dans ce cas, les champs communs sont stock√©s dans une table commune, et sp√©cifiques aux entit√©s enfants sont stock√©s dans des entit√©s distinctes.  En utilisant cette strat√©gie, nous obtenons un JOIN lors du choix d'une entit√©, mais maintenant nous enregistrons le troisi√®me formulaire normal, et nous pouvons √©galement sp√©cifier une contrainte NOT NULL dans la base de donn√©es. </li><li>  Chaque entit√© a sa propre table. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="image"><br><br>  Dans ce cas, nous n'avons pas de table commune.  En utilisant cette strat√©gie, nous utilisons UNION pour les requ√™tes polymorphes.  Nous rencontrons des probl√®mes avec les g√©n√©rateurs de cl√©s primaires et d'autres contraintes d'int√©grit√©.  Ce type de mappage d'h√©ritage est fortement d√©conseill√©. </li></ol><br>  Au cas o√π, je mentionnerai l'annotation - @MappedSuperclass.  Il est utilis√© lorsque vous souhaitez ¬´masquer¬ª des champs communs pour plusieurs entit√©s du mod√®le objet.  De plus, la classe annot√©e elle-m√™me n'est pas consid√©r√©e comme une entit√© distincte. <br><br><h3>  Probl√®me 2. Rapport de composition en POO </h3><br>  Revenant √† notre exemple, nous notons que dans le mod√®le objet, nous avons pris le profil utilisateur dans une entit√© distincte - Profil.  Mais dans le mod√®le relationnel, nous n'avons pas s√©lectionn√© de table distincte pour cela. <br><br>  L'attitude OneToOne est souvent une mauvaise pratique car  dans select, nous avons un JOIN injustifi√© (m√™me en sp√©cifiant fetchType = LAZY dans la plupart des cas, nous aurons JOIN - nous discuterons de ce probl√®me plus tard). <br><br>  Il existe des annotations @Embedable et @Embeded pour afficher une composition dans un tableau commun.  Le premier est plac√© au-dessus du champ et le second au-dessus de la classe.  Ils sont interchangeables. <br><br><h2>  Gestionnaire d'entit√©s </h2><br>  Chaque instance d'EntityManager (EM) d√©finit une session d'interaction avec la base de donn√©es.  Au sein d'une instance EM, il existe un cache de premier niveau.  Ici, je vais souligner les points importants suivants: <br><br><ol><li>  <b>Capture de la connexion √† la base de donn√©es</b> <br><br>  Ceci est juste un point int√©ressant.  Hibernate ne capture pas la connexion au moment de la r√©ception de l'EM, mais au premier acc√®s √† la base de donn√©es ou √† l'ouverture de la transaction (bien que ce probl√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">puisse √™tre r√©solu</a> ).  Ceci est fait afin de r√©duire le temps de connexion occup√©e.  Lors de la r√©ception d'EM-a, la pr√©sence d'une transaction JTA est v√©rifi√©e. </li><li>  <b>Les entit√©s persistantes ont toujours un identifiant</b> </li><li>  <b>Les entit√©s d√©crivant une ligne dans la base de donn√©es sont √©quivalentes par r√©f√©rence</b> <br>  Comme mentionn√© ci-dessus, EM a un cache de premier niveau, les objets y sont compar√©s par r√©f√©rence.  En cons√©quence, la question se pose - quels champs doivent √™tre utilis√©s pour remplacer √©gal et hashcode?  Consid√©rez les options suivantes: <br><br><ul><li>  Utilisez tous les champs.  Mauvaise id√©e  √©gaux peut affecter les champs LAZY.  Soit dit en passant, cela est √©galement vrai pour la m√©thode toString. </li><li>  Utilisez id uniquement.  Une id√©e normale, mais il y a aussi des nuances.  Puisque le plus souvent pour les nouvelles entit√©s, id met un g√©n√©rateur au moment de persister.  La situation suivante est possible: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Utilisez une cl√© m√©tier (grosso modo, des champs uniques et NON NULS).  Mais cette option n'est pas toujours pratique. <br><br>  Soit dit en passant, puisque nous parlons de NOT NULL et UNIQUE, il est parfois pratique de cr√©er un constructeur public avec des arguments NOT NULL, et le constructeur sans arguments est prot√©g√©. </li><li>  Ne remplacez pas √©gaux et hashcode du tout. </li></ul></li><li>  <b>Comment fonctionne le rin√ßage</b> <br>  Flush - ex√©cute les insert-s, update-s et delete-s accumul√©s dans la base de donn√©es.  Par d√©faut, le vidage est ex√©cut√© dans les cas: <br><br><ul><li>  Avant d'ex√©cuter la requ√™te (√† l'exception d'em.get), cela est n√©cessaire pour se conformer au principe ACID.  Par exemple: nous avons chang√© la date de naissance de l'avion d'attaque, puis nous avons voulu obtenir le nombre d'avions d'attaque adultes. <br><br>  Si nous parlons de CriteriaQuery ou JPQL, alors le vidage sera ex√©cut√© si la requ√™te affecte une table dont les entit√©s sont dans le cache du premier niveau. </li><li>  Lors de la validation d'une transaction; </li><li>  Parfois, lors de la persistance d'une nouvelle entit√© - dans le cas o√π nous ne pouvons obtenir son identifiant que par insertion. </li></ul><br>  Et maintenant un petit test.  Combien d'op√©rations UPDATE seront effectu√©es dans ce cas? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Une fonctionnalit√© d'hibernation int√©ressante est cach√©e sous l'op√©ration de vidage - elle essaie de r√©duire le temps n√©cessaire pour verrouiller les lignes dans la base de donn√©es. <br><br>  Notez √©galement qu'il existe diff√©rentes strat√©gies pour l'op√©ration de rin√ßage.  Par exemple, vous pouvez interdire la ¬´fusion¬ª des modifications apport√©es √† la base de donn√©es - elle est appel√©e MANUELLE (elle d√©sactive √©galement le m√©canisme de v√©rification incorrecte). <br></li><li>  <b>V√©rification sale</b> <br><br>  Dirty Checking est un m√©canisme ex√©cut√© lors d'une op√©ration de vidage.  Son but est de trouver des entit√©s qui ont chang√© et de les mettre √† jour.  Pour impl√©menter un tel m√©canisme, hibernate doit stocker la copie originale de l'objet (avec quoi l'objet r√©el sera compar√©).  Pour √™tre plus pr√©cis, hibernate stocke une copie des champs de l'objet, pas l'objet lui-m√™me. <br><br>  Il convient de noter que si le graphique des entit√©s est grand, l'op√©ration de v√©rification incorrecte peut √™tre co√ªteuse.  N'oubliez pas qu'hibernate stocke 2 copies d'entit√©s (grosso modo). <br>  Afin de "r√©duire le co√ªt" de ce processus, utilisez les fonctionnalit√©s suivantes: <br><br><ul><li>  em.detach / em.clear - d√©tache des entit√©s d'EntityManager </li><li>  FlushMode = MANUAL- utile dans les op√©rations de lecture </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Immuable</a> - √©vite √©galement les op√©rations de v√©rification sales </li></ul><br></li><li>  <b>Les transactions</b> <br><br>  Comme vous le savez, hibernate vous permet de mettre √† jour des entit√©s uniquement dans une transaction.  Les op√©rations de lecture offrent plus de libert√© - nous pouvons les ex√©cuter sans ouvrir explicitement une transaction.  Mais c'est pr√©cis√©ment la question: cela vaut-il la peine d'ouvrir une transaction explicitement pour les op√©rations de lecture? <br><br>  Je citerai quelques faits: <br><br><ul><li>  Toute instruction est ex√©cut√©e dans la base de donn√©es √† l'int√©rieur de la transaction.  M√™me si nous ne l'avons √©videmment pas ouvert.  (mode auto-commit). </li><li>  En r√®gle g√©n√©rale, nous ne sommes pas limit√©s √† une seule requ√™te dans la base de donn√©es.  Par exemple: pour obtenir les 10 premiers enregistrements, vous souhaiterez probablement renvoyer le nombre total d'enregistrements.  Et c'est presque toujours 2 demandes. </li><li>  Si nous parlons de donn√©es de printemps, les m√©thodes de r√©f√©rentiel sont transactionnelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par d√©faut</a> , tandis que les m√©thodes de lecture sont en lecture seule. </li><li>  L'annotation @Transactional spring (readOnly = true) affecte √©galement FlushMode, plus pr√©cis√©ment, Spring la met en statut MANUAL, ainsi la mise en veille prolong√©e n'effectuera pas de v√©rification de la salet√©. </li><li>  Des tests synth√©tiques avec une ou deux requ√™tes de base de donn√©es montreront que la validation automatique est plus rapide.  Mais en mode combat, ce n'est peut-√™tre pas le cas.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent article sur ce sujet</a> , + voir commentaires) </li></ul><br>  En un mot: il est de bonne pratique d'effectuer toute communication avec la base de donn√©es lors d'une transaction. <br></li></ol><br><h2>  G√©n√©rateurs </h2><br>  Des g√©n√©rateurs sont n√©cessaires pour d√©crire comment les cl√©s primaires de nos entit√©s recevront des valeurs.  Passons rapidement en revue les options: <br><br><ul><li>  <b>GenerationType.AUTO</b> - la s√©lection du g√©n√©rateur est bas√©e sur le dialecte.  Ce n'est pas la meilleure option, car la r√®gle ¬´explicite vaut mieux que l'implicite¬ª s'applique juste ici. </li><li>  <b>GenerationType.IDENTITY</b> est le moyen le plus simple de configurer un g√©n√©rateur.  Il s'appuie sur la colonne d'incr√©mentation automatique du tableau.  Par cons√©quent, pour obtenir id avec persist, nous devons faire une insertion.  C'est pourquoi il √©limine la possibilit√© de persistance diff√©r√©e et donc de batch. </li><li>  <b>GenerationType.SEQUENCE</b> est le cas le plus pratique lorsque nous obtenons id √† partir d'une s√©quence. </li><li>  <b>GenerationType.TABLE</b> - dans ce cas, hibernate √©mule une s√©quence via une table suppl√©mentaire.  Pas la meilleure option, car  dans une telle solution, hibernate doit utiliser une transaction distincte et verrouiller par ligne. </li></ul><br>  Parlons un peu plus de s√©quence.  Afin d'augmenter la vitesse de fonctionnement, hibernate utilise diff√©rents algorithmes d'optimisation.  Tous visent √† r√©duire le nombre de conversations avec la base de donn√©es (le nombre d'aller-retour).  Examinons-les plus en d√©tail: <br><br><ul><li>  <b>aucune</b> - aucune optimisation.  pour chaque id, nous tirons la s√©quence. </li><li>  <b>pooled et pooled-lo</b> - dans ce cas, notre s√©quence doit augmenter d'un certain intervalle - N dans la base de donn√©es (SequenceGenerator.allocationSize).  Et dans l'application, nous avons un certain pool, les valeurs √† partir desquelles nous pouvons attribuer √† de nouvelles entit√©s sans acc√©der √† la base de donn√©es .. </li><li>  <b>hilo</b> - pour g√©n√©rer un ID, l'algorithme hilo utilise 2 nombres: hi (stock√© dans la base de donn√©es - la valeur obtenue √† partir de l'appel de s√©quence) et lo (stock√© uniquement dans l'application - SequenceGenerator.allocationSize).  Sur la base de ces chiffres, l'intervalle de g√©n√©ration de id est calcul√© comme suit: [(hi - 1) * lo + 1, hi * lo + 1).  Pour des raisons √©videntes, cet algorithme est consid√©r√© comme obsol√®te et il n'est pas recommand√© de l'utiliser. </li></ul><br>  Voyons maintenant comment l'optimiseur est s√©lectionn√©.  Hibernate poss√®de plusieurs g√©n√©rateurs de s√©quences.  Nous serons int√©ress√©s par 2 d'entre eux: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> est un ancien g√©n√©rateur qui utilise l'optimiseur hilo.  S√©lectionn√© par d√©faut si nous avons la propri√©t√© hibernate.id.new_generator_mappings == false. </li><li>  <b>SequenceStyleGenerator</b> - utilis√© par d√©faut (si la propri√©t√© hibernate.id.new_generator_mappings == true).  Ce g√©n√©rateur prend en charge plusieurs optimiseurs, mais la valeur par d√©faut est mise en commun. </li></ul><br>  Vous pouvez √©galement configurer l'annotation du g√©n√©rateur @GenericGenerator. <br><br><h2>  Impasse </h2><br>  Regardons un exemple de situation de pseudo-code qui peut conduire √† un blocage: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Pour √©viter de tels probl√®mes, hibernate dispose d'un m√©canisme qui √©vite les blocages de ce type - le param√®tre hibernate.order_updates.  Dans ce cas, toutes les mises √† jour seront ordonn√©es par id et ex√©cut√©es.  Je mentionnerai √©galement une fois de plus qu'hibernate essaie de "retarder" la capture de la connexion et l'ex√©cution des insert-s et update-s. <br><br><h2>  Ensemble, sac, liste </h2><br>  Hibernate a 3 fa√ßons principales de pr√©senter la collection de communication OneToMany. <br><br><ul><li>  Ensemble - un ensemble non ordonn√© d'entit√©s sans r√©p√©titions; </li><li>  Sac - un ensemble non ordonn√© d'entit√©s; </li><li>  La liste est un ensemble ordonn√© d'entit√©s. </li></ul><br>  Il n'y a pas de classe pour Bag in java core qui d√©crirait une telle structure.  Par cons√©quent, toutes les listes et collections sont sac sauf si vous sp√©cifiez une colonne selon laquelle notre collection sera tri√©e (annotation OrderColumn. √Ä ne pas confondre avec SortBy).  Je d√©conseille fortement d'utiliser l'annotation OrderColumn en raison de la mauvaise mise en ≈ìuvre (√† mon avis) des fonctionnalit√©s - pas de requ√™tes SQL optimales, NULL possibles dans la feuille. <br><br>  La question se pose, mais quoi de mieux d'utiliser un sac ou un ensemble?  Pour commencer, lors de l'utilisation d'un sac, les probl√®mes suivants sont possibles: <br><br><ul><li>  Si votre version de hibernate est inf√©rieure √† 5.0.8, alors il y a un bug assez s√©rieux - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HHH-5855</a> - la duplication est possible lors de l'insertion d'une entit√© enfant (dans le cas de cascadType = MERGE et PERSIST); </li><li>  Si vous utilisez bag pour la relation ManyToMany, hibernate g√©n√®re des requ√™tes extr√™mement inappropri√©es lors de la suppression d'une entit√© de la collection - il supprime d'abord toutes les lignes de la table de jointure, puis effectue l'insertion; </li><li>  Hibernate ne peut pas r√©cup√©rer plusieurs sacs pour la m√™me entit√© en m√™me temps. </li></ul><br>  Dans le cas o√π vous souhaitez ajouter une autre entit√© √† la connexion @OneToMany, il est plus rentable d'utiliser Bag, car  il ne n√©cessite pas de charger toutes les entit√©s li√©es pour cette op√©ration.  Voyons un exemple: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  R√©f√©rences de force </h2><br>  La r√©f√©rence est une r√©f√©rence √† un objet, que nous avons d√©cid√© de reporter le chargement.  Dans le cas de la relation de ManyToOne avec fetchType = LAZY, nous obtenons une telle r√©f√©rence.  L'initialisation de l'objet a lieu au moment de l'acc√®s aux champs de l'entit√©, √† l'exception de id (puisque nous connaissons la valeur de ce champ). <br><br>  Il convient de noter que dans le cas du chargement diff√©r√©, la r√©f√©rence fait toujours r√©f√©rence √† une ligne existante dans la base de donn√©es.  Pour cette raison, la plupart des cas de chargement diff√©r√© ne fonctionnent pas dans les relations OneToOne - la mise en veille prolong√©e doit √™tre jointe pour v√©rifier si la connexion existe et il y avait d√©j√† une jointure, puis la mise en veille prolong√©e la charge dans le mod√®le d'objet.  Si nous indiquons nullable = true dans OneToOne, alors LazyLoad devrait fonctionner. <br><br>  Nous pouvons cr√©er notre propre r√©f√©rence en utilisant la m√©thode em.getReference.  Certes, dans ce cas, rien ne garantit que la r√©f√©rence se r√©f√®re √† une ligne existante dans la base de donn√©es. <br><br>  Donnons un exemple d'utilisation d'un tel lien: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Juste au cas o√π, je vous rappelle que nous obtiendrons une LazyInitializationException en cas d'EM ferm√© ou de lien d√©tach√©. <br><br><h2>  Date et heure </h2><br>  Malgr√© le fait que java 8 poss√®de une excellente API pour travailler avec la date et l'heure, l'API JDBC vous permet toujours de travailler uniquement avec l'ancienne API de date.  Par cons√©quent, nous analyserons certains points int√©ressants. <br><br>  Tout d'abord, vous devez comprendre clairement les diff√©rences entre LocalDateTime et Instant et ZonedDateTime.  (Je ne m'√©tirerai pas, mais je donnerai d'excellents articles sur ce sujet: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Si bri√®vement</b> <div class="spoiler_text">  LocalDateTime et LocalDate repr√©sentent un tuple r√©gulier de nombres.  Ils ne sont pas li√©s √† un moment pr√©cis.  C'est-√†-dire  l'heure d'atterrissage de l'avion ne peut pas √™tre stock√©e dans LocalDateTime.  Et la date de naissance via LocalDate est tout √† fait normale.  Instant repr√©sente un point dans le temps, par rapport auquel nous pouvons obtenir l'heure locale √† n'importe quel point de la plan√®te. <br></div></div><br>  Un point plus int√©ressant et plus important est la fa√ßon dont les dates sont stock√©es dans la base de donn√©es.  Si le type TIMESTAMP WITH TIMEZONE est appos√©, il ne devrait pas y avoir de probl√®me, mais si TIMESTAMP (WITHOUT TIMEZONE) se tient, il y a une chance que la date soit √©crite / lue incorrectement.  (hors LocalDate et LocalDateTime) <br><br>  Voyons pourquoi: <br><br>  Lorsque nous enregistrons la date, une m√©thode avec la signature suivante est utilis√©e: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Comme vous pouvez le voir, l'ancienne API est utilis√©e ici.  L'argument Calendar facultatif est n√©cessaire pour convertir l'horodatage en une repr√©sentation sous forme de cha√Æne.  C'est-√†-dire qu'il stocke le fuseau horaire en soi.  Si le calendrier n'est pas transmis, le calendrier est utilis√© par d√©faut avec le fuseau horaire JVM. <br><br>  Il existe 3 fa√ßons de r√©soudre ce probl√®me: <br><br><ul><li>  D√©finissez la JVM de fuseau horaire souhait√©e </li><li>  Utilisez le param√®tre hibernate - hibernate.jdbc.time_zone (ajout√© en 5.2) - ne corrigera que ZonedDateTime et OffsetDateTime </li><li>  Utilisez le type TIMESTAMP WITH TIMEZONE </li></ul><br>  Une question int√©ressante, pourquoi LocalDate et LocalDateTime ne rel√®vent pas d'un tel probl√®me? <br><br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text">  Pour r√©pondre √† cette question, vous devez comprendre la structure de la classe java.util.Date (java.sql.Date et java.sql.Timestamp, ses h√©ritiers et leurs diff√©rences dans ce cas ne nous d√©rangent pas).  Date stocke la date en millisecondes depuis 1970, grosso modo en UTC, mais la m√©thode toString convertit la date en fonction de la zone horaire du syst√®me. <br><br>  Par cons√©quent, lorsque nous obtenons une date sans fuseau horaire de la base de donn√©es, elle est mapp√©e √† un objet Timestamp afin que la m√©thode toString affiche sa valeur souhait√©e.  Dans le m√™me temps, le nombre de millisecondes depuis 1970 peut diff√©rer (selon le fuseau horaire).  C'est pourquoi seule l'heure locale est toujours affich√©e correctement. <br><br>  Je donne √©galement un exemple du code responsable de la conversion de Timesamp en LocalDateTime et Instant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Batching </h2><br>  Par d√©faut, les requ√™tes sont envoy√©es √† la base de donn√©es une par une.  Lorsque le traitement par lots est activ√©, hibernate pourra envoyer plusieurs instructions en une seule requ√™te √† la base de donn√©es.  (c'est-√†-dire que le traitement par lots r√©duit le nombre d'aller-retour dans la base de donn√©es) <br><br>  Pour ce faire, vous devez: <br><br><ul><li>  Activez le traitement par lots et d√©finissez le nombre maximal d'instructions: <br>  hibernate.jdbc.batch_size (5 √† 30 recommand√©s) </li><li>  Activez le tri des insertions et des mises √† jour: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Si nous utilisons le contr√¥le de version, nous devons √©galement activer <br>  hibernate.jdbc.batch_versioned_data - attention ici, vous avez besoin du pilote jdbc pour pouvoir donner le nombre de lignes affect√©es lors de la mise √† jour. </li></ul><br>  Je vais √©galement vous rappeler l'efficacit√© de l'op√©ration em.clear () - elle d√©lie les entit√©s d'em, lib√©rant ainsi de la m√©moire et r√©duisant le temps de l'op√©ration de v√©rification sale. <br>  Si nous utilisons postgres, nous pouvons √©galement dire hibernate pour utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'insertion multi-raw</a> . <br><br><h2>  Probl√®me N + 1 </h2><br>  C'est un sujet assez omnipr√©sent, alors revenez-y rapidement. <br><br>  Un probl√®me N + 1 est une situation o√π, au lieu d'une seule demande de s√©lection de N livres, au moins N + 1 demandes se produisent. <br><br>  La fa√ßon la plus simple de r√©soudre le probl√®me N + 1 consiste √† r√©cup√©rer les tables associ√©es.  Dans ce cas, nous pouvons rencontrer plusieurs autres probl√®mes: <br><br><ul><li>  <b>Pagination.</b>  dans le cas des relations OneToMany, hibernate ne pourra pas sp√©cifier de d√©calage et de limite.  Par cons√©quent, la pagination se produira en m√©moire. </li><li>  <b>Le probl√®me d'un produit cart√©sien</b> est une situation o√π une base de donn√©es renvoie N * M * K lignes pour choisir N ‚Äã‚Äãlivres avec M chapitres et K auteurs. </li></ul><br>  Il existe d'autres fa√ßons de r√©soudre le probl√®me N + 1. <br><br><ul><li>  <b>FetchMode</b> - vous permet de modifier l'algorithme de chargement des entit√©s enfants.  Dans notre cas, nous nous int√©ressons aux √©l√©ments suivants: <ul><li>  <b>FetchType.SUBSELECT</b> - Charge les enregistrements enfants dans une demande distincte.  L'inconv√©nient est que toute la complexit√© de la requ√™te principale est r√©p√©t√©e en sous-s√©lection. </li><li>  <b>BATCH (annotation FetchType.SELECT + BatchSize)</b> - charge √©galement les enregistrements en tant que demande distincte, mais avec la sous-requ√™te, il cr√©e une condition comme WHERE parent_id IN (?,?,?, ..., N) </li></ul>  Il convient de noter que lors de l'utilisation de l'extraction dans l'API Criteria, FetchType est ignor√© - JOIN est toujours utilis√© </li><li>  <b>JPA EntityGraph et Hibernate FetchProfile</b> - vous permettent de faire des r√®gles de chargement d'entit√© dans une abstraction distincte - √† mon avis, les deux impl√©mentations sont g√™nantes. </li></ul><br><h2>  Test </h2><br>  Id√©alement, l'environnement de d√©veloppement devrait fournir autant d'informations utiles que possible sur le fonctionnement de la mise en veille prolong√©e et sur l'interaction avec la base de donn√©es.  √Ä savoir: <br><br><ul><li>  Journalisation <ul><li>  org.hibernate.SQL: d√©bogage </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Statistiques <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Parmi les utilitaires utiles, on peut distinguer les suivants: <br><ul><li>  <b>DBUnit</b> - vous permet de d√©crire l'√©tat de la base de donn√©es au format XML.  Parfois, c'est pratique.  Mais mieux r√©fl√©chir si vous en avez besoin. </li><li>  DataSource-proxy <ul><li>  <b>p6spy</b> est l'une des solutions les plus anciennes.  offre une journalisation avanc√©e des requ√™tes, un runtime, etc. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> est un utilitaire pratique pour trouver les probl√®mes N + 1.  Il vous permet √©galement d'enregistrer des requ√™tes.  La composition comprend une annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Retry</a> int√©ressante, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">r√©essaye</a> la transaction dans le cas d'une exception OptimisticLockException. </li><li>  <b>Sniffy</b> - vous permet de faire une affirmation sur le nombre de demandes via l'annotation.  √Ä certains √©gards, plus √©l√©gant que la d√©cision de Vlad. </li></ul></li></ul><br>  Mais je r√©p√®te encore une fois que ce n'est que pour le d√©veloppement, cela ne devrait pas √™tre inclus dans la production. <br><br><h2>  Litt√©rature </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rapport de Nikolai Alimenkov - Faisons √† nouveau</a> hiberner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapidement</a> - c'est ce rapport qui m'a inspir√© √† √©tudier l'hibernation plus profond√©ment.  Voici les ressources que j'ai utilis√©es. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le livre ¬´Java Persistence API and Hibernate¬ª</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog de Vlad M.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Weakly Digest</a> - Daily Digest (indirectement li√© au sujet) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416851/">https://habr.com/ru/post/fr416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416841/index.html">Comment tester des hypoth√®ses et gagner de l'argent sur Swift √† l'aide de tests fractionn√©s</a></li>
<li><a href="../fr416843/index.html">Moteurs de fus√©es nucl√©aires et syst√®mes de propulsion √©lectrique de fus√©es nucl√©aires</a></li>
<li><a href="../fr416845/index.html">10 raisons d'utiliser itracking ou de l'abandonner pour toujours</a></li>
<li><a href="../fr416847/index.html">Le site d'administration d'Ammyy √† nouveau compromis</a></li>
<li><a href="../fr416849/index.html">Oh mon code. Comment devenir administrateur syst√®me</a></li>
<li><a href="../fr416855/index.html">Baccalaur√©at de l'Universit√© d'√âtat de Saint-P√©tersbourg</a></li>
<li><a href="../fr416857/index.html">Nous construisons des temples - dans le code et dans la vie. Mon exp√©rience dans le d√©veloppement de ma deuxi√®me application Android</a></li>
<li><a href="../fr416859/index.html">Meet All at Once React Boilerplate par Maximilian Stoiber v3.6.0</a></li>
<li><a href="../fr416863/index.html">Une nouvelle fa√ßon de pr√©senter les exposants</a></li>
<li><a href="../fr416865/index.html">Design r√©tro pour la premi√®re console portable de la lointaine 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>