<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏻 🙋🏽 🐨 Hibernate - de quoi les didacticiels sont muets 😫 👨‍👩‍👦 ⛑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article ne couvrira pas les bases d'Hibernate (comment définir une entité ou écrire une requête de critères). Ici, je vais essayer de parler de po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hibernate - de quoi les didacticiels sont muets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Cet article ne couvrira pas les bases d'Hibernate (comment définir une entité ou écrire une requête de critères).  Ici, je vais essayer de parler de points plus intéressants qui sont vraiment utiles dans le travail.  Informations sur lesquelles je n'ai pas rencontré en un seul endroit. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="image"><br><a name="habracut"></a><br>  Je ferai une réservation tout de suite.  Tout ce qui suit est vrai pour Hibernate 5.2.  Des erreurs sont également possibles du fait que j'ai mal compris quelque chose.  Si vous trouvez - écrivez. <br><br><h2>  Problèmes de mappage d'un modèle d'objet dans un relationnel </h2><br>  Mais commençons par les bases de l'ORM.  ORM - mapping objet-relationnel - en conséquence, nous avons des modèles relationnels et objet.  Et lors de l'affichage les uns des autres, il y a des problèmes que nous devons résoudre nous-mêmes.  Prenons-les à part. <br><br>  Pour illustrer cela, prenons l'exemple suivant: nous avons l'entité «Utilisateur», qui peut être un Jedi ou un avion d'attaque.  Les Jedi doivent avoir de la force et la spécialisation des avions d'attaque.  Voici un diagramme de classes. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="image"><br><br><h3>  Problème 1. Héritage et requêtes polymorphes. </h3><br>  Il existe un héritage dans le modèle objet, mais pas dans le modèle relationnel.  En conséquence, c'est le premier problème - comment mapper correctement l'héritage au modèle relationnel. <br><br>  Hibernate propose 3 options pour afficher un tel modèle d'objet: <br><br><ol><li>  Tous les héritiers sont dans le même tableau: <br>  <b>@Inheritance (stratégie = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="image"><br><br>  Dans ce cas, les champs communs et les champs des héritiers se trouvent dans une seule table.  En utilisant cette stratégie, nous évitons les jointures lors de la sélection des entités.  Parmi les inconvénients, il convient de noter que, premièrement, nous ne pouvons pas définir la restriction «NOT NULL» pour la colonne «force» dans le modèle relationnel, et deuxièmement, nous perdons la troisième forme normale.  (une dépendance transitive d'attributs non clés apparaît: force et disque). <br><br>  Soit dit en passant, y compris pour cette raison, il existe 2 façons de spécifier une contrainte de champ non nulle - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">NotNull</a> est responsable de la validation;  @Column (nullable = true) - responsable de la contrainte non null dans la base de données. <br><br>  À mon avis, c'est la meilleure façon de mapper un modèle objet sur un modèle relationnel. <br></li><li>  Les champs spécifiques à l'entité se trouvent dans une table distincte. <br><br>  <b>@Inheritance (stratégie = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="image"><br><br>  Dans ce cas, les champs communs sont stockés dans une table commune, et spécifiques aux entités enfants sont stockés dans des entités distinctes.  En utilisant cette stratégie, nous obtenons un JOIN lors du choix d'une entité, mais maintenant nous enregistrons le troisième formulaire normal, et nous pouvons également spécifier une contrainte NOT NULL dans la base de données. </li><li>  Chaque entité a sa propre table. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="image"><br><br>  Dans ce cas, nous n'avons pas de table commune.  En utilisant cette stratégie, nous utilisons UNION pour les requêtes polymorphes.  Nous rencontrons des problèmes avec les générateurs de clés primaires et d'autres contraintes d'intégrité.  Ce type de mappage d'héritage est fortement déconseillé. </li></ol><br>  Au cas où, je mentionnerai l'annotation - @MappedSuperclass.  Il est utilisé lorsque vous souhaitez «masquer» des champs communs pour plusieurs entités du modèle objet.  De plus, la classe annotée elle-même n'est pas considérée comme une entité distincte. <br><br><h3>  Problème 2. Rapport de composition en POO </h3><br>  Revenant à notre exemple, nous notons que dans le modèle objet, nous avons pris le profil utilisateur dans une entité distincte - Profil.  Mais dans le modèle relationnel, nous n'avons pas sélectionné de table distincte pour cela. <br><br>  L'attitude OneToOne est souvent une mauvaise pratique car  dans select, nous avons un JOIN injustifié (même en spécifiant fetchType = LAZY dans la plupart des cas, nous aurons JOIN - nous discuterons de ce problème plus tard). <br><br>  Il existe des annotations @Embedable et @Embeded pour afficher une composition dans un tableau commun.  Le premier est placé au-dessus du champ et le second au-dessus de la classe.  Ils sont interchangeables. <br><br><h2>  Gestionnaire d'entités </h2><br>  Chaque instance d'EntityManager (EM) définit une session d'interaction avec la base de données.  Au sein d'une instance EM, il existe un cache de premier niveau.  Ici, je vais souligner les points importants suivants: <br><br><ol><li>  <b>Capture de la connexion à la base de données</b> <br><br>  Ceci est juste un point intéressant.  Hibernate ne capture pas la connexion au moment de la réception de l'EM, mais au premier accès à la base de données ou à l'ouverture de la transaction (bien que ce problème <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">puisse être résolu</a> ).  Ceci est fait afin de réduire le temps de connexion occupée.  Lors de la réception d'EM-a, la présence d'une transaction JTA est vérifiée. </li><li>  <b>Les entités persistantes ont toujours un identifiant</b> </li><li>  <b>Les entités décrivant une ligne dans la base de données sont équivalentes par référence</b> <br>  Comme mentionné ci-dessus, EM a un cache de premier niveau, les objets y sont comparés par référence.  En conséquence, la question se pose - quels champs doivent être utilisés pour remplacer égal et hashcode?  Considérez les options suivantes: <br><br><ul><li>  Utilisez tous les champs.  Mauvaise idée  égaux peut affecter les champs LAZY.  Soit dit en passant, cela est également vrai pour la méthode toString. </li><li>  Utilisez id uniquement.  Une idée normale, mais il y a aussi des nuances.  Puisque le plus souvent pour les nouvelles entités, id met un générateur au moment de persister.  La situation suivante est possible: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Utilisez une clé métier (grosso modo, des champs uniques et NON NULS).  Mais cette option n'est pas toujours pratique. <br><br>  Soit dit en passant, puisque nous parlons de NOT NULL et UNIQUE, il est parfois pratique de créer un constructeur public avec des arguments NOT NULL, et le constructeur sans arguments est protégé. </li><li>  Ne remplacez pas égaux et hashcode du tout. </li></ul></li><li>  <b>Comment fonctionne le rinçage</b> <br>  Flush - exécute les insert-s, update-s et delete-s accumulés dans la base de données.  Par défaut, le vidage est exécuté dans les cas: <br><br><ul><li>  Avant d'exécuter la requête (à l'exception d'em.get), cela est nécessaire pour se conformer au principe ACID.  Par exemple: nous avons changé la date de naissance de l'avion d'attaque, puis nous avons voulu obtenir le nombre d'avions d'attaque adultes. <br><br>  Si nous parlons de CriteriaQuery ou JPQL, alors le vidage sera exécuté si la requête affecte une table dont les entités sont dans le cache du premier niveau. </li><li>  Lors de la validation d'une transaction; </li><li>  Parfois, lors de la persistance d'une nouvelle entité - dans le cas où nous ne pouvons obtenir son identifiant que par insertion. </li></ul><br>  Et maintenant un petit test.  Combien d'opérations UPDATE seront effectuées dans ce cas? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Une fonctionnalité d'hibernation intéressante est cachée sous l'opération de vidage - elle essaie de réduire le temps nécessaire pour verrouiller les lignes dans la base de données. <br><br>  Notez également qu'il existe différentes stratégies pour l'opération de rinçage.  Par exemple, vous pouvez interdire la «fusion» des modifications apportées à la base de données - elle est appelée MANUELLE (elle désactive également le mécanisme de vérification incorrecte). <br></li><li>  <b>Vérification sale</b> <br><br>  Dirty Checking est un mécanisme exécuté lors d'une opération de vidage.  Son but est de trouver des entités qui ont changé et de les mettre à jour.  Pour implémenter un tel mécanisme, hibernate doit stocker la copie originale de l'objet (avec quoi l'objet réel sera comparé).  Pour être plus précis, hibernate stocke une copie des champs de l'objet, pas l'objet lui-même. <br><br>  Il convient de noter que si le graphique des entités est grand, l'opération de vérification incorrecte peut être coûteuse.  N'oubliez pas qu'hibernate stocke 2 copies d'entités (grosso modo). <br>  Afin de "réduire le coût" de ce processus, utilisez les fonctionnalités suivantes: <br><br><ul><li>  em.detach / em.clear - détache des entités d'EntityManager </li><li>  FlushMode = MANUAL- utile dans les opérations de lecture </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Immuable</a> - évite également les opérations de vérification sales </li></ul><br></li><li>  <b>Les transactions</b> <br><br>  Comme vous le savez, hibernate vous permet de mettre à jour des entités uniquement dans une transaction.  Les opérations de lecture offrent plus de liberté - nous pouvons les exécuter sans ouvrir explicitement une transaction.  Mais c'est précisément la question: cela vaut-il la peine d'ouvrir une transaction explicitement pour les opérations de lecture? <br><br>  Je citerai quelques faits: <br><br><ul><li>  Toute instruction est exécutée dans la base de données à l'intérieur de la transaction.  Même si nous ne l'avons évidemment pas ouvert.  (mode auto-commit). </li><li>  En règle générale, nous ne sommes pas limités à une seule requête dans la base de données.  Par exemple: pour obtenir les 10 premiers enregistrements, vous souhaiterez probablement renvoyer le nombre total d'enregistrements.  Et c'est presque toujours 2 demandes. </li><li>  Si nous parlons de données de printemps, les méthodes de référentiel sont transactionnelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par défaut</a> , tandis que les méthodes de lecture sont en lecture seule. </li><li>  L'annotation @Transactional spring (readOnly = true) affecte également FlushMode, plus précisément, Spring la met en statut MANUAL, ainsi la mise en veille prolongée n'effectuera pas de vérification de la saleté. </li><li>  Des tests synthétiques avec une ou deux requêtes de base de données montreront que la validation automatique est plus rapide.  Mais en mode combat, ce n'est peut-être pas le cas.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent article sur ce sujet</a> , + voir commentaires) </li></ul><br>  En un mot: il est de bonne pratique d'effectuer toute communication avec la base de données lors d'une transaction. <br></li></ol><br><h2>  Générateurs </h2><br>  Des générateurs sont nécessaires pour décrire comment les clés primaires de nos entités recevront des valeurs.  Passons rapidement en revue les options: <br><br><ul><li>  <b>GenerationType.AUTO</b> - la sélection du générateur est basée sur le dialecte.  Ce n'est pas la meilleure option, car la règle «explicite vaut mieux que l'implicite» s'applique juste ici. </li><li>  <b>GenerationType.IDENTITY</b> est le moyen le plus simple de configurer un générateur.  Il s'appuie sur la colonne d'incrémentation automatique du tableau.  Par conséquent, pour obtenir id avec persist, nous devons faire une insertion.  C'est pourquoi il élimine la possibilité de persistance différée et donc de batch. </li><li>  <b>GenerationType.SEQUENCE</b> est le cas le plus pratique lorsque nous obtenons id à partir d'une séquence. </li><li>  <b>GenerationType.TABLE</b> - dans ce cas, hibernate émule une séquence via une table supplémentaire.  Pas la meilleure option, car  dans une telle solution, hibernate doit utiliser une transaction distincte et verrouiller par ligne. </li></ul><br>  Parlons un peu plus de séquence.  Afin d'augmenter la vitesse de fonctionnement, hibernate utilise différents algorithmes d'optimisation.  Tous visent à réduire le nombre de conversations avec la base de données (le nombre d'aller-retour).  Examinons-les plus en détail: <br><br><ul><li>  <b>aucune</b> - aucune optimisation.  pour chaque id, nous tirons la séquence. </li><li>  <b>pooled et pooled-lo</b> - dans ce cas, notre séquence doit augmenter d'un certain intervalle - N dans la base de données (SequenceGenerator.allocationSize).  Et dans l'application, nous avons un certain pool, les valeurs à partir desquelles nous pouvons attribuer à de nouvelles entités sans accéder à la base de données .. </li><li>  <b>hilo</b> - pour générer un ID, l'algorithme hilo utilise 2 nombres: hi (stocké dans la base de données - la valeur obtenue à partir de l'appel de séquence) et lo (stocké uniquement dans l'application - SequenceGenerator.allocationSize).  Sur la base de ces chiffres, l'intervalle de génération de id est calculé comme suit: [(hi - 1) * lo + 1, hi * lo + 1).  Pour des raisons évidentes, cet algorithme est considéré comme obsolète et il n'est pas recommandé de l'utiliser. </li></ul><br>  Voyons maintenant comment l'optimiseur est sélectionné.  Hibernate possède plusieurs générateurs de séquences.  Nous serons intéressés par 2 d'entre eux: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> est un ancien générateur qui utilise l'optimiseur hilo.  Sélectionné par défaut si nous avons la propriété hibernate.id.new_generator_mappings == false. </li><li>  <b>SequenceStyleGenerator</b> - utilisé par défaut (si la propriété hibernate.id.new_generator_mappings == true).  Ce générateur prend en charge plusieurs optimiseurs, mais la valeur par défaut est mise en commun. </li></ul><br>  Vous pouvez également configurer l'annotation du générateur @GenericGenerator. <br><br><h2>  Impasse </h2><br>  Regardons un exemple de situation de pseudo-code qui peut conduire à un blocage: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Pour éviter de tels problèmes, hibernate dispose d'un mécanisme qui évite les blocages de ce type - le paramètre hibernate.order_updates.  Dans ce cas, toutes les mises à jour seront ordonnées par id et exécutées.  Je mentionnerai également une fois de plus qu'hibernate essaie de "retarder" la capture de la connexion et l'exécution des insert-s et update-s. <br><br><h2>  Ensemble, sac, liste </h2><br>  Hibernate a 3 façons principales de présenter la collection de communication OneToMany. <br><br><ul><li>  Ensemble - un ensemble non ordonné d'entités sans répétitions; </li><li>  Sac - un ensemble non ordonné d'entités; </li><li>  La liste est un ensemble ordonné d'entités. </li></ul><br>  Il n'y a pas de classe pour Bag in java core qui décrirait une telle structure.  Par conséquent, toutes les listes et collections sont sac sauf si vous spécifiez une colonne selon laquelle notre collection sera triée (annotation OrderColumn. À ne pas confondre avec SortBy).  Je déconseille fortement d'utiliser l'annotation OrderColumn en raison de la mauvaise mise en œuvre (à mon avis) des fonctionnalités - pas de requêtes SQL optimales, NULL possibles dans la feuille. <br><br>  La question se pose, mais quoi de mieux d'utiliser un sac ou un ensemble?  Pour commencer, lors de l'utilisation d'un sac, les problèmes suivants sont possibles: <br><br><ul><li>  Si votre version de hibernate est inférieure à 5.0.8, alors il y a un bug assez sérieux - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HHH-5855</a> - la duplication est possible lors de l'insertion d'une entité enfant (dans le cas de cascadType = MERGE et PERSIST); </li><li>  Si vous utilisez bag pour la relation ManyToMany, hibernate génère des requêtes extrêmement inappropriées lors de la suppression d'une entité de la collection - il supprime d'abord toutes les lignes de la table de jointure, puis effectue l'insertion; </li><li>  Hibernate ne peut pas récupérer plusieurs sacs pour la même entité en même temps. </li></ul><br>  Dans le cas où vous souhaitez ajouter une autre entité à la connexion @OneToMany, il est plus rentable d'utiliser Bag, car  il ne nécessite pas de charger toutes les entités liées pour cette opération.  Voyons un exemple: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Références de force </h2><br>  La référence est une référence à un objet, que nous avons décidé de reporter le chargement.  Dans le cas de la relation de ManyToOne avec fetchType = LAZY, nous obtenons une telle référence.  L'initialisation de l'objet a lieu au moment de l'accès aux champs de l'entité, à l'exception de id (puisque nous connaissons la valeur de ce champ). <br><br>  Il convient de noter que dans le cas du chargement différé, la référence fait toujours référence à une ligne existante dans la base de données.  Pour cette raison, la plupart des cas de chargement différé ne fonctionnent pas dans les relations OneToOne - la mise en veille prolongée doit être jointe pour vérifier si la connexion existe et il y avait déjà une jointure, puis la mise en veille prolongée la charge dans le modèle d'objet.  Si nous indiquons nullable = true dans OneToOne, alors LazyLoad devrait fonctionner. <br><br>  Nous pouvons créer notre propre référence en utilisant la méthode em.getReference.  Certes, dans ce cas, rien ne garantit que la référence se réfère à une ligne existante dans la base de données. <br><br>  Donnons un exemple d'utilisation d'un tel lien: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Juste au cas où, je vous rappelle que nous obtiendrons une LazyInitializationException en cas d'EM fermé ou de lien détaché. <br><br><h2>  Date et heure </h2><br>  Malgré le fait que java 8 possède une excellente API pour travailler avec la date et l'heure, l'API JDBC vous permet toujours de travailler uniquement avec l'ancienne API de date.  Par conséquent, nous analyserons certains points intéressants. <br><br>  Tout d'abord, vous devez comprendre clairement les différences entre LocalDateTime et Instant et ZonedDateTime.  (Je ne m'étirerai pas, mais je donnerai d'excellents articles sur ce sujet: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Si brièvement</b> <div class="spoiler_text">  LocalDateTime et LocalDate représentent un tuple régulier de nombres.  Ils ne sont pas liés à un moment précis.  C'est-à-dire  l'heure d'atterrissage de l'avion ne peut pas être stockée dans LocalDateTime.  Et la date de naissance via LocalDate est tout à fait normale.  Instant représente un point dans le temps, par rapport auquel nous pouvons obtenir l'heure locale à n'importe quel point de la planète. <br></div></div><br>  Un point plus intéressant et plus important est la façon dont les dates sont stockées dans la base de données.  Si le type TIMESTAMP WITH TIMEZONE est apposé, il ne devrait pas y avoir de problème, mais si TIMESTAMP (WITHOUT TIMEZONE) se tient, il y a une chance que la date soit écrite / lue incorrectement.  (hors LocalDate et LocalDateTime) <br><br>  Voyons pourquoi: <br><br>  Lorsque nous enregistrons la date, une méthode avec la signature suivante est utilisée: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Comme vous pouvez le voir, l'ancienne API est utilisée ici.  L'argument Calendar facultatif est nécessaire pour convertir l'horodatage en une représentation sous forme de chaîne.  C'est-à-dire qu'il stocke le fuseau horaire en soi.  Si le calendrier n'est pas transmis, le calendrier est utilisé par défaut avec le fuseau horaire JVM. <br><br>  Il existe 3 façons de résoudre ce problème: <br><br><ul><li>  Définissez la JVM de fuseau horaire souhaitée </li><li>  Utilisez le paramètre hibernate - hibernate.jdbc.time_zone (ajouté en 5.2) - ne corrigera que ZonedDateTime et OffsetDateTime </li><li>  Utilisez le type TIMESTAMP WITH TIMEZONE </li></ul><br>  Une question intéressante, pourquoi LocalDate et LocalDateTime ne relèvent pas d'un tel problème? <br><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  Pour répondre à cette question, vous devez comprendre la structure de la classe java.util.Date (java.sql.Date et java.sql.Timestamp, ses héritiers et leurs différences dans ce cas ne nous dérangent pas).  Date stocke la date en millisecondes depuis 1970, grosso modo en UTC, mais la méthode toString convertit la date en fonction de la zone horaire du système. <br><br>  Par conséquent, lorsque nous obtenons une date sans fuseau horaire de la base de données, elle est mappée à un objet Timestamp afin que la méthode toString affiche sa valeur souhaitée.  Dans le même temps, le nombre de millisecondes depuis 1970 peut différer (selon le fuseau horaire).  C'est pourquoi seule l'heure locale est toujours affichée correctement. <br><br>  Je donne également un exemple du code responsable de la conversion de Timesamp en LocalDateTime et Instant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Batching </h2><br>  Par défaut, les requêtes sont envoyées à la base de données une par une.  Lorsque le traitement par lots est activé, hibernate pourra envoyer plusieurs instructions en une seule requête à la base de données.  (c'est-à-dire que le traitement par lots réduit le nombre d'aller-retour dans la base de données) <br><br>  Pour ce faire, vous devez: <br><br><ul><li>  Activez le traitement par lots et définissez le nombre maximal d'instructions: <br>  hibernate.jdbc.batch_size (5 à 30 recommandés) </li><li>  Activez le tri des insertions et des mises à jour: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Si nous utilisons le contrôle de version, nous devons également activer <br>  hibernate.jdbc.batch_versioned_data - attention ici, vous avez besoin du pilote jdbc pour pouvoir donner le nombre de lignes affectées lors de la mise à jour. </li></ul><br>  Je vais également vous rappeler l'efficacité de l'opération em.clear () - elle délie les entités d'em, libérant ainsi de la mémoire et réduisant le temps de l'opération de vérification sale. <br>  Si nous utilisons postgres, nous pouvons également dire hibernate pour utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'insertion multi-raw</a> . <br><br><h2>  Problème N + 1 </h2><br>  C'est un sujet assez omniprésent, alors revenez-y rapidement. <br><br>  Un problème N + 1 est une situation où, au lieu d'une seule demande de sélection de N livres, au moins N + 1 demandes se produisent. <br><br>  La façon la plus simple de résoudre le problème N + 1 consiste à récupérer les tables associées.  Dans ce cas, nous pouvons rencontrer plusieurs autres problèmes: <br><br><ul><li>  <b>Pagination.</b>  dans le cas des relations OneToMany, hibernate ne pourra pas spécifier de décalage et de limite.  Par conséquent, la pagination se produira en mémoire. </li><li>  <b>Le problème d'un produit cartésien</b> est une situation où une base de données renvoie N * M * K lignes pour choisir N ​​livres avec M chapitres et K auteurs. </li></ul><br>  Il existe d'autres façons de résoudre le problème N + 1. <br><br><ul><li>  <b>FetchMode</b> - vous permet de modifier l'algorithme de chargement des entités enfants.  Dans notre cas, nous nous intéressons aux éléments suivants: <ul><li>  <b>FetchType.SUBSELECT</b> - Charge les enregistrements enfants dans une demande distincte.  L'inconvénient est que toute la complexité de la requête principale est répétée en sous-sélection. </li><li>  <b>BATCH (annotation FetchType.SELECT + BatchSize)</b> - charge également les enregistrements en tant que demande distincte, mais avec la sous-requête, il crée une condition comme WHERE parent_id IN (?,?,?, ..., N) </li></ul>  Il convient de noter que lors de l'utilisation de l'extraction dans l'API Criteria, FetchType est ignoré - JOIN est toujours utilisé </li><li>  <b>JPA EntityGraph et Hibernate FetchProfile</b> - vous permettent de faire des règles de chargement d'entité dans une abstraction distincte - à mon avis, les deux implémentations sont gênantes. </li></ul><br><h2>  Test </h2><br>  Idéalement, l'environnement de développement devrait fournir autant d'informations utiles que possible sur le fonctionnement de la mise en veille prolongée et sur l'interaction avec la base de données.  À savoir: <br><br><ul><li>  Journalisation <ul><li>  org.hibernate.SQL: débogage </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Statistiques <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Parmi les utilitaires utiles, on peut distinguer les suivants: <br><ul><li>  <b>DBUnit</b> - vous permet de décrire l'état de la base de données au format XML.  Parfois, c'est pratique.  Mais mieux réfléchir si vous en avez besoin. </li><li>  DataSource-proxy <ul><li>  <b>p6spy</b> est l'une des solutions les plus anciennes.  offre une journalisation avancée des requêtes, un runtime, etc. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> est un utilitaire pratique pour trouver les problèmes N + 1.  Il vous permet également d'enregistrer des requêtes.  La composition comprend une annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Retry</a> intéressante, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">réessaye</a> la transaction dans le cas d'une exception OptimisticLockException. </li><li>  <b>Sniffy</b> - vous permet de faire une affirmation sur le nombre de demandes via l'annotation.  À certains égards, plus élégant que la décision de Vlad. </li></ul></li></ul><br>  Mais je répète encore une fois que ce n'est que pour le développement, cela ne devrait pas être inclus dans la production. <br><br><h2>  Littérature </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rapport de Nikolai Alimenkov - Faisons à nouveau</a> hiberner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapidement</a> - c'est ce rapport qui m'a inspiré à étudier l'hibernation plus profondément.  Voici les ressources que j'ai utilisées. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le livre «Java Persistence API and Hibernate»</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog de Vlad M.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Weakly Digest</a> - Daily Digest (indirectement lié au sujet) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416851/">https://habr.com/ru/post/fr416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416841/index.html">Comment tester des hypothèses et gagner de l'argent sur Swift à l'aide de tests fractionnés</a></li>
<li><a href="../fr416843/index.html">Moteurs de fusées nucléaires et systèmes de propulsion électrique de fusées nucléaires</a></li>
<li><a href="../fr416845/index.html">10 raisons d'utiliser itracking ou de l'abandonner pour toujours</a></li>
<li><a href="../fr416847/index.html">Le site d'administration d'Ammyy à nouveau compromis</a></li>
<li><a href="../fr416849/index.html">Oh mon code. Comment devenir administrateur système</a></li>
<li><a href="../fr416855/index.html">Baccalauréat de l'Université d'État de Saint-Pétersbourg</a></li>
<li><a href="../fr416857/index.html">Nous construisons des temples - dans le code et dans la vie. Mon expérience dans le développement de ma deuxième application Android</a></li>
<li><a href="../fr416859/index.html">Meet All at Once React Boilerplate par Maximilian Stoiber v3.6.0</a></li>
<li><a href="../fr416863/index.html">Une nouvelle façon de présenter les exposants</a></li>
<li><a href="../fr416865/index.html">Design rétro pour la première console portable de la lointaine 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>