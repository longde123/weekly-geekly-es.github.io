<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏾 🛷 👩🏾‍🌾 Mengevaluasi pengembang berdasarkan data objektif 🧘 👹 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sayangnya, kami tidak hidup di dunia yang ideal di mana setiap pengembang memiliki tingkat produktivitas yang ideal dan seimbang, sambil berfokus pada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengevaluasi pengembang berdasarkan data objektif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417411/">  Sayangnya, kami tidak hidup di dunia yang ideal di mana setiap pengembang memiliki tingkat produktivitas yang ideal dan seimbang, sambil berfokus pada tugas dan memikirkannya dari satu ke yang lain.  Kolaborasi tim juga tidak selalu dirancang sehingga semua anggota tim bekerja dengan efisiensi maksimum.  Seperti halnya banyak masalah pada umumnya, pengembangan awal dalam tim pengembangan menghemat sumber daya, membuat gugup, dan menciptakan suasana kerja yang baik. <br><br>  Dalam tim kecil, pemimpin tim dapat mencoba menilai segala sesuatu yang terjadi atas dasar perasaan subjektif, tetapi semakin besar perusahaan, semakin penting menggunakan data dan metrik objektif.  <strong>Alexander Kiselev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">AleksandrKiselev</a> ) dan <strong>Sergey Semenov</strong> dalam laporan mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TeamLead Conf</a> menunjukkan cara menggunakan data yang telah Anda kumpulkan, di mana mendapatkan data tambahan, dan bersama-sama mereka dapat membantu mengidentifikasi masalah yang tidak jelas.  Dan bahkan, setelah mengumpulkan pengalaman banyak rekan, mereka mengusulkan solusi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BF740kkXTvI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang para pembicara:</strong> Alexander Kiselev dan Sergey Semenov, kami telah berada di IT selama lebih dari 8 tahun.  Keduanya beralih dari pengembang ke pemimpin tim dan lebih jauh ke manajer produk.  Sekarang mereka bekerja pada layanan analitik GitLean, yang secara otomatis mengumpulkan analisis dari tim pengembangan untuk arahan tim dan CTO.  Tujuan dari layanan ini adalah manajer teknis dapat membuat keputusan berdasarkan data objektif. <br><a name="habracut"></a><br><h2>  Pernyataan masalah <br></h2><br>  Kami berdua bekerja sebagai pemimpin tim dan sering menghadapi masalah ketidakpastian dan ambiguitas dalam pekerjaan kami. <br><img src="https://habrastorage.org/webt/_b/oc/cb/_boccbltl1wgqu2dckbdzevfvvk.jpeg"><br><br>  Akibatnya, seringkali perlu untuk membuat keputusan secara membabi buta, dan kadang-kadang tidak jelas apakah itu lebih baik atau lebih buruk.  Oleh karena itu, kami melihat solusi yang ada di pasar, memeriksa metodologi untuk mengevaluasi kinerja pengembang, dan menyadari bahwa tidak ada layanan yang akan memenuhi kebutuhan kami.  Karena itu, <strong>kami memutuskan untuk membuatnya sendiri</strong> . <br><br>  Hari ini kita akan berbicara tentang apa yang dapat Anda katakan pada data yang telah Anda kumpulkan, tetapi kemungkinan besar tidak menggunakannya. <br><img src="https://habrastorage.org/webt/yt/0e/au/yt0eaumuz05vl_1vhmyo2rrbaji.jpeg"><br><br>  Ini diperlukan dalam dua kasus utama. <br><br>  <strong>Tinjauan kinerja adalah proses yang</strong> agak rumit dan subyektif.  Akan sangat bagus untuk mengumpulkan fakta tentang pekerjaan pengembang secara otomatis. <br><br>  Kami berbicara dengan perwakilan perusahaan Jerman besar dengan staf pengembangan besar.  Kira-kira setahun sekali mereka menghentikan seluruh pekerjaan pengembangan selama 2 minggu, dan hanya seluruh perusahaan melakukan tinjauan kinerja - para pengembang menulis penolakan anonim sepanjang hari kepada rekan kerja yang bekerja bersama mereka selama setahun.  Jika perusahaan ini memiliki kesempatan untuk mengumpulkan fakta secara otomatis, mereka akan menghemat banyak waktu. <br><br>  Aspek kedua adalah <strong>memantau situasi saat ini di tim.</strong>  Saya ingin cepat memahami masalah yang muncul, dan cepat menanggapinya. <br><br><h2>  Opsi keputusan <br></h2><br>  Mungkin ada beberapa solusi. <br><img src="https://habrastorage.org/webt/3c/oa/aq/3coaaqtqnrpp-st-ajnjfjfz0uo.jpeg"><br><br>  Pertama, Anda <strong>tidak</strong> dapat <strong>menggunakan analitik sama sekali</strong> , tetapi hanya penilaian subjektif Anda.  Ini berfungsi jika Anda adalah pemimpin tim dalam tim kecil.  Tetapi jika Anda sudah menjadi CTO, dan Anda memiliki banyak tim, maka Anda tidak akan dapat menggunakan penilaian subjektif Anda, karena Anda tidak tahu segalanya.  Anda harus menggunakan penilaian subyektif timlids Anda, dan ini merupakan masalah, karena sering timlids mendekati penilaian subyektif dengan sangat berbeda. <br><img src="https://habrastorage.org/webt/kq/sf/rv/kqsfrv2kw9zi6x8oxs-yy7xwf1k.jpeg"><br><br>  Ini adalah hal selanjutnya yang harus dilakukan.  Karena penilaian subjektif seringkali tidak cukup, Anda bisa bingung dan <strong>mengumpulkan fakta dengan tangan</strong> . <br><br>  Sebagai contoh, satu CTO dengan siapa kami berbicara entah bagaimana mencurigai tim bahwa mereka melakukan review kode terlalu lambat, tetapi tidak ada yang mempresentasikannya.  Karena dia hanya memiliki perasaan yang samar, dia memutuskan untuk mengumpulkan fakta, hanya beberapa minggu untuk menonton tim.  CTO mencatat waktu yang dibutuhkan tim untuk meninjau, dan apa yang dia temukan pada akhirnya mengejutkannya.  Ternyata 2 senior telah berkonflik untuk waktu yang lama dalam review kode, sementara mereka tidak mengeluarkannya sama sekali.  Mereka duduk seperti tikus, tidak ada yang berteriak pada siapa pun - tim tidak tahu sama sekali.  Satu-satunya hal yang mereka lakukan adalah secara berkala pergi ke pendingin, menuangkan air lagi untuk diri mereka sendiri dan berlari untuk menulis jawaban cerdas dalam ulasan kode kepada musuh mereka dalam permintaan tarik. <br><br>  Ketika CTO mengetahui, ternyata masalahnya sudah sangat tua sehingga tidak mungkin melakukan apa-apa, dan pada akhirnya salah satu programmer harus dipecat. <br><img src="https://habrastorage.org/webt/5w/tj/pj/5wtjpjcjmo7zrluzs10imywuiua.jpeg"><br><br>  <strong>Statistik Jira</strong> adalah opsi yang sering digunakan.  Ini adalah alat yang sangat berguna di mana ada informasi tentang tugas, tetapi tingkatannya cukup tinggi.  Seringkali sulit untuk memahami apa yang terjadi dalam tim secara khusus. <br><br>  Contoh sederhana - pengembang dalam sprint sebelumnya melakukan 5 tugas, yang ini - 10. Apakah mungkin untuk mengatakan bahwa ia mulai bekerja lebih baik?  Itu tidak mungkin, karena tugasnya sangat berbeda. <br><img src="https://habrastorage.org/webt/n5/7f/gr/n57fgrtcdghpsht4eqecapnxstk.jpeg"><br><br>  Solusi terakhir yang ada adalah dengan hanya menyingsingkan lengan baju Anda dan menulis <strong>skrip Anda sendiri untuk pengumpulan data otomatis</strong> .  Ini adalah cara semua CTO di perusahaan besar lebih atau kurang datang.  Dia adalah yang paling produktif, tetapi, tentu saja, yang paling sulit.  Ini tentang dia yang akan kita bicarakan hari ini. <br><br><h2>  Solusi yang dipilih <br></h2><br>  Jadi, solusi yang dipilih adalah untuk memotong skrip Anda untuk mengumpulkan analitik.  Pertanyaan utama adalah di mana mendapatkan data dan apa yang diukur. <br><br><h3>  Sumber data <br></h3><br>  Sumber data utama di mana informasi tentang pekerjaan pengembang diakumulasikan adalah: <br><br><ol><li>  <strong>Git</strong> - entitas utama: komit, cabang dan kode di dalamnya. </li><li>  <strong>Alat ulasan kode</strong> - layanan hosting git yang ulasan kode host menampung informasi tentang permintaan-tarik yang dapat digunakan. </li><li>  <strong>Pelacak</strong> tugas - informasi tentang tugas dan siklus hidupnya. </li></ol><br>  Sumber data tambahan: <br><br><ol><li>  <strong>Utusan</strong> - di sana Anda dapat, misalnya, melakukan analisis sentimen, menghitung waktu respons rata-rata pengembang terhadap permintaan informasi. </li><li>  <strong>Layanan CI</strong> yang menyimpan informasi tentang pembuatan dan rilis. </li><li>  <strong>Jajak pendapat tim.</strong> </li></ol><br>  Karena semua sumber yang saya bicarakan di atas kurang lebih standar, dan yang terakhir tidak terlalu standar, saya akan membicarakannya sedikit lebih banyak. <br><img src="https://habrastorage.org/webt/lc/fx/7q/lcfx7qdvbqptymjrw_1fumfayhc.jpeg"><br><br>  CTO lain membagikan metode ini kepada kami.  Pada akhir setiap iterasi, ia mengirim tim jajak pendapat secara otomatis, di mana hanya ada 2 pertanyaan: <br><br><ol><li>  Menurut Anda, seberapa pentingkah apa yang kami lakukan dalam iterasi ini? </li><li>  Apakah menurut Anda apa yang kami lakukan menarik? </li></ol><br>  Ini adalah cara yang cukup murah untuk mengukur suasana hati dalam tim dan, mungkin, menangkap beberapa masalah dengan motivasi. <br><br><h3>  Apa dan bagaimana mengukur <br></h3><br>  Pertama-tama, kita akan membahas metodologi pengukuran.  Metrik yang baik harus menjawab 3 pertanyaan: <br><br><ol><li>  <strong>Apakah ini penting?</strong>  Anda hanya perlu mengukur sinyal apa tentang sesuatu yang signifikan bagi perusahaan. </li><li>  <strong>Apakah sudah semakin buruk / lebih baik / sama?</strong>  Dengan metrik, harus jelas apakah itu menjadi lebih baik atau lebih buruk. </li><li>  <strong>Apa yang harus dilakukan</strong>  Dari metrik, harus jelas apa yang harus dilakukan untuk memperbaiki situasi. </li></ol><br>  Secara umum, ada baiknya mengikuti prinsip: <br><br><blockquote>  Ukur apa yang Anda inginkan dan dapat berubah. </blockquote><br>  Perlu disebutkan segera bahwa tidak ada metrik universal, dan kami tidak akan berbicara tentang metrik universal hari ini karena alasan berikut: <br><br><ul><li>  Pengembang memiliki <strong>banyak aspek kegiatan</strong> - ia bekerja dengan persyaratan, menulis kode, menguji, melakukan tinjauan kode, membuat penyebaran - dan tidak mungkin untuk memasukkan semua ini ke dalam metrik universal tunggal.  Karena itu, lebih baik fokus pada kasus-kasus individual yang dapat dideteksi. <br></li><li>  Alasan kedua mengapa satu-satunya metrik tidak layak dilakukan adalah bahwa satu metrik mudah digunakan, karena pengembangnya adalah orang-orang yang cukup pintar dan mereka akan mencari cara melakukannya sendiri. </li></ul><br><img src="https://habrastorage.org/webt/vy/q-/30/vyq-30vyjgqo4zdzz69kprxnap8.jpeg"><br><br><h2>  Pendekatan baru <br></h2><br>  Oleh karena itu, kami telah merumuskan pendekatan di mana kami pergi dari masalah: kami mencoba mengidentifikasi masalah tertentu dan memilih serangkaian metrik untuk mereka yang akan mendeteksi mereka.  Pengembang yang baik akan disebut pengembang dengan jumlah masalah paling sedikit. <br><img src="https://habrastorage.org/webt/vf/uw/sj/vfuwsj9nasynifgojqhpqi_e6y4.jpeg"><br><br>  Berdasarkan apa pilihan masalah kita?  Sederhana: kami melakukan wawancara dengan 37 CTO dan pemimpin tim yang berbicara tentang masalah yang mereka miliki di tim mereka, dan bagaimana mereka memecahkan masalah ini. <br><br>  Daftar besar yang dihasilkan, kami memprioritaskan dan mengumpulkan peretasan dan metrik kehidupan untuk masalah ini.  Kami membagi semua masalah menjadi 2 kelompok: <br><br><ol><li>  Masalah pengembang individu (pengembang bertanggung jawab atas masalah ini). <br><img src="https://habrastorage.org/webt/j2/7r/wc/j27rwcdo_9byklbwogxfvlrsz2g.jpeg"><br></li><li>  Masalah tim.  Tim bertanggung jawab atas masalah ini, sehingga untuk menyelesaikannya, Anda perlu bekerja dengan tim secara keseluruhan dan mengubah solusi proses. <br><img src="https://habrastorage.org/webt/qk/hs/vi/qkhsvia6d_svbdrqkgrpb3jdeuw.jpeg"><br></li></ol><br>  Mari kita bahas secara terperinci setiap masalah, kunci mana dari metrik yang dapat dipilih.  Mari kita mulai dengan masalah paling sederhana dan perlahan-lahan bergerak di sepanjang gradien kompleksitas ke yang paling sulit untuk diukur. <br><br><h3>  Masalah Pengembang </h3><br><h5>  <em>Kinerja pengembang kecil</em> </h5><br><img src="https://habrastorage.org/webt/el/wy/p8/elwyp8z-ibmscajp_ogprvktpl8.jpeg"><br><br>  Selain itu, "kinerja kecil" biasanya berarti bahwa <strong>pengembang hampir tidak melakukan apa-apa</strong> .  Dengan syarat, sebuah tiket digantung di Jira, entah bagaimana melaporkannya, tapi benar-benar tidak ada pekerjaan yang terjadi.  Jelas bahwa masalah ini akan muncul cepat atau lambat, Anda akan menemukannya, tetapi akan keren untuk melakukannya secara otomatis. <br><br>  <strong>Bagaimana ini bisa diukur?</strong> <br><br>  Hal pertama yang terlintas dalam pikiran adalah hanya untuk melihat <strong>jumlah hari aktif</strong> dengan pengembang.  Hari aktif akan disebut hari ketika pengembang membuat setidaknya satu komit.  Untuk pengembang penuh waktu, pada kenyataannya, jumlah karakteristik hari aktif per minggu setidaknya 3. Jika kurang, maka kami mulai mencurigai pengembang bahwa ia tidak akan melakukan banyak. <br><br>  Jelas, jumlah hari aktif saja tidak cukup.  Pengembang hanya dapat menulis kode dan tidak melakukan itu - menulis, menulis, dan kemudian suatu hari melakukan banyak kode. <br><br>  Oleh karena itu, batasan berikutnya yang kami berikan adalah bahwa pengembang juga harus memiliki <strong>sedikit kode</strong> .  Bagaimana menentukan ambang "kode kecil"?  Kami menyarankan Anda untuk membuatnya cukup kecil sehingga siapa pun, sebanyak pengembang yang berkinerja baik, dapat dengan mudah mengatasinya.  Misalnya, dalam layanan kami untuk JS ini ada sekitar 150 baris kode, dan untuk Clojure - 100 baris kode. <br><br>  Mengapa ambang kecil seperti itu?  Idenya adalah bahwa kami ingin memisahkan bukan pengembang yang bekerja keren dari pengembang yang bekerja rata-rata, tetapi mereka yang hampir tidak melakukan apa-apa, dari mereka yang melakukan setidaknya sejumlah pekerjaan yang waras. <br><br>  Tetapi bahkan jika pengembang memiliki beberapa hari aktif dan sedikit kode, ini tidak berarti sama sekali bahwa ia tidak berfungsi.  Dia bisa, misalnya, membuat perbaikan bug yang memerlukan sejumlah kecil kode.  Akibatnya, seseorang tampaknya telah melakukan banyak tugas, tetapi ia mungkin memiliki beberapa kode dan hari aktif.  Artinya, kami memperhitungkan <strong>jumlah tugas</strong> . <br><br>  Hal berikutnya yang patut diperhatikan adalah <strong>jumlah ulasan kode</strong> yang dia lakukan, karena seseorang tidak dapat melakukan tugas dan tidak menulis kode, tetapi sepenuhnya tenggelam dalam ulasan kode.  Itu terjadi. <br><br>  Karena itu, jika untuk semua metrik ini - dan hanya itu!  - pengembang tidak mencapai ambang batas apa pun, Anda dapat mencurigainya tidak berperforma baik. <br><br>  <strong>Apa yang harus dilakukan?</strong> <br><br>  Pertama, jika Anda mengetahui alasan yang sah, maka Anda tidak perlu melakukan apa pun - misalnya, pengembang dilatih atau libur.  Jika Anda tidak tahu alasan yang sah, maka mungkin ada baiknya <strong>berbicara</strong> dengan seseorang.  Jika alasan yang sah tidak muncul, maka ada baiknya untuk memantaunya lebih lanjut, dan jika masalah ini terus berulang kadang-kadang, maka mungkin ada baiknya mengucapkan selamat tinggal kepada pengembang seperti itu. <br><br>  Ini adalah masalah paling sederhana dan paling provokatif.  Mari kita beralih ke yang lebih berat. <br><br><h5>  <em>Pengembang daur ulang</em> <br></h5><br><img src="https://habrastorage.org/webt/bg/ts/jb/bgtsjbdtsakvrekrboad2ohblfo.jpeg"><br><br>  Ini juga merupakan cerita umum.  Jika seseorang mengolahnya, ia terbakar, akhirnya kehilangan motivasi dan, sebagai hasilnya, dapat meninggalkan perusahaan.  Salah satu manajer teknis yang berbicara dengan kami menceritakan kisah seperti itu.  Dia bekerja untuk sebuah perusahaan Amerika di mana budaya unjuk rasa dikembangkan dengan liar.  Akibatnya, semua pengembang, ketika mereka mulai bekerja, hanya melakukan apa yang mereka rally, dan mereka menulis kode setelah berjam-jam dan pada akhir pekan.  Akibatnya, omset tahunan pengembang di perusahaan mencapai 30%, meskipun norma industri adalah 6%. <br><br>  Akibatnya, semua manajemen teknis yang terdiri dari 30 orang diberhentikan dari kantor ini.  Agar tidak membahas hal ini, saya ingin menemukan masalah ini tepat waktu. <br><br>  <strong>Bagaimana ini bisa diukur?</strong> <br><br>  Bahkan, tidak ada yang terlalu rumit - mari kita lihat <strong>jumlah kode yang ditulis pengembang setelah jam.</strong>  Jika jumlah kode ini sebanding secara kondisional atau lebih besar dari yang dilakukannya selama jam kerja, maka pengembang secara eksplisit memprosesnya. <br><br>  Jelas, pengembang tidak hidup sebagai kode tunggal.  Masalah umum adalah bahwa ada cukup waktu untuk kode - pekerjaan utama - tetapi tidak lagi untuk tinjauan kode.  Akibatnya, tinjauan kode dilakukan pada malam hari atau akhir pekan.  Ini dapat dilacak hanya dengan <strong>jumlah komentar di tarik-permintaan</strong> setelah <strong>jam</strong> . <br><br>  Pemicu eksplisit terakhir adalah sejumlah <strong>besar tugas paralel</strong> .  Ada beberapa batasan wajar 3-4 tugas untuk pengembang.  Anda dapat melacaknya dengan git atau oleh Jira - sesuai keinginan.  Ini bekerja dengan cukup baik. <br><br>  <strong>Apa yang harus dilakukan?</strong> <br><br>  Jika Anda menemukan pengembang daur ulang, Anda harus terlebih dahulu <strong>memeriksa kalendernya</strong> untuk melihat apakah ia kelebihan beban dengan demonstrasi yang tidak berguna.  Jika kelebihan beban, disarankan untuk menguranginya, dan idealnya membuat hari pertemuan - hari yang didedikasikan ketika pengembang akan memusatkan sebagian besar pertemuan terlama sehingga ia dapat bekerja secara normal di hari-hari lain. <br><br>  Jika ini tidak berhasil, perlu untuk <strong>mendistribusikan kembali beban</strong> .  Ini sebenarnya pertanyaan yang agak rumit - bagaimana melakukannya.  Ada banyak cara berbeda.  Kami tidak akan masuk terlalu dalam, tetapi perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> keren tentang HighLoad 2017 dari Anton Potapov, di mana topik ini sangat dipertimbangkan. <br><br><h5>  <em>Pengembang tidak memiliki fokus pada pelepasan tugas</em> <br></h5><br>  Saya ingin memahami berapa banyak pengembang seperti itu di tim Anda dan berapa biaya dalam waktu. <br><img src="https://habrastorage.org/webt/in/rr/ah/inrrahhv1puubdomhkd5ijj8f0o.jpeg"><br><br>  Ini adalah situasi yang cukup umum bahwa pengembang mengambil tugas, membawanya ke status dalam tinjauan, pengujian - dan lupa tentangnya.  Kemudian dia kembali untuk revisi dan hang di sana tidak jelas berapa banyak waktu.  Saya sendiri punya pengembang di tim saya sekaligus.  Saya meremehkan masalah ini untuk waktu yang lama, sampai sekali saya menghitung jumlah waktu itu, rata-rata, membutuhkan berbagai downtime.  Akibatnya, ternyata tugas pengembang ini, rata-rata, menganggur 60% dari waktu rilis. <br><br>  <strong>Bagaimana ini bisa diukur?</strong> <br><br>  Pertama, Anda perlu mengukur semua waktu henti yang bergantung pada pengembang.  Ini adalah waktu untuk memperbaiki <strong>setelah peninjauan dan pengujian kode</strong> .  Jika Anda memiliki pengiriman berkelanjutan, ini adalah <strong>waktu tunggu rilis.</strong>  Pembatasan yang wajar harus diberlakukan pada masing-masing waktu - seperti tidak lebih dari sehari. <br><br>  Alasannya adalah sebagai berikut.  Ketika seorang pengembang datang untuk bekerja di pagi hari, akan keren baginya untuk terlebih dahulu menganalisis tugas-tugas prioritas tertinggi.  Tugas dengan prioritas tertinggi, jika tidak ada perbaikan bug atau sesuatu yang sangat penting, adalah tugas yang paling dekat dengan rilis dan rilis. <br><br>  Pemicu keren lainnya pada topik ini adalah <strong>jumlah ulasan kode yang tergantung pada pengembang, seperti pada pengulas.</strong>  Jika seseorang lupa tentang tugasnya, maka kemungkinan besar dia juga akan berhubungan dengan tugas rekan-rekannya. <br><br>  <strong>Apa yang harus dilakukan?</strong> <br><br>  Jika Anda menemukan pengembang seperti itu, jelas bermanfaat untuk menghampirinya dan <strong>berkata</strong> : "Lihat, 30-40% dari waktu Anda dihabiskan untuk downtime!" Ini biasanya bekerja sangat keren. Dalam kasus saya, misalnya, itu memiliki efek seperti itu, bahwa masalahnya hampir sepenuhnya hilang, jika tidak, Anda perlu terus <strong>memantau</strong> , katakan secara berkala, tetapi hal utama di sini adalah tidak jatuh ke manajemen mikro, karena itu akan menjadi lebih buruk. <br><br>  Oleh karena itu, jika memungkinkan, ada baiknya untuk segera berurusan dengan solusi proses.  Ini dapat, misalnya, <strong>membatasi jumlah tugas aktif</strong> , atau, jika anggaran dan waktu Anda memungkinkan, Anda dapat menulis bot atau menggunakan layanan yang akan secara otomatis melakukan <strong>ping ke</strong> pengembang jika tugas tersebut sudah dalam status tertentu terlalu lama.  Ini mungkin solusi paling keren di sini. <br><br><h5>  <em>Pengembang tidak memikirkan cukup tugas</em> <br></h5><br>  Saya pikir Anda tahu gejalanya - ini adalah perkiraan yang tidak bisa dipahami dari waktu yang dibutuhkan untuk menyelesaikan tugas yang tidak kami ikuti, tenggat waktu yang panjang pada akhirnya, peningkatan jumlah bug dalam tugas - secara umum, tidak ada yang baik. <br><img src="https://habrastorage.org/webt/lc/w9/ur/lcw9urobbr3vso7bx7znbafm63g.jpeg"><br><br>  <strong>Bagaimana ini bisa diukur?</strong> <br><br>  Saya pikir Anda tahu gejalanya - ini adalah perkiraan yang tidak bisa dipahami dari waktu yang dibutuhkan untuk menyelesaikan tugas yang tidak kami ikuti, tenggat waktu yang panjang pada akhirnya, peningkatan jumlah bug dalam tugas - secara umum, tidak ada yang baik. <br><br>  <strong>Bagaimana ini bisa diukur?</strong> <br><br>  Untuk melakukan ini, kita perlu memperkenalkan 2 metrik, yang pertama adalah kode Churn. <br><img src="https://habrastorage.org/webt/rv/gl/jx/rvgljxztmgo_qvbavzb-hlcce2e.jpeg"><br><br>  Churn adalah ukuran seberapa banyak kode yang ditulis oleh pengembang dengan sia-sia. <br><br>  Bayangkan situasinya.  Pada hari Senin, pengembang mulai melakukan tugas baru, dan menulis 100 baris kode.  Kemudian datang pada hari Selasa, dia menulis 100 baris kode baru dalam tugas ini.  Tetapi, sayangnya, kebetulan bahwa 50 baris kode yang ditulis pada hari Senin, ia menghapus, dan melepaskan tugas.  Akibatnya, 200 baris kode tampaknya dibuat dalam tugas, tetapi hanya 150 yang selamat sampai rilis, dan 50 ditulis dengan sia-sia.  50 ini kita sebut Churn.  Jadi dalam contoh ini, pengembang Churn adalah 25%. <br><br>  Menurut pendapat kami, <strong>tingkat tinggi Churn</strong> adalah pemicu keren bahwa pengembang tidak memikirkan tugas. <br><br>  Ada sebuah studi oleh perusahaan Amerika di mana mereka mengukur tingkat Churn dari 20.000 pengembang dan sampai pada kesimpulan bahwa kode Churn yang baik harus berada di kisaran 10-20%. <br><br>  Tetapi ada 2 kondisi penting: <br><br><ol><li>  High Churn baik-baik saja jika, misalnya, Anda membuat prototipe atau proyek baru.  Maka bisa sama dengan 50-60% selama beberapa bulan.  Tidak ada yang perlu dikhawatirkan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara kasar, Churn tergantung pada tahap produk - semakin stabil produk, semakin rendah seharusnya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus apa pun Anda harus berusaha untuk tingkat Churn nol - ini adalah perfeksionisme yang benar-benar berarti. </font><font style="vertical-align: inherit;">Tidak perlu memaksa pengembang untuk menulis kode yang sempurna dari awal. </font><font style="vertical-align: inherit;">Mereka akan menghabiskan banyak waktu untuk memikirkan atau mencoba untuk meretas cerita ini. </font><font style="vertical-align: inherit;">Akibatnya, waktu pengiriman hanya akan meningkat.</font></font></li></ol><br><img src="https://habrastorage.org/webt/b6/uo/t0/b6uot0xpb-9fqm6hb_j_ahslyvy.jpeg"><br><br>  ,    ,    ,     ,    Fixed Tasks,  <strong>  </strong> .    ,      . <br><br>    ,  bug fixes  ,      bug fixes .       bug fixes  3 ,  ,      .      ,       ,      ,     . <br><br>   —  <strong>    </strong> .            , ,  ,   -      . <br><br> <strong>   ?</strong> <br><br>       , ,     ,     <strong>   </strong>    .    , ,  <strong>   </strong> ,    estimation  .. <br><br>   CTO,    ,    workflow,    ,   .     ,        ,        ,        <strong>-</strong> ,     . <br><br> <strong>   Churn  Fixed Tasks</strong> <br><br>  ,        , : <br><br><ul><li>     commit message,       .    commit message,    ,   git    . </li><li>   git-squash commit'   ,    Churn    . </li><li>       git.       merge  master,  merge   ,     .      —     ,   ,    Churn  Fixed Tasks. </li></ul><br><h3>   </h3><br><img src="https://habrastorage.org/webt/rh/0r/ty/rh0rtyyvplw4n5i3uqgrmedl8l4.jpeg"><br><br>       ,      —  <strong>      </strong>  ,            .   ,    ,    ,      .     ,      -   . <br><br> ,     ,  -        3-4 .    ,     . <br><br> <strong>   ?</strong> <br><br>    —  -  ,       ,         . <br><img src="https://habrastorage.org/webt/un/nk/hb/unnkhb3dgba1yggcwjjcpwnrez4.jpeg"><br><br>       ,       3 ,    ,           (      ),     . <br><br>       ,    ,    .  — ,       . <br><br>   —   ,      <strong>      </strong> —   — ,  ,          . <br><br> <strong>   ?</strong> <br><br>     .     ,     ,   .   -      ,         . <br><br>   — , ,   .     .    ,         ,       .             . <br><br>       30-50      50-60 %.   ,     . <br><br>     ,      ,     .    ,     ,          ,                .        <strong>   </strong> . <br><img src="https://habrastorage.org/webt/a-/vo/bf/a-vobfkdyzmwrdvjitfd7ew4_nc.jpeg"><br><br>    ,       — <strong>  </strong> .  product-    ,   .      ,  ,           . <br><br> <strong>   ?</strong> <br><br>    product-   ,       ? <br><br>  , product-     ,     : <br><br><ul><li>   Churn,          ; </li><li>    ,     ,     estimation; </li><li>        in progress        product-. </li></ul><br> <strong>   ?</strong> <br><br>  <strong>  </strong>    product-  : «,     Churn    - —         ». <br><br>    «     »   ,   1-2     .        ,         product-,    . <br><img src="https://habrastorage.org/webt/rz/jv/fu/rzjvfug-i51b9anqhcwoiieih3c.jpeg"><br><br> <strong>   </strong>     .          ,  , . <br><br>    ,    ,       ,   .  ,  ,    -    ,     ,     .      ,        .     . <br><br> <strong>   ?</strong> <br><br>      ,   ,      : <br><br><ul><li>   ; </li><li>       ; </li><li>     ; </li><li>  -,        -   ,   ; </li><li>  . </li></ul><br> <strong>   ?</strong> <br><br> -,     ,      ,       <strong> </strong>      <strong></strong> ,     . <br><br> -, ,     ,  ,     <strong> </strong>  ,  ,      . <br><br>    —  -           ,   .     best practise,      ,     ,     ,  .           3   ,        3 . <br><img src="https://habrastorage.org/webt/1p/be/qg/1pbeqgn6dtqugshhhfila-7cefo.jpeg"><br><br>  ,     — <strong>  </strong> .   ,   .      -    ,      ,            -.    ,     ,        CTO,         ,           100%.    ,  -  . <br><br> <strong>   ?</strong> <br><br>      ,   <strong>legacy refactoring</strong> .      ,      .      .      ,    ,   ,     . <br><img src="https://habrastorage.org/webt/mp/ni/px/mpnipxdhwv3tehknn0v1w_ddb7a.jpeg"><br><br>   ,    <strong>  legacy refactoring</strong> ,         ,     <strong> complexity</strong> ,     ,    . <br><br> <strong>   ?</strong> <br><br>      ,  ,         .    ,    CTO.          ,        . <br><br>  CTO    ,      ,      Jira <strong>   «»</strong> .               ,  - estimation    .     ,    —        ,  .. <br><br>  CTO        .      ,     ,    , <strong>   «Hack».</strong>     -    -,   : «   Hack —  », .         grep'     «Hack»       ,          . <br><br>        .           . <br><br><h2>   </h2><br>      : <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa hal masih tidak mudah diukur. </font><font style="vertical-align: inherit;">Ini berlaku, misalnya, untuk Churn atau refactoring lama. </font><font style="vertical-align: inherit;">Diperlukan waktu untuk mempelajari cara menghitungnya.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data perlu dibersihkan dan sedikit disesuaikan dengan perintah. </font><font style="vertical-align: inherit;">Misalnya, hal biasa yang akan Anda temui jika Anda mencoba menerapkan ini - di git Anda akan melihat bahwa beberapa akun git berhubungan dengan orang yang sama. </font><font style="vertical-align: inherit;">Anda harus mempertimbangkan keduanya - ini adalah contoh sepele dari pembersihan data yang perlu dilakukan.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu memantau nilai ambang batas dan memilihnya dengan bijak, karena mereka bergantung pada tahap kehidupan perusahaan dan juga jenis perusahaan. </font><font style="vertical-align: inherit;">Apa yang baik untuk agen outsourcing mungkin tidak terlalu baik untuk perusahaan grosir.</font></font></li><li> Sebagian besar metrik yang kami cantumkan di sini hanya berfungsi untuk pengembang multi waktu, karena hanya aktivitas pengembang multi waktu yang tercermin dengan baik dalam sumber data yang tersedia: git, Jira, GitHub, pesan instan, dll. </li></ol><br><h2>  Kesimpulan </h2><br>  Kami ingin menyampaikan kepada Anda hal-hal berikut: <br><br><ul><li>  <strong>Pengembang dan tim dapat dan harus diukur</strong> .  Ini bisa sulit, tetapi bisa dilakukan. <br></li><li>  <strong>Tidak ada set kecil KPI universal</strong> .  Untuk setiap masalah, Anda perlu memilih set metrik khusus Anda.  Harus diingat bahwa Anda tidak boleh mengabaikan metrik yang paling sederhana sekalipun.  Bersama-sama mereka bisa bekerja dengan baik. <br></li><li>  Git dapat menceritakan banyak hal menarik tentang pengembangan dan pengembang, tetapi Anda harus <strong>mengikuti praktik tertentu</strong> sehingga data dapat diakses dengan mudah darinya, termasuk: <br><ul><li>  jumlah tugas dalam komit; </li><li>  tidak ada squash; </li><li>  Anda dapat menentukan waktu rilis: menggabungkan master, tag. </li></ul></li></ul><br>  <strong>Tautan dan kontak yang berguna:</strong> <br><br><ul><li>  Ada beberapa masalah bonus dan metrik untuk mereka dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi presentasi</a> . <br></li><li>  Penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> dengan artikel bermanfaat untuk manajer pengembangan <br></li><li>  Kontak Telegram: @avkiselev (Alexander Kiselev) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">sss0791</a> (Sergey Semenov). </li></ul><br><blockquote>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TeamLead Conf, mereka</a> membahas banyak masalah berbeda dalam mengelola tim pengembangan dan mencari solusi.  Jika Anda sudah berjalan sebagian, mengisi lebih dari satu tonjolan, menginjak penggaruk, mencoba berbagai pendekatan dan siap untuk menarik kesimpulan dan berbagi pengalaman Anda - kami menunggu Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat melamar</a> pertunjukan <b>hingga 10 Agustus</b> . <br><br>  Para peserta juga diharapkan untuk lebih terlibat, mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memesan tiket</a> , dan kemudian mencoba merumuskan apa yang paling menggairahkan Anda - kemudian Anda dapat mendiskusikan rasa sakit Anda dan mendapatkan hasil maksimal dari konferensi. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417411/">https://habr.com/ru/post/id417411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417399/index.html">Selamat datang: memperkenalkan pengembang baru ke tim</a></li>
<li><a href="../id417401/index.html">Akhirnya, kami memilih multimeter anggaran dengan fungsionalitas yang baik</a></li>
<li><a href="../id417405/index.html">Pengkode Otomatis dan Kecerdasan Buatan yang Kuat</a></li>
<li><a href="../id417407/index.html">Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 1</a></li>
<li><a href="../id417409/index.html">Bagaimana cara bertahan rekan satu tim di scram scalable dan mempertahankan kontrol kualitas kode</a></li>
<li><a href="../id417413/index.html">Apakah masalah pemimpin tim berbeda di St. Petersburg, cari tahu di Saint TeamLead Conf</a></li>
<li><a href="../id417415/index.html">Pelajaran pencetakan 3D. Mencetak komponen dengan ketebalan lapisan berbeda dari 3Dtool</a></li>
<li><a href="../id417419/index.html">[Yekaterinburg, pengumuman] Alice mengunjungi Kontur - hackathon untuk menciptakan keterampilan bagi asisten suara</a></li>
<li><a href="../id417421/index.html">Menjadi buta warna: percobaan empati</a></li>
<li><a href="../id417423/index.html">33 tips untuk pemasaran ICO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>