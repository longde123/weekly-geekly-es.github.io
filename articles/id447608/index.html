<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ 🕵️ 💇🏾 Evolusi CI dalam tim pengembangan seluler 👨🏽‍🎤 🖇️ 🧑🏽‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, sebagian besar produk perangkat lunak dikembangkan dalam tim. Kondisi keberhasilan untuk pengembangan tim dapat disajikan dalam bentuk skema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi CI dalam tim pengembangan seluler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/447608/">  Saat ini, sebagian besar produk perangkat lunak dikembangkan dalam tim.  Kondisi keberhasilan untuk pengembangan tim dapat disajikan dalam bentuk skema sederhana. <br><br><img src="https://habrastorage.org/webt/wd/yv/we/wdyvwe6jcuq9yygmffhk5-eqnlo.png"><br><br>  Setelah menulis kode, Anda harus memastikannya: <br><br><ol><li>  Itu bekerja. </li><li>  Tidak merusak apa pun, termasuk kode yang ditulis rekan Anda. </li></ol><br>  Jika kedua kondisi terpenuhi, maka Anda berada di jalan menuju kesuksesan.  Agar dapat dengan mudah memeriksa kondisi ini dan tidak mematikan jalur yang menguntungkan, mereka datang dengan Integrasi Berkelanjutan. <br><br>  CI adalah alur kerja di mana Anda mengintegrasikan kode Anda ke dalam kode produk umum sesering mungkin.  Dan tidak hanya berintegrasi, tetapi juga selalu memeriksa bahwa semuanya berfungsi.  Karena Anda perlu memeriksa banyak dan sering, Anda harus berpikir tentang otomatisasi.  Anda dapat memeriksa semuanya dengan traksi manual, tetapi tidak sepadan, dan itulah sebabnya. <br><a name="habracut"></a><br><ul><li>  <strong>Orang itu mahal</strong> .  Satu jam kerja dari setiap programmer lebih mahal daripada satu jam kerja dari server mana pun. </li><li>  <strong>Orang salah</strong> .  Oleh karena itu, situasi dapat muncul ketika mereka menjalankan tes pada cabang yang salah atau mengumpulkan komit yang salah untuk penguji. </li><li>  <strong>Orang-orang malas</strong> .  Secara berkala, ketika saya menyelesaikan tugas, saya berpikir: “Tapi apa yang harus diperiksa?  Saya menulis dua baris - stopudovo semuanya berfungsi! "  Saya pikir untuk sebagian dari Anda, pemikiran seperti itu kadang muncul di benak Anda.  Tetapi Anda selalu perlu memeriksa. </li></ul><br>  Bagaimana Integrasi Berkelanjutan diperkenalkan dan dikembangkan dalam tim pengembangan ponsel Avito, bagaimana mereka memperoleh dari 0 hingga 450 perangkat per hari, dan bahwa mesin-mesin membangun mengumpulkan 200 jam sehari, kata Nikolay Nesterov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">nnesterov</a> ) - peserta dalam semua perubahan evolusioner aplikasi CI / CD Android . <br><br>  Kisah ini dibangun berdasarkan contoh tim Android, tetapi sebagian besar pendekatan juga berlaku di iOS. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lz8MNATTUCU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sekali waktu, satu orang bekerja di tim Android Avito.  Menurut definisi, ia tidak memerlukan apa pun dari Integrasi Berkelanjutan: tidak ada seorang pun untuk diintegrasikan dengannya. <br><br>  Namun aplikasi bertambah, semakin banyak tugas baru yang muncul, masing-masing, tim bertambah.  Pada titik tertentu, sudah waktunya untuk lebih formal menetapkan proses mengintegrasikan kode.  Diputuskan untuk menggunakan aliran Git. <br><br><img src="https://habrastorage.org/webt/rv/qa/jd/rvqajd0kgcao3w0-vw6lnomjpc8.png"><br><br>  Konsep aliran Git diketahui: ada satu cabang pengembangan umum dalam proyek, dan untuk setiap fitur baru, pengembang memotong cabang terpisah, komit, dorong, dan ketika mereka ingin menyuntikkan kode mereka ke cabang pengembangan, buka permintaan tarik.  Untuk berbagi pengetahuan dan mendiskusikan pendekatan, kami memperkenalkan tinjauan kode, yaitu, kolega harus memeriksa dan mengkonfirmasi kode masing-masing. <br><br><h2>  Cek </h2><br>  Menonton kode dengan mata Anda itu keren, tetapi tidak cukup.  Karenanya, pemeriksaan otomatis diperkenalkan. <br><br><ul><li>  Pertama-tama, kami memeriksa <strong>perakitan ARC</strong> . </li><li>  Banyak <strong>tes Junit</strong> . </li><li>  <strong>Kami mempertimbangkan cakupan kode</strong> , karena kami menjalankan tes. </li></ul><br>  Untuk memahami bagaimana pemeriksaan ini harus dijalankan, mari kita lihat proses pengembangan di Avito. <br><br>  Secara skematis, dapat direpresentasikan sebagai berikut: <br><br><ul><li>  Pengembang menulis kode di laptop-nya.  Anda dapat menjalankan pemeriksaan integrasi di sini - dengan kait komit, atau hanya menjalankan pemeriksaan di latar belakang. </li><li>  Setelah pengembang menjalankan kode, ia membuka permintaan tarik.  Agar kodenya masuk ke cabang pengembangan, Anda harus melalui tinjauan kode dan mengumpulkan jumlah konfirmasi yang diperlukan.  Anda dapat mengaktifkan pemeriksaan dan pembuatan di sini: sampai semua bangunan berhasil, permintaan tarik tidak dapat digabungkan. </li><li>  Setelah permintaan tarik digabungkan dan kode dikembangkan, Anda dapat memilih waktu yang nyaman: misalnya, pada malam hari, ketika semua server gratis, dan mendorong pemeriksaan sesuka Anda. </li></ul><br>  Tidak ada yang suka menjalankan tes di laptop mereka.  Ketika pengembang telah menyelesaikan fitur, ia ingin meluncurkannya dengan cepat dan membuka permintaan tarik.  Jika pada saat itu beberapa cek lama diluncurkan, ini tidak hanya tidak terlalu menyenangkan, tetapi juga memperlambat pengembangan: saat laptop memeriksa sesuatu, tidak mungkin untuk bekerja secara normal di atasnya. <br><br>  Kami sangat suka menjalankan cek di malam hari, karena ada banyak waktu dan server, Anda dapat berjalan-jalan.  Namun, sayangnya, ketika kode fitur mulai dikembangkan, pengembang sudah memiliki motivasi yang jauh lebih sedikit untuk memperbaiki kesalahan yang ditemukan CI.  Saya secara berkala menemukan diri saya berpikir ketika saya melihat di laporan pagi tentang semua kesalahan yang ditemukan bahwa saya akan memperbaikinya beberapa waktu kemudian, karena sekarang di Jira ada tugas baru yang keren yang saya ingin mulai lakukan. <br><br>  Jika cek memblokir permintaan tarik, maka ada motivasi yang cukup, karena sampai build berubah hijau, kode tidak masuk ke pengembangan, yang berarti bahwa tugas tidak akan selesai. <br><br>  Sebagai hasilnya, kami memilih strategi ini: pada malam hari kami mengendarai set maksimum mungkin pemeriksaan, dan yang paling kritis dari mereka dan, yang paling penting cepat, berjalan pada permintaan tarik.  Tetapi kami tidak berhenti sampai di situ - secara paralel, kami mengoptimalkan kecepatan lulus pemeriksaan sedemikian rupa untuk memindahkannya dari mode malam ke pemeriksaan atas permintaan tarik. <br><br>  Pada saat itu, semua majelis kami berjalan cukup cepat, jadi kami hanya menyertakan perakitan ARC, tes Junit dan perhitungan cakupan kode dengan pemblokir permintaan tarik.  Mereka menyalakannya, memikirkannya, dan meninggalkan cakupan kode karena mereka pikir kami tidak membutuhkannya. <br><br>  <strong><em>Kami membutuhkan dua hari untuk menyelesaikan pengaturan CI dasar (selanjutnya, perkiraan sementara adalah perkiraan, diperlukan untuk skala).</em></strong> <br><br>  Setelah itu, mereka mulai berpikir lebih jauh - apakah kita memeriksanya dengan benar?  Apakah kita meluncurkan build berdasarkan permintaan tarik dengan benar? <br><br>  Kami mulai membangun di komit terakhir cabang dengan permintaan tarik terbuka.  Tetapi pemeriksaan terhadap komit ini hanya dapat menunjukkan bahwa kode yang ditulis pengembang berfungsi.  Tetapi mereka tidak membuktikan bahwa dia tidak merusak apa pun.  Bahkan, Anda perlu memeriksa status mengembangkan cabang setelah fitur telah disuntikkan ke dalamnya. <br><br><img src="https://habrastorage.org/webt/g7/sw/gn/g7swgnopkxqajjm-73mz9oxwbng.png"><br><br>  Untuk melakukan ini, kami menulis skrip bash sederhana <strong>premerge.sh:</strong> <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash set -e git fetch origin develop git merge origin/develop</span></span></code> </pre> <br>  Di sini, semua perubahan terbaru dari pengembangan hanya ditarik dan digabung ke cabang saat ini.  Kami menambahkan skrip premerge.sh sebagai langkah pertama dari semua build dan mulai memeriksa apa yang kami inginkan, yaitu <strong>integrasi</strong> . <br><br>  <strong><em>Butuh tiga hari untuk melokalisasi masalah, menemukan solusi, dan menulis skrip ini.</em></strong> <br><br>  Aplikasi dikembangkan, semakin banyak tugas muncul, tim tumbuh, dan muncul. Kadang-kadang kami mulai mengecewakan kami.  Dalam mengembangkan menembus perubahan yang bertentangan yang merusak majelis. <br><br>  Contoh bagaimana ini terjadi: <br><br><img src="https://habrastorage.org/webt/xc/dm/e-/xcdme-bg7rwxkmgip5pgh4hlc8u.png"><br><br>  Dua pengembang secara bersamaan mulai menggergaji fitur A dan B. Pengembang fitur A menemukan fungsi <code>answer()</code> digunakan dalam proyek dan, seperti scout yang baik, menghilangkannya.  Pada saat yang sama, pengembang fitur B menambahkan panggilan baru ke fungsi ini di cabangnya. <br><br>  Pengembang menyelesaikan pekerjaan dan pada saat yang sama permintaan tarik terbuka.  Build build, premerge.sh memeriksa kedua permintaan tarik untuk status pengembangan baru - semua cek berwarna hijau.  Setelah itu fitur permintaan tarik A digabung, fitur permintaan tarik B digabung ... Boom!  Mengembangkan istirahat karena dalam mengembangkan kode ada panggilan ke fungsi yang tidak ada. <br><br><img src="https://habrastorage.org/webt/zk/im/_r/zkim_rji20ahq4fyztlnc-twxwi.png"><br><br>  Ketika tidak akan berkembang, ini adalah <strong>bencana lokal</strong> .  Seluruh tim tidak dapat mengumpulkan dan memberikan apa pun untuk pengujian. <br><br>  Kebetulan saya paling sering terlibat dalam tugas infrastruktur: analitik, jaringan, basis data.  Artinya, saya menulis fungsi dan kelas yang digunakan pengembang lain.  Karena ini, saya sangat sering masuk ke situasi seperti itu.  Saya bahkan punya gambar seperti itu pada satu waktu. <br><br><img src="https://habrastorage.org/webt/xo/vj/6e/xovj6ea0xjjvuoxfgnrrhbskxta.jpeg"><br><br>  Karena ini tidak cocok untuk kami, kami mulai mencari tahu cara mencegahnya. <br><br><h2>  Bagaimana tidak putus berkembang </h2><br>  Opsi pertama: <strong>membangun kembali semua permintaan tarik ketika peningkatan dikembangkan.</strong>  Jika dalam contoh kami permintaan tarik dengan fitur A pertama kali dikembangkan, permintaan tarik fitur B akan dibangun kembali, dan, karenanya, pemeriksaan akan gagal karena kesalahan kompilasi. <br><br>  Untuk memahami berapa lama, pertimbangkan sebuah contoh dengan dua PR.  Kami membuka dua PR: dua build, dua peluncuran uji.  Setelah PR pertama dituangkan ke dalam pengembangan, yang kedua harus dibangun kembali.  Secara total, dua peluncuran cek PR mengambil tiga PR: 2 + 1 = 3. <br><br>  Pada prinsipnya, itu normal.  Tapi kami melihat statistik, dan situasi khas di tim kami adalah 10 PR terbuka, dan kemudian jumlah cek adalah jumlah perkembangan: 10 + 9 + ... + 1 = 55. Artinya, untuk menerima 10 PR, Anda harus membangun kembali 55 kali.  Dan ini dalam situasi yang ideal, ketika semua cek lulus pertama kali, ketika tidak ada yang membuka permintaan tarik tambahan saat sepuluh ini sedang diproses. <br><br>  Bayangkan diri Anda seorang pengembang yang perlu punya waktu untuk menekan tombol "gabungkan" terlebih dahulu, karena jika ini dilakukan oleh tetangga, Anda harus menunggu sampai semua majelis melewati lagi ... Tidak, itu tidak akan berhasil, itu akan memperlambat pembangunan secara serius. <br><br>  Cara kedua yang mungkin: <strong>untuk mengumpulkan permintaan tarik setelah peninjauan kode.</strong>  Artinya, buka permintaan tarik, kumpulkan jumlah pembaruan yang diperlukan dari kolega, perbaiki apa yang Anda butuhkan, lalu jalankan build.  Jika mereka berhasil, tarik permintaan bergabung dengan mengembangkan.  Dalam hal ini, tidak ada restart lagi, tetapi umpan baliknya banyak melambat.  Sebagai pengembang, ketika saya membuka permintaan tarik, saya langsung ingin melihat apakah dia mau.  Misalnya, jika tes macet, Anda harus memperbaikinya dengan cepat.  Dalam kasus pembangunan yang tertunda, umpan balik melambat, yang berarti seluruh pengembangan.  Ini juga tidak cocok untuk kita. <br><br>  Akibatnya, hanya opsi ketiga yang tersisa - untuk <strong>berputar</strong> .  Semua kode kami, semua sumber kami disimpan di repositori di server Bitbucket.  Karenanya, kami harus mengembangkan plugin untuk Bitbucket. <br><br><img src="https://habrastorage.org/webt/kf/ye/yx/kfyeyxalmkommukvjics9uvinn4.png"><br><br>  Plugin ini menimpa mekanisme gabungan permintaan tarik.  Awal adalah standar: PR terbuka, semua majelis mulai, ulasan kode melewati.  Tetapi setelah peninjauan kode telah berlalu, dan pengembang memutuskan untuk mengklik "gabung", plugin memeriksa untuk melihat kondisi apa yang terjadi pada pemeriksaan pengembangan.  Jika, setelah membangun, mengembangkan pembaruan yang berhasil, plugin tidak akan memungkinkan Anda untuk menggabungkan permintaan tarikan seperti itu ke cabang utama.  Ini hanya akan memulai kembali pembangunan relatif terhadap pengembangan segar. <br><br><img src="https://habrastorage.org/webt/_v/_s/0z/_v_s0zaf1bjvxn8oiwekagtj37a.png"><br><br>  Dalam contoh kami dengan perubahan yang bertentangan, build tersebut akan gagal karena kesalahan kompilasi.  Dengan demikian, pengembang fitur B harus memperbaiki kode, memulai kembali pemeriksaan, kemudian plugin akan secara otomatis menerapkan permintaan tarik. <br><br>  Sebelum menerapkan plugin ini, kami memiliki rata-rata 2,7 tes berjalan per permintaan tarik.  Dengan plugin tersebut ada 3,6 peluncuran.  Itu cocok untuk kita. <br><br>  Perlu dicatat bahwa plugin ini memiliki kekurangan: plugin ini hanya me-restart build sekali saja.  Bagaimanapun, itu adalah jendela kecil tetap melalui mana perubahan yang saling bertentangan dapat berkembang.  Tetapi probabilitas ini tidak tinggi, dan kami membuat kompromi antara jumlah awal dan probabilitas kegagalan ini.  Selama dua tahun, tembakannya hanya sekali, karena itu, mungkin tidak sia-sia. <br><br>  <strong><em>Kami butuh dua minggu untuk menulis versi pertama plugin untuk Bitbucket.</em></strong> <br><br><h3>  Cek Baru </h3><br>  Sementara itu, tim kami terus berkembang.  Cek baru ditambahkan. <br><br>  Kami berpikir: mengapa memperbaiki kesalahan jika bisa dicegah?  Maka mereka memperkenalkan <strong>analisis kode statis</strong> .  Kami mulai dengan serat, yang termasuk dalam Android SDK.  Tetapi pada saat itu dia sama sekali tidak tahu cara bekerja dengan kode Kotlin, dan kami sudah memiliki 75% aplikasi yang ditulis dalam Kotlin.  Oleh karena itu, <strong>pemeriksaan Android Studio bawaan</strong> ditambahkan ke serat <strong>.</strong> <br><br>  Untuk melakukan ini, saya harus sangat sesat: mengambil Android Studio, kemas di Docker dan jalankan di CI dengan monitor virtual sehingga berpikir bahwa itu berjalan pada laptop sungguhan.  Tapi itu berhasil. <br><br>  Juga pada saat ini, kami mulai menulis banyak <strong>tes instrumentasi</strong> dan mengimplementasikan <strong>pengujian tangkapan layar</strong> .  Ini adalah ketika tangkapan layar referensi dihasilkan untuk tampilan kecil yang terpisah, dan pengujiannya adalah tangkapan layar diambil dari tampilan dan dibandingkan secara langsung dengan piksel referensi demi piksel.  Jika ada perbedaan, itu berarti bahwa tata letak telah pergi ke suatu tempat atau ada sesuatu yang salah dalam gaya. <br><br>  Tetapi tes instrumentasi dan uji tangkapan layar harus dijalankan pada perangkat: pada emulator atau pada perangkat nyata.  Mengingat ada banyak tes dan mereka sering mengejar, Anda memerlukan seluruh peternakan.  Untuk memulai pertanian Anda sendiri terlalu melelahkan, jadi kami menemukan opsi yang sudah jadi - Firebase Test Lab. <br><br><h3>  Laboratorium uji Firebase </h3><br>  Itu dipilih karena Firebase adalah produk Google, yaitu, itu harus dapat diandalkan dan tidak akan pernah mati.  Harga terjangkau: $ 5 per jam untuk perangkat nyata, $ 1 per jam untuk emulator. <br><br>  <strong><em>Butuh sekitar tiga minggu untuk menerapkan Firebase Test Lab di CI kami.</em></strong> <br><br>  Tetapi tim terus tumbuh, dan Firebase, sayangnya, mulai mengecewakan kami.  Pada saat itu, dia tidak memiliki SLA.  Terkadang Firebase membuat kami menunggu hingga jumlah perangkat yang diperlukan untuk pengujian menjadi gratis, dan tidak segera mulai menjalankannya, seperti yang kami inginkan.  Menunggu dalam antrean memakan waktu hingga setengah jam, dan ini adalah waktu yang sangat lama.  Tes instrumentasi berjalan di setiap PR, keterlambatan sangat memperlambat pengembangan, dan kemudian tagihan bulanan datang dengan jumlah bulat.  Secara umum, diputuskan untuk meninggalkan Firebase dan melihat sendiri, karena tim sudah cukup berkembang. <br><br><h3>  Docker + python + bash </h3><br>  Kami membawa buruh pelabuhan, memasukkan emulator ke dalamnya, menulis program Python sederhana yang pada waktu yang tepat meningkatkan jumlah emulator yang tepat dalam versi yang tepat dan menghentikannya jika perlu.  Dan, tentu saja, beberapa skrip bash - di mana tanpa itu? <br><br>  <strong><em>Butuh lima minggu untuk menciptakan lingkungan pengujian kami sendiri.</em></strong> <br><br>  Akibatnya, setiap permintaan tarik memiliki daftar cek yang luas dan menghalangi digabung: <br><br><ul><li>  Majelis ARC; </li><li>  Tes Junit </li><li>  Lint; </li><li>  Android Studio memeriksa; </li><li>  Tes instrumentasi; </li><li>  Tes tangkapan layar. </li></ul><br>  Ini mencegah banyak kemungkinan kerusakan.  Secara teknis, semuanya bekerja, tetapi pengembang mengeluh bahwa menunggu hasil terlalu lama. <br><br>  Terlalu lama berapa?  Kami mengunggah data dari Bitbucket dan TeamCity ke sistem analisis dan menyadari bahwa <strong>waktu tunggu rata</strong> - <strong>rata adalah 45 menit</strong> .  Artinya, pengembang, membuka permintaan tarik, rata-rata mengharapkan hasil pembangunan 45 menit.  Menurut pendapat saya, ini banyak, dan Anda tidak bisa bekerja seperti itu. <br><br>  Tentu saja, kami memutuskan untuk mempercepat semua bangunan kami. <br><br><h2>  Mempercepat </h2><br>  Melihat bahwa sering membangun sejalan, hal pertama yang kami <strong>beli adalah besi</strong> - pengembangan luas adalah yang paling sederhana.  Bangun berhenti berdiri dalam antrean, tetapi waktu tunggu berkurang hanya sedikit, karena beberapa cek sendiri mengejar untuk waktu yang sangat lama. <br><br><h3>  Kami menghapus cek terlalu lama </h3><br>  Integrasi Berkelanjutan kami dapat menangkap jenis kesalahan dan masalah ini. <br><br><ul><li>  <strong>Tidak akan</strong> .  CI dapat menangkap kesalahan kompilasi ketika, karena perubahan yang bertentangan, sesuatu tidak terjadi.  Seperti yang saya katakan, maka tidak ada yang bisa mengumpulkan apa pun, perkembangan meningkat, dan semua orang menjadi gugup. </li><li>  <strong>Bug dalam perilaku</strong> .  Misalnya, ketika aplikasi dibangun, tetapi ketika Anda mengklik tombol itu crash, atau tombol tidak ditekan sama sekali.  Ini buruk karena bug semacam itu dapat menjangkau pengguna. </li><li>  <strong>Bug dalam tata letak</strong> .  Misalnya, tombol ditekan, tetapi dipindahkan 10 piksel ke kiri. </li><li>  <strong>Peningkatan utang teknis</strong> . </li></ul><br>  Melihat daftar ini, kami menyadari bahwa hanya dua poin pertama yang kritis.  Kami ingin menangkap masalah seperti itu terlebih dahulu.  Bug dalam tata letak terdeteksi pada tahap tinjauan desain dan kemudian diperbaiki dengan mudah.  Bekerja dengan hutang teknis membutuhkan proses dan perencanaan yang terpisah, jadi kami memutuskan untuk tidak memeriksa permintaan tarik. <br><br>  Berdasarkan klasifikasi ini, kami mengguncang seluruh daftar cek.  <strong>Coret Lint</strong> dan tunda peluncurannya untuk malam ini: hanya supaya memberikan laporan tentang berapa banyak masalah yang ada dalam proyek.  Kami sepakat untuk bekerja secara terpisah dengan hutang teknis, tetapi <strong>sepenuhnya menolak cek Android Studio</strong> .  Studio Android Docker untuk meluncurkan inspeksi terdengar menarik, tetapi hal itu membawa banyak masalah dalam dukungan.  Setiap pembaruan ke versi Android Studio adalah perjuangan melawan bug yang tidak jelas.  Juga sulit untuk mempertahankan tes tangkapan layar, karena perpustakaan tidak bekerja dengan sangat stabil, ada kesalahan positif.  <strong>Tes tangkapan layar dihapus dari daftar cek</strong> . <br><br>  Akibatnya, kami telah meninggalkan: <br><br><ul><li>  Majelis ARC; </li><li>  Tes Junit </li><li>  Tes instrumentasi. </li></ul><br><br><h3>  Cache jarak jauh gradle </h3><br>  Tanpa cek berat, segalanya menjadi lebih baik.  Tetapi tidak ada batasan untuk kesempurnaan! <br><br>  Aplikasi kami telah dipecah menjadi sekitar 150 modul gradle.  Biasanya, dalam hal ini, cache jarak jauh Gradle berfungsi dengan baik, dan kami memutuskan untuk mencobanya. <br><br>  Cache jarak jauh gradle adalah layanan yang dapat membuat cache membangun artefak untuk tugas-tugas individu dalam modul terpisah.  Gradle, alih-alih benar-benar menyusun kode, mengetuk cache jarak jauh melalui HTTP dan menanyakan apakah seseorang telah melakukan tugas ini.  Jika demikian, cukup unduh hasilnya. <br><br>  <strong><em>Memulai cache jarak jauh Gradle mudah karena Gradle menyediakan gambar Docker.</em></strong>  <strong><em>Kami berhasil melakukan ini dalam tiga jam.</em></strong> <br><br>  Yang diperlukan hanyalah meluncurkan Docker dan mendaftarkan satu baris dalam proyek.  Tetapi meskipun Anda bisa memulainya dengan cepat sehingga semuanya bekerja dengan baik, itu akan memakan banyak waktu. <br><br>  Di bawah ini adalah grafik cache yang hilang. <br><br><img src="https://habrastorage.org/webt/je/0j/an/je0jansmt1nkhgiqhwybnmc2_fs.png"><br><br>  Pada awalnya, persentase kesalahan melewati cache adalah sekitar 65. Tiga minggu kemudian, kami berhasil membawa nilai ini menjadi 20%.  Ternyata tugas yang dikumpulkan aplikasi Android memiliki dependensi transitif yang aneh, karena Gradle melewatkan cache. <br><br>  Dengan menghubungkan cache, kami sangat mempercepat perakitan.  Namun terlepas dari perakitan, tes instrumentasi masih mengejar, dan mereka mengejar untuk waktu yang lama.  Mungkin tidak semua tes perlu dikejar untuk setiap permintaan tarik.  Untuk mengetahuinya, kami menggunakan analisis dampak. <br><br><h3>  Analisis dampak </h3><br>  Berdasarkan permintaan, kami membangun git diff dan menemukan modul Gradle yang dimodifikasi. <br><br><img src="https://habrastorage.org/webt/yg/xn/ki/ygxnkisjdskb-qkqxoccaywcu5a.png"><br><br>  Masuk akal untuk menjalankan hanya tes instrumentasi yang menguji modul yang dimodifikasi dan semua modul yang bergantung padanya.  Tidak ada gunanya menjalankan tes untuk modul tetangga: kode tidak berubah di sana, dan tidak ada yang dapat merusak. <br><br>  Tes instrumentasi tidak begitu sederhana, karena harus ditempatkan di modul Aplikasi tingkat atas.  Kami menerapkan heuristik analisis bytecode untuk memahami modul mana masing-masing tes milik. <br><br>  <strong><em>Butuh sekitar delapan minggu untuk meningkatkan tes instrumentasi untuk menguji hanya modul yang terlibat.</em></strong> <br><br>  Tindakan percepatan verifikasi telah berhasil.  Dari 45 menit kami mencapai sekitar 15. Seperempat jam untuk menunggu build sudah normal. <br><br>  Tetapi sekarang para pengembang telah mulai mengeluh bahwa tidak jelas bagi mereka yang membangun sedang diluncurkan, di mana log akan melihat, mengapa build itu merah, tes mana yang jatuh, dll. <br><br><img height="487" src="https://habrastorage.org/webt/ez/ev/wl/ezevwlalp50tf9bcret2aff7fte.png"><br><br>  Masalah umpan balik memperlambat pengembangan, jadi kami mencoba memberikan informasi yang paling dimengerti dan terperinci tentang setiap PR dan pengembangan.  Kami mulai dengan komentar pada Bitbucket untuk PR, yang menunjukkan bangunan mana yang jatuh dan mengapa, menulis pesan yang ditargetkan di Slack.  Pada akhirnya, mereka membuat dasbor untuk halaman PR dengan daftar semua build yang sedang berjalan dan statusnya: sejalan, dimulai, macet, atau berakhir.  Anda dapat mengklik build dan membuka log-nya. <br><br><img src="https://habrastorage.org/webt/d5/hu/fr/d5hufrypmfupj3g8k4snhrksy9w.png"><br><br>  <strong><em>Enam minggu dihabiskan untuk umpan balik terperinci.</em></strong> <br><br><h2>  Paket </h2><br>  Kami lolos ke riwayat terbaru.  Setelah menyelesaikan pertanyaan tentang umpan balik, kami pergi ke tingkat yang baru - kami memutuskan untuk membangun pertanian emulator kami sendiri.  Ketika ada banyak tes dan emulator, mereka sulit untuk dikelola.  Akibatnya, semua emulator kami pindah ke cluster K8 dengan manajemen sumber daya yang fleksibel. <br><br>  Selain itu, ada rencana lain. <br><br><ul><li>  <strong>Return Lint</strong> (dan analisis statis lainnya).  Kami sudah bekerja ke arah ini. </li><li>  Jalankan semua <strong>tes ujung ke ujung</strong> pada pemblokir PR pada semua versi SDK. </li></ul><br>  Jadi, kami menelusuri sejarah perkembangan Integrasi Berkelanjutan di Avito.  Sekarang saya ingin memberikan saran dari sudut pandang yang berpengalaman. <br><br><h1>  Kiat </h1><br>  Jika saya hanya bisa memberikan satu saran, ini adalah ini: <br><br><blockquote>  Harap berhati-hati dengan skrip shell! </blockquote><br>  Bash adalah alat yang sangat fleksibel dan kuat, sangat nyaman dan cepat untuk menulis skrip di atasnya.  Tapi bersamanya Anda bisa jatuh ke dalam perangkap, dan kami, sayangnya, jatuh ke dalamnya. <br><br>  Semuanya dimulai dengan skrip sederhana yang berjalan di mesin build kami: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash ./gradlew assembleDebug</span></span></code> </pre> <br>  Tapi, seperti yang Anda tahu, semuanya berkembang dan semakin rumit dari waktu ke waktu - mari kita jalankan satu skrip dari yang lain, mari kita berikan beberapa parameter di sana - pada akhirnya saya harus menulis fungsi yang menentukan tingkat bash bersarang seperti apa kita saat ini untuk mengganti tanda kutip yang diperlukan, sehingga semuanya dimulai. <br><br><img src="https://habrastorage.org/webt/rt/o6/vp/rto6vp4hs-ucbefd_3pbzehvx0a.png"><br><br>  Anda bisa membayangkan kerja keras yang terlibat dalam mengembangkan skrip tersebut.  Saya menyarankan Anda untuk tidak jatuh ke dalam perangkap ini. <br><br>  Apa yang bisa diganti? <br><br><ul><li>  Bahasa scripting apa pun.  Menulis dengan <strong>Skrip Python atau Kotlin</strong> lebih nyaman karena merupakan pemrograman, bukan skrip. </li><li>  Atau jelaskan semua logika build dalam bentuk <strong>tugas Gradle khusus</strong> untuk proyek Anda. </li></ul><br>  Kami memutuskan untuk memilih opsi kedua, dan sekarang kami secara sistematis menghapus semua skrip bash dan menulis banyak shuffles gradle khusus. <br><br>  <strong>Kiat # 2: simpan infrastruktur Anda dalam kode.</strong> <br><br>  Akan lebih mudah bila konfigurasi Integrasi Berkelanjutan disimpan bukan di antarmuka Jenkins atau TeamCity UI, dll., Tetapi sebagai file teks langsung di repositori proyek.  Ini memberikan kemampuan versi.  Tidak akan sulit untuk memutar kembali atau mengumpulkan kode di cabang lain. <br><br>  Skrip dapat disimpan dalam proyek.  Dan apa yang harus dilakukan dengan lingkungan? <br><br>  <strong>Kiat # 3: Docker dapat membantu dengan lingkungan.</strong> <br><br>  Sayangnya itu pasti akan membantu pengembang Android, iOS belum. <br><br>  Ini adalah contoh file buruh pelabuhan sederhana yang berisi jdk dan android-sdk: <br><br><pre> <code class="plaintext hljs">FROM openjdk:8 ENV SDK_URL="https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip" \ ANDROID_HOME="/usr/local/android-sdk" \ ANDROID_VERSION=26 \ ANDROID_BUILD_TOOLS_VERSION=26.0.2 # Download Android SDK RUN mkdir "$ANDROID_HOME" .android \ &amp;&amp; cd "$ANDROID_HOME" \ &amp;&amp; curl -o sdk.zip $SDK_URL \ &amp;&amp; unzip sdk.zip \ &amp;&amp; rm sdk.zip \ &amp;&amp; yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses # Install Android Build Tool and Libraries RUN $ANDROID_HOME/tools/bin/sdkmanager --update RUN $ANDROID_HOME/tools/bin/sdkmanager "build-tools;${ANDROID_BUILD_TOOLS_VERSION}" \ "platforms;android-${ANDROID_VERSION}" \ "platform-tools" RUN mkdir /application WORKDIR /application</code> </pre><br>  Setelah menulis file buruh pelabuhan ini (saya akan memberi tahu Anda sebuah rahasia, Anda tidak dapat menulisnya, tetapi menariknya dari GitHub) dan mengumpulkan gambar, Anda mendapatkan mesin virtual tempat Anda dapat membangun aplikasi dan menjalankan tes Junit. <br><br>  Dua argumen utama mengapa ini masuk akal adalah skalabilitas dan pengulangan.  Dengan menggunakan buruh pelabuhan, Anda dapat dengan cepat mengumpulkan selusin agen bangunan yang akan memiliki lingkungan yang persis sama dengan yang lama.  Ini membuat hidup lebih mudah bagi insinyur CI.  Mendorong android-sdk ke buruh pelabuhan cukup sederhana, dengan emulator sedikit lebih rumit: Anda harus sedikit berolahraga (baik, atau unduh yang sudah selesai dari GitHub). <br><br>  <strong>Kiat nomor 4: jangan lupa bahwa cek dilakukan bukan untuk kepentingan cek, tetapi untuk orang-orang.</strong> <br><br>  Umpan balik yang cepat dan, yang paling penting, jelas adalah sangat penting bagi pengembang: apa yang mereka langgar, tes apa yang gagal, di mana log pembangunan. <br><br>  <strong>Kiat # 5: Bersikap pragmatis dengan Integrasi Berkelanjutan.</strong> <br><br>  Pahami dengan jelas jenis kesalahan apa yang ingin Anda cegah, seberapa banyak Anda bersedia menghabiskan sumber daya, waktu, waktu komputer.  Cek yang terlalu lama dapat, misalnya, dijadwal ulang semalam.  Dan mereka yang menangkap kesalahan yang tidak terlalu penting harus sepenuhnya ditinggalkan. <br><br>  <strong>Kiat nomor 6: gunakan alat yang sudah jadi.</strong> <br><br>  Sekarang ada banyak perusahaan yang menyediakan cloud CI. <br><br><img src="https://habrastorage.org/webt/7a/dr/k3/7adrk3z_1xnccybehwal8sfi-pi.png"><br><br>  Untuk tim kecil, ini jalan keluar yang bagus.  Anda tidak perlu memelihara apa pun, cukup membayar sejumlah uang, kumpulkan aplikasi Anda dan bahkan uji coba instrumentasi. <br><br>  <strong>Kiat # 7: dalam tim besar, solusi internal lebih menguntungkan.</strong> <br><br>  Namun cepat atau lambat, dengan pertumbuhan tim akan menjadi solusi in-house yang lebih menguntungkan.  Ada satu hal dengan keputusan ini.  Di bidang ekonomi, ada hukum pengembalian yang semakin menurun: dalam proyek apa pun, setiap peningkatan selanjutnya akan semakin sulit, membutuhkan semakin banyak investasi. <br><br>  Ekonomi menggambarkan seluruh hidup kita, termasuk Integrasi Berkelanjutan.  Saya membuat jadwal kerja untuk setiap tahap pengembangan Integrasi Berkelanjutan kami. <br><br><img src="https://habrastorage.org/webt/es/za/8w/esza8woeimanj5auez2iz9js7di.png"><br><br>  Dapat dilihat bahwa setiap perbaikan diberikan semakin sulit.  Melihat grafik ini, kita dapat memahami bahwa pengembangan Integrasi Berkelanjutan harus konsisten dengan pertumbuhan ukuran tim.  Untuk tim yang terdiri dari dua orang, menghabiskan 50 hari mengembangkan pertanian emulator internal adalah ide yang biasa-biasa saja.  Tetapi pada saat yang sama, bagi tim besar untuk tidak melakukan Integrasi Berkelanjutan sama sekali juga merupakan ide yang buruk, karena masalah integrasi, memperbaiki komunikasi, dll.  itu akan membutuhkan lebih banyak waktu. <br><br>  Kami mulai dengan fakta bahwa otomatisasi diperlukan karena orang mahal, mereka keliru dan malas.  Tetapi orang-orang juga mengotomatisasi.  Oleh karena itu, semua masalah yang sama ini berlaku untuk otomasi. <br><br><ul><li>  Otomatis itu mahal.  Ingat jadwal kerja. </li><li>  Dalam otomatisasi, orang membuat kesalahan. </li><li>  Otomasi terkadang sangat malas, karena semuanya berjalan seperti itu.  Kenapa lagi membaik, mengapa semua Integrasi Terus-Menerus ini? </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi saya punya statistik: di 20% dari kesalahan majelis tertangkap. </font><font style="vertical-align: inherit;">Dan ini bukan karena pengembang kami menulis kode dengan buruk. </font><font style="vertical-align: inherit;">Ini karena pengembang yakin bahwa jika mereka membuat kesalahan, itu tidak akan berkembang, itu akan ditangkap oleh cek otomatis. </font><font style="vertical-align: inherit;">Dengan demikian, pengembang dapat menghabiskan lebih banyak waktu menulis kode dan hal-hal menarik, daripada mengejar dan memeriksa sesuatu secara lokal. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlibat dalam Integrasi Berkelanjutan. </font><font style="vertical-align: inherit;">Namun dalam jumlah sedang.</font></font></strong> <br><br><blockquote> ,        ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a>        .            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .     22-23   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447608/">https://habr.com/ru/post/id447608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447592/index.html">WhatsApp di telapak tangan Anda: di mana dan bagaimana Anda dapat mendeteksi artefak forensik?</a></li>
<li><a href="../id447594/index.html">Instrumen khusus: ketika plang tidak cukup</a></li>
<li><a href="../id447598/index.html">Menulis Permainan Kartu Memori di Swift</a></li>
<li><a href="../id447604/index.html">Gigi halus, C ++ dan matematika - bagaimana mereka terkait? Percakapan dengan Align</a></li>
<li><a href="../id447606/index.html">CLRium # 5 Pengumpul Sampah: Peter - Habis</a></li>
<li><a href="../id447610/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Tiga Keamanan jaringan. Bagian tiga</a></li>
<li><a href="../id447612/index.html">Pusat Data Luar Angkasa. Terjemahan teks dari peluncuran server ke stratosfer</a></li>
<li><a href="../id447614/index.html">Anda tidak akan bisa menyelesaikan masalah ini saat wawancara</a></li>
<li><a href="../id447616/index.html">Menghubungkan Aquastorozh ke Smart Home di Z-Wave</a></li>
<li><a href="../id447618/index.html">Basis data layanan streaming Kanopy membocorkan hingga 40 juta entri log tentang film yang dilihat oleh pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>