<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷 👴🏼 🛣️ 用Ghidra打破简单的“裂缝”-第1部分 🙉 🚶🏾 🚏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="许多人可能已经第一手知道这是哪种野兽-Ghidra （“九头蛇”），以及它是如何用第一手吃掉该程序的，尽管该工具仅在今年3月才公开提供。 我不会对Hydra，其功能等的描述打扰读者。 我敢肯定，那些已经成为主题的人已经自己研究了这些，而那些还没有成为主题的人可以随时进行研究，因为现在可以很容易地在I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用Ghidra打破简单的“裂缝”-第1部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447450/"> 许多人可能已经第一手知道这是哪种野兽<b>-Ghidra</b> （“九头蛇”），以及它是如何用第一手吃掉该程序的，尽管该工具仅在今年3月才公开提供。 我不会对Hydra，其功能等的描述打扰读者。 我敢肯定，那些已经成为主题的人已经自己研究了这些，而那些还没有成为主题的人可以随时进行研究，因为现在可以很容易地在Internet上找到详细的信息。 顺便说一下，Habra（它的插件开发）的一个方面已经在Habré（出色的文章！）中进行了介绍。我将仅给出主要链接： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NSA网站上的官方页面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github项目</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">首次在Hacker Magazine上发表评论</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出色的YouTube频道，带有Ghidra中的解析程序</a> </li></ul><br> 因此，Hydra是一款<em>具有模块化结构</em>的<em>免费跨平台交互式反汇编程序和反编译器，它支持几乎所有主要的CPU架构，并且具有灵活的图形界面，可用于处理反汇编代码，内存，恢复的（反编译）代码，调试符号等</em> 。 <br><br> 让我们尝试用这款九头蛇打破一些东西！ <br><a name="habracut"></a><br><h2> 步骤1.找到并研究裂纹 </h2><br> 作为“受害者”，我们找到了一个简单的“破解”程序。 我只是去了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cramess.one</a> ，在搜索中指出了难度级别= 2-3（“简单”和“中等”），程序的源语言=“ C / C ++”，平台＝“ Multiplatform”，如下面的屏幕截图所示： <br><br><img src="https://habrastorage.org/webt/oz/hh/4w/ozhh4w-nraygltspefvjnyrvpjk.png"><br><br> 搜索返回2个结果（下面的绿色）。 第一次破解是16位的，没有在我的Win10 64位上启动，但是第二次<b>破解</b> （ <b>seveb的level_2</b> ）出现了。 您可以从此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>下载它。 <br><br> 下载并解压破解包； 如站点上所示，存档的密码为<b>cramess.de</b> 。 在档案中，我们找到了与Linux和Windows对应的两个目录。 在我的机器上，我进入Windows目录，在其中遇到了唯一的“可执行文件” <b>-level_2.exe</b> 。 让我们跑步，看看她想要什么： <br><br><img src="https://habrastorage.org/webt/qx/mu/yj/qxmuyjfvnatrgoggnmet17egii8.png"><br><br> 看起来真是个无赖！ 在启动时，该程序不显示任何内容。 我们尝试再次运行它，将一个任意字符串作为参数传递给它（突然间，它在等待键吗？）-再也没有什么……但是不要绝望。 假设我们还必须找出启动参数作为任务！ 是时候揭开我们的“瑞士刀”了-九头蛇。 <br><br><h2> 步骤2.在Hydra中创建一个项目并进行初步分析 </h2><br> 假设您已经安装了Hydra。 如果还没有，那么一切都很简单。 <br><br><div class="spoiler">  <b class="spoiler_title">安装Ghidra</b> <div class="spoiler_text">  1）安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JDK</a>版本11或更高版本（我有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">12</a> ） <br><br>  2）下载Hydra（例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从此处</a> ）并安装（在撰写本文时，Hydra的最新版本是9.0.2，我有9.0.1） <br></div></div><br> 我们启动Hydra，并在打开的项目管理器中立即创建一个新项目。 我给它起名为<b>crackme3</b> （即已经为我创建了crackme和crackme2项目）。 该项目实际上是文件目录，您可以向其中添加任何文件以进行研究（exe，dll等）。 我们将立即添加我们的level_2.exe（ <b>文件|导入</b>或只是<b>I</b>键）： <br><br><img src="https://habrastorage.org/webt/sb/gl/_e/sbgl_e0acdolgbxtvjnuohiscua.png"><br><br> 我们看到，在导入之前，Hydra将我们的实验用程序确定为Win32 OS和x86平台的32位PE（便携式可执行文件）。 导入后，我们正在等待更多信息： <br><br><img src="https://habrastorage.org/webt/zb/v0/ga/zbv0gatojwqtmbdejhe6zclenac.png"><br><br> 在这里，除了前面提到的位深度之外，我们可能仍然对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字节顺序</a>感兴趣，在我们的例子中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字节顺序</a>是<b>Little</b> （从低字节到高字节），这是英特尔第86平台所期望的。 <br><br> 通过初步分析，我们完成了。 <br><br><h2> 步骤3.执行自动分析 </h2><br> 是时候在Hydra中开始对该程序进行全自动分析了。 通过双击相应的文件（level_2.exe）来完成此操作。  Hydra具有模块化结构，可通过可独立添加/禁用或开发的插件系统提供其所有基本功能。 分析也是如此-每个插件都负责其分析类型。 因此，首先，我们面对这个窗口，您可以在其中选择感兴趣的分析类型： <br><br><div class="spoiler">  <b class="spoiler_title">分析设置窗口</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p2/aw/sa/p2awsa9slwl8tkbjo0mtcbkgnh8.png"></div></div><br> 就我们的目的而言，保留默认设置并运行分析是有意义的。 尽管论坛上的用户抱怨说，对于大型项目，Hydra失去了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IDA Pro的</a>速度，但分析本身的执行速度非常快（花了我大约7秒钟）。 这可能是正确的，但对于小文件，此差异并不明显。 <br><br> 至此，分析完成。 其结果显示在“代码浏览器”窗口中： <br><br><img src="https://habrastorage.org/webt/lh/dy/e5/lhdye5faqmse8w2evahggln5bge.png"><br><br> 该窗口是在Hydra中工作的主要窗口，因此您应仔细研究。 <br><br><div class="spoiler">  <b class="spoiler_title">代码浏览器界面概述</b> <div class="spoiler_text"> 默认界面设置将窗口分为三部分。 <br><br> 在<b>中央部分</b>是主窗口-反汇编程序的列表，它或多或少类似于IDA，OllyDbg等中的“兄弟”。 默认情况下，该列表中的列是（从左到右）：内存地址，命令的操作码，ASM命令，ASM命令的参数，交叉引用（如果适用）。 当然，可以通过单击此窗口工具栏中的砖墙形式的按钮来更改显示。 老实说，我从未在任何地方看到过如此灵活的反汇编程序输出配置，这非常方便。 <br><br> 在3面板的<b>左侧</b> ： <br><br><ol><li> 程序的各个部分（单击鼠标可在各个部分中移动） </li><li> 字符树（导入，导出，函数，标题等） </li><li> 使用变量的类型树 </li></ol><br> 对于我们来说，这里最有用的窗口是符号树，它使您可以快速找到例如功能名称的函数并转到相应的地址。 <br><br>  <b>右侧</b>是反编译代码的列表（在我们的示例中为C）。 <br><br> 除了默认窗口外，您还可以在“ <b>窗口”</b>菜单中选择并放置许多其他窗口，并在浏览器中的任何位置显示。 为了方便起见，我在中间添加了一个字节窗口和一个带有函数图的窗口，在右边添加了字符串变量（Strings）和函数表（Functions）。 这些窗口现在在单独的选项卡中可用。 另外，任何窗户都可以拆卸并“浮动”，并根据自己的意愿放置和调整它们的尺寸-我认为这也是一个非常周到的解决方案。 <br></div></div><br><h2> 步骤4.学习程序算法-main（）函数 </h2><br> 好吧，让我们继续直接分析我们的破解程序。 在大多数情况下，您应该先搜索程序的入口点，即 启动时调用的主要功能。 知道我们的破解是用C / C ++编写的，我们猜测main函数的名称将是<b>main（）</b>或类似的名称：)说完了。 在符号树的过滤器中（在左侧面板中）输入“ main”，然后在“ <b>功能”</b>部分中查看函数<b>_main（）</b> 。 单击鼠标转到它。 <br><br><h3>  main（）函数概述和重命名晦涩的函数 </h3><br> 在反汇编程序列表中，将立即显示相应的代码部分，然后在右侧我们看到此函数的反编译C代码。  Hydra的另一个便利功能是同步选择：当鼠标选择一系列ASM命令时，反编译器中的相应代码部分将突出显示，反之亦然。 另外，如果打开了内存查看窗口，则分配与内存同步。 正如他们所说，所有的创意都很简单！ <br><br> 我马上注意到在Hydra工作的一个重要特征（与IDA相对）。  <em>Hydra的工作主要集中在分析反编译的代码</em> 。 因此，Hydra的创建者（我们记得-我们所说的是来自NSA的间谍：）非常注重反编译的质量和使用代码的便利性。 特别是，只需双击代码即可简单地继续定义函数，变量和内存部分。 另外，任何变量和函数都可以立即重命名，这非常方便，因为默认名称没有含义并且可能会造成混淆。 正如您稍后将看到的，我们将经常使用这种机制。 <br><br> 因此，这里是<b>main（）</b>函数，Hydra对其进行了“解剖”，如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">列出主要（）</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __cdecl _main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _Argc,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Argv,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Env) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bVar1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar3; FILE *_File; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **ppcVar4; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_18; ___main(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); local_18 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_18 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { _text(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); _text(_Dest,_Argv[local_18],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } sVar3 = _text(_Argv[local_18]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((sVar3 == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[local_18] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[local_18][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } local_18 = local_18 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { _File = _text(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ppcVar4 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar4 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _text(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar4); } _text(_File); } _text(_Dest); iVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { iVar2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iVar2; }</code> </pre> <br></div></div><br> 似乎一切似乎都很正常-变量的定义，标准C类型，条件，循环，函数调用。 但是仔细看一下代码，我们注意到由于某些原因，某些函数的名称未定义，而是由伪<b>函数_text（）</b>代替（在反编译器窗口中为<b>.text（）</b> ）。 让我们从定义这些功能开始。 <br><br> 双击第一个通话的正文 <br><br><pre> <code class="cpp hljs"> _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br> 我们看到这只是标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">calloc（）</a>函数的包装函数，该函数用于为数据分配内存。 因此，让我们将该函数重命名为<b>calloc2（）</b> 。 将光标放在函数标题上，调用上下文菜单，然后选择“ <b>重命名函数”</b> （热键<b>-L</b> ），然后在打开的字段中输入新名称： <br><br><img src="https://habrastorage.org/webt/nz/q1/3z/nzq13zx8ddn0vsbvni8mkpencyc.png"><br><br> 我们看到该函数被立即重命名。 我们回到<b>主体（）</b>主体（工具栏上的“ <b>后退”</b>按钮或<b>Alt + &lt;-</b> ），我们看到这里已经代替了神秘的<b>_text（）calloc2（）</b> 。 太好了！ <br><br> 我们对所有其他包装器函数都执行相同的操作：我们逐一检查它们的定义，看一下它们的作用，将它们重命名（我在C函数的标准名称中添加了索引2）并返回到主函数。 <br><br><h3> 我们理解了main（）函数代码 </h3><br> 好的，我们发现了一些奇怪的功能。 我们开始研究主要功能的代码。 跳过变量声明，我们看到仅当满足字符串指定的条件时，函数才返回变量iVar2的值，该值是零（函数成功的标志）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre><br>  <b>_Argc</b>是传递给<b>main（）</b>的命令行参数（参数）的数量。 也就是说，我们的程序“吃”了2个参数（我们记得，第一个参数始终是可执行文件的路径）。 <br><br> 好的，让我们继续。 在这里，我们创建一个由256个字符组成的C字符串（ <b>char</b>数组）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)calloc2(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  new char[256]  C++</span></span></code> </pre><br> 接下来，我们有一个3次迭代的循环。 在其中，我们首先检查是否<b>设置</b>了<b>bVar1</b>标志<b>，</b>如果已<b>设置，</b>则将以下命令行参数（字符串）复制到<b>_Dest</b> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    .  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> memset2(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    _Dest    */</span></span> strncpy2(_Dest,_Argv[i],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br> 解析以下参数时设置此标志： <br><br><pre> <code class="cpp hljs">n_strlen = strlen2(_Argv[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((n_strlen == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[i] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br> 第一行计算此参数的长度。 此外，条件检查参数的长度必须为2，倒数第二个字符==“-”，最后一个字符==“ f”。 请注意，反编译器如何使用字节掩码“转换”从字符串中提取字符。 <br><blockquote> 可以通过将光标放在相应的十六进制文字上来监视数字的十进制值以及相应的ASCII字符。  ASCII映射并不总是有效（？），因此我建议查看Internet上的ASCII表。 您也可以直接在Hydra中将标量从任何数字系统转换为任何其他数字系统（通过上下文菜单-&gt; <b>Convert</b> ），在这种情况下，该数字将显示在所选数字系统的任何位置（在反汇编程序和反编译器中）； 但就我个人而言，我更喜欢在代码中保留十六进制以保证工作的和谐，因为 内存地址，偏移量等 十六进制无处不在。 <br></blockquote> 循环后出现以下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    1) "-f"  2)  -         */</span></span> _File = fopen2(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  1    */</span></span> perror2(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... }</code> </pre><br> 在这里，我立即添加了评论。 我们检查参数（“ -f path_to_file”）的有效性，然后打开相应的文件（传递的第二个参数，我们将其复制到_Dest）。 该文件将以二进制格式读取，如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fopen（）</a>函数的“ rb”参数所示。 如果读取失败（例如，文件不可用），则在stderror流中显示一条错误消息，并且程序退出并显示代码1。 <br><br> 接下来是最有趣的： <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* !!!     !!! */</span></span> ppcVar3 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar3 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,  "Nope" */</span></span> puts2(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    -      */</span></span> printf2(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar3); } fclose2(_File);</code> </pre><br> 打开的文件描述符（ <b>_File</b> ）被传递给<b>_construct_key（）</b>函数，该函数显然对所寻找的密钥进行验证。 该函数返回一个二维字节数组（ <b>char **</b> ），该数组存储在<b>ppcVar3</b>变量中。 如果阵列为空，则控制台上会显示简洁的“ Nope”（即，我们认为是“ Nope！”），然后释放内存。 否则（如果数组不为空），将显示看似正确的键，并释放内存。 函数结束时，文件描述符关闭，内存释放，并<b>返回</b>值<b>iVar2</b> 。 <br><br> 因此，现在我们意识到我们需要： <br><br>  <i>1）用正确的密钥创建一个二进制文件；</i> <i><br></i>  <i>2）在参数“ -f”之后在裂纹中传递其路径</i> <br><br> 在本文的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分，</a>我们将分析函数<b>_construct_key（）</b> ，我们发现该函数负责检查文件中的密钥。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447450/">https://habr.com/ru/post/zh-CN447450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447438/index.html">单元测试和抽象测试</a></li>
<li><a href="../zh-CN447440/index.html">深入了解RBKmoney付款-付款平台的逻辑</a></li>
<li><a href="../zh-CN447442/index.html">引入shell运算符：使Kubernetes的运算符更加容易</a></li>
<li><a href="../zh-CN447446/index.html">IBM研讨会：2019年春夏-人工智能，云开发，聊天机器人，区块链和其他技术</a></li>
<li><a href="../zh-CN447448/index.html">智力进化：开始</a></li>
<li><a href="../zh-CN447452/index.html">供应链安全：“如果我是一个民族国家……”</a></li>
<li><a href="../zh-CN447454/index.html">FPGA七段显示控制</a></li>
<li><a href="../zh-CN447456/index.html">Yandex如何准确预测冬天的降水量？ 我们分析预测服务的准确性</a></li>
<li><a href="../zh-CN447458/index.html">现代英语如何创建新单词</a></li>
<li><a href="../zh-CN447460/index.html">破解您的小米吸尘器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>