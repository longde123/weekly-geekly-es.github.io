<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚ÄçüöÄ üßîüèæ ü§≤üèΩ Beitr√§ge von der Fr√ºhjahrskonferenz C ++ Russia 2018 üõÅ ü•å üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom 19. bis 21. April fand in St. Petersburg die Konferenz C ++ Russia 2018 statt. Von Jahr zu Jahr werden Organisation und Verhalten um eine Ebene h√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beitr√§ge von der Fr√ºhjahrskonferenz C ++ Russia 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418645/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/m8/km/ifm8kmasjfgchispcdfdx3-2ax0.png"></div><br>  Vom 19. bis 21. April fand in St. Petersburg die Konferenz C ++ Russia 2018 statt. Von Jahr zu Jahr werden Organisation und Verhalten um eine Ebene h√∂her, was eine gute Nachricht ist.  Dank an den st√§ndigen Organisator von C ++ Russia, Sergey Platonov, f√ºr seinen Beitrag zur Entwicklung dieses Gebiets. <br><a name="habracut"></a><br>  Am 19. April waren Meisterkurse geplant, an denen wir leider nicht teilnehmen konnten, und am 20. und 21. fand das Hauptprogramm der Konferenz statt, an dem wir mit gro√üem Interesse teilnahmen.  Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sermp</a> hat einen tollen Job gemacht und mehrere bemerkenswerte ausl√§ndische Sprecher als Redner angezogen.  Der erste Tag der Konferenz wurde von Jon Kalb, dem Organisator von CppCon und Autor von C ++ Today: The Beast is Back, er√∂ffnet.  Der zweite Tag begann mit einer Pr√§sentation von Daveed Vandevoorde, Mitglied des Standardisierungsausschusses, einem der Autoren von C ++ - Vorlagen: The Complete Guide.  Andrei Alexandrescu stand im Mittelpunkt der Aufmerksamkeit, der nach seinem Bericht √ºber Ausnahmen einmal eine ganze Menge von Menschen versammelte, die ein Autogramm bekommen und ein gemeinsames Foto machen wollten.  Zum ersten Mal wurde auf Skype ein Herb Sutter-Vortrag √ºber den Raumschiff-Betreiber f√ºr C ++ 20 ausgestrahlt. <br><br>  Obwohl die Konferenz vor mehr als drei Monaten stattfand, wurde das Video ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndige Wiedergabeliste</a> ) gerade darauf ver√∂ffentlicht. Es ist also an der Zeit, Ihre Erinnerungen aufzufrischen und in die erstaunlichen Funktionen von C ++ einzutauchen. <br><br><h3>  Jon Kalb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Heute: Das Biest ist zur√ºck</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qj/4d/qxqj4duts1eygoh4trgst-2i8bw.png"></div><br>  In diesem Vortrag wird erl√§utert, warum Ingenieure, die nach Leistung suchen, C ++ w√§hlen.  Jon pr√§sentiert eine historische Perspektive von C ++ und konzentriert sich darauf, was gerade in der C ++ - Community vor sich geht und wohin die Sprache und ihre Benutzerbasis f√ºhren.  Mit einem erneuten Interesse an Leistung sowohl f√ºr Rechenzentren als auch f√ºr mobile Ger√§te und dem Erfolg von Open Source-Softwarebibliotheken ist C ++ zur√ºck und es ist hei√ü.  In diesem Vortrag wird erkl√§rt, warum C ++ f√ºr die Leistung die Sprache der meisten Softwareentwickler ist.  Sie erhalten eine grobe historische Skizze, die C ++ relativiert und die H√∂hen und Tiefen seiner Popularit√§t abdeckt. <br><br><h3>  Arno Sch√∂dl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von Iteratoren zu Bereichen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/wi/1c/g2wi1czg7ulvtypu_8xqlz1irdo.png"></div><br>  Iteratorpaare sind in der gesamten C ++ - Bibliothek allgegenw√§rtig.  Es ist allgemein anerkannt, dass das Kombinieren eines solchen Paares zu einer einzigen Entit√§t, die √ºblicherweise als Range bezeichnet wird, einen pr√§ziseren und lesbareren Code liefert.  Die genaue Semantik eines solchen Range-Konzepts zu definieren, erweist sich jedoch als √ºberraschend schwierig.  Theoretische √úberlegungen stehen im Widerspruch zu praktischen.  Einige Entwurfsziele sind insgesamt nicht miteinander kompatibel. <br><br><h3>  Jonathan Boccara.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">105 STL-Algorithmen in weniger als einer Stunde</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/lf/ga/jvlfga-cdxxb3furo797y5ezpfy.png"></div><br>  Wir sind uns alle bewusst, dass wir die STL-Algorithmen kennen sollten.  Wenn wir sie in unsere Entw√ºrfe aufnehmen, k√∂nnen wir unseren Code ausdrucksvoller und robuster gestalten.  Und manchmal auf spektakul√§re Weise. <br><br>  Aber kennen Sie Ihre STL-Algorithmen? <br><br>  In diesem Vortrag stellt der Autor 105 Algorithmen vor, √ºber die die STL derzeit verf√ºgt, einschlie√ülich der in C ++ 11 und C ++ 17 hinzugef√ºgten.  In diesem Vortrag geht es jedoch nicht nur um eine Auflistung, sondern auch darum, die verschiedenen Gruppen von Algorithmen, die Muster, die sie in der STL bilden, und die Beziehung zwischen den Algorithmen darzustellen. <br><br>  Diese Art von Gesamtbild ist der beste Weg, um sich tats√§chlich an alle zu erinnern, und stellt eine Toolbox dar, die voller M√∂glichkeiten ist, unseren Code ausdrucksvoller und robuster zu machen. <br><br><h3>  Viktor Kirilov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interaktive C ++ - Kompilierung (REPL): Der schlanke Weg</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/bd/4w/zzbd4w9yrkytmf3aqgamwc6iafw.png"></div><br>  Wollten Sie schon immer einen Wert √§ndern oder eine Anweisung ausf√ºhren, w√§hrend Ihr C ++ - Programm ausgef√ºhrt wird, um etwas zu testen - nicht trivial oder mit einem Debugger m√∂glich?  Skriptsprachen haben eine REPL (Read-Eval-Print-Loop).  Das N√§chste, was C ++ hat, ist das Festhalten (entwickelt von Forschern am CERN), aber es basiert auf LLVM und ist sehr umst√§ndlich einzurichten.  RCRL (Read-Compile-Run-Loop) ist ein Demo-Projekt, das einen innovativen Ansatz f√ºr die plattform- und compilerunabh√§ngige C ++ - Kompilierung zur Laufzeit zeigt, der einfach eingebettet werden kann.  In dieser Pr√§sentation wird gezeigt, wie es verwendet wird, wie es funktioniert und wie es ge√§ndert und in jede Anwendung und jeden Workflow integriert werden kann. <br><br><h3>  Victor Ciura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genug string_view, um uns aufzuh√§ngen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/gz/sl/bmgzslbc51pb7tc4f-jeaoywee4.png"></div><br>  W√§re es nicht sch√∂n, wenn wir einen Standard-C ++ - Typ zur Darstellung von Zeichenfolgen h√§tten?  Oh, warte ... wir machen: std :: string.  W√§re es nicht sch√∂n, wenn wir diesen Standardtyp f√ºr unsere gesamte Anwendung / unser gesamtes Projekt verwenden k√∂nnten?  Nun ... wir k√∂nnen nicht!  Es sei denn, wir schreiben eine Konsolen-App oder einen Dienst.  Wenn wir jedoch eine App mit GUI schreiben oder mit modernen Betriebssystem-APIs interagieren, m√ºssen wir uns wahrscheinlich mit mindestens einem anderen nicht standardm√§√üigen C ++ - Zeichenfolgentyp befassen.  Je nach Plattform und Projekt kann es sich um CString von MFC oder ATL, Platform :: String von WinRT, QString von Qt, wxString von wxWidgets usw. handeln.  Oh, vergessen wir nicht unseren alten Freund const char *, besser noch const wchar_t * f√ºr die C-Familie von APIs ... <br><br>  Wir haben also zwei Zeichenfolgentypen in unserer Codebasis gefunden.  OK, das ist √ºberschaubar: Wir bleiben bei std :: string f√ºr den gesamten plattformunabh√§ngigen Code und konvertieren bei der Interaktion mit System-APIs oder GUI-Code hin und her in den anderen XString.  Wir werden einige unn√∂tige Kopien machen, wenn wir diese Br√ºcke √ºberqueren, und am Ende werden wir einige komisch aussehende Funktionen haben, die zwei Arten von Saiten jonglieren.  aber das ist doch klebercode ... richtig? <br><br>  Es ist ein guter Plan ... bis unser Projekt w√§chst und wir viele String-Dienstprogramme und Algorithmen sammeln.  Beschr√§nken wir diese algorithmischen Extras auf std :: string?  Greifen wir auf den gemeinsamen Nenner const char * zur√ºck und verlieren die Typ- / Speichersicherheit unseres C ++ - Typs?  Ist C ++ 17 std :: string_view die Antwort auf alle unsere String-Probleme? <br><br>  Der Autor versucht, die Optionen zusammen mit einer Fallstudie zu einer 15 Jahre alten Windows-Anwendung zu untersuchen: Advanced Installer (www.advancedinstaller.com) - ein aktiv entwickeltes C ++ - Projekt, das dank Clang-Tidy auf C ++ 17 modernisiert wurde und "Clang Power Tools" ( <a href="">www.clangpowertools.com)</a> ... <br><br><h3>  Andrei Alexandrescu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erwarten Sie das Erwartete</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/76/5i/k4765i7g8pxr-u0qfvk433pbfnk.png"></div><br>  Das Schreiben von Code, der bei Fehlern stabil ist, war in allen Sprachen schon immer ein Problem.  Ausnahmen sind das politisch korrekte Mittel, um Fehler in C ++ zu signalisieren. Viele Anwendungen greifen jedoch aus Gr√ºnden des besseren Verst√§ndnisses, der einfachen Handhabung von Fehlern vor Ort und der Effizienz des generierten Codes immer noch auf Fehlercodes zur√ºck. <br><br>  Dieser Vortrag zeigt, wie verschiedene theoretische und praktische Artefakte miteinander kombiniert werden k√∂nnen, um Fehlercodes und Ausnahmen in einem gesunden, einfachen Paket zu beheben.  Der generische Typ Expected kann sowohl f√ºr lokale (Fehlercode-Stil) als auch f√ºr zentralisierte (Ausnahme-Stil) Manieren verwendet werden, wobei die jeweiligen St√§rken ber√ºcksichtigt werden. <br><br><h3>  Borislav Stanimirov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DynaMix: Eine neue Sicht auf Polymorphismus</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2r/ji/ej/2rjiej_ldue2ztihyhwrgy7lhaa.png"></div><br>  Software mit sehr komplexer Gesch√§ftslogik wie Spiele, CAD-Systeme und Unternehmenssysteme muss h√§ufig zur Laufzeit Objekte erstellen und √§ndern, um beispielsweise eine Methode in einem vorhandenen Objekt hinzuzuf√ºgen oder zu √ºberschreiben.  Standard C ++ hat starre Typen, die zur Kompilierungszeit definiert werden und dies erschweren.  Sprachen mit dynamischen Typen wie Lua, Python und JavaScript machen dies jedoch sehr einfach.  Daher verwenden viele Projekte solche Sprachen neben C ++, um den Code lesbar und wartbar zu halten und komplexe Anforderungen an die Gesch√§ftslogik zu erf√ºllen.  Einige Nachteile dieses Ansatzes sind die zus√§tzliche Komplexit√§t in einer Sprachbindungsschicht, der Leistungsverlust durch die Verwendung einer interpretierten Sprache und die unvermeidliche Codeduplizierung f√ºr viele kleine Dienstprogrammfunktionen. <br><br>  DynaMix ist eine Bibliothek, die versucht, die Notwendigkeit einer separaten Skriptsprache zu beseitigen oder zumindest stark zu reduzieren, indem die Benutzer zur Laufzeit in C ++ polymorphe Objekte erstellen und √§ndern k√∂nnen.  In diesem Vortrag wird dieses Problem n√§her erl√§utert und potenziellen Benutzern oder Personen, die von dem Ansatz profitieren k√∂nnten, die Bibliothek und ihre Hauptfunktionen anhand eines kommentierten Beispiels und einer kleinen Demo vorgestellt. <br><br><h3>  Mikhail Matrosov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielseitiges C ++ angewendet</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/ox/ha/aooxhajausoz9zfpywpbrsz8wsa.png"></div><br>  In C ++ k√∂nnen Sie eine einzelne Aufgabe auf mehrere Arten l√∂sen.  Der Autor w√§hlt eine tats√§chliche Aufgabe aus der Produktion aus und untersucht, wie sie mit einer Reihe von Tools gel√∂st werden kann, die C ++ bereitstellt: STL-Container, boost.range, C ++ 20-Bereiche, Coroutinen.  Er vergleicht auch API-Einschr√§nkungen und die Leistung verschiedener L√∂sungen und wie sie leicht von einer zur anderen konvertiert werden k√∂nnen, wenn der Code gut strukturiert ist.  W√§hrenddessen untersucht der Autor auch Anwendungen einiger n√ºtzlicher C ++ 17-Funktionen wie constexpr if, Auswahlanweisungen mit Initialisierer, std :: not_fn usw.  Besonderes Augenmerk wird auf themenbezogene Standardalgorithmen gelegt. <br><br><h3>  Alexander Granin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionaler Ansatz f√ºr den Software-Transaktionsspeicher</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/ty/uh/d-tyuhxlhdvvelofkinuwnmpyl4.png"></div><br>  Parallele Programmierung ist ein sehr facettenreiches und tiefgreifendes Thema.  Im Laufe der Jahrzehnte der Forschung wurde eine Vielzahl von Ans√§tzen, Praktiken und Werkzeugen entwickelt, aber wir k√∂nnen kaum davon ausgehen, dass die C ++ - Sprache mit diesen Trends Schritt gehalten hat.  Beginnend mit dem C ++ 11-Standard wurden Konzepte wie std :: thread, std :: atomic, std :: future und std :: mutex eingef√ºhrt, und es wird erwartet, dass in Zukunft Coroutinen, ein Modell f√ºr asynchrone Berechnungen, hinzugef√ºgt werden.  Nun, das sind alles interessante Dinge, die es zu studieren gilt, aber der Bericht wird sich auf eine ganz andere Idee konzentrieren. <br><br>  Software Transactional Memory (STM) - das Konzept eines transaktionsver√§nderlichen Datenmodells - existiert seit langem und verf√ºgt √ºber eine Reihe von Implementierungen f√ºr alle Sprachen.  Mit STM dr√ºcken Sie Ihr Datenmodell aus und starten es, um es wettbewerbsf√§hig √ºber mehrere Threads hinweg zu √§ndern, ohne sich um die Thread-Synchronisierung, den g√ºltigen Datenstatus oder Sperren k√ºmmern zu m√ºssen.  STM wird alles f√ºr Sie tun.  Das klingt sehr gut, aber nicht alle STM-Bibliotheken sind gleich n√ºtzlich.  Herk√∂mmliche imperative STMs sind sehr komplex, anf√§llig f√ºr nicht triviale Multithread-Fehler und schwierig zu verwenden.  Andererseits gibt es in der Welt der funktionalen Programmierung seit langem das Konzept des kombinatorischen STM, Transaktionen, bei denen es sich um zusammensetzbare Bausteine ‚Äã‚Äãhandelt, aus denen Sie Transaktionen auf einer h√∂heren Ebene erstellen.  Der kombinatorische Ansatz f√ºr STM erm√∂glicht es Ihnen, ein wettbewerbsf√§higes Datenmodell flexibler, klarer und zuverl√§ssiger auszudr√ºcken.  Parallele Programmierung kann auch Spa√ü machen! <br><br>  In dem Bericht wird der Autor √ºber die Funktionen von kombinatorischem STM sprechen, wie es verwendet wird und wie es in C ++ 17 implementiert werden kann. <br><br><h3>  Vadim Vinnik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sammelabwicklung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzelne Essenz, mehrere Manifestationen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/4-/09/xh4-09mvu7jukasuqttn0-ipifu.png"></div><br>  W√§hrend der gesamten Geschichte der Programmierung war und ist die sequentielle elementweise Verarbeitung verschiedener Arten von Sammlungen eine der h√§ufigsten praktischen Aufgaben.  Die interne Darstellung der Sammlungen sowie der Algorithmus zum Abrufen nachfolgender Elemente k√∂nnen in einem sehr gro√üen Bereich variieren: Array, verkn√ºpfte Liste, Baum, Hash-Tabelle, Datei et al.  Hinter der Vielfalt der Redewendungen, Standardbibliotheksfunktionen und Ad-hoc-L√∂sungen kann man jedoch die Essenz aufdecken, die f√ºr diese ganze Klasse von Aufgaben unver√§nderlich bleibt.  Dieser Vortrag soll einen schrittweisen √úbergang von Algorithmen auf der Grundlage einer expliziten Beschreibung von Aktionen √ºber einzelne Elemente hin zu deklarativen Verarbeitungswerkzeugen auf hoher Ebene zeigen, die eine Sammlung als Einheit behandeln und die Logik der Dom√§ne angemessen offenlegen. <br><br><h3>  Dmitry Banshchikov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Freigegebene Bibliotheken ohne externe Abh√§ngigkeiten</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/75/rt/xn/75rtxnsxinft9v9g2bs2rtyc2sy.png"></div><br>  Der Autor wird √ºber seine Erfahrungen bei der Entwicklung einer Antiviren-Engine in C ++ in Form einer gemeinsam genutzten Bibliothek berichten.  Ein einzigartiges Merkmal ist das Fehlen externer Abh√§ngigkeiten (Laufzeit C ++ oder C).  Diese ganze Reihe basiert auf der Verwendung einer benutzerdefinierten Toolchain in GCC f√ºr ein spezielles Ziel, das libc newlib f√ºr dasselbe Ziel verwenden wird, auf dem libstdc ++ basiert.  Dementsprechend wird die gemeinsam genutzte Bibliothek √ºber eine benutzerdefinierte Toolchain mit benutzerdefinierten libgcc_s, libc, libcstdc ++ zusammengestellt (√Ñnderungen nur in der Assembly).  Die gesamte Interaktion mit der Laufzeit erfolgt √ºber die gemeinsam genutzte Bibliothek ABI.  Somit beh√§lt die Bibliothek die M√∂glichkeit, vollwertiges modernes C ++ ohne Einschr√§nkungen (RTTI, Ausnahmen, iostream usw.) zu verwenden, das an libstdc ++ libc (newlib) | geht  l ibgcc-ABI.  Ein √§hnlicher Ansatz wurde mit den Toolketten GCC / newlib / libstdc ++ f√ºr Linux und clang / newlib / libc ++ f√ºr MacOS getestet.  Der Bericht ist m√∂glicherweise f√ºr diejenigen von Interesse, die C ++ in gemeinsam genutzten Bibliotheken verwenden m√∂chten, kann ihn sich jedoch aufgrund externer Abh√§ngigkeiten nicht leisten. <br><br><h3>  Ilya Shishkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So unterrichten Sie die C ++ - Sprache: die Erfahrung beim Erstellen von Kursen auf Coursera</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/zk/e6/sjzke6dn32bnehol5pyaeg9bmpe.png"></div><br>  In den letzten anderthalb Jahren hat der Autor die Coursera-Spezialisierung f√ºr modernes C ++ geleitet.  Die Spezialisierung besteht aus f√ºnf Kursen, von denen zwei bereits laufen und ein weiterer fast fertig ist. <br><br>  Der Bericht wird sagen: <br><br><ul><li>  Welche Probleme k√∂nnen bei der Arbeit an Kursen auftreten (zum Beispiel haben die Entwickler nach 3 Monaten Arbeit alle Materialien weggeworfen und erneut begonnen) </li><li>  wie der Lehrplan gebildet wird und warum genau (zum Beispiel, warum das Wort "Zeiger" in den ersten beiden Kursen nicht einmal geklungen hat) </li></ul><br>  Dar√ºber hinaus wurde w√§hrend der Spezialisierungsarbeit eine Reihe von Grunds√§tzen entwickelt, die in der t√§glichen Arbeit anwendbar sind: <br><br><ul><li>  bei der Integration eines neuen Mitarbeiters in das Projekt </li><li>  w√§hrend der Code√ºberpr√ºfung </li><li>  bei der Einstellung </li></ul><br>  Daher m√∂chte der Autor nicht nur erz√§hlen, wie er sich spezialisiert, sondern auch versuchen, die gesammelten Erfahrungen auf allt√§gliche Aufgaben zu √ºbertragen. <br><br><h3>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Absturz von NDK-Berichten f√ºr Android</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/yx/zc/h9yxzc_vcjlymv-gzh28xsaock4.png"></div><br>  Es ist kein Geheimnis, dass die Entwicklung in C / C ++ viel h√∂here Anforderungen an die Codequalit√§t stellt als die Entwicklung in Java.  Die Wahrscheinlichkeit, einen fatalen Fehler zu machen, ist viel h√∂her.  Gleichzeitig ist das Sammeln von Informationen √ºber solche Fehler selbst f√ºr erfahrene Programmierer keine triviale Aufgabe. <br><br>  Im ersten Teil des Berichts werden wir kurz auf die bestehenden Entwicklungen eingehen: Wie der integrierte Android-Debugger funktioniert, welche L√∂sungen bereits existieren.  Der zweite Teil ist der Geschichte gewidmet, wie es "unter der Haube" funktioniert: wie man den Status des Prozessors zum Zeitpunkt des Fehlers erh√§lt, wie man den Aufrufstapel abwickelt, wie man die Zeilennummern im Quellcode herausfindet.  Es wird eine √úbersicht √ºber Stack-Promotion-Bibliotheken wie libcorkscrew, libunwind, libunwindstack gegeben. <br><br>  Der Bericht wird sowohl f√ºr Android-Entwickler, deren Anwendungen NDK verwenden, als auch f√ºr alle anderen von Interesse sein, um ihren Horizont zu erweitern. <br><br><h3>  Fedor Short.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erinnerung ist die perfekte Abstraktion</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/yh/ns/tcyhnsqf9zd7owu6oylohlcgkqe.png"></div><br>  int * ptr = new int; <br>  * ptr = 42; <br>  ptr l√∂schen; <br><br>  Was passiert eigentlich, wenn diese 3 Codezeilen ausgef√ºhrt werden?  Wir werden uns den Speicherzuweiser, das Betriebssystem und die moderne Hardware ansehen, um eine umfassende Antwort auf diese Frage zu geben. <br><br><h3>  Alexey Salmin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps und Tricks zur Speicherverwaltung</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/re/ju/yirejuytypvwzo-ldwc-jmd4ylg.png"></div><br>  Im Jahr 2017 verliert das Problem der Auswahl eines Allokators in C ++ nicht an Relevanz.  Sie haben dem Standard eine neue Methode hinzugef√ºgt, um einen lokalen Allokator f√ºr Container (std :: pmr), globales tcmalloc und jemalloc sowie die Kernel-Schnittstellen, auf die sie sich verlassen, auszuw√§hlen.  Dieser Bericht ist der "unteren Etage" dieses Entwurfs gewidmet: den Funktionen von mmap und madvise im Linux-Kernel und den Auswirkungen dieser Funktionen auf die Leistung von Allokatoren. <br><br><h3>  Kr√§utersutter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neu in C ++ 20: Der Raumschiffoperator</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ex/dw/jhexdwnxovbsvpbtftm3jmrofr0.png"></div><br>  Das neue Raumschiff wurde k√ºrzlich als Sprachfunktion f√ºr C ++ 20 √ºbernommen.  In diesem Vortrag gibt der Designer und Autor des Raumschiffvorschlags einen √úberblick √ºber das Feature, diskutiert dessen Motivation und Design und geht durch Beispiele f√ºr dessen Verwendung.  Er legt besonderen Wert darauf, wie die Funktion das Schreiben und Lesen von C ++ - Code sauberer macht, schneller durch Vermeidung redundanter Arbeit und robuster, indem mehrere wichtige, aber subtile Fallstricke in dem spr√∂deren Code vermieden werden, den wir zuvor ohne diese Funktion von Hand schreiben mussten. <br><br><h3>  Anastasia Kazakova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen von C ++ - Code ohne Ausf√ºhren und Kompilieren</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/na/ve/atnaverrgqdy-zv-xexxy6oan_g.png"></div><br>  Wenn Sie sich Vorlagen, Reflexion, Codegenerierung in der Kompilierungsphase und Metaklassen ansehen, haben Sie das Gef√ºhl, dass C ++ es sich zur Aufgabe gemacht hat, den endg√ºltigen Code so weit wie m√∂glich vor dem Entwickler zu ‚Äûverbergen‚Äú.  Eine nicht triviale Verwendung des Pr√§prozessors (und zahlreicher Zweige) kann die Programmsequenz sehr offensichtlich machen.  Diese Ans√§tze ersparen Entwicklern nat√ºrlich das endlose Kopieren und Einf√ºgen √§hnlicher Teile der Codebasis, erfordern jedoch eine erweiterte Unterst√ºtzung in den Entwicklungstools. <br><br>  Ist es m√∂glich, Code zu debuggen, ohne ihn kontinuierlich neu zu starten, ohne einen Debugger und sogar ohne eine einfache Kompilierung der gesamten Codebasis?  Ist es m√∂glich, Fehler im Code zu finden, die nicht zusammengestellt oder auf dem lokalen Computer ausgef√ºhrt werden k√∂nnen?  Da ist!  Integrierte Entwicklungsumgebungen (IDEs) verf√ºgen √ºber umfassende Kenntnisse und Kenntnisse in Bezug auf benutzerdefinierten Code und k√∂nnen die entsprechenden Tools bereitstellen. <br><br>  Dieser Bericht zeigt, wie man durch typedef verschachtelte Makrosubstitutionen ‚Äûdebuggen‚Äú, die Variablentypen (die in modernem C ++ h√§ufig ‚Äûversteckt‚Äú sind) verstehen, verschiedene Zweige der √úberladung von Pr√§prozessoren oder Operatoren debuggen und vieles mehr mithilfe eines wirklich intelligenten Ger√§ts IDE  Einige der Funktionen sind bereits in CLion und ReSharper C ++ verf√ºgbar, andere sind nur interessante Ideen f√ºr die Zukunft, die mit dem Publikum diskutiert werden k√∂nnten. <br><br><h3>  Eugene Lukyanets.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie Docker mit Conan</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kt/es/9y/ktes9yg6zny3qia9p2qd6mksxqm.png"></div><br>  Die Assembly eines C ++ - Projekts kann in den Docker-Container verschoben werden. Anstatt die erforderlichen Bibliotheken und Abh√§ngigkeiten im Hostsystem zu installieren, k√∂nnen sie entweder direkt im Docker-Image (z. B. Cuda) oder mit dem C ++ - Manager der Conan-Bibliothek (z. B.) installiert werden. Boost).  Dies f√ºhrt zu einer isolierten kontrollierten (und jedes Mal gleichen) Umgebung f√ºr die Assembly, in die Sie den Conan-Cache einbinden k√∂nnen, sodass verschiedene Projekte, die dieselben Bibliotheken verwenden, dieselben Assemblys verwenden.  Au√üerdem h√§ngt der Build nicht mehr von der Linux-Distribution ab, in der das Projekt erstellt wird. Hauptsache, Sie k√∂nnen Docker auf dieser Distribution ausf√ºhren. <br><br><h3>  Denis Panin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktische Metaprogrammierung: Schreiben einer heterogenen Hash-Tabelle</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/zf/8d/ilzf8daway7fam09ukocar1bdpw.png"></div><br>  Im Verlauf des Berichts werden wir eine kleine Arbeitsbibliothek mit std :: tuple schreiben.  Mit dieser Bibliothek kompilieren wir die Kompilierungszeit in eine heterogene Hash-Tabelle.  Weiter - auf seiner Basis werden wir ein kleines RPC-Framework schreiben, wobei wir die Tatsache verwenden, dass wir keine Typl√∂schung haben. <br><br>  In C ++ 17 wird es viele constexpr-Berechnungen, Vorlagen und neue Funktionen geben (insbesondere wenn constexpr). <br><br><h3>  Dmitry Sokolov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codegenerierung als Reflexion f√ºr die Armen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/cy/ey/m6cyeyyxuncuuz_jzzlzzcwj8q8.png"></div><br>  Reflexion ist h√§ufig erforderlich, um Serialisierungsalgorithmen zu verallgemeinern.  Implementierung verschiedener Protokolle, Arbeit mit Datenbanken.  Um solche Probleme zu l√∂sen, haben wir einen Homebrew-IDL-Compiler zum Generieren von C ++ - Strukturen und eine Bibliothek zur Interaktion mit dem Ergebnis geschrieben.  Protobuf mit Pedalen und ob es sich gelohnt hat. <br><br><h3>  Daveed Vandevoorde.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflektierende Metaprogrammierung in C ++</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/ho/ie/5choiecmddpmcbekwyekclxdmlq.png"></div><br>  Vor einiger Zeit hat das C ++ - Standardisierungskomitee eine Untergruppe "SG-7" erstellt, um zu untersuchen, wie der Sprache Reflexionsfunktionen hinzugef√ºgt werden k√∂nnen.  In j√ºngerer Zeit hat diese Gruppe ihrer Platte "Metaprogrammierung" hinzugef√ºgt und einige wichtige Entscheidungen hinsichtlich der Form der m√∂glichen L√∂sung getroffen.  In diesem Vortrag untersucht der Autor die Vergangenheit, die uns hierher gebracht hat, und untersucht einen m√∂glichen Weg f√ºr C ++ 's erstklassige Unterst√ºtzung der "reflektierenden Metaprogrammierung". <br><br><h3>  Dietmar K√ºhl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konzeptbasiertes Testen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/sa/3s/stsa3scg4ux8lm4x7avft5qzabg.png"></div><br>  Mit der Hinzuf√ºgung von Konzepten zur n√§chsten Version von C ++ wird erwartet, dass neue Konzepte definiert werden.  Jedes Konzept definiert eine Reihe von Operationen, die von generischem Code verwendet werden.  Eine solche Verwendung k√∂nnte ein generischer Test sein, der √ºberpr√ºft, ob alle Teile eines Konzepts definiert sind, und generische Interaktionen zwischen den Operationen eines Konzepts √ºberpr√ºft.  Im Idealfall funktioniert ein solcher Test sogar mit Klassen, die ein Konzept nur teilweise modellieren, um die Implementierung von Klassen zu steuern. <br><br>  Diese Pr√§sentation verwendet nicht die eigentlichen Konzepterweiterungen, sondern zeigt, wie generische Tests mit den Funktionen von C ++ 17 erstellt werden k√∂nnen.  F√ºr die generischen Tests werden die Erkennungssprache und der Kontext verwendet, um die Verf√ºgbarkeit der erforderlichen Operationen zu bestimmen und die Abwesenheit von Operationen ordnungsgem√§√ü zu behandeln.  Die generischen Tests sollten in der Lage sein, die Grundlagen von Klassen zu erfassen, die ein Konzept modellieren.  Offensichtlich erfordert ein spezifisches Verhalten f√ºr Klassen immer noch entsprechende Tests. <br><br><h3>  Simon Brand  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moderne C ++ - Parallelit√§t von CPU zu GPU</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/qz/st/qqqzstnuzvnt3ev15p-9hngj3iy.png"></div><br>  Parallele Programmierung kann verwendet werden, um Multi-Core- und heterogene Architekturen zu nutzen und die Leistung von Software erheblich zu steigern.  Modernes C ++ hat viel dazu beigetragen, die parallele Programmierung einfacher und zug√§nglicher zu machen.  Bereitstellung von Abstraktionen auf hoher und niedriger Ebene.  C ++ 17 geht noch einen Schritt weiter und bietet parallele Algorithmen auf hoher Ebene. In C ++ 20 wird noch viel mehr erwartet.  Dieser Vortrag gibt einen √úberblick √ºber die derzeit verf√ºgbaren Parallelit√§tsdienstprogramme und gibt einen √úberblick √ºber die Zukunft, wie GPUs und heterogene Systeme durch neue Standardbibliotheksfunktionen und andere Standards wie SYCL unterst√ºtzt werden k√∂nnen. <br><br><h3>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effektives C ++ (Maers hat nichts damit zu tun :)</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/lp/mu/rblpmu6fzwwn7hnt3cim-pipjf0.png"></div><br>  Die C ++ - Sprache und die damit verbundene Infrastruktur entwickeln sich weiter, was diese Sprache derzeit zu einem der effektivsten Tools macht.  Ich m√∂chte drei Faktoren hervorheben, die die C ++ - Sprache jetzt so attraktiv machen. <br><br><ul><li>  Erstens: Innovationen im Sprachstandard, mit denen Sie effizienten Code schreiben k√∂nnen. </li><li>  Zweitens: die Reife der Entwicklungswerkzeuge und eine Beschleunigung der Montage von Projekten. </li><li>  Drittens: ausgereifte Support-Tools, mit denen Sie die Qualit√§t des Codes und andere Aspekte des Projektlebenszyklus steuern k√∂nnen. </li></ul><br>  Dieser Bericht ist eine Ode an die Programmiersprache C ++! <br><br><h3>  Ivan Puzyrevsky.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchronit√§t in der Programmierung</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/vx/iw/3gvxiw02427rxts0p3nza4kburu.png"></div><br>  Auf dem Gebiet der Entwicklung hoch geladener Multithread- oder verteilter Anwendungen kann man zunehmend Gespr√§che √ºber asynchronen Code h√∂ren, einschlie√ülich Spekulationen √ºber die Notwendigkeit (mangelnde Notwendigkeit), die Asynchronit√§t im Code zu ber√ºcksichtigen, √ºber die Verst√§ndlichkeit (Unverst√§ndlichkeit) von asynchronem Code und dessen Effizienz (Ineffizienz).  In diesem Bericht werden wir versuchen, tiefer in den Themenbereich einzutauchen: Wir werden analysieren, was Asynchronit√§t ist;  wenn es entsteht;  wie sich dies auf den von uns geschriebenen Code und die von uns verwendete Programmiersprache auswirkt.  Wir werden versuchen herauszufinden, was Zukunft und Versprechen damit zu tun haben. Lassen Sie uns ein wenig √ºber Coroutinen und Schauspieler sprechen.  Wir werden JavaScript und Betriebssysteme beeinflussen.  Der Zweck des Berichts besteht darin, die Kompromisse, die sich aus dem einen oder anderen Ansatz bei der Entwicklung von Multithread- oder verteilter Software ergeben, deutlicher zu machen. <br><br><h3>  Pavel Bulatov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wechsel zu WebAssembly: Ist das Spiel die Kerze wert?</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/s6/ga/vts6gamnunde4u6qzk6p_4zqc6c.png"></div><br>  In dem Bericht wird der aktuelle Status von WebAssembly in Bezug auf reale Produkte er√∂rtert.  Wir werden √ºber unsere Erfahrungen mit der Portierung der Anwendung sprechen, dar√ºber, welche Probleme aufgetreten sind und wie wir sie gel√∂st haben. <br><br>  Zu den behandelten Themen geh√∂ren: <br><br><ul><li>  Unterst√ºtzung f√ºr den Standard auf verschiedenen Plattformen und Browsern. </li><li>  Leistung und Build-Gr√∂√üe im Vergleich zu asm.js. </li><li>  Interaktionen mit dem Browser. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build st√ºrzt vom Benutzer ab. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM-Funktionen. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Kozhevnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake Fallstricke und wo sie leben</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/_l/qr/zt_lqrmu-qimm8_m2z7g_zd2xsg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das CMake-Build-System wird allm√§hlich zum De-facto-Standard f√ºr die plattform√ºbergreifende C ++ - Programmierung. </font><font style="vertical-align: inherit;">Es wird jedoch h√§ufig fair kritisiert, unter anderem wegen der unbequemen Skriptsprache, der veralteten Dokumentation und der Tatsache, dass dieselben Aufgaben auf unterschiedliche Weise ausgef√ºhrt werden k√∂nnen und es ziemlich schwierig sein kann zu verstehen, welche in einer bestimmten Situation korrekter ist . </font><font style="vertical-align: inherit;">Der Autor wird sagen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> h√§ufige popul√§re Anti-Muster und warum sie schlecht sind, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf welchen Abstraktionsebenen funktioniert CMake und wann ‚Äûlecken‚Äú sie? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist "Modern CMake" und was sind seine Vorteile? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lokalisieren und Debuggen von Problemen in CMake-Skripten (einschlie√ülich einiger eher exotischer). </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Shambir. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn prozedurales C ++ gut ist</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ib/vy/kxibvyhzvf5taodgpswkywptk9y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die klare Architektur des Projekts, einfache Abstraktionen auf jeder Ebene ist der Traum eines jeden Teams. </font><font style="vertical-align: inherit;">Um diesen Traum zu verwirklichen, wurden viele objektorientierte Techniken erfunden. </font><font style="vertical-align: inherit;">Von OOP mitgenommen, vergessen Entwickler, die Sauberkeit des Codes an der Kreuzung von C und C ++ zu √ºberwachen. </font><font style="vertical-align: inherit;">Hier hilft der prozedurale Stil dabei, die Ordnung wiederherzustellen, bequeme und sichere Abstraktionen zu erstellen, die leicht in den objektorientierten Code des Projekts passen. </font><font style="vertical-align: inherit;">Wir werden herausfinden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum m√ºssen Sie die C-API isolieren (z. B. Winapi, POSIX, SQLite, OpenGL, OpenSSL)? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum arbeitet OOP in diesem Gesch√§ft schlecht? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie schreibe ich eine Abstraktionsschicht √ºber die API im C-Stil? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgang mit R√ºckrufen, Fehlerbehandlung und Ressourcenverwaltung, um traditionell komplexen und verwirrenden Code auch f√ºr Junioren verst√§ndlich zu machen </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Zuev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semantische API f√ºr C ++ - Programme</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/wb/d4/-ewbd4monfzqy8msagott8iaxzu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seine beruflichen Interessen sind die Semantik von Programmiersprachen, das Design und die Implementierung von Compilern von YaP und anderen sprachorientierten Tools. </font><font style="vertical-align: inherit;">Zu den wichtigsten Errungenschaften z√§hlen die Teilnahme an Projekten wie die Erstellung eines Compilers des vollst√§ndigen C ++ - Sprachstandards (Interstron, Moskau, 2000), die Implementierung des Zonnon-Sprachcompilers f√ºr .NET (ETH Z√ºrich, 2005) und die Implementierung des Prototyps Swift-Compiler f√ºr die Tizen-Plattform ( Samsung Research Institute, Moskau, 2015).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ivan ƒåukiƒá. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020: Eine nichtige Odyssee</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/_4/qw/lz_4qwm76c6mz0aadcqwqcd8av8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ hatte schon immer eine leistungsstarke Subsprache f√ºr die Meta-Programmierung, die es Bibliotheksentwicklern erm√∂glichte, magische Leistungen wie statische Selbstbeobachtung auszuf√ºhren, um eine polymorhpische Ausf√ºhrung ohne Vererbung zu erreichen. </font><font style="vertical-align: inherit;">Das Problem war, dass die Syntax umst√§ndlich und unn√∂tig ausf√ºhrlich war, was das Erlernen der Metaprogrammierung zu einer entmutigenden Aufgabe machte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den j√ºngsten Verbesserungen des Standards und den f√ºr C ++ 20 geplanten Funktionen ist die Metaprogrammierung viel einfacher geworden, und Metaprogramme sind leichter zu verstehen und zu verstehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Vortrag stellt der Autor einige moderne Techniken der Metaprogrammierung vor, wobei der Schwerpunkt auf der magischen Metafunktion void_t liegt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Okhotnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Schauspieler: War es das wert?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/tn/tw/9ttntwqtinuogjfwkd0jjbqn8ko.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Autor des Berichts ist seit 16 Jahren f√ºr die Entwicklung des Open-Source-SObjectizer-Frameworks verantwortlich. </font><font style="vertical-align: inherit;">Dies ist eines der wenigen Live- und plattform√ºbergreifenden Akteur-Frameworks f√ºr C ++. </font><font style="vertical-align: inherit;">Die Entwicklung von SObjectizer begann im Jahr 2002, als C ++ zu den beliebtesten und gebr√§uchlichsten Programmiersprachen geh√∂rte. </font><font style="vertical-align: inherit;">In der letzten Zeit hat sich C ++ stark ver√§ndert, und die Einstellung zu C ++ hat sich noch mehr ver√§ndert. </font><font style="vertical-align: inherit;">In dem Bericht wird er√∂rtert, wie sich diese √Ñnderungen auf die Entwicklung eines Tools mit einer 16-j√§hrigen Geschichte auswirkten und wie einfach und bequem es war, ein solches Tool f√ºr die C ++ - Sprache zu erstellen. </font><font style="vertical-align: inherit;">Und ob es notwendig war, ein solches Tool f√ºr C ++ im Allgemeinen zu erstellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainer Grimm. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Practices f√ºr Parallelit√§t in modernem C ++</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/12/j2/yk12j2luup7tzp2at0vt9epwr6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der Standardisierung von C ++ 11 haben wir in C ++ eine Multithreading-Bibliothek und ein Speichermodell erhalten. </font><font style="vertical-align: inherit;">Die Bibliothek enth√§lt die Grundbausteine ‚Äã‚Äãwie Atomics, Threads, Tasks, Sperren und Bedingungsvariablen. </font><font style="vertical-align: inherit;">Das Speichermodell bietet Garantien f√ºr die thread-sichere Verwendung dieser Grundbausteine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieben Jahre sp√§ter haben wir viele bew√§hrte Methoden, um Multithreading und das Speichermodell auf sichere Weise anzuwenden. </font><font style="vertical-align: inherit;">Im Vortrag des Autors geht es genau um diese Best Practices f√ºr allgemeine Regeln f√ºr die Parallelit√§t, spezielle Regeln f√ºr die Multithreading-Bibliothek und spezielle Regeln f√ºr das Speichermodell. </font><font style="vertical-align: inherit;">Der Fokus dieser Best Practices liegt weit √ºber C ++ hinaus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Malov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahrung in der Verwendung von modernem C ++ bei der Entwicklung von Desktop-Anwendungen</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uu/te/59/uute59evuanipkaccp6qabg1ari.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Vortrag befasst sich mit den Tools der C ++ - Sprache und den Boost- und STL-Bibliotheken sowie mit architektonischen Ans√§tzen zum Erstellen von GUI-Anwendungen, mit denen wir ein Tool zum Erstellen von Videolektionen entwickelt haben. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úben Sie die Verwendung des Model-View-Presenter-Musters </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Document Lifecycle Management </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smart Pointers-Dateispeicherung </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Analyse: Auf der Suche nach Fehlern ... und Schwachstellen?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/it/1h/z7it1hjlb46zf_4xp1pvsqlyqbq.png"></div><br>  Hier und da tauchen regelm√§√üig Nachrichten √ºber die n√§chste Sicherheitsl√ºcke auf.  Die Kollateralverluste von $ sind in der Regel enorm.  Anstatt Schwachstellen zu beheben, sollten sie daher nicht angezeigt werden. <br><br>  Eine M√∂glichkeit, mit Codefehlern umzugehen, ist die statische Analyse.  Aber wie geeignet ist es, nach Schwachstellen zu suchen?  Und gibt es wirklich einen gro√üen Unterschied zwischen einfachen Fehlern und Code-Schwachstellen? <br><br>  Wir werden diese Probleme w√§hrend des Berichts er√∂rtern und gleichzeitig dar√ºber sprechen, wie statische Analysen verwendet werden, um das Beste daraus zu machen. <br><br>  <b>PS</b> <br><br>  Ich m√∂chte Sie alleine auf die Mini-Intrige um <i>std :: string</i> aufmerksam machen, die sich auf die Berichte meines Kollegen Andrei Karpov bezieht.  Also in der Reihenfolge: <br><br><ol><li>  Ein Fragment von Andrei's Bericht (C ++ Russia 2016) "Private Geschichten von Code Analyzer-Entwicklern" von 30:05 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li><li>  Einfaches Trolling von Menschen wie uns von Anton Polukhin (C ++ Russland 2017) im Bericht ‚ÄûWie man es nicht macht: C ++ Fahrradbau f√ºr Profis‚Äú ab 2:00 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li><li>  Andreys Geschichte auf der C ++ Russia 2018 Konferenz, dass wir keine Dinosaurier sind und etwas Neues lernen: "Effective C ++" ab 12:21 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li></ol><br>  Das ist alles!  Viel Spa√ü mit Ihren Berichten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418645/">https://habr.com/ru/post/de418645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418635/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 1</a></li>
<li><a href="../de418637/index.html">Kubernetes an die Massen: Slurm startet am 3. August</a></li>
<li><a href="../de418639/index.html">Akka Streams f√ºr blo√üe Sterbliche</a></li>
<li><a href="../de418641/index.html">Ein Fehler, der einen Designer davon abh√§lt, zu wachsen</a></li>
<li><a href="../de418643/index.html">Sitzen gegen Stehen: Wie kann man besser arbeiten?</a></li>
<li><a href="../de418647/index.html">TESS startet die Exoplaneten-Suche</a></li>
<li><a href="../de418649/index.html">Die kontinuierliche Generierung alternativer Versionen von TLS wird das Problem der Ossifikation des alten Protokolls l√∂sen</a></li>
<li><a href="../de418651/index.html">Digitale Veranstaltungen in Moskau vom 30. Juli bis 5. August</a></li>
<li><a href="../de418653/index.html">Gibt WebAssembly Java- und Flash-Applets zur√ºck?</a></li>
<li><a href="../de418655/index.html">Windows Mixed Reality: Ein Entwicklerhandbuch (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>