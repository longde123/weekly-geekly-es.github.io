<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 🧔🏾 🤲🏽 Beiträge von der Frühjahrskonferenz C ++ Russia 2018 🛁 🥌 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom 19. bis 21. April fand in St. Petersburg die Konferenz C ++ Russia 2018 statt. Von Jahr zu Jahr werden Organisation und Verhalten um eine Ebene hö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beiträge von der Frühjahrskonferenz C ++ Russia 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418645/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/m8/km/ifm8kmasjfgchispcdfdx3-2ax0.png"></div><br>  Vom 19. bis 21. April fand in St. Petersburg die Konferenz C ++ Russia 2018 statt. Von Jahr zu Jahr werden Organisation und Verhalten um eine Ebene höher, was eine gute Nachricht ist.  Dank an den ständigen Organisator von C ++ Russia, Sergey Platonov, für seinen Beitrag zur Entwicklung dieses Gebiets. <br><a name="habracut"></a><br>  Am 19. April waren Meisterkurse geplant, an denen wir leider nicht teilnehmen konnten, und am 20. und 21. fand das Hauptprogramm der Konferenz statt, an dem wir mit großem Interesse teilnahmen.  Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sermp</a> hat einen tollen Job gemacht und mehrere bemerkenswerte ausländische Sprecher als Redner angezogen.  Der erste Tag der Konferenz wurde von Jon Kalb, dem Organisator von CppCon und Autor von C ++ Today: The Beast is Back, eröffnet.  Der zweite Tag begann mit einer Präsentation von Daveed Vandevoorde, Mitglied des Standardisierungsausschusses, einem der Autoren von C ++ - Vorlagen: The Complete Guide.  Andrei Alexandrescu stand im Mittelpunkt der Aufmerksamkeit, der nach seinem Bericht über Ausnahmen einmal eine ganze Menge von Menschen versammelte, die ein Autogramm bekommen und ein gemeinsames Foto machen wollten.  Zum ersten Mal wurde auf Skype ein Herb Sutter-Vortrag über den Raumschiff-Betreiber für C ++ 20 ausgestrahlt. <br><br>  Obwohl die Konferenz vor mehr als drei Monaten stattfand, wurde das Video ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständige Wiedergabeliste</a> ) gerade darauf veröffentlicht. Es ist also an der Zeit, Ihre Erinnerungen aufzufrischen und in die erstaunlichen Funktionen von C ++ einzutauchen. <br><br><h3>  Jon Kalb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Heute: Das Biest ist zurück</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qj/4d/qxqj4duts1eygoh4trgst-2i8bw.png"></div><br>  In diesem Vortrag wird erläutert, warum Ingenieure, die nach Leistung suchen, C ++ wählen.  Jon präsentiert eine historische Perspektive von C ++ und konzentriert sich darauf, was gerade in der C ++ - Community vor sich geht und wohin die Sprache und ihre Benutzerbasis führen.  Mit einem erneuten Interesse an Leistung sowohl für Rechenzentren als auch für mobile Geräte und dem Erfolg von Open Source-Softwarebibliotheken ist C ++ zurück und es ist heiß.  In diesem Vortrag wird erklärt, warum C ++ für die Leistung die Sprache der meisten Softwareentwickler ist.  Sie erhalten eine grobe historische Skizze, die C ++ relativiert und die Höhen und Tiefen seiner Popularität abdeckt. <br><br><h3>  Arno Schödl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von Iteratoren zu Bereichen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/wi/1c/g2wi1czg7ulvtypu_8xqlz1irdo.png"></div><br>  Iteratorpaare sind in der gesamten C ++ - Bibliothek allgegenwärtig.  Es ist allgemein anerkannt, dass das Kombinieren eines solchen Paares zu einer einzigen Entität, die üblicherweise als Range bezeichnet wird, einen präziseren und lesbareren Code liefert.  Die genaue Semantik eines solchen Range-Konzepts zu definieren, erweist sich jedoch als überraschend schwierig.  Theoretische Überlegungen stehen im Widerspruch zu praktischen.  Einige Entwurfsziele sind insgesamt nicht miteinander kompatibel. <br><br><h3>  Jonathan Boccara.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">105 STL-Algorithmen in weniger als einer Stunde</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/lf/ga/jvlfga-cdxxb3furo797y5ezpfy.png"></div><br>  Wir sind uns alle bewusst, dass wir die STL-Algorithmen kennen sollten.  Wenn wir sie in unsere Entwürfe aufnehmen, können wir unseren Code ausdrucksvoller und robuster gestalten.  Und manchmal auf spektakuläre Weise. <br><br>  Aber kennen Sie Ihre STL-Algorithmen? <br><br>  In diesem Vortrag stellt der Autor 105 Algorithmen vor, über die die STL derzeit verfügt, einschließlich der in C ++ 11 und C ++ 17 hinzugefügten.  In diesem Vortrag geht es jedoch nicht nur um eine Auflistung, sondern auch darum, die verschiedenen Gruppen von Algorithmen, die Muster, die sie in der STL bilden, und die Beziehung zwischen den Algorithmen darzustellen. <br><br>  Diese Art von Gesamtbild ist der beste Weg, um sich tatsächlich an alle zu erinnern, und stellt eine Toolbox dar, die voller Möglichkeiten ist, unseren Code ausdrucksvoller und robuster zu machen. <br><br><h3>  Viktor Kirilov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interaktive C ++ - Kompilierung (REPL): Der schlanke Weg</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/bd/4w/zzbd4w9yrkytmf3aqgamwc6iafw.png"></div><br>  Wollten Sie schon immer einen Wert ändern oder eine Anweisung ausführen, während Ihr C ++ - Programm ausgeführt wird, um etwas zu testen - nicht trivial oder mit einem Debugger möglich?  Skriptsprachen haben eine REPL (Read-Eval-Print-Loop).  Das Nächste, was C ++ hat, ist das Festhalten (entwickelt von Forschern am CERN), aber es basiert auf LLVM und ist sehr umständlich einzurichten.  RCRL (Read-Compile-Run-Loop) ist ein Demo-Projekt, das einen innovativen Ansatz für die plattform- und compilerunabhängige C ++ - Kompilierung zur Laufzeit zeigt, der einfach eingebettet werden kann.  In dieser Präsentation wird gezeigt, wie es verwendet wird, wie es funktioniert und wie es geändert und in jede Anwendung und jeden Workflow integriert werden kann. <br><br><h3>  Victor Ciura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genug string_view, um uns aufzuhängen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/gz/sl/bmgzslbc51pb7tc4f-jeaoywee4.png"></div><br>  Wäre es nicht schön, wenn wir einen Standard-C ++ - Typ zur Darstellung von Zeichenfolgen hätten?  Oh, warte ... wir machen: std :: string.  Wäre es nicht schön, wenn wir diesen Standardtyp für unsere gesamte Anwendung / unser gesamtes Projekt verwenden könnten?  Nun ... wir können nicht!  Es sei denn, wir schreiben eine Konsolen-App oder einen Dienst.  Wenn wir jedoch eine App mit GUI schreiben oder mit modernen Betriebssystem-APIs interagieren, müssen wir uns wahrscheinlich mit mindestens einem anderen nicht standardmäßigen C ++ - Zeichenfolgentyp befassen.  Je nach Plattform und Projekt kann es sich um CString von MFC oder ATL, Platform :: String von WinRT, QString von Qt, wxString von wxWidgets usw. handeln.  Oh, vergessen wir nicht unseren alten Freund const char *, besser noch const wchar_t * für die C-Familie von APIs ... <br><br>  Wir haben also zwei Zeichenfolgentypen in unserer Codebasis gefunden.  OK, das ist überschaubar: Wir bleiben bei std :: string für den gesamten plattformunabhängigen Code und konvertieren bei der Interaktion mit System-APIs oder GUI-Code hin und her in den anderen XString.  Wir werden einige unnötige Kopien machen, wenn wir diese Brücke überqueren, und am Ende werden wir einige komisch aussehende Funktionen haben, die zwei Arten von Saiten jonglieren.  aber das ist doch klebercode ... richtig? <br><br>  Es ist ein guter Plan ... bis unser Projekt wächst und wir viele String-Dienstprogramme und Algorithmen sammeln.  Beschränken wir diese algorithmischen Extras auf std :: string?  Greifen wir auf den gemeinsamen Nenner const char * zurück und verlieren die Typ- / Speichersicherheit unseres C ++ - Typs?  Ist C ++ 17 std :: string_view die Antwort auf alle unsere String-Probleme? <br><br>  Der Autor versucht, die Optionen zusammen mit einer Fallstudie zu einer 15 Jahre alten Windows-Anwendung zu untersuchen: Advanced Installer (www.advancedinstaller.com) - ein aktiv entwickeltes C ++ - Projekt, das dank Clang-Tidy auf C ++ 17 modernisiert wurde und "Clang Power Tools" ( <a href="">www.clangpowertools.com)</a> ... <br><br><h3>  Andrei Alexandrescu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erwarten Sie das Erwartete</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/76/5i/k4765i7g8pxr-u0qfvk433pbfnk.png"></div><br>  Das Schreiben von Code, der bei Fehlern stabil ist, war in allen Sprachen schon immer ein Problem.  Ausnahmen sind das politisch korrekte Mittel, um Fehler in C ++ zu signalisieren. Viele Anwendungen greifen jedoch aus Gründen des besseren Verständnisses, der einfachen Handhabung von Fehlern vor Ort und der Effizienz des generierten Codes immer noch auf Fehlercodes zurück. <br><br>  Dieser Vortrag zeigt, wie verschiedene theoretische und praktische Artefakte miteinander kombiniert werden können, um Fehlercodes und Ausnahmen in einem gesunden, einfachen Paket zu beheben.  Der generische Typ Expected kann sowohl für lokale (Fehlercode-Stil) als auch für zentralisierte (Ausnahme-Stil) Manieren verwendet werden, wobei die jeweiligen Stärken berücksichtigt werden. <br><br><h3>  Borislav Stanimirov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DynaMix: Eine neue Sicht auf Polymorphismus</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2r/ji/ej/2rjiej_ldue2ztihyhwrgy7lhaa.png"></div><br>  Software mit sehr komplexer Geschäftslogik wie Spiele, CAD-Systeme und Unternehmenssysteme muss häufig zur Laufzeit Objekte erstellen und ändern, um beispielsweise eine Methode in einem vorhandenen Objekt hinzuzufügen oder zu überschreiben.  Standard C ++ hat starre Typen, die zur Kompilierungszeit definiert werden und dies erschweren.  Sprachen mit dynamischen Typen wie Lua, Python und JavaScript machen dies jedoch sehr einfach.  Daher verwenden viele Projekte solche Sprachen neben C ++, um den Code lesbar und wartbar zu halten und komplexe Anforderungen an die Geschäftslogik zu erfüllen.  Einige Nachteile dieses Ansatzes sind die zusätzliche Komplexität in einer Sprachbindungsschicht, der Leistungsverlust durch die Verwendung einer interpretierten Sprache und die unvermeidliche Codeduplizierung für viele kleine Dienstprogrammfunktionen. <br><br>  DynaMix ist eine Bibliothek, die versucht, die Notwendigkeit einer separaten Skriptsprache zu beseitigen oder zumindest stark zu reduzieren, indem die Benutzer zur Laufzeit in C ++ polymorphe Objekte erstellen und ändern können.  In diesem Vortrag wird dieses Problem näher erläutert und potenziellen Benutzern oder Personen, die von dem Ansatz profitieren könnten, die Bibliothek und ihre Hauptfunktionen anhand eines kommentierten Beispiels und einer kleinen Demo vorgestellt. <br><br><h3>  Mikhail Matrosov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielseitiges C ++ angewendet</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/ox/ha/aooxhajausoz9zfpywpbrsz8wsa.png"></div><br>  In C ++ können Sie eine einzelne Aufgabe auf mehrere Arten lösen.  Der Autor wählt eine tatsächliche Aufgabe aus der Produktion aus und untersucht, wie sie mit einer Reihe von Tools gelöst werden kann, die C ++ bereitstellt: STL-Container, boost.range, C ++ 20-Bereiche, Coroutinen.  Er vergleicht auch API-Einschränkungen und die Leistung verschiedener Lösungen und wie sie leicht von einer zur anderen konvertiert werden können, wenn der Code gut strukturiert ist.  Währenddessen untersucht der Autor auch Anwendungen einiger nützlicher C ++ 17-Funktionen wie constexpr if, Auswahlanweisungen mit Initialisierer, std :: not_fn usw.  Besonderes Augenmerk wird auf themenbezogene Standardalgorithmen gelegt. <br><br><h3>  Alexander Granin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionaler Ansatz für den Software-Transaktionsspeicher</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/ty/uh/d-tyuhxlhdvvelofkinuwnmpyl4.png"></div><br>  Parallele Programmierung ist ein sehr facettenreiches und tiefgreifendes Thema.  Im Laufe der Jahrzehnte der Forschung wurde eine Vielzahl von Ansätzen, Praktiken und Werkzeugen entwickelt, aber wir können kaum davon ausgehen, dass die C ++ - Sprache mit diesen Trends Schritt gehalten hat.  Beginnend mit dem C ++ 11-Standard wurden Konzepte wie std :: thread, std :: atomic, std :: future und std :: mutex eingeführt, und es wird erwartet, dass in Zukunft Coroutinen, ein Modell für asynchrone Berechnungen, hinzugefügt werden.  Nun, das sind alles interessante Dinge, die es zu studieren gilt, aber der Bericht wird sich auf eine ganz andere Idee konzentrieren. <br><br>  Software Transactional Memory (STM) - das Konzept eines transaktionsveränderlichen Datenmodells - existiert seit langem und verfügt über eine Reihe von Implementierungen für alle Sprachen.  Mit STM drücken Sie Ihr Datenmodell aus und starten es, um es wettbewerbsfähig über mehrere Threads hinweg zu ändern, ohne sich um die Thread-Synchronisierung, den gültigen Datenstatus oder Sperren kümmern zu müssen.  STM wird alles für Sie tun.  Das klingt sehr gut, aber nicht alle STM-Bibliotheken sind gleich nützlich.  Herkömmliche imperative STMs sind sehr komplex, anfällig für nicht triviale Multithread-Fehler und schwierig zu verwenden.  Andererseits gibt es in der Welt der funktionalen Programmierung seit langem das Konzept des kombinatorischen STM, Transaktionen, bei denen es sich um zusammensetzbare Bausteine ​​handelt, aus denen Sie Transaktionen auf einer höheren Ebene erstellen.  Der kombinatorische Ansatz für STM ermöglicht es Ihnen, ein wettbewerbsfähiges Datenmodell flexibler, klarer und zuverlässiger auszudrücken.  Parallele Programmierung kann auch Spaß machen! <br><br>  In dem Bericht wird der Autor über die Funktionen von kombinatorischem STM sprechen, wie es verwendet wird und wie es in C ++ 17 implementiert werden kann. <br><br><h3>  Vadim Vinnik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sammelabwicklung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzelne Essenz, mehrere Manifestationen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/4-/09/xh4-09mvu7jukasuqttn0-ipifu.png"></div><br>  Während der gesamten Geschichte der Programmierung war und ist die sequentielle elementweise Verarbeitung verschiedener Arten von Sammlungen eine der häufigsten praktischen Aufgaben.  Die interne Darstellung der Sammlungen sowie der Algorithmus zum Abrufen nachfolgender Elemente können in einem sehr großen Bereich variieren: Array, verknüpfte Liste, Baum, Hash-Tabelle, Datei et al.  Hinter der Vielfalt der Redewendungen, Standardbibliotheksfunktionen und Ad-hoc-Lösungen kann man jedoch die Essenz aufdecken, die für diese ganze Klasse von Aufgaben unveränderlich bleibt.  Dieser Vortrag soll einen schrittweisen Übergang von Algorithmen auf der Grundlage einer expliziten Beschreibung von Aktionen über einzelne Elemente hin zu deklarativen Verarbeitungswerkzeugen auf hoher Ebene zeigen, die eine Sammlung als Einheit behandeln und die Logik der Domäne angemessen offenlegen. <br><br><h3>  Dmitry Banshchikov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Freigegebene Bibliotheken ohne externe Abhängigkeiten</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/75/rt/xn/75rtxnsxinft9v9g2bs2rtyc2sy.png"></div><br>  Der Autor wird über seine Erfahrungen bei der Entwicklung einer Antiviren-Engine in C ++ in Form einer gemeinsam genutzten Bibliothek berichten.  Ein einzigartiges Merkmal ist das Fehlen externer Abhängigkeiten (Laufzeit C ++ oder C).  Diese ganze Reihe basiert auf der Verwendung einer benutzerdefinierten Toolchain in GCC für ein spezielles Ziel, das libc newlib für dasselbe Ziel verwenden wird, auf dem libstdc ++ basiert.  Dementsprechend wird die gemeinsam genutzte Bibliothek über eine benutzerdefinierte Toolchain mit benutzerdefinierten libgcc_s, libc, libcstdc ++ zusammengestellt (Änderungen nur in der Assembly).  Die gesamte Interaktion mit der Laufzeit erfolgt über die gemeinsam genutzte Bibliothek ABI.  Somit behält die Bibliothek die Möglichkeit, vollwertiges modernes C ++ ohne Einschränkungen (RTTI, Ausnahmen, iostream usw.) zu verwenden, das an libstdc ++ libc (newlib) | geht  l ibgcc-ABI.  Ein ähnlicher Ansatz wurde mit den Toolketten GCC / newlib / libstdc ++ für Linux und clang / newlib / libc ++ für MacOS getestet.  Der Bericht ist möglicherweise für diejenigen von Interesse, die C ++ in gemeinsam genutzten Bibliotheken verwenden möchten, kann ihn sich jedoch aufgrund externer Abhängigkeiten nicht leisten. <br><br><h3>  Ilya Shishkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So unterrichten Sie die C ++ - Sprache: die Erfahrung beim Erstellen von Kursen auf Coursera</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/zk/e6/sjzke6dn32bnehol5pyaeg9bmpe.png"></div><br>  In den letzten anderthalb Jahren hat der Autor die Coursera-Spezialisierung für modernes C ++ geleitet.  Die Spezialisierung besteht aus fünf Kursen, von denen zwei bereits laufen und ein weiterer fast fertig ist. <br><br>  Der Bericht wird sagen: <br><br><ul><li>  Welche Probleme können bei der Arbeit an Kursen auftreten (zum Beispiel haben die Entwickler nach 3 Monaten Arbeit alle Materialien weggeworfen und erneut begonnen) </li><li>  wie der Lehrplan gebildet wird und warum genau (zum Beispiel, warum das Wort "Zeiger" in den ersten beiden Kursen nicht einmal geklungen hat) </li></ul><br>  Darüber hinaus wurde während der Spezialisierungsarbeit eine Reihe von Grundsätzen entwickelt, die in der täglichen Arbeit anwendbar sind: <br><br><ul><li>  bei der Integration eines neuen Mitarbeiters in das Projekt </li><li>  während der Codeüberprüfung </li><li>  bei der Einstellung </li></ul><br>  Daher möchte der Autor nicht nur erzählen, wie er sich spezialisiert, sondern auch versuchen, die gesammelten Erfahrungen auf alltägliche Aufgaben zu übertragen. <br><br><h3>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Absturz von NDK-Berichten für Android</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/yx/zc/h9yxzc_vcjlymv-gzh28xsaock4.png"></div><br>  Es ist kein Geheimnis, dass die Entwicklung in C / C ++ viel höhere Anforderungen an die Codequalität stellt als die Entwicklung in Java.  Die Wahrscheinlichkeit, einen fatalen Fehler zu machen, ist viel höher.  Gleichzeitig ist das Sammeln von Informationen über solche Fehler selbst für erfahrene Programmierer keine triviale Aufgabe. <br><br>  Im ersten Teil des Berichts werden wir kurz auf die bestehenden Entwicklungen eingehen: Wie der integrierte Android-Debugger funktioniert, welche Lösungen bereits existieren.  Der zweite Teil ist der Geschichte gewidmet, wie es "unter der Haube" funktioniert: wie man den Status des Prozessors zum Zeitpunkt des Fehlers erhält, wie man den Aufrufstapel abwickelt, wie man die Zeilennummern im Quellcode herausfindet.  Es wird eine Übersicht über Stack-Promotion-Bibliotheken wie libcorkscrew, libunwind, libunwindstack gegeben. <br><br>  Der Bericht wird sowohl für Android-Entwickler, deren Anwendungen NDK verwenden, als auch für alle anderen von Interesse sein, um ihren Horizont zu erweitern. <br><br><h3>  Fedor Short.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erinnerung ist die perfekte Abstraktion</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/yh/ns/tcyhnsqf9zd7owu6oylohlcgkqe.png"></div><br>  int * ptr = new int; <br>  * ptr = 42; <br>  ptr löschen; <br><br>  Was passiert eigentlich, wenn diese 3 Codezeilen ausgeführt werden?  Wir werden uns den Speicherzuweiser, das Betriebssystem und die moderne Hardware ansehen, um eine umfassende Antwort auf diese Frage zu geben. <br><br><h3>  Alexey Salmin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps und Tricks zur Speicherverwaltung</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/re/ju/yirejuytypvwzo-ldwc-jmd4ylg.png"></div><br>  Im Jahr 2017 verliert das Problem der Auswahl eines Allokators in C ++ nicht an Relevanz.  Sie haben dem Standard eine neue Methode hinzugefügt, um einen lokalen Allokator für Container (std :: pmr), globales tcmalloc und jemalloc sowie die Kernel-Schnittstellen, auf die sie sich verlassen, auszuwählen.  Dieser Bericht ist der "unteren Etage" dieses Entwurfs gewidmet: den Funktionen von mmap und madvise im Linux-Kernel und den Auswirkungen dieser Funktionen auf die Leistung von Allokatoren. <br><br><h3>  Kräutersutter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neu in C ++ 20: Der Raumschiffoperator</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ex/dw/jhexdwnxovbsvpbtftm3jmrofr0.png"></div><br>  Das neue Raumschiff wurde kürzlich als Sprachfunktion für C ++ 20 übernommen.  In diesem Vortrag gibt der Designer und Autor des Raumschiffvorschlags einen Überblick über das Feature, diskutiert dessen Motivation und Design und geht durch Beispiele für dessen Verwendung.  Er legt besonderen Wert darauf, wie die Funktion das Schreiben und Lesen von C ++ - Code sauberer macht, schneller durch Vermeidung redundanter Arbeit und robuster, indem mehrere wichtige, aber subtile Fallstricke in dem spröderen Code vermieden werden, den wir zuvor ohne diese Funktion von Hand schreiben mussten. <br><br><h3>  Anastasia Kazakova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen von C ++ - Code ohne Ausführen und Kompilieren</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/na/ve/atnaverrgqdy-zv-xexxy6oan_g.png"></div><br>  Wenn Sie sich Vorlagen, Reflexion, Codegenerierung in der Kompilierungsphase und Metaklassen ansehen, haben Sie das Gefühl, dass C ++ es sich zur Aufgabe gemacht hat, den endgültigen Code so weit wie möglich vor dem Entwickler zu „verbergen“.  Eine nicht triviale Verwendung des Präprozessors (und zahlreicher Zweige) kann die Programmsequenz sehr offensichtlich machen.  Diese Ansätze ersparen Entwicklern natürlich das endlose Kopieren und Einfügen ähnlicher Teile der Codebasis, erfordern jedoch eine erweiterte Unterstützung in den Entwicklungstools. <br><br>  Ist es möglich, Code zu debuggen, ohne ihn kontinuierlich neu zu starten, ohne einen Debugger und sogar ohne eine einfache Kompilierung der gesamten Codebasis?  Ist es möglich, Fehler im Code zu finden, die nicht zusammengestellt oder auf dem lokalen Computer ausgeführt werden können?  Da ist!  Integrierte Entwicklungsumgebungen (IDEs) verfügen über umfassende Kenntnisse und Kenntnisse in Bezug auf benutzerdefinierten Code und können die entsprechenden Tools bereitstellen. <br><br>  Dieser Bericht zeigt, wie man durch typedef verschachtelte Makrosubstitutionen „debuggen“, die Variablentypen (die in modernem C ++ häufig „versteckt“ sind) verstehen, verschiedene Zweige der Überladung von Präprozessoren oder Operatoren debuggen und vieles mehr mithilfe eines wirklich intelligenten Geräts IDE  Einige der Funktionen sind bereits in CLion und ReSharper C ++ verfügbar, andere sind nur interessante Ideen für die Zukunft, die mit dem Publikum diskutiert werden könnten. <br><br><h3>  Eugene Lukyanets.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie Docker mit Conan</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kt/es/9y/ktes9yg6zny3qia9p2qd6mksxqm.png"></div><br>  Die Assembly eines C ++ - Projekts kann in den Docker-Container verschoben werden. Anstatt die erforderlichen Bibliotheken und Abhängigkeiten im Hostsystem zu installieren, können sie entweder direkt im Docker-Image (z. B. Cuda) oder mit dem C ++ - Manager der Conan-Bibliothek (z. B.) installiert werden. Boost).  Dies führt zu einer isolierten kontrollierten (und jedes Mal gleichen) Umgebung für die Assembly, in die Sie den Conan-Cache einbinden können, sodass verschiedene Projekte, die dieselben Bibliotheken verwenden, dieselben Assemblys verwenden.  Außerdem hängt der Build nicht mehr von der Linux-Distribution ab, in der das Projekt erstellt wird. Hauptsache, Sie können Docker auf dieser Distribution ausführen. <br><br><h3>  Denis Panin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktische Metaprogrammierung: Schreiben einer heterogenen Hash-Tabelle</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/zf/8d/ilzf8daway7fam09ukocar1bdpw.png"></div><br>  Im Verlauf des Berichts werden wir eine kleine Arbeitsbibliothek mit std :: tuple schreiben.  Mit dieser Bibliothek kompilieren wir die Kompilierungszeit in eine heterogene Hash-Tabelle.  Weiter - auf seiner Basis werden wir ein kleines RPC-Framework schreiben, wobei wir die Tatsache verwenden, dass wir keine Typlöschung haben. <br><br>  In C ++ 17 wird es viele constexpr-Berechnungen, Vorlagen und neue Funktionen geben (insbesondere wenn constexpr). <br><br><h3>  Dmitry Sokolov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codegenerierung als Reflexion für die Armen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/cy/ey/m6cyeyyxuncuuz_jzzlzzcwj8q8.png"></div><br>  Reflexion ist häufig erforderlich, um Serialisierungsalgorithmen zu verallgemeinern.  Implementierung verschiedener Protokolle, Arbeit mit Datenbanken.  Um solche Probleme zu lösen, haben wir einen Homebrew-IDL-Compiler zum Generieren von C ++ - Strukturen und eine Bibliothek zur Interaktion mit dem Ergebnis geschrieben.  Protobuf mit Pedalen und ob es sich gelohnt hat. <br><br><h3>  Daveed Vandevoorde.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflektierende Metaprogrammierung in C ++</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/ho/ie/5choiecmddpmcbekwyekclxdmlq.png"></div><br>  Vor einiger Zeit hat das C ++ - Standardisierungskomitee eine Untergruppe "SG-7" erstellt, um zu untersuchen, wie der Sprache Reflexionsfunktionen hinzugefügt werden können.  In jüngerer Zeit hat diese Gruppe ihrer Platte "Metaprogrammierung" hinzugefügt und einige wichtige Entscheidungen hinsichtlich der Form der möglichen Lösung getroffen.  In diesem Vortrag untersucht der Autor die Vergangenheit, die uns hierher gebracht hat, und untersucht einen möglichen Weg für C ++ 's erstklassige Unterstützung der "reflektierenden Metaprogrammierung". <br><br><h3>  Dietmar Kühl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konzeptbasiertes Testen</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/sa/3s/stsa3scg4ux8lm4x7avft5qzabg.png"></div><br>  Mit der Hinzufügung von Konzepten zur nächsten Version von C ++ wird erwartet, dass neue Konzepte definiert werden.  Jedes Konzept definiert eine Reihe von Operationen, die von generischem Code verwendet werden.  Eine solche Verwendung könnte ein generischer Test sein, der überprüft, ob alle Teile eines Konzepts definiert sind, und generische Interaktionen zwischen den Operationen eines Konzepts überprüft.  Im Idealfall funktioniert ein solcher Test sogar mit Klassen, die ein Konzept nur teilweise modellieren, um die Implementierung von Klassen zu steuern. <br><br>  Diese Präsentation verwendet nicht die eigentlichen Konzepterweiterungen, sondern zeigt, wie generische Tests mit den Funktionen von C ++ 17 erstellt werden können.  Für die generischen Tests werden die Erkennungssprache und der Kontext verwendet, um die Verfügbarkeit der erforderlichen Operationen zu bestimmen und die Abwesenheit von Operationen ordnungsgemäß zu behandeln.  Die generischen Tests sollten in der Lage sein, die Grundlagen von Klassen zu erfassen, die ein Konzept modellieren.  Offensichtlich erfordert ein spezifisches Verhalten für Klassen immer noch entsprechende Tests. <br><br><h3>  Simon Brand  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moderne C ++ - Parallelität von CPU zu GPU</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/qz/st/qqqzstnuzvnt3ev15p-9hngj3iy.png"></div><br>  Parallele Programmierung kann verwendet werden, um Multi-Core- und heterogene Architekturen zu nutzen und die Leistung von Software erheblich zu steigern.  Modernes C ++ hat viel dazu beigetragen, die parallele Programmierung einfacher und zugänglicher zu machen.  Bereitstellung von Abstraktionen auf hoher und niedriger Ebene.  C ++ 17 geht noch einen Schritt weiter und bietet parallele Algorithmen auf hoher Ebene. In C ++ 20 wird noch viel mehr erwartet.  Dieser Vortrag gibt einen Überblick über die derzeit verfügbaren Parallelitätsdienstprogramme und gibt einen Überblick über die Zukunft, wie GPUs und heterogene Systeme durch neue Standardbibliotheksfunktionen und andere Standards wie SYCL unterstützt werden können. <br><br><h3>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effektives C ++ (Maers hat nichts damit zu tun :)</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/lp/mu/rblpmu6fzwwn7hnt3cim-pipjf0.png"></div><br>  Die C ++ - Sprache und die damit verbundene Infrastruktur entwickeln sich weiter, was diese Sprache derzeit zu einem der effektivsten Tools macht.  Ich möchte drei Faktoren hervorheben, die die C ++ - Sprache jetzt so attraktiv machen. <br><br><ul><li>  Erstens: Innovationen im Sprachstandard, mit denen Sie effizienten Code schreiben können. </li><li>  Zweitens: die Reife der Entwicklungswerkzeuge und eine Beschleunigung der Montage von Projekten. </li><li>  Drittens: ausgereifte Support-Tools, mit denen Sie die Qualität des Codes und andere Aspekte des Projektlebenszyklus steuern können. </li></ul><br>  Dieser Bericht ist eine Ode an die Programmiersprache C ++! <br><br><h3>  Ivan Puzyrevsky.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchronität in der Programmierung</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/vx/iw/3gvxiw02427rxts0p3nza4kburu.png"></div><br>  Auf dem Gebiet der Entwicklung hoch geladener Multithread- oder verteilter Anwendungen kann man zunehmend Gespräche über asynchronen Code hören, einschließlich Spekulationen über die Notwendigkeit (mangelnde Notwendigkeit), die Asynchronität im Code zu berücksichtigen, über die Verständlichkeit (Unverständlichkeit) von asynchronem Code und dessen Effizienz (Ineffizienz).  In diesem Bericht werden wir versuchen, tiefer in den Themenbereich einzutauchen: Wir werden analysieren, was Asynchronität ist;  wenn es entsteht;  wie sich dies auf den von uns geschriebenen Code und die von uns verwendete Programmiersprache auswirkt.  Wir werden versuchen herauszufinden, was Zukunft und Versprechen damit zu tun haben. Lassen Sie uns ein wenig über Coroutinen und Schauspieler sprechen.  Wir werden JavaScript und Betriebssysteme beeinflussen.  Der Zweck des Berichts besteht darin, die Kompromisse, die sich aus dem einen oder anderen Ansatz bei der Entwicklung von Multithread- oder verteilter Software ergeben, deutlicher zu machen. <br><br><h3>  Pavel Bulatov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wechsel zu WebAssembly: Ist das Spiel die Kerze wert?</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/s6/ga/vts6gamnunde4u6qzk6p_4zqc6c.png"></div><br>  In dem Bericht wird der aktuelle Status von WebAssembly in Bezug auf reale Produkte erörtert.  Wir werden über unsere Erfahrungen mit der Portierung der Anwendung sprechen, darüber, welche Probleme aufgetreten sind und wie wir sie gelöst haben. <br><br>  Zu den behandelten Themen gehören: <br><br><ul><li>  Unterstützung für den Standard auf verschiedenen Plattformen und Browsern. </li><li>  Leistung und Build-Größe im Vergleich zu asm.js. </li><li>  Interaktionen mit dem Browser. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build stürzt vom Benutzer ab. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM-Funktionen. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Kozhevnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake Fallstricke und wo sie leben</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/_l/qr/zt_lqrmu-qimm8_m2z7g_zd2xsg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das CMake-Build-System wird allmählich zum De-facto-Standard für die plattformübergreifende C ++ - Programmierung. </font><font style="vertical-align: inherit;">Es wird jedoch häufig fair kritisiert, unter anderem wegen der unbequemen Skriptsprache, der veralteten Dokumentation und der Tatsache, dass dieselben Aufgaben auf unterschiedliche Weise ausgeführt werden können und es ziemlich schwierig sein kann zu verstehen, welche in einer bestimmten Situation korrekter ist . </font><font style="vertical-align: inherit;">Der Autor wird sagen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> häufige populäre Anti-Muster und warum sie schlecht sind, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf welchen Abstraktionsebenen funktioniert CMake und wann „lecken“ sie? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist "Modern CMake" und was sind seine Vorteile? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lokalisieren und Debuggen von Problemen in CMake-Skripten (einschließlich einiger eher exotischer). </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Shambir. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn prozedurales C ++ gut ist</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ib/vy/kxibvyhzvf5taodgpswkywptk9y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die klare Architektur des Projekts, einfache Abstraktionen auf jeder Ebene ist der Traum eines jeden Teams. </font><font style="vertical-align: inherit;">Um diesen Traum zu verwirklichen, wurden viele objektorientierte Techniken erfunden. </font><font style="vertical-align: inherit;">Von OOP mitgenommen, vergessen Entwickler, die Sauberkeit des Codes an der Kreuzung von C und C ++ zu überwachen. </font><font style="vertical-align: inherit;">Hier hilft der prozedurale Stil dabei, die Ordnung wiederherzustellen, bequeme und sichere Abstraktionen zu erstellen, die leicht in den objektorientierten Code des Projekts passen. </font><font style="vertical-align: inherit;">Wir werden herausfinden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum müssen Sie die C-API isolieren (z. B. Winapi, POSIX, SQLite, OpenGL, OpenSSL)? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum arbeitet OOP in diesem Geschäft schlecht? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie schreibe ich eine Abstraktionsschicht über die API im C-Stil? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgang mit Rückrufen, Fehlerbehandlung und Ressourcenverwaltung, um traditionell komplexen und verwirrenden Code auch für Junioren verständlich zu machen </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Zuev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semantische API für C ++ - Programme</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/wb/d4/-ewbd4monfzqy8msagott8iaxzu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seine beruflichen Interessen sind die Semantik von Programmiersprachen, das Design und die Implementierung von Compilern von YaP und anderen sprachorientierten Tools. </font><font style="vertical-align: inherit;">Zu den wichtigsten Errungenschaften zählen die Teilnahme an Projekten wie die Erstellung eines Compilers des vollständigen C ++ - Sprachstandards (Interstron, Moskau, 2000), die Implementierung des Zonnon-Sprachcompilers für .NET (ETH Zürich, 2005) und die Implementierung des Prototyps Swift-Compiler für die Tizen-Plattform ( Samsung Research Institute, Moskau, 2015).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ivan Čukić. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020: Eine nichtige Odyssee</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/_4/qw/lz_4qwm76c6mz0aadcqwqcd8av8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ hatte schon immer eine leistungsstarke Subsprache für die Meta-Programmierung, die es Bibliotheksentwicklern ermöglichte, magische Leistungen wie statische Selbstbeobachtung auszuführen, um eine polymorhpische Ausführung ohne Vererbung zu erreichen. </font><font style="vertical-align: inherit;">Das Problem war, dass die Syntax umständlich und unnötig ausführlich war, was das Erlernen der Metaprogrammierung zu einer entmutigenden Aufgabe machte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den jüngsten Verbesserungen des Standards und den für C ++ 20 geplanten Funktionen ist die Metaprogrammierung viel einfacher geworden, und Metaprogramme sind leichter zu verstehen und zu verstehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Vortrag stellt der Autor einige moderne Techniken der Metaprogrammierung vor, wobei der Schwerpunkt auf der magischen Metafunktion void_t liegt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Okhotnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Schauspieler: War es das wert?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/tn/tw/9ttntwqtinuogjfwkd0jjbqn8ko.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Autor des Berichts ist seit 16 Jahren für die Entwicklung des Open-Source-SObjectizer-Frameworks verantwortlich. </font><font style="vertical-align: inherit;">Dies ist eines der wenigen Live- und plattformübergreifenden Akteur-Frameworks für C ++. </font><font style="vertical-align: inherit;">Die Entwicklung von SObjectizer begann im Jahr 2002, als C ++ zu den beliebtesten und gebräuchlichsten Programmiersprachen gehörte. </font><font style="vertical-align: inherit;">In der letzten Zeit hat sich C ++ stark verändert, und die Einstellung zu C ++ hat sich noch mehr verändert. </font><font style="vertical-align: inherit;">In dem Bericht wird erörtert, wie sich diese Änderungen auf die Entwicklung eines Tools mit einer 16-jährigen Geschichte auswirkten und wie einfach und bequem es war, ein solches Tool für die C ++ - Sprache zu erstellen. </font><font style="vertical-align: inherit;">Und ob es notwendig war, ein solches Tool für C ++ im Allgemeinen zu erstellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainer Grimm. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Practices für Parallelität in modernem C ++</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/12/j2/yk12j2luup7tzp2at0vt9epwr6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der Standardisierung von C ++ 11 haben wir in C ++ eine Multithreading-Bibliothek und ein Speichermodell erhalten. </font><font style="vertical-align: inherit;">Die Bibliothek enthält die Grundbausteine ​​wie Atomics, Threads, Tasks, Sperren und Bedingungsvariablen. </font><font style="vertical-align: inherit;">Das Speichermodell bietet Garantien für die thread-sichere Verwendung dieser Grundbausteine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieben Jahre später haben wir viele bewährte Methoden, um Multithreading und das Speichermodell auf sichere Weise anzuwenden. </font><font style="vertical-align: inherit;">Im Vortrag des Autors geht es genau um diese Best Practices für allgemeine Regeln für die Parallelität, spezielle Regeln für die Multithreading-Bibliothek und spezielle Regeln für das Speichermodell. </font><font style="vertical-align: inherit;">Der Fokus dieser Best Practices liegt weit über C ++ hinaus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Malov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahrung in der Verwendung von modernem C ++ bei der Entwicklung von Desktop-Anwendungen</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uu/te/59/uute59evuanipkaccp6qabg1ari.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Vortrag befasst sich mit den Tools der C ++ - Sprache und den Boost- und STL-Bibliotheken sowie mit architektonischen Ansätzen zum Erstellen von GUI-Anwendungen, mit denen wir ein Tool zum Erstellen von Videolektionen entwickelt haben. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Üben Sie die Verwendung des Model-View-Presenter-Musters </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Document Lifecycle Management </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smart Pointers-Dateispeicherung </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Analyse: Auf der Suche nach Fehlern ... und Schwachstellen?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/it/1h/z7it1hjlb46zf_4xp1pvsqlyqbq.png"></div><br>  Hier und da tauchen regelmäßig Nachrichten über die nächste Sicherheitslücke auf.  Die Kollateralverluste von $ sind in der Regel enorm.  Anstatt Schwachstellen zu beheben, sollten sie daher nicht angezeigt werden. <br><br>  Eine Möglichkeit, mit Codefehlern umzugehen, ist die statische Analyse.  Aber wie geeignet ist es, nach Schwachstellen zu suchen?  Und gibt es wirklich einen großen Unterschied zwischen einfachen Fehlern und Code-Schwachstellen? <br><br>  Wir werden diese Probleme während des Berichts erörtern und gleichzeitig darüber sprechen, wie statische Analysen verwendet werden, um das Beste daraus zu machen. <br><br>  <b>PS</b> <br><br>  Ich möchte Sie alleine auf die Mini-Intrige um <i>std :: string</i> aufmerksam machen, die sich auf die Berichte meines Kollegen Andrei Karpov bezieht.  Also in der Reihenfolge: <br><br><ol><li>  Ein Fragment von Andrei's Bericht (C ++ Russia 2016) "Private Geschichten von Code Analyzer-Entwicklern" von 30:05 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li><li>  Einfaches Trolling von Menschen wie uns von Anton Polukhin (C ++ Russland 2017) im Bericht „Wie man es nicht macht: C ++ Fahrradbau für Profis“ ab 2:00 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li><li>  Andreys Geschichte auf der C ++ Russia 2018 Konferenz, dass wir keine Dinosaurier sind und etwas Neues lernen: "Effective C ++" ab 12:21 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . </li></ol><br>  Das ist alles!  Viel Spaß mit Ihren Berichten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418645/">https://habr.com/ru/post/de418645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418635/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 1</a></li>
<li><a href="../de418637/index.html">Kubernetes an die Massen: Slurm startet am 3. August</a></li>
<li><a href="../de418639/index.html">Akka Streams für bloße Sterbliche</a></li>
<li><a href="../de418641/index.html">Ein Fehler, der einen Designer davon abhält, zu wachsen</a></li>
<li><a href="../de418643/index.html">Sitzen gegen Stehen: Wie kann man besser arbeiten?</a></li>
<li><a href="../de418647/index.html">TESS startet die Exoplaneten-Suche</a></li>
<li><a href="../de418649/index.html">Die kontinuierliche Generierung alternativer Versionen von TLS wird das Problem der Ossifikation des alten Protokolls lösen</a></li>
<li><a href="../de418651/index.html">Digitale Veranstaltungen in Moskau vom 30. Juli bis 5. August</a></li>
<li><a href="../de418653/index.html">Gibt WebAssembly Java- und Flash-Applets zurück?</a></li>
<li><a href="../de418655/index.html">Windows Mixed Reality: Ein Entwicklerhandbuch (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>