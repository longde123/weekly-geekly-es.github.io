<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌽 🕺🏿 📢 Dukungan serialisasi JavaScript JavaScript 🔘 👨🏽‍🔧 📗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Saat ini, saya sedang mengembangkan editor skema Javascript, dan dalam proses pekerjaan ini, saya menemukan masalah yang akan menjadi fokus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dukungan serialisasi JavaScript JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog">  Prolog </h3><br><p>  Saat ini, saya sedang mengembangkan editor skema Javascript, dan dalam proses pekerjaan ini, saya menemukan masalah yang akan menjadi fokus artikel ini, yaitu serialisasi dan deserialisasi objek data yang kompleks. </p><br><p> Tanpa membahas detail proyek, saya perhatikan bahwa menurut ide saya, skema adalah array elemen (simpul) yang diwarisi dari kelas dasar.  Dengan demikian, setiap kelas anak mengimplementasikan logikanya sendiri.  Selain itu, simpul berisi tautan satu sama lain (panah), yang juga perlu dipertahankan.  Secara teoritis, simpul dapat merujuk ke diri mereka sendiri secara langsung atau melalui simpul lainnya.  Standard JSON.stringify tidak dapat membuat serialisasi array seperti itu, jadi saya memutuskan untuk membuat serializer sendiri yang memecahkan dua masalah yang dijelaskan: </p><br><ol><li>  Kemampuan untuk menyimpan informasi kelas selama serialisasi dan mengembalikannya selama deserialisasi. </li><li>  Kemampuan untuk menyimpan dan mengembalikan tautan ke objek, termasuk  siklik. </li></ol><br><p>  Baca lebih lanjut tentang pernyataan masalah dan solusinya di bawah potongan. </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Proyek serializer Github </h3><br><p>  Tautan ke proyek github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> . <br>  Contoh kompleks juga ada di folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">test-src</a> . </p><br><p>  Serializer rekursif: <a href="">tautan</a> . <br>  Serializer datar: <a href="">tautan</a> . </p><br><h3 id="postanovka-zadachi">  Pernyataan masalah </h3><br><p>  Seperti yang sudah saya catat, tugas awalnya adalah membuat serial rangkaian arbitrer untuk editor.  Agar tidak membuang waktu menggambarkan editor, kami mengatur tugas lebih mudah.  Misalkan kita ingin membuat deskripsi formal dari skema algoritma sederhana menggunakan kelas Javascript ES6, dan kemudian membuat serial dan deserialize skema ini. </p><br><p>  Di Internet, saya menemukan gambar yang cocok dari algoritma paling sederhana untuk menentukan maksimum dua nilai: </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="gambar"></p><br><p>  Di sini saya harus mengatakan bahwa saya bukan pengembang Javascript, dan bahasa "asli" saya adalah C #, jadi pendekatan untuk menyelesaikan masalah ditentukan oleh pengalaman pengembangan berorientasi objek dalam C #.  Melihat diagram ini, saya melihat simpul dari tipe berikut (nama kondisional dan peran khusus tidak dimainkan): </p><br><ul><li>  Mulai simpul (Mulai) </li><li>  Puncak akhir (Selesai) </li><li>  Team Top (Command) </li><li>  Penugasan Vertex (Biarkan) </li><li>  Verifikasi Verifikasi Atas (Jika) </li></ul><br><p>  Verteks ini memiliki beberapa perbedaan dari satu sama lain dalam kumpulan data atau semantik mereka, tetapi mereka semua diwarisi dari basis simpul (Node).  Di tempat yang sama, di kelas Node, bidang tautan dijelaskan, yang berisi tautan ke simpul lain, dan metode addLink memungkinkan tautan ini ditambahkan.  Kode lengkap dari semua kelas dapat ditemukan di <a href="">sini</a> . </p><br><p>  Mari kita menulis kode yang mengumpulkan rangkaian dari gambar, dan mencoba membuat serialisasi hasilnya. </p><br><div class="spoiler">  <b class="spoiler_title">Kode Desain Algoritma</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p>  Jika kami membuat serialisasi skema ini menggunakan JSON.stringify, kami mendapatkan sesuatu yang buruk.  Saya akan memberikan beberapa baris pertama dari hasilnya, di mana saya menambahkan komentar saya: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify hasil</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p>  Karena  verteks pertama berisi tautan ke yang kedua, dan ke yang berikutnya, kemudian sebagai akibat dari serialisasinya, seluruh rangkaian diserialisasi.  Kemudian puncak kedua adalah serial dan segala sesuatu yang bergantung padanya, dan seterusnya.  Anda dapat mengembalikan tautan asli dari hash ini hanya dengan pengidentifikasi, tetapi mereka tidak akan membantu jika salah satu dari simpul merujuk ke dirinya sendiri secara langsung atau melalui simpul lainnya.  Dalam hal ini, serializer akan <u>membuang UnEught TypeError: Mengubah struktur lingkaran menjadi</u> kesalahan <u>JSON</u> .  Jika tidak jelas, maka di sini adalah contoh paling sederhana yang menghasilkan kesalahan ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsfiddle.net/L4guo86w/</a> . </p><br><p>  Selain itu, JSON tidak mengandung informasi apa pun tentang kelas sumber, sehingga tidak ada cara untuk memahami tipe setiap titik sebelum serialisasi. </p><br><p>  Menyadari masalah ini, saya online dan mulai mencari solusi yang sudah jadi.  Ada banyak, tetapi sebagian besar sangat besar atau memerlukan deskripsi khusus tentang kelas serial, jadi diputuskan untuk membuat sepeda sendiri.  Dan ya, saya suka sepeda. </p><br><h3 id="koncepciya-serializatora">  Konsep Serializer </h3><br><p>  Bagian ini adalah untuk mereka yang ingin berpartisipasi dalam membuat algoritma serialisasi dengan saya, meskipun secara virtual. </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh">  Menyimpan informasi tipe data </h4><br><p>  Salah satu masalah dengan Javascript adalah kurangnya metadata yang dapat bekerja luar biasa dalam bahasa seperti C # atau Java (atribut dan refleksi).  Di sisi lain, saya tidak perlu serialisasi super kompleks dengan kemampuan untuk mendefinisikan daftar bidang serializable, validasi dan chip lainnya.  Oleh karena itu, ide utamanya adalah menambahkan informasi tentang tipenya ke objek dan membuat serial dengan JSON.stringify biasa. </p><br><p>  Saat mencari solusi, saya menemukan sebuah artikel menarik yang judulnya diterjemahkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"6 Cara Salah untuk Menambahkan Jenis Informasi di JSON"</a> .  Sebenarnya, metodenya sangat bagus, dan saya memilih yang ada di nomor 5. Jika Anda terlalu malas untuk membaca artikel, tapi saya sangat menyarankan melakukannya, maka saya akan menjelaskan secara singkat metode ini: ketika membuat serial suatu objek, kami membungkusnya di objek lain dengan satu-satunya. bidang yang namanya dalam format <code>"@&lt;type&gt;"</code> , dan nilainya adalah data objek.  Selama deserialisasi, kami mengekstrak nama jenis, membuat ulang objek dari konstruktor, dan membaca data bidangnya. </p><br><p>  Jika kami menghapus tautan dari contoh kami di atas, maka JSON standar.stringify data berseri seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p>  Dan serializer kami akan membungkusnya seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Hasil serialisasi</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p>  Tentu saja, ada kekurangannya: serializer harus tahu tentang jenis-jenis yang dapat diserialisasi, dan objek itu sendiri tidak boleh berisi bidang yang namanya dimulai dengan anjing.  Namun, masalah kedua diselesaikan dengan kesepakatan dengan pengembang atau dengan mengganti simbol anjing dengan sesuatu yang lain, dan masalah pertama diselesaikan dalam satu baris kode (di bawah ini akan menjadi contoh).  Kami tahu persis apa yang akan kami serialkan, kan? </p><br><h4 id="reshenie-problemy-so-ssylkami">  Memecahkan masalah tautan </h4><br><p>  Ini masih lebih sederhana dalam hal algoritma, tetapi lebih sulit untuk diimplementasikan. </p><br><p>  Saat membuat serial dari kelas-kelas yang terdaftar dalam serializer, kami akan menyimpannya di cache dan memberikan nomor seri.  Jika di masa depan kita bertemu contoh ini lagi, maka dalam definisi pertama kita akan menambahkan nomor ini (nama bidang akan mengambil bentuk <code>"@&lt;type&gt;|&lt;index&gt;"</code> ), dan di tempat serialisasi kita akan memasukkan tautan sebagai objek </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p>  Jadi, selama deserialisasi, kita melihat apa sebenarnya nilai dari bidang tersebut.  Jika ini adalah angka, maka kami mengekstrak objek dari cache dengan nomor ini.  Kalau tidak, ini adalah definisi pertamanya. </p><br><p>  Mari kembalikan tautan dari bagian atas skema ke yang kedua dan lihat hasilnya: </p><br><div class="spoiler">  <b class="spoiler_title">Hasil serialisasi</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p>  Sekilas tidak terlihat jelas, karena  titik kedua didefinisikan pertama di dalam yang pertama di objek komunikasi Tautan, tetapi penting bahwa pendekatan ini bekerja.  Selain itu, saya membuat versi kedua dari serializer, yang memotong pohon tidak di kedalaman, tetapi lebarnya, yang menghindari "tangga" seperti itu. </p><br><h3 id="sozdanie-serializatora">  Buat serializer </h3><br><p>  Bagian ini ditujukan bagi mereka yang tertarik dalam mengimplementasikan ide-ide yang dijelaskan di atas. </p><br><h4 id="zagotovka-serializatora">  Serializer kosong </h4><br><p>  Seperti yang lain, serializer kami akan memiliki dua metode utama - serialisasi dan deserialize.  Selain itu, kita akan memerlukan metode yang memberi tahu serializer tentang kelas-kelas yang harus di-serialisasi (didaftarkan) dan kelas-kelas yang tidak boleh (abaikan).  Yang terakhir ini diperlukan agar tidak membuat serial elemen DOM, objek JQuery, atau tipe data lainnya yang tidak dapat diserialisasi atau yang tidak perlu diserialisasi.  Misalnya, di editor saya, saya menyimpan elemen visual yang sesuai dengan simpul atau tautan.  Itu dibuat selama inisialisasi dan, tentu saja, tidak boleh jatuh ke dalam database. </p><br><div class="spoiler">  <b class="spoiler_title">Kode shell Serializer</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p>  Penjelasan </p><br><p>  Untuk mendaftarkan kelas, Anda harus meneruskan konstruktornya ke metode pendaftaran dengan salah satu dari dua cara berikut: </p><br><ol><li>  daftar (MyClass) </li><li>  daftar ('MyNamespace.MyClass', MyClass) </li></ol><br><p>  Dalam kasus pertama, nama kelas akan diekstraksi dari nama fungsi konstruktor (tidak didukung di IE), di saat Anda menentukan nama sendiri.  Metode kedua lebih disukai, karena  memungkinkan Anda untuk menggunakan ruang nama, dan yang pertama, dengan desain, dirancang untuk mendaftarkan tipe-tipe Javascript bawaan dengan logika serialisasi yang didefinisikan ulang. </p><br><p>  Sebagai contoh kami, inisialisasi serializer adalah sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  Objek Skema berisi deskripsi dari semua kelas simpul, sehingga kode pendaftaran kelas cocok menjadi satu baris. </p><br><h4 id="kontekst-serializacii-i-deserializacii">  Konteks serialisasi dan deserialisasi </h4><br><p>  Anda mungkin telah memperhatikan kelas SerializationContext dan DeserializationContext cryptic.  Merekalah yang melakukan semua pekerjaan, dan dibutuhkan terutama untuk memisahkan data dari proses serialisasi / deserialisasi yang berbeda, karena  untuk setiap panggilan mereka perlu menyimpan informasi antara - cache objek berseri dan nomor seri untuk tautan. </p><br><h4 id="serializationcontext">  Konteks Serialisasi </h4><br><p>  Saya akan menganalisis secara rinci hanya serializer rekursif, karena  pasangan "datar" mereka agak lebih rumit, dan hanya berbeda dalam pendekatannya untuk memproses pohon objek. </p><br><p>  Mari kita mulai dengan konstruktor: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p>  Saya <code>this.__proto__.__proto__ = ser;</code> menjelaskan garis misterius <code>this.__proto__.__proto__ = ser;</code> <br>  Atas masukan konstruktor, kami menerima objek dari serializer itu sendiri, dan baris ini mewarisi kelas kami darinya.  Ini memungkinkan akses ke data serializer melalui <code>this</code> . <br>  Sebagai contoh, <code>this._ignore</code> merujuk ke daftar kelas yang diabaikan dari serializer itu sendiri ("daftar hitam"), yang sangat berguna.  Kalau tidak, kita harus menulis sesuatu seperti <code>this._serializer._ignore</code> . </p><br><p>  Metode serialisasi utama: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p>  Perlu dicatat bahwa ada tiga tipe dasar data yang kami proses: array, objek, dan nilai sederhana.  Jika konstruktor suatu objek ada di "daftar hitam", maka objek ini tidak bersambung. </p><br><p>  Serialisasi serialisasi: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Anda dapat menulis lebih pendek melalui peta, tetapi ini tidak penting.  Hanya satu hal yang penting - memeriksa nilai untuk undefined.  Jika ada kelas non-serializable dalam array, maka tanpa pemeriksaan ini akan jatuh ke dalam array sebagai tidak terdefinisi, yang tidak terlalu baik.  Juga dalam implementasi saya, array adalah serial tanpa kunci.  Secara teoritis, Anda dapat memperbaiki algoritma untuk serialisasi array asosiatif, tetapi untuk tujuan ini saya lebih suka menggunakan objek.  Selain itu, JSON.stringify juga tidak suka array asosiatif. </p><br><p>  Serialisasi objek: </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p>  Jelas, ini adalah bagian tersulit dari serializer, hatinya.  Mari kita pisahkan. </p><br><p>  Untuk mulai dengan, kami memeriksa apakah konstruktor kelas terdaftar di serializer.  Jika tidak, maka ini adalah objek sederhana yang disebut metode utilitas <code>serializeObjectInner</code> . </p><br><p>  Jika tidak, kami memeriksa apakah objek tersebut diberi pengenal unik <strong>__uuid</strong> .  Ini adalah variabel penghitung sederhana yang umum untuk semua serializer, dan digunakan untuk menyimpan referensi ke instance kelas dalam cache.  Anda bisa melakukannya tanpa itu, dan menyimpan instance itu sendiri tanpa kunci dalam cache, tetapi kemudian untuk memeriksa apakah objek disimpan dalam cache, Anda harus melalui seluruh cache, dan di sini cukup untuk memeriksa kunci.  Saya pikir ini lebih cepat dalam hal implementasi internal objek di browser.  Selain itu, saya sengaja tidak membuat serial bidang yang dimulai dengan dua garis bawah, sehingga bidang <strong>__uuid</strong> tidak <strong>akan</strong> jatuh ke json yang dihasilkan, seperti bidang kelas swasta lainnya.  Jika ini tidak dapat diterima untuk tugas Anda, Anda dapat mengubah logika ini. </p><br><p>  Selanjutnya, dengan nilai <strong>__uuid,</strong> kami mencari objek yang menggambarkan instance kelas dalam cache (di- <strong>cache</strong> ). </p><br><p>  Jika objek seperti itu ada, maka nilainya telah diserialisasi sebelumnya.  Dalam hal ini, kami menetapkan nomor seri ke objek, jika ini belum pernah dilakukan sebelumnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p>  Kode terlihat membingungkan, dan dapat disederhanakan dengan memberikan nomor ke semua kelas yang kita serialkan.  Tetapi untuk debugging dan merasakan hasilnya, lebih baik ketika nomor ditugaskan hanya untuk kelas-kelas yang ada tautan di masa depan. </p><br><p>  Ketika nomor diberikan, kami mengembalikan tautan sesuai dengan algoritma: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p>  Jika objek diserialisasi untuk pertama kalinya, kami membuat instance cache-nya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p>  Dan kemudian membuat cerita bersambung: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p>  Ada pemeriksaan untuk implementasi antarmuka serialisasi oleh kelas (yang akan dibahas nanti), serta pembangunan <code>Object.keys(cached.ref)[0]</code> .  Faktanya adalah bahwa cached.ref menyimpan tautan ke objek wrapper <code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> , tetapi nama bidang objek tidak diketahui oleh kami, karena  pada tahap ini, kita belum tahu apakah nama itu akan berisi nomor objek (indeks).  Konstruk ini hanya mengekstraksi bidang objek pertama dan satu-satunya. </p><br><p>  Akhirnya, metode utilitas serialisasi objek internal: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p>  Kami membuat objek baru dan menyalin bidang dari yang lama ke dalamnya. </p><br><h4 id="deserializationcontext">  Konteks Deserialisasi </h4><br><p>  Proses deserialisasi bekerja dalam urutan terbalik dan tidak memerlukan komentar khusus. </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti">  Fitur tambahan </h3><br><h4 id="interfeys-serializacii">  Antarmuka serialisasi </h4><br><p>  Tidak ada dukungan antarmuka dalam Javascript, tetapi kami dapat setuju bahwa jika kelas mengimplementasikan metode serialisasi dan deserialize, maka metode ini akan digunakan untuk serialisasi / deserialisasi, masing-masing. </p><br><p>  Selain itu, Javascript memungkinkan Anda menerapkan metode ini untuk tipe bawaan, misalnya, untuk Tanggal: </p><br><div class="spoiler">  <b class="spoiler_title">Serialisasi tanggal ke format ISO</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p>  Yang terpenting adalah ingat untuk mendaftarkan tipe Tanggal: <code>serializer.register(Date);</code>  . </p><br><p>  Hasil: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p>  Satu-satunya batasan: hasil serialisasi tidak boleh bilangan bulat, karena  dalam hal ini, itu akan ditafsirkan sebagai referensi ke objek. </p><br><p>  Demikian pula, Anda bisa membuat serialkan kelas-kelas sederhana menjadi string.  Contoh serialisasi kelas Warna, yang menggambarkan warna, ke baris <code>#rrggbb</code> ada di <a href="">github</a> . </p><br><h4 id="ploskiy-serializator">  Serializer datar </h4><br><p>  Khusus untuk Anda, pembaca yang budiman, saya menulis <a href="">versi kedua dari serializer</a> , yang melintasi pohon objek tidak secara mendalam secara rekursif, tetapi secara lebar lebarnya menggunakan antrian. </p><br><p>  Sebagai perbandingan, saya akan memberikan contoh serialisasi dari dua simpul pertama dari skema kami dalam kedua kasus. </p><br><div class="spoiler">  <b class="spoiler_title">Serializer rekursif (serialisasi mendalam)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Serializer datar (lebar serialisasi)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p>  Secara pribadi, saya suka opsi kedua bahkan lebih dari yang pertama, tetapi harus diingat bahwa memilih salah satu opsi, Anda tidak dapat menggunakan yang lain.  Ini semua tentang tautan.  Perhatikan bahwa dalam serializer datar, tautan ke simpul kedua berjalan sebelum deskripsinya. </p><br><h3 id="plyusy-i-minusy-serializatora">  Pro dan kontra dari serializer </h3><br><p>  Pro: </p><br><ul><li>  Kode serializer cukup sederhana dan ringkas (sekitar 300 baris, setengahnya adalah komentar). </li><li>  Serializer mudah digunakan dan tidak memerlukan perpustakaan pihak ketiga. </li><li>  Ada dukungan built-in untuk antarmuka serialisasi untuk serialisasi arbitrer kelas. </li><li>  Hasilnya menyenangkan mata (IMHO). </li><li>  Mengembangkan serializer / deserializer serupa dalam bahasa lain bukanlah masalah.  Ini mungkin diperlukan jika hasil serialisasi diproses di bagian belakang. </li></ul><br><p>  Cons: </p><br><ul><li>  Serializer memerlukan pendaftaran kelas yang dapat diserialisasi. </li><li>  Ada sedikit batasan pada nama bidang objek. </li><li>  Serializer ditulis noob dalam Javascript, sehingga mungkin mengandung bug dan kesalahan. </li><li>  Performa pada sejumlah besar data mungkin menderita. </li></ul><br><p>  Juga minus adalah bahwa kode ini ditulis dalam ES6.  Tentu saja, dimungkinkan untuk mengkonversi ke versi Javascript sebelumnya, tetapi saya tidak memeriksa kompatibilitas kode yang dihasilkan dengan browser yang berbeda. </p><br><h3 id="drugie-moi-publikacii">  Publikasi saya yang lain </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lokalisasi proyek di .NET dengan juru fungsi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengisi templat teks dengan data berbasis model.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi .NET menggunakan fungsi bytecode dinamis (IL)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413113/">https://habr.com/ru/post/id413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413103/index.html">3CX v15.5 Pembaruan 5 Beta dan integrasi REST dengan AmoCRM dirilis</a></li>
<li><a href="../id413105/index.html">Catatan dari penyedia IoT. Aktivasi dan keamanan di LoraWAN</a></li>
<li><a href="../id413107/index.html">Terjemahan dari wiki proyek Svelto.ECS. Kerangka kerja ECS untuk Unity3D</a></li>
<li><a href="../id413109/index.html">Cara Membangun Platform Integrasi Produk SaaS: Pengalaman Cloud Checkout Poster</a></li>
<li><a href="../id413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../id413117/index.html">Cara memprogram dengan aman di bash</a></li>
<li><a href="../id413119/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 317 (28 Mei - 3 Juni 2018)</a></li>
<li><a href="../id413121/index.html">Tur foto rekan kerja Moskow #tceh</a></li>
<li><a href="../id413123/index.html">BERGABUNG di Basis Data NoSQL</a></li>
<li><a href="../id413125/index.html">Terapi gen memberi pasien kecil dengan atrofi otot kesempatan untuk bertahan hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>