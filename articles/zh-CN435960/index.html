<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚕️ 🌈 🍪 思想实验：随心所欲 🛄 🎡 👓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我发现了Flutter （Google的一个用于开发跨平台移动应用程序的新框架），甚至有机会向从未编程的人展示Flutter的基础知识。 Flutter本身是用Dart编写的-Dart是Chrome浏览器中出生的一种语言，后来逃到了控制台世界-这使我想到了“嗯，但Flutter完全可以用Go语...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>思想实验：随心所欲</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435960/"><p> 最近，我发现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flutter</a> （Google的一个用于开发跨平台移动应用程序的新框架），甚至有机会向从未编程的人展示Flutter的基础知识。  Flutter本身是用Dart编写的-Dart是Chrome浏览器中出生的一种语言，后来逃到了控制台世界-这使我想到了“嗯，但Flutter完全可以用Go语言编写！”。 </p><br><p> 为什么不呢  Go和Dart都是由Google创建的，都使用了已编译的语言-围绕某些事件进行一些稍有不同的处理，Go将是实施Flutter这样的大规模项目的理想人选。 有人会说-Go中没有类，泛型和异常，因此不适合。 </p><br><p> 因此，让我们假设Flutter已经用Go编写了。 该代码的外观如何，并且通常会起作用？ </p><br><p><img src="https://habrastorage.org/webt/9r/4y/cv/9r4ycvikoillhjboi5olwnta4nm.png"></p><a name="habracut"></a><br>
<h1 id="chto-ne-tak-s-dart">  Dart有什么问题？ </h1><br><p> 自从这种语言在浏览器中替代JavaScript以来，我一直在关注它。  Dart已内置到Chrome浏览器中一段时间​​，希望它能取代JS。 疯狂的是伤心的2015年3月，以阅读， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持达特已经从Chrome删除</a> 。 </p><br><p> 飞镖本身很棒！ 好吧，基本上，在使用JavaScript之后，任何语言都很棒，但是在说Go之后，Dart并不是那么漂亮。 但是还可以。 它具有所有可能的和难以想象的功能-类，泛型，异常，期货，异步等待，事件循环，JIT / AOT，垃圾收集器，函数重载-从编程语言理论中命名任何已知功能，在Dart中它将占很大比例概率。  Dart几乎对所有芯片都有特殊的语法-用于getter / setter的特殊语法，用于缩写构造函数的特殊语法，用于特殊语法的特殊语法，等等。 </p><br><p> 乍一看，这使Dart成为了以前已经使用任何编程语言进行编程的人所熟悉的，这很棒。 但是，在一个简单的“ Hello，world”示例中尝试解释所有这些丰富的特殊功能时，我发现与此相反，这使得很难掌握。 </p><br><ul><li>  <strong>该语言的所有“特殊”功能都令人困惑</strong> -“称为构造函数的特殊方法”，“自动初始化的特殊语法”，“命名参数的特殊语法”等。 </li><li>  <strong>“隐藏”的所有内容都令人困惑</strong> -“此函数从什么导入？它是隐藏的，查看您无法找到的代码”，“为什么在此类中有构造函数，但在此类中没有？构造函数在那里，但它是隐藏的”等等 </li><li>  <strong>一切“模棱两可”的问题</strong>都令人<strong>困惑</strong> -“因此要在这里创建带有或不带有名称的函数参数吗？”，“应该是const还是final？”，“在此处使用函数的常规语法或用”缩短箭头“”等。 </li></ul><br><p> 原则上，这种三位一体-“特殊”，“隐藏”和“模棱两可”-可以抓住人们在编程语言中所谓的“魔术”的本质。 这些功能是为了简化代码编写而创建的，但实际上会使代码的阅读和理解复杂化。 </p><br><p> 而这恰恰是Go在其他语言上所处的根本不同立场，并且在激烈的防守中占据了重要位置。  Go是一种几乎没有魔法的语言-将其中的“隐藏”，“特殊”和“模棱两可”的数量减至最少。 但是Go有其缺点。 </p><br><h1 id="chto-ne-tak-s-go">  Go有什么问题？ </h1><br><p> 由于我们正在谈论Flutter，而这是一个UI框架，因此我们将Go视为描述和使用UI的工具。 通常，UI框架是一个巨大的挑战，几乎总是需要专门的解决方案。  UI中最常见的方法之一是创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DSL</a> （特定于域的语言），以特定于UI需求的库或框架的形式实现。 多数情况下，您会听到这样的观点：Go在客观上是DSL的一种糟糕语言。 </p><br><p> 从本质上讲，DSL意味着创建一种新的语言-术语和动词-开发人员可以对其进行操作。 它上的代码应清楚地描述图形界面及其组件的主要特征，应具有足够的灵活性以自由约束设计人员的想象力，同时应具有足够的刚性以按照某些规则对其进行限制。 例如，您应该能够将按钮放置在某个容器上，并将图标放在该按钮的正确位置，但是如果您尝试将按钮插入文本中，则编译器应该返回错误。 </p><br><p> 另外，用于描述UI的语言通常是声明性的-从而有机会以“我希望看到的东西”的形式描述接口，并让框架本身了解从哪些代码以及如何运行它。 </p><br><p> 某些语言最初是在具有此类任务的情况下开发的，但Go语言却没有。 在Go上编写Flutter似乎是另一项任务！ </p><br><h1 id="oda-flutter"> 小田扑 </h1><br><p> 如果您不熟悉Flutter，我强烈建议您在下个周末度过观看教育视频或阅读教程，其中有很多。 因为毫无疑问，Flutter在移动应用程序开发中颠覆了游戏规则。 而且，很可能不仅移动设备，而且已经有渲染器（就Flutter而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">嵌入</a>器）可以将Flutter应用程序作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本机dekstop应用程序</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web应用程序启动</a> 。 </p><br><p>它很容易学习，很合乎逻辑，它带有一个巨大的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Material Design设计</a>精美的小部件库（并且不仅如此），它具有强大的社区和出色的调优功能（如果您喜欢在Go中然后在Flutter中轻松进行<code>go build/run/test</code>的工作，您将获得类似的体验）。 </p><br><p> 一年前，我需要编写一个小型移动应用程序（当然适用于iOS和Android），并且我意识到为两个平台开发高质量应用程序的复杂性太高了（该应用程序不是主要任务）-我不得不外包并为此付费。 实际上，即使对于拥有将近20年编程经验的人来说，编写一个简单但高质量的应用程序并在所有设备上工作都是一项不可能的任务。 对我而言，这一直都是胡说八道。 </p><br><p> 使用Flutter，我在下午3点重新编写了该应用程序，同时从头开始学习框架本身。 如果有人告诉我这可能要早一点，我不会相信。 </p><br><p> 上次发现新技术时，我上次看到生产率的类似提升是在5年前，当时我发现了Go。 那一刻改变了我的生活。 </p><br><p> 因此，我建议开始学习Flutter， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本教程非常好</a> 。 </p><br><h1 id="hello-world-na-flutter">  Flutter上的“ Hello，World” </h1><br><p> 当您通过<code>flutter create</code>创建一个新的应用程序时，您将得到一个带有标题，文本，计数器和递增计数器的按钮的程序。 </p><br><p><img src="https://habrastorage.org/webt/_1/iu/9g/_1iu9gibgfkoiyadzl0kb8be_j4.gif"></p><br><p> 我认为这是一个很好的例子。 写在我们想象中的Flutter on Go上。 它几乎包含了您可以在其上测试该思想的框架的所有基本概念。 让我们看一下代码（这是一个文件）： </p><br><pre> <code class="plaintext hljs">import 'package:flutter/material.dart'; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } }</code> </pre> <br><p> 让我们分析各部分中的代码，分析它们在Go中的适合方式以及如何适合它们，并查看我们拥有的各种选项。 </p><br><h2 id="perevodim-kod-na-go"> 我们在Go上翻译代码 </h2><br><p> 开始会很简单明了-导入依赖项并启动<code>main()</code>函数。 这里没什么复杂或有趣的，变化几乎是语法上的： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() flutter.Run(app) }</code> </pre> <br><p> 唯一的区别是，我们无需启动<code>MyApp()</code> （该函数是一个构造函数，该函数是隐藏在名为MyApp的类中的特殊函数<code>MyApp()</code> ，而没有启动它，而是简单地调用了通常的显式函数而不是隐藏函数<code>NewApp()</code> 。 她做同样的事情，但是更清楚地解释和理解它的含义，起步方式和工作方式。 </p><br><h3 id="klassy-vidzhetov"> 小部件类 </h3><br><p> 在Flutter中，所有内容都由小部件组成。 在Flutter的Dart版本中，每个窗口小部件都实现为一个类，该类继承了Flutter中窗口小部件的特殊类。 </p><br><p>  Go中没有类，因此也没有类层次结构，因为世界不是面向对象的，甚至是更少的层次结构。 对于只熟悉面向类的OOP模型的程序员来说，这可能是一个启示，但实际上并非如此。 世界是概念，过程和相互作用的巨大交织图。 它的结构不是完美的，但也不是混乱的，尝试将其压缩到类层次结构中是使代码库不可读和笨拙的最可靠方法，而这正是目前大多数代码库所需要的。 </p><br><p><img src="https://habrastorage.org/webt/gd/9f/ad/gd9fadtyygideailxszfgw2cs_k.png"></p><br><p> 我非常感谢Go，因为它的创建者费心思虑了这个无处不在的类概念，并在Go中实现了一个更简单，功能更强大的OOP概念，事实并非偶然，它更接近于OOP的创建者Alan Kay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的想法</a> 。 </p><br><p> 在Go中，我们以特定类型的形式表示任何抽象-结构： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 在Flutter的Dart版本中， <code>MyApp</code>必须继承<code>StatelessWidget</code>并覆盖<code>build</code>方法。 这对于解决两个问题是必要的： </p><br><ol><li> 给我们的小部件（ <code>MyApp</code> ）一些特殊的属性/方法 </li><li> 使Flutter可以在构建/渲染过程中调用我们的代码 </li></ol><br><p> 我不知道Flutter的内部原理，所以可以说第1项没有问题，我们只需要这样做即可。  Go为此提供了一个独特而明显的解决方案： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">嵌入</a>类型： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 这段代码会将所有<code>flutter.Core</code>属性和方法添加到我们的<code>MyApp</code>类型中。 我称它为<code>Core</code>而不是<code>Widget</code> ，因为，首先，类型嵌入还没有使<code>MyApp</code>窗口小部件，其次，此名称在GopherJS Vecty框架中使用得很好（类似于React，仅用于Go）。 我将在稍后讨论Vecty和Flutter之间的相似性。 </p><br><p> 第二点-可以使用Flutter引擎的<code>build()</code>方法的实现-在Go中也可以轻松实现。 我们只需要添加一个具有特定签名的方法，即可满足我们在Go上虚构的Flutter库中某个地方定义的特定接口的需求： </p><br><p>  flutter.go： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Widget <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Build(ctx BuildContext) Widget }</code> </pre> <br><p> 现在我们的main.go： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.MaterialApp() }</span></span></code> </pre> <br><p> 我们可以在这里注意到一些区别： </p><br><ul><li> 代码更加冗长<code>BuildContext</code> ， <code>Widget</code>和<code>MaterialApp</code>指向它们前面的导入。 </li><li> 该代码没有那么少的依据-没有诸如<code>extends Widget</code>或<code>@override</code> </li><li>  <code>Build()</code>方法以大写字母开头，因为这意味着Go中该方法的“公开性”。 在Dart中，公开性取决于名称是否以下划线（_）开头。 </li></ul><br><p> 因此，要在我们的Flutter on Go中制作小部件，我们需要嵌入<code>flutter.Core</code>类型并实现<code>flutter.Widget</code>接口。 我们弄清楚了，进一步挖掘。 </p><br><h2 id="sostoyanie"> 条件 </h2><br><p> 这是在Flutter中真正让我困惑的事情之一。 有两种不同的类<code>StatelessWidget</code>和<code>StatefulWidget</code> 。 对我而言，“无状态窗口小部件”是相同的窗口小部件，只是没有数据，状态，状态-为什么要提出一个新类？ 但是，好的，我可以接受。 </p><br><p> 但是，此外-您不仅可以继承另一个类（ <code>StatefulWidget</code> ），还必须编写这样的魔术（IDE会为您做到这一点，但并非重点）： </p><br><pre> <code class="plaintext hljs">class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold() } }</code> </pre> <br><p> 嗯，让我们看看这里发生了什么。 </p><br><p> 从根本上讲，任务是这样的：向小部件添加状态-在我们的示例中为计数器-让Flutter引擎知道何时更改状态以重绘小部件。 这就是问题的真正复杂性（用Brooks术语来说是基本复杂性）。 </p><br><p> 其他一切都是偶然的复杂性。  Dart上的Flutter提出了一个新的<code>State</code>类，该类使用泛型并将小部件作为类型参数。 接下来，创建<code>_MyHomePageState</code>类，该类继承<code>State  MyApp</code> ...好的，您仍然可以以某种方式消化它。 但是为什么<code>build()</code>方法不是由State类定义的，而是由State类定义的？  Brrr .... </p><br><p>  Flutter FAQ中提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该问题的答案，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>对简短答案进行了足够详细的介绍-避免在继承<code>StatefulWidget</code>时出现某些类的错误。 换句话说，这是解决面向类的OOP设计问题的解决方法。 别致 </p><br><p> 我们将如何在Go中做到这一点？ </p><br><p> 首先，我个人不希望不为“国家”-State创建单独的实体。 毕竟，我们已经在每种特定类型中都有一个状态-这些只是结构的字段。 可以这么说，语言已经赋予了我们这种本质。 创建另一个类似的实体只会使程序员感到困惑。 </p><br><p> 当然，挑战在于使Flutter具有响应状态变化的能力（毕竟，这是反应式编程的本质）。 而且，如果我们可以“要求”开发人员使用特殊功能（ <code>setState()</code> ），则可以以相同的方式要求使用特殊功能，以告知引擎何时需要重绘，何时不使用。 最后，并非所有状态更改都需要重绘，这里我们将拥有更多控制权： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyHomePage <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core counter <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments widgets's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) // or m.Rerender() // or m.NeedsUpdate() }</span></span></code> </pre> <br><p> 您可以使用不同的命名选项-我喜欢<code>NeedsUpdate()</code>的直接性以及这是一个控件属性（从<code>flutter.Core</code>获得）的事实，但是全局<code>flutter.Rerender()</code>方法看起来也不错。 的确，给人一种错误的感觉，即小部件会立即立即重绘，但事实并非如此-它会在下一帧更新时重绘，并且方法调用频率可能比渲染频率高得多-但是我们的Flutter引擎应该已经处理了。 </p><br><p> 但想法是，我们无需添加即可解决必要的问题： </p><br><ul><li> 新类型 </li><li> 仿制药 </li><li> 读/写状态的特殊规则 </li><li> 特殊的新覆盖方法 </li></ul><br><p> 另外，API更清晰，更易理解-只需增加计数器（就像在其他任何程序中一样），然后要求Flutter重绘该小部件即可。 如果我们仅调用<code>setState</code> ，这只是不太明显的事情-它不仅是用于设置状态的特殊函数，它是返回函数（wtf？）的函数，其中我们已经在对state进行了处理。 同样，语言和框架中的隐藏魔术使得很难理解和阅读代码。 </p><br><p> 在我们的案例中，我们解决了相同的问题，代码更简单，而且缩短了两倍。 </p><br><h2 id="vidzhety-s-sostoyaniem-v-drugih-vidzhetah"> 状态小部件在其他小部件中 </h2><br><p> 作为该主题的逻辑继续，让我们看一下Flutter中另一个小部件中如何使用“状态小部件”： </p><br><pre> <code class="plaintext hljs">@override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: MyHomePage(title: 'Flutter Demo Home Page'), ); }</code> </pre> <br><p>  <code>MyHomePage</code>这里是一个“状态小部件”（它有一个计数器），我们在构建过程中通过调用构造函数<code>MyHomePage()</code>创建它。 </p><br><p> 调用<code>build()</code>来重绘窗口小部件，每秒可能多次。 为什么在渲染期间每次都要创建一个小部件，尤其是带有状态的小部件？ 没有道理 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事实证明</a> ，Flutter使用<code>Widget</code>和<code>State</code>之间的这种分隔来向程序员隐藏此初始化/状态管理（更多隐藏的东西，更多！）。 每次都会创建一个新的窗口小部件，但是状态（如果已经创建）会自动找到并附加到窗口小部件。 这种魔力是无形的，我不知道它是如何工作的-您需要阅读代码。 </p><br><p> 我认为在编程中尽可能多地向程序员隐藏和隐藏，以符合人体工程学的理由是一种真正的邪恶。 我敢肯定，一般的统计程序员不会阅读Flutter代码来了解这种魔术的工作原理，并且不太可能了解互连的方式和内容。 </p><br><p> 对于Go版本，我绝对不希望使用这种隐藏的巫术，并且宁愿使用显式且可见的初始化，即使这意味着稍微没有根据的代码也是如此。  Flutter使用Dart的方法也可以实现，但是我喜欢Go可以将魔术最小化，并且我希望在框架中看到相同的哲学。 因此，我将在小部件树中为状态编写小部件的代码，如下所示： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { flutter.Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return m.homePage } // MyHomePage is a home page widget. type MyHomePage struct { flutter.Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p> 这段代码丢失了Dart版本，因为如果我想从小部件树中删除<code>homePage</code>并将其替换为其他内容，则必须在三个位置而不是一个位置中将其删除。 但是作为回报，我们可以全面了解发生了什么，在哪里发生以及如何发生，在哪里分配了内存，谁叫了谁等等，这一切-您手中的代码清晰易读。 </p><br><p> 顺便说一句，Flutter还具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StatefulBuilder之类的功能</a> ，它增加了更多的魔力，并允许您动态创建状态的小部件。 </p><br><h1 id="dsl">  DSL </h1><br><p> 现在让我们开始有趣的部分。 我们将如何在Go上表示小部件树？ 我们希望它看起来简洁，干净，易于重构和更改，描述小部件之间的空间关系（视觉上邻近的小部件，并且必须位于描述中），同时又具有足够的灵活性来描述任意像事件处理程序这样的代码。 </p><br><p> 在我看来，Dart上的选项非常漂亮且雄辩： </p><br><pre> <code class="plaintext hljs">return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), );</code> </pre> <br><p> 每个小部件都有一个接受可选参数的构造函数，在这里使记录真正美好<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的是函数</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命名参数</a> 。 </p><br><h2 id="imenovannye-parametry"> 命名参数 </h2><br><p> 如果您不熟悉此术语，那么在许多语言中，函数的参数称为“位置”，因为它们的位置对函数很重要： </p><br><pre> <code class="plaintext hljs">Foo(arg1, arg2, arg3)</code> </pre> <br><p>  ，对于命名参数，一切都取决于调用中的名称： </p><br><pre> <code class="plaintext hljs">Foo(name: arg1, description: arg2, size: arg3)</code> </pre> <br><p> 这样可以添加文本，但是可以节省点击次数并在代码中移动，以了解参数的含义。 </p><br><p> 对于小部件树，它们在可读性方面起着关键作用。 比较与上面相同的代码，但没有命名参数： </p><br><pre> <code class="plaintext hljs">return Scaffold( AppBar( Text(widget.title), ), Center( Column( MainAxisAlignment.center, &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', Theme.of(context).textTheme.display1, ), ], ), ), FloatingActionButton( _incrementCounter, 'Increment', Icon(Icons.add), ), );</code> </pre> <br><p> 不是那样 对不对 这不仅更加难以理解（您需要牢记每个参数的含义及其类型，这是很大的认知负担），而且也没有给我们自由选择要传递的参数。 例如，您可能不需要Material应用程序的<code>FloatingActionButton</code> ，因此您只需在参数中不指定它即可。 如果没有命名参数，我们要么必须强制指定所有可能的窗口小部件，要么借助反射魔术来找出传输了哪些窗口小部件。 </p><br><p> 而且由于Go中没有函数和命名参数的重载，因此这对于Go而言并非易事。 </p><br><h1 id="derevo-vidzhetov-v-go"> 转到小部件树 </h1><br><h2 id="versiya-1"> 版本1 </h2><br><p> 让我们仔细研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Scaffold</a>对象，它是移动应用程序的便捷包装。 它具有几个属性-appBar，drawe，home，bottomNavigationBar，floatingActionBar-这些都是小部件。 创建窗口小部件树时，实际上我们必须以某种方式初始化此对象，并向其传递上述窗口小部件属性。 好吧，这与通常的对象创建和初始化没有太大区别。 </p><br><p> 让我们尝试一下额头方法： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flutter.NewScaffold( flutter.NewAppBar( flutter.Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, flutter.NewCenter( flutter.NewColumn( flutter.MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []flutter.Widget{ flutter.Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), flutter.Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), flutter.FloatingActionButton( flutter.NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p> 绝对不是最漂亮的UI代码。  <code>flutter</code>这个词无处不在，并要求。 要隐藏它（实际上，我必须给包装<code>material</code>命名，而不是<code>flutter</code> ，但不是本质），匿名参数是完全不明显的，并且这些<code>nil</code>在任何地方都令人困惑。 </p><br><h2 id="versiya-2"> 版本2 </h2><br><p> 但是，由于大多数代码将使用<code>flutter</code>包中的一个或另一个类型/函数，因此我们可以使用“点导入”格式将包导入到我们的命名空间中，从而“隐藏”包名称： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span></code> </pre> <br><p> 现在我们可以只写<code>Text</code>而不是<code>flutter.Text</code> 。 这通常是不好的做法，但是我们使用框架，并且此导入实际上会出现在每一行上。 根据我的实践，这种导入是可以接受的，例如使用出色的框架测试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoConvey时</a> 。 </p><br><p> 让我们看看代码的外观： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, NewCenter( NewColumn( MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p> 已经更好了，但是这些nil -s和未命名的参数.... </p><br><h2 id="versiya-3"> 版本3 </h2><br><p> 让我们看看如果我们使用反射（程序运行时检查代码的能力）来分析传递的参数，代码将是什么样。 这种方法已在Go上的多个早期HTTP框架中使用（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">martini</a> ），并且被认为是非常糟糕的做法-不安全，失去类型系统的便利性，相对较慢并在代码中添加了魔力-但为了进行实验，您可以尝试： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>), ), NewCenter( NewColumn( MainAxisCenterAlignment, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, ), )</code> </pre> <br><p> 还不错，看起来像Dart的原始版本，但是缺少命名参数仍然确实伤害了眼睛。 </p><br><h2 id="versiya-4"> 版本4 </h2><br><p> 让我们退后一步，问问自己我们要做什么。 我们不必盲目地模仿Dart的方法（尽管这将是一个不错的好处-教那些已经熟悉Flutter on Dart的人的知识很少）。 实际上，我们只是创建新对象并为其分配属性。 </p><br><p> 可以这样尝试吗？ </p><br><pre> <code class="go hljs">scaffold := NewScaffold() scaffold.AppBar = NewAppBar(Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>)) column := NewColumn() column.MainAxisAlignment = MainAxisCenterAlignment counterText := Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter)) counterText.Style = ctx.Theme.textTheme.display1 column.Children = []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), counterText, } center := NewCenter() center.Child = column scaffold.Home = center icon := NewIcon(icons.Add), fab := NewFloatingActionButton() fab.Icon = icon fab.Text = <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> fab.Handler = m.onPressed scaffold.FloatingActionButton = fab <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scaffold</code> </pre> <br><p>    ,         " ",         . -,       –   ,      . -,      ,            . </p><br><p> ,       UI   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GTK</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qt</a> . , ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>  Qt 5: </p><br><pre> <code class="plaintext hljs"> QGridLayout *layout = new QGridLayout(this); layout-&gt;addWidget(new QLabel(tr("Object name:")), 0, 0); layout-&gt;addWidget(m_objectName, 0, 1); layout-&gt;addWidget(new QLabel(tr("Location:")), 1, 0); m_location-&gt;setEditable(false); m_location-&gt;addItem(tr("Top")); m_location-&gt;addItem(tr("Left")); m_location-&gt;addItem(tr("Right")); m_location-&gt;addItem(tr("Bottom")); m_location-&gt;addItem(tr("Restore")); layout-&gt;addWidget(m_location, 1, 1); QDialogButtonBox *buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, this); connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;QDialog::reject); connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;QDialog::accept); layout-&gt;addWidget(buttonBox, 2, 0, 1, 2);</code> </pre><br><p>   ,   -      . ,  ,    ,           . </p><br><h2 id="versiya-5">  5 </h2><br><p>   ,     –          -. 例如： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text(TextParams{ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParams{ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p> ! ,   .    <code>...Params</code>    ,          .  , ,       Go    ,       ,     . </p><br><p> -,     <code>...Params</code> ,       .    (proposal)     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">"  "</a> .  ,     <code>FloatingActionButtonParameters{...}</code>  <code>{...}</code>    .     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold({ AppBar: NewAppBar({ Title: Text({ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter({ Child: NewColumn({ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text({ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text({ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton({ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon({ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p>        Dart!         . </p><br><h2 id="versiya-6">  6 </h2><br><p>   ,         .  ,    ,    ,       ,   . </p><br><p>   ,    ,   ,      -,     –     : </p><br><pre> <code class="go hljs">button := NewButton(). WithText(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). WithStyle(MyButtonStyle1)</code> </pre> <br><p> 或 </p><br><pre> <code class="go hljs">button := NewButton(). Text(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). Style(MyButtonStyle1)</code> </pre> <br><p>     Scaffold-    : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return NewScaffold(). AppBar(NewAppBar(). Text("Flutter Go app")). Child(NewCenter(). Child(NewColumn(). MainAxisAlignment(MainAxisCenterAlignment). Children([]Widget{ Text("You have pushed the button this many times:"), Text(fmt.Sprintf("%d", m.counter)). Style(ctx.Theme.textTheme.display1), }))). FloatingActionButton(NewFloatingActionButton(). Icon(NewIcon(icons.Add)). Text("Increment"). Handler(m.onPressed)) }</span></span></code> </pre> <br><p>        Go –       , .      Dart-,       : </p><br><ul><li>    </li><li>  "" </li><li>      </li><li>       </li></ul><br><p>          <code>New...()</code>   –  ,   .       ,    — <strong>"  ,      ,   ,      ,    ,     ,      –        "</strong> . </p><br><p>   ,   , 5-  6-    . </p><br><h1 id="finalnaya-versiya-koda">    </h1><br><p>         "hello, world"   Flutter  Go: </p><br><p> main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flutter.Run(NewMyApp()) }</code> </pre> <br><p> app.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx BuildContext) Widget { return m.homePage }</span></span></code> </pre> <br><p> home_page.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// MyHomePage is a home page widget. type MyHomePage struct { Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx BuildContext) Widget { return NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: "My Home Page", }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: "You have pushed the button this many times:", }), Text(TextParams{ Text: fmt.Sprintf("%d", m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParameters{ OnPressed: m.incrementCounter, Tooltip: "Increment", Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p>   ! </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><h4 id="pohozhest-s-vecty">   Vecty </h4><br><p>        ,      ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vecty</a> .  , ,  , ,  Vecty    DOM/CSS/JS,  Flutter            ,        120   .   ,   Vecty  ,     Flutter  Go  Vecty . </p><br><h4 id="luchshee-ponimanie-dizayna-flutter">    Flutter </h4><br><p>         –        ,   .            Flutter,         . </p><br><h4 id="nedostatki-go">  Go </h4><br><p>    <strong>"  Flutter    Go?"</strong>    <strong>""</strong> ,  , , ,        ,   Flutter, , ,     ""   .      ,    Go       . </p><br><p>  ,  <strong>   Go    </strong> .                 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>    Go, , ,    -.    –      ,         ,        . </p><br><p>           Go.              –       ,      . </p><br><h4 id="mysli-o-buduschem-flutter">    Flutter </h4><br><p>      ,  Flutter  ,     ,       .  "/ "   ,  Dart    ( , ,     ).    Dart,  ,      (,    )    DartVM  V8,  Flutter    –   Flutter      -. </p><br><p> ,     .          .  ,           ,  1.0     . , -      . </p><br><p>    game changer,     Flutter ,           ,           . </p><br><p>            UI –  Flutter,    . </p><br><h1 id="ssylki"> 参考文献 </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://flutter.io</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flutter Tutorial for Beginners — Build iOS and Android Apps</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go proposal: An Improved, Golang-Cohesive Design for Named Arguments</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go proposal: spec: untyped composite literals</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435960/">https://habr.com/ru/post/zh-CN435960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435950/index.html">大型强子对撞机的模块化数据中心</a></li>
<li><a href="../zh-CN435952/index.html">谁是“未洗的主人”？</a></li>
<li><a href="../zh-CN435954/index.html">使用人偶开发套件为人偶开发模块</a></li>
<li><a href="../zh-CN435956/index.html">PHP文摘147（2019年1月1日至14日）</a></li>
<li><a href="../zh-CN435958/index.html">上周第347期（2019年1月7日至13日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN435962/index.html">Aeron成立25周年：Aeron Remastered更新版本的感召和印象</a></li>
<li><a href="../zh-CN435964/index.html">以太坊计划经济性提高99％</a></li>
<li><a href="../zh-CN435968/index.html">机器人的深度机器学习算法概述</a></li>
<li><a href="../zh-CN435970/index.html">使用Node.js进行Web服务器开发的初学者指南</a></li>
<li><a href="../zh-CN435972/index.html">在Spring中引入反应式编程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>