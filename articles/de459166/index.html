<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 🗿 🙄 Was sind Sie, Schließungen in JavaScript? 💠 👶🏾 🔃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich versuchen, den Mechanismus zum Implementieren von Schließungen in JavaScript im Detail zu analysieren. Dafür werde ich den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was sind Sie, Schließungen in JavaScript?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459166/">  In diesem Artikel werde ich versuchen, den Mechanismus zum Implementieren von Schließungen in JavaScript im Detail zu analysieren.  Dafür werde ich den Chrome-Browser verwenden. <br><br>  Beginnen wir mit der Definition: <br><blockquote>  <b>Verschlüsse</b> sind Funktionen, die auf unabhängige (freie) Variablen verweisen.  Mit anderen Worten, die im Abschluss definierte Funktion "erinnert" sich an die Umgebung, in der sie erstellt wurde. </blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> <br><br>  Wenn Ihnen in dieser Definition etwas nicht klar ist, ist es nicht beängstigend.  Lesen Sie einfach weiter. <br><br>  Ich bin zutiefst davon überzeugt, dass das Verstehen von etwas anhand konkreter Beispiele einfacher und schneller ist. <br><br>  Daher schlage ich vor, ein Stück Code zu nehmen und mit dem Interpreter von Anfang bis Ende schrittweise zu gehen und zu sortieren, was gerade passiert. <br><br>  Also fangen wir an: <br><br><img src="https://habrastorage.org/webt/o_/pi/wo/o_piwoknty0bjixs4sv8ohsw9am.png"><br>  <i>Abbildung 1</i> <br><a name="habracut"></a><br>  Wir befinden uns im globalen Kontext des Aufrufs, es ist global (im Browser auch als Fenster bezeichnet) und wir sehen, dass die Hauptfunktion bereits im aktuellen Kontext liegt und bereit ist zu arbeiten. <br><br><img src="https://habrastorage.org/webt/-i/2i/vv/-i2ivvoyp8qo-f0hq0xf1oezoqu.png"><br>  <i>Abbildung 2</i> <br><br>  Dies geschieht, weil alle Funktionsdeklarationen (im Folgenden als FD bezeichnet) immer in einem beliebigen Kontext angezeigt werden, sofort initialisiert werden und betriebsbereit sind.  Dasselbe passiert mit Variablen, die über var deklariert wurden. Nur ihre Werte werden als undefiniert initialisiert. <br><br>  Es ist auch wichtig zu verstehen, dass JavaScript auch die über let und const deklarierten Variablen "auslöst".  Der einzige Unterschied besteht darin, dass sie nicht als var oder als FD initialisiert werden.  Wenn wir daher vor der Initialisierung versuchen, auf sie zuzugreifen, wird ein Referenzfehler angezeigt. <br><br>  Außerdem sehen wir in main eine intern versteckte Eigenschaft <b>[[Scopes]]</b> - dies ist eine Liste externer Kontexte, auf die main Zugriff hat.  In unserem Fall ist Global da, da main in einem globalen Kontext gestartet wird. <br><br>  Die Tatsache, dass in JavaScript die Initialisierung von Verweisen auf die externe Umgebung zum Zeitpunkt der Erstellung der Funktion und nicht zum Zeitpunkt der Ausführung erfolgt, legt nahe, dass JS eine Sprache mit einem statischen Bereich ist.  Und das ist wichtig. <br><br>  Gehen Sie voran: <br><br><img src="https://habrastorage.org/webt/_h/0w/qx/_h0wqxn3kdigr1j-mry8pvdt2fm.png"><br>  <i>Abbildung 3</i> <br><cut></cut><br>  Wir gehen auf die Hauptfunktion ein und das erste, was auffällt, ist das lokale Objekt (in der Spezifikation - localEnv).  Dort sehen wir <b>a</b> , da diese Variable über <b>var</b> deklariert ist und "aufgetaucht" ist, und traditionell sehen wir alle 3 FDs (foo, bar, baz).  Lassen Sie uns nun herausfinden, woher das alles kam. <br><br>  Wenn ein Kontext <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gestartet</a> wird, wird die abstrakte Operation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NewDeclarativeEnvironment gestartet</a> , mit der Sie <b>LexicalEnvironment</b> (im Folgenden LE) und <b>VariableEnvironment</b> initialisieren <b>können</b> .  Außerdem verwendet <b>NewDeclarativeEnvironment ein</b> Argument - die externe LE, um die <b>Bereiche</b> zu erstellen, über die wir oben gesprochen haben.  LE ist eine API, mit der wir die Beziehung zwischen Bezeichnern und einzelnen Variablen und Funktionen definieren können.  LE besteht aus 2 Komponenten: <br><br><ol><li>  <b>Datensatzumgebung</b> - Ein Umgebungsdatensatz, mit dem Sie die Beziehung zwischen Bezeichnern und dem, was uns im aktuellen Anrufkontext zur Verfügung steht, bestimmen können </li><li>  Link zu externem LE.  Jede Funktion verfügt beim <b>Erstellen</b> über eine interne Eigenschaft <b>[[Bereiche]].</b> </li></ol><br>  VariableEnvironment - meistens ist es dasselbe wie LE.  Der Unterschied zwischen beiden besteht darin, dass sich der Wert von VariableEnvironment nie ändert und sich LE während der Codeausführung ändern kann.  Um das weitere Verständnis zu vereinfachen, schlage ich vor, diese Komponenten zu einer LE zu kombinieren. <br><br>  Auch im aktuellen Local gibt es dies aufgrund der Tatsache, dass <b>ThisBinding aufgerufen wurde</b> - dies ist auch eine abstrakte Methode, die dies im aktuellen Kontext initialisiert. <br><br>  Natürlich erhielt jeder FD sofort [[Scopes]]: <br><br><img src="https://habrastorage.org/webt/nz/_t/ap/nz_tapg-wc5fulmh7wtsviyxus8.png"><br><a name="pic4"></a>  <i>Abbildung 4</i> <br><br>  Wir sehen, dass alle FDs in [[Scopes]] ein Array von [Closure main, Global] empfangen haben, was logisch ist. <br><cut></cut><br>  Auch in der Abbildung sehen wir <b>Call Stack</b> - dies ist eine Datenstruktur, die nach dem Prinzip von LIFO arbeitet - last in first out.  Da JavaScript Single-Threaded ist, kann jeweils nur ein Kontext ausgeführt werden.  In unserem Fall ist dies der Kontext der Hauptfunktion.  Jeder neue Funktionsaufruf erstellt einen neuen Kontext, der gestapelt wird. <br><br>  Am oberen Rand des Stapels befindet sich immer der aktuelle Ausführungskontext.  Nachdem die Funktion ihre Ausführung abgeschlossen und der Interpreter sie beendet hat, wird der Aufrufkontext vom Stapel entfernt.  Das ist alles, was wir in diesem Artikel über Call Stack wissen müssen :) <br><br>  Wir fassen zusammen, was im aktuellen Kontext passiert ist: <br><br><ul><li>  Zum Zeitpunkt der Erstellung erhielt main [[Scopes]] mit Links zur externen Umgebung </li><li>  Der Interpreter hat den Hauptteil der Hauptfunktion eingegeben </li><li>  Call Stack hat den Ausführungskontext main erhalten </li><li>  Dies wurde initialisiert </li><li>  LE initialisiert </li></ul><br>  In der Tat ist der schwierigste Teil vorbei.  Wir fahren mit dem nächsten Schritt im Code fort: <br><br>  Jetzt müssen wir baz anrufen, um das Ergebnis zu erhalten. <br><br><img src="https://habrastorage.org/webt/m4/0x/-i/m40x-if0h9mshfrsqxqv27wgbaw.png"><br><a name="pic5"></a>  <i>Abbildung 5</i> <br><br>  Ein neuer Baz-Aufrufkontext wurde zu Call Stack hinzugefügt.  Wir sehen, dass ein neues Closure-Objekt angezeigt wurde.  Hier erhalten wir, was uns von Scopes zur Verfügung steht.  Also kamen wir zum Punkt.  Dies ist die Schließung.  Wie Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abbildung 4 sehen, steht</a> Closure (main) in der Liste der 'Backup'-Kontexte in baz an erster Stelle.  Wieder keine Magie. <br><br>  Nennen wir foo: <br><br><img src="https://habrastorage.org/webt/ln/nd/yg/lnndygmqufofzebonalpko5ro3s.png"><br>  <i>Abbildung 6</i> <br><br>  Es ist wichtig zu wissen, dass es, egal wo wir foo nennen, immer den undefinierten Bezeichnern in seiner [[Scopes]] - Kette folgt.  Nämlich in main und dann in Global, wenn nicht in main gefunden. <br><br>  Nachdem sie foo ausgeführt hatte, gab sie den Wert zurück und ihr Kontext sprang aus Call Stack heraus. <br>  Wir gehen zum Aufruf der Balkenfunktion über.  Im Zusammenhang mit der Balkenausführung gibt es eine Variable mit demselben Namen wie die Variable in LE foo - <b>a</b> .  Wie Sie bereits vermutet haben, hat dies jedoch keine Auswirkungen.  foo übernimmt weiterhin den Wert aus seinen [[Scopes]]. <br><blockquote>  Der Ort des Anrufs wirkt sich nicht auf den Umfang aus, sondern nur auf den Ort der Erstellung </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Logachyova</a> <br><br><img src="https://habrastorage.org/webt/lx/oe/er/lxoeer85v0udg9ivlztvi6qr8yw.png"><br>  <i>Abbildung 7</i> <br><br>  Infolgedessen gibt baz 300 zurück und wird aus dem Call Stack geworfen.  Dann passiert dasselbe mit dem Hauptkontext, unser Codefragment wird fertig ausgeführt. <br><br>  Wir fassen zusammen: <br><br><ul><li>  Während der Funktionserstellung wird <b>[[Bereiche]] festgelegt</b> .  Dies ist sehr wichtig für das Verständnis von Abschlüssen, da der Interpreter diesen Links bei der Suche nach Werten sofort folgt </li><li>  Wenn diese Funktion aufgerufen wird, wird dann ein aktiver Ausführungskontext erstellt, der im Aufrufstapel abgelegt wird </li><li>  ThisBinding wird ausgeführt und für den aktuellen Kontext festgelegt </li><li>  Die LE wird initialisiert und alle Funktionsargumente, Variablen, die durch var und FD deklariert wurden, werden verfügbar.  Wenn Variablen über let oder const deklariert sind, werden sie auch zu LE hinzugefügt </li><li>  Wenn der Interpreter im aktuellen Kontext keine Kennung findet, werden <b>[[Bereiche]]</b> für die weitere Suche verwendet, die alle nacheinander sortiert werden.  Wenn der Wert gefunden wird, fällt der Link dazu in das spezielle Closure-Objekt.  Gleichzeitig wird für jeden Kontext, den der aktuelle schließt, ein separater <b>Abschluss</b> mit den erforderlichen Variablen erstellt </li><li>  Wenn der Wert in keinem Bereich, einschließlich Global, gefunden wird, wird ein ReferenceError zurückgegeben. </li></ul><br>  Das ist alles! <br><br>  Ich hoffe, dieser Artikel war hilfreich für Sie und jetzt verstehen Sie, wie der Sperrmechanismus in JavaScript funktioniert. <br><br>  Tschüss :) Und bis bald.  Gefällt mir und abonniere meinen Kanal :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459166/">https://habr.com/ru/post/de459166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459154/index.html">Netzwerk für kleine Unternehmen mit Cisco-Geräten. Teil 1</a></li>
<li><a href="../de459156/index.html">VNIITE des Planeten des Ganzen: Wie sie in der UdSSR auf das „Smart Home“ -System gekommen sind</a></li>
<li><a href="../de459158/index.html">Wie Artefakt zum größten Fehler von Valve wird</a></li>
<li><a href="../de459160/index.html">Wie wählen Sie Produkte in Geschäften aus?</a></li>
<li><a href="../de459162/index.html">"Um die Meisterschaft zu gewinnen, muss das Team im Einklang atmen." Interview mit Moskauer Workshops ICPC Trainer</a></li>
<li><a href="../de459168/index.html">Billig und fröhlich mit Windows Defender umgehen: Meterpreter-Sitzung über Python</a></li>
<li><a href="../de459172/index.html">Top 13 Scala-Bibliotheken für die Datenanalyse</a></li>
<li><a href="../de459174/index.html">Rx-Ereignisquellenreferenz</a></li>
<li><a href="../de459176/index.html">Stabile Hochspannungsversorgung für PMT</a></li>
<li><a href="../de459180/index.html">TheOutloud - Sprechen Sie und teilen Sie Ihre Lieblingsartikel und -geschichten. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>