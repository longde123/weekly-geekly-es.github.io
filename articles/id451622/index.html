<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ƒ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ” Tentang penghitungan bit, tipe yang tidak ditandatangani di Kotlin dan tentang situasi di mana penghematan pada pertandingan dibenarkan ğŸ‘¨ğŸ»â€ğŸ³ ğŸ‘¶ğŸ» ğŸ‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komentar ini didorong oleh penulisan artikel. Lebih tepatnya, satu frasa darinya. 
 ... menghabiskan memori atau siklus prosesor pada item dalam milia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang penghitungan bit, tipe yang tidak ditandatangani di Kotlin dan tentang situasi di mana penghematan pada pertandingan dibenarkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/451622/"><img src="https://habrastorage.org/webt/b6/qc/5k/b6qc5klplot_lkmjsi0edrecbye.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komentar ini</a> didorong oleh penulisan artikel.  Lebih tepatnya, satu frasa darinya. <br><blockquote>  ... menghabiskan memori atau siklus prosesor pada item dalam miliaran dolar tidak baik ... <br></blockquote>  Kebetulan baru-baru ini saya harus melakukan hal itu.  Dan, meskipun, kasus yang akan saya pertimbangkan dalam artikel ini agak istimewa - kesimpulan dan solusi yang diterapkan dapat bermanfaat bagi seseorang. <br><br><h1>  Sedikit konteks </h1><br>  Aplikasi iFunny menangani sejumlah besar konten grafis dan video, dan pencarian fuzzy untuk duplikat adalah salah satu tugas yang sangat penting.  Ini sendiri merupakan topik besar yang pantas mendapatkan artikel terpisah, tetapi hari ini saya hanya akan berbicara sedikit tentang beberapa pendekatan untuk menghitung jumlah array yang sangat besar dalam kaitannya dengan pencarian ini.  Tentu saja, setiap orang memiliki pemahaman yang berbeda tentang "array yang sangat besar", dan itu akan bodoh untuk bersaing dengan Hadron Collider, tetapi tetap saja.  :) <br><br>  Jika algoritma ini sangat singkat, maka untuk setiap gambar tanda tangan digitalnya (tanda tangan) dibuat dari 968 bilangan bulat, dan perbandingannya dibuat dengan menemukan "jarak" antara dua tanda tangan.  Menimbang bahwa volume konten dalam dua bulan terakhir saja berjumlah sekitar 10 juta gambar, maka pembaca yang penuh perhatian akan dengan mudah mengetahuinya dalam benaknya - ini adalah persis "elemen dalam miliaran volume."  Siapa yang peduli - selamat datang di kucing. <br><a name="habracut"></a><br>  Pada awalnya akan ada cerita yang membosankan tentang menghemat waktu dan memori, dan pada akhirnya akan ada cerita instruktif singkat tentang fakta bahwa kadang-kadang sangat berguna untuk melihat sumbernya.  Sebuah gambar untuk menarik perhatian secara langsung berkaitan dengan kisah instruktif ini. <br><br>  Saya harus mengakui bahwa saya sedikit licik.  Dalam analisis awal dari algoritma, dimungkinkan untuk mengurangi jumlah nilai di setiap tanda tangan dari 968 menjadi 420. Ini sudah dua kali lebih baik, tetapi urutan besarnya tetap sama. <br><br>  Meskipun, jika Anda memikirkannya, saya tidak terlalu menipu, dan ini akan menjadi kesimpulan pertama: sebelum memulai tugas, ada baiknya berpikir - apakah mungkin untuk menyederhanakannya terlebih dahulu? <br><br>  Algoritma perbandingannya cukup sederhana: akar dari jumlah kuadrat dari perbedaan dari dua tanda tangan dihitung, dibagi dengan jumlah nilai yang dihitung sebelumnya (mis., Dalam setiap iterasi penjumlahan akan tetap dan tidak dapat dianggap sebagai konstanta sama sekali) dan dibandingkan dengan nilai ambang.  Perlu dicatat bahwa elemen tanda tangan terbatas pada nilai dari -2 hingga +2, dan, karenanya, nilai absolut dari selisih terbatas pada nilai dari 0 hingga 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br>  Tidak ada yang rumit, tetapi kuantitas memutuskan. <br><br><h1>  Pendekatan pertama, naif </h1><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  const val d = 0.3 // 10.000.000 . //      , //        val collection: MutableList&lt;Signature&gt; = mutableListOf() // signature â€”   420   Byte class Signature(val signature: Array&lt;Byte&gt;, val norma: Double) fun getSimilar(signature: Signature) = collection .filter { calculateDistance(it, signature) &lt; d } fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; Math.pow((value - second.signature[index]).toDouble(), 2.0) }.sum()) / (first.norma + second.norma)</span></span></code> </pre> <br>  Mari kita hitung apa yang kita miliki di sini dengan jumlah operasi: <br><br>  <code>10M</code> Square Roots <code>Math.sqrt</code> <br>  <code>10M</code> penambahan dan pembagian <code>/ (first.norma + second.norma)</code> <br>  <code>4.200M</code> pengurangan dan mengkuadratkan <code>Math.pow((value - second.signature[index]).toDouble(), 2.0)</code> <br>  <code>4.200M</code> penambahan <code>.sum()</code> <br><br>  Opsi apa yang kami miliki: <br><br><ol><li>  Dengan volume seperti itu, menghabiskan seluruh <code>Byte</code> (atau, Tuhan melarang, seseorang akan menduga untuk menggunakan <code>Int</code> ) untuk menyimpan tiga bit signifikan adalah pemborosan yang tidak termaafkan. </li><li>  Mungkin, bagaimana cara mengurangi jumlah matematika? </li><li>  Tetapi apakah mungkin untuk melakukan penyaringan awal, yang tidak begitu mahal secara komputasi? </li></ol><br><h1>  Pendekatan kedua, kami kemas </h1><br>  <i>Ngomong-ngomong, jika seseorang menyarankan bagaimana Anda dapat menyederhanakan perhitungan dengan kemasan seperti itu, Anda akan menerima banyak terima kasih dan plus dalam karma.</i>  <i>Meski satu, tapi dengan sepenuh hati :)</i> <br><br>  One <code>Long</code> adalah 64 bit, yang, dalam kasus kami, akan memungkinkan kami untuk menyimpan 21 nilai di dalamnya (dan 1 bit akan tetap tidak tenang). <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   20   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; calculatePartial(value, second.signature[index]) }.sum()) / (first.norma + second.norma) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L (0..60 step 3).onEach { val current = (first.ushr(it) and 0x7) - (second.ushr(it) and 0x7) sum += current * current } return sum.toDouble() }</span></span></code> </pre><br>  Lebih baik dari memori ( <code>4.200M</code> versus <code>1.600M</code> byte, jika kira-kira), tetapi bagaimana dengan perhitungannya? <br><br>  Saya pikir sudah jelas bahwa jumlah operasi tetap sama dan <code>8.400M</code> bergeser dan <code>8.400M</code> logis telah ditambahkan ke mereka. Mungkin itu dapat dioptimalkan, tetapi trennya masih tidak bahagia - ini bukan yang kita inginkan. <br><br><h1>  Pendekatan ketiga, kemas ulang dengan sub-subs </h1><br>  Di pagi hari aku bisa mencium baunya, di sini kamu bisa menggunakan bit magic! <br><br>  Mari kita simpan nilai bukan dalam tiga, tetapi dalam empat bit.  Dengan cara ini: <br><div class="scrollable-table"><table><tbody><tr><td>  -2 </td><td>  0b1100 </td></tr><tr><td>  -1 </td><td>  0b0100 </td></tr><tr><td>  0 </td><td>  0b0000 </td></tr><tr><td>  1 </td><td>  0b0010 </td></tr><tr><td>  2 </td><td>  0b0011 </td></tr></tbody></table></div><br>  Ya, kami akan kehilangan kepadatan kemasan dibandingkan dengan versi sebelumnya, tetapi kami akan mendapatkan kesempatan untuk menerima <code>Long</code> dengan 16 (tidak cukup) perbedaan dengan satu ohm satu <code>XOR</code> sekaligus.  Selain itu, hanya akan ada 11 opsi untuk distribusi bit di setiap nibble akhir, yang akan memungkinkan Anda untuk menggunakan nilai pra-perhitungan dari kotak perbedaan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   27   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) // -1    val precomputed = arrayOf(0, 1, 1, 4, 1, -1, 4, 9, 1, -1, -1, -1, 4, -1, 9, 16) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L val difference = first xor second (0..60 step 4).onEach { sum += precomputed[(difference.ushr(it) and 0xF).toInt()] } return sum.toDouble() }</span></span></code> </pre><br>  Dari memori menjadi <code>2.160M</code> dibandingkan <code>1.600M</code> - tidak menyenangkan, tetapi masih lebih baik dari <code>4.200M</code> awal. <br><br>  Mari kita hitung operasi: <br><br>  Akar, penambahan, dan divisi <code>10M</code> kuadrat (tidak kemana-mana) <br>  <code>270M</code> <code>XOR</code> <br>  <code>4.320</code> penambahan, pergeseran, <code>4.320</code> logis, dan ekstrak dari array. <br><br>  Itu sudah terlihat lebih menarik, tetapi, bagaimanapun, ada terlalu banyak perhitungan.  Sayangnya, tampaknya kami telah menghabiskan 20% dari upaya memberikan 80% dari hasilnya dan sekarang saatnya untuk memikirkan di mana lagi Anda bisa mendapat untung.  Hal pertama yang terlintas dalam pikiran adalah tidak membawanya ke perhitungan sama sekali, menyaring tanda tangan jelas tidak pantas dengan beberapa filter ringan. <br><br><h1>  Pendekatan keempat, ayakan besar </h1><br>  Jika Anda sedikit mengubah rumus perhitungan, Anda bisa mendapatkan ketimpangan ini (semakin kecil jarak yang dihitung, semakin baik): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/ny/mv/nunymvgccfhu2hlexvir0d0dlvq.png"></div><br>  Yaitu  sekarang kita perlu mencari cara bagaimana menghitung nilai minimum yang mungkin dari sisi kiri ketidaksetaraan berdasarkan informasi yang kita miliki pada jumlah bit yang ditentukan dalam <code>Long</code> 's.  Maka cukup buang semua tanda tangan yang tidak memuaskannya. <br>  Biarkan saya mengingatkan Anda bahwa x <sub>saya</sub> dapat mengambil nilai dari 0 hingga 4 (tandanya tidak penting, saya pikir itu jelas mengapa).  Mengingat bahwa setiap istilah dikuadratkan, mudah untuk mendapatkan pola umum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/pk/um/empkumsytnx11yoplffogdf4dbc.png"></div><br>  Formula terakhirnya terlihat seperti ini (kami tidak akan membutuhkannya, tapi saya menyimpulkannya untuk waktu yang lama dan akan memalukan untuk melupakan dan tidak menunjukkan kepada siapa pun): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/md/xd/ramdxdoczcczinkn8bouj_40zls.png"></div><br>  Di mana B adalah jumlah bit yang ditetapkan. <br><br>  Bahkan, dalam satu <code>Long</code> hanya 64 bit, baca 64 hasil yang mungkin.  Dan mereka dengan sempurna dihitung sebelumnya dan ditambahkan ke array, dengan analogi dengan bagian sebelumnya. <br><br>  Selain itu, itu sepenuhnya opsional untuk menghitung semua 27 Panjang - itu sudah cukup untuk melampaui ambang batas pada yang berikutnya dan Anda dapat mengganggu cek dan mengembalikan false.  Pendekatan yang sama, omong-omong, dapat digunakan dalam perhitungan utama. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .asSequence() <span class="hljs-comment"><span class="hljs-comment">//     !? .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d } val estimateValues = arrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 69, 74, 79, 84, 89, 94, 99, 104, 109, 114, 119, 124, 129, 134, 139, 144, 151, 158, 165, 172, 179, 186, 193, 200, 207, 214, 221, 228, 235, 242, 249, 256) fun estimate(first: Signature, second: Signature):Boolean{ var bitThreshold = Math.pow(d * (first.norma + second.norma), 2.0).toLong() first.signature.forEachIndexed { index, value -&gt; bitThreshold -= estimateValues[java.lang.Long.bitCount(value xor second.signature[index])] if (bitThreshold &lt;= 0) return false } return true }</span></span></code> </pre><br>  Di sini harus dipahami bahwa efektivitas filter ini (hingga negatif) sangat tergantung pada ambang yang dipilih dan, sedikit kurang kuat, pada data input.  Untungnya, untuk ambang yang diperlukan <code>d=0.3</code> sejumlah kecil objek berhasil melewati filter dan kontribusi perhitungannya terhadap total waktu respons sangat sedikit sehingga mereka dapat diabaikan.  Dan jika demikian, maka Anda dapat menghemat sedikit lebih banyak. <br><br><h1>  Pendekatan kelima, menyingkirkan urutan </h1><br>  Ketika bekerja dengan koleksi besar, <code>sequence</code> adalah pertahanan yang baik terhadap <b>kehabisan memori yang</b> sangat tidak menyenangkan.  Namun, jika kita jelas tahu bahwa pada filter pertama koleksi akan dikurangi menjadi ukuran yang waras, maka pilihan yang jauh lebih masuk akal adalah menggunakan iterasi biasa dalam satu lingkaran dengan penciptaan koleksi perantara, karena <code>sequence</code> tidak hanya modis dan awet muda, tetapi juga sebuah iterator, yang memiliki sahabat berikutnya yang jauh dari bebas. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d }</code> </pre><br>  Tampaknya ini adalah kebahagiaan, tetapi saya ingin "menjadikannya indah."  Di sini kita sampai pada kisah instruktif yang dijanjikan. <br><br><h1>  Pendekatan keenam, kami menginginkan yang terbaik </h1><br>  Kami menulis di Kotlin, dan di sini beberapa <code>java.lang.Long.bitCount</code> asing!  Dan baru-baru ini, tipe yang tidak ditandatangani dimasukkan ke dalam bahasa.  Serang! <br><br>  Tidak lebih cepat dikatakan daripada dilakukan.  Semua <code>ULong</code> digantikan oleh <code>ULong</code> , <code>ULong</code> dari sumber Java dan ditulis ulang sebagai fungsi ekstensi untuk <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ULong.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> i = i - (i.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>uL) i = (i and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) + (i.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>) and <span class="hljs-number"><span class="hljs-number">0x0f0f0f0f0f0f0f0f</span></span>uL i = i + i.shr(<span class="hljs-number"><span class="hljs-number">8</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">16</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.toInt() and <span class="hljs-number"><span class="hljs-number">0x7f</span></span> }</code> </pre><br>  Kita mulai dan ... Ada yang salah.  Kode mulai bekerja lebih lambat.  Kami memulai profiler dan melihat sesuatu yang aneh (lihat <code>bitCount()</code> artikel): sedikit kurang dari satu juta panggilan ke <code>bitCount()</code> hampir 16 juta panggilan ke <code>Kotlin.ULong.constructor-impl</code> .  WAT!? <br><br>  Teka-teki itu dijelaskan secara sederhana - lihat saja kode kelas <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ULong</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@PublishedApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@PublishedApi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) : Comparable&lt;ULong&gt; { <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.plus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.minus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bitCount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> shl bitCount) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.inc())  .. }</code> </pre><br>  Tidak, saya mengerti segalanya, <code>ULong</code> masih <code>experimental</code> sekarang, tapi bagaimana itu !? <br>  Secara umum, kami mengakui pendekatan itu gagal, yang sangat disayangkan. <br><br>  Yah, tapi tetap saja, mungkin sesuatu yang lain bisa diperbaiki? <br><br>  Sebenarnya kamu bisa.  Kode <code>java.lang.Long.bitCount</code> asli bukan yang paling optimal.  Ini memberikan hasil yang baik dalam kasus umum, tetapi jika kita tahu sebelumnya tentang prosesor mana aplikasi kita akan bekerja, maka kita dapat memilih cara yang lebih optimal - di sini adalah artikel yang sangat baik tentang hal itu di HabrÃ©. Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat</a> merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghitung bit tunggal</a> , saya sangat merekomendasikan membacanya. <br><br>  Saya menggunakan "Metode Gabungan" <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Long</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> n -= (n.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555L</span></span> n = ((n.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) + (n and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) n = ((((n.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>)) + n) and <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0FL</span></span>) * <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>).shr(<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.toInt() and <span class="hljs-number"><span class="hljs-number">0x7F</span></span> }</code> </pre><br><h1>  Menghitung burung beo </h1><br>  Semua pengukuran dilakukan secara acak, selama pengembangan pada mesin lokal dan direproduksi dari memori, sehingga sulit untuk berbicara tentang akurasi, tetapi Anda dapat memperkirakan perkiraan kontribusi masing-masing pendekatan. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Apa yang terjadi? </th><th>  kakatua (detik) </th></tr><tr><td>  Pendekatan pertama, naif </td><td>  25 Â± </td></tr><tr><td>  Pendekatan kedua, kami kemas </td><td>  - </td></tr><tr><td>  Pendekatan ketiga, kemas ulang dengan sub-subs </td><td>  11-14 </td></tr><tr><td>  Pendekatan keempat, ayakan besar </td><td>  2-3 </td></tr><tr><td>  Pendekatan kelima, menyingkirkan urutan </td><td>  1.8-2.2 </td></tr><tr><td>  Pendekatan keenam, kami menginginkan yang terbaik </td><td>  3-4 </td></tr><tr><td>  "Metode gabungan" untuk menghitung bit yang ditetapkan </td><td>  1.5-1.7 </td></tr></tbody></table></div><br><h1>  Kesimpulan </h1><br><ul><li>  Ketika berhadapan dengan pemrosesan data dalam jumlah besar, perlu menghabiskan waktu untuk analisis pendahuluan.  Mungkin tidak semua data ini perlu diproses. </li><li>  Jika Anda dapat menggunakan pra-penyaringan yang kasar, tetapi murah, ini dapat banyak membantu. </li><li>  Sihir bit adalah segalanya bagi kami.  Nah, jika ada, tentu saja. </li><li>  Untuk melihat kode sumber dari kelas dan fungsi standar terkadang sangat berguna. </li></ul><br>  Terima kasih atas perhatian anda!  :) <br><br>  Dan ya, untuk dilanjutkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451622/">https://habr.com/ru/post/id451622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451606/index.html">Sejarah Internet: Peluruhan, Bagian 2</a></li>
<li><a href="../id451610/index.html">Security Week 20: menonaktifkan ekstensi Firefox</a></li>
<li><a href="../id451614/index.html">"Apa yang kita diskusikan di Rusia juga relevan di Barat": wawancara dengan Denis Neklyudov</a></li>
<li><a href="../id451618/index.html">CampusInsight: Dari Pemantauan Infrastruktur hingga Analisis Pengalaman Pengguna</a></li>
<li><a href="../id451620/index.html">Otorisasi otomatis pada kartu Strava Heatmap</a></li>
<li><a href="../id451624/index.html">Tentang bagaimana Harry Potter membentuk pendidikan Rusia, tentu saja, bukan di tempat Anda membutuhkannya</a></li>
<li><a href="../id451626/index.html">Belajar tanpa guru: murid yang penasaran</a></li>
<li><a href="../id451628/index.html">Ulasan 3D Expo teratas pada bulan April 2019</a></li>
<li><a href="../id451630/index.html">Pemantauan Berkelanjutan - otomatisasi pemeriksaan kualitas perangkat lunak dalam CI / CD Pipeline</a></li>
<li><a href="../id451634/index.html">Bagaimana kami dianalisis di toko-toko dan restoran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>