<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üç∂ üç¥ Knative - eine k8s-basierte Plattform als Service mit serverloser Unterst√ºtzung ‚ôâÔ∏è üöà üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes hat sich zweifellos zur dominierenden Plattform f√ºr die Bereitstellung von Containern entwickelt. Es bietet die M√∂glichkeit, fast alles mit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Knative - eine k8s-basierte Plattform als Service mit serverloser Unterst√ºtzung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/475630/"><p><img src="https://habrastorage.org/webt/4k/yp/89/4kyp89-_aofexlkgyzwoiiekmbq.png"></p><br><p>  Kubernetes hat sich zweifellos zur dominierenden Plattform f√ºr die Bereitstellung von Containern entwickelt.  Es bietet die M√∂glichkeit, fast alles mit seinen APIs und Benutzercontrollern zu verwalten, die seine API durch Benutzerressourcen erweitern. </p><br><p>  Der Benutzer muss jedoch noch detaillierte Entscheidungen √ºber die Bereitstellung, Konfiguration, Verwaltung und Skalierung von Anwendungen treffen.  Es liegt im Ermessen des Benutzers, Fragen zur Skalierung der Anwendung, zum Schutz und zum Verkehrsweg zu stellen.  Dies unterscheidet Kubernetes von herk√∂mmlichen ‚ÄûPlatform as a Service‚Äú (PaaS) wie Cloud Foundry und Heroku. </p><br><p>  Plattformen haben eine vereinfachte Benutzeroberfl√§che, die sich an Anwendungsentwickler richtet, die am h√§ufigsten an der Anpassung einzelner Anwendungen beteiligt sind.  Routing, Bereitstellung und Metriken, die f√ºr den Benutzer transparent sind, werden vom zugrunde liegenden PaaS-System verwaltet. </p><a name="habracut"></a><br><p> Der Workflow f√ºr die Quellzustellung wird von PaaS abgewickelt, indem ein benutzerdefiniertes Container-Image erstellt, bereitgestellt, eine neue Route und eine DNS-Unterdom√§ne f√ºr eingehenden Datenverkehr eingerichtet wird.  All dies wird durch den Befehl <code>git push</code> ausgel√∂st. </p><br><p>  Kubernetes stellt (absichtlich) nur die Grundbausteine ‚Äã‚Äãf√ºr solche Plattformen zur Verf√ºgung und gibt der Community die M√∂glichkeit, diese Arbeit alleine zu erledigen.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kelsey Hightower sagte</a> : </p><br><blockquote>  Kubernetes ist eine Plattform zum Bauen von Plattformen.  Die beste Position, um zu starten, aber nicht zu beenden. </blockquote><p>  Infolgedessen sehen wir eine Reihe von Kubernetes-Assemblys sowie Hosting-Unternehmen, die versuchen, PaaS f√ºr Kubernetes zu erstellen, z. B. OpenShift und Rancher.  Inmitten des wachsenden Kube-PaaS-Marktes betritt Knative, der im Juli 2018 von Google und Pivotal gegr√ºndet wurde, den Ring. </p><br><p>  Knative war eine Zusammenarbeit zwischen Google und Pivotal, wobei andere Unternehmen wie IBM, RedHat und Solo.im kaum zusammengearbeitet haben.  Es bietet √§hnliche PaaS-Produkte f√ºr Kubernetes mit erstklassiger Unterst√ºtzung f√ºr serverlose Computeranwendungen.  Im Gegensatz zu Kubernetes-Assemblys wird Knative als Add-On zu jedem kompatiblen Kubernetes-Cluster installiert und √ºber Benutzerressourcen konfiguriert. </p><br><h2 id="chto-takoe-knative">  Was ist Knative? </h2><br><p>  Knative wird als "Kubernetes-basierte Plattform zur Bereitstellung und Verwaltung von Workloads mit modernem Serverless Computing" beschrieben.  Knative erkl√§rt sich selbst zu einer solchen Plattform und skaliert Container automatisch proportional zu gleichzeitigen HTTP-Anforderungen.  Nicht genutzte Dienste werden letztendlich auf null skaliert und bieten eine On-Demand-Skalierung im Stil von Serverless Computing. </p><br><p>  Knative besteht aus einer Reihe von Controllern, die in einem beliebigen Kubernetes-Cluster installiert sind und die folgenden Funktionen bieten: </p><br><ul><li>  Zusammenstellung von containerisierten Anwendungen aus dem Quellcode (bereitgestellt von der <em>Build-</em> Komponente), </li><li>  Bereitstellung des Zugriffs auf eingehenden Datenverkehr f√ºr Anwendungen (bereitgestellt von der <em>Serving-</em> Komponente), </li><li>  Bereitstellung und automatische Skalierung von Anwendungen nach Bedarf (auch von der <em>Serving-</em> Komponente bereitgestellt), </li><li>  Ermittlung der Ereignisquellen, die zum Starten von Anwendungen f√ºhren (bereitgestellt von der <em>Eventing-</em> Komponente). </li></ul><br><p>  Eine Schl√ºsselkomponente ist Serving, das die Bereitstellung, automatische Skalierung und Datenverkehrssteuerung f√ºr verwaltete Anwendungen bietet.  Nach der Installation von Knative bleibt der uneingeschr√§nkte Zugriff auf die Kubernetes-API erhalten, sodass Benutzer Anwendungen auf die <em>√ºbliche</em> Weise verwalten und Knative-Dienste debuggen k√∂nnen, indem sie mit denselben API-Grundelementen arbeiten, die diese Dienste verwenden (Module, Dienste usw.). </p><br><p>  Durch das Serving wird auch das blau-gr√ºne Routing des Datenverkehrs automatisiert und die Trennung des Datenverkehrs zwischen neuen und alten Versionen der Anwendung sichergestellt, wenn der Benutzer eine aktualisierte Version der Anwendung bereitstellt. </p><br><p>  Knative selbst h√§ngt von der Installation eines kompatiblen Ingress-Controllers ab.  Zum Zeitpunkt des Schreibens werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gloo API Gateway</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Istio Service Mesh</a> unterst√ºtzt.  Er wird den verf√ºgbaren Eingang konfigurieren, um Datenverkehr an Knative-gesteuerte Anwendungen weiterzuleiten. </p><br><p>  Istio Service Mesh kann eine gro√üe Sucht f√ºr Knative-Benutzer werden, die es ausprobieren m√∂chten, ohne das Istio-Kontrollfeld zu installieren, da Knative nur vom Gateway abh√§ngig ist. </p><br><p>  Aus diesem Grund bevorzugen die meisten Benutzer Gloo als Gateway zu Knative, das mit Istio √§hnliche Funktionen bietet (wenn wir √ºber den Zweck sprechen, nur Knative zu verwenden), sowie deutlich weniger Ressourcen verbraucht und niedrigere Betriebskosten bietet. </p><br><p>  Lassen Sie uns Knative in Aktion am Stand √ºberpr√ºfen.  Ich verwende einen frisch installierten Cluster, der in GKE ausgef√ºhrt wird: </p><br><pre> <code class="plaintext hljs">kubectl get namespace NAME STATUS AGE default Active 21h kube-public Active 21h kube-system Active 21h</code> </pre> <br><p>  Wir fahren mit der Installation von Knative und Gloo fort.  Dies kann in beliebiger Reihenfolge erfolgen: </p><br><pre> <code class="plaintext hljs">#  Knative-Serving kubectl apply -f \ https://github.com/knative/serving/releases/download/v0.8.0/serving-core.yaml namespace/knative-serving created # ... #  Gloo kubectl apply -f \ https://github.com/solo-io/gloo/releases/download/v0.18.22/gloo-knative.yaml namespace/gloo-system created # ...</code> </pre> <br><p>  Stellen Sie sicher, dass sich alle Pods im Status "Running" befinden: </p><br><pre> <code class="plaintext hljs">kubectl get pod -n knative-serving NAME READY STATUS RESTARTS AGE activator-5dd55958cc-fkp7r 1/1 Running 0 7m32s autoscaler-fd66459b7-7d5s2 1/1 Running 0 7m31s autoscaler-hpa-85b5667df4-mdjch 1/1 Running 0 7m32s controller-85c8bb7ffd-nj9cs 1/1 Running 0 7m29s webhook-5bd79b5c8b-7czrm 1/1 Running 0 7m29s kubectl get pod -n gloo-system NAME READY STATUS RESTARTS AGE discovery-69548c8475-fvh7q 1/1 Running 0 44s gloo-5b6954d7c7-7rfk9 1/1 Running 0 45s ingress-6c46cdf6f6-jwj7m 1/1 Running 0 44s knative-external-proxy-7dd7665869-x9xkg 1/1 Running 0 44s knative-internal-proxy-7775476875-9xvdg 1/1 Running 0 44s</code> </pre> <br><p>  Gloo ist bereit f√ºr das Routing. Erstellen wir einen automatisch skalierbaren Knative-Service (nennen wir ihn kservice) und leiten Sie den Datenverkehr dorthin. </p><br><p>  Knative Services bieten eine einfachere M√∂glichkeit, Anwendungen f√ºr Kubernetes bereitzustellen - im Vergleich zum regul√§ren Deployment + Service + Ingress-Modell.  Wir werden mit einem solchen Beispiel arbeiten: </p><br><pre> <code class="plaintext hljs">apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: name: helloworld-go namespace: default spec: template: spec: containers: - image: gcr.io/knative-samples/helloworld-go env: - name: TARGET Value: Knative user</code> </pre> <br><p>  Ich habe dies in eine Datei kopiert und es dann folgenderma√üen auf meinen Kubernetes-Cluster angewendet: </p><br><pre> <code class="plaintext hljs">kubectl apply -f ksvc.yaml -n default</code> </pre> <br><p>  Wir k√∂nnen die Ressourcen anzeigen, die Knative nach der Bereitstellung unseres 'helloworld-go'-Service im Cluster <em>erstellt hat</em> : </p><br><pre> <code class="plaintext hljs">kubectl get pod -n default NAME READY STATUS RESTARTS AGE helloworld-go-fjp75-deployment-678b965ccb-sfpn8 2/2 Running 0 68s</code> </pre> <br><p>  Der Pod mit unserem "helloworld-go" -Image wird gestartet, wenn Sie kservice bereitstellen.  Wenn es keinen Verkehr gibt, wird die Anzahl der Pods auf Null reduziert.  Und umgekehrt, wenn die Anzahl der gleichzeitigen Anforderungen einen benutzerdefinierten Schwellenwert √ºberschreitet, erh√∂ht sich die Anzahl der Pods. </p><br><pre> <code class="plaintext hljs">kubectl get ingresses.networking.internal.knative.dev -n default NAME READY REASON helloworld-go True</code> </pre> <br><p>  Knative konfiguriert seinen Eingang mithilfe einer speziellen Eingangsressource in der internen API von Knative.  Gloo verwendet diese API als Konfiguration, um die Eigenschaften von PaaS bereitzustellen, einschlie√ülich des blau-gr√ºnen Bereitstellungsmodells, des automatischen TLS, Timeouts und anderer erweiterter Routingfunktionen. </p><br><p>  Nach einiger Zeit sehen wir, dass unsere Pods verschwunden sind (da es keinen eingehenden Verkehr gab): </p><br><pre> <code class="plaintext hljs">kubectl get pod -n default No resources found. kubectl get deployment -n default NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE helloworld-go-fjp75-deployment 0 0 0 0 9m46s</code> </pre> <br><p>  Schlie√ülich werden wir versuchen, sie zu erreichen.  Das Abrufen von URLs f√ºr Knative Proxy ist mit <code>glooctl</code> einfach: </p><br><pre> <code class="plaintext hljs">glooctl proxy url --name knative-external-proxy http://35.190.151.188:80</code> </pre> <br><p>  Ohne <code>glooctl</code> Installation von <code>glooctl</code> k√∂nnen <code>glooctl</code> die Adresse und den Port in kube service aussp√§hen: </p><br><pre> <code class="plaintext hljs">kubectl get svc -n gloo-system knative-external-proxy NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE knative-external-proxy LoadBalancer 10.16.11.157 35.190.151.188 80:32168/TCP,443:30729/TCP 77m</code> </pre> <br><p>  F√ºhre ein bisschen Daten mit cURL aus: </p><br><pre> <code class="plaintext hljs">curl -H "Host: helloworld-go.default.example.com" http://35.190.151.188 Hello Knative user!</code> </pre> <br><p>  Knative bietet Entwicklern Near-PaaS zus√§tzlich zu Kubernetes 'Box-basiertem, leistungsf√§higem API-Gateway von Gloo.  Diese Anmerkung hat die umfangreiche Anzahl an Knative-Funktionen, die zur Anpassung zur Verf√ºgung stehen, sowie zus√§tzliche Funktionen nur geringf√ºgig ber√ºhrt.  √Ñhnliches gilt f√ºr Gloo! </p><br><p>  Obwohl Knative noch ein junges Projekt ist, ver√∂ffentlicht sein Team alle sechs Wochen neue Versionen. Mit der Implementierung erweiterter Funktionen wurde begonnen, z. B. die automatische TLS-Bereitstellung und die automatische Skalierung des Control Panels.  Es besteht eine hohe Wahrscheinlichkeit, dass Knative aufgrund der Zusammenarbeit zwischen zahlreichen Cloud-Unternehmen sowie aufgrund des neuen Cloud-Run-Angebots von Google zur Hauptoption f√ºr die Organisation von Serverless Computing und PaaS in Kubernetes wird.  Befolgen Sie die Nachrichten! </p><br><p>  <em>Von SouthBridge</em> <br>  Die Meinung der Leser ist uns wichtig, daher bitten wir Sie, an einer kleinen Umfrage zu zuk√ºnftigen Artikeln √ºber Knative, Kubernetes und Serverless Computing teilzunehmen: </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475630/">https://habr.com/ru/post/de475630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475612/index.html">Vorausgesetzt, wann, Behauptungen und Vertrauen in die Umsetzung</a></li>
<li><a href="../de475614/index.html">Automatisierung f√ºr die Kleinsten. Zweiter Teil. Netzwerkdesign</a></li>
<li><a href="../de475618/index.html">So erstellen Sie einen Smart Python-Vertrag im Ontology-Netzwerk. Teil 2: Speicher-API</a></li>
<li><a href="../de475624/index.html">PHP-Watcher: Ein Tool, das die Entwicklung langlebiger Anwendungen vereinfacht</a></li>
<li><a href="../de475626/index.html">K√∂nnen Autotests eine Person auf der Suche nach Schwachstellen ersetzen: Interview mit Alexandra Svatikova</a></li>
<li><a href="../de475636/index.html">Inkrementieren Sie Vektorelemente</a></li>
<li><a href="../de475640/index.html">Wenn Sie etwas erstellen, vermeiden Sie den Zeitplan des Managers.</a></li>
<li><a href="../de475642/index.html">Heap-Only-Tupel-Mechanismus in PostgreSQL</a></li>
<li><a href="../de475646/index.html">Yuri Ryabtsev: "Das erste Abfangen einer ballistischen Rakete ist ein Ereignis, das in etwa Gagarins Flug entspricht."</a></li>
<li><a href="../de475652/index.html">Wie wir eine mobile Anwendung auf dem Aurora OS (Sailfish Mobile OS RUS) entwickelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>