<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎱 🗜️ 🧓🏼 Schreiben eines Wasm Loader für Ghidra. Teil 1: Problemstellung und Einrichtung der Umgebung 🕐 💟 😅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche machte die NSA ( National Security Agency ) plötzlich ein Geschenk an die Menschheit und öffnete Quellen für ihr Software-Reverse-Engineer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines Wasm Loader für Ghidra. Teil 1: Problemstellung und Einrichtung der Umgebung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443318/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xy/1q/jm/xy1qjmpn0nactzdrq1laun9brhm.png"></div><br>  Diese Woche machte die NSA ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">National Security Agency</a> ) plötzlich ein Geschenk an die Menschheit und öffnete Quellen für ihr Software-Reverse-Engineering-Framework.  Die Community der Reverse Engineers und Sicherheitsexperten begann mit großer Begeisterung, das neue Spielzeug zu erkunden.  Dem Feedback zufolge ist es ein wirklich erstaunliches Tool, das mit vorhandenen Lösungen wie IDA Pro, R2 und JEB konkurrieren kann.  Das Tool heißt Ghidra und professionelle Ressourcen sind voller Eindrücke von Forschern.  Eigentlich hatten sie einen guten Grund: Nicht jeden Tag bieten Regierungsorganisationen Zugang zu ihren internen Instrumenten.  Ich selbst als professioneller Reverse Engineer und Malware-Analyst konnte nicht vorbeikommen.  Ich beschloss, ein oder zwei Wochenenden zu verbringen und mir einen ersten Eindruck vom Tool zu verschaffen.  Ich hatte ein bisschen mit der Demontage gespielt und beschlossen, die Erweiterbarkeit des Tools zu überprüfen.  In dieser Artikelserie werde ich die Entwicklung des Ghidra-Add-Ons erläutern, das ein benutzerdefiniertes Format lädt, das zur Lösung der CTF-Aufgabe verwendet wird.  Da es sich um ein großes Framework handelt und ich eine ziemlich komplizierte Aufgabe gewählt habe, werde ich den Artikel in mehrere Teile aufteilen. <br><br>  Am Ende dieses Teils hoffe ich, die Entwicklungsumgebung einzurichten und ein minimales Modul zu erstellen, das das Format der WebAssembly-Datei erkennen und den richtigen Disassembler für die Verarbeitung vorschlagen kann. <br><a name="habracut"></a><br>  Beginnen wir mit der Aufgabenbeschreibung.  Letztes Jahr veranstaltete das Sicherheitsunternehmen FireEye einen CTF-Wettbewerb mit dem Namen Flare-On.  Während des Wettbewerbs mussten die Forscher zwölf Aufgaben im Zusammenhang mit dem Reverse Engineering lösen.  Eine der Aufgaben bestand darin, die mit WebAssembly erstellte Webanwendung zu untersuchen.  Es ist ein relativ neues ausführbares Format, und soweit ich weiß, gibt es keine perfekten Werkzeuge, um damit umzugehen.  Während der Herausforderung habe ich verschiedene Tools ausprobiert, um sie zu besiegen.  Dies waren einfache Skripte von Github und bekannten Dekompilierern wie IDA Pro und JEB.  Überraschenderweise habe ich mich für Chrome entschieden, das einen ziemlich guten Disassembler und Debugger für WebAssembly bietet.  Mein Ziel ist es, die Herausforderung mit der Ghidra zu lösen.  Ich werde die Studie so vollständig wie möglich beschreiben und alle möglichen Informationen geben, um meine Schritte zu reproduzieren.  Vielleicht gehe ich als Person, die nicht viel Erfahrung mit dem Instrument hat, auf einige unnötige Details ein, aber so ist es. <br><br>  Die Aufgabe, die ich für das Studium verwenden werde, kann von der flareon5-Herausforderungsseite heruntergeladen <a href="">werden</a> .  Es gibt die Datei 05_web2point0.7z: Archiv, verschlüsselt mit einem unheimlichen Wort, das <b>infiziert ist</b> .  Das Archiv enthält drei Dateien: index.html, main.js und test.wasm.  Öffnen wir die Datei index.html in einem Browser und überprüfen das Ergebnis: <br><br><img src="https://habrastorage.org/webt/5z/o2/fd/5zo2fdf7jjndo2tmhesju4go7io.png"><br><br>  Nun, damit werde ich arbeiten.  Beginnen wir mit dem HTML-Studium, zumal es der einfachste Teil der Herausforderung ist.  Der HTML-Code enthält nichts außer dem Laden des Skripts main.js. <br><br><pre><code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"./main.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Das Skript macht auch nichts Kompliziertes, obwohl es etwas ausführlicher aussieht.  Es lädt nur die Datei test.wasm und erstellt daraus eine WebAssembly-Instanz.  Dann liest es den Parameter "q" aus der URL und übergibt ihn an die von der Instanz exportierte Methodenübereinstimmung.  Wenn die Zeichenfolge im Parameter falsch ist, zeigt das Skript das oben gezeigte Bild in Bezug auf FireEye-Entwickler mit dem Namen "Pile of Poo". <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder().encode(getParameterByName(<span class="hljs-string"><span class="hljs-string">"q"</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pa = wasm_alloc(instance, <span class="hljs-number"><span class="hljs-number">0x200</span></span>); wasm_write(instance, pa, a); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pb = wasm_alloc(instance, <span class="hljs-number"><span class="hljs-number">0x200</span></span>); wasm_write(instance, pb, b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance.exports.Match(pa, a.byteLength, pb, b.byteLength) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// PARTY POPPER document.getElementById("container").innerText = "ðŸŽ‰"; } else { // PILE OF POO document.getElementById("container").innerText = "ðŸ'"; }</span></span></code> </pre><br>  Die Lösung der Aufgabe besteht darin, den Wert des Parameters q zu ermitteln, mit dem die Funktion "übereinstimmt" und "Wahr" zurückgibt.  Dazu zerlege ich die Datei test.wasm und analysiere den Algorithmus der Funktion Match. <br><br>  Es gibt keine Überraschungen und ich werde versuchen, es in Ghidra zu tun.  Aber zuerst muss ich es installieren.  Die Installation kann (und sollte) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://ghidra-sre.org/</a> heruntergeladen werden.  Da es in Java geschrieben ist, gibt es fast keine besonderen Anforderungen an die Installation, es erfordert keine besonderen Anstrengungen bei der Installation.  Sie müssen lediglich das Archiv entpacken und die Anwendung ausführen.  Sie müssen lediglich JDK und JRE auf Version 11 aktualisieren. <br><br>  Erstellen wir ein neues Ghidra-Projekt ( <b>Datei-&gt; Neues Projekt</b> ) und nennen es "wasm" / <br><br><img src="https://habrastorage.org/webt/yt/1j/2s/yt1j2sgpytbsoyhsschjdit4v7m.png"><br><br>  Fügen Sie dann die Datei test.wasm ( <b>Datei →</b> Datei importieren) hinzu, um zu projizieren, und sehen Sie, wie ghidra damit umgehen kann <br><br><img src="https://habrastorage.org/webt/up/wq/jq/upwqjqan-5cooznznqw5pcks-pw.png"><br><br>  Nun, es kann nichts tun.  Es erkennt kein Format und kann nichts zerlegen, daher ist es absolut machtlos, diese Aufgabe zu erledigen.  Endlich sind wir zum Thema des Artikels gekommen.  Es bleibt nichts anderes zu tun, als ein Modul zu schreiben, mit dem die WASM-Datei geladen, analysiert und der Code zerlegt werden kann. <br><br>  Zunächst habe ich alle verfügbaren Dokumentationen studiert.  Tatsächlich gibt es nur ein geeignetes Dokument, das den Prozess der Entwicklung von Add-Ons zeigt: Folien GhidraAdvancedDevelopment.  Ich werde dem Dokument folgen und Schlag für Schlag beschreiben. <br><br>  Leider erfordert die Entwicklung von Add-Ons die Verwendung von Eclipse.  Alle meine Erfahrungen mit Eclipse sind die Entwicklung von zwei GDX-Spielen für Android im Jahr 2012. Es waren zwei Wochen voller Schmerzen und Leiden, nach denen ich sie aus meinem Kopf löschte.  Hoffe nach 7 Jahren Entwicklung ist es besser als früher. <br><br>  Lassen Sie uns Eclipse von der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> herunterladen und installieren. <br><br>  Installieren Sie dann die Erweiterung für die Ghidra-Entwicklung: <br><br>  Gehen Sie zur Eclipse- <b>Hilfe →</b> Menü <b>Neue Software installieren</b> , klicken <b>Sie auf die</b> Schaltfläche <b>Hinzufügen</b> und wählen Sie GhidraDev.zip unter / Extensions / Eclipse / GhidraDev /.  Installieren Sie es und starten Sie die Erweiterung neu.  Die Erweiterung, die dem neuen Projektmenü Vorlagen hinzufügt, ermöglicht das Debuggen von Modulen aus Eclipse und das Kompilieren von Modulen in das Distributionspaket. <br><br>  Wie aus den Entwicklerdokumenten hervorgeht, müssen die folgenden Schritte ausgeführt werden, um ein Modul für die Verarbeitung des neuen Binärformats hinzuzufügen: <br><br><ul><li>  Erstellen Sie Klassen, die Datenstrukturen beschreiben </li><li>  Lader entwickeln.  Der Loader sollte von der Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AbstractLibrarySupportLoader</a> geerbt werden.  Es liest alle erforderlichen Daten aus der Datei, überprüft die Datenintegrität und konvertiert die Binärdaten in eine interne Darstellung, um sie für die Analyse vorzubereiten <br></li><li>  Analysator entwickeln.  Analyzer wird von der Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AbstractAnalyzer</a> geerbt.  Es nimmt die vom Loader vorbereiteten Datenstrukturen und kommentiert sie (ich bin mir nicht sicher, was das bedeutet, aber ich hoffe, sie während der Entwicklung zu verstehen). <br></li><li>  Prozessor hinzufügen.  Ghidra hat eine Abstraktion: Prozessor.  Es ist in interner deklarativer Sprache geschrieben und beschreibt den Befehlssatz, das Speicherlayout und andere architektonische Merkmale.  Ich werde dieses Thema behandeln und den Disassembler schreiben. <br></li></ul><br>  Wenn wir nun alle notwendigen Theorien haben, ist es Zeit, das Modulprojekt zu erstellen.  Dank der zuvor installierten Eclipse-Erweiterung GhidraDev haben wir die <b>Modulvorlage</b> direkt im Menü <b>Datei-&gt; Neues Projekt</b> . <br><br><img src="https://habrastorage.org/webt/ir/z3/77/irz377yf_rcsginnfb-e8-ee-ga.png"><br><br>  Der Assistent fragt, welche Komponenten erforderlich sind.  Wie bereits beschrieben, benötigen wir zwei davon: Lader und Analysator. <br><br><img src="https://habrastorage.org/webt/vf/cc/j1/vfccj1djknkxefjuc1bg9pysycs.png"><br><br>  Der Assistent erstellt ein Projektskelett mit allen erforderlichen Teilen: leerer Analysator in der Datei WasmAnalyzer.java, leerer Loader in der Datei WasmLoader.java und Sprachskelett in Verzeichnis / Daten / Sprachen. <br><br><img src="https://habrastorage.org/webt/bu/3q/uw/bu3quwuupe-0heogbta81hrub7c.png"><br><br>  Beginnen wir mit dem Lader.  Wie bereits erwähnt, sollte es von der Klasse AbstractLibrarySupportLoader geerbt werden und drei Methoden zum Überladen haben: <br><br><ul><li>  getName - Diese Methode sollte den internen Namen des Loaders haben.  Ghidra verwendet es an verschiedenen Stellen, um beispielsweise den Loader an den Prozessor zu binden </li><li>  findSupportedLoadSpecs - Rückruf, ausgeführt, wenn der Benutzer die zu importierende Datei ausgewählt hat.  In diesem Rückruf sollte der Loader entscheiden, ob er die Datei verarbeiten und die Instanz der Klasse LoadSpec zurückgeben kann, und dem Benutzer mitteilen, wie die Datei verarbeitet werden kann </li><li>  load - Rückruf, ausgeführt, nachdem der Benutzer die Datei geladen hat.  Bei dieser Methode analysiert der Loader die Dateistruktur und lädt sie in Ghidra.  Wird im nächsten Artikel ausführlicher beschrieben </li></ul><br>  Die erste und einfachste Methode ist getName. Sie gibt nur den Namen des Loaders zurück <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"WebAssembly"</span></span>; }</code> </pre><br>  Die zweite zu implementierende Methode ist findSupportedLoadSpecs.  Es wird vom Tool während des Imports der Datei aufgerufen und sollte überprüfen, ob der Loader die Datei verarbeiten kann.  Wenn die Methode able in der Lage ist, ein Objekt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LoadSpec-</a> Klasse zurückzugeben, wird angegeben, welches Objekt zum Laden der Datei verwendet wird und welcher Prozessor den Code zerlegt. <br><br>  Die Methode beginnt mit der Formatüberprüfung.  Wie aus der <a href="">Spezifikation hervorgeht</a> , sollten die ersten acht Bytes der WASM-Datei die Signatur "\ 0asm" und die Version sein. <br><br>  Um den Header zu analysieren, habe ich die Klasse WasmHeader erstellt und die Schnittstelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StructConverter</a> implementiert, die als Basisschnittstelle zur Beschreibung strukturierter Daten dient.  Der Konstruktor des WasmHeader empfängt das Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BinaryReader</a> - Abstraktion, mit dem Daten aus der zu analysierenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binärquelle</a> gelesen werden.  Der Konstruktor verwendet es, um den Header der Eingabedatei zu lesen <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] magic; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> [] version; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WasmHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryReader reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ magic = reader.readNextByteArray(WASM_MAGIC_BASE.length()); version = reader.readNextByteArray(WASM_VERSION_LENGTH); }</code> </pre><br>  Loader verwendet dieses Objekt, um die Signatur der Datei zu überprüfen.  Sucht dann im Erfolgsfall nach dem geeigneten Prozessor.  Es ruft die Methodenabfrage der Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QueryOpinionService auf</a> und übergibt ihr den Namen des Loaders ("Webassembly").  OpinionService sucht nach einem Prozessor, der diesem Loader zugeordnet ist, und gibt ihn zurück. <br><br><pre> <code class="java hljs">List&lt;QueryResult&gt; queries = QueryOpinionService.query(getName(), MACHINE, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br>  Sicher, es gibt nichts zurück, weil Ghidra den Prozessor WebAssembly nicht kennt und ihn definieren muss.  Wie bereits erwähnt, hat der Assistent das Sprachskelett in Verzeichnisdaten / -sprachen erstellt. <br><br><img src="https://habrastorage.org/webt/ck/hq/0d/ckhq0d4gena4dbalhjufpwv9kbs.png"><br><br>  Derzeit gibt es zwei interessante Dateien: Webassembly.opinion und Wbassembly.ldefs.  Die Datei .opinon legt die Entsprechung zwischen Loader und Prozessor fest. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">opinions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constraint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">loader</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"WebAssembly"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">compilerSpecID</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"default"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constraint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">primary</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">processor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Webassembly"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"16"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constraint</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">opinions</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Es enthält einfache XML mit wenigen Attributen.  Der Name des Loaders muss in das Attribut "Loader" und der Name des Prozessors in das Attribut "Prozessor" gesetzt werden. Beide sind "Webassembly".  In diesem Schritt fülle ich andere Parameter mit den Zufallswerten.  Sobald ich mehr über die Architektur des Webassembly-Prozessors weiß, werde ich sie in korrekte Werte ändern. <br><br>  Datei .ldefs beschreibt Funktionen des Prozessors, die Code aus der Datei ausführen sollen. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">language_definitions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">language</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">processor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Webassembly"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">endian</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"little"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"16"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">variant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"default"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slafile</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Webassembly.sla"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">processorspec</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Webassembly.pspec"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wasm:LE:16:default"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Webassembly Language Module<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">compiler</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"default"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spec</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Webassembly.cspec"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"default"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">language</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">language_definitions</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Das Attribut "Prozessor" sollte mit dem Attributprozessor aus der Datei .opinion identisch sein.  Lassen wir andere Felder unberührt.  Denken Sie jedoch beim nächsten Mal daran, dass es möglich ist, die Registrierungsbittness (Attribut "Größe"), die Datei, die die Architektur des Prozessors "Prozessorspezifikation" beschreibt, und die Datei festzulegen, die die Beschreibung des Codes in der speziellen deklarativen Sprache "slafile" enthält.  Es ist praktisch, an der Demontage zu arbeiten. <br><br>  Jetzt ist es Zeit, zum Lader zurückzukehren und die Spezifikation des Laders zurückzugeben. <br><br>  Alles ist bereit für den Testlauf.  Das Plugin für GhidraDev hat die Ausführungsoption " <b>Ausführen → Ausführen als → Ghidra</b> " zur Sonnenfinsternis hinzugefügt: <br><br><img src="https://habrastorage.org/webt/j5/z-/ft/j5z-ft7xxiy1equy99ahzrt6d7a.png"><br><br>  Es führt ghidra im Debug-Modus aus und stellt das dortige Modul bereit. Dies bietet eine hervorragende Möglichkeit, mit dem Tool zu arbeiten und gleichzeitig den Debugger zu verwenden, um Fehler im zu entwickelnden Modul zu beheben.  In dieser einfachen Phase gibt es jedoch keinen Grund, einen Debugger zu verwenden.  Nach wie vor werde ich ein neues Projekt erstellen, eine Datei importieren und sehen, ob sich meine Bemühungen gelohnt haben.  Im Gegensatz zum letzten Mal wird die Datei als WebAssembly erkannt, und der Loader schlägt einen entsprechenden Prozessor dafür vor.  Das heißt, alles funktioniert und mein Modul kann das Format erkennen. <br><br><img src="https://habrastorage.org/webt/zs/np/vd/zsnpvdvzqx5ecg7xdlz86dzres0.png"><br><br>  Im nächsten Artikel werde ich den Loader erweitern und ihn nicht nur erkennen, sondern auch die Struktur der WASM-Datei beschreiben lassen.  Ich denke, in diesem Stadium, nachdem die Umgebung eingerichtet wurde, wird es einfach sein, dies zu tun. <br><br>  Der Code des Moduls ist im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-</a> Repository verfügbar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443318/">https://habr.com/ru/post/de443318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443308/index.html">Mythen der modernen Physik. Naturschutzgesetze</a></li>
<li><a href="../de443310/index.html">Bellabeat Frauen Wellness Gadget Bewertung</a></li>
<li><a href="../de443312/index.html">Python-Speicherverwaltung</a></li>
<li><a href="../de443314/index.html">Was ist Herzlichkeit? [Übersetzung des Artikels]</a></li>
<li><a href="../de443316/index.html">ReactJS-Test: Wie tief das Kaninchenloch ist</a></li>
<li><a href="../de443320/index.html">Elektronisches Dokumentenmanagementsystem "Vizier"</a></li>
<li><a href="../de443322/index.html">GitLab 11.8 veröffentlicht mit SAST für JavaScript, GitLab Pages für Untergruppen und Bug Tracking</a></li>
<li><a href="../de443324/index.html">Python vs. Scala für Apache Spark - erwarteter Benchmark mit unerwartetem Ergebnis</a></li>
<li><a href="../de443326/index.html">Python & Arduino. Einfach, schnell und schön</a></li>
<li><a href="../de443330/index.html">Sicherheitswoche 11: RSA 2019 und eine bessere Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>