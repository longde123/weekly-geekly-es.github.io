<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¢ üë©üèº‚Äçüé§ üéß Tentando pr√©-carregamento (PHP 7.4) e RoadRunner ‚ÅâÔ∏è üò¥ üïµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Costumamos escrever e falar sobre o desempenho do PHP: como lidamos com isso em geral, como economizamos US $ 1 milh√£o ao mudar para o PH...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentando pr√©-carregamento (PHP 7.4) e RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Ol√° Habr! <br><br>  Costumamos escrever e falar sobre o desempenho do PHP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como lidamos com isso</a> em geral, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como economizamos</a> US $ 1 milh√£o ao mudar para o PHP 7.0 e tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">traduzimos</a> v√°rios materiais sobre esse t√≥pico.  Isso se deve ao fato de o p√∫blico-alvo de nossos produtos estar crescendo e o dimensionamento do back-end do PHP com ferro √© muito caro - temos 600 servidores com PHP-FPM.  Portanto, investir tempo em otimiza√ß√£o √© ben√©fico para n√≥s. <br><br>  Antes, convers√°vamos principalmente sobre as formas usuais e j√° estabelecidas de trabalhar com produtividade.  Mas a comunidade PHP est√° em alerta!  O JIT aparecer√° no PHP 8, o pr√©-carregamento aparecer√° no PHP 7.4 e estruturas fora do n√∫cleo do desenvolvimento do PHP ser√£o desenvolvidas, assumindo que o PHP funcione como um daemon.  √â hora de experimentar algo novo e ver o que isso pode nos dar. <br><br>  Como o lan√ßamento do PHP 8 ainda est√° muito longe, e as estruturas ass√≠ncronas s√£o pouco adequadas para nossas tarefas (por que - vou dizer a seguir), hoje vamos nos concentrar no pr√©-carregamento, que aparecer√° no PHP 7.4, e na estrutura para demonizar o PHP, RoadRunner. <br><br>  Esta √© a vers√£o em texto do meu relat√≥rio com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo PHP Meetup # 3</a> .  V√≠deo de todos os discursos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reunimos neste post</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php e maneiras semelhantes de executar scripts PHP e processar solicita√ß√µes (que s√£o executadas pela grande maioria dos sites e servi√ßos; por simplicidade, vou cham√°-los de PHP "cl√°ssico") funcionam com base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nada compartilhado</a> no sentido amplo do termo: <br><br><ul><li>  estado n√£o √© vasculhado entre trabalhadores de PHP; <br></li><li>  o estado n√£o √© vasculhado entre v√°rios pedidos. <br></li></ul><br>  Considere isso com um exemplo de um script simples: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Para cada solicita√ß√£o, o script √© executado da primeira √† √∫ltima linha: apesar de a inicializa√ß√£o, provavelmente, n√£o diferir da solicita√ß√£o da solicita√ß√£o e poder ser executada uma vez (economizando recursos), voc√™ ainda precisa repeti-lo para cada solicita√ß√£o.  N√£o podemos simplesmente pegar e salvar vari√°veis ‚Äã‚Äã(por exemplo, <code>$app</code> ) entre solicita√ß√µes devido √†s peculiaridades de como o PHP ‚Äúcl√°ssico‚Äù funciona. <br><br>  Como seria se f√¥ssemos al√©m do escopo do PHP "cl√°ssico"?  Por exemplo, nosso script poderia ser executado independentemente da solicita√ß√£o, inicializar e ter um loop de consulta dentro dele, no qual ele esperaria o pr√≥ximo, processaria e repetiria o loop sem limpar o ambiente (a seguir chamarei essa solu√ß√£o de "PHP como um daemon" "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Conseguimos n√£o apenas nos livrar da inicializa√ß√£o repetida para cada solicita√ß√£o, mas tamb√©m salvar a lista de cidades uma vez na vari√°vel <code>$cities</code> e us√°-la em v√°rias solicita√ß√µes sem acessar qualquer lugar, exceto a mem√≥ria (esta √© a maneira mais r√°pida de obter dados). <br><br>  O desempenho dessa solu√ß√£o √© potencialmente significativamente maior que o do PHP "cl√°ssico".  Mas geralmente o aumento da produtividade n√£o √© dado de gra√ßa - voc√™ precisa pagar um pre√ßo por isso.  Vamos ver o que pode ser no nosso caso. <br><br>  Para fazer isso, vamos complicar um pouco o nosso script e, em vez de exibir a vari√°vel <code>$name</code> , preencheremos a matriz: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  No caso do PHP "cl√°ssico", n√£o haver√° problemas - no final da consulta, a vari√°vel <code>$name</code> ser√° destru√≠da e cada solicita√ß√£o subsequente funcionar√° conforme o esperado.  No caso de iniciar o PHP como um daemon, cada solicita√ß√£o adicionar√° outra cidade a essa vari√°vel, o que levar√° a um crescimento descontrolado da matriz at√© que a mem√≥ria se esgote na m√°quina. <br><br>  Em geral, n√£o apenas a mem√≥ria pode terminar - podem ocorrer outros erros que levar√£o √† morte do processo.  Com esses problemas, o PHP "cl√°ssico" lida automaticamente.  No caso de iniciar o PHP como um daemon, precisamos monitorar de alguma forma esse daemon, reinici√°-lo se ele travar. <br><br>  Erros desse tipo s√£o desagrad√°veis, mas existem solu√ß√µes eficazes para eles.  √â muito pior se, devido a um erro, o script n√£o cair, mas alterar imprevisivelmente os valores de algumas vari√°veis ‚Äã‚Äã(por exemplo, limpa a matriz <code>$cities</code> ).  Nesse caso, todas as solicita√ß√µes subsequentes funcionar√£o com dados incorretos. <br><br><blockquote>  Resumindo, √© mais f√°cil escrever c√≥digo para PHP ‚Äúcl√°ssico‚Äù (PHP-FPM, Apache mod_php e similares) - isso nos liberta de v√°rios problemas e erros.  Mas por isso pagamos com desempenho. </blockquote><br>  A partir dos exemplos acima, vemos que em algumas partes do c√≥digo, o PHP gasta recursos que n√£o poderiam ter sido gastos (ou desperdi√ßados uma vez) no processamento de cada solicita√ß√£o da "cl√°ssica".  Estas s√£o as seguintes √°reas: <br><br><ul><li>  conex√£o de arquivo (incluir, exigir, etc.); <br></li><li>  inicializa√ß√£o (estrutura, bibliotecas, cont√™iner DI, etc.); <br></li><li>  solicitar dados do armazenamento externo (em vez de armazenar na mem√≥ria). <br></li></ul><br>  O PHP existe h√° muitos anos e pode at√© se tornar popular gra√ßas a este modelo de trabalho.  Durante esse per√≠odo, muitos m√©todos de graus variados de sucesso foram desenvolvidos para resolver o problema descrito.  Eu mencionei alguns deles no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior.  Hoje, abordaremos duas solu√ß√µes relativamente novas para a comunidade: preload e RoadRunner. <br><br><h2>  Pr√©-carregamento </h2><br>  Dos tr√™s pontos listados acima, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√©-carga foi</a> projetada para lidar com a primeira sobrecarga ao conectar arquivos.  √Ä primeira vista, isso pode parecer estranho e sem sentido, porque o PHP j√° possui o OPcache, que foi criado apenas para esse fim.  Para entender a ess√™ncia, vamos tra√ßar um perfil real com a ajuda do <code>perf</code> , sobre a qual o OPcache est√° ativado, com taxa de acerto igual a 100%. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Apesar do OPcache, vemos que <code>persistent_compile_file</code> ocupa 5,84% do tempo de execu√ß√£o da consulta. <br><br>  Para entender por que isso acontece, podemos ver as fontes de <a href="">zend_accel_load_script</a> .  Pode-se ver com eles que, apesar da presen√ßa do OPcache, com cada chamada para <code>include/require</code> assinaturas de classes e fun√ß√µes s√£o copiadas da mem√≥ria compartilhada para a mem√≥ria do processo do operador, e v√°rios trabalhos auxiliares s√£o realizados.  E esse trabalho deve ser feito para cada solicita√ß√£o, pois ao final dele a mem√≥ria do processo do trabalhador √© limpa. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Isso √© composto pelo grande n√∫mero de chamadas de inclus√£o / necessidade que geralmente fazemos em uma √∫nica solicita√ß√£o.  Por exemplo, o Symfony 4 inclui cerca de 310 arquivos antes de executar a primeira linha de c√≥digo √∫til.  √Äs vezes, isso acontece implicitamente: para criar uma inst√¢ncia da classe A, mostrada abaixo, o PHP carrega automaticamente todas as outras classes (B, C, D, E, F, G).  E especialmente a esse respeito, as depend√™ncias do Composer que declaram fun√ß√µes se destacam: para garantir que essas fun√ß√µes estejam dispon√≠veis durante a execu√ß√£o do c√≥digo do usu√°rio, o Composer sempre deve conect√°-las independentemente do uso, pois o PHP n√£o possui fun√ß√µes de carregamento autom√°tico e elas n√£o podem ser carregado no momento da chamada. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Como a pr√©-carga funciona </h3><br>  O pr√©-carregamento possui uma √∫nica configura√ß√£o principal, opcache.preload, na qual o caminho para o script PHP √© passado.  Este script ser√° executado uma vez ao iniciar o PHP-FPM / Apache / etc., e todas as assinaturas de classes, m√©todos e fun√ß√µes declaradas neste arquivo estar√£o dispon√≠veis para todos os scripts que processam solicita√ß√µes da primeira linha de sua execu√ß√£o (importante nota: isso n√£o se aplica a vari√°veis ‚Äã‚Äãe constantes globais - seus valores ser√£o redefinidos para zero ap√≥s o final da fase de pr√©-carga).  N√£o √© mais necess√°rio incluir / exigir chamadas e copiar assinaturas de fun√ß√£o / classe da mem√≥ria compartilhada para a mem√≥ria do processo: todas s√£o declaradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imut√°veis</a> e, por isso, todos os processos podem se referir ao mesmo local de mem√≥ria que as cont√©m. <br><br>  Normalmente, as classes e fun√ß√µes que precisamos est√£o em arquivos diferentes e √© inconveniente combin√°-las em um script de pr√©-carregamento.  Mas isso n√£o precisa ser feito: como o preload √© um script PHP comum, podemos usar include / require ou opcache_compile_file () do script preload para todos os arquivos que precisamos.  Al√©m disso, como todos esses arquivos ser√£o carregados uma vez, o PHP poder√° fazer otimiza√ß√µes adicionais que n√£o puderam ser feitas enquanto os arquivos foram conectados separadamente no momento da consulta.  O PHP faz otimiza√ß√µes somente dentro da estrutura de cada arquivo separado, mas no caso de pr√©-carregamento, para todo o c√≥digo carregado na fase de pr√©-carregamento. <br><br><h3>  Pr√©-carregamento de benchmarks </h3><br>  Para demonstrar na pr√°tica os benef√≠cios do pr√©-carregamento, usei um ponto final associado √† CPU, o Badoo.  Nosso back-end geralmente √© caracterizado por carga ligada √† CPU.  Esse fato √© a resposta para a pergunta por que n√£o consideramos estruturas ass√≠ncronas: elas n√£o oferecem nenhuma vantagem no caso de carga ligada √† CPU e, ao mesmo tempo, complicam ainda mais o c√≥digo (ele precisa ser escrito de forma diferente), bem como para trabalhar com uma rede, disco, etc. drivers ass√≠ncronos especiais s√£o necess√°rios. <br><br>  Para apreciar completamente os benef√≠cios do pr√©-carregamento, para o experimento, baixei com ele todos os arquivos necess√°rios para o script testado no trabalho e carreguei-o com uma apar√™ncia de uma carga de produ√ß√£o normal usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wrk2</a> - um an√°logo mais avan√ßado do Apache Benchmark, mas igualmente simples . <br><br>  Para experimentar o pr√©-carregamento, voc√™ deve primeiro atualizar para o PHP 7.4 (agora temos o PHP 7.2).  Eu medi o desempenho do PHP 7.2, PHP 7.4 sem pr√©-carregamento e PHP 7.4 com pr√©-carregamento.  O resultado √© uma imagem: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Portanto, a transi√ß√£o do PHP 7.2 para o PHP 7.4 fornece + 10% ao desempenho em nosso n√≥ de extremidade e o pr√©-carregamento fornece outros 10% acima. <br><br>  No caso de pr√©-carregamento, os resultados depender√£o muito do n√∫mero de arquivos conectados e da complexidade da l√≥gica execut√°vel: se muitos arquivos estiverem conectados e a l√≥gica for simples, o pr√©-carregamento fornecer√° mais do que se houver poucos arquivos e a l√≥gica for complexa. <br><br><h3>  As nuances da pr√©-carga </h3><br>  O que aumenta a produtividade geralmente tem uma desvantagem.  O pr√©-carregamento tem muitas nuances, que darei a seguir.  Todos eles precisam ser levados em considera√ß√£o, mas apenas um (primeiro) pode ser fundamental. <br><br><h4>  Alterar - reiniciar </h4><br>  Como todos os arquivos de pr√©-carregamento s√£o compilados apenas na inicializa√ß√£o, marcados como imut√°veis ‚Äã‚Äãe n√£o recompilados no futuro, a √∫nica maneira de aplicar altera√ß√µes nesses arquivos √© reiniciar (recarregar ou reiniciar) PHP-FPM / Apache / etc. <br><br>  No caso de recarregar, o PHP tenta reiniciar com a maior precis√£o poss√≠vel: as solicita√ß√µes do usu√°rio n√£o ser√£o interrompidas, mas, mesmo assim, enquanto a fase de pr√©-carregamento estiver em andamento, todas as novas solicita√ß√µes aguardar√£o a conclus√£o.  Se n√£o houver muito c√≥digo no pr√©-carregamento, isso pode n√£o causar problemas, mas se voc√™ tentar fazer o download de todo o aplicativo, haver√° um aumento significativo no tempo de resposta durante uma reinicializa√ß√£o. <br><br>  Al√©m disso, uma reinicializa√ß√£o (independentemente de ser recarregada ou reiniciada) possui um recurso importante - como resultado dessa a√ß√£o, o OPcache √© limpo.  Ou seja, todas as solicita√ß√µes depois funcionar√£o com um cache de c√≥digo de opera√ß√£o frio, o que pode aumentar ainda mais o tempo de resposta. <br><br><h4>  Caracteres indefinidos </h4><br>  Para o pr√©-carregamento carregar uma classe, tudo o que depende deve ser definido at√© este ponto.  Para a classe abaixo, isso significa que todas as outras classes (B, C, D, E, F, G), a vari√°vel <code>$someGlobalVar</code> e a constante SOME_CONST devem estar dispon√≠veis antes da compila√ß√£o desta classe.  Como o script de pr√©-carregamento √© apenas um c√≥digo PHP comum, podemos definir um carregador autom√°tico.  Nesse caso, tudo o que estiver conectado a outras classes ser√° carregado automaticamente.  Mas isso n√£o funciona com vari√°veis ‚Äã‚Äãe constantes: n√≥s mesmos devemos garantir que eles sejam definidos no momento em que essa classe √© declarada. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Felizmente, a pr√©-carga cont√©m ferramentas suficientes para entender se voc√™ tira algo do caminho ou n√£o.  Em primeiro lugar, estas s√£o mensagens de aviso com informa√ß√µes sobre o que n√£o foi carregado e por que: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Em segundo lugar, o preload adiciona uma se√ß√£o separada ao resultado da fun√ß√£o opcache_get_status (), que mostra o que foi carregado com sucesso na fase de pr√©-carregamento: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Campo de classe / otimiza√ß√£o constante </h4><br>  Como escrevi acima, o pr√©-carregamento resolve os valores dos campos / constantes da classe e os salva.  Isso permite otimizar o c√≥digo: durante o processamento da solicita√ß√£o, os dados est√£o prontos e n√£o precisam ser derivados de outros dados.  Mas isso pode levar a resultados n√£o √≥bvios, que o exemplo a seguir demonstra: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  O resultado √© uma situa√ß√£o contra-intuitiva: parece que as constantes devem ser iguais, j√° que uma delas recebeu o valor da outra, mas, na realidade, n√£o √© assim.  Isso ocorre porque as constantes globais, em contraste com as constantes / campos da classe, s√£o limpas √† for√ßa ap√≥s o t√©rmino da fase de pr√©-carregamento, enquanto as constantes / campos da classe s√£o resolvidas e salvas.  Isso leva ao fato de que, durante a execu√ß√£o da solicita√ß√£o, precisamos definir a constante global novamente, como resultado da qual ela pode obter um valor diferente. <br><br><h4>  N√£o √© poss√≠vel redeclarar someFunc () </h4><br>  No caso de classes, a situa√ß√£o √© simples: geralmente n√£o as conectamos explicitamente, mas usamos um carregador autom√°tico.  Isso significa que se uma classe for definida na fase de pr√©-carregamento, o carregador autom√°tico simplesmente n√£o ser√° executado durante a solicita√ß√£o e n√£o tentaremos conectar essa classe uma segunda vez. <br><br>  A situa√ß√£o √© diferente com as fun√ß√µes: devemos conect√°-las explicitamente.  Isso pode levar a uma situa√ß√£o em que, no script de pr√©-carregamento, conectaremos todos os arquivos necess√°rios √†s fun√ß√µes e, durante a solicita√ß√£o, tentaremos faz√™-lo novamente (um exemplo t√≠pico √© o gerenciador de inicializa√ß√£o do Composer: ele sempre tentar√° conectar todos os arquivos com as fun√ß√µes).  Nesse caso, obtemos um erro: a fun√ß√£o j√° foi definida e n√£o pode ser redefinida. <br><br>  Este problema pode ser resolvido de diferentes maneiras.  No caso do Composer, voc√™ pode, por exemplo, conectar tudo na fase de pr√©-carregamento e n√£o conectar nada relacionado ao Composer durante solicita√ß√µes.  Outra solu√ß√£o n√£o √© conectar arquivos com fun√ß√µes diretamente, mas fazer isso por meio de um arquivo proxy com uma verifica√ß√£o de function_exists (), como, por exemplo, o Guzzle HTTP. <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  O PHP 7.4 ainda n√£o foi lan√ßado oficialmente (ainda) </h4><br>  Essa nuance se tornar√° irrelevante ap√≥s algum tempo, mas at√© agora a vers√£o do PHP 7.4 ainda n√£o foi lan√ßada oficialmente e a equipe do PHP nas notas de vers√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escreve</a> explicitamente: "Por favor, N√ÉO use esta vers√£o em produ√ß√£o, √© uma vers√£o de teste inicial".  Durante nossos experimentos com pr√©-carregamento, encontramos v√°rios bugs, corrigimos eles mesmos e at√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enviamos</a> algo para o upstream.  Para evitar surpresas, √© melhor aguardar o lan√ßamento oficial. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RoadRunner</a> √© um daemon escrito em Go, que, por um lado, cria trabalhadores PHP e os monitora (inicia / termina / reinicia conforme necess√°rio) e, por outro lado, aceita solicita√ß√µes e as transmite a esses trabalhadores.  Nesse sentido, seu trabalho n√£o √© diferente do trabalho do PHP-FPM (onde tamb√©m h√° um processo mestre que monitora os trabalhadores).  Mas ainda existem diferen√ßas.  A chave √© que o RoadRunner n√£o redefine o estado do script ap√≥s a conclus√£o da consulta. <br><br>  Assim, se recordarmos nossa lista de quais recursos s√£o gastos no caso do PHP "cl√°ssico", o RoadRunner permitir√° que voc√™ lide com todos os pontos (a pr√©-carga, como lembramos, √© apenas a primeira): <br><br><ul><li>  conex√£o de arquivo (incluir, exigir, etc.); <br></li><li>  inicializa√ß√£o (estrutura, bibliotecas, cont√™iner DI, etc.); <br></li><li>  solicitar dados do armazenamento externo (em vez de armazenar na mem√≥ria). <br></li></ul><br>  O exemplo do Hello World RoadRunner √© mais ou menos assim: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Vamos tentar nosso ponto de extremidade atual, que testamos com pr√©-carregamento, para rodar no RoadRunner sem modifica√ß√µes, carreg√°-lo e medir o desempenho.  Sem modifica√ß√µes - porque, caso contr√°rio, o benchmark n√£o ser√° completamente honesto. <br><br>  Vamos tentar adaptar o exemplo do Hello World para isso. <br><br>  Em primeiro lugar, como escrevi acima, n√£o queremos que o trabalhador caia no caso de um erro.  Para fazer isso, precisamos agrupar tudo em uma tentativa global .. captura.  Em segundo lugar, como nosso script n√£o sabe nada sobre o Zend Diactoros, para obter a resposta, precisaremos converter seus resultados.  Para isso, usamos fun√ß√µes ob_.  Terceiro, nosso script n√£o sabe nada sobre a natureza da solicita√ß√£o PSR-7.  A solu√ß√£o √© preencher o ambiente PHP padr√£o dessas entidades.  E quarto, nosso script espera que a solicita√ß√£o morra e todo o estado seja limpo.  Portanto, com o RoadRunner, precisaremos fazer essa limpeza sozinhos. <br><br>  Assim, a vers√£o inicial do Hello World se transforma em algo assim: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Pontos de Refer√™ncia RoadRunner </h3><br>  Bem, √© hora de lan√ßar benchmarks. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Os resultados n√£o atendem √†s expectativas: o RoadRunner permite nivelar mais fatores que causam perdas de desempenho do que a pr√©-carga, mas os resultados s√£o piores.  Vamos descobrir por que isso acontece, como sempre, executando o perf para isso. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  Nos resultados do perf, vemos phar_compile_file.  Isso ocorre porque inclu√≠mos alguns arquivos durante a execu√ß√£o do script e, como o OPcache n√£o est√° ativado (o RoadRunner executa scripts como a CLI, onde o OPcache est√° desativado por padr√£o), esses arquivos s√£o compilados novamente com cada solicita√ß√£o. <br><br>  Edite a configura√ß√£o do RoadRunner - ative o OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Esses resultados j√° s√£o mais parecidos com o que esper√°vamos: o RoadRunner come√ßou a mostrar mais desempenho do que o pr√©-carregamento.  Mas talvez possamos conseguir ainda mais! <br><br>  Parece n√£o haver nada mais incomum com o perf - vejamos o c√≥digo PHP.  A maneira mais f√°cil de criar um perfil √© usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">phpspy</a> : ele n√£o requer nenhuma modifica√ß√£o do c√≥digo PHP - voc√™ s√≥ precisa execut√°-lo no console.  Vamos fazer isso e criar um gr√°fico de chama: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Como concordamos em n√£o modificar a l√≥gica de nosso aplicativo para a pureza do experimento, estamos interessados ‚Äã‚Äãno ramo de pilha associado ao trabalho do RoadRunner: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  A parte principal se resume a chamar fread (), quase nada pode ser feito com isso.  Mas vemos alguns outros ramos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , exceto o pr√≥prio medo.  Voc√™ pode entender o significado deles olhando para o c√≥digo-fonte: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Torna-se claro que o RoadRunner est√° tentando criar um objeto de solicita√ß√£o compat√≠vel com PSR-7 usando uma matriz serializada.  Se sua estrutura trabalha diretamente com objetos de consulta PSR-7 (por exemplo, o Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o funciona</a> ), isso √© completamente justificado.  Em outros casos, o PSR-7 se torna um link extra antes que a solicita√ß√£o seja convertida no que seu aplicativo pode trabalhar.  Vamos remover esse link intermedi√°rio e examinar os resultados novamente: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  O script de teste foi bastante f√°cil, ent√£o consegui extrair uma parte significativa do desempenho - + 17% em compara√ß√£o com o PHP puro (lembro que o pr√©-carregamento fornece + 10% no mesmo script). <br><br><h3>  Nuances do RoadRunner </h3><br>  Em geral, o uso do RoadRunner √© uma mudan√ßa mais s√©ria do que apenas a inclus√£o da pr√©-carga; portanto, as nuances aqui s√£o ainda mais significativas. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     ¬´¬ª    ‚Äî      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Conclus√£o </h2><br> ,    ¬´¬ª PHP,   ,     preload       RoadRunner. <br><br> PHP  ¬´¬ª   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 ‚Äî 845 RPS; <br></li><li> PHP 7.4 ‚Äî 931 RPS; <br></li><li> RoadRunner   ‚Äî 987 RPS; <br></li><li> PHP 7.4 + preload ‚Äî 1030 RPS; <br></li><li> RoadRunner   ‚Äî 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Obrigado pela aten√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472528/">https://habr.com/ru/post/pt472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472516/index.html">Yandex.Translator para Linux em Python + GTK3</a></li>
<li><a href="../pt472520/index.html">Kits de treinamento do v√≠deo - de maneira r√°pida e eficiente</a></li>
<li><a href="../pt472522/index.html">O livro "Desenvolvimento cont√≠nuo da API. As decis√µes corretas em um cen√°rio tecnol√≥gico em mudan√ßa ‚Äù</a></li>
<li><a href="../pt472524/index.html">Espa√ßo, grades e layouts</a></li>
<li><a href="../pt472526/index.html">3D sobe: um novo comp√≥sito para o setor aeroespacial foi criado, o que reduziu a massa de pe√ßas em 20%</a></li>
<li><a href="../pt472530/index.html">Vigil√¢ncia por v√≠deo em Moscou: realidades e perspectivas atuais</a></li>
<li><a href="../pt472532/index.html">Link de ajuda √∫til para profissionais de marketing</a></li>
<li><a href="../pt472534/index.html">Eles acordam! (N. ¬∞ F. romance, parte 1 de 2)</a></li>
<li><a href="../pt472536/index.html">Smart IdReader SDK - incorporar reconhecimento em projetos em Python e PHP</a></li>
<li><a href="../pt472540/index.html">Eles acordam! (n¬∫ hist√≥ria, parte 2 e a √∫ltima)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>