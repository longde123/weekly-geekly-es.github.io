<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíâ ‚úàÔ∏è üß§ Wie Maschinen Big Data analysieren: Eine Einf√ºhrung in Clustering-Algorithmen üßïüèø üêÑ üïë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√úbersetzung, wie Maschinen Big Data verstehen: eine Einf√ºhrung in Clustering-Algorithmen . 

 Schauen Sie sich das Bild unten an. Dies ist eine Sammlu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Maschinen Big Data analysieren: Eine Einf√ºhrung in Clustering-Algorithmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>√úbersetzung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Maschinen Big Data verstehen: eine Einf√ºhrung in Clustering-Algorithmen</a> .</i> <br><br>  Schauen Sie sich das Bild unten an.  Dies ist eine Sammlung von Insekten (Schnecken sind keine Insekten, aber wir werden keinen Fehler finden) in verschiedenen Formen und Gr√∂√üen.  Teilen Sie sie nun nach dem Grad der √Ñhnlichkeit in mehrere Gruppen ein.  Kein Fang.  Beginnen Sie mit der Gruppierung von Spinnen. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Fertig?  Obwohl es hier keine ‚Äûrichtige‚Äú L√∂sung gibt, m√ºssen Sie diese Kreaturen in vier <b>Cluster unterteilt haben</b> .  In einer Gruppe gibt es Spinnen, in der zweiten - ein Paar Schnecken, in der dritten - Schmetterlinge und in der vierten - ein Trio von Bienen und Wespen. <br><br>  Gut gemacht, richtig?  Sie k√∂nnten wahrscheinlich dasselbe tun, wenn doppelt so viele Insekten auf dem Bild w√§ren.  Und wenn Sie viel Zeit gehabt h√§tten - oder ein Verlangen nach Entomologie -, h√§tten Sie wahrscheinlich Hunderte von Insekten gruppiert. <br><br>  F√ºr eine Maschine ist es jedoch keine leichte Aufgabe, zehn Objekte in sinnvolle Cluster zu gruppieren.  Dank eines so komplexen Zweigs der Mathematik wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kombinatorik</a> wissen wir, dass 10 Insekten auf 115.975 Arten gruppiert sind.  Und wenn es 20 Insekten gibt, wird die Anzahl der Clustering-Optionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">50 Billionen √ºberschreiten</a> . <br><br>  Mit hundert Insekten ist die Anzahl der m√∂glichen L√∂sungen gr√∂√üer als die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzahl der Elementarteilchen im bekannten Universum</a> .  Wie viel mehr?  Nach meinen Sch√§tzungen etwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºnfhundert Millionen Milliarden Mal mehr</a> .  Es stellt sich heraus, dass mehr als <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vier Millionen Milliarden Google-</a></b> L√∂sungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was ist Google?</a> ).  Und das nur f√ºr Hunderte von Objekten. <br><br>  Fast alle diese Kombinationen sind bedeutungslos.  Trotz der unvorstellbaren Anzahl von L√∂sungen haben Sie selbst sehr schnell eine der wenigen n√ºtzlichen M√∂glichkeiten zum Clustering gefunden. <br><br>  Wir Menschen halten unsere hervorragende F√§higkeit, gro√üe Datenmengen zu katalogisieren und zu verstehen, f√ºr selbstverst√§ndlich.  Es spielt keine Rolle, ob es sich um Text, Bilder auf dem Bildschirm oder eine Folge von Objekten handelt - Menschen verstehen im Allgemeinen die Daten aus der Umgebung effektiv. <br><br>  Wie kann ich die Arbeitseffizienz verbessern, da ein Schl√ºsselaspekt der KI-Entwicklung und des maschinellen Lernens darin besteht, dass Maschinen gro√üe Mengen an Eingabedaten schnell verstehen k√∂nnen?  In diesem Artikel werden drei Clustering-Algorithmen betrachtet, mit denen Maschinen gro√üe Datenmengen schnell erfassen k√∂nnen.  Diese Liste ist bei weitem nicht vollst√§ndig - es gibt andere Algorithmen - aber es ist bereits durchaus m√∂glich, damit zu beginnen. <br><br>  F√ºr jeden Algorithmus werde ich beschreiben, wann er verwendet werden kann, wie er funktioniert, und ich werde auch ein Beispiel mit schrittweiser Analyse geben.  Ich glaube, f√ºr ein wirkliches Verst√§ndnis des Algorithmus m√ºssen Sie seine Arbeit selbst wiederholen.  Wenn Sie <b>wirklich interessiert sind</b> , werden Sie feststellen, dass es am besten ist, Algorithmen auf Papier auszuf√ºhren.  Handeln Sie, niemand wird Ihnen die Schuld geben! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Drei verd√§chtig saubere Cluster mit k = 3</i> <br><br><h2>  K-bedeutet Clustering </h2><br><h5>  Verwendet von: </h5><br>  Wenn Sie verstehen, wie viele Gruppen erhalten werden k√∂nnen, um <b>eine vorgegebene</b> (a priori) zu finden. <br><br><h5>  Wie es funktioniert: </h5><br>  Der Algorithmus ordnet jede Beobachtung zuf√§llig einer von <b>k</b> Kategorien zu und berechnet dann den <b>Durchschnitt</b> f√ºr jede Kategorie.  Dann ordnet er jede Beobachtung der Kategorie mit dem n√§chsten Durchschnitt zu und berechnet erneut die Durchschnittswerte.  Der Vorgang wird wiederholt, bis Neuzuweisungen erforderlich sind. <br><br><h5>  Arbeitsbeispiel: </h5><br>  Nehmen Sie eine Gruppe von 12 Spielern und die Anzahl der Tore, die jeder von ihnen in der aktuellen Saison erzielt hat (zum Beispiel im Bereich von 3 bis 30).  Wir teilen die Spieler beispielsweise in drei Cluster ein. <br><br>  <b>Schritt 1</b> : Sie m√ºssen die Spieler zuf√§llig in drei Gruppen aufteilen und den Durchschnitt f√ºr jede von ihnen berechnen. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Schritt 2</b> : Ordnen Sie jeden Spieler der Gruppe mit dem n√§chsten Durchschnitt zu.  Zum Beispiel geht Spieler A (5 Tore) in Gruppe 2 (Durchschnitt = 9).  Andererseits berechnen wir die Gruppenmittelwerte. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Wiederholen Sie</b> Schritt 2 immer wieder, bis die Spieler aufh√∂ren, die Gruppe zu wechseln.  In diesem k√ºnstlichen Beispiel geschieht dies bei der n√§chsten Iteration.  <b>H√∂r auf!</b>  Sie haben drei Cluster aus einem Datensatz gebildet! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Cluster sollten der Position der Spieler auf dem Spielfeld entsprechen - Verteidiger, Innenverteidiger und St√ºrmer.  K-means funktioniert in diesem Beispiel, da Grund zu der Annahme besteht, dass die Daten in diese drei Kategorien unterteilt werden. <br><br>  Basierend auf den statistischen Leistungsschwankungen kann die Maschine somit die Position der Spieler auf dem Spielfeld f√ºr jede Mannschaftssportart rechtfertigen.  Dies ist n√ºtzlich f√ºr die Sportanalyse sowie f√ºr alle anderen Aufgaben, bei denen die Aufteilung des Datensatzes in vordefinierte Gruppen dazu beitr√§gt, die entsprechenden Schlussfolgerungen zu ziehen. <br><br>  Es gibt verschiedene Variationen des beschriebenen Algorithmus.  Die anf√§ngliche Bildung von Clustern kann auf verschiedene Arten durchgef√ºhrt werden.  Wir untersuchten die zuf√§llige Einteilung der Spieler in Gruppen, gefolgt von der Berechnung der Durchschnittswerte.  Infolgedessen liegen die anf√§nglichen Gruppenmittelwerte nahe beieinander, was die Wiederholbarkeit erh√∂ht. <br><br>  Ein alternativer Ansatz besteht darin, Cluster zu bilden, die nur aus einem Spieler bestehen, und die Spieler dann in die n√§chsten Cluster zu gruppieren.  Die resultierenden Cluster h√§ngen st√§rker vom Anfangsstadium der Bildung ab, und die Wiederholbarkeit in Datens√§tzen mit hoher Variabilit√§t nimmt ab.  Bei diesem Ansatz sind m√∂glicherweise weniger Iterationen erforderlich, um den Algorithmus zu vervollst√§ndigen, da weniger Zeit f√ºr die Aufteilung der Gruppen aufgewendet wird. <br><br>  Der offensichtliche Nachteil von k-means Clustering besteht darin, dass Sie <b>im Voraus</b> erraten m√ºssen <b>,</b> wie viele Cluster Sie haben.  Es gibt Methoden zur Bewertung der Konformit√§t eines bestimmten Satzes von Clustern.  Beispielsweise ist die Quadratsumme innerhalb des Clusters ein Ma√ü f√ºr die Variabilit√§t innerhalb jedes Clusters.  Je ‚Äûbesser‚Äú die Cluster sind, desto geringer ist die gesamte Quadratsumme innerhalb des Clusters. <br><br><h2>  Hierarchisches Clustering </h2><br><h5>  Verwendet von: </h5><br>  Wenn Sie die Beziehung zwischen den Werten (Beobachtungen) offenlegen m√ºssen. <br><br><h5>  Wie es funktioniert: </h5><br>  Die Abstandsmatrix wird berechnet, in der der Wert der Zelle ( <i>i, j</i> ) die Metrik des Abstands zwischen den Werten von <i>i</i> und <i>j ist</i> .  Dann wird ein Paar der n√§chsten Werte genommen und der Durchschnitt berechnet.  Eine neue Distanzmatrix wird erstellt, gepaarte Werte werden zu einem Objekt zusammengefasst.  Dann wird ein Paar der n√§chsten Werte aus dieser neuen Matrix entnommen und ein neuer Durchschnittswert berechnet.  Der Zyklus wird wiederholt, bis alle Werte gruppiert sind. <br><br><h5>  Arbeitsbeispiel: </h5><br>  Nehmen Sie einen extrem vereinfachten Datensatz mit mehreren Arten von Walen und Delfinen.  Ich bin Biologe und kann Ihnen versichern, dass viel mehr Eigenschaften f√ºr den Bau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phylogenetischer B√§ume verwendet werden</a> .  In unserem Beispiel beschr√§nken wir uns jedoch auf die charakteristische K√∂rperl√§nge von sechs Arten von Meeress√§ugern.  Es wird zwei Berechnungsstufen geben. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Schritt 1</b> : Die Matrix der Abst√§nde zwischen allen Ansichten wird berechnet.  Wir werden die euklidische Metrik verwenden, die beschreibt, wie weit unsere Daten voneinander entfernt sind, wie die Siedlungen auf der Karte.  Sie k√∂nnen den Unterschied in der L√§nge der K√∂rper jedes Paares ermitteln, indem Sie den Wert am Schnittpunkt der entsprechenden Spalte und Zeile lesen. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Schritt 2</b> : Nehmen Sie ein Paar von zwei Arten, die einander am n√§chsten sind.  In diesem Fall handelt es sich um einen T√ºmmler und einen grauen Delphin, bei denen die durchschnittliche K√∂rperl√§nge 3,3 m betr√§gt. <br><br>  Wir wiederholen Schritt 1 und berechnen erneut die Entfernungsmatrix. Diesmal kombinieren wir T√ºmmler und Grau-Delfin zu einem Objekt mit einer K√∂rperl√§nge von 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Jetzt wiederholen wir Schritt 2, jedoch mit einer neuen Distanzmatrix.  Diesmal ist der Grind- und Killerwal am n√§chsten, also lasst sie uns zu einem Paar zusammenfassen und den Durchschnitt berechnen - 7 m. <br><br>  Wiederholen Sie als N√§chstes Schritt 1: Berechnen Sie erneut die Entfernungsmatrix, jedoch mit dem Mahl- und Killerwal in Form eines einzelnen Objekts mit einer K√∂rperl√§nge von 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Wiederholen Sie Schritt 2 mit dieser Matrix.  Der kleinste Abstand (3,7 m) liegt zwischen den beiden kombinierten Objekten, daher kombinieren wir sie zu einem noch gr√∂√üeren Objekt und berechnen den Durchschnittswert - 5,2 m. <br><br>  Wiederholen Sie dann Schritt 1 und berechnen Sie eine neue Matrix, indem Sie T√ºmmler / Grau-Delfin mit Mahl- / Killerwal kombinieren. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Wiederholen Sie Schritt 2. Der kleinste Abstand (5 m) liegt zwischen dem Buckel und dem Finwale. Wir kombinieren sie also und berechnen den Durchschnitt - 17,5 m. <br><br>  Wieder Schritt 1: Berechnen Sie die Matrix. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Wiederholen Sie abschlie√üend Schritt 2 - es ist nur noch eine Entfernung (12,3 m) vorhanden, sodass wir alle zu einem Objekt vereinen und anhalten.  Folgendes ist passiert: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  Das Objekt hat eine hierarchische Struktur (denken Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON</a> ), sodass es als Baumdiagramm oder Dendrogramm angezeigt werden kann.  Das Ergebnis √§hnelt einem Stammbaum.  Je n√§her zwei Werte an einem Baum liegen, desto √§hnlicher oder enger sind sie miteinander verbunden. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Ein einfaches Dendrogramm, das mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R-Fiddle.org erstellt wurde</a></i> <br><br>  Die Struktur des Dendrogramms erm√∂glicht es Ihnen, die Struktur des Datensatzes selbst zu verstehen.  In unserem Beispiel haben wir zwei Hauptzweige - einen mit Buckel und Finwal, den anderen mit einem T√ºmmler / Grau-Delphin und einem Mahl- / Killerwal. <br><br>  In der Evolutionsbiologie werden viel gr√∂√üere Datens√§tze mit vielen Arten und einer F√ºlle von Zeichen verwendet, um taxonomische Beziehungen zu identifizieren.  Au√üerhalb der Biologie wird hierarchisches Clustering in den Bereichen Data Mining und maschinelles Lernen angewendet. <br><br>  Dieser Ansatz erfordert keine Vorhersage der erforderlichen Anzahl von Clustern.  Sie k√∂nnen das resultierende Dendrogramm in Cluster aufteilen und den Baum auf die gew√ºnschte H√∂he ‚Äûzuschneiden‚Äú.  Sie k√∂nnen die H√∂he je nach gew√ºnschter Aufl√∂sung des Datenclusters auf verschiedene Arten ausw√§hlen. <br>  Wenn beispielsweise das obige Dendrogramm in einer H√∂he von 10 abgeschnitten wird, schneiden wir die beiden Haupt√§ste und teilen das Dendrogramm in zwei Spalten.  Wenn Sie in einer H√∂he von 2 schneiden, teilen Sie das Dendrogramm in drei Gruppen. <br><br>  Andere hierarchische Clustering-Algorithmen k√∂nnen sich in drei Aspekten von den in diesem Artikel beschriebenen unterscheiden. <br><br>  Das Wichtigste ist der Ansatz.  Hier verwendeten wir die <b>agglomerative</b> Methode: Wir begannen mit einzelnen Werten und gruppierten sie zyklisch, bis wir einen gro√üen Cluster erhielten.  Ein alternativer (und rechenintensiverer) Ansatz impliziert die umgekehrte Reihenfolge: Zuerst wird ein riesiger Cluster erstellt und dann nacheinander in immer kleinere Cluster unterteilt, bis separate Werte verbleiben. <br><br>  Es gibt auch verschiedene Methoden zur Berechnung von Distanzmatrizen.  Euklidische Metriken sind f√ºr die meisten Aufgaben ausreichend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Metriken</a> sind jedoch in einigen Situationen besser geeignet. <br><br>  Schlie√ülich kann das Verkn√ºpfungskriterium variieren.  Die Beziehung zwischen Clustern h√§ngt von ihrer N√§he zueinander ab, aber die Definition von ‚ÄûN√§he‚Äú kann unterschiedlich sein.  In unserem Beispiel haben wir den Abstand zwischen den Durchschnittswerten (oder "Schwerpunkten") jeder Gruppe gemessen und die n√§chsten Gruppen paarweise kombiniert.  Sie k√∂nnen jedoch eine andere Definition verwenden. <br><br>  Angenommen, jeder Cluster besteht aus mehreren diskreten Werten.  Der Abstand zwischen zwei Clustern kann als minimaler (oder maximaler) Abstand zwischen einem ihrer Werte definiert werden, wie unten gezeigt.  F√ºr verschiedene Kontexte ist es zweckm√§√üig, unterschiedliche Definitionen des Verkn√ºpfungskriteriums zu verwenden. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rot / Blau: Schwerpunktpool;</i>  <i>rot / gr√ºn: Kombination basierend auf Minima;</i>  <i>gr√ºn / blau: Zusammenf√ºhren basierend auf H√∂hen.</i> <br><br><h2>  Definition von Communities in Diagrammen (Graph Community Detection) </h2><br><h5>  Verwendet von: </h5><br>  Wenn Ihre Daten in Form eines Netzwerks oder "Diagramms" dargestellt werden k√∂nnen. <br><br><h5>  Wie es funktioniert: </h5><br>  <b>Eine Community in einem Diagramm</b> kann grob als Teilmenge von Scheitelpunkten definiert werden, die st√§rker miteinander verbunden sind als mit dem Rest des Netzwerks.  Es gibt verschiedene Community-Definitionsalgorithmen, die auf spezifischeren Definitionen basieren, wie z. B. Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Arbeitsbeispiel: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Graphentheorie</a> ist ein sehr interessanter Zweig der Mathematik, der es uns erm√∂glicht, komplexe Systeme in Form von abstrakten Mengen von ‚ÄûPunkten‚Äú (Eckpunkten, Knoten) zu modellieren, die durch ‚ÄûLinien‚Äú (Kanten) verbunden sind. <br><br>  Vielleicht ist die erste Anwendung von Grafiken, die mir in den Sinn kommt, das Studium sozialer Netzwerke.  In diesem Fall repr√§sentieren die Peaks Personen, die durch Rippen mit Freunden / Abonnenten verbunden sind.  Sie k√∂nnen sich jedoch jedes System in Form eines Netzwerks vorstellen, wenn Sie die Methode der sinnvollen Verbindung von Komponenten rechtfertigen k√∂nnen.  Innovative Anwendungen des Clustering mithilfe der Graphentheorie umfassen das Extrahieren von Eigenschaften aus visuellen Daten und das Analysieren genetischer regulatorischer Netzwerke. <br><br>  Schauen wir uns als einfaches Beispiel die folgende Grafik an.  Dies zeigt die acht Websites, die ich am h√§ufigsten besuche.  Die Links zwischen ihnen basieren auf Links in Wikipedia-Artikeln.  Solche Daten k√∂nnen manuell erfasst werden, aber bei gro√üen Projekten ist das Schreiben eines Python-Skripts viel schneller.  Zum Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>Das Diagramm wird mit dem igraph-Paket f√ºr R 3.3.3 erstellt</i> <br><br>  Die Farbe der Peaks h√§ngt von der Teilnahme an Gemeinschaften ab, und die Gr√∂√üe h√§ngt von der Zentralit√§t ab.  Bitte beachten Sie, dass die zentralsten Google und Twitter sind. <br><br>  Au√üerdem spiegeln die resultierenden Cluster reale Aufgaben sehr genau wider (dies ist immer ein wichtiger Leistungsindikator).  Die Eckpunkte, die die Link- / Suchseiten darstellen, sind gelb hervorgehoben.  blau hervorgehobene Websites f√ºr Online-Ver√∂ffentlichungen (Artikel, Tweets oder Code);  Rot hervorgehoben sind PayPal und YouTube, die von ehemaligen PayPal-Mitarbeitern gegr√ºndet wurden.  Guter Abzug f√ºr den Computer! <br><br>  Neben der Visualisierung gro√üer Systeme liegt die wahre Kraft von Netzwerken in der mathematischen Analyse.  Beginnen wir mit der Konvertierung des Netzwerkbildes in ein mathematisches Format.  Das Folgende <b>ist die Adjazenzmatrix</b> des Netzwerks. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Die Werte an den Schnittpunkten von Spalten und Zeilen geben an, ob sich zwischen diesem Eckpunktpaar eine Kante befindet.  Beispielsweise befindet sich zwischen Medium und Twitter am Schnittpunkt dieser Zeile und Spalte 1. Und zwischen Medium und PayPal gibt es keine Kante, sodass in der entsprechenden Zelle 0 vorhanden ist. <br><br>  Wenn wir alle Eigenschaften des Netzwerks in Form einer Adjazenzmatrix darstellen, k√∂nnen wir alle m√∂glichen n√ºtzlichen Schlussfolgerungen ziehen.  Beispielsweise kennzeichnet die Summe der Werte in einer Spalte oder Zeile den <b>Grad</b> jedes Scheitelpunkts, dh die Anzahl der mit diesem Scheitelpunkt verbundenen Objekte.  Normalerweise angezeigt durch den Buchstaben <i>k</i> . <br><br>  Wenn wir die Grade aller Eckpunkte summieren und durch zwei teilen, erhalten wir L - die Anzahl der Kanten im Netzwerk.  Die Anzahl der Zeilen und Spalten entspricht N - der Anzahl der Scheitelpunkte im Netzwerk. <br><br>  Wenn wir nur k, L, N und die Werte in allen Zellen der Adjazenzmatrix A kennen, k√∂nnen wir die Modularit√§t jeder Clusterbildung berechnen. <br><br>  Angenommen, wir haben ein Netzwerk in mehreren Communities zusammengefasst.  Anschlie√üend k√∂nnen Sie den Modularit√§tswert verwenden, um die ‚ÄûQualit√§t‚Äú des Clusters vorherzusagen.  Eine h√∂here Modularit√§t zeigt an, dass wir das Netzwerk in ‚Äûexakte‚Äú Communities unterteilt haben, und eine niedrigere Modularit√§t deutet darauf hin, dass Cluster eher zuf√§llig als vern√ºnftig gebildet werden.  Um es klarer zu machen: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  Die Modularit√§t dient als Ma√ü f√ºr die ‚ÄûQualit√§t‚Äú von Gruppen. <br><br>  Die Modularit√§t kann mit der folgenden Formel berechnet werden: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Schauen wir uns diese ziemlich fantastisch aussehende Formel an. <br><br>  <b>M</b> , wie Sie wissen, ist dies Modularit√§t. <br><br>  Der <b>1 / 2L-</b> Koeffizient bedeutet, dass wir den Rest des "K√∂rpers" der Formel durch 2L teilen, dh durch die doppelte Anzahl von Kanten im Netzwerk.  In Python k√∂nnte man schreiben: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  Was ist <code>#stuff with i and j</code> ?  Das Bit in Klammern sagt uns, dass wir (k_i k_j) / 2L von A_ij subtrahieren sollen, wobei A_ij der Wert in der Matrix am Schnittpunkt von Zeile i und Spalte j ist. <br><br>  Die Werte k_i und k_j sind die Grade jedes Scheitelpunkts.  Sie k√∂nnen durch Summieren der Werte in Zeile i bzw. Spalte j ermittelt werden.  Wenn wir sie multiplizieren und durch 2L dividieren, erhalten wir die erwartete Anzahl von Kanten zwischen den Eckpunkten i und j, wenn das Netzwerk zuf√§llig gemischt wurde. <br><br>  Der Inhalt der Klammern spiegelt den Unterschied zwischen der tats√§chlichen Struktur des Netzwerks und der erwarteten wider, wenn das Netzwerk zuf√§llig neu aufgebaut wurde.  Wenn Sie mit den Werten herumspielen, liegt die h√∂chste Modularit√§t bei A_ij = 1 und niedrig (k_i k_j) / 2L.  Das hei√üt, die Modularit√§t nimmt zu, wenn zwischen den Eckpunkten i und j eine "unerwartete" Kante liegt. <br><br>  Schlie√ülich multiplizieren wir den Inhalt der Klammern mit dem, was in der Formel als Œ¥c_i, c_j angegeben ist.  Dies ist die Kronecker-Delta-Funktion.  Hier ist die Implementierung in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Ja so einfach.  Die Funktion akzeptiert zwei Argumente. Wenn sie identisch sind, gibt sie 1 zur√ºck. Wenn nicht, dann 0. <br><br>  Mit anderen Worten, wenn die Eckpunkte i und j in einen Cluster fallen, ist Œ¥c_i, c_j = 1. Und wenn sie sich in verschiedenen Clustern befinden, gibt die Funktion 0 zur√ºck. <br><br>  Da wir den Inhalt der Klammern mit dem Kronecker-Symbol multiplizieren, ist das Ergebnis der investierten Summe <b>Œ£</b> am h√∂chsten, wenn die Eckpunkte innerhalb eines Clusters durch eine gro√üe Anzahl ‚Äûunerwarteter‚Äú Kanten verbunden sind.  Die Modularit√§t ist somit ein Indikator daf√ºr, wie gut ein Diagramm in einzelne Communities gruppiert ist. <br><br>  Die Division durch 2L begrenzt die obere Modularit√§t auf Eins.  Wenn die Modularit√§t nahe 0 oder negativ ist, bedeutet dies, dass die aktuelle Clusterbildung des Netzwerks keinen Sinn ergibt.  Durch die Erh√∂hung der Modularit√§t k√∂nnen wir einen besseren Weg finden, das Netzwerk zu gruppieren. <br><br>  Bitte beachten Sie, dass wir zur Bewertung der ‚ÄûQualit√§t‚Äú des Clustering eines Diagramms im Voraus festlegen m√ºssen, wie es gruppiert werden soll.  Leider ist es aufgrund der Komplexit√§t der Berechnungen physikalisch einfach unm√∂glich, alle Methoden zum Clustering eines Graphen durch Vergleichen ihrer Modularit√§t dumm durchzugehen, es sei denn, die Stichprobe ist sehr klein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Kombinatorik</a> legt nahe, dass es f√ºr ein Netzwerk mit 8 Eckpunkten 4.140 Clustering-Methoden gibt.  F√ºr ein Netzwerk mit 16 Eckpunkten gibt es bereits mehr als 10 Milliarden Wege, f√ºr ein Netzwerk mit 32 Eckpunkten - 128 Septillionen und f√ºr ein Netzwerk mit 80 Eckpunkten wird die Anzahl der Clustering-Methoden die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzahl der Atome im beobachtbaren Universum</a> √ºberschreiten. <br><br>  Daher verwenden wir anstelle der Aufz√§hlung die heuristische Methode, mit deren Hilfe Cluster mit maximaler Modularit√§t relativ einfach berechnet werden k√∂nnen.  Dies ist ein Algorithmus namens <i>Fast-Greedy Modularity-Maximization</i> , eine Art Analogon zu dem oben beschriebenen agglomerativen hierarchischen Clustering-Algorithmus.  Anstatt auf der Grundlage der N√§he zu kombinieren, vereint Mod-Max Communitys in Abh√§ngigkeit von √Ñnderungen der Modularit√§t.  Wie es funktioniert: <br><br>  <b>Zun√§chst wird</b> jeder Scheitelpunkt seiner eigenen Community zugewiesen und die Modularit√§t des gesamten Netzwerks berechnet - M. <br><br>  <b>Schritt 1</b> : F√ºr jedes Paar von Gemeinschaften, die durch mindestens eine Kante verbunden sind, berechnet der Algorithmus die resultierende √Ñnderung der Modularit√§t ŒîM im Fall der Kombination dieser Paare von Gemeinschaften. <br><br>  <b>Schritt 2</b> : Dann wird ein Paar genommen, wenn kombiniert, ist ŒîM maximal und kombiniert.  F√ºr dieses Clustering wird eine neue Modularit√§t berechnet und gespeichert. <br><br>  Die Schritte 1 und 2 werden <b>wiederholt</b> : Jedes Mal, wenn sich ein Paar von Gemeinschaften zusammenschlie√üt, ergibt sich das gr√∂√üte ŒîM, ein neues Clustering-Schema und sein M. <br><br>  Iterationen werden beendet <b>,</b> wenn alle Scheitelpunkte zu einem gro√üen Cluster zusammengefasst sind.  Jetzt √ºberpr√ºft der Algorithmus die gespeicherten Datens√§tze und findet das Clustering-Schema mit der h√∂chsten Modularit√§t.  Sie ist es, die als Gemeinschaftsstruktur zur√ºckkehrt. <br><br>  Zumindest f√ºr die Menschen war es rechenintensiv.  Die Graphentheorie ist eine reiche Quelle f√ºr schwierige Rechenprobleme und NP-harte Probleme.  Mithilfe von Diagrammen k√∂nnen wir viele n√ºtzliche Schlussfolgerungen zu komplexen Systemen und Datens√§tzen ziehen.  Fragen Sie Larry Page, dessen PageRank-Algorithmus, mit dem Google in weniger als einer Generation von einem Startup zu einem globalen Dominanten wurde, vollst√§ndig auf der Graphentheorie basiert. <br><br>  Studien zur Graphentheorie konzentrieren sich heute auf die Identifizierung von Gemeinschaften.  Es gibt viele Alternativen zum Modularit√§tsmaximierungsalgorithmus, der zwar n√ºtzlich, aber nicht ohne Nachteile ist. <br><br>  Erstens werden bei einem agglomerativen Ansatz kleine, genau definierte Gemeinschaften h√§ufig zu gr√∂√üeren zusammengefasst.  Dies wird als Aufl√∂sungslimit bezeichnet. Der Algorithmus weist keine Communitys zu, die kleiner als eine bestimmte Gr√∂√üe sind.  Ein weiterer Nachteil besteht darin, dass der Mod-Max-Algorithmus anstelle eines ausgepr√§gten, leicht erreichbaren globalen Peaks versucht, aus vielen engen Modularit√§tswerten ein breites "Plateau" zu erzeugen.  Infolgedessen ist es schwierig, den Gewinner zu ermitteln. <br><br>  Andere Algorithmen verwenden andere Methoden zum Definieren von Communities.  Beispielsweise ist Edge-Betweenness ein Teilungsalgorithmus (Teilungsalgorithmus), bei dem zun√§chst alle Scheitelpunkte in einem gro√üen Cluster zusammengefasst werden.  Dann werden die am wenigsten ‚Äûwichtigen‚Äú Kanten iterativ entfernt, bis alle Scheitelpunkte isoliert sind.  Das Ergebnis ist eine hierarchische Struktur, bei der die Eckpunkte umso n√§her beieinander liegen, je √§hnlicher sie sind. <br><br>  Der Algorithmus Clique Percolation ber√ºcksichtigt m√∂gliche Schnittpunkte zwischen Communities.  Es gibt eine Gruppe von Algorithmen, die auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuf√§lligen Gehen</a> in einem Graphen basieren, und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spektrale Clustering-</a> Methoden, die sich mit der spektralen Zerlegung (Eigendekomposition) der Adjazenzmatrix und anderen daraus abgeleiteten Matrizen befassen.  All diese Ideen werden verwendet, um Funktionen hervorzuheben, beispielsweise in der Bildverarbeitung. <br><br>  Wir werden nicht die Arbeitsbeispiele f√ºr jeden Algorithmus im Detail analysieren.  ,              ,     20    . <br><br><h2>  Fazit </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   ‚Äî    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413269/">https://habr.com/ru/post/de413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413253/index.html">Richard Hamming: Kapitel 21. Faseroptik</a></li>
<li><a href="../de413255/index.html">Richard Hamming: Kapitel 27. Ung√ºltige Daten</a></li>
<li><a href="../de413261/index.html">Wie die Suche funktioniert</a></li>
<li><a href="../de413265/index.html">Zum Badehaus mit IT</a></li>
<li><a href="../de413267/index.html">10 unverzichtbare Eigenschaften, die ein unerfahrener Produktmanager beachten muss</a></li>
<li><a href="../de413271/index.html">Keine Passw√∂rter: Funktionsweise des Authentifizierungssystems in einer verteilten Registrierung</a></li>
<li><a href="../de413273/index.html">Management der IT-Produktanforderungen im Unternehmen</a></li>
<li><a href="../de413275/index.html">Vergleichende Pr√ºfung von Grills, um das k√∂stlichste Ergebnis zu erzielen</a></li>
<li><a href="../de413277/index.html">JSFiddle - neue Version</a></li>
<li><a href="../de413279/index.html">Die mobile Anwendung berechnet den Kaloriengehalt von Gerichten in Restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>