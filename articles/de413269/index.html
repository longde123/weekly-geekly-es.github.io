<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 ✈️ 🧤 Wie Maschinen Big Data analysieren: Eine Einführung in Clustering-Algorithmen 🧕🏿 🐄 🕑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Übersetzung, wie Maschinen Big Data verstehen: eine Einführung in Clustering-Algorithmen . 

 Schauen Sie sich das Bild unten an. Dies ist eine Sammlu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Maschinen Big Data analysieren: Eine Einführung in Clustering-Algorithmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Übersetzung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Maschinen Big Data verstehen: eine Einführung in Clustering-Algorithmen</a> .</i> <br><br>  Schauen Sie sich das Bild unten an.  Dies ist eine Sammlung von Insekten (Schnecken sind keine Insekten, aber wir werden keinen Fehler finden) in verschiedenen Formen und Größen.  Teilen Sie sie nun nach dem Grad der Ähnlichkeit in mehrere Gruppen ein.  Kein Fang.  Beginnen Sie mit der Gruppierung von Spinnen. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Fertig?  Obwohl es hier keine „richtige“ Lösung gibt, müssen Sie diese Kreaturen in vier <b>Cluster unterteilt haben</b> .  In einer Gruppe gibt es Spinnen, in der zweiten - ein Paar Schnecken, in der dritten - Schmetterlinge und in der vierten - ein Trio von Bienen und Wespen. <br><br>  Gut gemacht, richtig?  Sie könnten wahrscheinlich dasselbe tun, wenn doppelt so viele Insekten auf dem Bild wären.  Und wenn Sie viel Zeit gehabt hätten - oder ein Verlangen nach Entomologie -, hätten Sie wahrscheinlich Hunderte von Insekten gruppiert. <br><br>  Für eine Maschine ist es jedoch keine leichte Aufgabe, zehn Objekte in sinnvolle Cluster zu gruppieren.  Dank eines so komplexen Zweigs der Mathematik wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kombinatorik</a> wissen wir, dass 10 Insekten auf 115.975 Arten gruppiert sind.  Und wenn es 20 Insekten gibt, wird die Anzahl der Clustering-Optionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">50 Billionen überschreiten</a> . <br><br>  Mit hundert Insekten ist die Anzahl der möglichen Lösungen größer als die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzahl der Elementarteilchen im bekannten Universum</a> .  Wie viel mehr?  Nach meinen Schätzungen etwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fünfhundert Millionen Milliarden Mal mehr</a> .  Es stellt sich heraus, dass mehr als <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vier Millionen Milliarden Google-</a></b> Lösungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was ist Google?</a> ).  Und das nur für Hunderte von Objekten. <br><br>  Fast alle diese Kombinationen sind bedeutungslos.  Trotz der unvorstellbaren Anzahl von Lösungen haben Sie selbst sehr schnell eine der wenigen nützlichen Möglichkeiten zum Clustering gefunden. <br><br>  Wir Menschen halten unsere hervorragende Fähigkeit, große Datenmengen zu katalogisieren und zu verstehen, für selbstverständlich.  Es spielt keine Rolle, ob es sich um Text, Bilder auf dem Bildschirm oder eine Folge von Objekten handelt - Menschen verstehen im Allgemeinen die Daten aus der Umgebung effektiv. <br><br>  Wie kann ich die Arbeitseffizienz verbessern, da ein Schlüsselaspekt der KI-Entwicklung und des maschinellen Lernens darin besteht, dass Maschinen große Mengen an Eingabedaten schnell verstehen können?  In diesem Artikel werden drei Clustering-Algorithmen betrachtet, mit denen Maschinen große Datenmengen schnell erfassen können.  Diese Liste ist bei weitem nicht vollständig - es gibt andere Algorithmen - aber es ist bereits durchaus möglich, damit zu beginnen. <br><br>  Für jeden Algorithmus werde ich beschreiben, wann er verwendet werden kann, wie er funktioniert, und ich werde auch ein Beispiel mit schrittweiser Analyse geben.  Ich glaube, für ein wirkliches Verständnis des Algorithmus müssen Sie seine Arbeit selbst wiederholen.  Wenn Sie <b>wirklich interessiert sind</b> , werden Sie feststellen, dass es am besten ist, Algorithmen auf Papier auszuführen.  Handeln Sie, niemand wird Ihnen die Schuld geben! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Drei verdächtig saubere Cluster mit k = 3</i> <br><br><h2>  K-bedeutet Clustering </h2><br><h5>  Verwendet von: </h5><br>  Wenn Sie verstehen, wie viele Gruppen erhalten werden können, um <b>eine vorgegebene</b> (a priori) zu finden. <br><br><h5>  Wie es funktioniert: </h5><br>  Der Algorithmus ordnet jede Beobachtung zufällig einer von <b>k</b> Kategorien zu und berechnet dann den <b>Durchschnitt</b> für jede Kategorie.  Dann ordnet er jede Beobachtung der Kategorie mit dem nächsten Durchschnitt zu und berechnet erneut die Durchschnittswerte.  Der Vorgang wird wiederholt, bis Neuzuweisungen erforderlich sind. <br><br><h5>  Arbeitsbeispiel: </h5><br>  Nehmen Sie eine Gruppe von 12 Spielern und die Anzahl der Tore, die jeder von ihnen in der aktuellen Saison erzielt hat (zum Beispiel im Bereich von 3 bis 30).  Wir teilen die Spieler beispielsweise in drei Cluster ein. <br><br>  <b>Schritt 1</b> : Sie müssen die Spieler zufällig in drei Gruppen aufteilen und den Durchschnitt für jede von ihnen berechnen. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Schritt 2</b> : Ordnen Sie jeden Spieler der Gruppe mit dem nächsten Durchschnitt zu.  Zum Beispiel geht Spieler A (5 Tore) in Gruppe 2 (Durchschnitt = 9).  Andererseits berechnen wir die Gruppenmittelwerte. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Wiederholen Sie</b> Schritt 2 immer wieder, bis die Spieler aufhören, die Gruppe zu wechseln.  In diesem künstlichen Beispiel geschieht dies bei der nächsten Iteration.  <b>Hör auf!</b>  Sie haben drei Cluster aus einem Datensatz gebildet! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Cluster sollten der Position der Spieler auf dem Spielfeld entsprechen - Verteidiger, Innenverteidiger und Stürmer.  K-means funktioniert in diesem Beispiel, da Grund zu der Annahme besteht, dass die Daten in diese drei Kategorien unterteilt werden. <br><br>  Basierend auf den statistischen Leistungsschwankungen kann die Maschine somit die Position der Spieler auf dem Spielfeld für jede Mannschaftssportart rechtfertigen.  Dies ist nützlich für die Sportanalyse sowie für alle anderen Aufgaben, bei denen die Aufteilung des Datensatzes in vordefinierte Gruppen dazu beiträgt, die entsprechenden Schlussfolgerungen zu ziehen. <br><br>  Es gibt verschiedene Variationen des beschriebenen Algorithmus.  Die anfängliche Bildung von Clustern kann auf verschiedene Arten durchgeführt werden.  Wir untersuchten die zufällige Einteilung der Spieler in Gruppen, gefolgt von der Berechnung der Durchschnittswerte.  Infolgedessen liegen die anfänglichen Gruppenmittelwerte nahe beieinander, was die Wiederholbarkeit erhöht. <br><br>  Ein alternativer Ansatz besteht darin, Cluster zu bilden, die nur aus einem Spieler bestehen, und die Spieler dann in die nächsten Cluster zu gruppieren.  Die resultierenden Cluster hängen stärker vom Anfangsstadium der Bildung ab, und die Wiederholbarkeit in Datensätzen mit hoher Variabilität nimmt ab.  Bei diesem Ansatz sind möglicherweise weniger Iterationen erforderlich, um den Algorithmus zu vervollständigen, da weniger Zeit für die Aufteilung der Gruppen aufgewendet wird. <br><br>  Der offensichtliche Nachteil von k-means Clustering besteht darin, dass Sie <b>im Voraus</b> erraten müssen <b>,</b> wie viele Cluster Sie haben.  Es gibt Methoden zur Bewertung der Konformität eines bestimmten Satzes von Clustern.  Beispielsweise ist die Quadratsumme innerhalb des Clusters ein Maß für die Variabilität innerhalb jedes Clusters.  Je „besser“ die Cluster sind, desto geringer ist die gesamte Quadratsumme innerhalb des Clusters. <br><br><h2>  Hierarchisches Clustering </h2><br><h5>  Verwendet von: </h5><br>  Wenn Sie die Beziehung zwischen den Werten (Beobachtungen) offenlegen müssen. <br><br><h5>  Wie es funktioniert: </h5><br>  Die Abstandsmatrix wird berechnet, in der der Wert der Zelle ( <i>i, j</i> ) die Metrik des Abstands zwischen den Werten von <i>i</i> und <i>j ist</i> .  Dann wird ein Paar der nächsten Werte genommen und der Durchschnitt berechnet.  Eine neue Distanzmatrix wird erstellt, gepaarte Werte werden zu einem Objekt zusammengefasst.  Dann wird ein Paar der nächsten Werte aus dieser neuen Matrix entnommen und ein neuer Durchschnittswert berechnet.  Der Zyklus wird wiederholt, bis alle Werte gruppiert sind. <br><br><h5>  Arbeitsbeispiel: </h5><br>  Nehmen Sie einen extrem vereinfachten Datensatz mit mehreren Arten von Walen und Delfinen.  Ich bin Biologe und kann Ihnen versichern, dass viel mehr Eigenschaften für den Bau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phylogenetischer Bäume verwendet werden</a> .  In unserem Beispiel beschränken wir uns jedoch auf die charakteristische Körperlänge von sechs Arten von Meeressäugern.  Es wird zwei Berechnungsstufen geben. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Schritt 1</b> : Die Matrix der Abstände zwischen allen Ansichten wird berechnet.  Wir werden die euklidische Metrik verwenden, die beschreibt, wie weit unsere Daten voneinander entfernt sind, wie die Siedlungen auf der Karte.  Sie können den Unterschied in der Länge der Körper jedes Paares ermitteln, indem Sie den Wert am Schnittpunkt der entsprechenden Spalte und Zeile lesen. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Schritt 2</b> : Nehmen Sie ein Paar von zwei Arten, die einander am nächsten sind.  In diesem Fall handelt es sich um einen Tümmler und einen grauen Delphin, bei denen die durchschnittliche Körperlänge 3,3 m beträgt. <br><br>  Wir wiederholen Schritt 1 und berechnen erneut die Entfernungsmatrix. Diesmal kombinieren wir Tümmler und Grau-Delfin zu einem Objekt mit einer Körperlänge von 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Jetzt wiederholen wir Schritt 2, jedoch mit einer neuen Distanzmatrix.  Diesmal ist der Grind- und Killerwal am nächsten, also lasst sie uns zu einem Paar zusammenfassen und den Durchschnitt berechnen - 7 m. <br><br>  Wiederholen Sie als Nächstes Schritt 1: Berechnen Sie erneut die Entfernungsmatrix, jedoch mit dem Mahl- und Killerwal in Form eines einzelnen Objekts mit einer Körperlänge von 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Wiederholen Sie Schritt 2 mit dieser Matrix.  Der kleinste Abstand (3,7 m) liegt zwischen den beiden kombinierten Objekten, daher kombinieren wir sie zu einem noch größeren Objekt und berechnen den Durchschnittswert - 5,2 m. <br><br>  Wiederholen Sie dann Schritt 1 und berechnen Sie eine neue Matrix, indem Sie Tümmler / Grau-Delfin mit Mahl- / Killerwal kombinieren. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Wiederholen Sie Schritt 2. Der kleinste Abstand (5 m) liegt zwischen dem Buckel und dem Finwale. Wir kombinieren sie also und berechnen den Durchschnitt - 17,5 m. <br><br>  Wieder Schritt 1: Berechnen Sie die Matrix. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Wiederholen Sie abschließend Schritt 2 - es ist nur noch eine Entfernung (12,3 m) vorhanden, sodass wir alle zu einem Objekt vereinen und anhalten.  Folgendes ist passiert: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  Das Objekt hat eine hierarchische Struktur (denken Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON</a> ), sodass es als Baumdiagramm oder Dendrogramm angezeigt werden kann.  Das Ergebnis ähnelt einem Stammbaum.  Je näher zwei Werte an einem Baum liegen, desto ähnlicher oder enger sind sie miteinander verbunden. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Ein einfaches Dendrogramm, das mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R-Fiddle.org erstellt wurde</a></i> <br><br>  Die Struktur des Dendrogramms ermöglicht es Ihnen, die Struktur des Datensatzes selbst zu verstehen.  In unserem Beispiel haben wir zwei Hauptzweige - einen mit Buckel und Finwal, den anderen mit einem Tümmler / Grau-Delphin und einem Mahl- / Killerwal. <br><br>  In der Evolutionsbiologie werden viel größere Datensätze mit vielen Arten und einer Fülle von Zeichen verwendet, um taxonomische Beziehungen zu identifizieren.  Außerhalb der Biologie wird hierarchisches Clustering in den Bereichen Data Mining und maschinelles Lernen angewendet. <br><br>  Dieser Ansatz erfordert keine Vorhersage der erforderlichen Anzahl von Clustern.  Sie können das resultierende Dendrogramm in Cluster aufteilen und den Baum auf die gewünschte Höhe „zuschneiden“.  Sie können die Höhe je nach gewünschter Auflösung des Datenclusters auf verschiedene Arten auswählen. <br>  Wenn beispielsweise das obige Dendrogramm in einer Höhe von 10 abgeschnitten wird, schneiden wir die beiden Hauptäste und teilen das Dendrogramm in zwei Spalten.  Wenn Sie in einer Höhe von 2 schneiden, teilen Sie das Dendrogramm in drei Gruppen. <br><br>  Andere hierarchische Clustering-Algorithmen können sich in drei Aspekten von den in diesem Artikel beschriebenen unterscheiden. <br><br>  Das Wichtigste ist der Ansatz.  Hier verwendeten wir die <b>agglomerative</b> Methode: Wir begannen mit einzelnen Werten und gruppierten sie zyklisch, bis wir einen großen Cluster erhielten.  Ein alternativer (und rechenintensiverer) Ansatz impliziert die umgekehrte Reihenfolge: Zuerst wird ein riesiger Cluster erstellt und dann nacheinander in immer kleinere Cluster unterteilt, bis separate Werte verbleiben. <br><br>  Es gibt auch verschiedene Methoden zur Berechnung von Distanzmatrizen.  Euklidische Metriken sind für die meisten Aufgaben ausreichend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Metriken</a> sind jedoch in einigen Situationen besser geeignet. <br><br>  Schließlich kann das Verknüpfungskriterium variieren.  Die Beziehung zwischen Clustern hängt von ihrer Nähe zueinander ab, aber die Definition von „Nähe“ kann unterschiedlich sein.  In unserem Beispiel haben wir den Abstand zwischen den Durchschnittswerten (oder "Schwerpunkten") jeder Gruppe gemessen und die nächsten Gruppen paarweise kombiniert.  Sie können jedoch eine andere Definition verwenden. <br><br>  Angenommen, jeder Cluster besteht aus mehreren diskreten Werten.  Der Abstand zwischen zwei Clustern kann als minimaler (oder maximaler) Abstand zwischen einem ihrer Werte definiert werden, wie unten gezeigt.  Für verschiedene Kontexte ist es zweckmäßig, unterschiedliche Definitionen des Verknüpfungskriteriums zu verwenden. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rot / Blau: Schwerpunktpool;</i>  <i>rot / grün: Kombination basierend auf Minima;</i>  <i>grün / blau: Zusammenführen basierend auf Höhen.</i> <br><br><h2>  Definition von Communities in Diagrammen (Graph Community Detection) </h2><br><h5>  Verwendet von: </h5><br>  Wenn Ihre Daten in Form eines Netzwerks oder "Diagramms" dargestellt werden können. <br><br><h5>  Wie es funktioniert: </h5><br>  <b>Eine Community in einem Diagramm</b> kann grob als Teilmenge von Scheitelpunkten definiert werden, die stärker miteinander verbunden sind als mit dem Rest des Netzwerks.  Es gibt verschiedene Community-Definitionsalgorithmen, die auf spezifischeren Definitionen basieren, wie z. B. Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Arbeitsbeispiel: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Graphentheorie</a> ist ein sehr interessanter Zweig der Mathematik, der es uns ermöglicht, komplexe Systeme in Form von abstrakten Mengen von „Punkten“ (Eckpunkten, Knoten) zu modellieren, die durch „Linien“ (Kanten) verbunden sind. <br><br>  Vielleicht ist die erste Anwendung von Grafiken, die mir in den Sinn kommt, das Studium sozialer Netzwerke.  In diesem Fall repräsentieren die Peaks Personen, die durch Rippen mit Freunden / Abonnenten verbunden sind.  Sie können sich jedoch jedes System in Form eines Netzwerks vorstellen, wenn Sie die Methode der sinnvollen Verbindung von Komponenten rechtfertigen können.  Innovative Anwendungen des Clustering mithilfe der Graphentheorie umfassen das Extrahieren von Eigenschaften aus visuellen Daten und das Analysieren genetischer regulatorischer Netzwerke. <br><br>  Schauen wir uns als einfaches Beispiel die folgende Grafik an.  Dies zeigt die acht Websites, die ich am häufigsten besuche.  Die Links zwischen ihnen basieren auf Links in Wikipedia-Artikeln.  Solche Daten können manuell erfasst werden, aber bei großen Projekten ist das Schreiben eines Python-Skripts viel schneller.  Zum Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>Das Diagramm wird mit dem igraph-Paket für R 3.3.3 erstellt</i> <br><br>  Die Farbe der Peaks hängt von der Teilnahme an Gemeinschaften ab, und die Größe hängt von der Zentralität ab.  Bitte beachten Sie, dass die zentralsten Google und Twitter sind. <br><br>  Außerdem spiegeln die resultierenden Cluster reale Aufgaben sehr genau wider (dies ist immer ein wichtiger Leistungsindikator).  Die Eckpunkte, die die Link- / Suchseiten darstellen, sind gelb hervorgehoben.  blau hervorgehobene Websites für Online-Veröffentlichungen (Artikel, Tweets oder Code);  Rot hervorgehoben sind PayPal und YouTube, die von ehemaligen PayPal-Mitarbeitern gegründet wurden.  Guter Abzug für den Computer! <br><br>  Neben der Visualisierung großer Systeme liegt die wahre Kraft von Netzwerken in der mathematischen Analyse.  Beginnen wir mit der Konvertierung des Netzwerkbildes in ein mathematisches Format.  Das Folgende <b>ist die Adjazenzmatrix</b> des Netzwerks. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Die Werte an den Schnittpunkten von Spalten und Zeilen geben an, ob sich zwischen diesem Eckpunktpaar eine Kante befindet.  Beispielsweise befindet sich zwischen Medium und Twitter am Schnittpunkt dieser Zeile und Spalte 1. Und zwischen Medium und PayPal gibt es keine Kante, sodass in der entsprechenden Zelle 0 vorhanden ist. <br><br>  Wenn wir alle Eigenschaften des Netzwerks in Form einer Adjazenzmatrix darstellen, können wir alle möglichen nützlichen Schlussfolgerungen ziehen.  Beispielsweise kennzeichnet die Summe der Werte in einer Spalte oder Zeile den <b>Grad</b> jedes Scheitelpunkts, dh die Anzahl der mit diesem Scheitelpunkt verbundenen Objekte.  Normalerweise angezeigt durch den Buchstaben <i>k</i> . <br><br>  Wenn wir die Grade aller Eckpunkte summieren und durch zwei teilen, erhalten wir L - die Anzahl der Kanten im Netzwerk.  Die Anzahl der Zeilen und Spalten entspricht N - der Anzahl der Scheitelpunkte im Netzwerk. <br><br>  Wenn wir nur k, L, N und die Werte in allen Zellen der Adjazenzmatrix A kennen, können wir die Modularität jeder Clusterbildung berechnen. <br><br>  Angenommen, wir haben ein Netzwerk in mehreren Communities zusammengefasst.  Anschließend können Sie den Modularitätswert verwenden, um die „Qualität“ des Clusters vorherzusagen.  Eine höhere Modularität zeigt an, dass wir das Netzwerk in „exakte“ Communities unterteilt haben, und eine niedrigere Modularität deutet darauf hin, dass Cluster eher zufällig als vernünftig gebildet werden.  Um es klarer zu machen: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  Die Modularität dient als Maß für die „Qualität“ von Gruppen. <br><br>  Die Modularität kann mit der folgenden Formel berechnet werden: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Schauen wir uns diese ziemlich fantastisch aussehende Formel an. <br><br>  <b>M</b> , wie Sie wissen, ist dies Modularität. <br><br>  Der <b>1 / 2L-</b> Koeffizient bedeutet, dass wir den Rest des "Körpers" der Formel durch 2L teilen, dh durch die doppelte Anzahl von Kanten im Netzwerk.  In Python könnte man schreiben: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  Was ist <code>#stuff with i and j</code> ?  Das Bit in Klammern sagt uns, dass wir (k_i k_j) / 2L von A_ij subtrahieren sollen, wobei A_ij der Wert in der Matrix am Schnittpunkt von Zeile i und Spalte j ist. <br><br>  Die Werte k_i und k_j sind die Grade jedes Scheitelpunkts.  Sie können durch Summieren der Werte in Zeile i bzw. Spalte j ermittelt werden.  Wenn wir sie multiplizieren und durch 2L dividieren, erhalten wir die erwartete Anzahl von Kanten zwischen den Eckpunkten i und j, wenn das Netzwerk zufällig gemischt wurde. <br><br>  Der Inhalt der Klammern spiegelt den Unterschied zwischen der tatsächlichen Struktur des Netzwerks und der erwarteten wider, wenn das Netzwerk zufällig neu aufgebaut wurde.  Wenn Sie mit den Werten herumspielen, liegt die höchste Modularität bei A_ij = 1 und niedrig (k_i k_j) / 2L.  Das heißt, die Modularität nimmt zu, wenn zwischen den Eckpunkten i und j eine "unerwartete" Kante liegt. <br><br>  Schließlich multiplizieren wir den Inhalt der Klammern mit dem, was in der Formel als δc_i, c_j angegeben ist.  Dies ist die Kronecker-Delta-Funktion.  Hier ist die Implementierung in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Ja so einfach.  Die Funktion akzeptiert zwei Argumente. Wenn sie identisch sind, gibt sie 1 zurück. Wenn nicht, dann 0. <br><br>  Mit anderen Worten, wenn die Eckpunkte i und j in einen Cluster fallen, ist δc_i, c_j = 1. Und wenn sie sich in verschiedenen Clustern befinden, gibt die Funktion 0 zurück. <br><br>  Da wir den Inhalt der Klammern mit dem Kronecker-Symbol multiplizieren, ist das Ergebnis der investierten Summe <b>Σ</b> am höchsten, wenn die Eckpunkte innerhalb eines Clusters durch eine große Anzahl „unerwarteter“ Kanten verbunden sind.  Die Modularität ist somit ein Indikator dafür, wie gut ein Diagramm in einzelne Communities gruppiert ist. <br><br>  Die Division durch 2L begrenzt die obere Modularität auf Eins.  Wenn die Modularität nahe 0 oder negativ ist, bedeutet dies, dass die aktuelle Clusterbildung des Netzwerks keinen Sinn ergibt.  Durch die Erhöhung der Modularität können wir einen besseren Weg finden, das Netzwerk zu gruppieren. <br><br>  Bitte beachten Sie, dass wir zur Bewertung der „Qualität“ des Clustering eines Diagramms im Voraus festlegen müssen, wie es gruppiert werden soll.  Leider ist es aufgrund der Komplexität der Berechnungen physikalisch einfach unmöglich, alle Methoden zum Clustering eines Graphen durch Vergleichen ihrer Modularität dumm durchzugehen, es sei denn, die Stichprobe ist sehr klein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Kombinatorik</a> legt nahe, dass es für ein Netzwerk mit 8 Eckpunkten 4.140 Clustering-Methoden gibt.  Für ein Netzwerk mit 16 Eckpunkten gibt es bereits mehr als 10 Milliarden Wege, für ein Netzwerk mit 32 Eckpunkten - 128 Septillionen und für ein Netzwerk mit 80 Eckpunkten wird die Anzahl der Clustering-Methoden die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzahl der Atome im beobachtbaren Universum</a> überschreiten. <br><br>  Daher verwenden wir anstelle der Aufzählung die heuristische Methode, mit deren Hilfe Cluster mit maximaler Modularität relativ einfach berechnet werden können.  Dies ist ein Algorithmus namens <i>Fast-Greedy Modularity-Maximization</i> , eine Art Analogon zu dem oben beschriebenen agglomerativen hierarchischen Clustering-Algorithmus.  Anstatt auf der Grundlage der Nähe zu kombinieren, vereint Mod-Max Communitys in Abhängigkeit von Änderungen der Modularität.  Wie es funktioniert: <br><br>  <b>Zunächst wird</b> jeder Scheitelpunkt seiner eigenen Community zugewiesen und die Modularität des gesamten Netzwerks berechnet - M. <br><br>  <b>Schritt 1</b> : Für jedes Paar von Gemeinschaften, die durch mindestens eine Kante verbunden sind, berechnet der Algorithmus die resultierende Änderung der Modularität ΔM im Fall der Kombination dieser Paare von Gemeinschaften. <br><br>  <b>Schritt 2</b> : Dann wird ein Paar genommen, wenn kombiniert, ist ΔM maximal und kombiniert.  Für dieses Clustering wird eine neue Modularität berechnet und gespeichert. <br><br>  Die Schritte 1 und 2 werden <b>wiederholt</b> : Jedes Mal, wenn sich ein Paar von Gemeinschaften zusammenschließt, ergibt sich das größte ΔM, ein neues Clustering-Schema und sein M. <br><br>  Iterationen werden beendet <b>,</b> wenn alle Scheitelpunkte zu einem großen Cluster zusammengefasst sind.  Jetzt überprüft der Algorithmus die gespeicherten Datensätze und findet das Clustering-Schema mit der höchsten Modularität.  Sie ist es, die als Gemeinschaftsstruktur zurückkehrt. <br><br>  Zumindest für die Menschen war es rechenintensiv.  Die Graphentheorie ist eine reiche Quelle für schwierige Rechenprobleme und NP-harte Probleme.  Mithilfe von Diagrammen können wir viele nützliche Schlussfolgerungen zu komplexen Systemen und Datensätzen ziehen.  Fragen Sie Larry Page, dessen PageRank-Algorithmus, mit dem Google in weniger als einer Generation von einem Startup zu einem globalen Dominanten wurde, vollständig auf der Graphentheorie basiert. <br><br>  Studien zur Graphentheorie konzentrieren sich heute auf die Identifizierung von Gemeinschaften.  Es gibt viele Alternativen zum Modularitätsmaximierungsalgorithmus, der zwar nützlich, aber nicht ohne Nachteile ist. <br><br>  Erstens werden bei einem agglomerativen Ansatz kleine, genau definierte Gemeinschaften häufig zu größeren zusammengefasst.  Dies wird als Auflösungslimit bezeichnet. Der Algorithmus weist keine Communitys zu, die kleiner als eine bestimmte Größe sind.  Ein weiterer Nachteil besteht darin, dass der Mod-Max-Algorithmus anstelle eines ausgeprägten, leicht erreichbaren globalen Peaks versucht, aus vielen engen Modularitätswerten ein breites "Plateau" zu erzeugen.  Infolgedessen ist es schwierig, den Gewinner zu ermitteln. <br><br>  Andere Algorithmen verwenden andere Methoden zum Definieren von Communities.  Beispielsweise ist Edge-Betweenness ein Teilungsalgorithmus (Teilungsalgorithmus), bei dem zunächst alle Scheitelpunkte in einem großen Cluster zusammengefasst werden.  Dann werden die am wenigsten „wichtigen“ Kanten iterativ entfernt, bis alle Scheitelpunkte isoliert sind.  Das Ergebnis ist eine hierarchische Struktur, bei der die Eckpunkte umso näher beieinander liegen, je ähnlicher sie sind. <br><br>  Der Algorithmus Clique Percolation berücksichtigt mögliche Schnittpunkte zwischen Communities.  Es gibt eine Gruppe von Algorithmen, die auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zufälligen Gehen</a> in einem Graphen basieren, und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spektrale Clustering-</a> Methoden, die sich mit der spektralen Zerlegung (Eigendekomposition) der Adjazenzmatrix und anderen daraus abgeleiteten Matrizen befassen.  All diese Ideen werden verwendet, um Funktionen hervorzuheben, beispielsweise in der Bildverarbeitung. <br><br>  Wir werden nicht die Arbeitsbeispiele für jeden Algorithmus im Detail analysieren.  ,              ,     20    . <br><br><h2>  Fazit </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   —    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413269/">https://habr.com/ru/post/de413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413253/index.html">Richard Hamming: Kapitel 21. Faseroptik</a></li>
<li><a href="../de413255/index.html">Richard Hamming: Kapitel 27. Ungültige Daten</a></li>
<li><a href="../de413261/index.html">Wie die Suche funktioniert</a></li>
<li><a href="../de413265/index.html">Zum Badehaus mit IT</a></li>
<li><a href="../de413267/index.html">10 unverzichtbare Eigenschaften, die ein unerfahrener Produktmanager beachten muss</a></li>
<li><a href="../de413271/index.html">Keine Passwörter: Funktionsweise des Authentifizierungssystems in einer verteilten Registrierung</a></li>
<li><a href="../de413273/index.html">Management der IT-Produktanforderungen im Unternehmen</a></li>
<li><a href="../de413275/index.html">Vergleichende Prüfung von Grills, um das köstlichste Ergebnis zu erzielen</a></li>
<li><a href="../de413277/index.html">JSFiddle - neue Version</a></li>
<li><a href="../de413279/index.html">Die mobile Anwendung berechnet den Kaloriengehalt von Gerichten in Restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>