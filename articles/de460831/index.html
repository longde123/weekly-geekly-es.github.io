<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõï üìÅ üë©üèæ‚Äçü§ù‚Äçüë©üèº Die Gefahren von Designern üï∏Ô∏è üë† ‚úçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Perils of Constructors" von Aleksey Kladov. 


 Einer meiner Lieblings-Rust-Blog-Beitr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Gefahren von Designern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460831/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Perils of Constructors" von Aleksey Kladov. </p><br><p>  Einer meiner Lieblings-Rust-Blog-Beitr√§ge ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Things Rust Shipped Without von Graydon Hoare</a> .  F√ºr mich ist das Fehlen jeglicher Merkmale in der Sprache, die ins Bein schie√üen k√∂nnen, normalerweise wichtiger als Ausdruckskraft.  In diesem leicht philosophischen Aufsatz m√∂chte ich √ºber mein besonders beliebtes Feature sprechen, das in Rust fehlt - √ºber Konstruktoren. </p><br><h1 id="chto-takoe-konstruktor">  Was ist ein Konstruktor? </h1><br><p>  Konstruktoren werden √ºblicherweise in OO-Sprachen verwendet.  Die Aufgabe des Konstruktors besteht darin, das Objekt vollst√§ndig zu initialisieren, bevor der Rest der Welt es sieht.  Auf den ersten Blick scheint dies eine wirklich gute Idee zu sein: </p><br><ol><li>  Sie <strong>legen die Invarianten</strong> im Konstruktor fest. </li><li>  Jede Methode k√ºmmert sich um die <strong>Erhaltung von</strong> Invarianten. </li><li>  Zusammen bedeuten diese beiden Eigenschaften, dass Sie Objekte als Invarianten und nicht als spezifische interne Zust√§nde betrachten k√∂nnen. </li></ol><br><p>  Der Konstruktor spielt hier die Rolle einer Induktionsbasis und ist die einzige M√∂glichkeit, ein neues Objekt zu erstellen. </p><br><p>  Leider gibt es eine L√ºcke in diesen Argumenten: Der Designer selbst beobachtet das Objekt in einem unfertigen Zustand, was viele Probleme verursacht. <a name="habracut"></a></p><br><h1 id="znachenie-this">  Dieser Wert </h1><br><p>  Wenn der Konstruktor das Objekt initialisiert, beginnt es mit einem leeren Zustand.  Aber wie definieren Sie diesen leeren Zustand f√ºr ein beliebiges Objekt? </p><br><p>  Der einfachste Weg, dies zu tun, besteht darin, alle Felder auf ihre Standardwerte zu setzen: false f√ºr bool, 0 f√ºr Zahlen, null f√ºr alle Links.  Dieser Ansatz erfordert jedoch, dass alle Typen Standardwerte haben, und f√ºhrt die ber√ºchtigte Null in die Sprache ein.  Dies ist der Pfad, den Java eingeschlagen hat: Zu Beginn der Erstellung des Objekts sind alle Felder 0 oder null. </p><br><p>  Mit diesem Ansatz wird es sehr schwierig sein, null danach loszuwerden.  Ein gutes Beispiel zum Lernen ist Kotlin.  Kotlin verwendet standardm√§√üig nicht nullf√§hige Typen, muss jedoch mit bereits vorhandener JVM-Semantik arbeiten.  Das Design der Sprache verbirgt diese Tatsache gut und ist in der Praxis gut anwendbar, aber <strong>unhaltbar</strong> .  Mit anderen Worten, mit Konstruktoren ist es m√∂glich, Nullpr√ºfungen in Kotlin zu umgehen. </p><br><p>  Das Hauptmerkmal von Kotlin ist die Ermutigung, sogenannte "Prim√§rkonstruktoren" zu erstellen, die <strong>sowohl</strong> ein Feld deklarieren als auch ihm einen Wert zuweisen, bevor benutzerdefinierter Code ausgef√ºhrt wird: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Eine weitere Option: Wenn das Feld im Konstruktor nicht deklariert ist, sollte der Programmierer es sofort initialisieren: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Der Versuch, ein Feld vor der Initialisierung zu verwenden, wird statisch abgelehnt: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  Aber mit ein bisschen Kreativit√§t kann jeder diese Schecks umgehen.  Hierzu eignet sich beispielsweise ein Methodenaufruf: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Auch dies mit einem Lambda (das in Kotlin wie folgt erstellt wird: {args -&gt; body}) zu greifen, ist ebenfalls geeignet: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Beispiele wie diese scheinen in der Realit√§t unrealistisch zu sein (und das ist es auch), aber ich habe √§hnliche Fehler im realen Code gefunden (Kolmogorovs Wahrscheinlichkeitsregel 0-1 in der Softwareentwicklung: In einer ausreichend gro√üen Datenbank ist fast garantiert, dass jeder Code existiert, zumindest wenn nicht statisch vom Compiler verboten (in diesem Fall existiert es mit ziemlicher Sicherheit nicht). </p><br><p>  Der Grund, warum Kotlin bei diesem Fehler m√∂glicherweise vorhanden ist, ist der gleiche wie bei kovarianten Java-Arrays: Zur Laufzeit werden weiterhin √úberpr√ºfungen durchgef√ºhrt.  Am Ende m√∂chte ich das Kotlin-Typ-System nicht komplizieren, um die oben genannten F√§lle in der Kompilierungsphase falsch zu machen: Angesichts der bestehenden Einschr√§nkungen (JVM-Semantik) ist das Preis-Leistungs-Verh√§ltnis von Validierungen zur Laufzeit viel besser als das von statischen. </p><br><p>  Was aber, wenn die Sprache nicht f√ºr jeden Typ einen angemessenen Standardwert hat?  In C ++, wo benutzerdefinierte Typen nicht unbedingt Referenzen sind, k√∂nnen Sie beispielsweise nicht einfach jedem Feld null zuweisen und sagen, dass dies funktioniert!  Stattdessen verwendet C ++ eine spezielle Syntax, um Anfangswerte f√ºr Felder festzulegen: Initialisierungslisten: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Da dies eine spezielle Syntax ist, funktioniert der Rest der Sprache nicht einwandfrei.  Zum Beispiel ist es schwierig, beliebige Operationen in die Initialisierungslisten aufzunehmen, da C ++ keine ausdrucksorientierte Sprache ist (was an sich normal ist).  Um mit Ausnahmen zu arbeiten, die in Initialisierungslisten auftreten, m√ºssen Sie eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">undurchsichtige Funktion der Sprache verwenden</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  Methoden aus dem Konstruktor aufrufen </h1><br><p>  Wie die Beispiele von Kotlin andeuten, zerbricht alles in Chips, sobald wir versuchen, eine Methode vom Konstruktor aufzurufen.  Grunds√§tzlich erwarten Methoden, dass das dadurch zug√§ngliche Objekt bereits vollst√§ndig konstruiert und korrekt ist (im Einklang mit Invarianten).  In Kotlin oder Java hindert Sie nichts daran, Methoden vom Konstruktor aufzurufen, und auf diese Weise k√∂nnen wir versehentlich ein halbkonstruiertes Objekt bearbeiten.  Der Designer verspricht, Invarianten zu etablieren, aber gleichzeitig ist dies der einfachste Ort f√ºr ihre m√∂gliche Verletzung. </p><br><p>  Besonders seltsame Dinge passieren, wenn der Basisklassenkonstruktor eine in einer abgeleiteten Klasse √ºberschriebene Methode aufruft: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Denken Sie nur einmal dar√ºber nach: Der Code einer beliebigen Klasse wird ausgef√ºhrt, <strong>bevor</strong> der Konstruktor aufgerufen wird!  √Ñhnlicher C ++ - Code f√ºhrt zu noch interessanteren Ergebnissen.  Anstatt die Funktion der abgeleiteten Klasse aufzurufen, wird die Funktion der Basisklasse aufgerufen.  Dies ist wenig sinnvoll, da die abgeleitete Klasse noch nicht initialisiert wurde (denken Sie daran, wir k√∂nnen nicht einfach sagen, dass alle Felder null sind).  Wenn die Funktion in der Basisklasse jedoch rein virtuell ist, f√ºhrt ihr Aufruf zu UB. </p><br><h1 id="signatura-konstruktora">  Designer-Unterschrift </h1><br><p>  Die Verletzung von Invarianten ist nicht das einzige Problem f√ºr Designer.  Sie haben eine Signatur mit einem festen Namen (leer) und einen R√ºckgabetyp (die Klasse selbst).  Dies macht es f√ºr Menschen schwierig, Design√ºberladungen zu verstehen. </p><br><blockquote>  Backfill-Frage: Was entspricht std :: vector &lt;int&gt; xs (92, 2)? <br><br>  a.  Vektor von zwei L√§ngen 92 <br><br>  b.  [92, 92] <br><br>  c.  [92, 2] </blockquote><p>  Probleme mit dem R√ºckgabewert treten in der Regel auf, wenn ein Objekt nicht erstellt werden kann.  Sie k√∂nnen nicht einfach das Ergebnis &lt;MyClass, io :: Error&gt; oder null vom Konstruktor zur√ºckgeben! </p><br><p>  Dies wird h√§ufig als Argument daf√ºr verwendet, dass die Verwendung von C ++ ohne Ausnahmen schwierig ist und dass die Verwendung von Konstruktoren Sie auch zur Verwendung von Ausnahmen zwingt.  Ich halte dieses Argument jedoch nicht f√ºr richtig: Factory-Methoden l√∂sen beide Probleme, da sie beliebige Namen haben und beliebige Typen zur√ºckgeben k√∂nnen.  Ich glaube, dass das folgende Muster in OO-Sprachen manchmal n√ºtzlich sein kann: </p><br><ul><li><p>  Erstellen Sie einen <strong>privaten</strong> Konstruktor, der die Werte aller Felder als Argumente verwendet und sie einfach zuweist.  Ein solcher Konstruktor w√ºrde also als Strukturliteral in Rust arbeiten.  Es kann auch nach Invarianten suchen, sollte aber nichts anderes mit Argumenten oder Feldern tun. </p><br></li><li><p>  F√ºr die √∂ffentliche API werden √∂ffentliche Factory-Methoden mit entsprechenden Namen und R√ºckgabetypen bereitgestellt. </p><br></li></ul><br><p>  Ein √§hnliches Problem bei Konstruktoren besteht darin, dass sie spezifisch sind und daher nicht verallgemeinert werden k√∂nnen.  In C ++ kann "es gibt einen Standardkonstruktor" oder "es gibt einen Kopierkonstruktor" nicht einfacher ausgedr√ºckt werden als "bestimmte <em>Syntax</em> funktioniert".  Vergleichen Sie dies mit Rust, wo diese Konzepte geeignete Signaturen haben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  Leben ohne Designer </h1><br><p>  Rust hat nur eine M√∂glichkeit, eine Struktur zu erstellen: Werte f√ºr alle Felder bereitzustellen.  Factory-Funktionen, wie die allgemein akzeptierten neuen, spielen die Rolle von Konstruktoren, aber vor allem k√∂nnen Sie keine Methoden aufrufen, bis Sie mindestens eine mehr oder weniger korrekte Instanz der Struktur haben. </p><br><p>  Der Nachteil dieses Ansatzes besteht darin, dass jeder Code eine Struktur erstellen kann, sodass es keinen einzigen Ort wie einen Konstruktor gibt, an dem Invarianten verwaltet werden k√∂nnen.  In der Praxis l√§sst sich dies leicht durch den Datenschutz l√∂sen: Wenn die Felder der Struktur privat sind, kann diese Struktur nur im selben Modul erstellt werden.  Innerhalb <em>eines</em> Moduls ist es nicht schwierig, die Vereinbarung einzuhalten, dass "alle Methoden zum Erstellen einer Struktur die neue Methode verwenden m√ºssen".  Sie k√∂nnen sich sogar eine Spracherweiterung vorstellen, mit der Sie einige Funktionen mit dem Attribut # [Konstruktor] markieren k√∂nnen, sodass die Strukturliteral-Syntax nur in markierten Funktionen verf√ºgbar ist.  Aber auch hier scheinen mir zus√§tzliche sprachliche Mechanismen √ºberfl√ºssig zu sein: Das Befolgen <strong>lokaler</strong> Konventionen erfordert wenig Aufwand. </p><br><blockquote>  Pers√∂nlich glaube ich, dass dieser Kompromiss f√ºr die Vertragsprogrammierung im Allgemeinen genauso aussieht.  Vertr√§ge wie "nicht null" oder "positiver Wert" werden am besten in Typen codiert.  F√ºr komplexe Invarianten ist es nicht so schwierig, in jeder Methode nur assert! (Self.validate ()) zu schreiben.  Zwischen diesen beiden Mustern ist wenig Platz f√ºr # [vor] und # [nach] Bedingungen, die auf Sprachebene implementiert sind oder auf Makros basieren. </blockquote><br><h1 id="a-chto-naschet-swift">  Was ist mit Swift? </h1><br><p>  Swift ist eine weitere interessante Sprache, die einen Blick auf die Entwurfsmechanismen wert ist.  Swift ist wie Kotlin eine null sichere Sprache.  Im Gegensatz zu Kotlin sind die Nullpr√ºfungen von Swift st√§rker, sodass die Sprache interessante Tricks verwendet, um den durch die Konstruktoren verursachten Schaden zu verringern. </p><br><p>  <em>Erstens</em> verwendet Swift benannte Argumente und hilft ein wenig bei "Alle Konstruktoren haben den gleichen Namen".  Insbesondere zwei Konstruktoren mit denselben Parametertypen sind kein Problem: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Zweitens</em> verwendet Swift zur L√∂sung des Problems "der Konstruktor ruft die virtuelle Methode der Klasse des Objekts auf, die noch nicht vollst√§ndig erstellt wurde" ein gut durchdachtes zweiphasiges Initialisierungsprotokoll.  Obwohl es keine spezielle Syntax f√ºr Initialisierungslisten gibt, √ºberpr√ºft der Compiler statisch, ob der Hauptteil des Konstruktors die richtige und sichere Form hat.  Das Aufrufen von Methoden ist beispielsweise erst m√∂glich, nachdem alle Felder der Klasse und ihrer Nachkommen initialisiert wurden. </p><br><p>  <em>Drittens</em> werden auf Sprachebene Konstruktoren unterst√ºtzt, deren Aufruf m√∂glicherweise fehlschl√§gt.  Der Konstruktor kann als nullwert festgelegt werden, wodurch das Ergebnis des Aufrufs der Klasse eine Option darstellt.  Der Konstruktor kann auch einen Throws-Modifikator haben, der mit der Semantik der zweiphasigen Initialisierung in Swift besser funktioniert als mit der Syntax von Initialisierungslisten in C ++. </p><br><p>  Swift schafft es, alle L√∂cher in den Konstruktoren zu schlie√üen, √ºber die ich mich beschwert habe.  Dies hat jedoch seinen Preis: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungskapitel ist</a> eines der gr√∂√üten im Swift-Buch. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  Wenn Konstruktoren wirklich ben√∂tigt werden </h1><br><p>  Trotz aller Widrigkeiten kann ich mir mindestens zwei Gr√ºnde ausdenken, warum Konstruktoren nicht durch Strukturliterale wie in Rust ersetzt werden k√∂nnen. </p><br><p>  <em>Erstens</em> zwingt die Vererbung die Sprache bis zu dem einen oder anderen Grad dazu, Konstruktoren zu haben.  Sie k√∂nnen sich eine Erweiterung der Syntax von Strukturen mit Unterst√ºtzung f√ºr Basisklassen vorstellen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  Dies funktioniert jedoch nicht in einem typischen Objektlayout einer OO-Sprache mit einfacher Vererbung!  In der Regel beginnt ein Objekt mit einem Titel, gefolgt von Klassenfeldern, von der Basis bis zu den am meisten abgeleiteten.  Somit ist das Pr√§fix des Objekts der abgeleiteten Klasse das richtige Objekt der Basisklasse.  Damit ein solches Layout funktioniert, muss der Designer jedoch Speicher f√ºr das gesamte Objekt gleichzeitig zuweisen.  Es kann nicht nur Speicher nur f√ºr die Basisklasse zuweisen und dann abgeleitete Felder anh√§ngen.  Eine solche Zuordnung des Speichers in Teilen ist jedoch erforderlich, wenn wir die Syntax zum Erstellen einer Struktur verwenden m√∂chten, in der wir einen Wert f√ºr die Basisklasse angeben k√∂nnen. </p><br><p>  <em>Zweitens</em> verf√ºgen Designer im Gegensatz zur Strukturliteral-Syntax √ºber einen ABI, der sich gut zum Platzieren von Objektunterobjekten im Speicher eignet (platzierungsfreundlicher ABI).  Der Konstruktor arbeitet mit einem Zeiger darauf, der auf den Speicherbereich zeigt, den das neue Objekt belegen soll.  Am wichtigsten ist, dass ein Konstruktor leicht einen Zeiger an Unterobjektkonstruktoren √ºbergeben kann, wodurch die Erstellung komplexer Werteb√§ume "an Ort und Stelle" erm√∂glicht wird.  Im Gegensatz dazu enth√§lt das Konstruieren von Strukturen in Rust semantisch einige Kopien, und hier hoffen wir auf die Gnade des Optimierers.  Es ist kein Zufall, dass Rust noch keinen akzeptierten Arbeitsvorschlag zur Platzierung von Unterobjekten im Speicher hat! </p><br><p>  Update 1: Tippfehler behoben.  Das "Schreibliteral" wurde durch "Strukturliteral" ersetzt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460831/">https://habr.com/ru/post/de460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460819/index.html">WorldSkills: R√ºckblick vom Teilnehmer der Olympiade</a></li>
<li><a href="../de460821/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 307 (15. - 21. Juli)</a></li>
<li><a href="../de460823/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. Juli</a></li>
<li><a href="../de460825/index.html">Einf√ºhrung in die Screen Capture API - Scannen Sie QR-Codes in einem Browser</a></li>
<li><a href="../de460827/index.html">PGP-Problem</a></li>
<li><a href="../de460833/index.html">Physik und Wirtschaft. Gnoseologischer Unterschied und seine Manifestation in der IT</a></li>
<li><a href="../de460837/index.html">Podcast-Handbuch f√ºr Anf√§nger</a></li>
<li><a href="../de460839/index.html">Starten Sie Predator - Precompiled Data Repositories</a></li>
<li><a href="../de460841/index.html">TOP-23 Sprachlern-Apps</a></li>
<li><a href="../de460843/index.html">Einf√ºhrung in den neuen 3CX Call Flow Designer und den 3CX CRM Template Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>