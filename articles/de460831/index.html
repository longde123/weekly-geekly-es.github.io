<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 📁 👩🏾‍🤝‍👩🏼 Die Gefahren von Designern 🕸️ 👠 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Perils of Constructors" von Aleksey Kladov. 


 Einer meiner Lieblings-Rust-Blog-Beitr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Gefahren von Designern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460831/"><p>  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels "Perils of Constructors" von Aleksey Kladov. </p><br><p>  Einer meiner Lieblings-Rust-Blog-Beiträge ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Things Rust Shipped Without von Graydon Hoare</a> .  Für mich ist das Fehlen jeglicher Merkmale in der Sprache, die ins Bein schießen können, normalerweise wichtiger als Ausdruckskraft.  In diesem leicht philosophischen Aufsatz möchte ich über mein besonders beliebtes Feature sprechen, das in Rust fehlt - über Konstruktoren. </p><br><h1 id="chto-takoe-konstruktor">  Was ist ein Konstruktor? </h1><br><p>  Konstruktoren werden üblicherweise in OO-Sprachen verwendet.  Die Aufgabe des Konstruktors besteht darin, das Objekt vollständig zu initialisieren, bevor der Rest der Welt es sieht.  Auf den ersten Blick scheint dies eine wirklich gute Idee zu sein: </p><br><ol><li>  Sie <strong>legen die Invarianten</strong> im Konstruktor fest. </li><li>  Jede Methode kümmert sich um die <strong>Erhaltung von</strong> Invarianten. </li><li>  Zusammen bedeuten diese beiden Eigenschaften, dass Sie Objekte als Invarianten und nicht als spezifische interne Zustände betrachten können. </li></ol><br><p>  Der Konstruktor spielt hier die Rolle einer Induktionsbasis und ist die einzige Möglichkeit, ein neues Objekt zu erstellen. </p><br><p>  Leider gibt es eine Lücke in diesen Argumenten: Der Designer selbst beobachtet das Objekt in einem unfertigen Zustand, was viele Probleme verursacht. <a name="habracut"></a></p><br><h1 id="znachenie-this">  Dieser Wert </h1><br><p>  Wenn der Konstruktor das Objekt initialisiert, beginnt es mit einem leeren Zustand.  Aber wie definieren Sie diesen leeren Zustand für ein beliebiges Objekt? </p><br><p>  Der einfachste Weg, dies zu tun, besteht darin, alle Felder auf ihre Standardwerte zu setzen: false für bool, 0 für Zahlen, null für alle Links.  Dieser Ansatz erfordert jedoch, dass alle Typen Standardwerte haben, und führt die berüchtigte Null in die Sprache ein.  Dies ist der Pfad, den Java eingeschlagen hat: Zu Beginn der Erstellung des Objekts sind alle Felder 0 oder null. </p><br><p>  Mit diesem Ansatz wird es sehr schwierig sein, null danach loszuwerden.  Ein gutes Beispiel zum Lernen ist Kotlin.  Kotlin verwendet standardmäßig nicht nullfähige Typen, muss jedoch mit bereits vorhandener JVM-Semantik arbeiten.  Das Design der Sprache verbirgt diese Tatsache gut und ist in der Praxis gut anwendbar, aber <strong>unhaltbar</strong> .  Mit anderen Worten, mit Konstruktoren ist es möglich, Nullprüfungen in Kotlin zu umgehen. </p><br><p>  Das Hauptmerkmal von Kotlin ist die Ermutigung, sogenannte "Primärkonstruktoren" zu erstellen, die <strong>sowohl</strong> ein Feld deklarieren als auch ihm einen Wert zuweisen, bevor benutzerdefinierter Code ausgeführt wird: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Eine weitere Option: Wenn das Feld im Konstruktor nicht deklariert ist, sollte der Programmierer es sofort initialisieren: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Der Versuch, ein Feld vor der Initialisierung zu verwenden, wird statisch abgelehnt: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  Aber mit ein bisschen Kreativität kann jeder diese Schecks umgehen.  Hierzu eignet sich beispielsweise ein Methodenaufruf: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Auch dies mit einem Lambda (das in Kotlin wie folgt erstellt wird: {args -&gt; body}) zu greifen, ist ebenfalls geeignet: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Beispiele wie diese scheinen in der Realität unrealistisch zu sein (und das ist es auch), aber ich habe ähnliche Fehler im realen Code gefunden (Kolmogorovs Wahrscheinlichkeitsregel 0-1 in der Softwareentwicklung: In einer ausreichend großen Datenbank ist fast garantiert, dass jeder Code existiert, zumindest wenn nicht statisch vom Compiler verboten (in diesem Fall existiert es mit ziemlicher Sicherheit nicht). </p><br><p>  Der Grund, warum Kotlin bei diesem Fehler möglicherweise vorhanden ist, ist der gleiche wie bei kovarianten Java-Arrays: Zur Laufzeit werden weiterhin Überprüfungen durchgeführt.  Am Ende möchte ich das Kotlin-Typ-System nicht komplizieren, um die oben genannten Fälle in der Kompilierungsphase falsch zu machen: Angesichts der bestehenden Einschränkungen (JVM-Semantik) ist das Preis-Leistungs-Verhältnis von Validierungen zur Laufzeit viel besser als das von statischen. </p><br><p>  Was aber, wenn die Sprache nicht für jeden Typ einen angemessenen Standardwert hat?  In C ++, wo benutzerdefinierte Typen nicht unbedingt Referenzen sind, können Sie beispielsweise nicht einfach jedem Feld null zuweisen und sagen, dass dies funktioniert!  Stattdessen verwendet C ++ eine spezielle Syntax, um Anfangswerte für Felder festzulegen: Initialisierungslisten: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Da dies eine spezielle Syntax ist, funktioniert der Rest der Sprache nicht einwandfrei.  Zum Beispiel ist es schwierig, beliebige Operationen in die Initialisierungslisten aufzunehmen, da C ++ keine ausdrucksorientierte Sprache ist (was an sich normal ist).  Um mit Ausnahmen zu arbeiten, die in Initialisierungslisten auftreten, müssen Sie eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">undurchsichtige Funktion der Sprache verwenden</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  Methoden aus dem Konstruktor aufrufen </h1><br><p>  Wie die Beispiele von Kotlin andeuten, zerbricht alles in Chips, sobald wir versuchen, eine Methode vom Konstruktor aufzurufen.  Grundsätzlich erwarten Methoden, dass das dadurch zugängliche Objekt bereits vollständig konstruiert und korrekt ist (im Einklang mit Invarianten).  In Kotlin oder Java hindert Sie nichts daran, Methoden vom Konstruktor aufzurufen, und auf diese Weise können wir versehentlich ein halbkonstruiertes Objekt bearbeiten.  Der Designer verspricht, Invarianten zu etablieren, aber gleichzeitig ist dies der einfachste Ort für ihre mögliche Verletzung. </p><br><p>  Besonders seltsame Dinge passieren, wenn der Basisklassenkonstruktor eine in einer abgeleiteten Klasse überschriebene Methode aufruft: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Denken Sie nur einmal darüber nach: Der Code einer beliebigen Klasse wird ausgeführt, <strong>bevor</strong> der Konstruktor aufgerufen wird!  Ähnlicher C ++ - Code führt zu noch interessanteren Ergebnissen.  Anstatt die Funktion der abgeleiteten Klasse aufzurufen, wird die Funktion der Basisklasse aufgerufen.  Dies ist wenig sinnvoll, da die abgeleitete Klasse noch nicht initialisiert wurde (denken Sie daran, wir können nicht einfach sagen, dass alle Felder null sind).  Wenn die Funktion in der Basisklasse jedoch rein virtuell ist, führt ihr Aufruf zu UB. </p><br><h1 id="signatura-konstruktora">  Designer-Unterschrift </h1><br><p>  Die Verletzung von Invarianten ist nicht das einzige Problem für Designer.  Sie haben eine Signatur mit einem festen Namen (leer) und einen Rückgabetyp (die Klasse selbst).  Dies macht es für Menschen schwierig, Designüberladungen zu verstehen. </p><br><blockquote>  Backfill-Frage: Was entspricht std :: vector &lt;int&gt; xs (92, 2)? <br><br>  a.  Vektor von zwei Längen 92 <br><br>  b.  [92, 92] <br><br>  c.  [92, 2] </blockquote><p>  Probleme mit dem Rückgabewert treten in der Regel auf, wenn ein Objekt nicht erstellt werden kann.  Sie können nicht einfach das Ergebnis &lt;MyClass, io :: Error&gt; oder null vom Konstruktor zurückgeben! </p><br><p>  Dies wird häufig als Argument dafür verwendet, dass die Verwendung von C ++ ohne Ausnahmen schwierig ist und dass die Verwendung von Konstruktoren Sie auch zur Verwendung von Ausnahmen zwingt.  Ich halte dieses Argument jedoch nicht für richtig: Factory-Methoden lösen beide Probleme, da sie beliebige Namen haben und beliebige Typen zurückgeben können.  Ich glaube, dass das folgende Muster in OO-Sprachen manchmal nützlich sein kann: </p><br><ul><li><p>  Erstellen Sie einen <strong>privaten</strong> Konstruktor, der die Werte aller Felder als Argumente verwendet und sie einfach zuweist.  Ein solcher Konstruktor würde also als Strukturliteral in Rust arbeiten.  Es kann auch nach Invarianten suchen, sollte aber nichts anderes mit Argumenten oder Feldern tun. </p><br></li><li><p>  Für die öffentliche API werden öffentliche Factory-Methoden mit entsprechenden Namen und Rückgabetypen bereitgestellt. </p><br></li></ul><br><p>  Ein ähnliches Problem bei Konstruktoren besteht darin, dass sie spezifisch sind und daher nicht verallgemeinert werden können.  In C ++ kann "es gibt einen Standardkonstruktor" oder "es gibt einen Kopierkonstruktor" nicht einfacher ausgedrückt werden als "bestimmte <em>Syntax</em> funktioniert".  Vergleichen Sie dies mit Rust, wo diese Konzepte geeignete Signaturen haben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  Leben ohne Designer </h1><br><p>  Rust hat nur eine Möglichkeit, eine Struktur zu erstellen: Werte für alle Felder bereitzustellen.  Factory-Funktionen, wie die allgemein akzeptierten neuen, spielen die Rolle von Konstruktoren, aber vor allem können Sie keine Methoden aufrufen, bis Sie mindestens eine mehr oder weniger korrekte Instanz der Struktur haben. </p><br><p>  Der Nachteil dieses Ansatzes besteht darin, dass jeder Code eine Struktur erstellen kann, sodass es keinen einzigen Ort wie einen Konstruktor gibt, an dem Invarianten verwaltet werden können.  In der Praxis lässt sich dies leicht durch den Datenschutz lösen: Wenn die Felder der Struktur privat sind, kann diese Struktur nur im selben Modul erstellt werden.  Innerhalb <em>eines</em> Moduls ist es nicht schwierig, die Vereinbarung einzuhalten, dass "alle Methoden zum Erstellen einer Struktur die neue Methode verwenden müssen".  Sie können sich sogar eine Spracherweiterung vorstellen, mit der Sie einige Funktionen mit dem Attribut # [Konstruktor] markieren können, sodass die Strukturliteral-Syntax nur in markierten Funktionen verfügbar ist.  Aber auch hier scheinen mir zusätzliche sprachliche Mechanismen überflüssig zu sein: Das Befolgen <strong>lokaler</strong> Konventionen erfordert wenig Aufwand. </p><br><blockquote>  Persönlich glaube ich, dass dieser Kompromiss für die Vertragsprogrammierung im Allgemeinen genauso aussieht.  Verträge wie "nicht null" oder "positiver Wert" werden am besten in Typen codiert.  Für komplexe Invarianten ist es nicht so schwierig, in jeder Methode nur assert! (Self.validate ()) zu schreiben.  Zwischen diesen beiden Mustern ist wenig Platz für # [vor] und # [nach] Bedingungen, die auf Sprachebene implementiert sind oder auf Makros basieren. </blockquote><br><h1 id="a-chto-naschet-swift">  Was ist mit Swift? </h1><br><p>  Swift ist eine weitere interessante Sprache, die einen Blick auf die Entwurfsmechanismen wert ist.  Swift ist wie Kotlin eine null sichere Sprache.  Im Gegensatz zu Kotlin sind die Nullprüfungen von Swift stärker, sodass die Sprache interessante Tricks verwendet, um den durch die Konstruktoren verursachten Schaden zu verringern. </p><br><p>  <em>Erstens</em> verwendet Swift benannte Argumente und hilft ein wenig bei "Alle Konstruktoren haben den gleichen Namen".  Insbesondere zwei Konstruktoren mit denselben Parametertypen sind kein Problem: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Zweitens</em> verwendet Swift zur Lösung des Problems "der Konstruktor ruft die virtuelle Methode der Klasse des Objekts auf, die noch nicht vollständig erstellt wurde" ein gut durchdachtes zweiphasiges Initialisierungsprotokoll.  Obwohl es keine spezielle Syntax für Initialisierungslisten gibt, überprüft der Compiler statisch, ob der Hauptteil des Konstruktors die richtige und sichere Form hat.  Das Aufrufen von Methoden ist beispielsweise erst möglich, nachdem alle Felder der Klasse und ihrer Nachkommen initialisiert wurden. </p><br><p>  <em>Drittens</em> werden auf Sprachebene Konstruktoren unterstützt, deren Aufruf möglicherweise fehlschlägt.  Der Konstruktor kann als nullwert festgelegt werden, wodurch das Ergebnis des Aufrufs der Klasse eine Option darstellt.  Der Konstruktor kann auch einen Throws-Modifikator haben, der mit der Semantik der zweiphasigen Initialisierung in Swift besser funktioniert als mit der Syntax von Initialisierungslisten in C ++. </p><br><p>  Swift schafft es, alle Löcher in den Konstruktoren zu schließen, über die ich mich beschwert habe.  Dies hat jedoch seinen Preis: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungskapitel ist</a> eines der größten im Swift-Buch. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  Wenn Konstruktoren wirklich benötigt werden </h1><br><p>  Trotz aller Widrigkeiten kann ich mir mindestens zwei Gründe ausdenken, warum Konstruktoren nicht durch Strukturliterale wie in Rust ersetzt werden können. </p><br><p>  <em>Erstens</em> zwingt die Vererbung die Sprache bis zu dem einen oder anderen Grad dazu, Konstruktoren zu haben.  Sie können sich eine Erweiterung der Syntax von Strukturen mit Unterstützung für Basisklassen vorstellen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  Dies funktioniert jedoch nicht in einem typischen Objektlayout einer OO-Sprache mit einfacher Vererbung!  In der Regel beginnt ein Objekt mit einem Titel, gefolgt von Klassenfeldern, von der Basis bis zu den am meisten abgeleiteten.  Somit ist das Präfix des Objekts der abgeleiteten Klasse das richtige Objekt der Basisklasse.  Damit ein solches Layout funktioniert, muss der Designer jedoch Speicher für das gesamte Objekt gleichzeitig zuweisen.  Es kann nicht nur Speicher nur für die Basisklasse zuweisen und dann abgeleitete Felder anhängen.  Eine solche Zuordnung des Speichers in Teilen ist jedoch erforderlich, wenn wir die Syntax zum Erstellen einer Struktur verwenden möchten, in der wir einen Wert für die Basisklasse angeben können. </p><br><p>  <em>Zweitens</em> verfügen Designer im Gegensatz zur Strukturliteral-Syntax über einen ABI, der sich gut zum Platzieren von Objektunterobjekten im Speicher eignet (platzierungsfreundlicher ABI).  Der Konstruktor arbeitet mit einem Zeiger darauf, der auf den Speicherbereich zeigt, den das neue Objekt belegen soll.  Am wichtigsten ist, dass ein Konstruktor leicht einen Zeiger an Unterobjektkonstruktoren übergeben kann, wodurch die Erstellung komplexer Wertebäume "an Ort und Stelle" ermöglicht wird.  Im Gegensatz dazu enthält das Konstruieren von Strukturen in Rust semantisch einige Kopien, und hier hoffen wir auf die Gnade des Optimierers.  Es ist kein Zufall, dass Rust noch keinen akzeptierten Arbeitsvorschlag zur Platzierung von Unterobjekten im Speicher hat! </p><br><p>  Update 1: Tippfehler behoben.  Das "Schreibliteral" wurde durch "Strukturliteral" ersetzt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460831/">https://habr.com/ru/post/de460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460819/index.html">WorldSkills: Rückblick vom Teilnehmer der Olympiade</a></li>
<li><a href="../de460821/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 307 (15. - 21. Juli)</a></li>
<li><a href="../de460823/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. Juli</a></li>
<li><a href="../de460825/index.html">Einführung in die Screen Capture API - Scannen Sie QR-Codes in einem Browser</a></li>
<li><a href="../de460827/index.html">PGP-Problem</a></li>
<li><a href="../de460833/index.html">Physik und Wirtschaft. Gnoseologischer Unterschied und seine Manifestation in der IT</a></li>
<li><a href="../de460837/index.html">Podcast-Handbuch für Anfänger</a></li>
<li><a href="../de460839/index.html">Starten Sie Predator - Precompiled Data Repositories</a></li>
<li><a href="../de460841/index.html">TOP-23 Sprachlern-Apps</a></li>
<li><a href="../de460843/index.html">Einführung in den neuen 3CX Call Flow Designer und den 3CX CRM Template Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>