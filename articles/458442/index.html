<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèΩ ‚ú≥Ô∏è ‚è≤Ô∏è ¬øPor qu√© LLVM puede llamar a una funci√≥n nunca llamada? üç± üï¥Ô∏è üéÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No me importa lo que haya dicho tu drag√≥n, es mentira. Los dragones mienten. No sabes lo que te espera del otro lado. 

 Michael Swanwick, la hija del...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© LLVM puede llamar a una funci√≥n nunca llamada?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458442/"><blockquote>  <i>No me importa lo que haya dicho tu drag√≥n, es mentira.</i>  <i>Los dragones mienten.</i>  <i>No sabes lo que te espera del otro lado.</i> <br><br>  Michael Swanwick, la hija del drag√≥n de hierro </blockquote>  Este art√≠culo se basa en la publicaci√≥n en el blog de Krister Walfridsson, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"¬øPor qu√© el comportamiento indefinido puede llamar a una funci√≥n que nunca se llama?"</a>  . <br><br>  El art√≠culo saca una conclusi√≥n simple: el comportamiento indefinido en un compilador puede hacer cualquier cosa, incluso algo absolutamente inesperado.  En este art√≠culo, examino el mecanismo interno de este trabajo de optimizaci√≥n. <br><a name="habracut"></a><br>  Para resumir brevemente la publicaci√≥n de Waldfridsson, en el c√≥digo fuente a continuaci√≥n, la funci√≥n EraseAll no debe llamarse desde main, y realmente no se llama cuando se compila con -O0, pero de repente se llama con optimizaci√≥n -O1 y superior. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system(‚Äúrm -rf /‚Äù); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  ¬øC√≥mo lo optimiza un compilador?  Al principio, Do, el puntero a una funci√≥n es nulo, porque, de acuerdo con el est√°ndar C, todas las variables globales tienen valores cero cuando se inicia un programa. <br><br><img src="https://habrastorage.org/webt/5i/k5/s0/5ik5s0xohytqkbqnw2exo1on1jc.jpeg"><br><br>  El programa intentar√° desreferenciar el puntero Do y llamar a la funci√≥n asignada.  Pero si tratamos de desreferenciar un puntero nulo, el est√°ndar dice que es UB, comportamiento indefinido.  Por lo general, si compilamos sin optimizaciones, con la opci√≥n -O0, obtenemos una falla de segmentaci√≥n (en Linux).  Pero el Est√°ndar dice que en el caso de UB, un programa puede hacer cualquier cosa. <br><br><img src="https://habrastorage.org/webt/ez/mq/bc/ezmqbco46shm4fqad2pbjyfhygw.jpeg"><br><br>  Un compilador utiliza esta caracter√≠stica del est√°ndar para eliminar operaciones innecesarias.  Si un compilador ve que Do est√° asignado en cualquier parte del programa, puede asignar este valor en el tiempo de inicializaci√≥n y no asignarlo en tiempo de ejecuci√≥n.  En realidad, hay dos posibilidades: <br><br>  1. si un puntero se desreferencia despu√©s de que se debe asignar, ganamos, porque un compilador puede eliminar una asignaci√≥n innecesaria. <br><br>  2. si un puntero se desreferencia antes de que deba asignarse, el est√°ndar dice que es UB, y el comportamiento puede ser cualquiera, incluida la llamada a una funci√≥n arbitraria.  Es decir, llamar a la funci√≥n PrintHello () no contradice el est√°ndar. <br><br>  Es decir, en cualquier caso, podemos asignar alg√∫n valor no nulo a un puntero no inicializado y obtener un comportamiento, de acuerdo con el est√°ndar. <br><br><img src="https://habrastorage.org/webt/se/th/yx/sethyxxeoe2wjcy941i8nxzj4gm.jpeg"><br><br>  ¬øCu√°les son las condiciones que hacen posible esta optimizaci√≥n?  Inicialmente, un programa debe contener un puntero global sin ning√∫n valor inicial o con un valor nulo (que es lo mismo).  A continuaci√≥n, el programa debe contener una asignaci√≥n de un valor para este puntero, en cualquier lugar, sin importar, antes de que el puntero se desreferencia o despu√©s.  En el ejemplo anterior, no se ha producido una asignaci√≥n, pero un compilador ve que la asignaci√≥n existe. <br><br>  Si se cumplen estas condiciones, un compilador puede eliminar la asignaci√≥n y cambiarla al valor inicial del puntero. <br><br>  En el c√≥digo dado, la variable Do es un puntero a una funci√≥n y tiene el valor inicial nulo.  Cuando intentamos llamar a una funci√≥n en el puntero nulo, el comportamiento del programa es indefinido (comportamiento indefinido, UB) y el compilador tiene derecho a optimizar el UB como lo desee.  En este caso, el compilador ejecut√≥ inmediatamente la asignaci√≥n Do = EraseAll. <br><br>  ¬øPor qu√© sucede esto?  En el resto del texto, LLVM y Clang versi√≥n 5.0.0 se utilizan como compilador.  Los ejemplos de c√≥digo son ejecutables para que pueda practicar usted mismo. <br><br>  Para empezar, echemos un vistazo al c√≥digo IR al optimizar con -O0 y -O1.  Cambiemos ligeramente el c√≥digo fuente para hacerlo menos dram√°tico: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Y compilamos el c√≥digo IR con -O0 (la informaci√≥n de depuraci√≥n se omite para mayor claridad): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span> And with -O1: ; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Si compila los ejecutables, confirmar√° que en el primer caso, se produce un error de segmentaci√≥n, y en el segundo caso, se muestra "hello world".  Con otras opciones de optimizaci√≥n, el resultado es el mismo que para -O1. <br><br>  Ahora encuentre la parte del c√≥digo del compilador que realiza esta optimizaci√≥n.  La arquitectura de LLVM el frontend no se ocupa de las optimizaciones en s√≠ misma, es decir, cfe (Clang Frontend) siempre genera el c√≥digo sin optimizaciones, que vemos en la versi√≥n para -O0, y todas las optimizaciones son realizadas por la utilidad opt: <br><br><img src="https://habrastorage.org/webt/1o/c9/vt/1oc9vtkgl4qt2yxundzkjso_u0w.jpeg"><br><br>  Con -O1, se realizan 186 pases de optimizaci√≥n. <br><br>  Desactivando los pases uno tras otro, encontramos lo que estamos buscando: el pase <i>globalopt</i> .  Solo podemos dejar este pase de optimizaci√≥n y asegurarnos de que, y nadie m√°s, genere el c√≥digo que necesitamos.  La fuente est√° en el archivo /lib/Transforms/IPO/GlobalOpt.cpp.  Puede ver el c√≥digo fuente en el repositorio LLVM.  Por brevedad, solo he proporcionado funciones importantes para comprender c√≥mo funciona. <br><br><img src="https://habrastorage.org/webt/4k/-g/nl/4k-gnlzr7e6573zeobjdcp91x5q.jpeg"><br><br>  Esta imagen representa una estructura de la representaci√≥n IR.  Un c√≥digo en la representaci√≥n LLVM IR tiene niveles jer√°rquicos: un m√≥dulo representa el nivel m√°s alto de una jerarqu√≠a e incluye todas las funciones y objetos globales, como las variables globales.  Una funci√≥n es el nivel m√°s importante de representaci√≥n IR y la mayor√≠a de los pases funcionan en este nivel.  Un bloque b√°sico es uno de los conceptos m√°s importantes de una teor√≠a de compilaci√≥n.  Un bloque b√°sico consta de instrucciones, que no pueden realizar saltos desde la mitad de un bloque b√°sico o dentro de un bloque b√°sico.  Todas las transiciones entre el bloque b√°sico son posibles solo desde el final de un bloque b√°sico y hasta el comienzo de un bloque b√°sico, y nunca es posible ning√∫n salto desde o hacia la mitad de un bloque b√°sico.  Un nivel de instrucci√≥n representa una instrucci√≥n de c√≥digo IR LLVM.  No es una instrucci√≥n de procesador, es una instrucci√≥n de una m√°quina virtual muy generalizada con un n√∫mero infinito de registros. <br><br><img src="https://habrastorage.org/webt/6y/dt/wn/6ydtwn5hajletngggvj27uzurls.png"><br><br>  Esta imagen muestra una jerarqu√≠a de pases LLVM.  A la izquierda se muestran los pases que funcionan con el c√≥digo LLVM IR, en el lado derecho se muestran pases que funcionan con las instrucciones del objetivo. <br><br>  Inicialmente, implementa el m√©todo runOnModule, es decir, cuando trabaja, ve y optimiza todo el m√≥dulo (que, por supuesto, es razonable en este caso).  La funci√≥n que realiza la optimizaci√≥n es optimizarGlobalsInModule: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comdat=<span class="hljs-string"><span class="hljs-string">"Comdat"</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Tratemos de describir con palabras lo que hace esta funci√≥n.  Para cada variable global en el m√≥dulo, solicita un objeto Comdat. <br><br>  ¬øQu√© es un objeto Comdat? <br><br>  Una secci√≥n de Comdat es una secci√≥n en el archivo de objetos, en la que se colocan los objetos, que se pueden duplicar en otros archivos de objetos.  Cada objeto tiene informaci√≥n para el enlazador, que indica lo que debe hacer cuando se detectan duplicados.  Las opciones pueden ser: Cualquiera - hacer cualquier cosa, ExactMatch - los duplicados deben coincidir completamente, de lo contrario se produce un error, Mayor - tomar el objeto con el valor m√°s grande, NoDublicates - no debe haber un duplicado, SameSize - los duplicados deben tener el mismo tama√±o, de lo contrario se produce un error. <br><br>  En LLVM, los datos de Comdat se representan mediante una enumeraci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  y la clase Comdat en realidad representa un par (Name, SelectionKind).  (De hecho, todo es m√°s complicado). Todas las variables que por alguna raz√≥n no se pueden eliminar se colocan en un conjunto de NotDiscardableComdats.  Con funciones y alias globales, hacemos lo mismo: algo que no se puede eliminar se coloca en NotDiscardableComdats.  Luego, se llaman funciones de optimizaci√≥n separadas para constructores globales, funciones globales, variables globales, alias globales y destructores globales.  Las optimizaciones contin√∫an en el ciclo hasta que no se realiza ninguna optimizaci√≥n.  En cada iteraci√≥n del bucle, el conjunto de NotDiscardableComdats se establece en cero. <br><br>  Veamos qu√© objetos de la lista contiene nuestra fuente de prueba. <br><br>  Variables globales: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (un poco mirando hacia el futuro, puedo decir que la primera variable ser√° eliminada por el optimizador en la primera iteraci√≥n). <br>  Funciones: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Tenga en cuenta que printf solo se declara, pero no se define. <br><br>  No hay alias globales. <br><br>  Veamos el ejemplo de este pase de optimizaci√≥n y consideremos c√≥mo result√≥ este resultado.  Por supuesto, analizar todas las opciones de optimizaci√≥n, incluso en una sola pasada, es una tarea muy grande, porque involucra muchos casos especiales diferentes de optimizaciones.  Nos concentraremos en nuestro ejemplo, considerando aquellas funciones y estructuras de datos que son importantes para comprender el trabajo de este pase de optimizaci√≥n. <br><br>  Inicialmente, el optimizador realiza varias comprobaciones poco interesantes en este caso y llama a la funci√≥n processInternalGlobal, que intenta optimizar las variables globales.  Esta funci√≥n tambi√©n es bastante compleja y hace muchas cosas diferentes, pero nos interesa una cosa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">// We are trying to optimize global variables, about which it is known that they are assigned a value only once, except the initializing value. if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  La informaci√≥n de que a la variable global se le asigna el valor uno y solo una vez se extrae de la estructura GS (GlobalStatus).  Esta estructura se completa en la funci√≥n de llamada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Aqu√≠ vemos un hecho m√°s interesante: los objetos cuyos nombres comienzan con "llvm".  no est√°n sujetos a optimizaci√≥n (ya que son llamadas del sistema para llvm runtime).  Y, por si acaso, los nombres de las variables en LLVM IR pueden contener puntos (e incluso constar de un punto con el prefijo @ o%).  La funci√≥n analyGlobal es una llamada a la API LLVM y no consideraremos su trabajo interno.  La estructura de GlobalStatus debe verse en detalle ya que contiene informaci√≥n muy importante para los pases de optimizaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// As we analyze each global, keep track of some information about it. If we /// find out that the address of the global is taken, none of this info will be /// accurate. struct GlobalStatus { /// True if the global's address is used in a comparison. bool IsCompared = false; /// True if the global is ever loaded. If the global isn't ever loaded it /// can be deleted. bool IsLoaded = false; /// Keep track of what stores to the global look like. enum StoredType { /// There is no store to this global. It can thus be marked constant. NotStored, /// This global is stored to, but the only thing stored is the constant it /// was initialized with. This is only tracked for scalar globals. InitializerStored, /// This global is stored to, but only its initializer and one other value /// is ever stored to it. If this global isStoredOnce, we track the value /// stored to it in StoredOnceValue below. This is only tracked for scalar /// globals. StoredOnce, /// This global is stored to by multiple values or something else that we /// cannot track. Stored } StoredType = NotStored; /// If only one value (besides the initializer constant) is ever stored to /// this global, keep track of what value it is. Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  Vale la pena explicar por qu√© "Si descubrimos que se toma la direcci√≥n de lo global, nada de esta informaci√≥n ser√° precisa".  De hecho, si tomamos la direcci√≥n de una variable global, y luego escribimos algo en esta direcci√≥n, no por nombre, ser√° extremadamente dif√≠cil rastrear esto, y es mejor dejar las variables como est√°n, sin tratar de optimizar . <br><br>  Entonces, ingresamos a la funci√≥n optimiceOnceStoredGlobal, a la cual se pasan la variable (GV) y el valor almacenado (StoredOnceVal).  Aqu√≠ est√°n: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// the variable i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // the value</span></span></code> </pre> <br>  A continuaci√≥n, para el valor, se elimina el bitcast insignificante y para la variable se verifica la siguiente condici√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  es decir, la variable debe inicializarse con un puntero nulo.  Si este es el caso, creamos una nueva variable SOVC correspondiente al valor de StoredOnceVal emitido al tipo GV: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Aqu√≠, getBitCast es el m√©todo que devuelve el comando bitcast, que escribe los tipos en el lenguaje LLVM IR. <br><br>  Despu√©s de eso, se llama a la funci√≥n OptimizeAwayTrappingUsesOfLoads.  Transfiere la variable global GV y la constante LV. <br><br>  La optimizaci√≥n directa se realiza mediante la funci√≥n OptimizeAwayTrappingUsesOfValue (Value * V, Constant * NewV). <br><br>  Para cada uso de una variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;instruction&gt;(*UI++);</code> </pre> <br>  Si se trata de un comando Cargar, reemplace su operando con un nuevo valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;loadinst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Si la variable se usa en la funci√≥n invocar o invocar (que es exactamente lo que sucede en nuestro ejemplo), cree una nueva funci√≥n, reemplazando su argumento con un nuevo valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;callinst&gt;(I) || isa&lt;invokeinst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  Todos los dem√°s argumentos de la funci√≥n simplemente se copian. <br><br>  Adem√°s, se proporcionan algoritmos de reemplazo similares para las instrucciones Cast y GEP, pero en nuestro caso esto no sucede. <br><br>  Las acciones adicionales son las siguientes: examinamos todos los usos de una variable global, tratando de eliminar todo, excepto la asignaci√≥n de valor.  Si esto es exitoso, entonces podemos eliminar la variable Do. <br><br>  Entonces, revisamos brevemente el trabajo del paso de optimizaci√≥n LLVM en un ejemplo espec√≠fico.  En principio, aqu√≠ no hay nada s√∫per complicado, pero se requiere una programaci√≥n m√°s cuidadosa para proporcionar todas las combinaciones posibles de comandos y tipos de variables.  Por supuesto, todo esto debe ser cubierto por pruebas.  Aprender el c√≥digo fuente de los optimizadores LLVM lo ayudar√° a escribir sus optimizaciones, permiti√©ndole mejorar el c√≥digo para algunos casos espec√≠ficos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458442/">https://habr.com/ru/post/458442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458424/index.html">Drone Show: mirada interior</a></li>
<li><a href="../458428/index.html">Google abre el c√≥digo fuente del analizador robots.txt</a></li>
<li><a href="../458434/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 11. Conceptos b√°sicos de VLAN</a></li>
<li><a href="../458436/index.html">Errores de registro comunes</a></li>
<li><a href="../458440/index.html">Soporte t√©cnico de lunes a viernes: historias sobre lo que sucede cuando no puede comunicarse con el usuario</a></li>
<li><a href="../458444/index.html">Internet para el residente de verano. Parte 4. Una tarjeta SIM es suficiente</a></li>
<li><a href="../458450/index.html">Caracter√≠sticas de las computadoras cu√°nticas.</a></li>
<li><a href="../458452/index.html">C√≥mo hacer una cocina de oficina a trav√©s de un enfoque de supermercado</a></li>
<li><a href="../458454/index.html">Alexey Savvateev: Modelos de Internet y redes sociales.</a></li>
<li><a href="../458458/index.html">C√°maras de profundidad: revoluci√≥n silenciosa (cuando los robots lo ver√°n) Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>