<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 👨🏽 👨🏾‍🎓 Überprüfen des Roslyn-Quellcodes 💇🏿 🍈 🤘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hin und wieder kehren wir zu den Projekten zurück, die wir zuvor mit PVS-Studio überprüft haben, was zu deren Beschreibung in verschiedenen Artikeln f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Überprüfen des Roslyn-Quellcodes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio gegen Roslyn"></div><br>  Hin und wieder kehren wir zu den Projekten zurück, die wir zuvor mit PVS-Studio überprüft haben, was zu deren Beschreibung in verschiedenen Artikeln führt.  Zwei Gründe machen diese Comebacks für uns spannend.  Erstens die Möglichkeit, den Fortschritt unseres Analysegeräts zu bewerten.  Zweitens die Überwachung des Feedbacks der Projektautoren zu unserem Artikel und des Fehlerberichts, den wir ihnen normalerweise zur Verfügung stellen.  Natürlich können Fehler ohne unsere Teilnahme korrigiert werden.  Es ist jedoch immer schön, wenn unsere Bemühungen dazu beitragen, ein Projekt besser zu machen.  Roslyn war keine Ausnahme.  Der vorherige Artikel über diese Projektprüfung stammt aus dem 23. Dezember 2015. Angesichts der Fortschritte, die unser Analysegerät seitdem erzielt hat, ist dies eine ziemlich lange Zeit.  Da der C # -Kern des PVS-Studio-Analysators auf Roslyn basiert, gibt es uns zusätzliches Interesse an diesem Projekt.  Aus diesem Grund sind wir von der Codequalität dieses Projekts begeistert.  Lassen Sie es uns jetzt noch einmal testen und einige neue und interessante Probleme herausfinden (aber hoffen wir, dass nichts Bedeutendes ist), die PVS-Studio finden kann. <br><a name="habracut"></a><br>  Viele unserer Leser kennen Roslyn (oder die .NET Compiler-Plattform) wahrscheinlich gut.  Kurz gesagt, es handelt sich um eine Reihe von Open Source-Compilern und eine API für die Code-Analyse von C # - und Visual Basic .NET-Sprachen von Microsoft.  Der Quellcode des Projekts ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. <br><br>  Ich werde diese Plattform nicht detailliert beschreiben und empfehle allen interessierten Lesern, den Artikel meines Kollegen Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in Roslyn und seine Verwendung in der Programmentwicklung</a> " zu lesen.  In diesem Artikel erfahren Sie nicht nur, welche Merkmale die Roslyn-Architektur aufweist, sondern auch, wie genau wir diese Plattform verwenden. <br><br>  Wie ich bereits erwähnt habe, ist es mehr als drei Jahre her, dass mein Kollege Andrey Karpov den letzten Artikel über den Roslyn-Check " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">New Year PVS-Studio 6.00 Release: Scanning Roslyn</a> " geschrieben hat.  Seitdem hat der C # PVS-Studio-Analysator viele neue Funktionen erhalten.  Eigentlich war Andreys Artikel ein Testfall, da zu diesem Zeitpunkt der C # -Analysator gerade in PVS-Studio hinzugefügt wurde.  Trotzdem konnten wir Fehler im Roslyn-Projekt feststellen, das sicherlich von hoher Qualität war.  Was hat sich in diesem Moment im Analysator für C # -Code geändert, sodass wir eine eingehendere Analyse durchführen können? <br><br>  Seitdem haben sich sowohl der Kern als auch die Infrastruktur entwickelt.  Wir haben Unterstützung für Visual Studio 2017 und Roslyn 2.0 sowie eine umfassende Integration in MSBuild hinzugefügt.  Der Artikel meines Kollegen Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung von Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist es nicht so einfach, vorgefertigte Lösungen zu verwenden, wie es scheint</a> " beschreibt unseren Ansatz zur Integration in MSBuild und die Gründe für diese Entscheidung. <br><br>  Momentan arbeiten wir aktiv an der Umstellung auf Roslyn 3.0, genauso wie wir Visual Studio 2017 ursprünglich unterstützt haben. Dazu muss unser eigenes Toolset verwendet werden, das in der PVS-Studio-Distribution als "Stub" enthalten ist und ein leeres MSBuild ist EXE-Datei.  Trotz der Tatsache, dass es wie eine „Krücke“ aussieht (MSBuild API ist aufgrund der geringen Portabilität von Bibliotheken nicht sehr benutzerfreundlich für die Wiederverwendung in Projekten von Drittanbietern), hat uns ein solcher Ansatz bereits geholfen, mehrere Roslyn-Updates in Bezug auf Visual Studio relativ nahtlos zu überwinden 2017. Bis jetzt war es hilfreich (trotz einiger Herausforderungen), das Visual Studio 2019-Update zu durchlaufen und die vollständige Abwärtskompatibilität und Leistung für Systeme mit älteren MSBuild-Versionen aufrechtzuerhalten. <br><br>  Der Analysatorkern hat auch eine Reihe von Verbesserungen erfahren.  Eines der Hauptmerkmale ist eine vollständige interprozedurale Analyse unter Berücksichtigung der Werte der Eingabe- und Ausgabemethoden, wobei die Erreichbarkeit der Ausführungszweige und Rückgabepunkte (abhängig von diesen Parametern) bewertet wird. <br><br>  Wir sind auf dem Weg, die Aufgabe der Überwachung der Parameter innerhalb der Methoden (z. B. potenziell gefährliche Dereferenzen) sowie das Speichern ihrer automatischen Anmerkungen abzuschließen.  Bei einer Diagnose, die einen Datenflussmechanismus verwendet, können gefährliche Situationen berücksichtigt werden, die beim Übergeben eines Parameters in einer Methode auftreten.  Zuvor wurde bei der Analyse derart gefährlicher Orte keine Warnung generiert, da wir bei einer solchen Methode nicht alle möglichen Eingabewerte kennen konnten.  Jetzt können wir die Gefahr erkennen, da an allen Stellen, an denen diese Methode aufgerufen wird, diese Eingabeparameter berücksichtigt werden. <br><br>  Hinweis: Weitere Informationen zu grundlegenden Analysemechanismen wie Datenfluss und anderen finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologien, die im PVS-Studio-Codeanalysator zum Auffinden von Fehlern und potenziellen Schwachstellen verwendet werden</a> ". <br><br>  Die interprozedurale Analyse in PVS-Studio C # ist weder durch Eingabeparameter noch durch die Tiefe begrenzt.  Die einzige Einschränkung sind virtuelle Methoden in Klassen, die für die Vererbung offen sind und in die Rekursion geraten (die Analyse wird beendet, wenn sie auf einen wiederholten Aufruf der bereits evaluierten Methode stößt).  Dabei wird die rekursive Methode selbst schließlich unter der Annahme bewertet, dass der Rückgabewert ihrer Rekursion unbekannt ist. <br><br>  Eine weitere großartige neue Funktion im C # -Analysator ist die Berücksichtigung einer möglichen Dereferenzierung eines potenziell Nullzeigers.  Zuvor beschwerte sich der Analysator über eine mögliche Nullreferenzausnahme, wobei sichergestellt wurde, dass in allen Ausführungszweigen der Variablenwert null ist.  Natürlich war es in einigen Fällen falsch, deshalb hatte die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose zuvor eine potenzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> genannt. <br><br>  Jetzt ist sich der Analysator der Tatsache bewusst, dass die Variable in einem der Ausführungszweige null sein kann (z. B. unter einer bestimmten <i>if-</i> Bedingung).  Wenn der Zugriff auf eine solche Variable ohne Prüfung bemerkt wird, wird die Warnung V3080 ausgegeben, jedoch mit geringerer Sicherheit, als wenn in allen Zweigen null angezeigt wird.  Zusammen mit der verbesserten interprozeduralen Analyse ermöglicht ein solcher Mechanismus das Auffinden von Fehlern, die sehr schwer zu erkennen sind.  Hier ein Beispiel - stellen Sie sich eine lange Kette von Methodenaufrufen vor, von denen der letzte Ihnen unbekannt ist.  Unter bestimmten Umständen wird im <i>catch-</i> Block null zurückgegeben, aber Sie haben sich nicht davor geschützt, wie Sie einfach nicht gewusst haben.  In diesem Fall beschwert sich der Analysator nur, wenn er genau die Nullzuweisung sieht.  Unserer Ansicht nach unterscheidet es unseren Ansatz qualitativ von einem solchen Merkmal von C # 8.0 als nullfähige Typreferenz, das sich tatsächlich darauf beschränkt, für jede Methode Prüfungen auf null zu setzen.  Wir empfehlen jedoch die Alternative, Überprüfungen nur an Stellen durchzuführen, an denen tatsächlich Null auftreten kann, und unser Analysator kann jetzt nach solchen Fällen suchen. <br><br>  Lassen Sie uns den Hauptpunkt also nicht zu lange aufschieben und uns dem Schuldsturm widmen - indem wir die Ergebnisse des Roslyn-Checks analysieren.  Betrachten wir zunächst die Fehler, die aufgrund der oben beschriebenen Funktionen festgestellt wurden.  Insgesamt gab es diesmal ziemlich viele Warnungen für den Roslyn-Code.  Ich denke, es hängt mit der Tatsache zusammen, dass sich die Plattform sehr aktiv weiterentwickelt (zu diesem Zeitpunkt umfasst die Codebasis etwa 2.770.000 Zeilen ohne Leerzeichen), und wir haben dieses Projekt nicht lange analysiert.  Trotzdem gibt es nicht so viele kritische Fehler, obwohl sie für den Artikel am interessantesten sind.  Wie üblich habe ich Tests von der Prüfung ausgeschlossen, es gibt ziemlich viele in Roslyn. <br><br>  Ich beginne mit V3080-Fehlern mittlerer Sicherheitsstufe, bei denen der Analysator einen möglichen Zugriff durch Nullreferenz erkannt hat, jedoch nicht in allen möglichen Fällen (Code-Verzweigungen). <br><br>  <b>Mögliche Null-Dereferenzierung - Mittel</b> <br><br>  V3080 Mögliche Null-Dereferenzierung.  Betrachten Sie die Überprüfung der "aktuellen".  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Betrachten wir die Methode <i>GetNode</i> .  Der Analysator schlägt vor, dass der Zugriff durch Nullreferenz im Zustand des <i>while-</i> Blocks möglich ist <i>.</i>  Der Variablen wird im Hauptteil des <i>while-</i> Blocks ein Wert zugewiesen, der ein Ergebnis der <i>AsNode-</i> Methode ist.  In einigen Fällen ist dieser Wert <i>null</i> .  Ein gutes Beispiel für eine interprozedurale Analyse in Aktion. <br><br>  Betrachten wir nun einen ähnlichen Fall, in dem die Interprozeduranalyse über zwei Methodenaufrufe durchgeführt wurde. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie das Verzeichnis.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Die <i>Verzeichnisvariable</i> im Hauptteil der <i>ExpandFileNamePattern-</i> Methode erhält den Wert von der Methode <i>GetDirectoryName (Zeichenfolge)</i> .  Dies gibt wiederum das Ergebnis der überladenen Methode <i>GetDirectoryName (string, bool) zurück,</i> deren Wert <i>null sein kann</i> .  Da das Variablenverzeichnis ohne vorläufige Prüfung auf null im Hauptteil der Methode <i>ExpandFileNamePattern verwendet wird</i> , können wir den Analysator für die Ausgabe der Warnung als korrekt proklamieren.  Dies ist eine möglicherweise unsichere Konstruktion. <br><br>  Ein weiteres Codefragment mit dem Fehler V3080, genauer gesagt mit zwei Fehlern, wurde für eine einzelne Codezeile ausgegeben.  Die interprozedurale Analyse wurde hier nicht benötigt. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Die Variablen <i>spanStartLocation</i> und <i>spanEndLocationExclusive</i> sind vom Typ <i>nullable int</i> und werden mit <i>null</i> initialisiert.  Weiter entlang des Codes können ihnen Werte zugewiesen werden, jedoch nur unter bestimmten Bedingungen.  In einigen Fällen bleibt ihr Wert <i>null</i> .  Danach wird auf diese Variablen ohne vorherige Überprüfung auf Null zugegriffen, was der Analysator anzeigt. <br><br>  Der Roslyn-Code enthält eine Menge solcher Fehler, mehr als 100. Oft ist das Muster dieser Fehler das gleiche.  Es gibt eine Art allgemeine Methode, die möglicherweise <i>null</i> zurückgibt.  Das Ergebnis dieser Methode wird an vielen Stellen verwendet, manchmal durch Dutzende von Zwischenmethodenaufrufen oder zusätzliche Überprüfungen.  Es ist wichtig zu verstehen, dass diese Fehler nicht schwerwiegend sind, aber möglicherweise zu einem Zugriff durch Nullreferenz führen können.  Das Erkennen solcher Fehler ist zwar eine ziemliche Herausforderung.  Aus diesem Grund sollte in einigen Fällen ein Code-Refactoring in Betracht gezogen werden. In diesem Fall <i>löst</i> die Methode eine Ausnahme aus, wenn <i>null</i> zurückgegeben wird.  Andernfalls können Sie Ihren Code nur mit allgemeinen Überprüfungen sichern, die ziemlich anstrengend und manchmal unzuverlässig sind.  Wie auch immer, es ist klar, dass jeder spezifische Fall eine Lösung erfordert, die auf Projektspezifikationen basiert. <br><br>  Hinweis  Es kommt also vor, dass es zu einem bestimmten Zeitpunkt keine solchen Fälle (Eingabedaten) gibt, wenn die Methode <i>null</i> zurückgibt und kein tatsächlicher Fehler vorliegt.  Ein solcher Code ist jedoch immer noch nicht zuverlässig, da sich bei der Einführung einiger Codeänderungen alles ändern kann. <br><br>  Um das Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">löschen</a> , betrachten wir offensichtliche Fehler mit hoher Sicherheit, wenn der Zugriff per Nullreferenz am wahrscheinlichsten oder sogar unvermeidlich ist. <br><br>  <b>Mögliche Null-Dereferenzierung - Hoch</b> <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Aufgrund des Tippfehlers in der Bedingung ( <i>&amp;&amp;</i> wird anstelle des Operators <i>|| verwendet</i> ) funktioniert der Code anders als beabsichtigt und der Zugriff auf die Variable <i>collectionType.Type</i> wird ausgeführt, wenn sie <i>null ist</i> .  Der Zustand sollte wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Übrigens können sich die Dinge auf andere Weise entfalten: Im ersten Teil der Bedingung sind die Operatoren <i>==</i> und <i>! =</i> Durcheinander <i>.</i>  Dann würde der richtige Code so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Diese Version des Codes ist weniger logisch, korrigiert aber auch den Fehler.  Die endgültige Lösung liegt bei den Autoren des Projekts. <br><br>  Ein weiterer ähnlicher Fehler. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überlegen Sie, ob Sie die Aktion überprüfen möchten.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Der Fehler tritt beim Generieren der Nachricht für die Ausnahme auf.  Es folgt der Versuch, über die <i>Aktionsvariable</i> , die als <i>null</i> bekannt ist, auf die <i>action.DisplayText-</i> Eigenschaft zuzugreifen. <br><br>  Hier kommt der letzte V3080-Fehler des High-Levels. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie den Typ.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Die Methode ist ziemlich klein, deshalb zitiere ich sie ganz.  Die Bedingung im <i>Rückgabeblock</i> ist falsch.  In einigen Fällen kann beim Zugriff auf <i>type.FullName</i> eine Ausnahme auftreten.  Ich werde Klammern verwenden, um es klar zu machen (sie werden das Verhalten nicht ändern): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Entsprechend der Priorität der Operationen funktioniert der Code genau so.  Falls die Typvariable <i>null ist</i> , fallen wir in die else-Prüfung, in der wir die <i>Typ-</i> Null-Referenz verwenden, nachdem wir die Variable <i>targetTypeName</i> auf <i>null</i> überprüft haben.  Der Code kann beispielsweise wie folgt festgelegt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Ich denke, es reicht aus, um V3080-Fehler zu überprüfen.  Jetzt ist es höchste Zeit, andere interessante Dinge zu sehen, die der PVS-Studio-Analysator gefunden hat. <br><br>  <b>Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3005</a> Die Variable 'SourceCodeKind' wird sich selbst zugewiesen.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Aufgrund fehlgeschlagener Benennung von Variablen wurde im Konstruktor der <i>DynamicFileInfo-</i> Klasse ein Tippfehler gemacht.  Dem Feld <i>SourceCodeKind</i> wird ein eigener Wert zugewiesen, anstatt den Parameter <i>sourceCodeKind zu verwenden</i> .  Um die Wahrscheinlichkeit solcher Fehler zu minimieren, empfehlen wir, in solchen Fällen das Unterstrichpräfix für die Parameternamen zu verwenden.  Hier ist ein Beispiel für eine korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Versehen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3006</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schlüsselwort 'throw' könnte fehlen: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Unter bestimmten Bedingungen muss der Destruktor eine Ausnahme auslösen, dies geschieht jedoch nicht, während das Ausnahmeobjekt einfach erstellt wird.  Das Schlüsselwort <i>throw</i> wurde übersehen.  Hier ist die korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Das Problem mit Destruktoren in C # und das Auslösen von Ausnahmen ist ein Thema für eine weitere Diskussion, die den Rahmen dieses Artikels sprengt. <br><br>  <b>Wenn das Ergebnis nicht wichtig ist</b> <br><br>  Methoden, die in allen Fällen den gleichen Wert erhielten, lösten eine bestimmte Anzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009-</a> Warnungen aus.  In einigen Fällen kann dies nicht kritisch sein oder der Rückgabewert wird im aufrufenden Code einfach nicht überprüft.  Ich habe solche Warnungen übersprungen.  Aber ein paar Codefragmente schienen verdächtig.  Hier ist einer von ihnen: <br><br>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode <i>TryExecuteCommand</i> gibt nur <i>true zurück</i> .  Dabei wird im aufrufenden Code der zurückgegebene Wert in einige Prüfungen einbezogen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es ist schwer genau zu sagen, inwieweit ein solches Verhalten gefährlich ist.  Wenn das Ergebnis jedoch nicht benötigt wird, sollte der Typ des Rückgabewerts möglicherweise in void geändert und die aufrufende Methode geringfügig geändert werden.  Dadurch wird der Code lesbarer und sicherer. <br><br>  Ähnliche Warnungen des Analysators: <br><br><ul><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  JsonRpcClient.cs 138 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'false' zurückgibt.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  ObjectList.cs 173 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  ObjectList.cs 249 </li></ul><br>  <b>Überprüfte das Falsche</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> Möglicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen.  Überprüfen Sie die Variablen 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Die <i>Wertvariable</i> wird in den Typ <i>NamingStylePreferences umgewandelt</i> .  Das Problem liegt in der folgenden Überprüfung.  Selbst wenn die <i>Wertvariable</i> nicht null war, kann nicht garantiert werden, dass die Typumwandlung erfolgreich war, und <i>valueToSerialize</i> enthält keine <i>Null</i> .  Mögliches <i>Auslösen</i> der Ausnahme <i>NullReferenceException</i> .  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Ein weiterer ähnlicher Fehler: <br><br>  V3019 Möglicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen.  Überprüfen Sie die Variablen 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Die Variable <i>columnState</i> wird in den Typ <i>ColumnState2 umgewandelt</i> .  Das Operationsergebnis, bei dem es sich um die Variable <i>columnState2 handelt,</i> wird jedoch nicht weiter auf <i>null</i> geprüft.  Stattdessen wird die Variable <i>columnState</i> mit dem bedingten <i>Nulloperator</i> überprüft.  Warum ist dieser Code gefährlich?  Genau wie im vorherigen Beispiel kann das Casting mit dem Operator <i>as</i> fehlschlagen und die Variable ist <i>null,</i> was zu einer Ausnahme führt.  Übrigens kann hier ein Tippfehler schuld sein.  Schauen Sie sich den Zustand im <i>if-</i> Block an. <br><br>  Vielleicht wollte der Autor anstelle von <i>columnState? .Name columnState2? .Name</i> schreiben.  Es ist sehr wahrscheinlich, wenn man die ziemlich fehlerhaften Variablennamen <i>columnState</i> und <i>columnState2 berücksichtigt.</i> <br><br>  <b>Redundante Schecks</b> <br><br>  Bei unkritischen, aber möglicherweise unsicheren Konstruktionen im Zusammenhang mit redundanten Überprüfungen wurde eine große Anzahl von Warnungen ausgegeben (mehr als 100).  Zum Beispiel ist dies einer von ihnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'navInfo == null' ist immer falsch.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Möglicherweise gibt es hier keinen tatsächlichen Fehler.  Dies ist nur ein guter Grund, die "Interprozedurale Analyse + Datenflussanalyse" im Schlepptau zu demonstrieren.  Der Analysator schlägt vor, dass die zweite Prüfung <i>navInfo == null</i> redundant ist.  <i>Zuvor</i> wird der <i>NavInfo</i> zugewiesene Wert von der Methode <i>libraryService.NavInfoFactory.CreateForProject</i> abgerufen, die ein neues Objekt der <i>NavInfo-</i> Klasse erstellt und <i>zurückgibt</i> .  Auf keinen Fall wird <i>null zurückgegeben</i> .  Hier stellt sich die Frage, warum der Analysator keine Warnung für die erste Prüfung <i>navInfo == null ausgegeben hat</i> .  Es gibt einige Gründe.  Erstens, wenn die <i>Symbolvariable</i> <i>null ist</i> , <i>bleibt</i> der <i>navInfo-</i> Wert auch eine <i>Nullreferenz</i> .  Zweitens kann dieser Wert auch <i>null sein</i> , selbst wenn <i>navInfo</i> den Wert von der Methode <i>ibraryService.NavInfoFactory.CreateForSymbol</i> erhält.  Daher wird die erste Prüfung <i>navInfo == null</i> wirklich benötigt. <br><br>  <b>Unzureichende Kontrollen</b> <br><br>  Nun ist die umgekehrte Situation von der oben diskutierten.  Für den Code wurden mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3042-</a> Warnungen ausgelöst, bei denen ein Zugriff per <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> möglich ist.  Sogar ein oder zwei kleine Schecks hätten alles reparieren können. <br><br>  Betrachten wir ein weiteres interessantes Codefragment, das zwei solche Fehler aufweist. <br><br>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'Empfänger'-Objekts Binder_Expressions.cs 7770 verwendet <br><br>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'Empfänger'-Objekts Binder_Expressions.cs 7776 verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Die <i>Empfängervariable</i> kann null sein.  Der Autor des Codes weiß davon, da er den bedingten <i>Nulloperator</i> in der Bedingung des <i>if-</i> Blocks verwendet, um auf den <i>Empfänger</i> zuzugreifen <i>. Syntax</i> .  Ferner wird die <i>Empfängervariable</i> ohne Überprüfung verwendet, um auf <i>Empfänger</i> zuzugreifen. Typ, <i>Empfänger</i> . <i>Syntax</i> und <i>Empfänger</i> . <i>HatErrors</i> .  Diese Fehler müssen korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Wir müssen auch sicherstellen, dass der Konstruktor das Abrufen von <i>Nullwerten</i> für seine Parameter unterstützt, oder wir müssen zusätzliches Refactoring durchführen. <br><br>  Andere ähnliche Fehler: <br><br><ul><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des Objekts 'includesType' SyntaxGeneratorExtensions_Negate.cs 240 verwendet </li><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li></ul><br>  <b>Fehler in der Bedingung</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3057</a> Die Funktion 'Teilzeichenfolge' könnte den Wert '-1' empfangen, während ein nicht negativer Wert erwartet wird.  Untersuchen Sie das zweite Argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Wenn die <i>Doppelpunktvariable</i> 0 ist, was gemäß der Bedingung im Code in <i>Ordnung ist</i> , <i>löst</i> die <i>Substring-</i> Methode eine Ausnahme aus.  Dies muss behoben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Möglicher Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3065 Der</a> Parameter 't2' wird im Körper der Methode nicht verwendet.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Der Lambda-Ausdruck akzeptiert zwei Parameter: t1 und t2.  Es wird jedoch nur t1 verwendet.  Es sieht verdächtig aus, wenn man bedenkt, wie einfach es ist, bei der Verwendung von Variablen mit solchen Namen einen Fehler zu machen. <br><br>  <b>Versehen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'TagsChanged', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Das <i>TagChanged-</i> Ereignis wird auf unsichere Weise aufgerufen.  Zwischen der Überprüfung auf <i>null</i> und dem Aufrufen des Ereignisses kann sich jemand abmelden, und es wird eine Ausnahme ausgelöst.  Darüber hinaus werden unmittelbar vor dem Aufrufen des Ereignisses andere Operationen im Hauptteil des <i>if-</i> Blocks ausgeführt.  Ich habe diesen Fehler "Versehen" genannt, weil dieses Ereignis an anderen Stellen wie folgt sorgfältiger behandelt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Die Verwendung einer zusätzlichen <i>Handlervariablen</i> verhindert das Problem.  In der Methode <i>OnTextBufferChanged müssen</i> Änderungen vorgenommen werden, um das Ereignis sicher zu behandeln. <br><br>  <b>Schnittpunkte</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3092 Bereichsschnittpunkte</a> sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Lassen Sie mich zum besseren Verständnis diesen Code neu schreiben und die Namen der Konstanten mit ihren tatsächlichen Werten ändern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Wahrscheinlich gibt es keinen wirklichen Fehler, aber der Zustand sieht seltsam aus.  Sein zweiter Teil ( <i>sonst wenn</i> ) wird nur für den Bereich von 2147483648 + 1 bis 4294967295 ausgeführt. <br><br>  Noch ein paar ähnliche Warnungen: <br><br><ul><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Weitere Informationen zu Überprüfungen auf Null (oder deren Fehlen)</b> <br><br>  Einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095-</a> Fehler bei der Überprüfung einer Variablen auf Null direkt nach ihrer Verwendung.  Der erste ist nicht eindeutig, betrachten wir den Code. <br><br>  V3095 Das Objekt 'displayName' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Es wird angenommen, dass der Referenzanzeigename <i>null sein</i> kann.  Hierzu wurde die Prüfung <i>Debug.Assert</i> durchgeführt.  Es ist nicht klar, warum es nach der Verwendung einer Zeichenfolge geht.  Es muss auch berücksichtigt werden, dass der Compiler bei anderen Konfigurationen als Debug <i>Debug.Assert</i> überhaupt entfernt <i>.</i>  Bedeutet dies, dass das Abrufen einer Nullreferenz nur für Debug möglich ist?  Wenn dies nicht der <i>Fall</i> ist, warum hat der Autor beispielsweise die <i>Zeichenfolge.IsNullOrEmpty (Zeichenfolge)</i> überprüft <i>?</i>  Dies ist die Frage an die Autoren des Codes. <br><br>  Der folgende Fehler ist offensichtlicher. <br><br>  V3095 Das Objekt 'scriptArgsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Ich denke, dieser Code braucht keine Erklärungen.  Lassen Sie mich Ihnen die feste Version geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Im Roslyn-Code gab es 15 weitere ähnliche Fehler: <br><br><ul><li>  V3095 Das Objekt 'LocalFunctions' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Das Objekt 'Resolution.OverloadResolutionResult' wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Das Objekt 'Resolution.MethodGroup' wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Das Objekt 'touchFilesLogger' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Das Objekt 'newExceptionRegionsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 Das 'Symbol'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Das Objekt '_state.BaseTypeOrInterfaceOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Das Objekt 'element' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Das 'Sprachen'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Das Objekt 'memberType' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Das Objekt 'validTypeDeclarations' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 Das 'Text'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 Das Objekt 'nameOrMemberAccessExpression' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 Das Objekt 'simpleName' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 Das Objekt 'option' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 23, 28. OptionKey.cs 23 </li></ul><br>  Betrachten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3105-</a> Fehler.  Hier wird der bedingte <i>Nulloperator</i> beim Initialisieren der Variablen verwendet, aber weiterhin wird die Variable ohne Prüfung auf <i>Null verwendet</i> . <br><br>  Zwei Warnungen weisen auf folgenden Fehler hin: <br><br>  V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist möglich.  CodeLensReferencesService.cs 138 <br><br>  V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist möglich.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  Die Variable <i>documentId</i> kann mit <i>null</i> initialisiert werden.  Wenn Sie ein Objekt <i>ReferenceLocationDescriptor</i> erstellen, wird eine Ausnahme ausgelöst.  Der Code muss behoben sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Entwickler sollten auch die Möglichkeit abdecken, dass Variablen, die an einen Konstruktor übergeben werden, <i>null sind.</i> <br><br>  Andere ähnliche Fehler im Code: <br><br><ul><li>  V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist möglich.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist möglich.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Prioritäten und Klammern</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3123</a> Vielleicht arbeitet der Operator '?:' Anders als erwartet.  Ihre Priorität ist niedriger als die Priorität anderer Betreiber in ihrem Zustand.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  Die Bedingung im Rückgabeblock wird nicht wie vom Entwickler beabsichtigt ausgewertet.  Es wurde angenommen, dass die erste Bedingung <i>_kind == other._kin</i> d ist (aus diesem Grund gibt es nach dieser Bedingung einen Zeilenumbruch), und danach werden die Bedingungsblöcke mit dem Operator " <i>?</i> " Nacheinander ausgewertet.  Tatsächlich ist die erste Bedingung <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Dies liegt an der Tatsache, dass der Operator <i>&amp;&amp;</i> eine höhere Priorität als der Operator " <i>?</i> " <i>Hat</i> .  Um dies zu beheben, sollte ein Entwickler alle Ausdrücke des Operators " <i>?</i> " In Klammern setzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Damit ist meine Beschreibung der gefundenen Fehler abgeschlossen. <br><br>  <b>Fazit</b> <br><br>  Trotz der großen Anzahl von Fehlern, die ich in Bezug auf die Größe des Roslyn-Projektcodes (2.770.000 Zeilen) gefunden habe, ist es nicht zu viel.  Wie Andrey in einem früheren Artikel schrieb, bin ich auch bereit, die hohe Qualität dieses Projekts anzuerkennen. <br><br>  Ich möchte darauf hinweisen, dass solche gelegentlichen Codeprüfungen nichts mit der Methodik der statischen Analyse zu tun haben und fast nicht hilfreich sind.  Statische Analysen sollten regelmäßig und nicht von Fall zu Fall durchgeführt werden.  Auf diese Weise werden viele Fehler in den frühesten Stadien korrigiert, und daher sind die Kosten für deren Behebung zehnmal geringer.  Diese Idee wird in dieser kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Notiz</a> ausführlicher beschrieben. Bitte probieren Sie sie aus. <br><br>  Sie können einige Fehler sowohl in diesem als auch in einem anderen Projekt überprüfen.  Dazu müssen Sie nur unseren Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> und ausprobieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446588/">https://habr.com/ru/post/de446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446572/index.html">Editor.js ist ein ausgezeichneter Editor, der Quellcode im JSON-Format speichert</a></li>
<li><a href="../de446576/index.html">Importsubstitution oder wie russische Hubschrauber etwas falsch gemacht haben</a></li>
<li><a href="../de446578/index.html">Postkartenbasierte Programmiersprache</a></li>
<li><a href="../de446582/index.html">Überlegungen zum Solar Hosting für Bienen</a></li>
<li><a href="../de446586/index.html">Netzwerkeinstellungen von FreeRadius über DHCP</a></li>
<li><a href="../de446590/index.html">39 neue Funktionen in Java 12</a></li>
<li><a href="../de446592/index.html">Überprüfen des Quellcodes von Roslyn</a></li>
<li><a href="../de446598/index.html">Neuerstellen von CRT-Schriftarten</a></li>
<li><a href="../de446602/index.html">Maximaler Gleichstrom durch Feldeffekttransistor</a></li>
<li><a href="../de446604/index.html">ESET: Neue Backdoor-Lieferprogramme für OceanLotus Cybergroup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>