<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèø üë®üèΩ üë®üèæ‚Äçüéì √úberpr√ºfen des Roslyn-Quellcodes üíáüèø üçà ü§ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hin und wieder kehren wir zu den Projekten zur√ºck, die wir zuvor mit PVS-Studio √ºberpr√ºft haben, was zu deren Beschreibung in verschiedenen Artikeln f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen des Roslyn-Quellcodes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio gegen Roslyn"></div><br>  Hin und wieder kehren wir zu den Projekten zur√ºck, die wir zuvor mit PVS-Studio √ºberpr√ºft haben, was zu deren Beschreibung in verschiedenen Artikeln f√ºhrt.  Zwei Gr√ºnde machen diese Comebacks f√ºr uns spannend.  Erstens die M√∂glichkeit, den Fortschritt unseres Analyseger√§ts zu bewerten.  Zweitens die √úberwachung des Feedbacks der Projektautoren zu unserem Artikel und des Fehlerberichts, den wir ihnen normalerweise zur Verf√ºgung stellen.  Nat√ºrlich k√∂nnen Fehler ohne unsere Teilnahme korrigiert werden.  Es ist jedoch immer sch√∂n, wenn unsere Bem√ºhungen dazu beitragen, ein Projekt besser zu machen.  Roslyn war keine Ausnahme.  Der vorherige Artikel √ºber diese Projektpr√ºfung stammt aus dem 23. Dezember 2015. Angesichts der Fortschritte, die unser Analyseger√§t seitdem erzielt hat, ist dies eine ziemlich lange Zeit.  Da der C # -Kern des PVS-Studio-Analysators auf Roslyn basiert, gibt es uns zus√§tzliches Interesse an diesem Projekt.  Aus diesem Grund sind wir von der Codequalit√§t dieses Projekts begeistert.  Lassen Sie es uns jetzt noch einmal testen und einige neue und interessante Probleme herausfinden (aber hoffen wir, dass nichts Bedeutendes ist), die PVS-Studio finden kann. <br><a name="habracut"></a><br>  Viele unserer Leser kennen Roslyn (oder die .NET Compiler-Plattform) wahrscheinlich gut.  Kurz gesagt, es handelt sich um eine Reihe von Open Source-Compilern und eine API f√ºr die Code-Analyse von C # - und Visual Basic .NET-Sprachen von Microsoft.  Der Quellcode des Projekts ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar. <br><br>  Ich werde diese Plattform nicht detailliert beschreiben und empfehle allen interessierten Lesern, den Artikel meines Kollegen Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in Roslyn und seine Verwendung in der Programmentwicklung</a> " zu lesen.  In diesem Artikel erfahren Sie nicht nur, welche Merkmale die Roslyn-Architektur aufweist, sondern auch, wie genau wir diese Plattform verwenden. <br><br>  Wie ich bereits erw√§hnt habe, ist es mehr als drei Jahre her, dass mein Kollege Andrey Karpov den letzten Artikel √ºber den Roslyn-Check " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">New Year PVS-Studio 6.00 Release: Scanning Roslyn</a> " geschrieben hat.  Seitdem hat der C # PVS-Studio-Analysator viele neue Funktionen erhalten.  Eigentlich war Andreys Artikel ein Testfall, da zu diesem Zeitpunkt der C # -Analysator gerade in PVS-Studio hinzugef√ºgt wurde.  Trotzdem konnten wir Fehler im Roslyn-Projekt feststellen, das sicherlich von hoher Qualit√§t war.  Was hat sich in diesem Moment im Analysator f√ºr C # -Code ge√§ndert, sodass wir eine eingehendere Analyse durchf√ºhren k√∂nnen? <br><br>  Seitdem haben sich sowohl der Kern als auch die Infrastruktur entwickelt.  Wir haben Unterst√ºtzung f√ºr Visual Studio 2017 und Roslyn 2.0 sowie eine umfassende Integration in MSBuild hinzugef√ºgt.  Der Artikel meines Kollegen Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung von Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist es nicht so einfach, vorgefertigte L√∂sungen zu verwenden, wie es scheint</a> " beschreibt unseren Ansatz zur Integration in MSBuild und die Gr√ºnde f√ºr diese Entscheidung. <br><br>  Momentan arbeiten wir aktiv an der Umstellung auf Roslyn 3.0, genauso wie wir Visual Studio 2017 urspr√ºnglich unterst√ºtzt haben. Dazu muss unser eigenes Toolset verwendet werden, das in der PVS-Studio-Distribution als "Stub" enthalten ist und ein leeres MSBuild ist EXE-Datei.  Trotz der Tatsache, dass es wie eine ‚ÄûKr√ºcke‚Äú aussieht (MSBuild API ist aufgrund der geringen Portabilit√§t von Bibliotheken nicht sehr benutzerfreundlich f√ºr die Wiederverwendung in Projekten von Drittanbietern), hat uns ein solcher Ansatz bereits geholfen, mehrere Roslyn-Updates in Bezug auf Visual Studio relativ nahtlos zu √ºberwinden 2017. Bis jetzt war es hilfreich (trotz einiger Herausforderungen), das Visual Studio 2019-Update zu durchlaufen und die vollst√§ndige Abw√§rtskompatibilit√§t und Leistung f√ºr Systeme mit √§lteren MSBuild-Versionen aufrechtzuerhalten. <br><br>  Der Analysatorkern hat auch eine Reihe von Verbesserungen erfahren.  Eines der Hauptmerkmale ist eine vollst√§ndige interprozedurale Analyse unter Ber√ºcksichtigung der Werte der Eingabe- und Ausgabemethoden, wobei die Erreichbarkeit der Ausf√ºhrungszweige und R√ºckgabepunkte (abh√§ngig von diesen Parametern) bewertet wird. <br><br>  Wir sind auf dem Weg, die Aufgabe der √úberwachung der Parameter innerhalb der Methoden (z. B. potenziell gef√§hrliche Dereferenzen) sowie das Speichern ihrer automatischen Anmerkungen abzuschlie√üen.  Bei einer Diagnose, die einen Datenflussmechanismus verwendet, k√∂nnen gef√§hrliche Situationen ber√ºcksichtigt werden, die beim √úbergeben eines Parameters in einer Methode auftreten.  Zuvor wurde bei der Analyse derart gef√§hrlicher Orte keine Warnung generiert, da wir bei einer solchen Methode nicht alle m√∂glichen Eingabewerte kennen konnten.  Jetzt k√∂nnen wir die Gefahr erkennen, da an allen Stellen, an denen diese Methode aufgerufen wird, diese Eingabeparameter ber√ºcksichtigt werden. <br><br>  Hinweis: Weitere Informationen zu grundlegenden Analysemechanismen wie Datenfluss und anderen finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologien, die im PVS-Studio-Codeanalysator zum Auffinden von Fehlern und potenziellen Schwachstellen verwendet werden</a> ". <br><br>  Die interprozedurale Analyse in PVS-Studio C # ist weder durch Eingabeparameter noch durch die Tiefe begrenzt.  Die einzige Einschr√§nkung sind virtuelle Methoden in Klassen, die f√ºr die Vererbung offen sind und in die Rekursion geraten (die Analyse wird beendet, wenn sie auf einen wiederholten Aufruf der bereits evaluierten Methode st√∂√üt).  Dabei wird die rekursive Methode selbst schlie√ülich unter der Annahme bewertet, dass der R√ºckgabewert ihrer Rekursion unbekannt ist. <br><br>  Eine weitere gro√üartige neue Funktion im C # -Analysator ist die Ber√ºcksichtigung einer m√∂glichen Dereferenzierung eines potenziell Nullzeigers.  Zuvor beschwerte sich der Analysator √ºber eine m√∂gliche Nullreferenzausnahme, wobei sichergestellt wurde, dass in allen Ausf√ºhrungszweigen der Variablenwert null ist.  Nat√ºrlich war es in einigen F√§llen falsch, deshalb hatte die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose zuvor eine potenzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> genannt. <br><br>  Jetzt ist sich der Analysator der Tatsache bewusst, dass die Variable in einem der Ausf√ºhrungszweige null sein kann (z. B. unter einer bestimmten <i>if-</i> Bedingung).  Wenn der Zugriff auf eine solche Variable ohne Pr√ºfung bemerkt wird, wird die Warnung V3080 ausgegeben, jedoch mit geringerer Sicherheit, als wenn in allen Zweigen null angezeigt wird.  Zusammen mit der verbesserten interprozeduralen Analyse erm√∂glicht ein solcher Mechanismus das Auffinden von Fehlern, die sehr schwer zu erkennen sind.  Hier ein Beispiel - stellen Sie sich eine lange Kette von Methodenaufrufen vor, von denen der letzte Ihnen unbekannt ist.  Unter bestimmten Umst√§nden wird im <i>catch-</i> Block null zur√ºckgegeben, aber Sie haben sich nicht davor gesch√ºtzt, wie Sie einfach nicht gewusst haben.  In diesem Fall beschwert sich der Analysator nur, wenn er genau die Nullzuweisung sieht.  Unserer Ansicht nach unterscheidet es unseren Ansatz qualitativ von einem solchen Merkmal von C # 8.0 als nullf√§hige Typreferenz, das sich tats√§chlich darauf beschr√§nkt, f√ºr jede Methode Pr√ºfungen auf null zu setzen.  Wir empfehlen jedoch die Alternative, √úberpr√ºfungen nur an Stellen durchzuf√ºhren, an denen tats√§chlich Null auftreten kann, und unser Analysator kann jetzt nach solchen F√§llen suchen. <br><br>  Lassen Sie uns den Hauptpunkt also nicht zu lange aufschieben und uns dem Schuldsturm widmen - indem wir die Ergebnisse des Roslyn-Checks analysieren.  Betrachten wir zun√§chst die Fehler, die aufgrund der oben beschriebenen Funktionen festgestellt wurden.  Insgesamt gab es diesmal ziemlich viele Warnungen f√ºr den Roslyn-Code.  Ich denke, es h√§ngt mit der Tatsache zusammen, dass sich die Plattform sehr aktiv weiterentwickelt (zu diesem Zeitpunkt umfasst die Codebasis etwa 2.770.000 Zeilen ohne Leerzeichen), und wir haben dieses Projekt nicht lange analysiert.  Trotzdem gibt es nicht so viele kritische Fehler, obwohl sie f√ºr den Artikel am interessantesten sind.  Wie √ºblich habe ich Tests von der Pr√ºfung ausgeschlossen, es gibt ziemlich viele in Roslyn. <br><br>  Ich beginne mit V3080-Fehlern mittlerer Sicherheitsstufe, bei denen der Analysator einen m√∂glichen Zugriff durch Nullreferenz erkannt hat, jedoch nicht in allen m√∂glichen F√§llen (Code-Verzweigungen). <br><br>  <b>M√∂gliche Null-Dereferenzierung - Mittel</b> <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung der "aktuellen".  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Betrachten wir die Methode <i>GetNode</i> .  Der Analysator schl√§gt vor, dass der Zugriff durch Nullreferenz im Zustand des <i>while-</i> Blocks m√∂glich ist <i>.</i>  Der Variablen wird im Hauptteil des <i>while-</i> Blocks ein Wert zugewiesen, der ein Ergebnis der <i>AsNode-</i> Methode ist.  In einigen F√§llen ist dieser Wert <i>null</i> .  Ein gutes Beispiel f√ºr eine interprozedurale Analyse in Aktion. <br><br>  Betrachten wir nun einen √§hnlichen Fall, in dem die Interprozeduranalyse √ºber zwei Methodenaufrufe durchgef√ºhrt wurde. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie das Verzeichnis.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Die <i>Verzeichnisvariable</i> im Hauptteil der <i>ExpandFileNamePattern-</i> Methode erh√§lt den Wert von der Methode <i>GetDirectoryName (Zeichenfolge)</i> .  Dies gibt wiederum das Ergebnis der √ºberladenen Methode <i>GetDirectoryName (string, bool) zur√ºck,</i> deren Wert <i>null sein kann</i> .  Da das Variablenverzeichnis ohne vorl√§ufige Pr√ºfung auf null im Hauptteil der Methode <i>ExpandFileNamePattern verwendet wird</i> , k√∂nnen wir den Analysator f√ºr die Ausgabe der Warnung als korrekt proklamieren.  Dies ist eine m√∂glicherweise unsichere Konstruktion. <br><br>  Ein weiteres Codefragment mit dem Fehler V3080, genauer gesagt mit zwei Fehlern, wurde f√ºr eine einzelne Codezeile ausgegeben.  Die interprozedurale Analyse wurde hier nicht ben√∂tigt. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Die Variablen <i>spanStartLocation</i> und <i>spanEndLocationExclusive</i> sind vom Typ <i>nullable int</i> und werden mit <i>null</i> initialisiert.  Weiter entlang des Codes k√∂nnen ihnen Werte zugewiesen werden, jedoch nur unter bestimmten Bedingungen.  In einigen F√§llen bleibt ihr Wert <i>null</i> .  Danach wird auf diese Variablen ohne vorherige √úberpr√ºfung auf Null zugegriffen, was der Analysator anzeigt. <br><br>  Der Roslyn-Code enth√§lt eine Menge solcher Fehler, mehr als 100. Oft ist das Muster dieser Fehler das gleiche.  Es gibt eine Art allgemeine Methode, die m√∂glicherweise <i>null</i> zur√ºckgibt.  Das Ergebnis dieser Methode wird an vielen Stellen verwendet, manchmal durch Dutzende von Zwischenmethodenaufrufen oder zus√§tzliche √úberpr√ºfungen.  Es ist wichtig zu verstehen, dass diese Fehler nicht schwerwiegend sind, aber m√∂glicherweise zu einem Zugriff durch Nullreferenz f√ºhren k√∂nnen.  Das Erkennen solcher Fehler ist zwar eine ziemliche Herausforderung.  Aus diesem Grund sollte in einigen F√§llen ein Code-Refactoring in Betracht gezogen werden. In diesem Fall <i>l√∂st</i> die Methode eine Ausnahme aus, wenn <i>null</i> zur√ºckgegeben wird.  Andernfalls k√∂nnen Sie Ihren Code nur mit allgemeinen √úberpr√ºfungen sichern, die ziemlich anstrengend und manchmal unzuverl√§ssig sind.  Wie auch immer, es ist klar, dass jeder spezifische Fall eine L√∂sung erfordert, die auf Projektspezifikationen basiert. <br><br>  Hinweis  Es kommt also vor, dass es zu einem bestimmten Zeitpunkt keine solchen F√§lle (Eingabedaten) gibt, wenn die Methode <i>null</i> zur√ºckgibt und kein tats√§chlicher Fehler vorliegt.  Ein solcher Code ist jedoch immer noch nicht zuverl√§ssig, da sich bei der Einf√ºhrung einiger Code√§nderungen alles √§ndern kann. <br><br>  Um das Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">l√∂schen</a> , betrachten wir offensichtliche Fehler mit hoher Sicherheit, wenn der Zugriff per Nullreferenz am wahrscheinlichsten oder sogar unvermeidlich ist. <br><br>  <b>M√∂gliche Null-Dereferenzierung - Hoch</b> <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Aufgrund des Tippfehlers in der Bedingung ( <i>&amp;&amp;</i> wird anstelle des Operators <i>|| verwendet</i> ) funktioniert der Code anders als beabsichtigt und der Zugriff auf die Variable <i>collectionType.Type</i> wird ausgef√ºhrt, wenn sie <i>null ist</i> .  Der Zustand sollte wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  √úbrigens k√∂nnen sich die Dinge auf andere Weise entfalten: Im ersten Teil der Bedingung sind die Operatoren <i>==</i> und <i>! =</i> Durcheinander <i>.</i>  Dann w√ºrde der richtige Code so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Diese Version des Codes ist weniger logisch, korrigiert aber auch den Fehler.  Die endg√ºltige L√∂sung liegt bei den Autoren des Projekts. <br><br>  Ein weiterer √§hnlicher Fehler. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberlegen Sie, ob Sie die Aktion √ºberpr√ºfen m√∂chten.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Der Fehler tritt beim Generieren der Nachricht f√ºr die Ausnahme auf.  Es folgt der Versuch, √ºber die <i>Aktionsvariable</i> , die als <i>null</i> bekannt ist, auf die <i>action.DisplayText-</i> Eigenschaft zuzugreifen. <br><br>  Hier kommt der letzte V3080-Fehler des High-Levels. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie den Typ.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Die Methode ist ziemlich klein, deshalb zitiere ich sie ganz.  Die Bedingung im <i>R√ºckgabeblock</i> ist falsch.  In einigen F√§llen kann beim Zugriff auf <i>type.FullName</i> eine Ausnahme auftreten.  Ich werde Klammern verwenden, um es klar zu machen (sie werden das Verhalten nicht √§ndern): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Entsprechend der Priorit√§t der Operationen funktioniert der Code genau so.  Falls die Typvariable <i>null ist</i> , fallen wir in die else-Pr√ºfung, in der wir die <i>Typ-</i> Null-Referenz verwenden, nachdem wir die Variable <i>targetTypeName</i> auf <i>null</i> √ºberpr√ºft haben.  Der Code kann beispielsweise wie folgt festgelegt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Ich denke, es reicht aus, um V3080-Fehler zu √ºberpr√ºfen.  Jetzt ist es h√∂chste Zeit, andere interessante Dinge zu sehen, die der PVS-Studio-Analysator gefunden hat. <br><br>  <b>Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3005</a> Die Variable 'SourceCodeKind' wird sich selbst zugewiesen.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Aufgrund fehlgeschlagener Benennung von Variablen wurde im Konstruktor der <i>DynamicFileInfo-</i> Klasse ein Tippfehler gemacht.  Dem Feld <i>SourceCodeKind</i> wird ein eigener Wert zugewiesen, anstatt den Parameter <i>sourceCodeKind zu verwenden</i> .  Um die Wahrscheinlichkeit solcher Fehler zu minimieren, empfehlen wir, in solchen F√§llen das Unterstrichpr√§fix f√ºr die Parameternamen zu verwenden.  Hier ist ein Beispiel f√ºr eine korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Versehen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3006</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schl√ºsselwort 'throw' k√∂nnte fehlen: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Unter bestimmten Bedingungen muss der Destruktor eine Ausnahme ausl√∂sen, dies geschieht jedoch nicht, w√§hrend das Ausnahmeobjekt einfach erstellt wird.  Das Schl√ºsselwort <i>throw</i> wurde √ºbersehen.  Hier ist die korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Das Problem mit Destruktoren in C # und das Ausl√∂sen von Ausnahmen ist ein Thema f√ºr eine weitere Diskussion, die den Rahmen dieses Artikels sprengt. <br><br>  <b>Wenn das Ergebnis nicht wichtig ist</b> <br><br>  Methoden, die in allen F√§llen den gleichen Wert erhielten, l√∂sten eine bestimmte Anzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009-</a> Warnungen aus.  In einigen F√§llen kann dies nicht kritisch sein oder der R√ºckgabewert wird im aufrufenden Code einfach nicht √ºberpr√ºft.  Ich habe solche Warnungen √ºbersprungen.  Aber ein paar Codefragmente schienen verd√§chtig.  Hier ist einer von ihnen: <br><br>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode <i>TryExecuteCommand</i> gibt nur <i>true zur√ºck</i> .  Dabei wird im aufrufenden Code der zur√ºckgegebene Wert in einige Pr√ºfungen einbezogen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es ist schwer genau zu sagen, inwieweit ein solches Verhalten gef√§hrlich ist.  Wenn das Ergebnis jedoch nicht ben√∂tigt wird, sollte der Typ des R√ºckgabewerts m√∂glicherweise in void ge√§ndert und die aufrufende Methode geringf√ºgig ge√§ndert werden.  Dadurch wird der Code lesbarer und sicherer. <br><br>  √Ñhnliche Warnungen des Analysators: <br><br><ul><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  JsonRpcClient.cs 138 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'false' zur√ºckgibt.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  ObjectList.cs 173 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  ObjectList.cs 249 </li></ul><br>  <b>√úberpr√ºfte das Falsche</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Die <i>Wertvariable</i> wird in den Typ <i>NamingStylePreferences umgewandelt</i> .  Das Problem liegt in der folgenden √úberpr√ºfung.  Selbst wenn die <i>Wertvariable</i> nicht null war, kann nicht garantiert werden, dass die Typumwandlung erfolgreich war, und <i>valueToSerialize</i> enth√§lt keine <i>Null</i> .  M√∂gliches <i>Ausl√∂sen</i> der Ausnahme <i>NullReferenceException</i> .  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Ein weiterer √§hnlicher Fehler: <br><br>  V3019 M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Die Variable <i>columnState</i> wird in den Typ <i>ColumnState2 umgewandelt</i> .  Das Operationsergebnis, bei dem es sich um die Variable <i>columnState2 handelt,</i> wird jedoch nicht weiter auf <i>null</i> gepr√ºft.  Stattdessen wird die Variable <i>columnState</i> mit dem bedingten <i>Nulloperator</i> √ºberpr√ºft.  Warum ist dieser Code gef√§hrlich?  Genau wie im vorherigen Beispiel kann das Casting mit dem Operator <i>as</i> fehlschlagen und die Variable ist <i>null,</i> was zu einer Ausnahme f√ºhrt.  √úbrigens kann hier ein Tippfehler schuld sein.  Schauen Sie sich den Zustand im <i>if-</i> Block an. <br><br>  Vielleicht wollte der Autor anstelle von <i>columnState? .Name columnState2? .Name</i> schreiben.  Es ist sehr wahrscheinlich, wenn man die ziemlich fehlerhaften Variablennamen <i>columnState</i> und <i>columnState2 ber√ºcksichtigt.</i> <br><br>  <b>Redundante Schecks</b> <br><br>  Bei unkritischen, aber m√∂glicherweise unsicheren Konstruktionen im Zusammenhang mit redundanten √úberpr√ºfungen wurde eine gro√üe Anzahl von Warnungen ausgegeben (mehr als 100).  Zum Beispiel ist dies einer von ihnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'navInfo == null' ist immer falsch.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  M√∂glicherweise gibt es hier keinen tats√§chlichen Fehler.  Dies ist nur ein guter Grund, die "Interprozedurale Analyse + Datenflussanalyse" im Schlepptau zu demonstrieren.  Der Analysator schl√§gt vor, dass die zweite Pr√ºfung <i>navInfo == null</i> redundant ist.  <i>Zuvor</i> wird der <i>NavInfo</i> zugewiesene Wert von der Methode <i>libraryService.NavInfoFactory.CreateForProject</i> abgerufen, die ein neues Objekt der <i>NavInfo-</i> Klasse erstellt und <i>zur√ºckgibt</i> .  Auf keinen Fall wird <i>null zur√ºckgegeben</i> .  Hier stellt sich die Frage, warum der Analysator keine Warnung f√ºr die erste Pr√ºfung <i>navInfo == null ausgegeben hat</i> .  Es gibt einige Gr√ºnde.  Erstens, wenn die <i>Symbolvariable</i> <i>null ist</i> , <i>bleibt</i> der <i>navInfo-</i> Wert auch eine <i>Nullreferenz</i> .  Zweitens kann dieser Wert auch <i>null sein</i> , selbst wenn <i>navInfo</i> den Wert von der Methode <i>ibraryService.NavInfoFactory.CreateForSymbol</i> erh√§lt.  Daher wird die erste Pr√ºfung <i>navInfo == null</i> wirklich ben√∂tigt. <br><br>  <b>Unzureichende Kontrollen</b> <br><br>  Nun ist die umgekehrte Situation von der oben diskutierten.  F√ºr den Code wurden mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3042-</a> Warnungen ausgel√∂st, bei denen ein Zugriff per <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> m√∂glich ist.  Sogar ein oder zwei kleine Schecks h√§tten alles reparieren k√∂nnen. <br><br>  Betrachten wir ein weiteres interessantes Codefragment, das zwei solche Fehler aufweist. <br><br>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'Empf√§nger'-Objekts Binder_Expressions.cs 7770 verwendet <br><br>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'Empf√§nger'-Objekts Binder_Expressions.cs 7776 verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Die <i>Empf√§ngervariable</i> kann null sein.  Der Autor des Codes wei√ü davon, da er den bedingten <i>Nulloperator</i> in der Bedingung des <i>if-</i> Blocks verwendet, um auf den <i>Empf√§nger</i> zuzugreifen <i>. Syntax</i> .  Ferner wird die <i>Empf√§ngervariable</i> ohne √úberpr√ºfung verwendet, um auf <i>Empf√§nger</i> zuzugreifen. Typ, <i>Empf√§nger</i> . <i>Syntax</i> und <i>Empf√§nger</i> . <i>HatErrors</i> .  Diese Fehler m√ºssen korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Wir m√ºssen auch sicherstellen, dass der Konstruktor das Abrufen von <i>Nullwerten</i> f√ºr seine Parameter unterst√ºtzt, oder wir m√ºssen zus√§tzliches Refactoring durchf√ºhren. <br><br>  Andere √§hnliche Fehler: <br><br><ul><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des Objekts 'includesType' SyntaxGeneratorExtensions_Negate.cs 240 verwendet </li><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li></ul><br>  <b>Fehler in der Bedingung</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3057</a> Die Funktion 'Teilzeichenfolge' k√∂nnte den Wert '-1' empfangen, w√§hrend ein nicht negativer Wert erwartet wird.  Untersuchen Sie das zweite Argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Wenn die <i>Doppelpunktvariable</i> 0 ist, was gem√§√ü der Bedingung im Code in <i>Ordnung ist</i> , <i>l√∂st</i> die <i>Substring-</i> Methode eine Ausnahme aus.  Dies muss behoben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>M√∂glicher Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3065 Der</a> Parameter 't2' wird im K√∂rper der Methode nicht verwendet.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Der Lambda-Ausdruck akzeptiert zwei Parameter: t1 und t2.  Es wird jedoch nur t1 verwendet.  Es sieht verd√§chtig aus, wenn man bedenkt, wie einfach es ist, bei der Verwendung von Variablen mit solchen Namen einen Fehler zu machen. <br><br>  <b>Versehen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'TagsChanged', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Das <i>TagChanged-</i> Ereignis wird auf unsichere Weise aufgerufen.  Zwischen der √úberpr√ºfung auf <i>null</i> und dem Aufrufen des Ereignisses kann sich jemand abmelden, und es wird eine Ausnahme ausgel√∂st.  Dar√ºber hinaus werden unmittelbar vor dem Aufrufen des Ereignisses andere Operationen im Hauptteil des <i>if-</i> Blocks ausgef√ºhrt.  Ich habe diesen Fehler "Versehen" genannt, weil dieses Ereignis an anderen Stellen wie folgt sorgf√§ltiger behandelt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Die Verwendung einer zus√§tzlichen <i>Handlervariablen</i> verhindert das Problem.  In der Methode <i>OnTextBufferChanged m√ºssen</i> √Ñnderungen vorgenommen werden, um das Ereignis sicher zu behandeln. <br><br>  <b>Schnittpunkte</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3092 Bereichsschnittpunkte</a> sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Lassen Sie mich zum besseren Verst√§ndnis diesen Code neu schreiben und die Namen der Konstanten mit ihren tats√§chlichen Werten √§ndern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Wahrscheinlich gibt es keinen wirklichen Fehler, aber der Zustand sieht seltsam aus.  Sein zweiter Teil ( <i>sonst wenn</i> ) wird nur f√ºr den Bereich von 2147483648 + 1 bis 4294967295 ausgef√ºhrt. <br><br>  Noch ein paar √§hnliche Warnungen: <br><br><ul><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Weitere Informationen zu √úberpr√ºfungen auf Null (oder deren Fehlen)</b> <br><br>  Einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095-</a> Fehler bei der √úberpr√ºfung einer Variablen auf Null direkt nach ihrer Verwendung.  Der erste ist nicht eindeutig, betrachten wir den Code. <br><br>  V3095 Das Objekt 'displayName' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Es wird angenommen, dass der Referenzanzeigename <i>null sein</i> kann.  Hierzu wurde die Pr√ºfung <i>Debug.Assert</i> durchgef√ºhrt.  Es ist nicht klar, warum es nach der Verwendung einer Zeichenfolge geht.  Es muss auch ber√ºcksichtigt werden, dass der Compiler bei anderen Konfigurationen als Debug <i>Debug.Assert</i> √ºberhaupt entfernt <i>.</i>  Bedeutet dies, dass das Abrufen einer Nullreferenz nur f√ºr Debug m√∂glich ist?  Wenn dies nicht der <i>Fall</i> ist, warum hat der Autor beispielsweise die <i>Zeichenfolge.IsNullOrEmpty (Zeichenfolge)</i> √ºberpr√ºft <i>?</i>  Dies ist die Frage an die Autoren des Codes. <br><br>  Der folgende Fehler ist offensichtlicher. <br><br>  V3095 Das Objekt 'scriptArgsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Ich denke, dieser Code braucht keine Erkl√§rungen.  Lassen Sie mich Ihnen die feste Version geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Im Roslyn-Code gab es 15 weitere √§hnliche Fehler: <br><br><ul><li>  V3095 Das Objekt 'LocalFunctions' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Das Objekt 'Resolution.OverloadResolutionResult' wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Das Objekt 'Resolution.MethodGroup' wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Das Objekt 'touchFilesLogger' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Das Objekt 'newExceptionRegionsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 Das 'Symbol'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Das Objekt '_state.BaseTypeOrInterfaceOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Das Objekt 'element' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Das 'Sprachen'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Das Objekt 'memberType' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Das Objekt 'validTypeDeclarations' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 Das 'Text'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 Das Objekt 'nameOrMemberAccessExpression' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 Das Objekt 'simpleName' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 Das Objekt 'option' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 23, 28. OptionKey.cs 23 </li></ul><br>  Betrachten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3105-</a> Fehler.  Hier wird der bedingte <i>Nulloperator</i> beim Initialisieren der Variablen verwendet, aber weiterhin wird die Variable ohne Pr√ºfung auf <i>Null verwendet</i> . <br><br>  Zwei Warnungen weisen auf folgenden Fehler hin: <br><br>  V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist m√∂glich.  CodeLensReferencesService.cs 138 <br><br>  V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist m√∂glich.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  Die Variable <i>documentId</i> kann mit <i>null</i> initialisiert werden.  Wenn Sie ein Objekt <i>ReferenceLocationDescriptor</i> erstellen, wird eine Ausnahme ausgel√∂st.  Der Code muss behoben sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Entwickler sollten auch die M√∂glichkeit abdecken, dass Variablen, die an einen Konstruktor √ºbergeben werden, <i>null sind.</i> <br><br>  Andere √§hnliche Fehler im Code: <br><br><ul><li>  V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist m√∂glich.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde.  NullReferenceException ist m√∂glich.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Priorit√§ten und Klammern</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3123</a> Vielleicht arbeitet der Operator '?:' Anders als erwartet.  Ihre Priorit√§t ist niedriger als die Priorit√§t anderer Betreiber in ihrem Zustand.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  Die Bedingung im R√ºckgabeblock wird nicht wie vom Entwickler beabsichtigt ausgewertet.  Es wurde angenommen, dass die erste Bedingung <i>_kind == other._kin</i> d ist (aus diesem Grund gibt es nach dieser Bedingung einen Zeilenumbruch), und danach werden die Bedingungsbl√∂cke mit dem Operator " <i>?</i> " Nacheinander ausgewertet.  Tats√§chlich ist die erste Bedingung <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Dies liegt an der Tatsache, dass der Operator <i>&amp;&amp;</i> eine h√∂here Priorit√§t als der Operator " <i>?</i> " <i>Hat</i> .  Um dies zu beheben, sollte ein Entwickler alle Ausdr√ºcke des Operators " <i>?</i> " In Klammern setzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Damit ist meine Beschreibung der gefundenen Fehler abgeschlossen. <br><br>  <b>Fazit</b> <br><br>  Trotz der gro√üen Anzahl von Fehlern, die ich in Bezug auf die Gr√∂√üe des Roslyn-Projektcodes (2.770.000 Zeilen) gefunden habe, ist es nicht zu viel.  Wie Andrey in einem fr√ºheren Artikel schrieb, bin ich auch bereit, die hohe Qualit√§t dieses Projekts anzuerkennen. <br><br>  Ich m√∂chte darauf hinweisen, dass solche gelegentlichen Codepr√ºfungen nichts mit der Methodik der statischen Analyse zu tun haben und fast nicht hilfreich sind.  Statische Analysen sollten regelm√§√üig und nicht von Fall zu Fall durchgef√ºhrt werden.  Auf diese Weise werden viele Fehler in den fr√ºhesten Stadien korrigiert, und daher sind die Kosten f√ºr deren Behebung zehnmal geringer.  Diese Idee wird in dieser kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Notiz</a> ausf√ºhrlicher beschrieben. Bitte probieren Sie sie aus. <br><br>  Sie k√∂nnen einige Fehler sowohl in diesem als auch in einem anderen Projekt √ºberpr√ºfen.  Dazu m√ºssen Sie nur unseren Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> und ausprobieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446588/">https://habr.com/ru/post/de446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446572/index.html">Editor.js ist ein ausgezeichneter Editor, der Quellcode im JSON-Format speichert</a></li>
<li><a href="../de446576/index.html">Importsubstitution oder wie russische Hubschrauber etwas falsch gemacht haben</a></li>
<li><a href="../de446578/index.html">Postkartenbasierte Programmiersprache</a></li>
<li><a href="../de446582/index.html">√úberlegungen zum Solar Hosting f√ºr Bienen</a></li>
<li><a href="../de446586/index.html">Netzwerkeinstellungen von FreeRadius √ºber DHCP</a></li>
<li><a href="../de446590/index.html">39 neue Funktionen in Java 12</a></li>
<li><a href="../de446592/index.html">√úberpr√ºfen des Quellcodes von Roslyn</a></li>
<li><a href="../de446598/index.html">Neuerstellen von CRT-Schriftarten</a></li>
<li><a href="../de446602/index.html">Maximaler Gleichstrom durch Feldeffekttransistor</a></li>
<li><a href="../de446604/index.html">ESET: Neue Backdoor-Lieferprogramme f√ºr OceanLotus Cybergroup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>