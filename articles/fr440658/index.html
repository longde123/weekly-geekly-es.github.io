<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 🔔 🚼 Exploration de Docker, partie 4: réduction de la taille des images et accélération de leur assemblage 🍷 🤸🏾 👩🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cette partie de la traduction de la série Docker, nous parlerons de la façon d'optimiser les tailles d'image et d'accélérer l'assemblage. Dans le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exploration de Docker, partie 4: réduction de la taille des images et accélération de leur assemblage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440658/">  Dans cette partie de la traduction de la série Docker, nous parlerons de la façon d'optimiser les tailles d'image et d'accélérer l'assemblage.  Dans les documents précédents, nous avons comparé les images Docker avec de la pizza, les termes avec des beignets et les instructions Dockerfile avec des bagels.  Aujourd'hui, il n'y aura pas de cuisson.  Il est temps de suivre un régime. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: les bases</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: termes et concepts</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: Fichiers Dockerfile</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: réduire la taille des images et accélérer leur assemblage</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: équipes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 6: travailler avec des données</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d1/a39/97f/4d1a3997f86da202d60bfbfb882efb9e.jpg"></div><br>  Afin de comprendre de quoi nous allons parler ici, il vous sera utile de rafraîchir la mémoire de ce qui a été discuté dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisième partie de</a> cette série de documents.  À savoir, nous avons parlé des instructions sur les fichiers Dockerfile.  Connaître ces instructions et les fonctionnalités de Docker dont nous discutons aujourd'hui vous aidera à optimiser les fichiers image Docker. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mise en cache</font> </h2><br>  L'une des forces de Docker est la mise en cache.  Grâce à ce mécanisme, l'assemblage des images est accéléré. <br><br>  Lors de l'assemblage d'une image Docker, il suit les instructions du Dockerfile, en les suivant dans l'ordre.  Dans le processus d'analyse des instructions, Docker vérifie son propre cache pour les images, ce que nous obtenons aux étapes intermédiaires de l'assemblage d'autres images.  Si de telles images peuvent être trouvées, le système peut les utiliser sans perdre de temps à les recréer. <br><br>  Si le cache est invalidé, l'instruction pendant laquelle il s'est produit s'exécute, créant une nouvelle couche sans utiliser le cache.  La même chose se produit lors de l'exécution des instructions qui la suivent. <br><br>  Par conséquent, si lors de l'exécution des instructions du Dockerfile, il s'avère que l'image de base est dans le cache, alors cette image du cache est utilisée.  C'est ce qu'on appelle un accès au cache.  Si l'image de base n'est pas dans le cache, alors tout le processus d'assemblage d'images se déroulera sans utiliser le cache. <br><br>  Ensuite, l'instruction suivante est comparée à toutes les images du cache, qui sont basées sur la même image de base qui se trouve déjà dans le cache.  Chaque image intermédiaire mise en cache est vérifiée pour voir si elle contient ce qui a été créé par la même instruction.  Si aucune correspondance ne peut être trouvée, cela s'appelle un «échec de cache» et le cache est considéré comme invalide.  La même chose se produit jusqu'à ce que le Dockerfile entier soit traité. <br><br>  La plupart des nouvelles instructions sont simplement comparées à celles déjà présentes dans les images intermédiaires.  Si le système parvient à trouver une correspondance, l'assembly utilise ce qui se trouve déjà dans le cache. <br><br>  L'utilisation d'un cache peut accélérer l'assemblage d'images, mais il y a un problème.  Par exemple, si une instruction <code>RUN pip install -r requirements.txt</code> se trouve dans le Dockerfile, Docker recherche la même instruction dans son cache local d'images intermédiaires.  Toutefois, le contenu des anciennes et nouvelles versions du fichier <code>requirements.txt</code> n'est pas comparé. <br><br>  Cela peut entraîner des problèmes si des informations sur les nouveaux packages ont été ajoutées à <code>requirements.txt</code> , après quoi, lors de la création de l'image mise à jour, pour installer un nouvel ensemble de packages, vous devez exécuter à nouveau l'instruction d' <code>RUN pip install</code> .  Nous parlerons bientôt de la façon de traiter ce problème. <br><br>  Contrairement à d'autres instructions Docker, lors de l'exécution des instructions <code>ADD</code> et <code>COPY</code> , Docker doit vérifier le contenu du ou des fichiers pour déterminer s'il est possible d'utiliser le cache lors de la création de l'image.  A savoir, la somme de contrôle des fichiers mentionnés dans ces instructions est comparée à la somme de contrôle des fichiers qui se trouvent dans les images intermédiaires qui sont déjà dans le cache.  Si le contenu des fichiers ou leurs métadonnées a changé, le cache est invalidé. <br><br>  Voici quelques conseils pour tirer parti du cache Docker: <br><br><ul><li>  La mise en cache peut être désactivée en passant le commutateur <code>--no-cache=True</code> à la <code>docker build</code> . </li><li>  Si vous souhaitez apporter des modifications aux instructions Dockerfile, chaque couche créée par les instructions venant après celles modifiées sera réassemblée assez souvent, sans utiliser de cache.  Pour tirer parti de la mise en cache, placez les instructions susceptibles de changer le plus près possible de la fin du Dockerfile. </li><li>  Combinez les commandes <code>RUN apt-get update</code> et <code>apt-get install</code> en chaînes pour éviter les problèmes associés à une mauvaise utilisation du cache. </li><li>  Si vous utilisez des gestionnaires de packages, comme <code>pip</code> , avec le fichier <code>requirements.txt</code> , respectez le schéma ci-dessous pour exclure l'utilisation d'images intermédiaires obsolètes du cache contenant l'ensemble des packages répertoriés dans l'ancienne version du fichier <code>requirements.txt</code> .  Voici à quoi ça ressemble: <br><br><pre> <code class="bash hljs">COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt COPY . /tmp/</code> </pre> </li></ul><br>  Si vous connaissez d'autres façons de traiter le «problème requirements.txt», vous pouvez en parler dans les commentaires. <br><br><h2>  <font color="#3AC1EF">Réduire la taille des images</font> </h2><br><h3>  <font color="#3AC1EF">▍ Sélection rigoureuse de l'image de base</font> </h3><br>  Les images Docker peuvent être assez volumineuses.  Cela contredit le désir bien fondé de la personne qui les crée de les rendre aussi compacts que possible, ce qui facilitera leur téléchargement à partir d'un référentiel distant et aura un effet bénéfique sur la quantité d'espace libre sur l'ordinateur sur lequel ils sont chargés.  Parlons de la façon de réduire leur taille. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbe/87c/ea4/dbe87cea4a1c04e25bd2becd194e34d8.jpg"></div><br>  <i><font color="#999999">Au lieu de bagels et beignets, nous allons maintenant manger des verts</font></i> <br><br>  Une façon de réduire la taille des images est de sélectionner soigneusement les images de base et leur réglage ultérieur. <br><br>  Par exemple, l'image Alpine de base est une distribution complète d'un système d'exploitation de type Linux, contenant un minimum de packages supplémentaires.  Sa taille est d'environ 5 mégaoctets.  Cependant, la construction de votre propre image basée sur Alpine nécessitera beaucoup de temps pour l'équiper de tout le nécessaire pour assurer le fonctionnement d'une certaine application. <br><br>  Il existe également des versions spécialisées de l'image alpine de base.  Par exemple, l'image correspondante du référentiel python dans laquelle le script <code>print("hello world")</code> est conditionné pèse environ 78,5 Mo.  Voici le Dockerfile pour construire une telle image: <br><br><pre> <code class="bash hljs">FROM python:3.7.2-alpine3.8 COPY . /app ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"python"</span></span>, <span class="hljs-string"><span class="hljs-string">"./app/my_script.py"</span></span>, <span class="hljs-string"><span class="hljs-string">"my_var"</span></span>]</code> </pre> <br>  Dans le même temps, le Docker Hub indique que cette image de base a une taille de 29 Mo.  La taille d'une image basée sur cette image de base est augmentée en téléchargeant et en installant Python. <br><br>  En plus d'utiliser des images de base basées sur Alpine, vous pouvez réduire la taille des images grâce à l'utilisation de la technologie d'assemblage en plusieurs étapes. <br><br><h3>  <font color="#3AC1EF">▍ Assemblage d'images en plusieurs étapes</font> </h3><br>  Le Dockerfile, qui décrit l'assemblage en plusieurs étapes d'une image, utilise plusieurs instructions <code>FROM</code> .  Le créateur d'une telle image peut configurer la copie sélective de fichiers appelés artefacts de génération d'un niveau de génération à un autre.  En même temps, il devient possible de se débarrasser de tout ce qui n'est pas nécessaire dans l'image finie.  Grâce à cette méthode, vous pouvez réduire la taille de l'image finie. <br><br>  Voici comment fonctionne chaque instruction <code>FROM</code> : <br><br><ul><li>  Elle commence une nouvelle étape de construction. </li><li>  Cela ne dépend pas de ce qui a été créé à l'étape de génération précédente. </li><li>  Elle peut utiliser une image de base différente de celle utilisée à l'étape précédente. </li></ul><br>  Voici un exemple modifié d'un Dockerfile de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> Docker décrivant une construction en plusieurs étapes. <br><br><pre> <code class="bash hljs">FROM golang:1.7.3 AS build WORKDIR /go/src/github.com/alexellis/href-counter/ RUN go get -d -v golang.org/x/net/html COPY app.go . RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=build /go/src/github.com/alexellis/href-counter/app . CMD [<span class="hljs-string"><span class="hljs-string">"./app"</span></span>]</code> </pre> <br>  Veuillez noter que nous avons donné le nom de la première étape de l'assemblage, en le spécifiant après la déclaration <code>FROM</code> .  Nous nous référons à la phase de construction nommée dans l' <code>COPY --from=</code> ci-dessous dans le Dockerfile. <br><br>  L'utilisation du processus d'assemblage d'images en plusieurs étapes est logique dans certains cas lorsque vous devez créer de nombreux conteneurs pour l'environnement de production.  L'assemblage en plusieurs étapes vous permet de minimiser la taille de l'image finie.  Mais parfois cette approche complique le support des images.  Par conséquent, vous n'utiliserez probablement pas d'assemblage d'images en plusieurs étapes dans les cas où vous pouvez vous en passer.  Vous pouvez découvrir les caractéristiques de cette technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Comme vous pouvez le voir, l'assemblage en plusieurs étapes est une technologie intéressante, mais elle ne convient pas à tous les cas.  La même manière de réduire la taille des images, dont nous parlerons ci-dessous, peut être recommandée à tout le monde. <br><br><h3>  <font color="#3AC1EF">▍ Fichier .dockerignore</font> </h3><br>  Absolument tous ceux qui veulent apprendre Docker doivent connaître les fichiers <code>.dockerignore</code> .  Ces fichiers sont similaires aux fichiers <code>.gitignore</code> .  Ils contiennent une liste de fichiers et de dossiers, sous forme de noms ou de modèles que Docker doit ignorer lors de l'assemblage d'images. <br><br>  Ce fichier est placé à l'emplacement du Dockerfile et de tout le reste inclus dans le contexte de l'assemblage d'image. <br><br>  Lorsque vous exécutez la <code>docker build</code> , qui lance l'assemblage de l'image, Docker vérifie la présence du fichier <code>.dockerignore</code> dans le dossier.  Si un tel fichier peut être trouvé, ce fichier est analysé et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règles de</a> la fonction <code>Match()</code> du package <code>filepath</code> Go et certaines de ses propres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règles</a> Docker sont utilisées pour déterminer la liste des fichiers à ignorer. <br><br>  Ainsi, par exemple, si un modèle de la forme <code>*.jpg</code> trouvé dans le fichier <code>.dockerignore</code> , alors lors de la création d'une image, les fichiers avec n'importe quel nom et avec l'extension <code>.jpg</code> seront ignorés.  Si la chaîne <code>videos</code> dans le fichier, le système ignorera le dossier <code>videos</code> et tout son contenu. <br><br>  Lors de la compilation d'un fichier <code>.dockerignore</code> , vous pouvez le commenter à l'aide du symbole <code>#</code> . <br><br>  Voici ce que le fichier <code>.dockerignore</code> donne à quiconque crée des images Docker: <br><br><ul><li>  Cela vous permet d'exclure des fichiers image contenant des informations sensibles comme les connexions et les mots de passe. </li><li>  Cela vous permet de réduire la taille de l'image.  Plus les fichiers de l'image sont petits, plus sa taille sera petite et plus il sera rapide de travailler avec elle. </li><li>  Cela permet de réduire le nombre de raisons d'invalider le cache lors de l'assemblage d'images similaires.  Par exemple, si pendant le réassemblage de l'image certains fichiers de service du projet changent, comme les fichiers journaux, en raison desquels les données stockées dans le cache sont, par essence, déraisonnablement invalides, cela ralentit l'assemblage des images. </li></ul><br>  <code>.dockerignore</code> pouvez en savoir plus sur le fichier <code>.dockerignore</code> dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> Docker. <br><br><h2>  <font color="#3AC1EF">Recherche sur la taille de l'image</font> </h2><br>  Voyons comment utiliser les outils de ligne de commande pour connaître les tailles d'images et de conteneurs Docker. <br><br><ul><li>  Pour connaître la taille approximative d'un conteneur en cours d'exécution, vous pouvez utiliser une commande du formulaire <code>docker container ls -s</code> . </li><li>  La <code>docker image ls</code> affiche <code>docker image ls</code> tailles d' <code>docker image ls</code> . </li><li>  Vous pouvez utiliser la commande <code>docker image history my_image:my_tag</code> connaître les tailles d'images intermédiaires à partir desquelles une certaine image est assemblée. </li><li>  La commande <code>docker image inspect my_image:tag</code> vous permet de trouver des informations détaillées sur l'image, y compris la taille de chacun de ses calques.  Les calques sont légèrement différents des images intermédiaires qui composent l'image finie, mais, dans la plupart des cas, ils peuvent être considérés comme des entités identiques.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> du bon matériel sur les détails de la structure interne des images Docker. </li><li>  Afin d'examiner le contenu des conteneurs, vous pouvez installer le package de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plongée</a> . </li></ul><br>  Maintenant que nous avons discuté des possibilités de réduire la taille des images, j'attire votre attention sur huit recommandations concernant la réduction de la taille des images et l'accélération du processus d'assemblage. <br><br><h2>  <font color="#3AC1EF">Recommandations pour réduire la taille des images et accélérer le processus d'assemblage</font> </h2><br><ol><li>  Dans la mesure du possible, utilisez des images officielles comme images de base.  Les images officielles sont régulièrement mises à jour, elles sont plus sûres que les images informelles. </li><li>  Afin de collecter des images aussi compactes que possible, utilisez des images de base basées sur Alpine Linux. </li><li>  Si vous utilisez <code>apt</code> , combinez les commandes <code>apt-get update</code> et <code>apt-get install</code> dans une seule instruction <code>RUN</code> .  De plus, combinez les commandes d'installation des packages en une seule instruction.  Liste les packages par ordre alphabétique sur plusieurs lignes, en séparant la liste par <code>\</code> .  Par exemple, cela pourrait ressembler à ceci: <br><br><pre> <code class="bash hljs">RUN apt-get update &amp;&amp; apt-get install -y \   package-one \   package-two \   package-three &amp;&amp; rm -rf /var/lib/apt/lists/*</code> </pre> <br>  Cette méthode réduit le nombre de couches à ajouter à l'image et permet de conserver le code du fichier sous une forme décente. </li><li>  Incluez une construction comme <code>&amp;&amp; rm -rf /var/lib/apt/lists/*</code> à la fin de l'instruction <code>RUN</code> utilisée pour installer les packages.  Cela <code>apt</code> cache <code>apt</code> et entraînera qu'il ne sera pas enregistré dans la couche formée par la commande <code>RUN</code> .  Des détails à ce sujet peuvent être trouvés dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . </li><li>  Utilisez judicieusement vos capacités de mise en cache en plaçant dans le Dockerfile des commandes susceptibles de changer vers la fin du fichier. </li><li>  Utilisez le fichier <code>.dockerignore</code> . </li><li>  Jetez un œil à la <code>dive</code> , un excellent outil pour explorer les images Docker qui aide à réduire leur taille. </li><li>  N'installez pas de paquets dont vous pouvez vous passer. </li></ol><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Vous savez maintenant comment assembler rapidement les images Docker, les charger rapidement à partir des référentiels et ne pas occuper trop d'espace informatique.  La prochaine fois, nous parlerons des équipes Docker. <br><br>  <b>Chers lecteurs!</b>  Avez-vous rencontré des problèmes avec les mécanismes de mise en cache lors de la création d'images Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440658/">https://habr.com/ru/post/fr440658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440648/index.html">Aperçu de la législation russe dans le domaine de l'accessibilité du Web</a></li>
<li><a href="../fr440650/index.html">Comment fonctionne la conscience: conclusions du livre d'Alexandre Nevzorov</a></li>
<li><a href="../fr440652/index.html">Vidéo calculée en 755 mégapixels: plénoptique hier, aujourd'hui et demain</a></li>
<li><a href="../fr440654/index.html">Apprendre Python: module argparse</a></li>
<li><a href="../fr440656/index.html">Conteneurisation professionnelle des applications Node.js à l'aide de Docker</a></li>
<li><a href="../fr440660/index.html">Learning Docker, Partie 5: Commandes</a></li>
<li><a href="../fr440662/index.html">Tutoriel React Partie 18: La sixième phase de travail sur une application TODO</a></li>
<li><a href="../fr440666/index.html">Classification des dessins manuscrits. Signaler dans Yandex</a></li>
<li><a href="../fr440670/index.html">La Banque centrale a publié des recommandations sur la protection cryptographique d'EBS</a></li>
<li><a href="../fr440672/index.html">Méthodes de rationalité et tapis de prière du Maghreb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>