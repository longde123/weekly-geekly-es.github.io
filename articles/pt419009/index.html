<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöø üë©‚Äçüë¶ üóÇÔ∏è clang e IDE: uma hist√≥ria sobre amizade e amizade üèÇüèΩ ‚ô®Ô∏è üéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para mim, come√ßou seis anos e meio atr√°s, quando, pela vontade do destino, fui atra√≠do para um projeto fechado. Cujo projeto - n√£o pergunte, n√£o vou c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>clang e IDE: uma hist√≥ria sobre amizade e amizade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419009/"><p><img src="https://habrastorage.org/webt/yi/u_/xb/yiu_xbaeyduzvwqklgpu5xujgvo.png" align="left">  Para mim, come√ßou seis anos e meio atr√°s, quando, pela vontade do destino, fui atra√≠do para um projeto fechado.  Cujo projeto - n√£o pergunte, n√£o vou contar.  S√≥ posso dizer que a ideia dele era simples como um ancinho: incorporar o front-end do clang no IDE.  Bem, como foi feito recentemente no QtCreator, no CLion (em certo sentido), etc. Clang era ent√£o uma estrela em ascens√£o, muitos estavam pensando na possibilidade de finalmente usar o analisador C ++ completo quase de gra√ßa.  E a ideia, por assim dizer, estava literalmente no ar (e o preenchimento autom√°tico do c√≥digo incorporado na API do clang foi sugerido por Be), voc√™ s√≥ precisava peg√°-lo e faz√™-lo.  Mas, como Boromir disse: "Voc√™ n√£o pode simplesmente aceitar e ...".  Ent√£o aconteceu neste caso.  Para detalhes - Wellcome sob cat. </p><a name="habracut"></a><br><h2 id="snachala-o-horoshem">  Primeiro sobre o bem </h2><br><p>  Os benef√≠cios de usar o clang como um analisador interno no IDE C ++, √© claro.  No final, as fun√ß√µes do IDE n√£o se limitam apenas √† edi√ß√£o de arquivos.  Este √© um banco de dados de caracteres, tarefas de navega√ß√£o, depend√™ncias e muito mais.  E aqui um compilador de pleno direito dirige-se √† sua altura m√°xima, porque dominar todo o poder do pr√©-processador e modelos em um analisador auto-escrito relativamente simples √© uma tarefa n√£o trivial.  Como voc√™ geralmente precisa fazer muitos compromissos, o que obviamente afeta a qualidade da an√°lise de c√≥digo.  Quem se importa - pode ver, por exemplo, o analisador interno do QtCeator aqui: analisador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qt Creator C ++</a> </p><br><p>  No mesmo local, no c√≥digo-fonte do QtCreator, voc√™ pode ver que o acima n√£o √© tudo o que o IDE requer do analisador.  Al√©m disso, voc√™ precisa de pelo menos: </p><br><ul><li>  realce de sintaxe (lexical e sem√¢ntico) </li><li>  todos os tipos de dicas "on the fly" com a exibi√ß√£o de informa√ß√µes no s√≠mbolo </li><li>  dicas sobre o que h√° de errado com o c√≥digo e como corrigi-lo / complement√°-lo </li><li>  Conclus√£o de c√≥digo em uma ampla variedade de contextos </li><li>  a refatora√ß√£o mais diversificada </li></ul><br><p>  Portanto, nos benef√≠cios listados anteriormente (realmente s√©rio!), As vantagens terminam e a dor come√ßa.  Para entender melhor essa dor, primeiro voc√™ pode ver o relat√≥rio de Anastasia Kazakova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">anastasiak2512</a> ) sobre o que √© realmente necess√°rio no analisador de c√≥digo incorporado no IDE: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4giOynD7Emg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="sut-problemy">  A ess√™ncia do problema </h2><br><p>  Mas √© simples, embora possa n√£o ser √≥bvio √† primeira vista.  Em poucas palavras, ent√£o: clang √© um <em>compilador</em> .  E refere-se ao c√≥digo como um <em>compilador</em> .  E agu√ßado pelo fato de que o c√≥digo foi fornecido a ele j√° conclu√≠do, e n√£o o esbo√ßo do arquivo que agora est√° aberto no editor do IDE.  Os compiladores n√£o gostam de bits de arquivos, como constru√ß√µes incompletas, identificadores escritos incorretamente, <strong>retrunde em</strong> vez de <strong>retornar</strong> e outras del√≠cias que podem surgir aqui e agora no editor.  Obviamente, antes da compila√ß√£o, tudo isso ser√° limpo, consertado e alinhado.  Mas aqui e agora, no editor, √© o que √©.  E √© dessa forma que o analisador incorporado no IDE chega √† tabela a cada 5-10 segundos.  E se a vers√£o auto-escrita dele "entende perfeitamente" que est√° lidando com um produto semi-acabado, ent√£o clang - n√£o.  E muito surpreso.  O que acontece como resultado de tal surpresa depende "de", como eles dizem. </p><br><p>  Felizmente, o clang √© bastante tolerante a erros de c√≥digo.  No entanto, pode haver surpresas - luz de fundo desaparecendo repentinamente, curva de preenchimento autom√°tico, diagn√≥stico estranho.  Voc√™ precisa estar preparado para tudo isso.  Al√©m disso, o clang n√£o √© on√≠voro.  Ele tem o direito de n√£o aceitar nada nos cabe√ßalhos do compilador, que aqui e agora √© usado para criar o projeto.  Intr√≠nsecas complicadas, extens√µes n√£o padr√£o e outras, um ..., recursos - tudo isso pode levar a erros de an√°lise nos locais mais inesperados.  E, claro, desempenho.  Editar um arquivo de gram√°tica no Boost.Spirit ou trabalhar em um projeto baseado no llvm ser√° um prazer.  Mas, sobre tudo em mais detalhes. </p><br><h2 id="kod-polufabrikat">  C√≥digo pr√©-fabricado </h2><br><p>  Ent√£o, digamos que voc√™ iniciou um novo projeto.  Seu ambiente gerou um espa√ßo em branco padr√£o para main.cpp e nele voc√™ escreveu: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { foo(10) }</span></span></span></span></code> </pre> <br><p>  O c√≥digo, do ponto de vista do C ++, francamente, √© inv√°lido.  N√£o h√° defini√ß√£o da fun√ß√£o foo (...) no arquivo, a linha n√£o est√° conclu√≠da, etc. Mas ... Voc√™ acabou de iniciar.  Este c√≥digo tem direito a esse tipo.  Como esse c√≥digo percebe um IDE com um analisador auto-escrito (neste caso, CLion)? </p><br><p><img src="https://habrastorage.org/webt/us/8y/ni/us8yni2bzf5zpm6epgx_uh7m4bs.png"></p><br><p>  E se voc√™ clicar na l√¢mpada, poder√° ver o seguinte: </p><br><p><img src="https://habrastorage.org/webt/p2/ej/h4/p2ejh4woiuojsq19oq90rmozhrm.png"></p><br><p>  Esse IDE, sabendo algo, um pouco mais sobre o que est√° acontecendo, oferece a op√ß√£o muito esperada: criar uma fun√ß√£o a partir do contexto de uso.  √ìtima oferta, eu acho.  Como o IDE baseado em clang se comporta (neste caso, Qt Creator 4.7)? </p><br><p><img src="https://habrastorage.org/webt/ql/pa/hj/qlpahj0vu5of_my6s1ymrelsa3o.png"></p><br><p>  E o que est√° sendo proposto para corrigir a situa√ß√£o?  Mas nada!  Somente renomear padr√£o! </p><br><p><img src="https://habrastorage.org/webt/kk/0m/pt/kk0mptuuwnufqjugzumnoisnyms.png"></p><br><p>  A raz√£o para esse comportamento √© muito simples: para clang, esse texto est√° completo (e n√£o pode ser mais nada).  E ele constr√≥i o AST com base nessa suposi√ß√£o.  E ent√£o tudo √© simples: o clang v√™ um identificador indefinido anteriormente.  Este √© um texto em C ++ (n√£o em C).  Nenhuma suposi√ß√£o √© feita sobre a natureza do identificador - ele n√£o est√° definido, portanto, um peda√ßo de c√≥digo √© inv√°lido.  E no AST para esta linha nada aparece.  Ela simplesmente n√£o est√° l√°.  E o que n√£o est√° no AST √© imposs√≠vel de analisar.  √â uma pena, irritante, tudo bem. </p><br><p>  O analisador incorporado no IDE vem de algumas outras suposi√ß√µes.  Ele <em>sabe</em> que o c√≥digo n√£o est√° conclu√≠do.  Que o programador est√° agora apressando o pensamento e os dedos atr√°s dela n√£o t√™m tempo.  Portanto, nem todos os identificadores podem ser definidos.  √â claro que esse c√≥digo est√° incorreto do ponto de vista dos altos padr√µes de qualidade do compilador, mas o analisador sabe o que pode ser feito com esse c√≥digo e oferece op√ß√µes.  Op√ß√µes bastante razo√°veis. </p><br><p>  Pelo menos at√© a vers√£o 3.7 (inclusive), problemas semelhantes ocorreram neste c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Temp { public: int i; }; template&lt;typename T&gt; class Foo { public: int Bar(Temp tmp) { Tpl(tmp); } private: template&lt;typename U&gt; void Tpl(U val) { Foo&lt;U&gt; tmp(val); tmp. } int member; }; int main() { return 0; }</span></span></span></span></code> </pre> <br><p>  Dentro dos m√©todos da classe de modelo, o preenchimento autom√°tico baseado em clang n√£o funcionou.  Tanto quanto eu consegui descobrir, o motivo estava na an√°lise de modelos de duas passagens.  O preenchimento autom√°tico no clang √© acionado na primeira passagem, quando as informa√ß√µes sobre os tipos realmente usados ‚Äã‚Äãpodem n√£o ser suficientes.  No clang 5.0 (a julgar pelas notas de vers√£o), isso foi corrigido. </p><br><p>  De uma maneira ou de outra, podem ser situa√ß√µes em que o compilador n√£o √© capaz de criar o AST correto (ou tirar as conclus√µes corretas do contexto) no c√≥digo editado.  E, nesse caso, o IDE simplesmente n√£o "ver√°" as se√ß√µes correspondentes do texto e n√£o poder√° ajudar o programador de nenhuma maneira.  O que, √© claro, n√£o √© √≥timo.  A capacidade de trabalhar efetivamente com c√≥digo incorreto √© o que o analisador precisa no IDE e o que o compilador comum n√£o precisa.  Portanto, o analisador no IDE pode usar muitas heur√≠sticas, que para o compilador podem ser n√£o apenas in√∫teis, mas tamb√©m prejudiciais.  E para implementar dois modos de opera√ß√£o nele - bem, voc√™ ainda precisa convencer os desenvolvedores. </p><br><h2 id="eta-rol---rugatelnaya">  "Este papel √© abusivo!" </h2><br><p>  O IDE do programador geralmente √© um (bem, dois), mas h√° muitos projetos e cadeias de ferramentas.  E, √© claro, n√£o quero fazer gestos extras para mudar da cadeia de ferramentas para a cadeia de ferramentas, de projeto para projeto.  Um ou dois cliques, e a configura√ß√£o da compila√ß√£o muda de Debug para Release, e o compilador de MSVC para MinGW.  Mas o analisador de c√≥digo no IDE permanece o mesmo.  E ele deve, juntamente com o sistema de compila√ß√£o, alternar de uma configura√ß√£o para outra, de uma cadeia de ferramentas para outra.  Uma cadeia de ferramentas pode ser algum tipo de ex√≥tica ou cruzada.  E a tarefa do analisador aqui √© continuar analisando corretamente o c√≥digo.  Se poss√≠vel com um m√≠nimo de erros. </p><br><p>  o clang √© on√≠voro o suficiente.  Ele pode ser for√ßado a aceitar extens√µes do compilador da Microsoft, o compilador gcc.  Podem ser passadas op√ß√µes no formato desses compiladores, e o clang at√© as entender√°.  Mas tudo isso n√£o garante que o clang aceite qualquer posi√ß√£o das miudezas coletadas no tanque gcc.  Qualquer __builtin_intrinsic_xxx pode se tornar uma pedra de trope√ßo para ele.  Ou a linguagem constr√≥i que a vers√£o atual do clang no IDE simplesmente n√£o suporta.  Provavelmente, isso n√£o afetar√° a qualidade da constru√ß√£o do AST para o arquivo editado no momento.  Mas construir uma base global de caracteres ou salvar cabe√ßalhos pr√©-compilados pode quebrar.  E isso pode ser um problema s√©rio.  Um problema semelhante pode vir a ser um c√≥digo semelhante, n√£o nos cabe√ßalhos das cadeias de ferramentas ou de terceiros, mas nos cabe√ßalhos ou nos c√≥digos-fonte do projeto.  A prop√≥sito, tudo isso √© uma raz√£o suficientemente significativa para informar explicitamente ao sistema de compila√ß√£o (e IDE) sobre quais arquivos de cabe√ßalho para o seu projeto s√£o "estranhos".  Pode facilitar a vida. </p><br><p>  Novamente, o IDE foi originalmente projetado para ser usado com diferentes compiladores, configura√ß√µes, cadeias de ferramentas e muito mais.  Projetado para lidar com c√≥digo, cujos elementos n√£o s√£o suportados.  O ciclo de lan√ßamento do IDE (nem todos :)) √© mais curto que o dos compiladores; portanto, existe o potencial de atrair novos recursos mais rapidamente e responder aos problemas encontrados.  No mundo dos compiladores, tudo √© um pouco diferente: o ciclo de lan√ßamento √© de pelo menos um ano, os problemas de compatibilidade entre compiladores s√£o resolvidos por compila√ß√£o condicional e repassados ‚Äã‚Äãaos ombros do desenvolvedor.  O compilador n√£o precisa ser universal e on√≠voro - sua complexidade j√° √© alta.  clang n√£o √© exce√ß√£o. </p><br><h2 id="borba-za-skorost">  A luta pela velocidade </h2><br><p>  Na parte do tempo gasto no IDE, quando o programador n√£o est√° sentado no depurador, ele edita o texto.  E seu desejo natural aqui √© torn√°-lo confort√°vel (caso contr√°rio, por que um IDE? Posso conviver com um bloco de notas!) O conforto, em particular, envolve a alta velocidade de rea√ß√£o do editor √†s altera√ß√µes de texto e pressionamento de teclas de atalho.  Como Anastasia observou corretamente em seu relat√≥rio, se cinco segundos depois de pressionar Ctrl + Space, o ambiente n√£o respondeu com a apar√™ncia de um menu ou de uma lista do preenchimento autom√°tico, isso √© terr√≠vel (s√©rio, tente voc√™ mesmo).  Em n√∫meros, isso significa que o analisador embutido no IDE tem cerca de um segundo para avaliar as altera√ß√µes no arquivo e reconstruir o AST, e outro e meio ou dois para oferecer ao desenvolvedor uma op√ß√£o sens√≠vel ao contexto.  Segundo.  Bem, talvez dois.  Al√©m disso, o comportamento esperado √© que, se o desenvolvedor alterou o apelido .h e depois mudou para o .cpp-shnik, as altera√ß√µes feitas ser√£o "vis√≠veis".  Os arquivos, aqui est√£o eles, abertos nas janelas vizinhas.  E agora um c√°lculo simples.  Se o clang, iniciado a partir da linha de comando, pode lidar com o c√≥digo-fonte em cerca de dez a vinte segundos, onde est√° o motivo para acreditar que, quando iniciado a partir do IDE, ele lidar√° com o c√≥digo-fonte muito mais r√°pido e se encaixar√° nesse segundo ou dois?  Ou seja, funcionar√° uma ordem de magnitude mais r√°pido?  Em geral, isso pode estar terminado, mas n√£o vou. </p><br><p>  Cerca de dez a vinte segundos para a fonte, √© claro, eu exagerei.  Embora, se alguma API pesada seja inclu√≠da l√° ou, por exemplo, boost.spirit com Hana pronto, e tudo isso seja usado ativamente no texto, 10 a 20 segundos ainda ser√£o bons valores.  Mas mesmo que o AST esteja pronto segundos depois de tr√™s ou quatro ap√≥s o lan√ßamento do analisador interno - j√° √© muito tempo.  Desde que esses lan√ßamentos devam ser t√£o regulares (para manter o modelo e o √≠ndice de c√≥digo em um estado consistente, realce, prompt, etc.), bem como sob demanda - a conclus√£o do c√≥digo tamb√©m √© o lan√ßamento do compilador.  √â poss√≠vel reduzir de alguma forma esse tempo?  Infelizmente, no caso de usar o clang como um analisador, n√£o h√° muitas possibilidades.  Raz√£o: essa √© uma ferramenta de terceiros na qual ( <em>idealmente</em> ) as altera√ß√µes n√£o podem ser feitas.  Ou seja, cavar o c√≥digo clang com perftool, otimizar, simplificar algumas ramifica√ß√µes - esses recursos n√£o est√£o dispon√≠veis e voc√™ tem a ver com o que a API externa fornece (no caso de usar libclang, tamb√©m √© bastante restrito). </p><br><p>  A primeira, √≥bvia e, de fato, a √∫nica solu√ß√£o √© usar cabe√ßalhos pr√©-compilados gerados dinamicamente.  Com a implementa√ß√£o adequada, a solu√ß√£o √© excelente.  Aumenta a velocidade de compila√ß√£o √†s vezes, pelo menos.  Sua ess√™ncia √© simples: o ambiente coleta todos os cabe√ßalhos de terceiros (ou cabe√ßalhos fora da raiz do projeto) em um √∫nico arquivo .h, cria pch a partir desse arquivo e inclui implicitamente esse pch em cada fonte.  Obviamente, um efeito colateral √≥bvio aparece: no c√≥digo-fonte ( <em>no est√°gio de edi√ß√£o</em> ), podem ser vistos s√≠mbolos que n√£o est√£o inclu√≠dos nele.  Mas isso √© uma cobran√ßa pela velocidade.  Eu tenho que escolher  E tudo ficaria bem, se n√£o fosse por um pequeno problema: o clang ainda √© um compilador.  E, sendo um compilador, ele n√£o gosta de erros no c√≥digo.  E se de repente (de repente! - consulte a se√ß√£o anterior) houver erros nos cabe√ßalhos, o arquivo .pch n√£o ser√° criado.  Pelo menos, estava na vers√£o 3.7.  Alguma coisa mudou a esse respeito desde ent√£o?  Eu n√£o sei, h√° uma suspeita de que n√£o.  Infelizmente, n√£o h√° mais nenhuma oportunidade de verificar. </p><br><p>  Op√ß√µes alternativas, infelizmente, n√£o est√£o dispon√≠veis pelo mesmo motivo: clang √© um compilador e uma coisa "em si".  Intervir ativamente no processo de gera√ß√£o do AST, de alguma forma faz√™-lo mesclar o AST de diferentes partes, manter bases de s√≠mbolos externas e te e te - alas, todos esses recursos n√£o est√£o dispon√≠veis.  Somente API externa, apenas incondicional e configura√ß√µes dispon√≠veis atrav√©s das op√ß√µes de compila√ß√£o.  E ent√£o a an√°lise do AST resultante.  Se voc√™ se sentar na vers√£o C ++ da API, um pouco mais de oportunidades estar√£o dispon√≠veis.  Por exemplo, voc√™ pode brincar com FrontendActions personalizadas, fazer configura√ß√µes mais refinadas para op√ß√µes de compila√ß√£o, etc. Mas, neste caso, o ponto principal n√£o ser√° alterado - o texto editado (ou indexado) ser√° compilado independentemente dos outros e completamente.  S√≥ isso.  O ponto. </p><br><p>  Talvez (talvez!) Algum dia haver√° um garfo do clang upstream especialmente adaptado para uso como parte do IDE.  Possivelmente.  Mas, por enquanto, tudo √© como √©.  Digamos que a integra√ß√£o da equipe do Qt Creator (at√© a fase "final") com a libclang levou sete anos.  Eu tentei o QtC 4.7 com um mecanismo baseado em libclang - admito que eu pessoalmente gosto da vers√£o antiga (na auto-escrita) mais simplesmente porque funciona melhor nos meus casos: solicita e destaca e tudo mais.  N√£o vou me comprometer a estimar quantas horas humanas eles gastaram nessa integra√ß√£o, mas me atrevo a sugerir que durante esse per√≠odo seria poss√≠vel concluir meu pr√≥prio analisador.  Pelo que sei (por indica√ß√µes indiretas), a equipe que trabalha no CLion procura cautelosamente a integra√ß√£o com o libclang / clang ++.  Mas essas s√£o suposi√ß√µes puramente pessoais.  A integra√ß√£o no n√≠vel do Language Server Protocol √© uma op√ß√£o interessante, mas especificamente para o caso C ++, costumo considerar isso mais como um paliativo pelos motivos listados acima.  Ele simplesmente transfere problemas de um n√≠vel de abstra√ß√£o para outro.  Mas talvez eu seja confundido com o LSP - o futuro.  Vamos ver  De qualquer maneira, a vida dos desenvolvedores de IDEs modernos para C ++ √© cheia de aventuras - com o clang como back-end ou sem ele. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419009/">https://habr.com/ru/post/pt419009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418999/index.html">[An√∫ncio, Peter] Reuni√£o do JUG.ru com Andrei Belyaev e Alexei Stukalov - Troll oprime CUBA: FAQ</a></li>
<li><a href="../pt419001/index.html">5 "super habilidades" necess√°rias para o trabalho do futuro</a></li>
<li><a href="../pt419003/index.html">Resumo de not√≠cias do Blockchain</a></li>
<li><a href="../pt419005/index.html">Excurs√£o √† subesta√ß√£o 220/110/20</a></li>
<li><a href="../pt419007/index.html">Texturas para introdu√ß√£o de 64k: como √© feito hoje</a></li>
<li><a href="../pt419011/index.html">Jinja2 no mundo C ++, parte dois. Renderiza√ß√£o</a></li>
<li><a href="../pt419013/index.html">Atribui√ß√£o baseada em funil para empresas B2B SaaS - considerando o valor de todos os esfor√ßos de marketing</a></li>
<li><a href="../pt419017/index.html">O que h√° de novo no ConstraintLayout 1.1</a></li>
<li><a href="../pt419019/index.html">AlterEgo: um dispositivo que pode ler (alguns) pensamentos</a></li>
<li><a href="../pt419021/index.html">Os principais tipos de impress√£o e seus recursos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>