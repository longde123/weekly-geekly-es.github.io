<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏻 🏪 🐊 Ekspresi reguler yang berlaku sebagai functor alternatif gratis ♍️ 🧓🏿 👚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya membawa kepada Anda terjemahan dari artikel segar yang indah oleh Justin Le. Dalam blognya di Code, penulis ini berbicara dalam bahasa yang agak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ekspresi reguler yang berlaku sebagai functor alternatif gratis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448644/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>Saya membawa kepada Anda terjemahan dari artikel segar yang indah oleh Justin Le.</em>  <em>Dalam blognya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Code,</a> penulis ini berbicara dalam bahasa yang agak mudah tentang esensi matematika dari solusi fungsional yang indah dan elegan untuk masalah praktis.</em>  <em>Artikel ini membahas secara rinci contoh bagaimana mentransfer struktur matematika yang membentuk data dalam area subjek ke sistem jenis program dapat segera, karena Gerald dan Sassman menulis "secara otomatis", mengarah pada solusi yang berfungsi.</em> </p><br><p> <em>Kode yang ditunjukkan dalam gambar adalah implementasi mandiri penuh, dapat diperluas dari pengurai ekspresi reguler, ditulis dari awal.</em>  <em>Kelas atas, sihir tipe nyata!</em> </p><a name="habracut"></a><br><p>  Hari ini kami menerapkan ekspresi reguler dan parser (dalam semangat perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regex-aplikatif</a> ) menggunakan struktur aljabar gratis!  Struktur bebas adalah salah satu alat favorit saya di Haskell, dan saya menulis sebelumnya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup gratis</a> , variasi pada topik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">monad gratis</a> dan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi bebas pada monoids</a> . </p><br><p>  Ekspresi reguler (dan parser untuk mereka) ada di mana-mana dalam pemrograman dan ilmu komputer, jadi saya berharap bahwa dengan menunjukkan betapa mudahnya mereka diimplementasikan menggunakan struktur bebas, saya akan membantu pembaca menghargai manfaat dari pendekatan ini tanpa takut tersesat dalam detail yang tidak perlu. </p><br><p> Semua kode dalam artikel <a href="">tersedia</a> online sebagai "stack executable".  Jika Anda menjalankannya ( <code>./regexp.hs</code> ), sesi GHCi akan dimulai dengan semua definisi, sehingga Anda akan memiliki kesempatan untuk bermain-main dengan fungsi dan tipenya. </p><br><p>  Artikel ini akan sepenuhnya dimengerti oleh "pemula tingkat lanjut", atau "spesialis pemula" di Haskell.  Ini membutuhkan pengetahuan tentang konsep dasar bahasa: pencocokan pola, tipe data aljabar, dan abstraksi seperti monoids, functors, dan notasi. </p><br><h1 id="regulyarnye-yazyki">  Bahasa reguler </h1><br><p>  Ekspresi reguler adalah cara mendefinisikan beberapa bahasa reguler.  Secara formal, ungkapan semacam itu dibangun dari tiga elemen dasar: </p><br><ol><li>  Set kosong adalah elemen yang tidak memetakan apa pun. </li><li>  String kosong adalah elemen netral yang sepele cocok dengan string kosong. </li><li>  Literal adalah simbol yang cocok dengan dirinya sendiri.  Banyak satu elemen. </li></ol><br><p>  Dan juga dari tiga operasi: </p><br><ol><li>  Rangkuman: <code>RS</code> , urutan ekspresi.  Produk set (Kartesius). </li><li>  Alternatif: <code>R|S</code> , pilihan antara ekspresi.  Persatuan set. </li><li>  Baji Bintang: <code>R*</code> , pengulangan suatu ekspresi beberapa kali sembarang (termasuk nol). </li></ol><br><p>  Dan hanya itu yang membentuk ekspresi reguler, tidak lebih, tidak kurang.  Dari komponen dasar ini, Anda bisa membuat semua operasi lain yang dikenal dengan ekspresi reguler - misalnya, <code>a+</code> dapat dinyatakan sebagai <code>aa*</code> , dan kategori seperti <code>\w</code> dapat direpresentasikan sebagai alternatif untuk karakter yang sesuai. </p><br><div class="spoiler">  <b class="spoiler_title">Catatan Penerjemah</b> <div class="spoiler_text"><p>  Definisi minimum bahasa reguler di atas cukup lengkap untuk ahli matematika, tetapi tidak praktis.  Misalnya, operasi negasi atau penambahan ("karakter apa pun kecuali yang ditentukan") dapat ditulis sebagai bagian dari definisi dasar, tetapi aplikasi langsungnya akan mengarah pada peningkatan eksponensial dalam sumber daya yang digunakan. </p></div></div><br><h1 id="alternativnyy-funktor">  Functor alternatif </h1><br><p>  Ketika Anda melihat struktur ekspresi reguler, bukankah itu tampak akrab?  Ini mengingatkan saya pada banyak jenis kelas <code>Alternative</code> .  Jika functor milik kelas ini, maka ini berarti bahwa berikut didefinisikan untuknya: </p><br><ol><li>  Elemen kosong yang terkait dengan kegagalan atau kesalahan perhitungan. </li><li>  <code>pure x</code> - elemen tunggal (dari kelas <code>Applicative</code> ). </li><li>  Operasi <code>&lt;*&gt;</code> , mengatur perhitungan berurutan. </li><li>  Operasi <code>&lt;|&gt;</code> , mengatur perhitungan alternatif. </li><li>  <code>many</code> fungsi adalah operasi perhitungan berulang nol atau lebih banyak kali. </li></ol><br><p>  Semua ini sangat mirip dengan konstruksi bahasa biasa, bukan?  Mungkin functor alternatif hampir apa yang kita butuhkan, satu-satunya hal yang hilang adalah primitif yang sesuai dengan karakter literal. </p><br><p>  Siapa pun yang baru mengenal kelas <code>Alternative</code> dapat menemukan pengantar yang bagus untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Typeclassopedia</a> .  Tetapi dalam kerangka artikel kami, kelas ini hanya mewakili "monoid ganda" dengan dua cara menggabungkan <code>&lt;*&gt;</code> dan <code>&lt;|&gt;</code> , yang, dalam arti tertentu, dapat dibandingkan dengan operasi <code>*</code> dan <code>+</code> untuk angka.  Secara umum, untuk menentukan functor alternatif, lima poin di atas dan beberapa undang-undang komutatif dan distributivitas tambahan sudah cukup. </p><br><div class="spoiler">  <b class="spoiler_title">Catatan penerjemah (membosankan)</b> <div class="spoiler_text"><p>  Lebih tepatnya, penulis sedikit bersemangat dengan "monoid ganda".  Kelas <code>Alternative</code> memperluas functor aplikatif, yang (di bawah batasan tertentu) adalah semigroup, ke semiring, di mana operasi penambahan <code>&lt;|&gt;</code> dengan elemen netral <code>empty</code> memainkan peran monoid komutatif.  Operator Aplikasi </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  tidak dapat bertindak sebagai analog dari operasi perkalian dalam semiring, karena itu bahkan tidak membentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">magma</a> .  Namun, bersama dengan operator <code>&lt;*&gt;</code> , operator "satu sisi" <code>*&gt;</code> dan <code>&lt;*</code> didefinisikan dalam paket <code>Control.Applicative</code> .  Masing-masing dari mereka mengabaikan hasil operan bahwa "sudut" tidak menunjukkan: </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  Jika tipe <code>a</code> dan <code>b</code> bertepatan, maka dengan operasi ini kita memperoleh semigroup (asosiatif mengikuti dari sifat-sifat komposisi).  Dapat diverifikasi bahwa untuk functor alternatif, perkalian bersifat distributif berkenaan dengan penjumlahan, baik di sebelah kanan maupun di sebelah kiri, dan, lebih lanjut, unsur netral untuk penjumlahan (analog nol) adalah elemen penyerap untuk operasi penggandaan. </p><br><p>  Semirings juga membentuk angka, set, matriks semirings, tipe aljabar dan ... ekspresi reguler, jadi, sungguh, kita berbicara tentang struktur aljabar yang sama. </p></div></div><br><p>  Dengan demikian, kita dapat menganggap ekspresi reguler sebagai functor alternatif, ditambah primitif untuk karakter literal.  Tapi, ada cara lain untuk melihatnya, dan itu mengarahkan kita langsung ke struktur bebas.  Alih-alih "functor alternatif dengan literal", kita dapat mengubah literal menjadi turunan dari kelas <code>Alternative</code> . </p><br><h1 id="svoboda">  Kebebasan </h1><br><p>  Mari kita menulis seperti itu.  Jenis literal primitif: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Perhatikan bahwa karena kami bekerja dengan functors (aplikatif, alternatif), maka dengan semua ekspresi reguler kami, "hasil" tertentu akan dikaitkan.  Ini karena ketika mendefinisikan instance untuk kelas <code>Functor</code> , <code>Applicative</code> dan <code>Alternative</code> , kita harus memiliki tipe parameter. </p><br><p>  Di satu sisi, Anda bisa mengabaikan jenis ini, tetapi di sisi lain, Anda harus menggunakan nilai ini sebagai hasil dari pencocokan dengan ekspresi reguler, seperti yang dilakukan dalam aplikasi industri yang bekerja dengan ekspresi reguler. </p><br><p>  Dalam kasus kami, <code>Prim 'a' 1 :: Prim Int</code> akan mewakili primitif yang memetakan ke karakter <code>'a'</code> dan segera ditafsirkan, menghasilkan unit. </p><br><p>  Nah, sekarang ... mari kita beri primitif kita struktur matematika yang diinginkan menggunakan functor alternatif gratis dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>free</code></a> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  Itu saja!  Ini adalah tipe lengkap kami untuk ekspresi reguler!  Setelah mendeklarasikan tipe <code>Alt</code> sebagai instance dari kelas <code>Functor</code> , kami mendapatkan semua operasi dari kelas <code>Applicative</code> dan <code>Alternative</code> , karena dalam hal ini ada contoh <code>Applicative (Alt f)</code> dan <code>Alternative (Alt f)</code> .  Sekarang kita memiliki: </p><br><ul><li>  Set sepele kosong - <code>empty</code> dari kelas <code>Alternative</code> </li><li>  String kosong - <code>pure</code> dari kelas <code>Applicative</code> </li><li>  Karakter Literal - Basic <code>Prim</code> </li><li>  Concatenation - <code>&lt;*&gt;</code> dari kelas <code>Applicative</code> </li><li>  Alternatif - <code>&lt;|&gt;</code> dari kelas <code>Alternative</code> </li><li>  Kleene Star - <code>many</code> dari kelas <code>Alternative</code> </li></ul><br><p>  Dan semua ini kita dapatkan sepenuhnya "gratis", yaitu, "gratis"! </p><br><p>  Pada dasarnya, struktur bebas secara otomatis memberikan kita hanya abstraksi untuk tipe dasar dan tidak lebih.  Tapi ekspresi reguler, dengan sendirinya, juga hanya mewakili struktur: elemen dasar dan serangkaian operasi, tidak lebih dan tidak kurang, sehingga functor alternatif gratis memberi kita apa yang kita butuhkan.  Tidak lebih, tetapi tidak kurang. </p><br><p>  Setelah menambahkan beberapa fungsi pembungkus yang nyaman ... kerjakan jenisnya selesai! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Contohnya </h1><br><p>  Baiklah, mari kita coba?  Mari kita susun ekspresi <code>(a|b)(cd)*e</code> , yang mengembalikan, jika cocok, tipe unit <code>()</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  Fungsi <code>void :: Functor f =&gt; fa -&gt; f ()</code> dari paket <code>Data.Functor</code> membuang hasilnya, kami menggunakannya, karena kami hanya tertarik pada keberhasilan perbandingan.  Tetapi operator <code>&lt;|&gt;</code> , <code>*&gt;</code> dan <code>many</code> digunakan oleh kami persis seperti yang diasumsikan ketika menggabungkan atau memilih salah satu opsi. </p><br><p>  Berikut ini contoh menarik yang lebih rumit, mari kita tentukan persamaan reguler yang sama, tetapi sekarang, sebagai hasil pencocokan, kami menghitung jumlah pengulangan dari <code>cd</code> substring. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  Ada kehalusan dalam operasi operator <code>*&gt;</code> dan <code>&lt;*</code> : panah menunjukkan hasil yang harus disimpan.  Dan karena <code>many (string "cd") :: RegExp [String]</code> mengembalikan daftar elemen berulang, kita dapat, tetap di dalam functor, menghitung panjang daftar ini dengan mendapatkan jumlah repetisi. </p><br><p>  Selain itu, <code>-XApplicativeDo</code> kompiler GHC <code>-XApplicativeDo</code> memungkinkan <code>-XApplicativeDo</code> untuk menulis ekspresi menggunakan do-notation, yang mungkin lebih mudah dimengerti: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  Ini semua agak mirip dengan bagaimana kita "menangkap" hasil parsing string menggunakan ekspresi reguler, mendapatkan akses ke sana.  Berikut ini adalah contoh di Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  satu-satunya perbedaan adalah bahwa kami menambahkan beberapa post-processing untuk menghitung jumlah pengulangan. </p><br><p>  Berikut ini adalah reguler reguler lain yang cocok dengan angka dari 0 hingga 9 dan mengembalikan nomor: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Di sini, fungsi <code>asum</code> dari paket <code>Control.Applicative.Alternative</code> mewakili pilihan dari daftar item <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> , dan fungsi <code>intToDigit</code> didefinisikan dalam paket <code>Data.Char</code> .  Dan, sekali lagi, kita dapat membuat hal-hal yang cukup elegan, misalnya, ekspresi <code>\[\d\]</code> , sesuai dengan angka dalam tanda kurung: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Parsing </h1><br><p>  Ya, ya, yang kami lakukan hanyalah mendeskripsikan tipe data untuk literal dengan penggabungan, seleksi, dan pengulangan.  Hebat!  Tapi yang benar-benar kita butuhkan adalah mencocokkan string dengan ekspresi reguler, bukan?  Bagaimana functor alternatif gratis dapat membantu kami dengan ini?  Bahkan, itu akan banyak membantu.  Mari kita lihat dua cara untuk melakukan ini! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Bongkar functor alternatif </h2><br><p>  <strong>Apa itu kebebasan?</strong> </p><br><p>  Cara kanonik menggunakan struktur bebas adalah dengan melipatnya menjadi struktur beton menggunakan aljabar yang sesuai.  Misalnya, transformasi <code>foldMap</code> mengubah monoid gratis (daftar) menjadi nilai instance instance dari kelas <code>Monoid</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  Fungsi <code>foldMap</code> mengubah transformasi <code>a -&gt; m</code> menjadi transformasi <code>[a] -&gt; m</code> (atau, <code>FreeMonoid a -&gt; m</code> ), dengan monoid <code>m</code> tertentu.  Gagasan umum adalah bahwa penggunaan struktur bebas memungkinkan Anda untuk menunda penggunaan spesifik "untuk nanti", memisahkan waktu pembuatan dan waktu menggunakan struktur. </p><br><p>  Misalnya, kita dapat membuat monoid gratis dari angka: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  Dan sekarang kita dapat memutuskan bagaimana kita ingin menafsirkan operasi <code>&lt;&gt;</code> : <br>  Mungkin tambahan ini? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  Atau multiplikasi? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  Atau mungkin perhitungan angka maksimal? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  Idenya adalah untuk menunda pemilihan monoid tertentu dengan terlebih dahulu membangun koleksi gratis angka 1, 2, 3, dan 4. Monoid bebas atas angka menentukan struktur di atas mereka yang Anda butuhkan, tidak lebih, tidak kurang.  Untuk menggunakan <code>foldMap</code> kami menentukan "cara menerima tipe dasar" dengan meneruskan operator <code>&lt;&gt;</code> ke monoid tertentu. </p><br><p>  <strong>Interpretasi dalam Functor <code>State</code></strong> </p><br><p>  Dalam praktiknya, memperoleh hasil dari struktur bebas terdiri dari menemukan (atau menciptakan) fungsi yang sesuai yang akan memberi kita perilaku yang diinginkan.  Dalam kasus kami, kami beruntung bahwa ada implementasi spesifik dari kelas <code>Alternative</code> yang bekerja persis seperti yang kita butuhkan: <code>StateT String Maybe</code> . </p><br><p>  Produk <code>&lt;*&gt;</code> untuk functor ini terdiri dalam mengatur urutan perubahan status.  Dalam kasus kami, di bawah status, kami akan mempertimbangkan sisa string yang diuraikan, sehingga pengurutan berurutan adalah yang paling cocok untuk operasi <code>&lt;*&gt;</code> . </p><br><p>  Dan jumlahnya <code>&lt;|&gt;</code> bekerja seperti mundur, pencarian dengan kembali ke alternatif jika terjadi kegagalan.  Ia mempertahankan status sejak eksekusi parsing terakhir yang berhasil dan kembali ke sana jika alternatifnya tidak berhasil dipilih.  Ini persis perilaku yang kita harapkan dari ungkapan <code>R|S</code> </p><br><p>  Akhirnya, transformasi alami untuk functor alternatif gratis disebut <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  Atau, untuk tipe RegExp: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  Jika Anda tidak terbiasa dengan jenis <code>RankN</code> (dengan <code>forall b.</code> Konstruksi), Anda dapat melihat pengantar yang baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Intinya di sini adalah bahwa Anda perlu menyediakan fungsi <code>runAlt</code> yang bekerja dengan <code>Prim b</code> untuk semua <code>b</code> , dan bukan jenis apa pun, seperti <code>Int</code> dan <code>Bool</code> , misalnya.  Yaitu, seperti pada <code>foldMap</code> kita hanya perlu menentukan apa yang harus dilakukan dengan tipe dasar.  Dalam kasus kami, jawab pertanyaan: "Apa yang perlu dilakukan dengan tipe <code>Prim</code> ?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  Ini adalah interpretasi <code>Prim</code> sebagai tindakan dalam konteks <code>StateT String Maybe</code> , di mana state adalah string yang <code>StateT String Maybe</code> .  Biarkan saya mengingatkan Anda bahwa <code>Prim</code> berisi informasi tentang karakter yang cocok <code>c</code> dan interpretasinya dalam bentuk beberapa nilai <code>x</code> .  Pemrosesan <code>Prim</code> terdiri dari langkah-langkah berikut: </p><br><ul><li>  Menggunakan <code>get</code> status (belum diuraikan bagian dari string) dan segera mencetak karakter pertama dan sisanya.  Jika garis kosong, sebuah alternatif akan kembali.  ( <em>Transformator <code>StateT</code> bertindak di dalam functor Mungkin, dan jika tidak mungkin untuk mencocokkan pola di sisi kanan <code>&lt;-</code> operator <code>&lt;-</code> di dalam blok do, perhitungan akan berakhir dengan hasil <code>empty</code> , yaitu, <code>Nothing</code> . Approx. Trans.</em> ). </li><li>  Kami menggunakan ekspresi penjaga untuk mencocokkan karakter saat ini dengan karakter yang diberikan.  Dalam hal kegagalan, <code>empty</code> dikembalikan, dan kami beralih ke opsi alternatif. </li><li>  Kami mengubah status dengan mengganti string yang diurai dengan "ekor", karena pada saat ini karakter saat ini sudah dapat dianggap berhasil diurai. </li><li>  Kami mengembalikan apa yang harus dikembalikan oleh primitif <code>Prim</code> . </li></ul><br><p>  Anda sudah dapat menggunakan fungsi ini untuk memetakan RegEx ke awalan string.  Untuk melakukan ini, Anda harus memulai perhitungan menggunakan <code>runAlt</code> dan <code>runStateT</code> , meneruskan string yang diurai ke fungsi terakhir sebagai argumen: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  Itu saja!  Mari kita lihat bagaimana solusi pertama kami bekerja: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Tunggu, apa itu tadi?</strong> </p><br><p>  Tampaknya semuanya terjadi sedikit lebih cepat dari yang Anda harapkan.  Semenit yang lalu kami menulis primitif kami, dan kemudian lagi!  dan pengurai bekerja siap.  Di sini, pada kenyataannya, semua kode kunci, beberapa baris di Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  Dan apakah kita memiliki pengurai ekspresi reguler yang berfungsi penuh?  Apa yang terjadi </p><br><p>  Ingatlah bahwa pada tingkat abstraksi yang tinggi, <code>Alt Prim</code> sudah mengandung <code>pure</code> , <code>empty</code> , <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , dan <code>many</code> di strukturnya (ada satu kehalusan yang tidak menyenangkan dengan operator ini, tetapi lebih pada nanti).  Apa <code>runAlt</code> adalah menggunakan perilaku functor alternatif tertentu (dalam kasus kami, <code>StateT String Maybe</code> ) untuk mengontrol perilaku <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , dan <code>many</code> operator.  Namun, <code>StateT</code> tidak memiliki operator <code>StateT</code> mirip dengan <code>Prim</code> , dan untuk ini kami perlu menulis <code>processPrim</code> . </p><br><p>  Jadi, untuk tipe <code>Prim</code> , fungsi <code>runAlt</code> menggunakan <code>runAlt</code> , dan untuk <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , dan <code>many</code> , contoh yang sesuai dari kelas <code>Alternative</code> digunakan.  Dengan demikian, 83% dari pekerjaan dilakukan untuk kita oleh functor <code>StateT</code> , dan sisanya 17% dilakukan oleh <code>StateT</code> .  Sebenarnya, ini agak mengecewakan.  Orang mungkin bertanya: mengapa harus mulai dengan pembungkus <code>Alt</code> ?  Mengapa tidak segera mendefinisikan tipe <code>RegExp = StateT String Maybe</code> dan <code>char :: Char -&gt; StateT String Maybe Char</code> primitive yang sesuai <code>char :: Char -&gt; StateT String Maybe Char</code> ?  Jika semuanya dilakukan di func StateT, maka mengapa repot-repot dengan <code>Alt</code> - functor alternatif gratis? </p><br><p>  Keuntungan utama <code>Alt</code> daripada <code>StateT</code> adalah <code>StateT</code> adalah ... alat yang sangat kuat.  Tapi nyatanya, dia kuat, sampai-sampai absurd.  Dengan itu, Anda dapat membayangkan sejumlah besar perhitungan dan struktur yang paling beragam, dan, tidak menyenangkan, mudah untuk membayangkan sesuatu yang bukan ekspresi reguler.  Katakanlah sesuatu yang mendasar seperti <code>put "hello" :: StateT String Maybe ()</code> tidak cocok dengan ekspresi reguler yang valid, tetapi jenisnya sama dengan <code>RegExp ()</code> .  Jadi, sementara kita mengatakan bahwa <code>Alt Prim</code> cocok dengan ekspresi reguler, tidak lebih, tetapi tidak kurang, kita tidak bisa mengatakan hal yang sama dengan <code>StateT String Maybe</code> .  Tipe <code>Alt Prim</code> adalah representasi sempurna dari ekspresi reguler.  Segala sesuatu yang dapat diekspresikan dengan bantuannya adalah ekspresi reguler, tetapi sesuatu yang bukan ekspresi seperti itu tidak dapat diekspresikan dengan bantuannya.  Di sini, bagaimanapun, ada juga beberapa kehalusan yang tidak menyenangkan terkait dengan kemalasan Haskell, lebih lanjut tentang ini nanti. </p><br><p>  Di sini kita dapat mempertimbangkan <code>StateT</code> hanya sebagai konteks yang digunakan untuk itu <br>  interpretasi ekspresi reguler - sebagai pengurai.  Tetapi Anda dapat membayangkan cara lain untuk menggunakan <code>RegExp</code> .  Sebagai contoh, kita mungkin memerlukan representasi tekstualnya, yang tidak <code>StateT</code> oleh <code>StateT</code> . </p><br><p>  Kita tidak bisa mengatakan bahwa <code>StateT String Maybe</code> adalah ekspresi reguler, hanya saja functor ini dapat mewakili pengurai berdasarkan tata bahasa reguler.  Tetapi tentang <code>Alt Prim</code> kita dapat mengatakan dengan pasti bahwa ini adalah ekspresi reguler ( <em>seperti yang dikatakan para ahli matematika, mereka sama dengan isomorfisme, kira-kira Trans.</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Penggunaan langsung struktur bebas </h2><br><p>  Semua ini, tentu saja, sangat baik, tetapi bagaimana jika kita tidak ingin mengalihkan 83% pekerjaan ke kode untuk jenis yang ditulis oleh seseorang untuk kita.  Apakah mungkin untuk menggunakan struktur <code>Alt</code> gratis secara langsung untuk menulis parser?  Pertanyaan ini mirip dengan ini: bagaimana menulis fungsi yang memproses daftar (dengan mencocokkan konstruktor <code>(:)</code> dan <code>[]</code> ) alih-alih hanya menggunakan <code>foldMap</code> ?  Bagaimana cara langsung beroperasi dengan struktur ini alih-alih mendelegasikan pekerjaan ke monoid tertentu? </p><br><p>  Senang Anda bertanya!  Mari kita lihat definisi functor alternatif gratis: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  Ini adalah tipe yang tidak biasa yang didefinisikan melalui rekursi timbal balik, sehingga dapat terlihat sangat membingungkan.  Salah satu cara untuk memahaminya adalah dengan membayangkan bahwa <code>Alt xs</code> berisi rantai alternatif yang dibentuk menggunakan operator <code>&lt;|&gt;</code> .       <code>AltF</code> ,     <code>f</code> ,     <code>&lt;*&gt;</code> (   ). </p><br><p>   <code>AltF fa</code>    <code>[fr]</code> ,   <code>r</code>   . <code>Ap</code>   <code>(:)</code> ,  <code>fr</code> ,  <code>Pure</code> —   <code>[]</code> .  <code>forall r.</code>       <code>-XExistentialQuantification</code>         . </p><br><p>   , <code>Alt f</code>   ,      .     ,      ( )  <code>&lt;*&gt;</code>  <code>&lt;|&gt;</code> ,  ,   <code>[a]</code>      <code>&lt;&gt;</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () — ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () —  ,   <code>+</code> ,   — ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) —  ,   <code>&lt;|&gt;</code> ,   — ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> —   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   —    ,           —    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    — . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x22A5;</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/448644/&amp;usg=ALkJrhheOxGbmMBnLJVp6EQXoWO_ablG3A#MJMAIN-22A5" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">⊥</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" . . .</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     —  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448644/">https://habr.com/ru/post/id448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448634/index.html">Pelajaran Ukraina</a></li>
<li><a href="../id448636/index.html">Retas Komputer Retas Retro</a></li>
<li><a href="../id448638/index.html">Buildroot - Bagian 1. Informasi umum, membangun sistem minimal, pengaturan melalui menu</a></li>
<li><a href="../id448640/index.html">SSD GIGABYTE Aorus RGB M.2: kecil, bahkan jarak jauh untuk LED RGB (2 bagian)</a></li>
<li><a href="../id448642/index.html">Wajib Model Distribusi Hak di FreeBSD</a></li>
<li><a href="../id448648/index.html">Bagaimana mendudukkan semua orang dalam sains dan tidak mengubah kantor menjadi sarang kebencian</a></li>
<li><a href="../id448652/index.html">Mozilla WebThings di Raspberry Pi - memulai</a></li>
<li><a href="../id448654/index.html">Mozilla WebThings - Pengaturan Gateway</a></li>
<li><a href="../id448656/index.html">Kakak sedang menonton ... dirinya sendiri atau peta dengan sejarah gerakan di HomeAssistant</a></li>
<li><a href="../id448658/index.html">Apa yang bisa dilakukan melalui konektor OBD di mobil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>