<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏽 👆🏿 👩🏼‍💻 uMCPIno: escribir un protocolo simple con entrega garantizada para Arduino 🦈 🎶 🤰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Saludos, queridos! 
 En algún momento de su vida, ¡cada obstinada caja de bricolaje deja de extrañar al Kantian Arduino como "cosas en sí mismas" que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>uMCPIno: escribir un protocolo simple con entrega garantizada para Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480110/"><h3>  ¡Saludos, queridos! </h3><br>  En algún momento de su vida, ¡cada obstinada caja de bricolaje deja de extrañar al Kantian Arduino como "cosas en sí mismas" <s>que simplemente no pueden!</s>  : Parpadear el LED, tomar datos de los sensores y transferirlos por el cable a la PC es ciertamente divertido, pero el Santo Grial está en movilidad, en liberación de los "enlaces de cobre", en verdadera libertad entre las ondas del éter universal. <br>  Aquí es donde se nos abre la dura realidad de los canales de comunicación inestables, los errores de transmisión y los mensajes no entregados. <br>  Dios prohíbe reclamar originalidad en esta área: la humanidad ha usado durante mucho tiempo un montón de protocolos para todas las ocasiones. <br>  Pero nuestro objetivo es aprender, y dado que soy un ferviente defensor del reconocimiento en combate, estudiaremos inventando nuestro propio protocolo "bicicleta". <br>  Hoy propongo desarrollar un protocolo que garantice la entrega garantizada, la integridad y la secuencia de mensajes entre dos suscriptores (punto a punto, punto a punto), sepa cómo y aplica el algoritmo de <a href="https://en.wikipedia.org/wiki/Nagle%2527s_algorithm" rel="nofollow">Nagle</a> y la <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" rel="nofollow">canalización del protocolo</a> , lo que sea que eso signifique.  Al mismo tiempo, debería tener una <a href="https://en.wikipedia.org/wiki/Overhead_(computing)" rel="nofollow">sobrecarga</a> mínima y exprimirse incluso en el estrecho Arduino UNO. <br><br><img src="https://habrastorage.org/webt/jt/7a/_b/jt7a_bc6uynr5uu08ab3plyuucq.png"><br><br>  Pregunto a todos los interesados ​​a bordo, cerramos las escotillas, abrimos las piedras del rey, llenamos los tanques de lastre.  ¡Tenemos una excursión al pasado, destino: año 1974! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Para los impacientes (¡yo mismo lo soy!)</b> <div class="spoiler_text">  Aquí está el repositorio de github donde están las implementaciones: <br><ul><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">Para arduino</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/STM32" rel="nofollow">Para STM32</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/CSharp" rel="nofollow">Para PC (C #)</a> </li></ul><br></div></div><br>  Según la vieja tradición, al menos dos expertos reconocidos en este campo están involucrados en la descripción de algoritmos y protocolos criptográficos, si alguien más no los conoce, familiarícese: <br><div class="spoiler">  <b class="spoiler_title">Alice</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/6f4/f08/fb46f4f081e1affbfba68c39dcbc7768.jpg" alt="imagen"><br></div></div><br>  Y <br><div class="spoiler">  <b class="spoiler_title">Bob</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/048/a75/668/048a75668215c8147df3f5720f283899.jpg" alt="imagen"><br></div></div><br><br><h3>  Primero describimos una tarea simple </h3><br>  Alice y Bob están sentados en trincheras adyacentes y no pueden levantar la cabeza para verse.  Solo pueden hablar en voz, al lado de ellos silban las balas y los proyectiles explotan, ahogando sus gritos, y además, cuando uno de ellos habla, tienes que gritar para que no escuches nada. <br>  La situación se complica por el hecho de que están siendo escuchados por los enemigos, y tienes que usar un lenguaje de código, por alguna razón que consiste en largas secuencias de números. <br>  Dado que tanto Alice como Bob son personas, periódicamente tienen que salir a comer o ir al baño, ¡y están tan impacientes que pueden ser impacientes en el momento más inoportuno! <br><br><h3>  ¿Cómo y por qué establecer una conexión? </h3><br>  ¿Cómo podemos organizar una transferencia de datos confiable en una situación tan deprimente, cuando parece que todo está condenado al fracaso? <br><br>  La primera solución que puede venir a la mente es usar frases de código de <s>palabras de detención</s> para iniciar y finalizar la transferencia. <br><br>  Bueno, digamos que si Alice quiere enviar un mensaje, entonces necesita gritar "¡Comience la transmisión!" Y espere hasta que Bob responda "¡Comience la recepción!". <br>  Si Alice no espera la respuesta de Bob, simplemente repite su solicitud para comenzar la transferencia.  Naturalmente, no debe hacer esto con demasiada frecuencia, de lo contrario, como sabemos, simplemente no escuchará la respuesta de Bob. <br><br>  Genial  Pero, ¿qué sucede si Alicia en respuesta escucha desde la siguiente trinchera, "Comenzar transmisión"? <br>  Resulta que Bob también decidió transferir información importante en este momento.  Alice tiene un carácter suave, y podría haber pensado: "Está bien, esperaré, mi mensaje es, en principio, no urgente, deja que Bob lo transmita primero".  Pensando en esto, ella responde: "¡Comienza la recepción!". <br><br>  Como <s>en tiempos de guerra el valor del seno puede alcanzar cuatro, la</s> velocidad del sonido es finita, y lleva un tiempo comprender lo que Alice y Bob han escuchado, e incluso Bob, como un caballero, puede decidir ceder ante la dama, se encoge de hombros y grita: "¡Estoy comenzando la recepción!" ... <br><br>  Para ilustrar la indignación, utilizaremos gráficos de tiempo.  El tiempo se les acaba. <br><br>  El caso cuando Alice y Bob no estuvieron de acuerdo a tiempo: <br><img src="https://habrastorage.org/webt/cz/ye/hn/czyehnoehw9e3wnxveaiwvef5ok.png"><br><br>  El caso cuando se perdió el mensaje: <br><img src="https://habrastorage.org/webt/5u/yk/md/5uykmdq7sxiagt-5twd3uhpnxas.png"><br><br>  Este es un fiasco.  Todo se vuelve demasiado confuso y se agrava por el hecho de que el destinatario puede escuchar o no escuchar cualquiera de las frases, y en cada caso el interlocutor no sabe si su mensaje fue escuchado por el destinatario. <br><br>  Ahora tanto Alice como Bob esperan una bienvenida.  Sería lógico darse cuenta de que se ha producido un conflicto y que alguien debe reanudar la transmisión.  Pero, ¿qué pasa si todo vuelve a suceder de una manera nueva?  Y aquí estamos nuevamente donde comenzamos. <br><br>  Si cree que la situación es extremadamente rara, recuerde la última vez que habló con alguien por voz, cuando su suscriptor o usted (o ambos) tienen una conexión lenta a Internet.  "Hola hola hola, desapareces".  "No puedes escuchar hola hola". <br><br>  Mientras tanto, en las trincheras, la situación se está calentando, los comandantes exigen la transmisión de informes. <br>  Es hora <s>de recurrir a las fuentes principales: para estudiar a Marx, Engels</s> regresará hace más de 40 años y verá cómo <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">los</a> ingenieros de <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">DEC</a> resolvieron tales problemas al diseñar el protocolo <a href="https://en.wikipedia.org/wiki/Digital_Data_Communications_Message_Protocol" rel="nofollow">DDCMP</a> . <br><br>  Según los desarrolladores de DDCMP, Alice y Bob deben rechazar las emociones y convertirse en <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow">máquinas de estados finitos</a> . <br>  Esto significa que a partir de ahora, nuestros Alice y Bob tendrán solo unos pocos estados fijos, las transiciones entre estos estados pueden ocurrir estrictamente de acuerdo con ciertas reglas cuando ocurren ciertos eventos. <br><br>  Primero, simplemente enumeramos los estados: <br><br><ul><li>  Detenido </li><li>  COMIENZO INICIAL </li><li>  INICIO RECONOCIDO </li><li>  CORRIENDO </li></ul><br><br>  Como puede ver, solo hay cuatro de ellos.  Y ahora, pase lo que pase, cada uno de los suscriptores al menos sabe con certeza que su visado solo se encuentra en uno de estos estados.  De hecho, mirando un poco más adelante, diré que casi siempre un suscriptor sabrá en qué estado se encuentra el segundo suscriptor, <s>pero esto no es exacto</s> . <br><br><h3>  Consideremos los estados por separado, en detalle </h3><br>  <b>HALTED</b> es el estado más simple, nadie va a ninguna parte, todos permanecen en sus lugares, nada se transmite y no se recibe, se ignora cualquier estímulo externo.  Todos menos uno: la voluntad de las autoridades superiores.  En el protocolo DDCMP original, la transición del estado <b>HALTED</b> solo puede estar en el estado <b>INICIAL INICIAL</b> a solicitud del usuario: Alice o Bob reciben una orden para establecer una conexión. <br><br>  ¿Qué sucede cuando Alice o Bob reciben tal orden? <br>  Inmediatamente se advierten a sí mismos que el estado ha cambiado de <b>HALTED</b> a <b>INICIAL START</b> , esta transición, como cualquier otra, implica una secuencia de acciones estrictamente definida.  En este caso, debe gritar "¡HAZLO!" Y poner el reloj en el reloj.  Eso es todo. <br><br>  Entonces, Alice gritó lo que se requería de ella y presionó un botón en el cronómetro.  Ahora, para comprender qué esperar de Bob, descubriremos qué puede pasarle a Alice cuando está en el estado <b>INICIAL</b> . <br><br>  - Desde el momento en que Alice notó que el tiempo había pasado, digamos 10 segundos y no escuchó ninguna reacción de Bob (nota, no estoy diciendo que Bob no le gritó nada en respuesta, esto no se sabe, pero solo Alice no sabe nada escuchado durante este tiempo, Alice es una mujer sabia y racional y se basa únicamente en hechos).  Llamamos a este evento un tiempo de espera: se ha excedido el intervalo de espera.  En este caso, el protocolo nos dice que repitamos: grite "¡HAZLO UNA VEZ!" Y una y otra vez.  Todavía no es grueso. <br><br>  - Si Alice escuchó que Bob gritó lo mismo: “¡HAGA UNA VEZ!”, Entonces Alice ingresa de manera <b>no selectiva</b> al estado <b>INICIO RECONOCIDO</b> , sobre el cual debe gritar inmediatamente “¡HAGA DOS!” Y cronometra el reloj nuevamente. <br><br>  - Una vez más, si Alice escuchó de Bob "DO DOO!", Entonces ella inmediatamente entra en el estado de <b>FUNCIONAMIENTO</b> (!), Grita "¡NOOOOOL ACEPTADO!".  Si su cronómetro se ha iniciado, lo apaga con precaución. <br><br>  Es muy importante no hacer movimientos innecesarios que no estén previstos por el estado actual.  Cualquier cosa que llore Bob, no importa cuán maldecida o suplicante, Alice solo reacciona según lo acordado. <br><br>  Es conveniente presentar tales cosas en forma de tabla.  Entonces, comencemos con los <b>estados HALTED</b> e <b>INICIAL START</b> ya descritos, y luego <b>repondremos</b> más la tabla. <br><br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ACTUAL </th><th>  EVENTO <br></th><th>  NUEVA CONDICIÓN </th><th>  ACCION <br></th></tr><tr><td>  Cualquiera </td><td>  La orden "rompe la conexión" </td><td>  Detenido <br></td><td></td></tr><tr><td>  Detenido <br></td><td>  Orden "Conectar" <br></td><td>  ESTADO INICIAL </td><td>  1) Grita "¡HAZLO UNA VEZ!" <br>  2) Iniciar el temporizador <br></td></tr><tr><td rowspan="3">  COMIENZO INICIAL <br></td><td>  Escuché "¡HAZLO UNA VEZ!" <br></td><td>  INICIO RECONOCIDO <br></td><td>  1) Grita "¡HAZ DOS!" <br>  2) Iniciar el temporizador <br></td></tr><tr><td>  Escuché "¡HAZ DOS!" </td><td>  CORRIENDO <br></td><td>  1) Grita "NOOOL ACEPTADO!" <br>  2) detener el temporizador <br></td></tr><tr><td>  Se acabó el tiempo - tiempo de espera </td><td>  COMIENZO INICIAL <br></td><td>  1) Grita "¡HAZLO UNA VEZ!" <br>  2) Iniciar el temporizador <br></td></tr></tbody></table></div><br><br>  Conscientemente omito algunos puntos de la descripción original de DDCMP: no los necesitamos, queremos no solo repetir DDCMP, sino construir sobre la base <s>el mismo, solo otro</s> protocolo nuevo. <br><br>  Pero volvamos a la descripción de estados y transiciones.  El siguiente estado es <b>INICIO RECONOCIDO</b> . <br>  Al estar en este estado, todo lo que puede preocupar a Alice o Bob es: <br><br>  - como antes, la expiración del tiempo de espera, en este caso debe permanecer en el mismo estado, gritar "¡HAGA DOS!" y vuelva a iniciar el temporizador <br><br>  - el "DO DOO!" escuchado se traduce al estado de <b>FUNCIONAMIENTO</b> , mientras grita "NOOOOL ACEPTADO!" Y detiene el temporizador; <br><br>  - el oído "¡HAZLO!" se va en el mismo estado, debes gritar "¡HAZ DOS!" e iniciar el temporizador; <br><br>  - escuché "NOOOL ACEPTADO!" - transición al estado EN <b>EJECUCIÓN</b> , detenga el temporizador. <br><br>  Ponemos todo lo anterior en una mesa. <br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ACTUAL </th><th>  EVENTO <br></th><th>  NUEVA CONDICIÓN </th><th>  ACCION <br></th></tr><tr><td rowspan="4">  INICIO RECONOCIDO <br></td><td>  Escuché "¡HAZLO UNA VEZ!" <br></td><td>  INICIO RECONOCIDO <br></td><td>  1) Grita "¡HAZ DOS!" <br>  2) Iniciar el temporizador <br></td></tr><tr><td>  Escuché "¡HAZ DOS!" </td><td>  CORRIENDO <br></td><td>  1) Grita "NOOOL ACEPTADO!" <br>  2) detener el temporizador <br></td></tr><tr><td>  Escuché "NOOOL ACEPTADO!" </td><td>  CORRIENDO <br></td><td>  1) detener el temporizador <br></td></tr><tr><td>  Se acabó el tiempo - tiempo de espera </td><td>  INICIO RECONOCIDO </td><td>  1) Grita "¡HAZ DOS!" <br>  2) Iniciar el temporizador <br></td></tr></tbody></table></div><br><br>  Con un apretón de manos, casi todo está listo: queda por considerar solo un estado <b>EN EJECUCIÓN</b> , porque uno de los suscriptores ya puede entrar, y el segundo, correr urgentemente al baño, y cuando regrese, olvida todo e intenta establecer una nueva conexión. <br><br>  Desde el punto de vista del procedimiento de protocolo de enlace (todavía no tratamos con la transferencia de datos, para lo cual todo se inició, esta es una historia separada) en el estado <b>EN EJECUCIÓN</b> , estamos interesados ​​en dos eventos: <br><br>  - si nos gritan "¡HAZLO UNA VEZ!" - todo es muy malo, es una desincronización completa, todo debe comenzar de nuevo.  El protocolo original le <b>indica</b> que simplemente ingrese al estado <b>HALTED</b> .  Pero esto no nos ayudará de ninguna manera: si por alguna razón esto sucedió en un Arduino autónomo, que transmite algunos datos de algunos sensores, entonces para nosotros esto es un completo fracaso.  Como sabemos, desde <b>HALTED</b> puede ir al <b>INICIO INICIAL</b> solo por orden de las autoridades. <br>  Por lo tanto, estamos modificando el protocolo aquí: la recepción en el estado <b>HALTED</b> del <b>comando</b> "DO ONCE!" Debería funcionar como una orden de las autoridades, es decir  <b>cambie al</b> estado <b>INICIO INICIAL</b> , grite "¡HAZLO UNA VEZ!", inicie el temporizador.  Además, en algunos casos es conveniente dar una orden para establecer comunicación inmediatamente después de suministrarse energía. <br>  Por lo tanto, ahora, en el caso más inconveniente, simplemente restableceremos la conexión. <br><br>  - el segundo evento al que es necesario reaccionar en el estado <b>EN EJECUCIÓN</b> - si escuchamos "DO DOO!" De una trinchera vecina.  Esto ya es más interesante.  En este caso, debe gritar "ER ACEPTADO!" Donde, por ER se entiende el número de mensajes recibidos con éxito en la sesión de comunicación actual.  Este es un nuevo concepto.  A continuación consideraremos todo con más detalle, pero por el momento traeremos todo lo que hemos aprendido al momento actual en una tabla: <br><br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ACTUAL </th><th>  EVENTO <br></th><th>  NUEVA CONDICIÓN </th><th>  ACCION <br></th></tr><tr><td rowspan="4">  INICIO RECONOCIDO <br></td><td>  Escuché "¡HAZLO UNA VEZ!" <br></td><td>  INICIO RECONOCIDO <br></td><td>  1) Grita "¡HAZ DOS!" <br>  2) Iniciar el temporizador <br></td></tr><tr><td>  Escuché "¡HAZ DOS!" </td><td>  CORRIENDO <br></td><td>  1) Grita "NOOOL ACEPTADO!" <br>  2) detener el temporizador <br></td></tr><tr><td>  Escuché "NOOOL ACEPTADO!" </td><td>  CORRIENDO <br></td><td>  1) detener el temporizador <br></td></tr><tr><td>  Se acabó el tiempo - tiempo de espera </td><td>  INICIO RECONOCIDO </td><td>  1) Grita "¡HAZ DOS!" <br>  2) Iniciar el temporizador <br></td></tr></tbody></table></div><br><br>  Ahora, si Alice y Bob siguen estrictamente el protocolo, simplemente no tienen ninguna opción <s>para meterse en</s> algo <s>incomprensible</s> , excepto cómo establecer una conexión, cambiar conjuntamente al estado <b>EN EJECUCIÓN</b> o, en un mal caso, tratar de establecerlo antes de que se <s>haga clic en</s> la victoria. <br><br>  Un lector agresivo puede intentar clasificar todas las opciones y llegar a la conclusión de que la serie de estados y transiciones resulta ser cerrada y estrictamente determinada.  Nosotros (con la ayuda de las mentes de los ingenieros de DEC) ahora hemos vinculado a Alice y Bob con un conjunto de reglas que simplemente siguiendo las cuales establecerán una conexión, si en las condiciones actuales esto es generalmente posible en principio. <br><br><h3>  ¿Cómo transferir datos ahora? </h3><br>  Bien, ese fue un buen entrenamiento.  Período Candy-bouquet en la relación de dos nodos de red.  Recuerde que comenzamos un negocio: ¡necesitamos transferir datos con entrega garantizada y prioridad!  Con recuperación ante desastres.  En la medida en que los recursos de hardware lo permitan (después de todo, ¡tanto Alice como Bob pueden probar ser controladores débiles de 8 bits con 2 kilobytes de RAM!). <br><br>  Los ingenieros de DEC nos enseñan que los mensajes que necesitamos numerar, debemos contar cuánto enviamos, cuántos recibimos y cuántos de los mensajes que enviamos llegaron al destinatario. <br><br><div class="spoiler">  <b class="spoiler_title">¡Es hora de una digresión!</b> <div class="spoiler_text">  Admítelo  Cuando vi los nombres de las variables en la descripción del protocolo DDCMP, decidí que no fue un accidente: a los estadounidenses les encanta atraer hermosas abreviaturas de sus oídos. <br><br>  Para nuestra conveniencia, hay incluso varios recursos donde los interesados ​​pueden tocar lo bello. <br>  Mi favorito es este: <a href="https://www.cfa.harvard.edu/~gpetitpas/Links/Astroacro.html" rel="nofollow">sitio de acrónimos astronómicos tontos o demasiado forzados (o DOOFAAS)</a> <br><br>  ¡Cuánto valen estas fabricaciones! <br>  Aquí hay un ejemplo: <br><br>  <b>WASP</b> - Espectrómetro analógico de banda ancha (¡Pero no es lo que pensabas!) <br>  <b>SAURON</b> - Unidad de área espectroscópica para la investigación de nebulosas ópticas <br>  <b>CISCO</b> - Espectrógrafo infrarrojo refrigerado y cámara para OHS (¡Eso es lo que significa!) <br><br>  Y aquí, solo dispara: <br>  <b>SQUIRT</b> (¡oh sí, artículo 18+!) - Satettile QUick Research Testbed <br>  <b>MIERDA</b> (¡Ni más ni menos!) - Telescopio interferométrico súper enorme, con la inscripción "búscate tú mismo", al que se adjunta el enlace al resumen al artículo del mismo nombre. <br><br>  Por lo tanto, las variables que indican el número de paquetes recibidos, enviados y entregados en el nodo en la descripción original del protocolo se denominan <b>ARN</b> . <br><br>  Ah, ¿por qué no nombraron el protocolo de esa manera: ARN!  Una especie de red de ARN.  Los protocolos DECnet tenían todas las posibilidades de convertirse en protocolos de Internet si la historia hubiera resultado diferente. <br></div></div><br><br><h3>  Pero volviendo a nuestras trincheras </h3><br>  El estándar de protocolo original define que todos los contadores son de 8 bits e incrementan el módulo 256. Esto significa que puede haber un máximo de 256 mensajes enviados para los cuales aún no se ha recibido la confirmación. <br>  Y si no se recibe la confirmación, es posible que necesiten retransmitirse, y si es necesario, deben almacenarse hasta la confirmación.  Después de todo, ¡tenemos entrega garantizada! <br><br>  Los parámetros físicos de nuestra Alice y Bob nos dictan diferentes condiciones.  En Arduino de 8 bits, esta cantidad de datos simplemente no se puede almacenar y tenemos que comprometerla.  Y no estoy hablando del hecho de que en el estándar la longitud de los paquetes (mensajes) en bytes está limitada a un número de 16 bits, es decir.  ¡64 kilobytes es un lujo inadmisible! <br><br><h3>  Entonces, la conexión está establecida.  Que sigue </h3><br>  En el momento en que Alice o Bob <b>ingresan al</b> estado <b>EN EJECUCIÓN</b> , los contadores se reinician. <br>  Como ya mencioné, el protocolo original involucra la numeración de mensajes en el módulo 256, pero tenemos que reducir este número para adaptarlo a la pequeña cantidad de memoria en cosas similares a Arduino. <br>  Para poder limitar de inmediato todos los incrementos de contadores, introduciremos una cierta UMCP_PACKETS_NUMBER constante, y ahora todos los incrementos ocurrirán en este módulo. <br><br>  Si toma UMCP_PACKETS_NUMBER = 8, y el tamaño máximo del paquete es UMCP_PACKET_DATA_SIZE: las porciones de los datos transmitidos en un momento están limitadas a 64 bytes, entonces todo encajará en el Arduino UNO y permanecerá un poco para las necesidades del usuario. <br>  Es importante recordar que ambos parámetros deben ser iguales para ambas partes. <br><br>  Obviamente, ahora, si Alice y Bob han establecido con éxito una conexión, y uno de ellos necesita transferir datos, entonces los datos primero deben dividirse en porciones que no excedan los 64 bytes de tamaño, y en segundo lugar, cada paquete también debe contener un estado dos contadores de remitente: el número de mensajes recibidos y enviados (R y N). <br><br>  Vea lo fácil que es ahora organizar el llamado  ¡y qué fácil es manejar situaciones de error! <br><br>  Si Alice envía 3 paquetes seguidos justo después de establecer la conexión, entonces todos ellos tendrán el contador R puesto a 0 (todavía no ha recibido ningún paquete), y el contador N aumentará en uno con cada paquete nuevo. <br><br>  Si Bob los acepta con éxito, entonces, para confirmar la recepción de los tres paquetes, será suficiente para que envíe una confirmación solo para el último, de hecho, si simplemente devuelve el estado de sus contadores R = 3 y N = 0, entonces Alice comprenderá de inmediato que todos se enviaron sus mensajes llegaron al destinatario. <br><br>  Fue un caso ideal cuando no se produjo fuerza mayor.  Veamos ahora qué podría salir mal y cómo solucionarlo. <br><br>  Si Bob por alguna razón omite el primer paquete y acepta uno de los siguientes, entonces inmediatamente llama la atención sobre el hecho de que el contador N en él (el número de paquetes transmitidos por Alice) claramente excede el contador R del lado de Bob y Bob se da cuenta fácilmente de que perdió el primer paquete .  En este caso, solo necesita jugar al Capitán Evidence más plano y decirle a Alice el estado de su contador de paquetes recibidos (R = 0).  Al mismo tiempo, Alice entiende que ella es N = 3, y Bob tiene R = 0, es decir, es necesario transferir paquetes de una nueva manera, comenzando desde el primero. <br><br>  Si observa este esquema detenidamente, puede ver que cualquier transmisión del estado de sus contadores por parte de cualquier suscriptor le informa inmediatamente sobre el resultado de la transmisión de paquetes de datos, y la diferencia entre el contador transmitido por un lado y recibido por el otro indica cuántos paquetes se perdieron y de qué número comenzó. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, en el peor de los casos, hay una retransmisión completa de la transmisión, en el caso promedio, el contador A en el lado del transmisor aumenta al valor del contador R en el lado receptor y "envía" los paquetes perdidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es fácil entender que de esta manera se mantiene la continuidad del incremento de los contadores, lo que significa que la transmisión de mensajes (paquetes) está garantizada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además de las variables de ARN, cada suscriptor tiene dos banderas SACK y SPEP. Si el primero está instalado, debe enviar una confirmación (Enviar confirmación), si es el segundo, debe enviar una solicitud de confirmación (Enviar REPly a un mensaje).</font></font><br><br> ,   DDCMP     — SNAK (Send Negative AcKnowledgement).         - .               ,      , ,         —       . <br>       ,      . <br><br>          - . -      .  Y es verdad    . <br>                  . <br><br>       ,        —   ,   .      ,   ,    L,   (,      —  R). <br><div class="scrollable-table"><table><tbody><tr><th>  </th><th>  </th></tr><tr><td>    NR=RL+1 </td><td> 1)   <br> 2)    <br> 3) RL=RL+1 <br> 4)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 5) AL=RR <br></td></tr><tr><td>     — REP </td><td> 1) SACK = true <br> 2) SREP = false <br></td></tr><tr><td>   — ACK </td><td> 1)   <br> 2) SREP = false <br> 3)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 4) AL=RR <br></td></tr><tr><td>    </td><td> 1) SREP = true </td></tr><tr><td>      SREP </td><td> 1)     REP(RL, NL) <br> 2)   <br></td></tr><tr><td>    AL&lt;NL </td><td> 1)     AL+1 <br> 2)   <br></td></tr><tr><td>  ,   SACK </td><td> 1)   ACK(RL,NL) </td></tr><tr><td>  , AL=NL,  SACK  SREP <br>  ,     <br></td><td> 1) NL=NL+1 <br> 2)     <br></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora mira de cerca, recorre todo el circuito en la cabeza. Nos damos cuenta de lo que falta aquí. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la descripción original de DDCMP, de la cual nos hemos alejado bastante, esto se llama la bandera SELECCIONAR - un nodo (Alice o Bob) puede o no ser "elegido". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que nos confundió fue que ningún mecanismo estaba autorizado para permitir o prohibir la transferencia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, aquí está: esta es la bandera SELECCIONAR. Se aplica de manera muy simple: si se establece la bandera, entonces es posible transmitir, si no, es imposible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los mensajes de control como ACK y REP deben contener este indicador. </font><font style="vertical-align: inherit;">El último paquete en la cola también debe contener esta bandera. </font><font style="vertical-align: inherit;">Si un nodo "cose" una bandera en un paquete, "la regala" y, en consecuencia, ya no está instalada. </font><font style="vertical-align: inherit;">El nodo que detecta este indicador en el paquete, por el contrario, debe instalarlo por sí mismo. </font><font style="vertical-align: inherit;">Esto es similar a pasar un bastón o jugar un picadillo (¿recuerdas eso?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo más importante al trabajar con este indicador es que uno de los nodos debe tener este indicador por defecto, y el otro no. </font><font style="vertical-align: inherit;">Ese es otro temporizador muy importante: el temporizador de retorno de la bandera SELECT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos un conjunto completo de reglas para establecer una conexión y transmitir datos a través de ella. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No nos referimos solo a la implementación concreta de este conjunto de reglas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, arreglalo!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formación y formato de paquete </font></font></h3><br>   Message Framing —        . <br>  ,    . <br><br> 1.    ,       R  N .  Arduino         8    .      ,      ,    4-. <br><br>     : <br><pre><code class="cpp hljs"> = (RL &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | (NL &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Y leeremos el estado de los contadores así: <br><pre> <code class="cpp hljs">NR = (c &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; RR = c &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>;</code> </pre> <br>  c - byte correspondiente del mensaje <br><br>  2. También recordamos que cada mensaje debe contener el estado del indicador SELECT.  Y los diferentes tipos de mensajes en sí serán: <br><div class="scrollable-table"><table><tbody><tr><th>  Nombre gracioso <br></th><th>  Nombre serio <br></th><th>  Descripción <br></th><th>  SELECCIONE el valor del indicador <br></th><th>  Valor PTYPE </th></tr><tr><td>  "HAZLO UNA VEZ!" <br></td><td>  STR <br></td><td>  ESTADO <br></td><td>  cierto </td><td>  40 <br></td></tr><tr><td>  "HACER DOS!" <br></td><td>  STA <br></td><td>  STart reconocido </td><td>  cierto </td><td>  36 </td></tr><tr><td>  "NOOL ACEPTADO!" <br></td><td>  ACK (NL = 0, RL = 0) <br></td><td>  Reconocimiento <br></td><td>  cierto </td><td>  33 <br></td></tr><tr><td>  "ACEPTADO POR ER, ENVIADO POR EN" </td><td>  ACK (NL, RL) </td><td>  Reconocimiento </td><td>  cierto </td><td>  33 </td></tr><tr><td>  "CONFIRMAR CÓMO ENTIENDO?" <br></td><td>  REP (NL, RL) <br></td><td>  RESPONDER a un mensaje </td><td>  cierto </td><td>  34 </td></tr><tr><td>  "PAQUETE DE DATOS" <br></td><td>  DTA (NL, RL) <br></td><td>  Paquete de datos </td><td>  falso </td><td>  17 </td></tr><tr><td>  PAQUETE DE DATOS EXTREMOS <br></td><td>  DTE (NL, RL) </td><td>  Paquete DaTa - Fin </td><td>  cierto </td><td>  49 </td></tr></tbody></table></div><br><br>  Es decir, solo 6 tipos diferentes de mensajes.  Todos los mensajes, excepto DTA, "liberan" el indicador SELECT; necesitan una respuesta inmediata del suscriptor remoto, y sin el indicador no podrá transmitirlo.  El mensaje de DTA no devuelve una bandera para hacer posible la canalización. <br><br>  En general, tenemos suficientes 3 bits para el tipo de mensaje, pero para no alterarlos, asignamos un byte completo al tipo; en caso de revisión, tendremos cierta libertad de acción. <br><br>  Si el mensaje contiene datos, entonces necesitamos transferir su cantidad y suma de verificación.  Como el tamaño máximo del paquete es de 64 bytes, también tomaremos un byte para la suma de comprobación y la longitud; de repente, tendrá que aumentar el tamaño del paquete. <br><br>  3. También necesitamos alguna firma del comienzo del mensaje y una suma de verificación separada para el encabezado. <br><br>  Con todo esto en mente, el encabezado (también conocido como mensajes de control) se ve así: <br><div class="scrollable-table"><table><tbody><tr><th>  Desplazamiento, byte <br></th><th>  Descripción </th><th>  Tamaño, poco </th></tr><tr><td>  0 0 </td><td>  SIGN = 0xAD <br></td><td>  8 </td></tr><tr><td>  1 </td><td>  PTYPE </td><td>  8 </td></tr><tr><td>  2 </td><td>  TCNT </td><td>  4 4 <br></td></tr><tr><td>  2 </td><td>  RCNT </td><td>  4 4 </td></tr><tr><td>  3 </td><td>  Hchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Y el bloque de datos es así: <br><div class="scrollable-table"><table><tbody><tr><th>  Desplazamiento, byte <br></th><th>  Descripción </th><th>  Tamaño, poco </th></tr><tr><td>  4 4 </td><td>  DCNT <br></td><td>  8 </td></tr><tr><td>  5..5 + DCNT-1 <br></td><td>  DATOS <br></td><td>  8 * DCNT </td></tr><tr><td>  5 + DCNT </td><td>  Dchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Eso es todo  Esta es una descripción completa del protocolo que obtuvimos de DDCMP. <br>  Ahora puede pasar por la implementación. <br><br><h3>  ¿Cómo está organizado y cómo usarlo? </h3><br>  Primero, un poco sobre la estructura del repositorio. <br>  Como mencioné al principio, el código del proyecto se encuentra en el github: <a href="https://github.com/AlekUnderwater/uMCPIno" rel="nofollow">uMCPIno</a> <br><br>  Para ver cómo funciona todo, puede ejecutar una <a href="" rel="nofollow">aplicación de prueba</a> en una PC. <br><br>  En el archivo, ejecute uMCPIno_Test.exe, seleccione el puerto COM deseado e intente cómo funciona. <br>  Puede verificar un par de puertos COM virtuales (generalmente hago esto). <br>  ¿Por qué puede ejecutar dos copias de la aplicación?  Simplemente no olvide activar “SELECCIONADO POR DEFECTO” en una copia, esta será Master, y en la otra, desactívela.  Por cierto, si está interesado, puede ver qué sucede si no cumple con esta regla =) <br><br>  La opción EXTRAS le permite ver todos los movimientos de pensamientos dentro del cerebro del protocolo.  Se mostrarán todos los cambios en el estado de las banderas SELECT, eventos de temporizadores, cambios en el estado del nodo y también los valores de las variables R y N en los mensajes transmitidos y recibidos. <br><br>  Conecto mi Arduino UNO a mi computadora portátil a través de un convertidor UART &lt;-&gt; USB.  Los conectores de clavija le permiten simular un salto de línea en cualquier momento: <br><img src="https://habrastorage.org/webt/nn/vg/kp/nnvgkplqtoqbazpubopcb8bff-g.jpeg"><br><br>  Si ahora ejecuta la aplicación en la computadora portátil, luego de presionar el botón "CONECTAR", la arduina establecerá una conexión: <br><img src="https://habrastorage.org/webt/cy/jm/lx/cyjmlxn_ga-_zvrzel5yjmfwdz4.png"><br><br>  Y así es como el sistema reacciona a un intento de enviar a través de una línea "desgarrada": <br><img src="https://habrastorage.org/webt/lu/kb/dw/lukbdwxot1xuopxjdqxgpq1xqsq.png"><br><br>  Para incrustar uMCPIno en su aplicación para PC: <br><ol><li>  El repositorio tiene una biblioteca uMCPIno.  Conéctelo a las referencias de su proyecto. </li><li>  Contiene la clase uMCPInoPort.  Declaramos su instancia: <br><pre> <code class="cs hljs">uMCPInoPort port; port = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uMCPInoPort(<span class="hljs-string"><span class="hljs-string">"COM1"</span></span>, UCNLDrivers.BaudRate.baudRate9600, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">8100</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre><br>  Parámetros en orden: nombre del puerto, luego velocidad del puerto, estado SELECT predeterminado, intervalo para SELECT, intervalo de tiempo de espera, tamaño de paquete y la cantidad máxima de mensajes no reconocidos. <br></li><li>  Suscríbase a eventos: <br>  cuando el indicador SELECT - port.Select cambia: <br><pre> <code class="cs hljs">OnSelectChangedEventHandler</code> </pre> <br>  cuando el estado cambia - puerto. Estado: <br><pre> <code class="cs hljs">OnStateChangedEventHandler</code> </pre> <br>  El host remoto confirma la recepción del código: <br><pre> <code class="cs hljs">OnDataBlockAcknowledgedEventHandler</code> </pre> <br>  cuando llega el paquete de datos: <br><pre> <code class="cs hljs">OnDataBlockReceivedEventHandler</code> </pre> <br></li><li>  Antes del trabajo, abra el puerto. <br><pre> <code class="cs hljs">port.Open();</code> </pre> <br></li><li>  Para enviar datos, llamamos al método: <pre> <code class="cs hljs">port.Send(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data);</code> </pre> <br></li><li>  Al finalizar, cierre el puerto: <pre> <code class="cs hljs">port.Close();</code> </pre> <br></li></ol><br><br>  ¡Solo envíe dos bytes! <br><br>  Ahora pasemos a la implementación de Arduino.  Hay dos ejemplos en la carpeta <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">github.com/AlekUnderwater/uMCPIno/tree/master/Arduino</a> <br><br>  <a href="" rel="nofollow">El primero</a> es solo un convertidor desde y hacia uMCP.  El primer Serial sirve para comunicarse con el Host, y Serial1 (si está en su placa) o SoftwareSerial en los pines 2 y 3, para comunicarse con otro nodo uMCPIno.  Puede conectar Bluetooth o un módulo de radio aquí. <br><br>  <a href="" rel="nofollow">El segundo</a> es una plantilla de proyecto con soporte para el protocolo uMCPIno <br><br>  Ambos proyectos tienen configuraciones donde puedes y debes escalar.  Aquí están: <br><br>  El estado predeterminado del indicador SELECT.  Si se establece en (verdadero), incluso si el nodo remoto no devuelve el indicador, el temporizador lo establecerá en verdadero. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_STATE (false)</span></span></code> </pre> <br><br>  Para establecer el período de este temporizador, existe la siguiente configuración: intervalo para devolver el indicador SELECT en milisegundos <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_INTERVAL_MS (4000)</span></span></code> </pre> <br><br>  El intervalo para esperar una respuesta en milisegundos, es mejor dejarlo un poco menos que el intervalo para devolver el indicador SELECT. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_TIMEOUT_INTERVAL_MS (3000)</span></span></code> </pre> <br><br>  La velocidad de transmisión real de la línea.  Este parámetro es necesario para determinar cuándo finalizará la transferencia. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_LINE_BAUDRATE_BPS (9600)</span></span></code> </pre> <br><br>  Intervalo de acumulación de datos para el algoritmo de Nagle.  Insolentemente tómalo igual a 100 milisegundos.  Durante este tiempo, estamos esperando un conjunto de paquetes, si no está escrito, lo enviamos tal cual.  La tarea del algoritmo de Nagle es librar a la red de un montón de paquetes pequeños de uno a varios bytes de tamaño. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_NAGLE_DELAY_MS (100)</span></span></code> </pre> <br><br>  Esta configuración establece las velocidades del puerto para la comunicación con el sistema de control (Host) y la línea.  No confunda la velocidad del puerto con una línea con una velocidad de transferencia física. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_HOST_CONNECTION_BAUDRATE_BPS (9600) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Host connection port speed #define CFG_LINE_CONNECTION_BAUDRATE_BPS (9600) // Line connection port speed</span></span></span></span></code> </pre> <br><br>  Si esta configuración está habilitada, cuando se suministre energía al controlador, el protocolo mismo se ordenará a sí mismo comenzar a establecer una conexión. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IS_AUTOSTART_ON_POWERON (true)</span></span></code> </pre> <br><br>  Este es el tamaño en bytes del búfer para los paquetes de datos entrantes. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IL_RING_SIZE (255)</span></span></code> </pre> <br><br>  A continuación, veamos cómo se ve el bucle de boceto principal: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uMCP_ITimers_Process(); DC_Input_Process(); DC_Output_Process(); <span class="hljs-comment"><span class="hljs-comment">//  ip_ready  ,      if (ip_ready) { uMCP_OnIncomingPacket(); } //        ,     -  if ((state == uMCP_STATE_HALTED) &amp;&amp; ((ih_Cnt &gt; 0) || (isStartup &amp;&amp; CFG_IS_AUTOSTART_ON_POWERON))) { if (isStartup) { isStartup = false; } uMCP_STATE_Set(uMCP_STATE_ISTART); uMCP_CtrlSend(uMCP_PTYPE_STR, 0, 0, true); } else if (state == uMCP_STATE_RUNNING) { uMCP_Protocol_Perform(); //      -   if (il_ready) { il_ready = false; USER_uMCPIno_DataPacketReceived(); } } }</span></span></code> </pre><br><br>  Ahora veamos cómo funciona el protocolo.  La lógica principal está contenida en la función uMCP_Protocol_Perform ();  Aquí está su código: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_Protocol_Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == uMCP_STATE_RUNNING) { <span class="hljs-comment"><span class="hljs-comment">//              SELECT  if ((!iTimer_State[uMCP_Timer_TX]) &amp;&amp; (!iTimer_State[uMCP_Timer_TMO]) &amp;&amp; (select)) { //     if (ih_Cnt == 0) { //    REP -  if (srep) { uMCP_CtrlSend(uMCP_PTYPE_REP, N, R, true); srep = false; } //     -   else if (sentBlocksCnt &gt; 0) { uMCP_DataBlockResend((A + 1) % UMCP_PACKETS_NUMBER, true, true); } //    SACK  -        //  -       ACK else if ((!selectDefaultState) || (sack)) { uMCP_CtrlSend(uMCP_PTYPE_ACK, N, R, false); sack = false; } } //     -  else if (ih_Cnt &gt; 0) { //              -  if ((ih_Cnt &gt;= UMCP_PACKET_DATA_SIZE) || (millis() &gt;= ih_TS + CFG_NAGLE_DELAY_MS)) { //   N N = (N + 1) % UMCP_PACKETS_NUMBER; uMCP_NextDataBlockSend(); } } } } }</span></span></code> </pre><br><br>  Un analizador de paquetes que vive en una función. <pre> <code class="cpp hljs">On_NewByte_From_Line</code> </pre>  también organizado por el principio de una máquina de estados finitos y funciona "byte por byte".  Esto se hace para ahorrar memoria. <br><br>  El resto de la implementación no es de particular interés.  Analizaremos mejor cómo interactúa el usuario con el protocolo.  En este ejemplo, hay cuatro "puntos de contacto". <br><br>  La primera es la función de enviar datos en la línea uMCPIno: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCPIno_SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte* dataToSend, byte dataSize)</span></span></span></span>;</code> </pre> <br>  Aquí todo es simple: tiene un búfer de datos dataToSend, su tamaño es dataSize.  La función devuelve verdadero si el envío es posible (hay espacio para agregar datos) y falso de lo contrario. <br>  Para no conducir en vano, puede verificar de inmediato la disponibilidad de espacio suficiente utilizando la función: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_IsCanSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte dataSize)</span></span></span></span>;</code> </pre> <br><br>  Para analizar los paquetes de datos entrantes, debe agregar su código al cuerpo de la función <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCPIno_DataPacketReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><br>  Los datos entrantes se escriben en el búfer de anillo il_ring.  Leer desde él se puede organizar en bytes de esta manera: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (il_Cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { c = il_ring[il_rPos]; il_rPos = (il_rPos + <span class="hljs-number"><span class="hljs-number">1</span></span>) % CFG_IL_RING_SIZE; il_Cnt--; <span class="hljs-comment"><span class="hljs-comment">//   "c" -      }</span></span></code> </pre><br><br>  Para placeres sofisticados hay una función <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCP_OnTxBufferEmptry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Que se llama cuando todos los datos se envían con éxito.  También es posible y necesario poner algún tipo de código en él. <br><br><h3>  ¿Por qué es todo esto y dónde? </h3><br>  Trate principalmente con Solo por diversión.  Además, necesitaba un protocolo simple y, lo más importante, "ligero" para enviar datos a través de nuestros módems de sonda <a href="https://habr.com/ru/post/428367/">uWAVE</a> .  Dado que transmiten datos a través del agua a una velocidad de solo 80 bps, y con su rango de comunicación máximo de 1000 metros y la velocidad del sonido en el agua de aproximadamente 1500 m / s, la transmisión está asociada con retrasos notables, y solo hay un canal de sonda (si no la mayoría) !) de los más ruidosos, lentos e inestables. <br>  En gran parte debido a esto, tuve que abandonar el mecanismo de reconocimiento negativo (NAK), si es posible no transmitir, en agua es mejor no transmitir al 100%. <br>  En realidad, el protocolo fue útil al transmitir datos a través de un canal de radio utilizando módulos <a href="http://www.dorji.com/products.php%3FCateId%3D9" rel="nofollow">DORJI</a> y el <a href="https%253A%252F%252Fwww.elecrow.com%252Fdownload%252FHC-12.pdf%26usg%3DAOvVaw2rNtYm7nLdpqPN6HR-LAS8" rel="nofollow">NS-012</a> conocido por los arduinoes. <br><br><h3>  Que sigue </h3><br>  Si hay tiempo, planeo agregar la posibilidad de direccionamiento (que, por cierto, estaba en DDCMP).  Dado que la tarea principal de este protocolo ahora es proporcionar comodidad para todo tipo de pruebas de nuestros módems de sonda y otras redes de sensores, entonces hay (¡literalmente!) Trampas allí.  Solo puedo decir que el problema no se puede resolver simplemente agregando los campos "Remitente" y "Destino". <br>  Quizás llegue a <a href="https://en.wikipedia.org/wiki/Geographic_routing" rel="nofollow">Enrutamiento geográfico</a> y todo ese jazz. <br><br><h3>  PS </h3><br>  Tradicionalmente, estaré muy agradecido por las críticas constructivas, los deseos y las sugerencias.  Siempre es importante comprender si está haciendo algo útil para las personas o está perdiendo el tiempo. <br>  Quizás, al tratar de evitar la transición de este largo hilo a la novela "Guerra y paz", me he perdido algunos detalles. No dude en preguntar. <br><br><h3>  PPS </h3><br>  Muchas gracias a la vergüenza de mi analfabetismo, señalando errores (gramaticales y lógicos): <br><ul><li>  <a href="https://habr.com/ru/users/berez/" class="user_link">berez</a> </li><li>  <a href="https://habr.com/ru/users/edo1h/" class="user_link">edo1h</a> </li></ul><br>  El proyecto fue originalmente de código abierto, pero ahora el artículo también es de código abierto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480110/">https://habr.com/ru/post/480110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480100/index.html">Principiantes Sobre SEO</a></li>
<li><a href="../480102/index.html">Resumen de gestión de productos de noviembre</a></li>
<li><a href="../480104/index.html">9 trucos HTML útiles</a></li>
<li><a href="../480106/index.html">Cómo ensamblar una imagen de Oracle DB para Testcontainers</a></li>
<li><a href="../480108/index.html">Física en un proyecto de unidad utilizando la lucha móvil como ejemplo</a></li>
<li><a href="../480112/index.html">Diferencias entre C ++ / Visual Basic y Java a nivel general (para principiantes y estudiantes)</a></li>
<li><a href="../480114/index.html">Todo sobre impuestos para trabajadores independientes de TI. IE y autónomos. Parte 1</a></li>
<li><a href="../480116/index.html">Posición del Grupo Mail.ru sobre el desarrollo de código abierto en Rusia</a></li>
<li><a href="../480118/index.html">Estamos escribiendo un simulador de escritura táctil usando JavaScript puro. Parte 1</a></li>
<li><a href="../480120/index.html">Un nuevo logro en criptografía: factorización de un RSA de 795 bits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>