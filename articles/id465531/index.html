<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💿 👍🏿 🙍🏾 Membongkar daftar bersarang dari kedalaman yang tidak terbatas 👩🏻‍🎨 👌🏽 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini saya ingin berbicara tentang membongkar daftar bersarang dari kedalaman yang tidak terbatas. Ini adalah tugas yang cukup sepele, jadi saya in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membongkar daftar bersarang dari kedalaman yang tidak terbatas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465531/"><p>  Hari ini saya ingin berbicara tentang membongkar daftar bersarang dari kedalaman yang tidak terbatas.  Ini adalah tugas yang cukup sepele, jadi saya ingin memberi tahu di sini tentang apa implementasi, pro dan kontra mereka dan perbandingan kinerja mereka. </p><br><p>  Artikel akan terdiri dari beberapa bagian di bawah ini: </p><br><ul><li>  Fungsi </li><li>  Data </li><li>  Hasil </li><li>  Kesimpulan </li></ul><a name="habracut"></a><br><h1 id="chast-1-funkcii">  Bagian 1. Fungsi </h1><br><h2 id="zaimstvovannye-realizacii">  Implementasi pinjaman </h2><br><h3 id="outer_flatten_1">  outer_flatten_1 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Based on C realization of this solution More on: https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deepflatten(array)</code> </pre> </div></div><br><p>  Saya mengambil fungsi ini untuk parsing dari paket eksternal, iteration_utilities. </p><br><p>  Implementasi dilakukan dalam C, meninggalkan python antarmuka panggilan fungsi tingkat tinggi. <br>  Implementasi fungsi di C agak rumit, Anda bisa melihatnya dengan mengklik tautan di spoiler.  Fungsinya adalah iterator. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Iterator, Generator &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> iteration_utilities <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deepflatten &gt;&gt;&gt; isinstance(deepflatten(a), Iterator) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(deepflatten(a), Generator) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Sulit untuk mengatakan tentang kompleksitas algoritma yang diterapkan di sini, jadi saya meninggalkan minat ini kepada pengguna Habr. </p><br><p>  Secara umum, saya juga ingin mencatat bahwa semua fungsi lain dari perpustakaan ini cukup cepat dan juga diimplementasikan dalam C. </p><br><h3 id="outer_flatten_2">  outer_flatten_2 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: .. code:: python try: tree = iter(node) except TypeError: yield node more on: https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collapse(array)</code> </pre> </div></div><br><p>  Implementasi metode membongkar daftar bersarang ini juga ada dalam paket eksternal, yaitu more_itertools. <br>  Fungsi ini dilakukan pada python murni, tetapi tidak optimal, menurut saya.  Implementasi terperinci dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> dokumentasi. <br>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h2 id="sobstvennye-realizacii">  Implementasi sendiri </h2><br><h3 id="niccolum_flatten">  niccolum_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">niccolum_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop/insert elements in current list """</span></span> new_array = array[:] ind = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isinstance(new_array[ind], list): item = new_array.pop(ind) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inner_item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(item): new_array.insert(ind, inner_item) ind += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IndexError: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_array</code> </pre> </div></div><br><p>  Ketika entah bagaimana muncul di telegram ke publik @ru_python_beginners tentang implementasi membongkar daftar bersarang dari nesting tak terbatas, saya mengusulkan pilihan saya sendiri. </p><br><p>  Terdiri dari fakta bahwa kita menyalin daftar asli (agar tidak mengubahnya), dan kemudian pada saat True loop kita periksa ketika item adalah daftar - kita menjelajahinya dan memasukkan hasilnya ke awal. </p><br><p>  Ya, sekarang saya mengerti bahwa itu tidak terlihat optimal dan sulit, karena  pengindeksan ulang terjadi setiap kali (karena kami menambah dan menghapus dari bagian atas daftar), namun opsi ini juga memiliki hak untuk hidup dan kami akan memeriksa implementasinya bersama dengan yang lainnya. </p><br><p>  Kompleksitas dari algoritma ini adalah O (n ^ 3 * m) karena membangun kembali daftar dua kali untuk setiap iterasi yang disahkan </p><br><h3 id="tishka_flatten">  tishka_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on append/extend elements to new list """</span></span> nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nested: new = [] nested = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): new.extend(i) nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(i) data = new <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> </div></div><br><p>  Salah satu yang pertama juga menunjukkan implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Tishka17</a> .  Terdiri dari fakta bahwa di dalam loop sementara nested berulang atas daftar yang ada dengan key nested = False, dan jika setidaknya sekali mendapat sheet, ia meninggalkan nested = True flag dan memperpanjang'it sheet ini ke daftar.  Dengan demikian, ternyata untuk setiap pelarian ia menjabarkan satu tingkat sarang, berapa banyak tingkat sarang akan ada - akan ada begitu banyak melewati siklus.  Seperti dapat dilihat dari deskripsi - bukan algoritma yang paling optimal, tetapi tetap saja, ini berbeda dari yang lain. <br>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h3 id="zart_flatten">  zart_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zart_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop from old and append elements to new list """</span></span> queue, out = [a], [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue: elem = queue.pop(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(elem, list): queue.extend(elem) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: out.append(elem) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out[::<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre> </div></div><br><p>  Algoritme juga disarankan oleh salah satu peserta obrolan yang berpengalaman.  Menurut saya, ini cukup sederhana dan bersih.  Artinya adalah jika elemen adalah daftar, kami menambahkan hasilnya ke akhir daftar asli, dan jika tidak, kami menambahkannya ke output.  Saya akan menyebutnya di bawah mekanisme extended / append.  Sebagai hasilnya, kami menampilkan daftar datar hasil yang dihasilkan terbalik untuk mempertahankan urutan asli elemen. </p><br><p>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h3 id="recursive_flatten_iterator">  recursive_flatten_iterator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arr: Iterable)</span></span></span><span class="hljs-function"> -&gt; Iterator:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm based on iterator Usual solution to this problem """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> recursion_flatten(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i</code> </pre> </div></div><br><p>  Mungkin solusi paling umum untuk masalah ini adalah melalui rekursi dan hasil dari.  Tidak banyak yang bisa dikatakan - algoritme tampaknya cukup sederhana dan efisien, terlepas dari kenyataan bahwa hal itu dilakukan melalui rekursi dan, dengan selungkup besar, mungkin ada setumpuk panggilan yang cukup besar. </p><br><p>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h3 id="recursive_flatten_generator">  recursive_flatten_generator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm Looks like recursive_flatten_iterator, but with extend/append """</span></span> lst = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): lst.extend(recursive_flatten_list(i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lst.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lst</code> </pre> </div></div><br><p>  Fungsi ini sangat mirip dengan yang sebelumnya, hanya dijalankan bukan melalui iterator, tetapi melalui mekanisme perpanjangan / penambahan rekursif. </p><br><p>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h3 id="tishka_flatten_with_stack">  tishka_flatten_with_stack </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten_with_stack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(seq: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on zart_flatten, but build on try/except pattern """</span></span> stack = [iter(seq)] new = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> stack: i = stack.pop() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: data = next(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(data, list): stack.append(i) i = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(data) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> </div></div><br><p>  Satu lagi algoritma yang disediakan Tishka, yang, pada kenyataannya, sangat mirip dengan zart_flatten, namun, itu diimplementasikan di sana melalui mekanisme extended / append sederhana, kemudian melalui iterasi dalam loop tak terbatas di mana mekanisme ini digunakan.  Jadi ternyata sesuatu yang mirip dengan zart_flatten, tetapi melalui iterasi dan sementara Benar. </p><br><p>  Kompleksitas dari algoritma ini adalah O (n * m). </p><br><h1 id="chast-2-dannye">  Bagian 2. Data </h1><br><p>  Untuk menguji keefektifan algoritma ini, kita perlu membuat fungsi untuk pembuatan daftar nesting tertentu secara otomatis, yang telah berhasil saya atasi dan akan menunjukkan kepada Anda hasilnya di bawah ini: </p><br><h3 id="create_data_decreasing_depth">  create_data_decreasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_decreasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth on decreasing. Examples: &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2, 3, 4, 5], 6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2], 3, 4], 5, 6], [[7, 8,] 9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: _result.append(create_data_decreasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, _result=_result)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: _result += create_data_decreasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Fungsi ini membuat daftar bersarang dengan mengurangi bersarang. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [[<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,] <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="create_data_increasing_depth">  create_data_increasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_increasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth to increase. Examples: &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, [3, 4, [5, 6]]], 7, 8, [9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result.append(tmp_res) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result += tmp_res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Fungsi ini membuat daftar bersarang dengan meningkatnya sarang. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]]], <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="generate_data">  menghasilkan_data </h3><br><div class="spoiler">  <b class="spoiler_title">Implementasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt; List[Tuple[str, Dict[str, Union[range, Num]]]]:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generated collections of Data by pattern {amount_item}_amount_{length}_length_{max_depth}_max_depth where: .. py:attribute:: amount_item: len of flatten elements .. py:attribute:: length: len of elements at the same level of nesting .. py:attribute:: max_depth: highest possible level of nesting """</span></span> data = [] amount_of_elements = [<span class="hljs-number"><span class="hljs-number">10</span></span> ** i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span> <span class="hljs-comment"><span class="hljs-comment"># amount_item doesn't need to be [1] for amount_item in amount_of_elements[1:]: for max_depth in amount_of_elements: # for exclude flatten list after generate data by create_data_increasing_depth if amount_item &gt; max_depth: # generate four types of length for length in range(0, max_depth + 1, math.ceil(max_depth / 4)): # min length must be 1 length = length or 1 data_name = data_template.format( amount_item=amount_item, length=length, max_depth=max_depth ) data_value = { 'data': range(amount_item), 'length': length, 'max_depth': max_depth } data.append((data_name, data_value)) # for not to produce more than 1 flat entity if max_depth == 1: break # this order is convenient for me data = sorted(data, key=lambda x: [x[1]['data'][-1], x[1]['max_depth'], x[1]['length']]) return data</span></span></code> </pre> </div></div><br><p>  Fungsi ini secara langsung membuat pola untuk data uji.  Untuk melakukan ini, ini menghasilkan header yang dibuat oleh templat. </p><br><pre> <code class="python hljs">data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span></code> </pre> <br><p>  Dimana: </p><br><ul><li>  jumlah - jumlah total item dalam daftar </li><li>  panjang - jumlah elemen pada satu tingkat sarang </li><li>  max_depth - jumlah maksimum level bersarang </li></ul><br><p>  Data itu sendiri ditransfer ke fungsi di atas untuk menghasilkan data yang diperlukan.  Dengan demikian, output, seperti yang akan kita lihat nanti, kita akan memiliki data berikut (header): </p><br><pre> <code class="plaintext hljs">10_amount_1_length_1_max_depth 100_amount_1_length_1_max_depth 100_amount_1_length_10_max_depth 100_amount_3_length_10_max_depth 100_amount_6_length_10_max_depth 100_amount_9_length_10_max_depth 1000_amount_1_length_1_max_depth 1000_amount_1_length_10_max_depth 1000_amount_3_length_10_max_depth 1000_amount_6_length_10_max_depth 1000_amount_9_length_10_max_depth 1000_amount_1_length_100_max_depth 1000_amount_25_length_100_max_depth 1000_amount_50_length_100_max_depth 1000_amount_75_length_100_max_depth 1000_amount_100_length_100_max_depth 10000_amount_1_length_1_max_depth 10000_amount_1_length_10_max_depth 10000_amount_3_length_10_max_depth 10000_amount_6_length_10_max_depth 10000_amount_9_length_10_max_depth 10000_amount_1_length_100_max_depth 10000_amount_25_length_100_max_depth 10000_amount_50_length_100_max_depth 10000_amount_75_length_100_max_depth 10000_amount_100_length_100_max_depth 10000_amount_1_length_1000_max_depth 10000_amount_250_length_1000_max_depth 10000_amount_500_length_1000_max_depth 10000_amount_750_length_1000_max_depth 10000_amount_1000_length_1000_max_depth</code> </pre> <br><h1 id="chast-3-rezultaty">  Bagian 3. Hasil </h1><br><p>  Untuk profil CPU - saya menggunakan line_profiler <br>  Untuk grafik - timeit + matplotlib </p><br><h4 id="cpu-profayler">  CPU Profiler </h4><br><div class="spoiler">  <b class="spoiler_title">Kesimpulan</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ kernprof -l funcs.py $ python -m line_profiler funcs.py.lprof Timer unit: 1e-06 s Total time: 1.7e-05 s File: funcs.py Function: outer_flatten_1 at line 11 Line # Hits Time Per Hit % Time Line Contents ============================================================== 11 @profile 12 def outer_flatten_1(array: Iterable) -&gt; List: 13 """ 14 Based on C realization of this solution 15 More on: 16 17 https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html 18 19 https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c 20 """ 21 2 17.0 8.5 100.0 return deepflatten(array) Total time: 3.3e-05 s File: funcs.py Function: outer_flatten_2 at line 24 Line # Hits Time Per Hit % Time Line Contents ============================================================== 24 @profile 25 def outer_flatten_2(array: Iterable) -&gt; List: 26 """ 27 recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: 28 29 .. code:: python 30 31 try: 32 tree = iter(node) 33 except TypeError: 34 yield node 35 36 more on: 37 https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse 38 """ 39 2 33.0 16.5 100.0 return collapse(array) Total time: 0.105099 s File: funcs.py Function: niccolum_flatten at line 42 Line # Hits Time Per Hit % Time Line Contents ============================================================== 42 @profile 43 def niccolum_flatten(array: Iterable) -&gt; List: 44 """ 45 Non recursive algorithm 46 Based on pop/insert elements in current list 47 """ 48 49 2 39.0 19.5 0.0 new_array = array[:] 50 2 6.0 3.0 0.0 ind = 0 51 2 2.0 1.0 0.0 while True: 52 20002 7778.0 0.4 7.4 try: 53 21010 13528.0 0.6 12.9 while isinstance(new_array[ind], list): 54 1008 1520.0 1.5 1.4 item = new_array.pop(ind) 55 21014 13423.0 0.6 12.8 for inner_item in reversed(item): 56 20006 59375.0 3.0 56.5 new_array.insert(ind, inner_item) 57 20000 9423.0 0.5 9.0 ind += 1 58 2 2.0 1.0 0.0 except IndexError: 59 2 2.0 1.0 0.0 break 60 2 1.0 0.5 0.0 return new_array Total time: 0.137481 s File: funcs.py Function: tishka_flatten at line 63 Line # Hits Time Per Hit % Time Line Contents ============================================================== 63 @profile 64 def tishka_flatten(data: Iterable) -&gt; List: 65 """ 66 Non recursive algorithm 67 Based on append/extend elements to new list 68 69 """ 70 2 17.0 8.5 0.0 nested = True 71 1012 1044.0 1.0 0.8 while nested: 72 1010 1063.0 1.1 0.8 new = [] 73 1010 992.0 1.0 0.7 nested = False 74 112018 38090.0 0.3 27.7 for i in data: 75 111008 50247.0 0.5 36.5 if isinstance(i, list): 76 1008 1431.0 1.4 1.0 new.extend(i) 77 1008 1138.0 1.1 0.8 nested = True 78 else: 79 110000 42052.0 0.4 30.6 new.append(i) 80 1010 1406.0 1.4 1.0 data = new 81 2 1.0 0.5 0.0 return data Total time: 0.062931 s File: funcs.py Function: zart_flatten at line 84 Line # Hits Time Per Hit % Time Line Contents ============================================================== 84 @profile 85 def zart_flatten(a: Iterable) -&gt; List: 86 """ 87 Non recursive algorithm 88 Based on pop from old and append elements to new list 89 """ 90 2 20.0 10.0 0.0 queue, out = [a], [] 91 21012 12866.0 0.6 20.4 while queue: 92 21010 16849.0 0.8 26.8 elem = queue.pop(-1) 93 21010 17768.0 0.8 28.2 if isinstance(elem, list): 94 1010 1562.0 1.5 2.5 queue.extend(elem) 95 else: 96 20000 13813.0 0.7 21.9 out.append(elem) 97 2 53.0 26.5 0.1 return out[::-1] Total time: 0.052754 s File: funcs.py Function: recursive_flatten_generator at line 100 Line # Hits Time Per Hit % Time Line Contents ============================================================== 100 @profile 101 def recursive_flatten_generator(array: Iterable) -&gt; List: 102 """ 103 Recursive algorithm 104 Looks like recursive_flatten_iterator, but with extend/append 105 106 """ 107 1010 1569.0 1.6 3.0 lst = [] 108 22018 13565.0 0.6 25.7 for i in array: 109 21008 17060.0 0.8 32.3 if isinstance(i, list): 110 1008 6624.0 6.6 12.6 lst.extend(recursive_flatten_generator(i)) 111 else: 112 20000 13622.0 0.7 25.8 lst.append(i) 113 1010 314.0 0.3 0.6 return lst Total time: 0.054103 s File: funcs.py Function: recursive_flatten_iterator at line 116 Line # Hits Time Per Hit % Time Line Contents ============================================================== 116 @profile 117 def recursive_flatten_iterator(arr: Iterable) -&gt; Iterator: 118 """ 119 Recursive algorithm based on iterator 120 Usual solution to this problem 121 122 """ 123 124 22018 20200.0 0.9 37.3 for i in arr: 125 21008 19363.0 0.9 35.8 if isinstance(i, list): 126 1008 6856.0 6.8 12.7 yield from recursive_flatten_iterator(i) 127 else: 128 20000 7684.0 0.4 14.2 yield i Total time: 0.056111 s File: funcs.py Function: tishka_flatten_with_stack at line 131 Line # Hits Time Per Hit % Time Line Contents ============================================================== 131 @profile 132 def tishka_flatten_with_stack(seq: Iterable) -&gt; List: 133 """ 134 Non recursive algorithm 135 Based on zart_flatten, but build on try/except pattern 136 """ 137 2 24.0 12.0 0.0 stack = [iter(seq)] 138 2 5.0 2.5 0.0 new = [] 139 1012 357.0 0.4 0.6 while stack: 140 1010 435.0 0.4 0.8 i = stack.pop() 141 1010 328.0 0.3 0.6 try: 142 1010 330.0 0.3 0.6 while True: 143 22018 17272.0 0.8 30.8 data = next(i) 144 21008 18951.0 0.9 33.8 if isinstance(data, list): 145 1008 997.0 1.0 1.8 stack.append(i) 146 1008 1205.0 1.2 2.1 i = iter(data) 147 else: 148 20000 15413.0 0.8 27.5 new.append(data) 149 1010 425.0 0.4 0.8 except StopIteration: 150 1010 368.0 0.4 0.7 pass 151 2 1.0 0.5 0.0 return new</code> </pre> </div></div><br><h4 id="grafiki">  Grafik </h4><br><p>  Hasil keseluruhan: </p><br><p><img src="https://habrastorage.org/webt/mv/hn/er/mvhner8sf4u_w9alvn647vudda0.png"></p><br><p>  Tidak termasuk fungsi paling lambat, kami mendapatkan: </p><br><p><img src="https://habrastorage.org/webt/gs/nm/pg/gsnmpgozl3yv02xdzllnuqvlif0.png"></p><br><h1 id="chast-4-vyvody">  Bagian 4. Kesimpulan </h1><br><p>  Mungkin saya akan mengatakan hal yang jelas, tetapi, meskipun kompleksitas algoritma diketahui, hasilnya mungkin tidak jelas.  Jadi, fungsi niccolum_flatten, yang kompleksitasnya paling tinggi, masuk ke tahap akhir dan mengambil jauh dari tempat terakhir.  Dan recursive_flatten_generator ternyata jauh lebih cepat daripada recursive_flatten_iterator. </p><br><p>  Kesimpulannya, saya ingin mengatakan pertama-tama bahwa ini lebih merupakan sebuah studi daripada panduan untuk menulis daftar algoritma pembongkaran yang efektif.  Biasanya, Anda dapat menulis implementasi paling sederhana tanpa berpikir apakah itu yang tercepat, karena  sedikit tabungan. </p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><p>  Hasil yang lebih lengkap dapat ditemukan di <a href="">sini.</a> <br>  Repositori dengan kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br>  Dokumentasi melalui sphinx <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </p><br><p>  Jika Anda menemukan kesalahan, tulis ke telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Niccolum</a> atau ke lastsal@mail.ru. <br>  Saya akan senang menerima kritik yang membangun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465531/">https://habr.com/ru/post/id465531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465521/index.html">Fly-fly-petal ... atau kisah tentang bagaimana desainer UX mempromosikan produknya di Instagram</a></li>
<li><a href="../id465523/index.html">Namun ular Android lainnya dengan Kivy, Python</a></li>
<li><a href="../id465525/index.html">Laporan seluler tentang Oracle BI EE 12c - satu, dua, tiga. Metodologi dari Kursus Oracle BI EE 12c CAD</a></li>
<li><a href="../id465527/index.html">Perjalanan panjang dari RFC 4357 ke RFC 8645 atau cara mengelola kunci enkripsi</a></li>
<li><a href="../id465529/index.html">Penangguhan lebih dari pemblokiran</a></li>
<li><a href="../id465535/index.html">Siapa yang mengimplementasikan IPv6, dan apa yang menghambat perkembangannya</a></li>
<li><a href="../id465537/index.html">Yandex: rumah pintar dewasa</a></li>
<li><a href="../id465539/index.html">766 km - rekor jangkauan baru untuk LoRaWAN</a></li>
<li><a href="../id465541/index.html">Dari Perusahaan ke SMB: Kami berbagi pengalaman kami dalam mengadaptasi solusi perusahaan untuk usaha kecil dan menengah dengan monetisasi menggunakan model SaaS</a></li>
<li><a href="../id465545/index.html">Di sisi berbeda negara: bagaimana Facebook digoreng di Kongres AS, sementara Telegram bertarung dengan FSB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>