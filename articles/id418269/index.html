<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎽 🍼 🐐 Cara Kerja Manajer CPU di Kubernetes 🍥 🧙🏽 👸🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Artikel ini diterbitkan di blog resmi Kubernetes dan ditulis oleh dua karyawan Intel yang terlibat langsung dalam pengembangan CPU Ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja Manajer CPU di Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/418269/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Artikel ini diterbitkan di blog resmi Kubernetes dan ditulis oleh dua karyawan Intel yang terlibat langsung dalam pengembangan CPU Manager, fitur baru di Kubernetes yang kami tulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis 1.8</a> review.</i>  <i>Saat ini (mis., Untuk K8 1.11), fitur ini memiliki status beta, dan membaca lebih lanjut tentang tujuannya nanti di catatan.</i> <br><br>  Publikasi berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CPU Manager</a> , fitur beta di Kubernetes.  CPU Manager memungkinkan Anda untuk mendistribusikan beban kerja dengan lebih baik di Kubelet, mis.  pada agen host Kubernetes, dengan menugaskan CPU khusus untuk wadah perapian tertentu. <br><br><img src="https://habrastorage.org/webt/h-/5g/yo/h-5gyocq5lrz2vsvso7ioblnb3q.png"><a name="habracut"></a><br><br><h2>  Kedengarannya bagus!  Tetapi apakah Manajer CPU membantu saya? </h2><br>  Tergantung pada beban kerja.  Satu-satunya simpul komputasi di kluster Kubernetes dapat menjalankan banyak perapian, dan beberapa di antaranya dapat menjalankan beban yang aktif dalam konsumsi CPU.  Dalam skenario ini, perapian dapat bersaing untuk sumber daya proses yang tersedia di simpul ini.  Ketika kompetisi ini meningkat, beban kerja dapat beralih ke CPU lain tergantung pada apakah itu <i>dibatasi di</i> bawah dan CPU mana yang tersedia pada saat perencanaan.  Selain itu, mungkin ada kasus di mana beban kerja sensitif terhadap konteks switch.  Dalam semua skenario ini, kinerja beban kerja mungkin terpengaruh. <br><br>  Jika beban kerja Anda sensitif terhadap skenario seperti itu, Anda dapat mengaktifkan CPU Manager untuk memberikan isolasi kinerja yang lebih baik dengan mengalokasikan CPU tertentu ke beban. <br><br>  CPU Manager dapat membantu memuat dengan fitur-fitur berikut: <br><br><ul><li>  Sensitif terhadap efek pelambatan CPU </li><li>  peka terhadap sakelar konteks; </li><li>  cache prosesor ketinggalan; </li><li>  Mendapatkan manfaat dari membagi sumber daya prosesor (mis., Cache data dan instruksi); </li><li>  memori yang peka-memori di antara soket prosesor <i>(penjelasan terperinci tentang apa yang ada dalam pikiran penulis diberikan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unix Stack Exchange</a> - <b>sekitar terjemahan.</b> )</i> ; </li><li>  hyperthread sensitif dari atau membutuhkan inti fisik yang sama dari CPU. </li></ul><br><h2>  Ok!  Bagaimana cara menggunakannya? </h2><br>  Menggunakan CPU Manager itu mudah.  Pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aktifkan itu menggunakan Kebijakan Statis</a> di Kubelet yang berjalan pada compute nodes of the cluster.  Kemudian konfigurasikan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Jaminan</i> Kualitas Layanan (QoS)</a> untuk perapian.  Meminta bilangan bulat dari inti CPU (mis. <code>1000m</code> atau <code>4000m</code> ) untuk wadah yang membutuhkan inti khusus.  Buat dengan metode sebelumnya (misalnya, <code>kubectl create -f pod.yaml</code> ) ... dan voila - CPU Manager akan menetapkan core prosesor khusus untuk setiap wadah perapian sesuai dengan kebutuhan CPU mereka. <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: exclusive-2 spec: containers: - image: quay.io/connordoyle/cpuset-visualizer name: exclusive-2 resources: # Pod is in the Guaranteed QoS class because requests == limits requests: # CPU request is an integer cpu: 2 memory: "256M" limits: cpu: 2 memory: "256M"</code> </pre> <br>  <i>Spesifikasi perapian yang meminta 2 CPU khusus.</i> <br><br><h2>  Bagaimana cara kerja Manajer CPU? </h2><br>  Kami mempertimbangkan tiga jenis kontrol sumber daya CPU yang tersedia di sebagian besar distribusi Linux, yang akan relevan untuk Kubernetes dan tujuan publikasi ini.  Dua yang pertama adalah bagian CFS (berapa bagian dari waktu CPU saya yang “jujur” dalam sistem) dan kuota CFS (berapa waktu CPU maksimum yang dialokasikan untuk saya selama periode tersebut).  CPU Manager juga menggunakan yang ketiga, yang disebut CPU affinity (di mana CPU logis saya diizinkan untuk melakukan perhitungan). <br><br>  Secara default, semua pod dan kontainer yang berjalan pada node cluster Kubernetes dapat berjalan di kernel sistem yang tersedia.  Jumlah total saham dan kuota yang ditetapkan dibatasi oleh sumber daya CPU yang dicadangkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernet dan daemon sistem</a> .  Namun, batas waktu CPU yang digunakan dapat ditentukan dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batas CPU dalam spesifikasi perapian</a> .  Kubernetes menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuota CFS</a> untuk menegakkan batas CPU pada wadah perapian. <br><br>  Saat Anda mengaktifkan Manajer CPU dengan kebijakan <i>statis</i> , ia mengelola kumpulan CPU khusus.  Awalnya, kumpulan ini berisi seluruh CPU dari node komputasi.  Ketika Kubelet membuat sebuah wadah di perapian dengan sejumlah inti prosesor khusus, CPU yang ditugaskan untuk wadah ini dialokasikan untuknya seumur hidup dan dikeluarkan dari kumpulan bersama.  Beban dari kontainer yang tersisa ditransfer dari inti khusus ini ke yang lain. <br><br>  Semua wadah tanpa CPU khusus ( <i>Burstable</i> , <i>BestEffort,</i> dan <i>Dijamin dengan CPU non-integer</i> ) berjalan di kernel yang tersisa di kumpulan bersama.  Ketika sebuah wadah dengan CPU khusus berhenti bekerja, kernelnya kembali ke kumpulan bersama. <br><br><h2>  Lebih detail, silakan ... </h2><br><img src="https://habrastorage.org/webt/cr/w-/-8/crw--8xnqnkcu8fl18xxbbeyfzk.png"><br><br>  Diagram di atas menunjukkan anatomi dari Manajer CPU.  Ia menggunakan metode <code>UpdateContainerResources</code> dari Container Runtime Interface (CRI) untuk mengubah CPU tempat wadah dijalankan.  <i>Manajer</i> secara berkala mencocokkan <code>cgroupfs</code> dengan kondisi saat ini dari sumber daya CPU untuk setiap wadah yang berjalan. <br><br>  Manajer CPU menggunakan <a href=""><i>Kebijakan</i></a> untuk memutuskan alokasi inti CPU.  Dua kebijakan diterapkan: <i>Tidak Ada</i> dan <i>Statis</i> .  Secara default, dimulai dengan Kubernetes versi 1.10, diaktifkan dengan kebijakan <i>None</i> . <br><br>  Kebijakan <i>statis</i> menetapkan wadah pod yang dialokasikan CPU untuk kelas QoS yang dijamin, yang meminta jumlah inti bilangan bulat.  Kebijakan <i>Static</i> mencoba untuk menunjuk CPU dengan cara topologi terbaik dan dalam urutan berikut: <br><br><ul><li>  Tetapkan semua CPU ke satu soket prosesor, jika tersedia dan wadah membutuhkan CPU dalam jumlah setidaknya seluruh soket CPU. </li><li>  Tetapkan semua CPU logis (hyperthreads) dari satu inti CPU fisik, jika tersedia, dan wadah memerlukan CPU setidaknya seluruh inti. </li><li>  Tetapkan CPU logis yang tersedia dengan preferensi untuk CPU dari satu soket. </li></ul><br><h2>  Bagaimana cara Manajer CPU meningkatkan isolasi komputasi? </h2><br>  Dengan kebijakan <i>Statis</i> diaktifkan di CPU Manager, beban kerja dapat berkinerja lebih baik karena salah satu alasan berikut: <br><br><ul><li>  CPU khusus dapat ditugaskan ke wadah dengan beban kerja, tetapi tidak untuk wadah lain.  Wadah ini (lainnya) tidak menggunakan sumber daya CPU yang sama.  Sebagai hasilnya, kami mengharapkan kinerja yang lebih baik karena isolasi dalam kasus munculnya "agresor" <i>(proses menuntut CPU - <b>kira</b> - <b>kira Terjemahkan.</b> )</i> Atau beban kerja yang berdekatan. </li><li>  Ada sedikit kompetisi untuk sumber daya yang digunakan oleh beban kerja, karena kita dapat membagi CPU dengan beban kerja itu sendiri.  Sumber daya ini tidak hanya mencakup CPU, tetapi juga hierarki cache dan bandwidth memori.  Ini meningkatkan kinerja beban kerja keseluruhan. </li><li>  Manajer CPU menetapkan CPU dalam urutan topologi berdasarkan pilihan terbaik yang tersedia.  Jika seluruh soket gratis, ia akan menetapkan semua CPU-nya ke beban kerja.  Ini meningkatkan kinerja beban kerja karena kurangnya lalu lintas di antara soket. </li><li>  Kontainer dalam pod dengan QoS yang <i>Dijamin</i> tunduk pada batas kuota CFS.  Beban kerja yang cenderung meledak tiba-tiba dapat direncanakan dan melebihi kuota mereka sebelum akhir periode yang ditentukan, sebagai akibatnya mereka <i>diperlambat</i> .  CPU yang terlibat saat ini dapat memiliki pekerjaan yang signifikan dan tidak terlalu berguna.  Namun, wadah tersebut tidak akan mengalami pelambatan CFS ketika kuota CPU dilengkapi dengan kebijakan alokasi CPU khusus. </li></ul><br><h2>  Ok!  Apakah Anda punya hasil? </h2><br>  Untuk melihat peningkatan kinerja dan isolasi yang disediakan oleh masuknya CPU Manager di Kubelet, kami melakukan percobaan pada node komputasi dengan dua soket (Intel Xeon CPU E5-2680 v3) dan diaktifkan HyperShreading.  Node terdiri dari 48 CPU logis (24 core fisik, masing-masing dengan hyperthreading).  Manfaat kinerja dan isolasi Manajer CPU yang ditangkap oleh tolok ukur dan beban kerja nyata dalam tiga skenario berbeda ditunjukkan di bawah ini. <br><br><h3>  Bagaimana cara mengartikan grafik? </h3><br>  Untuk setiap skenario, grafik ditampilkan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram rentang</a> , plot kotak) yang menggambarkan waktu eksekusi yang dinormalisasi dan variabilitasnya ketika memulai benchmark atau beban nyata dengan Manajer CPU yang hidup dan mati.  Waktu berjalan dinormalisasi ke peluncuran berkinerja terbaik (1,00 pada sumbu Y mewakili waktu startup terbaik: semakin rendah nilai grafik, semakin baik).  Ketinggian plot pada grafik menunjukkan variabilitas dalam kinerja.  Misalnya, jika situs tersebut berupa garis, maka tidak ada variasi dalam kinerja untuk peluncuran ini.  Di daerah-daerah ini sendiri, garis tengah adalah median, atas adalah persentil ke-75, dan bawah adalah persentil ke-25.  Ketinggian plot (mis., Perbedaan antara persentil ke-75 dan ke-25) didefinisikan sebagai rentang interkuartil (IQR).  "Moustache" menunjukkan data di luar interval ini, dan poin menunjukkan pencilan.  Emisi didefinisikan sebagai data apa pun yang berbeda dari IQR sebesar 1,5 kali - kurang atau lebih dari kuartil yang sesuai.  Setiap percobaan dilakukan 10 kali. <br><br><h3>  Perlindungan Agresif </h3><br>  Kami meluncurkan enam benchmark'ov dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian PARSEC</a> (beban kerja - "korban") <i>[lebih lanjut tentang beban kerja korban dapat dibaca, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - <b>kira</b> - <b>kira.</b></i>  <i><b>perev.</b></i>  <i>] di</i> sebelah wadah memuat CPU ("agresor" beban kerja) dengan Manajer CPU dihidupkan dan dimatikan. <br><br>  Kontainer agresor diluncurkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti di bawah</a> dengan kelas QoS <i>Burstable yang</i> meminta 23 CPU flag <code>--cpus 48</code> .  Benchmark dijalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagai pod</a> dengan kelas QoS yang <i>Dijamin</i> , yang membutuhkan satu set CPU dari soket penuh (mis. 24 CPU pada sistem ini).  Grafik di bawah ini menunjukkan waktu mulai pod yang dinormalisasi dengan patokan di sebelah aggressor pod, dengan kebijakan <i>Static</i> Manager CPU dan tanpa itu.  Dalam semua kasus pengujian, Anda dapat melihat peningkatan kinerja dan penurunan variabilitas kinerja dengan kebijakan diaktifkan. <br><br><img src="https://habrastorage.org/webt/tb/aj/gu/tbajgurqlbubtzm3il4d9vzoh8i.png"><br><br><h3>  Isolasi untuk beban yang berdekatan </h3><br>  Ini menunjukkan betapa bermanfaatnya CPU Manager untuk banyak beban kerja bersama.  Diagram rentang di bawah ini menunjukkan kinerja dua tolok ukur dari set <i>PARSEC</i> ( <i>Blackscholes</i> dan <i>Canneal</i> ) yang diluncurkan untuk kelas QoS <i>Guaranteed</i> (Gu) dan <i>Burstable</i> (Bu) yang berdekatan satu sama lain, dengan kebijakan <i>Statis</i> dihidupkan dan dimatikan. <br><br>  Mengikuti searah jarum jam dari grafik kiri atas, kita melihat kinerja <i>Blackscholes</i> untuk Bu QoS (kiri atas), <i>Canneal</i> untuk Bu QoS (kanan atas), <i>Canneal</i> untuk Gu QoS (kanan bawah) dan <i>Blackscholes</i> untuk Gu QoS (kiri bawah).  Pada setiap grafik, mereka berada (searah jarum jam lagi) bersama dengan <i>Canneal</i> untuk Gu QoS (kiri atas), <i>Blackscholes</i> untuk Gu QoS (kanan atas), <i>Blackscholes</i> untuk Bu QoS (kanan bawah) dan <i>Canneal</i> untuk Bu QoS (kiri bawah) sesuai.  Misalnya, <i>grafik Bu-blackscholes-Gu-canneal</i> (kiri atas) menunjukkan kinerja untuk <i>Blackscholes yang</i> berjalan dengan Bu QoS dan terletak di sebelah <i>Canneal</i> dengan kelas Gu QoS.  Dalam setiap kasus, di bawah dengan kelas Gu QoS membutuhkan inti soket penuh (mis. 24 CPU), dan di bawah dengan kelas Bu QoS - 23 CPU. <br><br>  Ada kinerja yang lebih baik dan lebih sedikit variasi dalam kinerja untuk kedua beban kerja yang berdekatan di semua tes.  Misalnya, lihat <i>Bu-blackscholes-Gu-canneal</i> (kiri atas) dan <i>Gu-canneal-Bu-blackscholes</i> (kanan bawah).  Mereka menunjukkan kinerja menjalankan <i>Blackscholes</i> dan <i>Canneal</i> dengan CPU Manager hidup dan mati.  Dalam hal ini, <i>Canneal</i> menerima lebih banyak core berdedikasi dari CPU Manager, karena itu milik kelas Gu QoS dan meminta nomor integer CPU core.  Namun, <i>Blackscholes juga</i> mendapatkan serangkaian CPU khusus, karena ini adalah satu-satunya beban kerja di kumpulan bersama.  Akibatnya, baik <i>Blackscholes</i> dan <i>Canneal</i> memanfaatkan isolasi beban saat menggunakan CPU Manager. <br><br><img src="https://habrastorage.org/webt/et/wj/93/etwj93f4gv4pbjyoq8-6_nfmtmm.png"><br><br><h3>  Isolasi untuk beban bebas </h3><br>  Ini menunjukkan betapa bermanfaatnya CPU Manager untuk beban kerja mandiri dari kehidupan nyata.  Kami mengambil dua beban dari model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi TensorFlow</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebar dan dalam</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ResNet</a> .  Set data khas digunakan untuk mereka (sensus dan CIFAR10, masing-masing).  Dalam kedua kasus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perapian</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebar dan dalam</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ResNet</a> ) membutuhkan 24 CPU, yang sesuai dengan soket penuh.  Seperti yang ditunjukkan dalam grafik, dalam kedua kasus CPU Manager menyediakan isolasi yang lebih baik. <br><br><img src="https://habrastorage.org/webt/ln/hv/a6/lnhva6g-1coouyustgjq-ziwybk.png"><br><br><h2>  Keterbatasan </h2><br>  Pengguna mungkin ingin mendapatkan CPU yang dialokasikan pada soket yang dekat dengan bus yang terhubung ke perangkat eksternal seperti akselerator atau kartu jaringan berkinerja tinggi untuk menghindari lalu lintas antar soket.  Jenis konfigurasi ini belum didukung di CPU Manager.  Karena Manajer CPU memberikan alokasi CPU terbaik yang mungkin dimiliki soket atau inti fisik, maka CPU ini sensitif terhadap kasus-kasus ekstrem dan dapat menyebabkan fragmentasi.  CPU Manager tidak memperhitungkan parameter boot kernel Linux <code>isolcpus</code> , meskipun ia digunakan sebagai praktik yang populer untuk beberapa kasus <i>(untuk detail lebih lanjut tentang parameter ini, lihat, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - <b>kira</b> - <b>kira Terjemahkan.</b> )</i> . <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  “Apa yang terjadi di Kubernetes ketika lari kubectl dimulai?”: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara kerja penjadwal Kubernetes bekerja?"</a>  "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes: The Life of the Hearth</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRI-O - sebuah alternatif untuk Docker untuk meluncurkan kontainer di Kubernetes</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> ” <i>(laporan video, yang mencakup pengenalan perangkat teknis Kubernetes);</i> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Infrastruktur dengan Kubernet sebagai layanan yang terjangkau</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418269/">https://habr.com/ru/post/id418269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418257/index.html">Github.com menolak untuk menggunakan jQuery dan beralih ke JavaScript murni</a></li>
<li><a href="../id418261/index.html">Sarung tangan stun gun buatan sendiri - senjata untuk geek</a></li>
<li><a href="../id418263/index.html">Ilmuwan Rusia sedang mengembangkan sistem MEG yang ringkas dan murah</a></li>
<li><a href="../id418265/index.html">Organisasi interaksi jaringan antara mesin fisik dan virtual</a></li>
<li><a href="../id418267/index.html">Agustus Acara TI Digest</a></li>
<li><a href="../id418271/index.html">Hancurkan garis dengan pemisah. Sedikit tentang CONNECT BY</a></li>
<li><a href="../id418273/index.html">Alat pengembangan untuk platform Baikal-T1 beralih ke ALT distribusi Rusia</a></li>
<li><a href="../id418275/index.html">Pelajaran Pencetakan 3D. Mencetak model berdinding tipis dari 3Dtool</a></li>
<li><a href="../id418277/index.html">Perangkat bayangan kotak</a></li>
<li><a href="../id418279/index.html">Reset kata sandi pada Cisco ASA tanpa downtime untuk sirkuit failover aktif / siaga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>