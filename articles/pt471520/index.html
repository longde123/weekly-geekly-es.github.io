<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë± üëàüèª üìÜ O livro "Tarefas cl√°ssicas de ci√™ncia da computa√ß√£o em Python" ü§õüèº ‚ÑπÔ∏è üë©üèª‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitas tarefas no campo da Ci√™ncia da Computa√ß√£o, que √† primeira vista parecem novas ou √∫nicas, est√£o realmente enraizadas em algoritmos cl√°ssicos, m√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro "Tarefas cl√°ssicas de ci√™ncia da computa√ß√£o em Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="imagem"></a>  Muitas tarefas no campo da Ci√™ncia da Computa√ß√£o, que √† primeira vista parecem novas ou √∫nicas, est√£o realmente enraizadas em algoritmos cl√°ssicos, m√©todos de codifica√ß√£o e princ√≠pios de desenvolvimento.  E t√©cnicas estabelecidas ainda s√£o a melhor maneira de resolver esses problemas! <br><br>  O livro lhe dar√° a oportunidade de aprender mais profundamente a linguagem Python, testar-se em tarefas, exerc√≠cios e algoritmos testados pelo tempo.  Voc√™ precisa resolver dezenas de tarefas de programa√ß√£o: das mais simples (por exemplo, localizar itens da lista usando classifica√ß√£o bin√°ria) √†s complexas (agrupar dados usando o m√©todo k-means).  Trabalhando com exemplos dedicados √† pesquisa, agrupamento, gr√°ficos, etc., voc√™ se lembrar√° do que havia esquecido e dominar√° as t√©cnicas cl√°ssicas para resolver problemas do dia a dia. <br><a name="habracut"></a><br><h3>  Para quem √© este livro? </h3><br>  Este livro √© destinado a programadores de n√≠vel m√©dio e alto.  Profissionais experientes que desejam aprofundar seus conhecimentos sobre Python encontrar√£o aqui tarefas familiares desde o momento em que ensinaram ci√™ncia da computa√ß√£o ou programa√ß√£o.  Programadores de n√≠vel intermedi√°rio se familiarizar√£o com essas tarefas cl√°ssicas na linguagem escolhida - Python.  Para desenvolvedores que est√£o se preparando para uma entrevista de programa√ß√£o, √© prov√°vel que a publica√ß√£o se torne um material preparat√≥rio valioso. <br><br>  Al√©m de programadores profissionais, este livro pode ser considerado √∫til por estudantes de gradua√ß√£o em ci√™ncias da computa√ß√£o e interessados ‚Äã‚Äãem Python.  N√£o afirma ser uma introdu√ß√£o rigorosa √†s estruturas e algoritmos de dados.  Este n√£o √© um tutorial sobre estruturas de dados e algoritmos.  Voc√™ n√£o encontrar√° provas de teoremas ou o uso abundante de O grandes nota√ß√µes em suas p√°ginas.  Pelo contr√°rio, este livro est√° posicionado como um guia pr√°tico acess√≠vel para m√©todos de solu√ß√£o de problemas que devem se tornar o produto final do estudo da estrutura de dados, algoritmos e classes de intelig√™ncia artificial. <br><br>  Enfatizo novamente: presume-se que os leitores estejam familiarizados com a sintaxe e a sem√¢ntica do Python.  √â improv√°vel que um leitor com experi√™ncia em programa√ß√£o zero se beneficie deste livro, e um programador com experi√™ncia em Python provavelmente ser√° dif√≠cil.  Em outras palavras, "Tarefas cl√°ssicas de ci√™ncia da computa√ß√£o em Python" √© um livro para programadores e estudantes de ci√™ncia da computa√ß√£o. <br><br><h3>  Trecho.  1.5  Torres de Han√≥i </h3><br>  Existem tr√™s colunas verticais altas (a seguir, torres).  N√≥s os designaremos A, B e C. Discos com orif√≠cios no centro est√£o amarrados na torre A. O disco mais largo - o qual chamaremos de disco 1 - est√° localizado abaixo.  Os discos restantes localizados acima dele s√£o indicados por n√∫meros crescentes e diminuem gradualmente.  Por exemplo, se tiv√©ssemos tr√™s discos, o mais largo, o abaixo, teria o n√∫mero 1. O pr√≥ximo disco mais largo, no n√∫mero 2, estaria localizado acima do disco 1. Por fim, o disco mais estreito, no n√∫mero 3 ficaria no disco 2. <br><br>  Nosso objetivo √© mover todas as unidades da torre A para a torre C, levando em considera√ß√£o as seguintes restri√ß√µes. <br><br><ul><li>  Os discos podem ser movidos apenas um de cada vez. </li><li>  A √∫nica unidade dispon√≠vel para movimenta√ß√£o √© aquela localizada no topo de qualquer torre. </li><li>  Uma unidade mais ampla nunca pode ser colocada em cima de uma unidade mais estreita. <br>  Esquematicamente, a tarefa √© mostrada na Fig.  1.7 </li></ul><br><h3>  1.5.1  Modelagem de Torres </h3><br>  Uma pilha √© uma estrutura de dados modelada com base no princ√≠pio LIFO (last-in-first-out).  A √∫ltima coisa que entra na pilha se torna a primeira que √© buscada a partir da√≠.  As duas opera√ß√µes principais da pilha s√£o push (colocar) e pop (extrair).  A opera√ß√£o de envio empurra um novo item para a pilha, e o pop remove-o da pilha e retorna o √∫ltimo item inserido.  Voc√™ pode modelar facilmente a pilha no Python usando a lista como armazenamento de backup (Listagem 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="imagem"></div><br>  Listagem 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  A classe Stack apresentada implementa o m√©todo __repr __ (), que facilita o exame do conte√∫do da torre.  __repr __ () √© o que ser√° produzido quando a fun√ß√£o print () for aplicada √† pilha. </blockquote><br><blockquote>  Conforme declarado na introdu√ß√£o, as anota√ß√µes de tipo s√£o usadas no livro.  A importa√ß√£o de Gen√©rico de um m√≥dulo de entrada permite que o Stack seja uma classe param√©trica para um tipo espec√≠fico nas anota√ß√µes de tipo.  Um tipo arbitr√°rio T √© definido em T = TypeVar ('T').  T pode ser de qualquer tipo.  Quando a anota√ß√£o de tipo for usada posteriormente para Stack na solu√ß√£o do problema da torre de Han√≥i, o prompt ser√° Stack [int], ou seja, o tipo int ser√° usado em vez de T.  Em outras palavras, aqui a pilha √© uma pilha de n√∫meros inteiros.  Se voc√™ estiver tendo dificuldades com as anota√ß√µes de tipo, d√™ uma olhada no Ap√™ndice B. </blockquote><br>  As pilhas s√£o perfeitas para o desafio da torre de Han√≥i.  Para mover o disco para a torre, podemos usar a opera√ß√£o push.  Para mover o disco de uma torre para outra, podemos empurr√°-lo da primeira (pop) e coloc√°-lo na segunda (push). <br><br>  Defina as torres como objetos Stack e preencha a primeira com discos (Listagem 1.21). <br><br>  Listagem 1.21.  hanoi.py (continua√ß√£o) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2  Resolvendo o problema das torres de Han√≥i </h3><br>  Como posso resolver o problema das torres de Han√≥i?  Suponha que estamos tentando mover apenas uma unidade.  Ent√£o saber√≠amos como fazer isso, certo?  De fato, mover um disco √© um caso b√°sico para uma solu√ß√£o recursiva para esse problema.  Mover v√°rias unidades √© um caso recursivo.  O ponto principal √© que, de fato, temos dois cen√°rios que precisam ser codificados: mover um disco (caso base) e mover v√°rios discos (caso recursivo). <br><br>  Para entender o caso recursivo, considere um exemplo espec√≠fico.  Suponha que temos tr√™s discos - superior, m√©dio e inferior, localizados na torre A, e queremos mov√™-los para a torre C. (Posteriormente, isso ajudar√° a descrever esquematicamente o problema.) Primeiro, podemos mover o disco superior para a torre C. Em seguida - mova o disco do meio para a torre B e, em seguida, o disco superior da torre C para a torre B. Agora temos o disco inferior ainda localizado na torre A e os dois discos superiores na torre B. Basicamente, j√° movemos com √™xito dois dirija de uma torre (A) para outra (B).  Mover o disco inferior de A para C √© o caso b√°sico (mover um disco).  Agora podemos mover os dois discos superiores de B para C usando o mesmo procedimento de A para B. Movemos o disco superior para A, o disco do meio para C e, finalmente, o disco superior de A para C. <br><br><blockquote>  Nas aulas de ci√™ncia da computa√ß√£o, pequenos modelos dessas torres s√£o frequentemente encontrados, constru√≠dos a partir de pinos e discos de pl√°stico.  Voc√™ pode fazer seu pr√≥prio modelo com tr√™s l√°pis e tr√™s folhas de papel.  Talvez isso ajude voc√™ a visualizar a solu√ß√£o. </blockquote><br>  No exemplo com tr√™s discos, houve um caso b√°sico simples de mover um disco e um caso recursivo de mover os discos restantes (neste caso dois) usando uma terceira torre tempor√°ria.  Podemos dividir o caso recursivo nas seguintes etapas. <br><br><ol><li>  Mova as unidades n - 1 superiores da torre A para a torre B (tempor√°ria), usando C como torre intermedi√°ria. </li><li>  Mova a unidade inferior de A para C. </li><li>  Mova os discos n - 1 da torre B para a torre C, a torre A √© intermedi√°ria. </li></ol><br>  Surpreendentemente, esse algoritmo recursivo funciona n√£o apenas para tr√™s, mas para qualquer n√∫mero de discos.  Codifique-a como uma fun√ß√£o hanoi (), respons√°vel por mover os discos de uma torre para outra usando uma terceira torre tempor√°ria (Listagem 1.22). <br><br>  Listagem 1.22.  hanoi.py (continua√ß√£o) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Ap√≥s chamar hanoi (), √© necess√°rio verificar as torres A, B e C para garantir que os discos foram movidos com sucesso (Listagem 1.23). <br><br>  Listagem 1.23.  hanoi.py (continua√ß√£o) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Voc√™ descobrir√° que as unidades foram realmente movidas.  Ao codificar a solu√ß√£o para o problema da torre de Han√≥i, n√£o √© necess√°rio entender todas as etapas necess√°rias para mover v√°rios discos da torre A para a torre C. Chegamos a entender o algoritmo recursivo geral para mover qualquer n√∫mero de discos e sistematiz√°-lo, permitindo que o computador fa√ßa o resto.  Esse √© o poder de formular solu√ß√µes recursivas para problemas: geralmente podemos imaginar solu√ß√µes abstratas, sem desperdi√ßar energia na representa√ß√£o mental de cada a√ß√£o individual. <br><br>  A prop√≥sito, a fun√ß√£o hanoi () ser√° executada exponencialmente, dependendo do n√∫mero de discos, o que torna a solu√ß√£o para o problema mesmo para 64 discos inadequados.  Voc√™ pode tentar execut√°-lo com um n√∫mero diferente de discos alterando a vari√°vel num_discs.  √Ä medida que o n√∫mero de discos aumenta, o n√∫mero de etapas para concluir a tarefa da torre de Han√≥i aumenta exponencialmente; mais detalhes podem ser encontrados em muitas fontes.  Se voc√™ estiver interessado em aprender mais sobre a matem√°tica por tr√°s da solu√ß√£o recursiva desse problema, consulte a explica√ß√£o de Karl Birch no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúOn Hanoi Towers‚Äù</a> . <br><br><h3>  1.6  Aplica√ß√µes reais </h3><br>  Os v√°rios m√©todos apresentados neste cap√≠tulo (recurs√£o, memoriza√ß√£o, compacta√ß√£o e manipula√ß√£o no n√≠vel de bits) s√£o t√£o difundidos no desenvolvimento de softwares modernos que, sem eles, √© imposs√≠vel imaginar o mundo da computa√ß√£o.  Apesar do fato de que as tarefas podem ser resolvidas sem elas, geralmente √© mais l√≥gico ou conveniente resolv√™-las usando esses m√©todos. <br><br>  Em particular, a recurs√£o est√° subjacente n√£o apenas a muitos algoritmos, mas tamb√©m a linguagens de programa√ß√£o inteiras.  Em algumas linguagens de programa√ß√£o funcionais, como Scheme e Haskell, a recurs√£o substitui os loops usados ‚Äã‚Äãem linguagens imperativas.  No entanto, deve-se lembrar que tudo o que pode ser alcan√ßado usando o m√©todo recursivo tamb√©m pode ser executado iterativamente. <br><br>  A memoriza√ß√£o foi usada com sucesso para acelerar o trabalho dos analisadores - programas que interpretam linguagens.  Isso √© √∫til em todas as tarefas em que √© prov√°vel que o resultado de um c√°lculo recente seja solicitado novamente.  Outra √°rea de a√ß√£o para memoriza√ß√£o √© o tempo de execu√ß√£o da linguagem de programa√ß√£o.  Alguns desses tempos de execu√ß√£o, por exemplo, para a vers√£o do Prolog, salvam automaticamente os resultados das chamadas de fun√ß√£o (auto-mash), para que a fun√ß√£o n√£o precise ser executada na pr√≥xima vez com a mesma chamada.  Isso √© semelhante ao decorador @lru_cache () em fib6 (). <br><br>  A compress√£o tornou o mundo da Internet, com sua largura de banda limitada, mais suport√°vel.  O m√©todo de cadeia de bits discutido na Se√ß√£o 1.2 √© aplic√°vel a tipos de dados simples no mundo real que possuem um n√∫mero limitado de valores poss√≠veis, para os quais at√© 1 byte √© redundante.  No entanto, a maioria dos algoritmos de compacta√ß√£o trabalha procurando padr√µes ou estruturas em um conjunto de dados que eliminam informa√ß√µes duplicadas.  Eles s√£o muito mais complicados do que o descrito na se√ß√£o 1.2. <br><br>  Cifras descart√°veis ‚Äã‚Äãn√£o s√£o adequadas para casos de criptografia geral.  Eles exigem que o codificador e o decodificador possuam uma das chaves (dados simulados em nosso exemplo) para restaurar os dados originais, o que √© muito complicado e na maioria dos esquemas de criptografia n√£o permite atingir o objetivo de manter as chaves em segredo.  Mas voc√™ pode estar interessado em saber que o nome ‚Äúcifra descart√°vel‚Äù foi inventado por espi√µes que durante a Guerra Fria usaram cadernos de papel reais com dados fict√≠cios gravados neles para criar mensagens criptografadas. <br><br>  Esses m√©todos s√£o os blocos de constru√ß√£o dos programas, outros algoritmos s√£o baseados neles.  Nos cap√≠tulos seguintes, voc√™ ver√° o qu√£o amplamente eles s√£o aplicados. <br><br><h3>  Sobre o autor </h3><br>  <b>David Kopec</b> √© professor s√™nior de ci√™ncia da computa√ß√£o e inova√ß√£o no Champlain College em Burlington, Vermont.  Ele √© um desenvolvedor de software experiente e autor de Classic Computer Science Problems in Swift (Manning, 2018) e Dart for Absolute Beginners (Apress, 2014).  David obteve um diploma de bacharel em economia e um mestrado em ci√™ncia da computa√ß√£o pelo Dartmouth College.  Voc√™ pode entrar em contato com ele no Twitter por @davekopec. <br><br>  ¬ªMais informa√ß√µes sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conte√∫do</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Cupom de 25% de desconto para vendedores ambulantes - <b>Python</b> <br><br>  Ap√≥s o pagamento da vers√£o impressa do livro, um livro eletr√¥nico √© enviado por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471520/">https://habr.com/ru/post/pt471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471508/index.html">Admin sem bra√ßos = hiperconverg√™ncia?</a></li>
<li><a href="../pt471512/index.html">28 de outubro, Ecaterimburgo - Comunica√ß√£o de qualidade</a></li>
<li><a href="../pt471514/index.html">O cabe√ßalho "Leia artigos para voc√™". Janeiro - junho 2019</a></li>
<li><a href="../pt471516/index.html">Intel 665p - SSD com QLC NAND de 96 camadas</a></li>
<li><a href="../pt471518/index.html">Apple em 2019 √© Linux em 2000</a></li>
<li><a href="../pt471522/index.html">Askozia. Como funciona o Plug & Play de provisionamento autom√°tico</a></li>
<li><a href="../pt471524/index.html">Tradu√ß√£o completa de instru√ß√µes para avaliadores do Google</a></li>
<li><a href="../pt471528/index.html">Implantar aplicativos usando o docker swarm</a></li>
<li><a href="../pt471530/index.html">O GitLab percorreu um caminho incomum para CI / CD e Kubernetes</a></li>
<li><a href="../pt471532/index.html">Adeus PCB; ol√° interconex√£o de silicone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>