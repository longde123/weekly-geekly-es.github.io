<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱 👈🏻 📆 O livro "Tarefas clássicas de ciência da computação em Python" 🤛🏼 ℹ️ 👩🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitas tarefas no campo da Ciência da Computação, que à primeira vista parecem novas ou únicas, estão realmente enraizadas em algoritmos clássicos, mé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro "Tarefas clássicas de ciência da computação em Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="imagem"></a>  Muitas tarefas no campo da Ciência da Computação, que à primeira vista parecem novas ou únicas, estão realmente enraizadas em algoritmos clássicos, métodos de codificação e princípios de desenvolvimento.  E técnicas estabelecidas ainda são a melhor maneira de resolver esses problemas! <br><br>  O livro lhe dará a oportunidade de aprender mais profundamente a linguagem Python, testar-se em tarefas, exercícios e algoritmos testados pelo tempo.  Você precisa resolver dezenas de tarefas de programação: das mais simples (por exemplo, localizar itens da lista usando classificação binária) às complexas (agrupar dados usando o método k-means).  Trabalhando com exemplos dedicados à pesquisa, agrupamento, gráficos, etc., você se lembrará do que havia esquecido e dominará as técnicas clássicas para resolver problemas do dia a dia. <br><a name="habracut"></a><br><h3>  Para quem é este livro? </h3><br>  Este livro é destinado a programadores de nível médio e alto.  Profissionais experientes que desejam aprofundar seus conhecimentos sobre Python encontrarão aqui tarefas familiares desde o momento em que ensinaram ciência da computação ou programação.  Programadores de nível intermediário se familiarizarão com essas tarefas clássicas na linguagem escolhida - Python.  Para desenvolvedores que estão se preparando para uma entrevista de programação, é provável que a publicação se torne um material preparatório valioso. <br><br>  Além de programadores profissionais, este livro pode ser considerado útil por estudantes de graduação em ciências da computação e interessados ​​em Python.  Não afirma ser uma introdução rigorosa às estruturas e algoritmos de dados.  Este não é um tutorial sobre estruturas de dados e algoritmos.  Você não encontrará provas de teoremas ou o uso abundante de O grandes notações em suas páginas.  Pelo contrário, este livro está posicionado como um guia prático acessível para métodos de solução de problemas que devem se tornar o produto final do estudo da estrutura de dados, algoritmos e classes de inteligência artificial. <br><br>  Enfatizo novamente: presume-se que os leitores estejam familiarizados com a sintaxe e a semântica do Python.  É improvável que um leitor com experiência em programação zero se beneficie deste livro, e um programador com experiência em Python provavelmente será difícil.  Em outras palavras, "Tarefas clássicas de ciência da computação em Python" é um livro para programadores e estudantes de ciência da computação. <br><br><h3>  Trecho.  1.5  Torres de Hanói </h3><br>  Existem três colunas verticais altas (a seguir, torres).  Nós os designaremos A, B e C. Discos com orifícios no centro estão amarrados na torre A. O disco mais largo - o qual chamaremos de disco 1 - está localizado abaixo.  Os discos restantes localizados acima dele são indicados por números crescentes e diminuem gradualmente.  Por exemplo, se tivéssemos três discos, o mais largo, o abaixo, teria o número 1. O próximo disco mais largo, no número 2, estaria localizado acima do disco 1. Por fim, o disco mais estreito, no número 3 ficaria no disco 2. <br><br>  Nosso objetivo é mover todas as unidades da torre A para a torre C, levando em consideração as seguintes restrições. <br><br><ul><li>  Os discos podem ser movidos apenas um de cada vez. </li><li>  A única unidade disponível para movimentação é aquela localizada no topo de qualquer torre. </li><li>  Uma unidade mais ampla nunca pode ser colocada em cima de uma unidade mais estreita. <br>  Esquematicamente, a tarefa é mostrada na Fig.  1.7 </li></ul><br><h3>  1.5.1  Modelagem de Torres </h3><br>  Uma pilha é uma estrutura de dados modelada com base no princípio LIFO (last-in-first-out).  A última coisa que entra na pilha se torna a primeira que é buscada a partir daí.  As duas operações principais da pilha são push (colocar) e pop (extrair).  A operação de envio empurra um novo item para a pilha, e o pop remove-o da pilha e retorna o último item inserido.  Você pode modelar facilmente a pilha no Python usando a lista como armazenamento de backup (Listagem 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="imagem"></div><br>  Listagem 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  A classe Stack apresentada implementa o método __repr __ (), que facilita o exame do conteúdo da torre.  __repr __ () é o que será produzido quando a função print () for aplicada à pilha. </blockquote><br><blockquote>  Conforme declarado na introdução, as anotações de tipo são usadas no livro.  A importação de Genérico de um módulo de entrada permite que o Stack seja uma classe paramétrica para um tipo específico nas anotações de tipo.  Um tipo arbitrário T é definido em T = TypeVar ('T').  T pode ser de qualquer tipo.  Quando a anotação de tipo for usada posteriormente para Stack na solução do problema da torre de Hanói, o prompt será Stack [int], ou seja, o tipo int será usado em vez de T.  Em outras palavras, aqui a pilha é uma pilha de números inteiros.  Se você estiver tendo dificuldades com as anotações de tipo, dê uma olhada no Apêndice B. </blockquote><br>  As pilhas são perfeitas para o desafio da torre de Hanói.  Para mover o disco para a torre, podemos usar a operação push.  Para mover o disco de uma torre para outra, podemos empurrá-lo da primeira (pop) e colocá-lo na segunda (push). <br><br>  Defina as torres como objetos Stack e preencha a primeira com discos (Listagem 1.21). <br><br>  Listagem 1.21.  hanoi.py (continuação) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2  Resolvendo o problema das torres de Hanói </h3><br>  Como posso resolver o problema das torres de Hanói?  Suponha que estamos tentando mover apenas uma unidade.  Então saberíamos como fazer isso, certo?  De fato, mover um disco é um caso básico para uma solução recursiva para esse problema.  Mover várias unidades é um caso recursivo.  O ponto principal é que, de fato, temos dois cenários que precisam ser codificados: mover um disco (caso base) e mover vários discos (caso recursivo). <br><br>  Para entender o caso recursivo, considere um exemplo específico.  Suponha que temos três discos - superior, médio e inferior, localizados na torre A, e queremos movê-los para a torre C. (Posteriormente, isso ajudará a descrever esquematicamente o problema.) Primeiro, podemos mover o disco superior para a torre C. Em seguida - mova o disco do meio para a torre B e, em seguida, o disco superior da torre C para a torre B. Agora temos o disco inferior ainda localizado na torre A e os dois discos superiores na torre B. Basicamente, já movemos com êxito dois dirija de uma torre (A) para outra (B).  Mover o disco inferior de A para C é o caso básico (mover um disco).  Agora podemos mover os dois discos superiores de B para C usando o mesmo procedimento de A para B. Movemos o disco superior para A, o disco do meio para C e, finalmente, o disco superior de A para C. <br><br><blockquote>  Nas aulas de ciência da computação, pequenos modelos dessas torres são frequentemente encontrados, construídos a partir de pinos e discos de plástico.  Você pode fazer seu próprio modelo com três lápis e três folhas de papel.  Talvez isso ajude você a visualizar a solução. </blockquote><br>  No exemplo com três discos, houve um caso básico simples de mover um disco e um caso recursivo de mover os discos restantes (neste caso dois) usando uma terceira torre temporária.  Podemos dividir o caso recursivo nas seguintes etapas. <br><br><ol><li>  Mova as unidades n - 1 superiores da torre A para a torre B (temporária), usando C como torre intermediária. </li><li>  Mova a unidade inferior de A para C. </li><li>  Mova os discos n - 1 da torre B para a torre C, a torre A é intermediária. </li></ol><br>  Surpreendentemente, esse algoritmo recursivo funciona não apenas para três, mas para qualquer número de discos.  Codifique-a como uma função hanoi (), responsável por mover os discos de uma torre para outra usando uma terceira torre temporária (Listagem 1.22). <br><br>  Listagem 1.22.  hanoi.py (continuação) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n — <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Após chamar hanoi (), é necessário verificar as torres A, B e C para garantir que os discos foram movidos com sucesso (Listagem 1.23). <br><br>  Listagem 1.23.  hanoi.py (continuação) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Você descobrirá que as unidades foram realmente movidas.  Ao codificar a solução para o problema da torre de Hanói, não é necessário entender todas as etapas necessárias para mover vários discos da torre A para a torre C. Chegamos a entender o algoritmo recursivo geral para mover qualquer número de discos e sistematizá-lo, permitindo que o computador faça o resto.  Esse é o poder de formular soluções recursivas para problemas: geralmente podemos imaginar soluções abstratas, sem desperdiçar energia na representação mental de cada ação individual. <br><br>  A propósito, a função hanoi () será executada exponencialmente, dependendo do número de discos, o que torna a solução para o problema mesmo para 64 discos inadequados.  Você pode tentar executá-lo com um número diferente de discos alterando a variável num_discs.  À medida que o número de discos aumenta, o número de etapas para concluir a tarefa da torre de Hanói aumenta exponencialmente; mais detalhes podem ser encontrados em muitas fontes.  Se você estiver interessado em aprender mais sobre a matemática por trás da solução recursiva desse problema, consulte a explicação de Karl Birch no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“On Hanoi Towers”</a> . <br><br><h3>  1.6  Aplicações reais </h3><br>  Os vários métodos apresentados neste capítulo (recursão, memorização, compactação e manipulação no nível de bits) são tão difundidos no desenvolvimento de softwares modernos que, sem eles, é impossível imaginar o mundo da computação.  Apesar do fato de que as tarefas podem ser resolvidas sem elas, geralmente é mais lógico ou conveniente resolvê-las usando esses métodos. <br><br>  Em particular, a recursão está subjacente não apenas a muitos algoritmos, mas também a linguagens de programação inteiras.  Em algumas linguagens de programação funcionais, como Scheme e Haskell, a recursão substitui os loops usados ​​em linguagens imperativas.  No entanto, deve-se lembrar que tudo o que pode ser alcançado usando o método recursivo também pode ser executado iterativamente. <br><br>  A memorização foi usada com sucesso para acelerar o trabalho dos analisadores - programas que interpretam linguagens.  Isso é útil em todas as tarefas em que é provável que o resultado de um cálculo recente seja solicitado novamente.  Outra área de ação para memorização é o tempo de execução da linguagem de programação.  Alguns desses tempos de execução, por exemplo, para a versão do Prolog, salvam automaticamente os resultados das chamadas de função (auto-mash), para que a função não precise ser executada na próxima vez com a mesma chamada.  Isso é semelhante ao decorador @lru_cache () em fib6 (). <br><br>  A compressão tornou o mundo da Internet, com sua largura de banda limitada, mais suportável.  O método de cadeia de bits discutido na Seção 1.2 é aplicável a tipos de dados simples no mundo real que possuem um número limitado de valores possíveis, para os quais até 1 byte é redundante.  No entanto, a maioria dos algoritmos de compactação trabalha procurando padrões ou estruturas em um conjunto de dados que eliminam informações duplicadas.  Eles são muito mais complicados do que o descrito na seção 1.2. <br><br>  Cifras descartáveis ​​não são adequadas para casos de criptografia geral.  Eles exigem que o codificador e o decodificador possuam uma das chaves (dados simulados em nosso exemplo) para restaurar os dados originais, o que é muito complicado e na maioria dos esquemas de criptografia não permite atingir o objetivo de manter as chaves em segredo.  Mas você pode estar interessado em saber que o nome “cifra descartável” foi inventado por espiões que durante a Guerra Fria usaram cadernos de papel reais com dados fictícios gravados neles para criar mensagens criptografadas. <br><br>  Esses métodos são os blocos de construção dos programas, outros algoritmos são baseados neles.  Nos capítulos seguintes, você verá o quão amplamente eles são aplicados. <br><br><h3>  Sobre o autor </h3><br>  <b>David Kopec</b> é professor sênior de ciência da computação e inovação no Champlain College em Burlington, Vermont.  Ele é um desenvolvedor de software experiente e autor de Classic Computer Science Problems in Swift (Manning, 2018) e Dart for Absolute Beginners (Apress, 2014).  David obteve um diploma de bacharel em economia e um mestrado em ciência da computação pelo Dartmouth College.  Você pode entrar em contato com ele no Twitter por @davekopec. <br><br>  »Mais informações sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Cupom de 25% de desconto para vendedores ambulantes - <b>Python</b> <br><br>  Após o pagamento da versão impressa do livro, um livro eletrônico é enviado por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471520/">https://habr.com/ru/post/pt471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471508/index.html">Admin sem braços = hiperconvergência?</a></li>
<li><a href="../pt471512/index.html">28 de outubro, Ecaterimburgo - Comunicação de qualidade</a></li>
<li><a href="../pt471514/index.html">O cabeçalho "Leia artigos para você". Janeiro - junho 2019</a></li>
<li><a href="../pt471516/index.html">Intel 665p - SSD com QLC NAND de 96 camadas</a></li>
<li><a href="../pt471518/index.html">Apple em 2019 é Linux em 2000</a></li>
<li><a href="../pt471522/index.html">Askozia. Como funciona o Plug & Play de provisionamento automático</a></li>
<li><a href="../pt471524/index.html">Tradução completa de instruções para avaliadores do Google</a></li>
<li><a href="../pt471528/index.html">Implantar aplicativos usando o docker swarm</a></li>
<li><a href="../pt471530/index.html">O GitLab percorreu um caminho incomum para CI / CD e Kubernetes</a></li>
<li><a href="../pt471532/index.html">Adeus PCB; olá interconexão de silicone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>