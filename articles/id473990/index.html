<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏙️ ⏱️ 🙌🏼 Pelajari OpenGL. Pelajaran 7.2 - Menggambar Teks 👨🏾‍⚖️ 🧗 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada titik tertentu dalam petualangan grafis Anda, Anda akan ingin menampilkan teks melalui OpenGL. Berlawanan dengan apa yang Anda harapkan, mendapat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari OpenGL. Pelajaran 7.2 - Menggambar Teks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="gambar" align="left" width="300">  Pada titik tertentu dalam petualangan grafis Anda, Anda akan ingin menampilkan teks melalui OpenGL.  Berlawanan dengan apa yang Anda harapkan, mendapatkan garis sederhana di layar cukup sulit dengan perpustakaan tingkat rendah seperti OpenGL.  Jika Anda tidak perlu lebih dari 128 karakter berbeda untuk menggambar teks, maka itu tidak akan sulit.  Kesulitan muncul ketika karakter tidak cocok dengan tinggi, lebar, dan offset.  Tergantung di mana Anda tinggal, Anda mungkin perlu lebih dari 128 karakter.  Tetapi bagaimana jika Anda menginginkan karakter khusus, karakter matematika atau musik?  Segera setelah Anda memahami bahwa menggambar teks bukan tugas termudah, Anda akan menyadari bahwa itu kemungkinan besar tidak seharusnya menjadi bagian dari API tingkat rendah seperti OpenGL. </p><br><p> Karena OpenGL tidak menyediakan sarana apa pun untuk merender teks, semua kesulitan dari kasus ini ada pada kami.  Karena tidak ada "Simbol" primitif grafis, kita harus menciptakannya sendiri.  Sudah ada contoh yang sudah jadi: menggambar simbol melalui <code>GL_LINES</code> , membuat model simbol 3D, atau menggambar simbol pada persegi empat datar dalam ruang tiga dimensi. </p><br><p>  Paling sering, pengembang <s>terlalu malas untuk</s> <s>minum kopi dan</s> memilih opsi terakhir.  Menggambar segi empat bertekstur ini tidak sesulit memilih tekstur yang tepat.  Dalam tutorial ini, kita akan belajar beberapa cara dan menulis renderer teks canggih namun fleksibel menggunakan FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Bagian 1. Memulai</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo segitiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem koordinat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 2. Pencahayaan dasar</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar pencahayaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber cahaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai Sumber Penerangan</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 3. Unduh model 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Polygon Mesh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Model 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 4. Fitur OpenGL Lanjutan</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kedalaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes stensil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencampuran warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memotong wajah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer bingkai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu kubik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan data tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader geometris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instancing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghaluskan</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 5. Pencahayaan Lanjut</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencahayaan tingkat lanjut.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blinn Fong Model</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koreksi gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu bayangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta bayangan omnidirectional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan paralaks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Render yang ditangguhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber Cahaya Analitik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iradiasi difus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paparan specular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 7. Berlatih</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debugging</a> </li><li>  <strong>Rendering teks</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Klasik: Font Raster </h1><br><p>  Sekali waktu <s>di masa dinosaurus,</s> rendering teks termasuk memilih font (atau membuatnya) untuk aplikasi dan menyalin karakter yang diinginkan ke tekstur besar yang disebut font bitmap.  Tekstur ini mengandung semua karakter yang diperlukan di bagian-bagian tertentu.  Karakter-karakter ini disebut glyphs.  Setiap mesin terbang memiliki area spesifik koordinat tekstur yang terkait dengannya.  Setiap kali Anda menggambar karakter, Anda memilih mesin terbang tertentu dan menggambar hanya bagian yang diinginkan pada quad datar. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Di sini Anda dapat melihat bagaimana kami akan merender teks "OpenGL".  Kami mengambil font raster dan mencicipi mesin terbang yang diperlukan dari tekstur, dengan hati-hati memilih koordinat tekstur, yang akan kami gambar pada beberapa segi empat.  Mengaktifkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencampuran</a> dan menjaga latar belakang transparan, kita mendapatkan serangkaian karakter di layar.  Font bitmap ini dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator font bitmap Codehead</a> . </p><br><p>  Pendekatan ini memiliki pro dan kontra.  Pendekatan ini memiliki implementasi yang sederhana, karena font bitmap sudah dirasterisasi.  Namun, ini tidak selalu nyaman.  Jika Anda membutuhkan font lain, Anda perlu membuat font bitmap baru.  Selain itu, meningkatkan ukuran karakter akan dengan cepat menunjukkan tepi pixelated.  Selain itu, font bitmap sering dikaitkan dengan sekumpulan karakter kecil, sehingga karakter Unicode kemungkinan besar tidak akan ditampilkan. </p><br><p>  Teknik ini sangat populer belum lama ini (dan masih mempertahankan popularitasnya), karena sangat cepat dan bekerja pada platform apa pun.  Namun hingga saat ini, ada pendekatan lain untuk merender teks.  Salah satunya adalah rendering font TrueType menggunakan FreeType. </p><br><h1 id="sovremennost-freetype">  Modernitas: FreeType </h1><br><p>  FreeType adalah pustaka yang mengunduh font, menjadikannya bitmap, dan menyediakan dukungan untuk beberapa operasi terkait font.  Perpustakaan populer ini digunakan pada Mac OS X, Java, Qt, PlayStation, Linux, dan Android.  Kemampuan memuat font TrueType membuat pustaka ini cukup menarik. </p><br><p>  Font TrueType adalah kumpulan mesin terbang yang didefinisikan bukan oleh piksel, tetapi oleh rumus matematika.  Seperti halnya gambar vektor, gambar font raster dapat dibuat berdasarkan ukuran font yang diinginkan.  Menggunakan font TrueType, Anda dapat dengan mudah membuat mesin terbang dari berbagai ukuran tanpa kehilangan kualitas. </p><br><p>  FreeType dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs resmi</a> .  Anda dapat mengkompilasi FreeType sendiri, atau menggunakan versi yang telah dikompilasi, jika ada, di situs.  Ingat untuk menautkan program Anda ke <code>freetype.lib</code> dan pastikan bahwa kompiler tahu ke mana harus mencari file header. </p><br><p>  Kemudian lampirkan file header yang benar: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Karena FreeType dirancang dengan cara yang agak aneh (pada saat menulis aslinya, beri tahu saya jika ada sesuatu yang berubah), Anda dapat meletakkan file header-nya hanya di root folder dengan file header.  Menghubungkan FreeType dengan cara lain (misalnya, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) dapat memicu konflik file header. </blockquote><p>  Apa yang dilakukan FreeType?  Memuat font TrueType dan menghasilkan gambar bitmap untuk setiap mesin terbang dan menghitung beberapa metrik mesin terbang.  Kita bisa mendapatkan gambar bitmap untuk menghasilkan tekstur dan memposisikan setiap mesin terbang tergantung pada metrik yang diterima. </p><br><p>  Untuk mengunduh font, kita perlu menginisialisasi FreeType dan memuat font sebagai wajah (seperti FreeType memanggil font).  Dalam contoh ini, kita memuat font TrueType <code>arial.ttf</code> , disalin dari folder C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Masing-masing fungsi FreeType mengembalikan nilai bukan nol jika terjadi kegagalan. </p><br><p>  Setelah kita memuat <s>wajah font</s> wajah, kita perlu menentukan ukuran font yang diinginkan, yang akan kita ekstrak: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Fungsi ini mengatur lebar dan tinggi mesin terbang.  Dengan mengatur lebar ke 0 (nol) kami memungkinkan FreeType untuk menghitung lebar tergantung pada ketinggian yang ditetapkan. </p><br><p>  Wajah FreeType berisi kumpulan mesin terbang.  Kami dapat mengaktifkan mesin terbang dengan menelepon <code>FT_Load_Char</code> .  Di sini kami mencoba memuat mesin terbang <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Dengan menetapkan <code>FT_LOAD_RENDER</code> sebagai salah satu flag unduhan, kami memberitahu FreeType untuk membuat bitmap skala abu-abu 8-bit, yang kemudian dapat kita peroleh seperti ini: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Mesin terbang yang dimuat dengan FreeType tidak memiliki ukuran yang sama dengan font bitmap.  Bitmap yang dihasilkan dengan FreeType adalah ukuran minimum untuk ukuran font tertentu dan hanya cukup untuk menampung satu karakter.  Misalnya, gambar bitmap dari mesin terbang <code>.</code>  jauh lebih kecil dari bitmap glyph <code>X</code>  Untuk alasan ini, FreeType juga mengunduh beberapa metrik yang menunjukkan ukuran dan di mana karakter tunggal harus ditempatkan.  Di bawah ini adalah gambar yang menunjukkan metrik yang menghitung FreeType untuk setiap mesin terbang. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Setiap mesin terbang terletak di garis dasar (garis horizontal dengan panah).  Beberapa tepat pada garis dasar ( <code>X</code> ), beberapa di bawah ( <code>g</code> , <code>p</code> ).  Metrik ini secara akurat menentukan offset untuk penentuan posisi mesin terbang secara akurat pada garis dasar, menyesuaikan ukuran mesin terbang dan untuk mencari tahu berapa banyak piksel yang perlu Anda tinggalkan untuk menggambar mesin terbang berikutnya.  Berikut ini adalah daftar metrik yang akan kami gunakan: </p><br><ul><li>  <strong>lebar</strong> : <strong>lebar</strong> mesin terbang dalam piksel, akses dengan <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : glyph height dalam pixel, akses oleh <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>bearingX</strong> : offset horizontal dari titik kiri atas mesin terbang relatif ke asal, akses oleh <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>bearingY</strong> : offset vertikal dari titik kiri atas mesin terbang relatif ke asal, akses oleh <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>muka</strong> : offset horisontal dari awal mesin terbang berikutnya dalam 1/64 piksel relatif terhadap asal, akses oleh <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Kita dapat memuat mesin terbang simbol, mendapatkan metriknya dan menghasilkan tekstur setiap kali kita ingin menggambarnya di layar, tetapi untuk membuat tekstur untuk setiap simbol pada setiap frame bukanlah metode yang baik.  Lebih baik kita menyimpan data yang dihasilkan di suatu tempat dan memintanya saat kita membutuhkannya.  Kami mendefinisikan struktur yang nyaman yang akan kami simpan di <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  Dalam artikel ini, kami akan menyederhanakan hidup kami dan hanya akan menggunakan 128 karakter pertama.  Untuk setiap karakter, kami akan menghasilkan tekstur dan menyimpan data yang diperlukan dalam struktur bertipe <code>Character</code> , yang akan kami tambahkan ke <code>Characters</code> bertipe <code>std::map</code> .  Dengan demikian, semua data yang diperlukan untuk menggambar karakter disimpan untuk digunakan di masa depan. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Di dalam loop, untuk masing-masing 128 karakter pertama, kita mendapatkan mesin terbang, menghasilkan tekstur, mengatur pengaturannya dan menyimpan metrik.  Sangat menarik untuk dicatat bahwa kami menggunakan <code>GL_RED</code> sebagai argumen untuk <code>internalFormat</code> dan <code>format</code> tekstur.  Bitmap yang dihasilkan mesin terbang adalah gambar skala abu-abu 8-bit, yang masing-masing pikselnya menempati 1 byte.  Untuk alasan ini, kami akan menyimpan buffer bitmap sebagai nilai warna tekstur.  Ini dicapai dengan membuat tekstur di mana setiap byte sesuai dengan komponen warna merah.  Jika kita menggunakan 1 byte untuk mewakili warna tekstur, jangan lupa tentang batasan OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL mengharuskan semua tekstur memiliki offset 4-byte, mis.  ukurannya harus kelipatan 4 byte (mis. 8 byte, 4000 byte, 2048 byte) atau (dan) mereka harus menggunakan 4 byte per piksel (seperti dalam format RGBA), tetapi karena kami menggunakan 1 byte per piksel, mereka dapat memiliki perbedaan lebar.  Dengan mengatur offset penyelarasan unpack (apakah ada terjemahan yang lebih baik?) Untuk 1, kami menghilangkan kesalahan offset yang dapat menyebabkan segfault. </p><br><p>  Juga, ketika kami selesai bekerja dengan font itu sendiri, kami harus menghapus sumber daya FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shader </h4><br><p>  Untuk menggambar mesin terbang, gunakan vertex shader berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Kami menggabungkan posisi simbol dan koordinat tekstur dalam satu <code>vec4</code> .  Vertex shader menghitung produk koordinat dengan matriks proyeksi dan mentransfer koordinat tekstur ke shader fragmen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  Shader fragmen menerima 2 variabel global - gambar monokrom mesin terbang dan warna mesin terbang itu sendiri.  Pertama, kami sampel nilai warna mesin terbang.  Karena data tekstur disimpan dalam komponen merah tekstur, kami hanya mengambil sampel komponen <code>r</code> sebagai nilai transparansi.  Dengan mengubah transparansi warna, warna yang dihasilkan akan transparan ke latar belakang mesin terbang dan buram ke piksel asli mesin terbang.  Kami juga mengalikan warna RGB dengan variabel textColor untuk mengubah warna teks. </p><br><p>  Tetapi agar mekanisme kami berfungsi, Anda harus mengaktifkan pencampuran: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Sebagai matriks proyeksi, kita akan memiliki matriks proyeksi ortografis.  Untuk menggambar teks, pada kenyataannya, matriks perspektif tidak diperlukan dan penggunaan proyeksi ortografis juga memungkinkan kita untuk mengatur semua koordinat titik dalam koordinat layar jika kita mengatur matriks seperti ini: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Kami mengatur bagian bawah matriks ke <code>0.0f</code> , bagian atas ke ketinggian jendela.  Akibatnya, koordinat <code>y</code> mengambil nilai dari bagian bawah layar ( <code>y = 0</code> ) ke bagian atas layar ( <code>y = 600</code> ).  Ini berarti bahwa titik <code>(0, 0)</code> menunjukkan dan sudut kiri bawah layar. </p><br><p>  Sebagai kesimpulan, buat VBO dan VAO untuk menggambar segi empat.  Di sini kami menyimpan cukup memori dalam VBO sehingga kami dapat memperbarui data untuk menggambar karakter. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Sebuah quadrangle datar membutuhkan 6 simpul dari 4 angka floating point, jadi kami memesan <code>6 * 4 = 24</code> float memori.  Karena kami akan sering mengubah data titik, kami mengalokasikan memori menggunakan <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Tampilkan satu baris teks di layar </h4><br><p>  Untuk menampilkan satu baris teks, kami mengekstrak struktur <code>Character</code> yang sesuai dengan simbol dan menghitung dimensi segi empat dari metrik simbol.  Dari dimensi yang dihitung dari segi empat, dengan cepat kami membuat satu set 6 simpul dan memperbarui data titik menggunakan <code>glBufferSubData</code> . </p><br><p>  Untuk kenyamanan, <code>RenderText</code> fungsi <code>RenderText</code> yang akan menggambar serangkaian karakter: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  Isi fungsi relatif jelas: perhitungan asal, ukuran dan simpul segi empat.  Perhatikan bahwa kami mengalikan setiap metrik dengan <code>scale</code> .  Setelah itu, perbarui VBO dan gambar quad. </p><br><p>  Baris kode ini membutuhkan perhatian: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Beberapa karakter, seperti <code>p</code> dan <code>g</code> , digambarkan dengan jelas di bawah garis dasar, yang berarti bahwa quad harus jauh lebih rendah daripada parameter <code>y</code> dari fungsi <code>RenderText</code> .  Offset tepat <code>y_offset</code> dapat diekspresikan dari metrik mesin terbang: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Untuk menghitung offset, kita perlu <s>lengan lurus untuk</s> mengetahui jarak di mana simbol berada di bawah garis dasar.  Jarak ini ditunjukkan oleh panah merah.  Jelas, <code>y_offset = bearingY - height</code> dan <code>ypos = y + y_offset</code> . </p><br><p>  Jika semuanya dilakukan dengan benar, Anda dapat menampilkan teks di layar seperti ini: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  Hasilnya akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Contoh kode ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (tautan ke situs penulis asli). </p><br><p>  Untuk memahami quadrangles mana yang digambar, matikan blending: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  Dari gambar ini, jelaslah bahwa sebagian besar segi empat berada di atas garis dasar imajiner, meskipun beberapa karakter, seperti <code>(</code> dan <code>p</code> , digeser ke bawah. </p><br><h1 id="chto-zhe-dalee">  Apa selanjutnya </h1><br><p>  Artikel ini menunjukkan cara merender font TrueType dengan FreeType.  Pendekatan ini fleksibel, dapat diukur dan efisien pada berbagai pengkodean karakter.  Namun, pendekatan ini mungkin terlalu berat untuk aplikasi Anda, karena tekstur dibuat untuk setiap karakter.  Font bitmap yang produktif lebih disukai karena kami memiliki satu tekstur untuk semua mesin terbang.  Pendekatan terbaik adalah menggabungkan dua pendekatan dan mengambil yang terbaik: on-the-fly menghasilkan font raster dari mesin terbang yang diunduh menggunakan FreeType.  Ini akan menyelamatkan renderer dari banyak penggantian tekstur dan, tergantung pada kemasan tekstur, akan meningkatkan kinerja. </p><br><p>  Tetapi FreeType memiliki satu kelemahan lagi: mesin terbang ukuran tetap, yang berarti bahwa ketika ukuran mesin terbang yang diberikan meningkat, langkah-langkah mungkin muncul di layar dan ketika diputar, mesin terbang mungkin terlihat buram.  Valve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20120815035559/">diselesaikan</a> (tautan ke arsip web) masalah ini beberapa tahun yang lalu menggunakan bidang jarak yang ditandatangani.  Mereka melakukannya dengan sangat baik dan menunjukkannya pada aplikasi 3D. </p><br><p>  <strong>PS</strong> : Kami punya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram conf</a> untuk koordinasi transfer.  Jika Anda memiliki keinginan serius untuk membantu penerjemahan, maka Anda dipersilakan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473990/">https://habr.com/ru/post/id473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473980/index.html">Teknologi dan dunia nyata: 4 Start-up yang mengubah masa depan desain interior</a></li>
<li><a href="../id473982/index.html">NB-IoT: bagaimana cara kerjanya? Bagian 3: SCEF - jendela akses tunggal ke layanan operator</a></li>
<li><a href="../id473984/index.html">Intisari Ilmu Data (Oktober 2019)</a></li>
<li><a href="../id473986/index.html">“Impian saya adalah melihat seseorang melalui pepohonan” - pendiri Lisa Alert tentang teknologi pencarian modern</a></li>
<li><a href="../id473988/index.html">Mengoptimalkan distribusi server di rak</a></li>
<li><a href="../id473992/index.html">Tinjauan umum protokol modern dalam sistem otomasi industri</a></li>
<li><a href="../id473994/index.html">Memuat skrip modern</a></li>
<li><a href="../id473998/index.html">Belanda, atau di sana dan kembali</a></li>
<li><a href="../id474000/index.html">IQBX - desainer elektromekanis untuk kalangan dan pecinta DIY [ide konsep]</a></li>
<li><a href="../id474004/index.html">Dari Norilsk ke Riyadh: Kasus Nyata untuk Kartu Memori Suhu Industri Kingston microSD UHS-I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>