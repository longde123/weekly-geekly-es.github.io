<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦‍👦 🐇 👨🏽‍🏭 Dasar-Dasar Aliran Dart 🚵🏾 🍒 👨‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari seri saya tentang Flutter Architecture: 


- Pendahuluan 
- Dasar-Dasar Dart Streams (posting ini) 
- RxDart: transformas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar Aliran Dart</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450950/"><p>  Ini adalah bagian kedua dari seri saya tentang Flutter Architecture: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <strong>Dasar-Dasar Dart Streams (posting ini)</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDart: transformasi ajaib arus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-Dasar RxVMS: RxCommand dan GetIt</a> </li><li>  RxVMS: Layanan dan Manajer </li><li>  RxVMS: widget mandiri </li><li>  Otentikasi Pengguna dengan RxVMS </li></ul><br><p>  Streaming adalah blok bangunan utama <strong>RxVMS</strong> , pemahaman mereka sangat diperlukan untuk bekerja dengan perpustakaan ini, jadi kami akan membahasnya lebih detail di pos ini. </p><br><p>  Ternyata termasuk Rx dalam posting ini akan membuatnya terlalu lama, jadi saya membaginya menjadi dua bagian. </p><br><h2 id="pust-techet">  Biarkan mengalir </h2><br><p>  Saya membaca banyak komentar yang mereka katakan stream, dan terutama Rx, terlalu rumit untuk dipahami dan, akibatnya, untuk digunakan. </p><br><p> Saya ingin Anda tahu bahwa saya tidak menganggap diri saya seorang guru Rx.  Memanfaatkan semua kekuatannya tidaklah mudah, dan saya akui bahwa saya terus belajar.  Tapi izinkan saya memperbaiki satu kesalahan sejak awal: <strong>Anda tidak perlu menjadi penyihir Rx untuk mulai mendapatkan banyak manfaat dari menggunakan utas dan teknologi ini</strong> .  Saya akan melakukan segala upaya untuk menjelaskan aliran kepada Anda dengan cara yang paling mudah diakses. </p><a name="habracut"></a><br><h2 id="chto-takoe-potoki">  Apa itu utas? </h2><br><p>  Menurut pendapat saya, analogi terbaik untuk thread adalah conveyor belt.  Anda dapat meletakkan sesuatu di salah satu ujungnya dan "sesuatu" ini secara otomatis akan ditransfer ke yang lain.  Tidak seperti pipa fisik, utas memanipulasi objek data, mentransfernya secara otomatis dari awal - tetapi di mana?  Seperti dalam pipa nyata, jika tidak ada yang menangkap data di ujung lainnya, mereka hanya akan "jatuh" dan menghilang (ini, tentu saja, tidak sepenuhnya benar untuk Dart Streams, tetapi yang terbaik untuk menangani stream seolah-olah itu masalahnya) . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/266/3a1/04f/2663a104fc0e4c1ad735881ef36fe32c.gif"></p><br><p>  Untuk menghindari kehilangan data, Anda dapat mengatur "jebakan" pada output stream.  Dengan cara ini Anda dapat mengambil data dan melakukan manipulasi yang diperlukan bersamanya setiap kali objek data mencapai akhir aliran. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd3/331/b2f/dd3331b2fa9036bee28628d563f3ceb7.gif"></p><br><p>  <strong>Ingat:</strong> </p><br><ul><li>  Jika jebakan tidak diatur, data akan hilang selamanya dan tidak akan ada cara untuk mendapatkannya lagi (sekali lagi, tidak persis dengan Dart Streams, tetapi Anda lebih baik berpura-pura) </li><li>  Setelah mengirim data ke aliran, Anda tidak perlu menjeda program dan menunggu hingga mencapai akhir, semua ini terjadi di latar belakang. </li><li>  Perangkap dapat menerima data kapan saja, tidak perlu segera setelah mengirim (tapi jangan khawatir, alirannya sebenarnya sangat cepat).  Bayangkan Anda tidak tahu seberapa cepat atau berapa lama sabuk konveyor bergerak.  Ini berarti menempatkan sesuatu di aliran benar-benar terpisah dari reaksi terhadap elemen di ujung lainnya.  Perangkap Anda akan bekerja dan menangkap item ketika sampai di sana.  (Beberapa dari Anda mungkin sudah menyadari bahwa ini cocok dengan cara reaktif Flutter memperbarui widgetnya) </li><li>  Anda dapat mengatur jebakan jauh sebelum pekerjaan dimulai dan item pertama muncul </li><li>  Alurnya bekerja berdasarkan prinsip FIFO.  Data selalu datang dalam urutan ditempatkan di aliran. </li></ul><br><h2 id="a-chto-takoe-rx">  Apa itu Rx? </h2><br><p>  Rx, kependekan dari Reactive Extensions, adalah aliran steroid.  Ini adalah konsep yang sangat mirip dengan Streams, yang diciptakan untuk .Net framework oleh tim Microsoft.  Sejak. Net sudah memiliki tipe Stream, yang digunakan untuk file I / O, mereka disebut Rx streams <strong>Observables</strong> dan menciptakan banyak fungsi untuk memanipulasi data yang melewatinya.  Dart memiliki Streaming yang dibangun ke dalam spesifikasi bahasanya yang sudah menawarkan sebagian besar fungsi ini, tetapi tidak semua.  Inilah sebabnya mengapa paket RxDart dikembangkan;  Ini didasarkan pada Dart Streams, tetapi memperluas fungsionalitasnya.  Saya akan membahas Rx dan RxDart di bagian selanjutnya dari seri ini. </p><br><h2 id="nemnogo-terminov">  Beberapa istilah </h2><br><p>  Dart Streams dan Rx menggunakan beberapa terminologi yang mungkin terlihat menyeramkan, jadi inilah terjemahannya.  Pertama kali muncul istilah Dart, kemudian Rx. </p><br><ul><li>  <strong>Aliran / Teramati</strong> .  Ini adalah "saluran pipa" yang dijelaskan sebelumnya.  Stream dapat dikonversi ke Observable dan di mana pun Stream diharapkan, Anda dapat menetapkan Observable.  Jadi jangan bingung jika saya mencampur istilah-istilah ini dalam proses menjelaskan </li><li>  <strong>mendengarkan / berlangganan</strong> - atur perangkap <strong>pendengar</strong> </li><li>  <strong>StreamController / Subjek</strong> .  Sisi "kiri" dari sabuk konveyor tempat Anda meletakkan data dalam Stream.  Mereka sedikit berbeda dalam sifat dan karakteristik mereka, tetapi melayani tujuan yang sama. </li><li>  <strong>Memancarkan item / data</strong> .  Saat ketika data muncul di pintu keluar "pipa" </li></ul><br><h2 id="sozdanie-potoka">  Penciptaan aliran </h2><br><p>  Jika Anda berniat untuk terus mempelajari topik ini, silakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiru proyek ini</a> dengan contoh.  Saya akan menggunakan sistem uji Dart / Flutter. </p><br><p>  Untuk membuat aliran, Anda membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StreamController</a> </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); controller.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>  Tipe template (dalam hal ini String) yang dilewati ketika membuat StreamController menentukan tipe objek yang dapat kami kirim ke stream.  Ini bisa berupa tipe APA SAJA!  Anda dapat membuat <code>StreamController&lt;List&lt;MyObject&gt;&gt;()</code> jika Anda mau dan streaming akan mentransfer seluruh lembar alih-alih satu objek. </p><br><h2 id="ustanovka-lovushki">  Pengaturan perangkap </h2><br><p>  Jika Anda menjalankan tes yang ditentukan, maka Anda tidak dapat melihat apa-apa, karena tidak ada yang menangkap garis kami pada output stream.  Sekarang atur perangkap: </p><br><pre> <code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">//  controller.add("Item1"); controller.add("Item2"); controller.add("Item3");</span></span></code> </pre> <br><p>  Sekarang jebakan diatur menggunakan metode <code>.listen()</code> .  Catatan ini terlihat seperti <code>controller.stream.listen</code> , tetapi jika Anda menggulirkannya ke belakang, seperti semacam album dari tahun 60an, maka makna sebenarnya dari apa yang tertulis akan muncul: "dengarkan aliran dari pengontrol ini" </p><br><p>  Anda perlu meneruskan fungsi tertentu ke metode <code>.listen()</code> untuk memanipulasi data yang masuk.  Fungsi harus menerima parameter dari tipe yang ditentukan saat membuat StreamController, dalam hal ini, String. </p><br><p>  Jika Anda menjalankan kode di atas, Anda akan melihat </p><br><pre> <code class="cpp hljs">Item1 Item2 Item3</code> </pre> <br><p>  Menurut pendapat saya, masalah terbesar bagi pendatang baru ke Streams adalah Anda dapat menentukan reaksi untuk elemen yang dipancarkan jauh sebelum elemen pertama dimasukkan ke dalam aliran, memicu panggilan untuk reaksi ini. </p><br><h2 id="zavershenie-proslushivaniya">  Akhiri mendengarkan </h2><br><p>  Kode di atas melewatkan bagian kecil tapi penting.  <code>StreamSubscription</code> <code>listen()</code> mengembalikan <code>StreamSubscription</code> - objek berlangganan streaming.  Panggilan ke metode <code>.cancel()</code> mengakhiri langganan, membebaskan sumber daya, dan mencegah fungsi mendengarkan Anda dipanggil setelah itu menjadi tidak perlu. </p><br><pre> <code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); StreamSubscription subscription = controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">// This is the Trap controller.add("Item1"); controller.add("Item2"); controller.add("Item3"); //    ,        //  ,     Stream   await Future.delayed(Duration(milliseconds: 500)); subscription.cancel;</span></span></code> </pre> <br><h2 id="podrobnosti-o-slushatelyah">  Detail Pendengar </h2><br><p>  Fungsi untuk <code>listen()</code> dapat berupa fungsi lambda atau sederhana. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message)</span></span></span><span class="hljs-function"> </span></span>{ print(message); } StreamSubscription subscription = controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">//  - StreamSubscription subscription2 = controller.stream.listen(myPrint); //    StreamSubscription subscription3 = controller.stream.listen((item) { print(item); print(item.toUpperCase); }); // -</span></span></code> </pre> <br><p>  <strong>Catatan penting: sebagian besar aliran Dart hanya memungkinkan langganan satu kali, yaitu, mereka tidak dapat berlangganan kembali setelah berlangganan selesai - ini akan menimbulkan pengecualian.</strong>  <strong>Ini perbedaan mereka dari implementasi Rx lainnya.</strong> </p><br><p>  Tanda tangan penuh untuk <code>listen()</code> terlihat seperti ini: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* excerpt from the API doc * The [onError] callback must be of type `void onError(error)` or * `void onError(error, StackTrace stackTrace)`. If [onError] accepts * two arguments it is called with the error object and the stack trace * (which could be `null` if the stream itself received an error without * stack trace). * Otherwise it is called with just the error object. * If [onError] is omitted, any errors on the stream are considered unhandled, * and will be passed to the current [Zone]'s error handler. * By default unhandled async errors are treated * as if they were uncaught top-level errors. * * If this stream closes and sends a done event, the [onDone] handler is * called. If [onDone] is `null`, nothing happens. * * If [cancelOnError] is true, the subscription is automatically canceled * when the first error event is delivered. The default is `false`. */</span></span> StreamSubscription&lt;T&gt; listen(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> onData(T event), {Function onError, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> onDone(), <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> cancelOnError});</code> </pre> <br><p>  Ini berarti bahwa Anda dapat melakukan lebih dari sekadar melewatkan satu penangan untuk data yang dikirim.  Anda juga dapat memiliki penangan untuk kesalahan, dan yang lain untuk menutup aliran di sisi pengontrol ( <code>onDone</code> ).  Pengecualian yang <code>onError()</code> dari dalam Stream akan <code>onError()</code> jika Anda memberikannya, <strong>jika tidak mereka hanya ditelan dan Anda tidak akan pernah tahu bahwa ada sesuatu yang salah.</strong> </p><br><h2 id="primer-flutter-potokov">  Contoh Flutter Thread </h2><br><p>  <em>Untuk memfasilitasi pemahaman bab-bab berikut, saya membuat cabang repositori yang terpisah.</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tolong tiru dia</a> </p><br><p>  Sebagai contoh pertama, saya mengambil aplikasi penghitung terkenal yang Anda dapatkan saat membuat proyek Flutter baru, dan mengatur ulangnya sedikit.  Saya menambahkan kelas model untuk menahan status aplikasi, yang pada dasarnya adalah nilai penghitung: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; StreamController _streamController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get counterUpdates =&gt; _streamController.stream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _counter++; _streamController.add(_counter); } }</code> </pre> <br><p>  di sini Anda dapat melihat templat yang sangat khas: alih-alih menerbitkan seluruh StreamController, kami cukup menerbitkan properti Stream-nya. </p><br><p>  Untuk membuat Model tersedia untuk UI, saya membuatnya menjadi bidang statis di objek App karena saya tidak ingin memasukkan InheritedWidget atau ServiceLocator.  Sebagai contoh sederhana, ini akan lolos begitu saja, tetapi saya tidak akan melakukannya dalam aplikasi ini! </p><br><p>  Tambahkan ke <code>main.dart</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHomePageState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;MyHomePage&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; StreamSubscription streamSubscription; @<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ streamSubscription = MyApp.model.counterUpdates.listen((newVal) =&gt; setState(() { _counter = newVal; })); super.initState(); } <span class="hljs-comment"><span class="hljs-comment">//   State   ,   , //       @override void dispose() { streamSubscription?.cancel(); super.dispose(); }</span></span></code> </pre> <br><p>  <code>initState()</code> baik untuk mengatur pendengar, dan sebagai warga negara Darts yang baik, kami selalu merilis langganan di <code>dispose()</code> , kan? </p><br><p>  Di pohon widget, kita hanya perlu mengadaptasi handler onPressed dari tombol FAB (tombol dengan aksi mengambang). </p><br><pre> <code class="cpp hljs">floatingActionButton: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatingActionButton( onPressed: MyApp.model.incrementCounter, tooltip: <span class="hljs-string"><span class="hljs-string">'Increment'</span></span>, child: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(Icons.add), ),</code> </pre> <br><p>  Dengan cara ini, kami membuat pemisahan bersih antara Tampilan dan Model menggunakan Stream. </p><br><h2 id="primenyaem-streambuilder">  Terapkan StreamBuilder </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> </p><br><p>  Alih-alih menggunakan <code>initState()</code> dan <code>setState()</code> untuk kebutuhan kita, Flutter hadir dengan widget <code>StreamBuilder</code> nyaman.  Seperti yang mungkin sudah Anda duga, dibutuhkan fungsi Stream dan metode konstruktor yang dipanggil setiap kali Stream mengembalikan nilai baru.  Dan sekarang kita tidak perlu inisialisasi dan rilis eksplisit: </p><br><pre> <code class="cpp hljs">body: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Center( child: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Text( <span class="hljs-string"><span class="hljs-string">'You have pushed the button this many times:'</span></span>, ), StreamBuilder&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( initialData: <span class="hljs-number"><span class="hljs-number">0</span></span>, stream: MyApp.model.counterUpdates, builder: (context, snappShot) { String valueAsString = <span class="hljs-string"><span class="hljs-string">'NoData'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snappShot != null &amp;&amp; snappShot.hasData) { valueAsString = snappShot.data.toString(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Text( valueAsString, style: Theme.of(context).textTheme.display1, ); }), ], ), ),</code> </pre> <br><p>  Kami hampir selesai, aku janji.  Inilah tiga hal yang harus Anda ketahui: </p><br><ul><li>  Keuntungan hebat menggunakan StreamBuilder daripada solusi pertama adalah bahwa memanggil <code>setState()</code> di <code>listen()</code> selalu mengatur ulang seluruh halaman, sementara StreamBuilder hanya akan memanggil pembuatnya. </li><li>  Variabel <code>snapShot</code> berisi data terbaru yang diterima dari Stream.  Selalu pastikan bahwa itu berisi data yang valid sebelum menggunakannya. </li><li><p>  Berdasarkan prinsip inisialisasi selama, StreamBuilder tidak bisa mendapatkan nilai selama frame pertama.  Untuk menyiasatinya, kami meneruskan nilai untuk <code>initialData</code> , yang digunakan untuk perakitan pertama, yaitu, untuk bingkai pertama layar.  Jika kami tidak lulus <code>initialData</code> , pembangun kami akan dipanggil untuk pertama kalinya dengan data yang tidak valid.  Alternatif untuk menggunakan <code>initialData</code> adalah mengembalikan widget placeholder jika <code>snapShot</code> tidak valid, yang ditampilkan hingga kami mendapatkan data yang valid, misalnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,           StreamBuilder&lt;int&gt;( stream: MyApp.model.databaseUpdates, builder: (context, snappShot) { if (snappShot != null &amp;&amp; snappShot.hasData) { return Text( snappShot.data.toString(), style: Theme.of(context).textTheme.display1, ); } //      ,   Spinner return CircularProgressIndicator (); })</span></span></code> </pre> <br></li></ul><br><p>  Pada posting selanjutnya kita akan melihat bagaimana mengkonversi data di stream kita dan melakukannya dengan cepat.  Banyak terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scott Stoll</a> untuk membaca bukti dan umpan balik penting. </p><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450950/">https://habr.com/ru/post/id450950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450930/index.html">Bagaimana kami mengembangkan # bigdataX5 dan siapa yang dibutuhkan di Big Data</a></li>
<li><a href="../id450938/index.html">Linux Instal Fest 05.19 di Nizhny Novgorod 18 Mei 2019</a></li>
<li><a href="../id450942/index.html">Sespan untuk pemecahan kode</a></li>
<li><a href="../id450946/index.html">Disk Cell Phone di LPC810</a></li>
<li><a href="../id450948/index.html">MU-MIMO: salah satu algoritma implementasi</a></li>
<li><a href="../id450952/index.html">Indeks Sedang dan Antibank</a></li>
<li><a href="../id450954/index.html">Bagaimana kami belajar mengeksploitasi Java di Docker</a></li>
<li><a href="../id450956/index.html">Perbandingan COB industri: ISIM vs Kics</a></li>
<li><a href="../id450958/index.html">AnyStub, perpustakaan rintisan koneksi Java</a></li>
<li><a href="../id450962/index.html">Pompa insulin, microchip yang rusak, dan radio yang ditentukan oleh perangkat lunak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>