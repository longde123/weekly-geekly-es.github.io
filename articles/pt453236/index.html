<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥄 😸 🏣 Prototipar um jogo para celular, por onde começar e como fazê-lo. Parte 2 👵🏻 👨🏾‍🤝‍👨🏻 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para quem perdeu a primeira parte - Parte 1 
 Próxima parte - parte 3 

 Se alguém estiver interessado em ler sobre o agregador usado pelo evento, aqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prototipar um jogo para celular, por onde começar e como fazê-lo. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453236/">  Para quem perdeu a primeira parte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> <br>  Próxima parte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 3</a> <br><br>  Se alguém estiver interessado em ler sobre o agregador usado pelo evento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está</a> você, mas isso não é necessário. <br><br><h3>  Então, começamos a coletar tudo em uma pilha </h3><br><img src="https://habrastorage.org/webt/z-/sa/5r/z-sa5rumeqhyobemc4hutmppbai.png"><br><a name="habracut"></a><br>  <b>Foguete:</b> <br><br><div class="spoiler">  <b class="spoiler_title">Classe de foguete base</b> <div class="spoiler_text"><pre><code class="java hljs">using DG.Tweening; using GlobalEventAggregator; using UnityEngine; namespace PlayerRocket { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rocket</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerRocketBase</span></span></span><span class="hljs-class"> </span></span>{ [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pathorrectionTime = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 movingUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartEventReact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ButtonStartPressed buttonStartPressed)</span></span></span><span class="hljs-function"> </span></span>{ transform.SetParent(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); rocketState = RocketState.MOVE; transform.DORotate(Vector3.zero, pathorrectionTime); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ base.Start(); EventAggregator.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterUser { playerHelper = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rocketState == RocketState.WAITFORSTART) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; RocketBehaviour(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RocketBehaviour(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RocketBehaviour</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rocketState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.WAITFORSTART: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inputController.OnTouch &amp;&amp; !inputController.OnDrag) rocketHolder.RotateHolder(inputController.worldMousePos); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.MOVE: rigidbody.AddRelativeForce(Vector3.up*(config.Speed*Time.deltaTime)); forceModel.AddModificator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.STOP: Debug.Log(<span class="hljs-string"><span class="hljs-string">" "</span></span>); rigidbody.velocity = Vector3.zero; rigidbody.drag = <span class="hljs-number"><span class="hljs-number">50</span></span>; rocketState = RocketState.COMPLETESTOP; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.COMPLETESTOP: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: rocketState = RocketState.COMPLETESTOP; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } }</code> </pre> <br></div></div><br>  O que precisamos para um foguete decolar?  No espaço de jogo, precisamos de um planeta condicional com o qual começamos, um botão de partida e um foguete.  O que um foguete deve ser capaz de fazer? <br><br><ol><li>  Aguarde o início </li><li>  Voar </li><li>  Seja afetado por modificadores </li><li>  Para parar </li></ol><br>  Ou seja, temos um comportamento / estado diferente do foguete, dependendo do estado atual, o foguete deve fornecer um comportamento diferente.  Na programação, somos constantemente confrontados com uma situação em que um objeto pode ter muitos comportamentos radicalmente diferentes. <br><br>  Para comportamento complexo de objetos - é melhor usar padrões comportamentais, por exemplo, um padrão de estado.  Para os mais simples, os programadores iniciantes costumam usar muito, se for o caso.  Eu recomendo usar switch e enum.  Em primeiro lugar, essa é uma divisão mais clara da lógica em estágios específicos; graças a isso, saberemos exatamente em que estado estamos agora e o que está acontecendo, há menos oportunidades de transformar o código em um macarrão de dezenas de exceções. <br><br>  <b>Como funciona:</b> <br><br>  Primeiro começamos enum com os estados que precisamos: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RocketState { WAITFORSTART = <span class="hljs-number"><span class="hljs-number">0</span></span>, MOVE = <span class="hljs-number"><span class="hljs-number">1</span></span>, STOP = <span class="hljs-number"><span class="hljs-number">2</span></span>, COMPLETESTOP = <span class="hljs-number"><span class="hljs-number">3</span></span>, }</code> </pre> <br>  Na classe pai, temos um campo - <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> RocketState rocketState;</code> </pre> <br>  Por padrão, o primeiro valor é atribuído a ele.  O próprio Enum define os valores padrão, mas para dados que podem ser alterados de cima ou configurados por designers de jogos, eu defino manualmente os valores, para quê?  Para poder agregar outro valor ao inam em qualquer lugar e não violar os dados armazenados.  Também aconselho a estudar flag enum. <br><br>  <b>Seguinte:</b> <br><br>  Definimos o próprio comportamento em uma atualização, dependendo do valor do campo rocketState <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RocketBehaviour(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RocketBehaviour</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rocketState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.WAITFORSTART: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inputController.OnTouch &amp;&amp; !inputController.OnDrag) rocketHolder.RotateHolder(inputController.worldMousePos); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.MOVE: rigidbody.AddRelativeForce(Vector3.up*(config.Speed*Time.deltaTime)); forceModel.AddModificator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.STOP: Debug.Log(<span class="hljs-string"><span class="hljs-string">" "</span></span>); rigidbody.velocity = Vector3.zero; rigidbody.drag = <span class="hljs-number"><span class="hljs-number">50</span></span>; rocketState = RocketState.COMPLETESTOP; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RocketState.COMPLETESTOP: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: rocketState = RocketState.COMPLETESTOP; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  <b>Vou decifrar o que está acontecendo:</b> <br><br><ol><li>  Quando esperamos, simplesmente giramos o foguete em direção ao cursor do mouse, definindo assim a trajetória inicial </li><li>  O segundo estado - voamos, aceleramos o foguete na direção certa e atualizamos o modelo de modificadores para a aparência de objetos que afetam a trajetória </li><li>  O terceiro estado é quando a equipe chega até nós para parar, aqui trabalhamos tudo para que o foguete pare e se traduza no estado - paramos completamente. </li><li>  O último estado é que não estamos fazendo nada. </li></ol><br>  A conveniência do padrão atual - tudo é facilmente expansível e ajustável, mas há uma coisa, mas um elo fraco - é quando podemos ter um estado que combina vários outros estados.  Aqui, ou um sinalizador inam, com uma complicação de processamento, ou já mude para padrões mais "pesados". <br><br>  Nós descobrimos o foguete.  O próximo passo é um objeto simples, mas divertido - o botão Iniciar. <br><br><h3>  Botão Iniciar </h3><br>  A funcionalidade a seguir é necessária para ela clicar, ela notificou que eles clicaram nela. <br><br><div class="spoiler">  <b class="spoiler_title">Classe do botão Iniciar</b> <div class="spoiler_text"><pre> <code class="java hljs">using UnityEngine; using UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartButton</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPointerDownHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool isTriggered; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonStartPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isTriggered) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; isTriggered = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; GlobalEventAggregator.EventAggregator.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ButtonStartPressed()); Debug.Log(<span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointerDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointerEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ ButtonStartPressed(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct ButtonStartPressed { }</code> </pre> <br></div></div><br>  De acordo com o design do jogo, este é um objeto 3D no palco, o botão deve ser integrado ao design do planeta inicial.  Bem, ok, há uma nuance - como rastrear um clique em um objeto em uma cena? <br><br>  Se pesquisarmos no Google, encontraremos vários métodos OnMouse, entre os quais haverá um clique.  Parece uma escolha fácil, mas é muito ruim, começando com o fato de que muitas vezes funciona torto (existem muitas nuances para rastrear cliques), "querido", terminando com o fato de que ele não fornece toneladas de pães que estão no UnityEngine.EventSystems. <br><br>  No final, eu recomendo usar o UnityEngine.EventSystems e as interfaces IPointerDownHandler, IPointerClickHandler.  Nos métodos deles, percebemos a reação à pressão, mas há várias nuances. <br><br><ol><li>  Um EventSystem deve estar presente na cena; esse é um objeto / classe / componente da unidade, geralmente criado quando criamos a tela para a interface, mas você também pode criá-lo. </li><li>  O RayCaster de física deve estar presente na câmera (isto é para 3D, para gráficos 2D, existe um racaster separado) </li><li>  Deve haver um colisor na instalação </li></ol><br>  <i>No projeto, fica assim:</i> <br><br><img src="https://habrastorage.org/webt/-l/qa/1s/-lqa1sfgetxwqvlj7tqn1qdafia.jpeg"><br><br>  Agora o objeto rastreia o clique e esse método é chamado: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointerDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointerEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ ButtonStartPressed(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonStartPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isTriggered) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; isTriggered = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; GlobalEventAggregator.EventAggregator.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ButtonStartPressed()); Debug.Log(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br>  <b>O que está acontecendo aqui:</b> <br><br>  Temos um campo booleano no qual rastreamos se o botão foi pressionado ou não (isso é proteção contra pressionamentos repetidos para que não tenhamos um script inicial executado a cada vez). <br><br>  Em seguida, chamamos o evento - o botão é pressionado, ao qual a classe de foguete está inscrita, e coloca o foguete em um estado de movimento. <br><br>  Avançando um pouco - por que está aqui e ali para eventos?  Essa é uma programação orientada a eventos: primeiro, um modelo de evento é mais barato que o processamento contínuo de dados para descobrir suas alterações.  Em segundo lugar, essa é a conexão mais fraca, não precisamos saber no foguete que existe um botão, que alguém o pressionou e assim por diante, apenas sabemos que há um evento para começar, recebemos e estamos agindo.  Além disso, este evento é interessante não apenas para o foguete, por exemplo, um painel com modificadores é assinado para o mesmo evento, está oculto no início do foguete.  Além disso, esse evento pode ser de interesse para o controlador de entrada - e a entrada do usuário não pode ser processada ou processada de maneira diferente após o lançamento do foguete. <br><br>  Por que muitos programadores não gostam do paradigma de eventos?  Como uma tonelada de eventos e inscrições para esses eventos transformam facilmente o código em macarrão, no qual não está claro por onde começar e se terminará em algum lugar, sem mencionar o fato de que você também precisa monitorar seu cancelamento de assinatura / assinatura e manter todos os objetos ativos. <br><br>  E é por isso que, para a implementação de eventos, uso meu agregador de eventos, que na verdade não transmite eventos, mas os contêineres de dados através de eventos e classes assinam os dados que lhes interessam.  Além disso, o próprio agregador monitora objetos ativos e lança objetos mortos para fora dos assinantes.  Graças à transferência do contêiner, a injeção também é possível; você pode passar um link para a classe de seu interesse.  Pelo contêiner, você pode acompanhar facilmente quem processa e envia esses dados.  Prototipar é uma coisa ótima. <br><br><h3>  Rotação de foguetes para determinar o caminho inicial </h3><br><img src="https://habrastorage.org/webt/se/fm/hx/sefmhxvs8qjjymxmsj-i9uogdk0.jpeg"><br>  De acordo com o design do jogo, o foguete deve poder girar ao redor do planeta para determinar a trajetória inicial, mas não mais do que um certo ângulo.  A rotação é realizada pelo toque - o foguete simplesmente segue o dedo e é sempre direcionado para o local onde cutucamos a tela.  A propósito, é apenas o protótipo que tornou possível determinar que esse é um ponto fraco e que existem muitos episódios associados ao gerenciamento que limitam essa funcionalidade. <br><br>  <b>Mas em ordem:</b> <br><br><ol><li>  Precisamos que o foguete gire em relação ao planeta na direção do carrinho de mão </li><li>  Precisamos prender o ângulo de rotação </li></ol><br>  Quanto à rotação em relação ao planeta - você pode girar astutamente em torno do eixo e calcular o eixo de rotação, ou você pode simplesmente criar um objeto com um manequim centrado dentro do planeta, mover o foguete para lá e girar silenciosamente o manequim em torno do eixo Z, o manequim terá uma classe que determinará o comportamento do objeto.  O foguete irá girar com ele.  O objeto que eu chamei de RocketHolder.  Nós descobrimos isso. <br><br>  Agora, sobre as restrições de virar e girar na direção do carrinho de mão: <br><br><div class="spoiler">  <b class="spoiler_title">classe RocketHolder</b> <div class="spoiler_text"><pre> <code class="java hljs">using UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RocketHolder</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clampAngle = <span class="hljs-number"><span class="hljs-number">45</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GlobalEventAggregator.EventAggregator.AddListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InjectEvent&lt;RocketHolder&gt; obj) =&gt; obj.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampAngle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> to)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) angle = <span class="hljs-number"><span class="hljs-number">360</span></span> + angle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">180f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.Max(angle, <span class="hljs-number"><span class="hljs-number">360</span></span> + from); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.Min(angle, to); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampRotationVectorZ</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector3 rotation )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(rotation.x, rotation.y, ClampAngle(rotation.z, -clampAngle, clampAngle)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector3 targetPosition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = targetPosition - transform.position; diff.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg; transform.rotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, rot_z - <span class="hljs-number"><span class="hljs-number">90</span></span>); transform.eulerAngles = ClampRotationVectorZ(transform.rotation.eulerAngles); } }</code> </pre> <br></div></div><br>  Apesar do fato de o jogo ser teoricamente 3D, mas toda a lógica e a jogabilidade são na verdade 2D.  E nós apenas precisamos apertar o foguete em torno do eixo Z na direção do local da pressão.  No final do método, fixamos o grau de rotação pelo valor especificado no inspetor.  No método Awake, você pode ver a implementação mais correta de uma injeção de classe por meio de um agregador. <br><br><h3>  Controlador de entrada </h3><br>  Uma das classes mais importantes, é ele quem coleta e processa o comportamento do usuário.  Pressionando teclas de atalho, botões do gamepad, teclados, etc.  Eu tenho uma entrada bastante simples no protótipo, na verdade você precisa saber apenas três coisas: <br><br><ol><li>  Existe um clique e suas coordenadas </li><li>  Existe um deslize vertical e quanto deslizar </li><li>  Opero com interface / modificadores </li></ol><br><div class="spoiler">  <b class="spoiler_title">classe InputController</b> <div class="spoiler_text"><pre> <code class="java hljs">using System; using UnityEngine; using UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DirectionRange = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 clickedPosition; [Header(<span class="hljs-string"><span class="hljs-string">"     "</span></span>)] [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> afterThisDistanceWeGonnaDoSwipe = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; [Header(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)] [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speedOfVerticalScroll = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReactiveValue&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; ReactiveVerticalScroll { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> set; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 worldMousePos =&gt; Camera.main.ScreenToWorldPoint(Input.mousePosition); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool OnTouch { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> set; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool OnDrag { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> set; } <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update private void Awake() { ReactiveVerticalScroll = new ReactiveValue&lt;float&gt;(); GlobalEventAggregator.EventAggregator.AddListener(this, (ImOnDragEvent obj) =&gt; OnDrag = obj.IsDragging); GlobalEventAggregator.EventAggregator.AddListener&lt;InjectEvent&lt;InputController&gt;&gt;(this, InjectReact); } private void InjectReact(InjectEvent&lt;InputController&gt; obj) { obj.inject(this); } private void OnEnable() { GlobalEventAggregator.EventAggregator.Invoke(this); } void Start() { GlobalEventAggregator.EventAggregator.Invoke(this); } private void MouseInput() { if (EventSystem.current.IsPointerOverGameObject() &amp;&amp; EventSystem.current.gameObject.layer == 5) return; if (Input.GetKeyDown(KeyCode.Mouse0)) clickedPosition = Input.mousePosition; if (Input.GetKey(KeyCode.Mouse0)) { if (OnDrag) return; VerticalMove(); OnTouch = true; return; } OnTouch = false; ReactiveVerticalScroll.CurrentValue = 0; } private void VerticalMove() { if ( Math.Abs(Input.mousePosition.y-clickedPosition.y) &lt; afterThisDistanceWeGonnaDoSwipe) return; var distance = clickedPosition.y + Input.mousePosition.y * speedOfVerticalScroll; if (Input.mousePosition.y &gt; clickedPosition.y) ReactiveVerticalScroll.CurrentValue = distance; else if (Input.mousePosition.y &lt; clickedPosition.y) ReactiveVerticalScroll.CurrentValue = -distance; else ReactiveVerticalScroll.CurrentValue = 0; } // Update is called once per frame void Update() { MouseInput(); } } }</span></span></code> </pre> <br></div></div><br>  Está tudo na testa e sem problemas, interessante pode ser a implementação primitiva do proprietário reativo - quando eu estava apenas começando a programar, sempre foi interessante descobrir como os dados foram alterados, sem ventilação constante dos dados.  Bem, é isso. <br><br>  É assim: <br><br><div class="spoiler">  <b class="spoiler_title">classe ReactiveValue</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReactiveValue</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T currentState; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Action&lt;T&gt; OnChange; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T CurrentValue { get =&gt; currentState; set { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.Equals(currentState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { currentState = value; OnChange?.Invoke(currentState); } } } }</code> </pre><br></div></div><br>  Assinamos o OnChange e agitamos se apenas o valor tiver sido alterado. <br><br>  Com relação à prototipagem e arquitetura - as dicas são as mesmas, somente propriedades e métodos públicos, todos os dados devem ser alterados apenas localmente.  Qualquer processamento e cálculos - adicione de acordo com métodos separados.  Como resultado, você sempre pode alterar a implementação / cálculos, e isso não afetará os usuários externos da classe.  Por enquanto, é a terceira parte final - sobre modificadores e interface (arrastar e soltar).  E pretendo colocar o projeto no git para que eu possa ver / sentir.  Se você tiver dúvidas sobre prototipagem, pergunte, tentarei responder com clareza. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453236/">https://habr.com/ru/post/pt453236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453220/index.html">13 erros de marketing por e-mail a serem evitados para melhor engajamento</a></li>
<li><a href="../pt453222/index.html">SuperJob do SphinxSearch-meetup</a></li>
<li><a href="../pt453228/index.html">Relógio Nixie nos indicadores IN-18</a></li>
<li><a href="../pt453232/index.html">Escrevendo bilhões de músicas com C # e Deep Learning</a></li>
<li><a href="../pt453234/index.html">Engenharia reversa do protocolo de troca em equipamentos EOS</a></li>
<li><a href="../pt453238/index.html">Luzes de marcha no relé</a></li>
<li><a href="../pt453242/index.html">Playground para eventos de verão</a></li>
<li><a href="../pt453246/index.html">ERP - Sistema de Degradação Contínua</a></li>
<li><a href="../pt453248/index.html">Missão Lunar Artemis - lançada a produção do elemento principal da estação orbital lunar Lunar Gateway</a></li>
<li><a href="../pt453252/index.html">Como fizemos o programa do clube Sportmaster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>