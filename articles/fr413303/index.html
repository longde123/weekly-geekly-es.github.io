<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö´ üîá üê• L'histoire d'un probl√®me: le plus court m√©mo JavaScript üï¥üèø üîú üîú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'√©tait le soir, √† la veille de la conf√©rence annuelle HolyJS √† Saint-P√©tersbourg. Notre entreprise est sponsor depuis plusieurs ann√©es: elle a donc s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'histoire d'un probl√®me: le plus court m√©mo JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="image"></p><br><p>  C'√©tait le soir, √† la veille de la conf√©rence annuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS</a> √† Saint-P√©tersbourg.  Notre entreprise est sponsor depuis plusieurs ann√©es: elle a donc son propre stand avec des int√©r√™ts int√©ressants pour l'esprit curieux des d√©veloppeurs attentionn√©s.  Quand le plat principal √©tait pr√™t et que toutes les t√¢ches √©taient revues et compl√©t√©es par des avocats, j'ai d√©cid√© de jeter un peu plus de nourriture intellectuelle √† mes coll√®gues la nuit: </p><br><blockquote>  √âcrivez un m√©mo - une fonction de d√©coration qui enregistre les r√©sultats de l'ex√©cution d'une fonction encapsul√©e pour √©viter des calculs r√©p√©t√©s.  Vous n'avez que 50 caract√®res. </blockquote><p>  Le langage est, bien s√ªr, <strong>JavaScript</strong> .  La t√¢che elle-m√™me est un classique, mais la limite de 50 caract√®res s'est transform√©e en un v√©ritable d√©fi. </p><br><p>  Dans les pauses du premier jour de la conf√©rence, nous avons discut√© des options pour atteindre l'objectif, en r√©duisant progressivement la r√©ponse.  Tout le battage m√©diatique a √©t√© couronn√© par l'id√©e de partager la t√¢che avec tous les participants de la conf√©rence, et le deuxi√®me jour, nous avons visualis√© la t√¢che (voir l'annexe) et commenc√© √† distribuer des formulaires √† ceux qui le voulaient.  En cons√©quence, nous avons obtenu environ 40 solutions et sommes une fois de plus convaincus de l'extraordinaire communaut√© de d√©veloppeurs js, mais <strong>le</strong> record de <strong>Dmitry Kataev</strong> (SEMrush) de <strong>53</strong> caract√®res est rest√©.  Voyons √ßa! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Mise en ≈ìuvre habituelle </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  R√©sultat: ~ <strong>190</strong> caract√®res </p><br><ul><li>  memoize - notre memoizer </li><li>  f - fonction d√©cor√©e et envelopp√©e </li><li>  ret - fonction r√©sultante </li></ul><br><p>  Pour obtenir la r√©ponse - la taille de la fonction - nous utilisons: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Lors de l'√©valuation de la taille d'une fonction, nous pr√™tons attention √† son corps et √† une liste de param√®tres.  Si la fonction est anonyme, la d√©claration n'est pas prise en compte. </p><br><p>  Des tests simples pour tester la sant√© apr√®s un abus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  Non. </th><th>  Appel de fonction </th><th>  Le r√©sultat de l'ex√©cution dans la console </th></tr></thead><tbody><tr><td>  1. </td><td> <code>log(false)</code> </td> <td>  &gt; faux </td></tr><tr><td>  2. </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3. </td><td> <code>log(false)</code> </td> <td>  Rien, car la fonction a d√©j√† √©t√© ex√©cut√©e pour ces valeurs. </td></tr><tr><td>  4. </td><td> <code>log('2', {x:1})</code> </td> <td>  Rien, car la fonction a d√©j√† √©t√© ex√©cut√©e pour ces valeurs. </td></tr><tr><td>  5. </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6. </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  Ensuite, le r√©sultat de chaque impl√©mentation sera marqu√© par le r√©sultat du test. </p><br><h3 id="chistaya-realizaciya">  Mise en ≈ìuvre nette </h3><br><p>  Tout d'abord, je veux me d√©barrasser de la <em>d√©claration</em> de <em>fonction</em> en faveur de la fonction fl√®che, car nous ne sommes pas int√©ress√©s par <em>ce</em> contexte, nous ne faisons pas appel aux <em>arguments,</em> et en tant que constructeur, nous n'avons pas l'intention d'appeler via <em>new</em> .  Dans le m√™me temps, nous r√©duirons les noms des variables locales utilis√©es: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  R√©sultat: <strong>154</strong> , tests r√©ussis </p><br><p>  Ensuite, nous pouvons effectuer une op√©ration similaire avec la fonction r√©sultante, mais nous avons besoin d' <em>arguments</em> .  Ici, l' <em>op√©rateur d'√©talement</em> vient √† la rescousse, nous permettant de remplacer l'objet it√©rable pass√© des arguments par la variable tableau <em>a</em> .  De plus, nous ne passerons plus <em>ce</em> contexte √† la fonction en cours de d√©coration: si n√©cessaire, <em>Function.prototype.bind</em> ou notre polyfil vous aidera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  R√©sultat: <strong>127</strong> , tests r√©ussis </p><br><p>  Passons maintenant au corps de la fonction r√©sultante.  √âvidemment, trouver la cl√© dans le cache et renvoyer la valeur est fastidieux.  Essayons de r√©duire comment: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  R√©sultat: <strong>101</strong> , les tests 3 et 4 sont tomb√©s </p><br><p>  Ici, nous abandonnons la m√©thode <em>hasOwnProperty</em> .  Nous pouvons nous le permettre, car le r√©sultat de la s√©rialisation du tableau d'arguments via <em>JSON.stringify</em> sera toujours "[...]" et il est peu probable qu'une telle propri√©t√© <em>apparaisse</em> dans le cache du prototype ( <em>Object</em> ). </p><br><p>  Ensuite, nous utilisons la fonction de l'op√©rateur OR ¬´logique¬ª pour renvoyer la premi√®re expression si elle peut √™tre convertie en <em>vrai</em> , ou sinon, la seconde avec le calcul de fonction pr√©c√©dent. </p><br><p>  Et ici, nous sommes tomb√©s aux tests 3 et 4. Cela s'est produit parce que la fonction d√©cor√©e <em>console.log</em> ne <em>renvoie</em> pas de valeur: le r√©sultat ne sera pas <em>d√©fini</em> .  Nous mettons cela dans le cache, et lorsque nous essayons de v√©rifier la fonctionnalit√© disjoncteur lorsque nous l'appelons √† nouveau, nous obtenons implicitement un affichage <em>faux</em> dans le premier op√©rande et, en cons√©quence, nous entrons dans le second, ce qui conduit √† l'appel de fonction.  Cet effet se produira pour tous les r√©sultats r√©duits √† <em>faux</em> : <em>0, "", null, NaN</em> , etc. </p><br><p>  Au lieu de l' <em>instruction</em> OR et <em>if,</em> nous pouvons utiliser un op√©rateur ternaire conditionnel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  R√©sultat: <strong>118</strong> , tests r√©ussis </p><br><p>  R√©duit tr√®s l√©g√®rement.  Mais que se passe-t-il si vous utilisez <em>Map</em> comme stockage au lieu d'un simple objet?  Il existe √©galement une m√©thode courte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  R√©sultat: <strong>121</strong> , tests r√©ussis </p><br><p>  La r√©duction a compl√®tement √©chou√©.  Mais jeter imm√©diatement <em>Map</em> n'en vaut pas la peine.  Cette impl√©mentation du stockage de valeurs-cl√©s vous permet d'utiliser des objets comme cl√©.  Et cela signifie, devrions-nous abandonner <em>JSON.stringify</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  R√©sultat: <strong>83</strong> , les tests 3 et 4 sont tomb√©s </p><br><p>  Cela semble tr√®s prometteur!  Cependant, les tests 3 et 4 ont recommenc√© √† tomber, car la comparaison des cl√©s dans l'objet <em>Map</em> est impl√©ment√©e √† l'aide de l'algorithme <em>SameValueZero</em> .  Si vous omettez les d√©tails avec <em>NaN, -0</em> et <em>0</em> , cela fonctionne de mani√®re similaire √† <em>l'op√©rateur de comparaison strict</em> ( <em>===</em> ).  Et nous avons un nouveau tableau d'arguments (et donc un objet) pour chaque appel de la fonction encapsul√©e, m√™me avec les m√™mes valeurs.  La comparaison a lieu en fonction de la r√©f√©rence de l'objet et donc la m√©thode <em>Map.prototype.has</em> ne trouvera jamais rien. </p><br><p>  Ainsi, l'utilisation de <em>Map</em> ne nous <em>a</em> pas r√©duit <em>hasOwnProperty</em> ou <em>JSON.stringify</em> . </p><br><p>  En <em>op√©rateur</em> vient √† la rescousse, qui v√©rifie la pr√©sence d'une propri√©t√© dans un objet ou dans la cha√Æne de ses prototypes.  Pourquoi nous ne pouvons pas avoir peur de la recherche dans les prototypes a √©t√© expliqu√© ci-dessus. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  R√©sultat: <strong>105</strong> , tests r√©ussis </p><br><p>  Le corps du memoizer et de la fonction r√©sultante se compose de deux expressions avec la n√©cessit√© de d√©clarer et d'initialiser une variable locale avant la logique dans l' <em>instruction de retour</em> .  Est-il possible de r√©duire le corps de la fonction fl√®che √† une seule expression ici?  Bien s√ªr, en utilisant le <em>mod√®le IIFE</em> ( <em>Immediateely</em> <em>Invoked</em> <em>Function Expression</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  R√©sultat: <strong>82</strong> , tests r√©ussis </p><br><p>  Il est temps de se d√©barrasser des espaces suppl√©mentaires: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  R√©sultat: <strong>68</strong> , tests r√©ussis </p><br><p>  De toute √©vidence, le goulot d'√©tranglement est maintenant la longue m√©thode <em>JSON.stringify</em> , qui s√©rialise r√©cursivement l'objet en une cha√Æne JSON, que nous utilisons comme cl√©.  En fait, nous n'avons pas besoin d'une fonction de s√©rialisation, mais d'une fonction de hachage avec laquelle nous pourrions v√©rifier l'√©galit√© des objets, car cela fonctionne dans d'autres langages.  Mais, malheureusement, il n'y a pas de solution native en JavaScript, et le <em>polyphile</em> auto-√©crit hashCode dans le prototype <em>Object</em> est clairement hors de port√©e. </p><br><p>  Hmm, pourquoi devons-nous m√™me nous s√©rialiser?  Lors de l'ajout d'un √©l√©ment √† un objet par cl√©, sa toString sera appel√©e implicitement.  Comme nous avons refus√© d'utiliser l'objet <em>arguments</em> it√©rables en faveur du tableau via l' <em>op√©rateur de propagation</em> , l'appel √† <em>String</em> ne <em>proviendra</em> pas de <em>Object.prototype</em> , mais de <em>Array.prototype</em> , dans lequel il est red√©fini et s√©par√© par des virgules de ses √©l√©ments.  Ainsi, pour un ensemble d'arguments diff√©rent, nous obtenons une cl√© diff√©rente. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  R√©sultat: <strong>44</strong> , le test 6 est tomb√© </p><br><p>  Le test 6 commence tout juste √† tomber. Il semble que la valeur de retour soit le r√©sultat d'un appel de fonction pr√©c√©dent dans le test 5. Pourquoi cela se produit-il?  Oui, nous avons ignor√© l'appel √† <em>String</em> pour l'objet <em>arguments</em> , mais nous n'avons pas pris en compte le fait qu'un argument peut √©galement √™tre un objet complexe, appelant <em>toString √†</em> partir duquel nous obtenons <em>[l'objet objet]</em> pr√©f√©r√© de tous.  Cela signifie que les arguments {x: 1} et {x: 2} utiliseront la m√™me cl√© dans le hachage. </p><br><p>  Le <em>btoa</em> utilis√© pour convertir en base64 semblait √™tre un bon concurrent pour la fonction de s√©rialisation.  Mais il m√®ne d'abord √† la cha√Æne, donc aucune chance.  Nous avons pens√© dans le sens de g√©n√©rer un URI et de former un <em>ArrayBuffer</em> , toutes les fonctions pour obtenir un hachage ou une valeur s√©rialis√©e.  Mais ils sont rest√©s en place. </p><br><p>  Soit dit en passant, <em>JSON.stringify</em> a ses propres particularit√©s: <em>Infinity, NaN, undefined, Symbol</em> sera <em>converti</em> en <em>null</em> .  Il en va de m√™me pour les fonctions.  Si possible, un appel implicite √† <em>JSON √†</em> partir de l'objet se produit, et <em>Map</em> et <em>Set</em> seront repr√©sent√©s par des √©l√©ments simplement √©num√©r√©s.  C'est compr√©hensible, √©tant donn√© le format final: JSON. </p><br><p>  Et ensuite? </p><br><h3 id="toksichnaya-dorabotka">  Modification toxique </h3><br><p>  Nous aimons certainement tous les fonctions pures, mais face au probl√®me, une telle exigence n'en vaut pas la peine.  Et cela signifie qu'il est temps d'ajouter une pinc√©e d'effets secondaires. </p><br><p>  Tout d'abord, pourquoi ne pas lancer le cache comme suit: </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  R√©sultat: <strong>66</strong> , tests r√©ussis </p><br><p>  Ici, nous utilisons le <em>param√®tre par d√©faut</em> dans la fonction fl√®che.  Bien s√ªr, nous donnons au client la possibilit√© de d√©finir son cache, alors quoi?  Mais nous avons r√©duit 2 caract√®res. </p><br><p>  Sinon, comment puis-je lancer un cache pour une fonction √† d√©corer?  La bonne r√©ponse: pourquoi devons-nous l'initier?  Pourquoi ne pas utiliser quelque chose de pr√™t dans le contexte d'une fonction √† encapsuler.  Mais que faire si la fonction elle-m√™me?  Nous savons tous que les fonctions en JavaScript sont √©galement des objets: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  R√©sultat: <strong>59</strong> , tests r√©ussis </p><br><p>  Ici, <em>JSON.stringify nous</em> prot√©gera contre l'intersection avec d'autres propri√©t√©s et m√©thodes de l'objet (fonction), en enveloppant les arguments dans "[...]". </p><br><p>  En ce moment m√™me, le sch√©ma <em>IIFE</em> pr√©c√©demment appliqu√© <em>ne</em> se justifie plus.  Mais il est urgent de conserver une seule expression pour la fonction fl√®che pour √©viter une <em>d√©claration de retour</em> : </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  R√©sultat: <strong>57</strong> , tests r√©ussis </p><br><p>  Puisque nous n'utilisons pas l' <em>instruction de bloc</em> dans la fonction fl√®che, nous ne pouvons pas d√©clarer une variable ( <em>var</em> ou <em>let</em> ), mais nous pouvons utiliser le contexte global - effet secondaire!  Ici, le conflit a d√©j√† quelques chances d‚Äô√™tre. </p><br><p>  En utilisant l' <em>op√©rateur virgule,</em> nous concat√©nons deux expressions en une seule: les op√©randes sont √©valu√©s de gauche √† droite, et le r√©sultat est la valeur de cette derni√®re. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  R√©sultat: <strong>54</strong> , tests r√©ussis </p><br><p>  Ainsi, en r√©organisant un seul support, nous nous sommes d√©barrass√©s de trois caract√®res √† la fois.  <em>L'op√©rateur de regroupement</em> lors du calcul de la cl√© nous a permis de combiner les deux op√©randes de l'expression en une seule expression, et le crochet de fermeture a supprim√© l'espace avant l' <em>op√©rateur in</em> . </p><br><p>  Et enfin: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  R√©sultat: <strong>53</strong> , tests r√©ussis </p><br><p>  Pourquoi ne pas calculer la cl√© lors de l'acc√®s √† la valeur.  Et puis - le m√™me op√©rateur ternaire et affectation.  Total: 53 caract√®res! </p><br><p>  Est-il possible de supprimer les 3 caract√®res restants? </p><br><h3 id="osmyslenie">  Compr√©hension </h3><br><p>  Pourquoi tout √ßa?  Cette t√¢che simple et la cha√Æne de conversions subs√©quente de l'habituel √† l'ind√©cent d√©montrent un nombre consid√©rable de fonctionnalit√©s du langage JavaScript.  Dans nos discussions, nous avons abord√© des sujets tels que: </p><br><ul><li>  Expression de la fonction fl√®che </li><li>  Port√©e lexicale et IIFE </li><li>  Objet arguments de type tableau </li><li>  Spread, virgule ou op√©rateurs </li><li>  Op√©rateur de comparaison strict </li><li>  JSON.stringify &amp; toString </li><li>  Dans operator &amp; hasOwnProperty </li><li>  Op√©rateur de regroupement et instruction de bloc </li><li>  Objet de carte </li><li>  et autre chose </li></ul><br><p>  De telles histoires sont une bonne raison de s'immerger dans l'√©tude des sp√©cificit√©s d'une langue, de mieux la comprendre (ou vice versa).  Et bien s√ªr, juste pour le plaisir! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="image"></p><br><p>  <em>Dans ses aventures, Rick doit souvent calibrer son arme portique.</em>  <em>La proc√©dure prend du temps, mais l'entr√©e est souvent r√©p√©t√©e.</em>  <em>Le scientifique tente de m√©moriser les r√©sultats d√©j√† obtenus une fois afin de ne pas faire de calculs √† plusieurs reprises, mais l'alcoolisme et la s√©nilit√© s√©nile affectent fortement sa m√©moire.</em>  <em>Il a demand√© √† Morty d'am√©liorer le module des param√®tres du pistolet, en ajoutant une fonction de m√©morisation.</em>  <em>Cette fonction doit enregistrer les r√©sultats de la fonction en cours de d√©coration pour √©viter des calculs r√©p√©t√©s.</em>  <em>Seul Morty a peur des fonctions longues.</em>  <em>Aidez-le √† r√©soudre le probl√®me <strong>de la</strong> mani√®re la <strong>plus</strong> compacte <strong>possible</strong> .</em>  <em>La fonction en cours de d√©coration peut prendre des entiers, des cha√Ænes, des bool√©ens et des objets comme arguments.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413303/">https://habr.com/ru/post/fr413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413287/index.html">DocumentFragment: qu'est-ce que c'est et comment (pas) le combattre</a></li>
<li><a href="../fr413289/index.html">Automatisation des centres de donn√©es ou "r√©bellion des machines"</a></li>
<li><a href="../fr413291/index.html">Le livre "Deep Learning in Python"</a></li>
<li><a href="../fr413293/index.html">Grand exode de l'industrie du jeu vid√©o</a></li>
<li><a href="../fr413297/index.html">Polices Web variables</a></li>
<li><a href="../fr413305/index.html">Batteries, Gigafactory, Northvolt et Siemens. Outsider T</a></li>
<li><a href="../fr413307/index.html">ESET a d√©couvert un banquier BackSwap en utilisant une nouvelle m√©thode de manipulation de navigateur</a></li>
<li><a href="../fr413309/index.html">C√¥t√© sombre agile</a></li>
<li><a href="../fr413311/index.html">Portage de votre application Web de JavaScript pur vers Vue.js</a></li>
<li><a href="../fr413315/index.html">Syst√®me climatique dans l'appartement de vos propres mains - partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>