<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 📁 🖕🏽 Gambaran kecil tentang SIMD di .NET / C # 🙅🏿 🔢 💆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berikut ini sekilas kemampuan vektorisasi algoritma dalam .NET Framework dan .NET Core. Artikel ini ditujukan bagi mereka yang tidak tahu apa-apa tent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gambaran kecil tentang SIMD di .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467689/"><p>  Berikut ini sekilas kemampuan vektorisasi algoritma dalam .NET Framework dan .NET Core.  Artikel ini ditujukan bagi mereka yang tidak tahu apa-apa tentang teknik ini.  Saya juga akan menunjukkan bahwa .NET tidak benar-benar ketinggalan bahasa "dikompilasi nyata" untuk pengembangan asli. </p><a name="habracut"></a><br><p> Saya baru mulai belajar teknik vektorisasi.  Jadi, saya akan menghargai jika anggota masyarakat menemukan kesalahan yang jelas atau menyarankan perbaikan pada algoritma yang dijelaskan. </p><br><h2 id="some-history">  Beberapa sejarah </h2><br><p>  SIMD muncul di .NET Framework 4.6 pada 2015. Saat itulah tipe Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3, dan Vector4 ditambahkan.  Mereka memungkinkan perhitungan vektor.  Berikutnya adalah tipe Vector &lt;T&gt; yang memberi lebih banyak peluang untuk membuat vektor algoritma.  Namun, banyak programmer masih tidak puas karena jenis ini membatasi aliran ide coders dan tidak membiarkan penggunaan kapasitas penuh instruksi SIMD dalam prosesor modern.  Sekarang di .NET Core 3.0 Preview, kami memiliki System.Runtime.Intrinsics namespace yang memberikan banyak kebebasan dalam pilihan instruksi.  Untuk mendapatkan kecepatan maksimal, Anda perlu menggunakan RyuJit dan menggunakan rakitan x64 atau mematikan Prefer 32-bit dan memilih rakitan AnyCPU.  Saya menjalankan semua tolok ukur pada komputer CPU Intel Core i7-6700 3,40 GHz (Skylake). </p><br><h2 id="summing-array-elements">  Menjumlahkan elemen array </h2><br><p>  Saya memutuskan untuk memulai dengan tugas klasik yang biasanya didahulukan jika ada vektorisasi yang terlibat.  Ini berkaitan dengan menemukan jumlah elemen array.  Mari kita menulis empat implementasi dari tugas ini untuk menjumlahkan elemen-elemen dari Array. </p><br><p>  Implementasi yang paling jelas: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Implementasi berbasis LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Implementasi berdasarkan vektor dari System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Implementasi berdasarkan kode dari namespace System.Runtime.Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Saya membandingkan 4 metode tersebut di komputer saya dan mendapatkan hasil sebagai berikut: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10 </td><td>  3,531 ns </td><td>  0,0336 ns </td><td>  0,0314 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76.925 ns </td><td>  0,4166 ns </td><td>  0,3897 ns </td><td>  21.79 </td></tr><tr><td>  Vektor </td><td>  10 </td><td>  2,750 ns </td><td>  0,0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrinsik </td><td>  10 </td><td>  6.513 ns </td><td>  0,0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100 </td><td>  47.982 ns </td><td>  0,3975 ns </td><td>  0,3524 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590.414 ns </td><td>  3,8808 ns </td><td>  3.4402 ns </td><td>  12.31 </td></tr><tr><td>  Vektor </td><td>  100 </td><td>  10.122 ns </td><td>  0,0747 ns </td><td>  0,0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrinsik </td><td>  100 </td><td>  14.277 ns </td><td>  0,0566 ns </td><td>  0,0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1000 </td><td>  569.910 ns </td><td>  2,8297 ns </td><td>  2.6469 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5,658.570 ns </td><td>  31,7465 ns </td><td>  29.6957 ns </td><td>  9,93 </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  79.598 ns </td><td>  0,3498 ns </td><td>  0,3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  66.970 ns </td><td>  0,3937 ns </td><td>  0,3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  5,637.571 ns </td><td>  37.5050 ns </td><td>  29.2814 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275.8287 ns </td><td>  10.02 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  772.900 ns </td><td>  2,6802 ns </td><td>  2,5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  579.152 ns </td><td>  2,8371 ns </td><td>  2,6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  56.352.865 ns </td><td>  230.7916 ns </td><td>  215.8826 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  562.610.571 ns </td><td>  3,775.7631 ns </td><td>  3,152.9332 ns </td><td>  9,98 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  8,389.647 ns </td><td>  165,9590 ns </td><td>  227.1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  7,261.334 ns </td><td>  89.6468 ns </td><td>  69,9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Sudah jelas bahwa solusi dengan Vektor dan Intrinsik jauh lebih cepat daripada solusi yang jelas dan berbasis LINQ.  Sekarang kita perlu mencari tahu apa yang terjadi dalam kedua metode ini. </p><br><p>  Mari kita pertimbangkan metode Vektor lebih dekat: </p><br><div class="spoiler">  <b class="spoiler_title">Vektor</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vektor &lt;int&gt; .Count;  - jumlah angka 4-byte yang dapat kita tempatkan dalam vektor.  Jika akselerasi perangkat keras digunakan, nilai ini menunjukkan berapa banyak angka 4-byte yang dapat kita masukkan dalam satu register SIMD.  Bahkan, ini menunjukkan berapa banyak elemen jenis ini dapat ditangani secara bersamaan; </li><li>  accVector adalah vektor yang mengakumulasikan hasil fungsi; </li><li>  var v = Vector baru &lt;int&gt; (array, i);  - data dari array dimuat ke vektor v baru, mulai dari indeks i.  Ukuran vektor data akan dimuat dengan tepat; </li><li>  accVector = Vector.Add (accVector, v);  - dua vektor dijumlahkan. <br>  Misalnya, ada 8 angka dalam Array: {0, 1, 2, 3, 4, 5, 6, 7} dan vectorSize == 4. <br>  Kemudian selama iterasi siklus pertama, accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3} dan setelah penambahan accVector akan menampung: {0, 0, 0, 0} 0 {0, 1 , 2, 3} = {0, 1, 2, 3}. <br>  Selama iterasi kedua v = {4, 5, 6, 7} dan setelah penambahan accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Sekarang kita hanya perlu mendapatkan jumlah semua elemen vektor.  Untuk melakukan ini kita dapat menggunakan perkalian skalar dengan vektor yang diisi dengan yang: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Maka kita mendapatkan: {4, 6, 8, 10} * {1, 1, 1, 1} = 4 * 1 + 6 * 1 + 8 * 1 + 10 * 1 = 28. </li><li>  Jika perlu, angka-angka yang tidak sesuai dengan vektor terakhir akan dijumlahkan di akhir. </li></ul><br><p>  Mari kita lihat kode intrinsik: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsik</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Kita dapat melihat bahwa itu seperti Vektor dengan satu pengecualian: </p><br><ul><li>  vectorSize ditentukan oleh konstanta.  Ini karena metode ini secara eksplisit menggunakan instruksi Avx2 yang beroperasi dengan register 256-bit.  Aplikasi nyata harus mencakup pemeriksaan apakah prosesor saat ini mendukung Avx2.  Jika tidak, kode lain harus dipanggil.  Ini terlihat seperti ini: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector dinyatakan sebagai vektor 256-bit yang diisi dengan nol. </li><li>  fixed (int * ptr = Array) - pointer ke array ditempatkan di ptr. </li><li>  Berikutnya adalah operasi yang sama seperti di Vektor: memuat data ke dalam vektor dan penambahan dua vektor. </li><li>  Penjumlahan elemen vektor menggunakan metode berikut: <br><ul><li>  buat array di stack: var temp = stackalloc int [vectorSize]; </li><li>  memuat vektor ke dalam array ini: Avx2.Store (temp, accVector); </li><li>  jumlah elemen array selama siklus. </li></ul></li><li>  Selanjutnya, elemen-elemen yang tidak sesuai dengan vektor terakhir diringkas. </li></ul><br><h2 id="comparing-two-arrays">  Membandingkan dua array </h2><br><p>  Kita perlu membandingkan dua array byte.  Persis tugas inilah yang membuat saya mempelajari SIMD di .NET.  Sekali lagi, mari kita menulis beberapa metode untuk pembandingan dan membandingkan dua array: ArrayA dan ArrayB. </p><br><p>  Solusi paling jelas: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solusi berbasis LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Solusi berdasarkan fungsi MemCmp: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Solusi berdasarkan vektor dari System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solusi berbasis intrinsik: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hasil menjalankan patokan di komputer saya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10.000 </td><td>  7.033.8 ns </td><td>  50,636 ns </td><td>  47.365 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  64.841,4 ns </td><td>  289.157 ns </td><td>  270.478 ns </td><td>  9.22 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  504.0 ns </td><td>  2,406 ns </td><td>  2,251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  368.1 ns </td><td>  2,637 ns </td><td>  2,466 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  283,6 ns </td><td>  1,135 ns </td><td>  1,061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  85.214,4 ns </td><td>  903.868 ns </td><td>  845.478 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  702.279,4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  5,179.2 ns </td><td>  45.337 ns </td><td>  42.409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  4,510,5 ns </td><td>  24.292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  2,957,0 ns </td><td>  11.452 ns </td><td>  10.712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  844,006,1 ns </td><td>  3,552.478 ns </td><td>  3,322.990 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6,483.079,3 ns </td><td>  42.641.040 ns </td><td>  39.886.455 ns </td><td>  7.68 </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  54.180.1 ns </td><td>  357.258 ns </td><td>  334.180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  49,480.1 ns </td><td>  515.675 ns </td><td>  457.133 ns </td><td>  0,06 </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  36.633.9 ns </td><td>  680.525 ns </td><td>  636.564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Saya kira kode metode ini jelas, kecuali untuk dua baris dalam Intrinsik: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Pada baris pertama dua vektor dibandingkan untuk kesetaraan dan hasilnya disimpan dalam vektor areEqual di mana semua bit dalam elemen pada posisi tertentu diatur ke 1 jika elemen yang sesuai dalam va dan vb sama.  Jadi, ternyata jika byte vektor va dan vb sama, semua elemen di areEqual harus sama dengan 255 (11111111b).  Karena Avx2.CompareEqual adalah pembungkus di atas _mm256_cmpeq_epi8, kita dapat pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Intel</a> dan melihat pseudocode dari operasi ini: <br>  Metode MoveMask membuat angka 32-bit dari vektor.  Bit teratas dari masing-masing 32 elemen onebyte dalam vektor adalah nilai bit dalam hasil MoveMask.  Kodesemu tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Jadi, jika beberapa byte dalam va dan vb tidak cocok, byte yang sesuai di areEqual akan menjadi 0. Oleh karena itu, bit teratas dari byte ini akan menjadi 0 juga.  Ini berarti bit terkait dalam respons Avx2.MoveMask juga akan 0 dan areEqual tidak akan sama dengan equalsMask. </p><br><p>  Mari kita lihat satu contoh dengan asumsi bahwa panjang vektor adalah 8 byte (untuk menulis lebih sedikit): </p><br><ul><li>  Misalkan va = {100, 10, 20, 30, 100, 40, 50, 100} dan vb = {100, 20, 10, 30, 100, 40, 80, 90}. </li><li>  Maka areEquals akan menjadi {255, 0, 0, 255, 255, 255, 0, 0}. </li><li>  Metode MoveMask akan mengembalikan 10011100b yang harus dibandingkan dengan topeng 11111111b.  Karena topeng ini tidak sama, vektor va dan vb juga tidak sama. </li></ul><br><h2 id="counting-the-times-an-element-occurs-in-a-collection">  Menghitung berapa kali suatu elemen muncul dalam koleksi. </h2><br><p>  Terkadang Anda perlu menghitung kemunculan elemen tertentu, misalnya bilangan bulat, dalam koleksi.  Kami dapat mempercepat algoritme ini juga.  Sebagai perbandingan, mari kita menulis beberapa metode untuk mencari elemen Item di Array. </p><br><p>  Yang paling jelas: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Menggunakan LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  Menggunakan vektor dari System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Menggunakan Intrinsik: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { temp[j] = Item; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = Avx2.LoadVector256(temp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Hasil menjalankan patokan di komputer saya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10 </td><td>  8,844 ns </td><td>  0,0772 ns </td><td>  0,0603 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87.456 ns </td><td>  0,9496 ns </td><td>  0,8883 ns </td><td>  9,89 </td></tr><tr><td>  Vektor </td><td>  10 </td><td>  3,140 ns </td><td>  0,0406 ns </td><td>  0,0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrinsik </td><td>  10 </td><td>  13.813 ns </td><td>  0,0825 ns </td><td>  0,0772 ns </td><td>  1.56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100 </td><td>  107.310 ns </td><td>  0,6975 ns </td><td>  0,6183 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626.285 ns </td><td>  5.7677 ns </td><td>  5.3951 ns </td><td>  5.83 </td></tr><tr><td>  Vektor </td><td>  100 </td><td>  11.844 ns </td><td>  0,2113 ns </td><td>  0,1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrinsik </td><td>  100 </td><td>  19.616 ns </td><td>  0,1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1000 </td><td>  1.032.466 ns </td><td>  6.3799 ns </td><td>  5.6556 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6,266.605 ns </td><td>  42,6585 ns </td><td>  39,9028 ns </td><td>  6.07 </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  83,417 ns </td><td>  0,5393 ns </td><td>  0,4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  88,358 ns </td><td>  0,4921 ns </td><td>  0,4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  9,942.503 ns </td><td>  47.9732 ns </td><td>  40.0598 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  62.305.598 ns </td><td>  643.8775 ns </td><td>  502.6972 ns </td><td>  6.27 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  914.967 ns </td><td>  7.2959 ns </td><td>  6.8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  931.698 ns </td><td>  6.3444 ns </td><td>  5.9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  94.834.804 ns </td><td>  793.8585 ns </td><td>  703.7349 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  626.620.968 ns </td><td>  4,696.9221 ns </td><td>  4,393.5038 ns </td><td>  6.61 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  9,000.827 ns </td><td>  179.5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  8,690.771 ns </td><td>  101.7078 ns </td><td>  95.1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  959.302.249 ns </td><td>  4,268.2488 ns </td><td>  3,783.6914 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6.218.681.888 ns </td><td>  31.321.9277 ns </td><td>  29.298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  99.778.488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  96.449.350 ns </td><td>  1,171.8067 ns </td><td>  978.5116 ns </td><td>  0,10 </td></tr></tbody></table></div><br><p>  Metode Vektor dan Intrinsik sepenuhnya bertepatan dalam logika tetapi berbeda dalam implementasi operasi tertentu.  Idenya adalah sebagai berikut: </p><br><ul><li>  membuat vektor topeng di mana nomor yang diperlukan disimpan di setiap elemen; </li><li>  muat bagian array dalam vektor v dan bandingkan bagian ini dengan mask.  Akibatnya, semua bit akan disetel dalam elemen sama dengan areEqual.  Karena areEqual adalah array bilangan bulat, maka jika kita mengatur semua bit dari satu elemen, kita akan mendapatkan -1 pada elemen ini ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  kurangi areEqual vector dari accVector.  Kemudian, accVector akan menahan hitungan berapa kali elemen item terjadi di semua vektor untuk setiap posisi (dikurangi dengan minus adalah plus). </li></ul><br><p>  Seluruh kode dari artikel ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </p><br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Saya menjelaskan hanya sebagian kecil dari kemampuan .NET untuk vektorisasi perhitungan.  Untuk melihat daftar lengkap semua intrinsik yang tersedia di .NET Core di bawah x86, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> .  Lebih mudah bahwa ringkasan setiap intrinsik dalam file C # berisi namanya di dunia C.  Ini membantu memahami tujuan intrinsik ini dan transfer algoritma C ++ / C yang ada ke .NET.  Dokumentasi System.Numerics.Vector tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">msdn</a> . </p><br><p>  Saya pikir .NET memiliki keunggulan dibandingkan C ++.  Karena kompilasi JIT sudah terjadi pada mesin klien, kompiler dapat mengoptimalkan kode untuk prosesor klien tertentu, memberikan kinerja maksimum.  Pada saat yang sama, seorang programmer dapat tetap berada dalam satu bahasa dan teknologi yang sama untuk menulis kode cepat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467689/">https://habr.com/ru/post/id467689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467675/index.html">Pemodelan status aplikasi menggunakan objek Store di SwiftUI</a></li>
<li><a href="../id467677/index.html">Tes atau tipe</a></li>
<li><a href="../id467679/index.html">PyCrunch - Eksekusi uji cerdas dan cakupan kode visual dalam IDE</a></li>
<li><a href="../id467681/index.html">Routing SOAP Memutar Kerentanan</a></li>
<li><a href="../id467683/index.html">Mencoba menyusun skema docking yang tidak dapat dikomposisikan</a></li>
<li><a href="../id467691/index.html">Intel Nervana NNP-T dan NNP-I - chip khusus untuk AI</a></li>
<li><a href="../id467693/index.html">September Digest Event TI (Bagian Dua)</a></li>
<li><a href="../id467697/index.html">Benarkah GOPATH dan GOROOT tidak lagi dibutuhkan?</a></li>
<li><a href="../id467699/index.html">Bagaimana tidak, membuat strlen tercepat dan menemukan kekurangan di Visual Studio 2019 Community</a></li>
<li><a href="../id467701/index.html">Kategori bukan direktori. Alat untuk penyimpanan file yang nyaman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>