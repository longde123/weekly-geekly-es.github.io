<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº ‚ôåÔ∏è üëµüèº Python e clientes HTTP r√°pidos ü§öüèø „äóÔ∏è üôéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Atualmente, se voc√™ estiver escrevendo algum tipo de aplicativo Python, provavelmente precisar√° equip√°-lo com a funcionalidade de um cliente HTTP capa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python e clientes HTTP r√°pidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  Atualmente, se voc√™ estiver escrevendo algum tipo de aplicativo Python, provavelmente precisar√° equip√°-lo com a funcionalidade de um cliente HTTP capaz de se comunicar com servidores HTTP.  A onipresen√ßa da API REST tornou as ferramentas HTTP um recurso respeitado em in√∫meros projetos de software.  √â por isso que qualquer programador precisa possuir padr√µes destinados a organizar o trabalho ideal com conex√µes HTTP. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Existem muitos clientes HTTP para Python.  O mais comum entre eles e, al√©m disso, o mais f√°cil de trabalhar, pode ser chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicita√ß√£o</a> .  Hoje, esse cliente √© o padr√£o de fato. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Conex√µes permanentes</font> </h2><br>  A primeira otimiza√ß√£o a considerar ao trabalhar com HTTP √© usar conex√µes persistentes com servidores da web.  As conex√µes persistentes tornaram-se padr√£o desde o HTTP 1.1, mas muitos aplicativos ainda n√£o as utilizam.  Essa falha √© f√°cil de explicar, sabendo que ao usar a biblioteca de <code>requests</code> no modo simples (por exemplo, usando seu m√©todo <code>get</code> ), a conex√£o com o servidor √© fechada ap√≥s receber uma resposta dele.  Para evitar isso, o aplicativo precisa usar o objeto <code>Session</code> , que permite reutilizar conex√µes abertas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  As conex√µes s√£o armazenadas no conjunto de conex√µes (o padr√£o √© 10 conex√µes por padr√£o).  O tamanho da piscina pode ser personalizado: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  Reutilizar uma conex√£o TCP para enviar v√°rias solicita√ß√µes HTTP oferece ao aplicativo muitos benef√≠cios de desempenho: <br><br><ul><li>  Reduzindo a carga no processador e reduzindo a necessidade de RAM (devido ao fato de menos conex√µes serem abertas ao mesmo tempo). </li><li>  Redu√ß√£o de atrasos na execu√ß√£o de solicita√ß√µes, uma ap√≥s a outra (n√£o h√° procedimento de handshake TCP). </li><li>  Exce√ß√µes podem ser lan√ßadas sem tempo adicional para fechar a conex√£o TCP. </li></ul><br>  O HTTP 1.1 tamb√©m suporta o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pipelining</a> de solicita√ß√µes.  Isso permite enviar v√°rias solicita√ß√µes dentro da mesma conex√£o sem aguardar respostas para solicita√ß√µes enviadas anteriormente (ou seja, enviar solicita√ß√µes em "pacotes").  Infelizmente, a biblioteca de <code>requests</code> n√£o suporta esse recurso.  No entanto, as solicita√ß√µes de pipeline podem n√£o ser t√£o r√°pidas quanto process√°-las em paralelo.  Al√©m disso, √© apropriado prestar aten√ß√£o a isso: as respostas √†s solicita√ß√µes de "pacotes" devem ser enviadas pelo servidor na mesma sequ√™ncia em que foram recebidas.  O resultado n√£o √© o esquema de processamento de solicita√ß√£o mais eficiente baseado no princ√≠pio FIFO ("primeiro a entrar, primeiro a sair" - "primeiro a chegar, primeiro a sair"). <br><br><h2>  <font color="#3AC1EF">Processamento de consulta paralela</font> </h2><br>  <code>requests</code> tamb√©m t√™m outra desvantagem s√©ria.  Esta √© uma biblioteca s√≠ncrona.  Uma chamada de m√©todo como <code>requests.get("http://example.org")</code> bloqueia o programa at√© que uma resposta completa do servidor HTTP seja recebida.  O fato de o aplicativo ter que esperar e n√£o fazer nada pode ser considerado menos esse esquema de organiza√ß√£o da intera√ß√£o com o servidor.  √â poss√≠vel fazer o programa fazer algo √∫til em vez de apenas esperar? <br><br>  Um aplicativo com design inteligente pode atenuar esse problema usando um conjunto de encadeamentos, semelhante aos fornecidos pelo <code>concurrent.futures</code> .  Isso permite que voc√™ paralelize rapidamente solicita√ß√µes HTTP: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Esse padr√£o muito √∫til √© implementado na biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pedidos futuros</a> .  Ao mesmo tempo, o uso de objetos <code>Session</code> √© transparente para o desenvolvedor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Por padr√£o, um trabalhador com dois threads √© criado, mas o programa pode facilmente definir esse valor passando o argumento <code>FuturSession</code> ou mesmo seu pr√≥prio executor para o objeto <code>FuturSession</code> .  Por exemplo, pode ser assim: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Trabalho ass√≠ncrono com solicita√ß√µes</font> </h2><br>  Como j√° mencionado, a biblioteca de <code>requests</code> √© completamente s√≠ncrona.  Isso leva ao bloqueio de aplicativos enquanto aguarda uma resposta do servidor, o que afeta mal o desempenho.  Uma solu√ß√£o para esse problema √© executar solicita√ß√µes HTTP em threads separados.  Mas o uso de threads √© uma carga adicional no sistema.  Al√©m disso, isso significa a introdu√ß√£o de um esquema de processamento de dados paralelo no programa, que n√£o √© adequado a todos. <br><br>  A partir do Python 3.5, os recursos de linguagem padr√£o incluem programa√ß√£o ass√≠ncrona usando <code>asyncio</code> .  A biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://aio">aiohttp</a> fornece ao desenvolvedor um cliente HTTP ass√≠ncrono com base no <code>asyncio</code> .  Essa biblioteca permite que o aplicativo envie uma s√©rie de solicita√ß√µes e continue trabalhando.  Ao mesmo tempo, para enviar outra solicita√ß√£o, voc√™ n√£o precisa aguardar uma resposta para uma solicita√ß√£o enviada anteriormente.  Diferentemente das solicita√ß√µes HTTP de pipelining, o <code>aiohttp</code> envia solicita√ß√µes em paralelo usando v√°rias conex√µes.  Isso evita o "problema FIFO" descrito acima.  Aqui est√° a apar√™ncia do uso do <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Todas as abordagens descritas acima (usando <code>Session</code> , streams, <code>concurrent.futures</code> ou <code>asyncio</code> ) oferecem maneiras diferentes de acelerar os clientes HTTP. <br><br><h2>  <font color="#3AC1EF">Desempenho</font> </h2><br>  O c√≥digo a seguir √© um exemplo no qual o cliente HTTP envia solicita√ß√µes ao servidor <code>httpbin.org</code> .  O servidor suporta uma API que pode, entre outras coisas, simular um sistema que demora muito para responder a uma solicita√ß√£o (nesse caso, √© de 1 segundo).  Aqui, todas as t√©cnicas discutidas acima s√£o implementadas e seu desempenho √© medido: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Aqui est√£o os resultados obtidos ap√≥s o in√≠cio deste programa: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Aqui est√° um gr√°fico dos resultados. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Os resultados de um estudo do desempenho de diferentes m√©todos para fazer solicita√ß√µes HTTP</font></i> <br><br>  N√£o √© de surpreender que o esquema de execu√ß√£o de consulta s√≠ncrona mais simples tenha sido o mais lento.  O ponto aqui √© que aqui as consultas s√£o executadas uma a uma, sem reutilizar a conex√£o.  Como resultado, s√£o necess√°rios 12 segundos para concluir 10 consultas. <br><br>  Usar o objeto <code>Session</code> e, como resultado, reutilizar conex√µes, economiza 8% do tempo.  Isso j√° √© muito bom, e conseguir isso √© muito simples.  Quem se preocupa com o desempenho deve usar pelo menos o objeto <code>Session</code> . <br><br>  Se seu sistema e seu programa permitem trabalhar com threads, esse √© um bom motivo para pensar em usar threads para paralelizar solicita√ß√µes.  Os fluxos, no entanto, criam uma carga adicional no sistema; eles s√£o, por assim dizer, n√£o "livres".  Eles precisam ser criados, executados, √© preciso aguardar a conclus√£o do trabalho deles. <br><br>  Se voc√™ deseja usar o cliente HTTP ass√≠ncrono r√°pido, se n√£o estiver escrevendo em vers√µes mais antigas do Python, preste muita aten√ß√£o ao <code>aiohttp</code> .  Esta √© a solu√ß√£o mais r√°pida e melhor escal√°vel.  √â capaz de lidar com centenas de solicita√ß√µes simult√¢neas. <br><br>  Uma alternativa ao <code>aiohttp</code> , e n√£o uma alternativa particularmente boa, √© gerenciar centenas de threads em paralelo. <br><br><h2>  <font color="#3AC1EF">Processamento de dados de fluxo</font> </h2><br>  Outra otimiza√ß√£o do trabalho com recursos de rede, que pode ser √∫til em termos de melhoria do desempenho do aplicativo, √© usar dados de streaming.  O esquema de processamento de solicita√ß√µes padr√£o se parece com o seguinte: o aplicativo envia uma solicita√ß√£o, ap√≥s a qual o corpo dessa solicita√ß√£o √© carregado de uma s√≥ vez.  O par√¢metro <code>stream</code> , que suporta a biblioteca de <code>requests</code> , bem como o atributo <code>content</code> da biblioteca <code>aiohttp</code> , permite que voc√™ se afaste desse esquema. <br><br>  Veja como √© a organiza√ß√£o do processamento de dados de streaming usando <code>requests</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  Veja como transmitir dados usando o <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  Eliminar a necessidade de carregamento instant√¢neo do conte√∫do completo da resposta √© importante nos casos em que √© necess√°rio evitar a possibilidade potencial de aloca√ß√£o in√∫til de centenas de megabytes de mem√≥ria.  Se o programa n√£o precisar acessar a resposta como um todo, se puder trabalhar com fragmentos individuais da resposta, provavelmente √© melhor recorrer a m√©todos de fluxo de trabalho com solicita√ß√µes.  Por exemplo, se voc√™ deseja salvar dados da resposta do servidor a um arquivo, a leitura e a grava√ß√£o em partes ser√£o muito mais eficientes em termos de uso de mem√≥ria do que a leitura de todo o corpo da resposta, a aloca√ß√£o de uma quantidade enorme de mem√≥ria e a grava√ß√£o em disco. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Espero que minha palestra sobre diferentes maneiras de otimizar a opera√ß√£o de clientes HTTP o ajude a escolher o que melhor se adequa ao seu aplicativo Python. <br><br>  <b>Caros leitores!</b>  Se voc√™ ainda conhece outras maneiras de otimizar o trabalho com solicita√ß√µes HTTP em aplicativos Python, compartilhe-as. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472858/">https://habr.com/ru/post/pt472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472848/index.html">Reflex√µes sobre uma carreira em TI</a></li>
<li><a href="../pt472850/index.html">Profiss√£o ou vida: ganhe um curso de netologia se n√£o tiver medo</a></li>
<li><a href="../pt472852/index.html">O GitLab faz altera√ß√µes para usu√°rios de produtos comerciais e em nuvem</a></li>
<li><a href="../pt472854/index.html">Cria√ß√£o de perfil de interface de usu√°rio do Unity: quem estraga meus lotes?</a></li>
<li><a href="../pt472856/index.html">Como criei um servi√ßo de controle de qualidade a partir de mesas e paus</a></li>
<li><a href="../pt472862/index.html">Invalida√ß√£o de cache em cascata. Parte 2</a></li>
<li><a href="../pt472864/index.html">Check Point: otimiza√ß√£o de CPU e RAM</a></li>
<li><a href="../pt472866/index.html">Talism√£ para comunica√ß√£o est√°vel</a></li>
<li><a href="../pt472870/index.html">Por que o Agile fica parado sem transformar as ferramentas de arquitetura e desenvolvimento - apresenta√ß√£o da confer√™ncia</a></li>
<li><a href="../pt472872/index.html">Como aumentar a inicializa√ß√£o para 50 funcion√°rios sem perder a cultura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>