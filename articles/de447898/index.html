<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öóÔ∏è üêπ üë®üèΩ‚Äçüè´ Gut gen√§hrte Philosophen oder wettbewerbsf√§hige .NET-Programmierung ‚ú°Ô∏è üè≥Ô∏è‚Äçüåà üåê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns anhand des Problems der Speisephilosophen sehen, wie die gleichzeitige und parallele Programmierung in .Net funktioniert. Ein solcher P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gut gen√§hrte Philosophen oder wettbewerbsf√§hige .NET-Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447898/"><p><img src="https://habrastorage.org/webt/ox/lr/6d/oxlr6dmndsfjh_zjsowzpozt-30.png"></p><br><p>  Lassen Sie uns anhand des Problems der Speisephilosophen sehen, wie die gleichzeitige und parallele Programmierung in .Net funktioniert.  Ein solcher Plan, von der Synchronisation von Threads / Prozessen bis zum Modell der Akteure (in den folgenden Teilen).  Der Artikel kann f√ºr eine erste Bekanntschaft oder zur Auffrischung Ihres Wissens n√ºtzlich sein. </p><br><p>  Warum das k√∂nnen?  Transistoren erreichen ihre minimale Gr√∂√üe, Moores Gesetz beruht auf der Begrenzung der Lichtgeschwindigkeit, und daher wird ein Wachstum in der Menge beobachtet, mehr Transistoren k√∂nnen durchgef√ºhrt werden.  Gleichzeitig w√§chst die Datenmenge und die Benutzer erwarten eine sofortige Reaktion der Systeme.  In einer solchen Situation ist die ‚Äûnormale‚Äú Programmierung, wenn wir einen ausf√ºhrenden Thread haben, nicht mehr effektiv.  Es ist notwendig, das Problem der gleichzeitigen oder wettbewerbsorientierten Ausf√ºhrung irgendwie zu l√∂sen.  Dar√ºber hinaus besteht dieses Problem auf verschiedenen Ebenen: auf der Ebene der Fl√ºsse, auf der Ebene der Prozesse, auf der Ebene der Maschinen im Netzwerk (verteilte Systeme).  .NET verf√ºgt √ºber hochwertige, bew√§hrte Technologien zur schnellen und effektiven L√∂sung solcher Probleme. </p><a name="habracut"></a><br><br><h2 id="anchorproblemanchor-zadacha"><a name="problem"></a>  Herausforderung </h2><br><p>  Edsger Dijkstra stellte seinen Sch√ºlern dieses Problem bereits 1965 vor. Der etablierte Wortlaut lautet wie folgt.  Es gibt einige (normalerweise f√ºnf) Philosophen und ebenso viele Gabeln.  Sie sitzen am runden Tisch, Gabeln dazwischen.  Philosophen k√∂nnen mit endlosem Essen von ihren Tellern essen, nachdenken oder warten.  Um den Philosophen zu essen, m√ºssen Sie zwei Gabeln nehmen (die letztere teilt die Gabel mit der ersten).  Eine Gabel nehmen und setzen - zwei getrennte Aktionen.  Alle Philosophen schweigen.  Die Aufgabe besteht darin, einen solchen Algorithmus zu finden, den alle denken und auch nach 54 Jahren satt haben. </p><br><p>  Versuchen wir zun√§chst, dieses Problem mithilfe des gemeinsam genutzten Speicherplatzes zu l√∂sen.  Die Gabeln liegen auf dem Tisch und die Philosophen nehmen sie einfach, wenn sie sind, und legen sie zur√ºck.  Es gibt Probleme mit der Synchronisation, wann genau die Stecker zu nehmen?  Was tun, wenn kein Stecker vorhanden ist?  und andere. Aber zuerst wollen wir die Philosophen starten. </p><br><p> Verwenden Sie zum Starten von Threads den Thread-Pool √ºber die <code>Task.Run</code> Methode: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelTokenSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; philosophersAmount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> icopy = i; <span class="hljs-comment"><span class="hljs-comment">//      .  RunDeadlock   // ,    .  . philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token); }</span></span></code> </pre> <br><p>  Thread-Pool erstellt, um die Erstellung und L√∂schung von Threads zu optimieren.  Dieser Pool verf√ºgt √ºber eine Aufgabenwarteschlange, und die CLR erstellt oder l√∂scht Threads abh√§ngig von der Anzahl dieser Aufgaben.  Ein Pool f√ºr alle AppDomains.  Dieser Pool sollte fast immer benutzt werden, weil  Sie m√ºssen sich nicht um das Erstellen, L√∂schen von Threads, deren Warteschlangen usw. k√ºmmern. Es ist ohne Pool m√∂glich, aber dann m√ºssen Sie <code>Thread</code> direkt verwenden. Dies ist ratsam, wenn Sie die Priorit√§t eines Threads √§ndern m√ºssen, wenn wir eine lange Operation haben, f√ºr den Vordergrund eines Threads usw. </p><br><p>  Und die <code>System.Threading.Tasks.Task</code> Klasse macht es einfach, mit diesem Thread-Pool zu arbeiten (oder sogar darauf zu verzichten).  Es ist eine asynchrone Operation.  Grob gesagt ist dies der gleiche <code>Thread</code> , aber mit allen m√∂glichen Annehmlichkeiten: Die M√∂glichkeit, Aufgaben nach einem Block anderer Aufgaben zu starten, sie von Funktionen zur√ºckzugeben, sie bequem zu unterbrechen und vieles mehr.  usw. Sie werden ben√∂tigt, um asynchrone / wartende Konstrukte zu unterst√ºtzen (aufgabenbasiertes asynchrones Muster, syntaktischer Zucker zum Warten auf den E / A-Betrieb).  Wir werden noch einmal dar√ºber sprechen. </p><br><p>  <code>CancelationTokenSource</code> wird hier ben√∂tigt, damit der Thread selbst durch das Signal des aufrufenden Threads beendet werden kann. </p><br><h2 id="problemy-s-sinhronizaciey">  Synchronisierungsprobleme </h2><br><h3 id="blokirovannye-filosofy">  Blockierte Philosophen </h3><br><p>  Ok, wir k√∂nnen Threads erstellen. Versuchen wir, zu Mittag zu essen: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    .  : 1 1 3 3 - 1  3    . private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray(); //  ,  RunPhilosopher() private void RunDeadlock(int i, CancellationToken token) { //  ,  . : // while(true) // if forks[fork] == 0 // forks[fork] = i+1 // break // Thread.Sleep()  Yield()  SpinWait() void TakeFork(int fork) =&gt; SpinWait.SpinUntil(() =&gt; Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0); //  ,    Interlocked.Exchange: void PutFork(int fork) =&gt; forks[fork] = 0; while (true) { TakeFork(Left(i)); TakeFork(Right(i)); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutFork(Left(i)); PutFork(Right(i)); Think(i); //   -. token.ThrowIfCancellationRequested(); } }</span></span></code> </pre> <br><p>  Hier versuchen wir zuerst, die linken und dann die rechten Gabeln zu nehmen, und wenn es funktioniert, dann essen wir und legen sie zur√ºck.  Das Nehmen einer Gabel ist atomar, d.h.  Zwei Streams k√∂nnen nicht gleichzeitig einen nehmen (falsch: Der erste liest, dass der Stecker frei ist, der zweite auch, der erste nimmt, der zweite nimmt).  Zu diesem <code>XCHG</code> <code>Interlocked.CompareExchange</code> , das mithilfe eines Prozessorbefehls ( <code>TSL</code> , <code>XCHG</code> ) implementiert werden muss, der ein St√ºck Speicher f√ºr atomares sequentielles Lesen und Schreiben blockiert.  Und SpinWait entspricht einem <code>while(true)</code> -Konstrukt mit nur wenig "Magie" - der Thread nimmt den Prozessor auf ( <code>Thread.SpinWait</code> ), √ºbertr√§gt aber manchmal die Kontrolle auf einen anderen Thread ( <code>Thread.Yeild</code> ) oder schl√§ft ein ( <code>Thread.Sleep</code> ). </p><br><p>  Aber diese L√∂sung funktioniert nicht, weil  Fl√ºsse werden bald blockiert sein (f√ºr mich innerhalb einer Sekunde): Alle Philosophen nehmen ihre linke Gabel, aber nicht die rechte.  Das Forks-Array hat dann folgende Werte: 1 2 3 4 5. </p><br><p><img src="https://habrastorage.org/webt/4l/0x/h9/4l0xh9rwiyjh1l8u2z2szlnv--o.png" alt="Livelock"></p><br><p>  In der Abbildung blockierende Threads (Deadlock).  Gr√ºn zeigt die Ausf√ºhrung an, Rot zeigt die Synchronisation an und Grau zeigt den Ruhezustand an.  Diamanten geben die Startzeit der Aufgabe an. </p><br><h3 id="golod-filosofov">  Der Hunger der Philosophen </h3><br><p>  Es ist zwar nicht notwendig, besonders viel √ºber Essen nachzudenken, aber man muss jeden zwingen, die Philosophie aufzugeben.  Versuchen wir, die Situation der Fastenstr√∂me in unserem Problem zu simulieren.  Hunger ist, wenn der Strom funktioniert, aber ohne nennenswerte Arbeit, mit anderen Worten, es ist der gleiche Stillstand, nur jetzt schl√§ft der Strom nicht, sondern sucht aktiv nach etwas zu essen, aber es gibt kein Essen.  Um h√§ufiges Blockieren zu vermeiden, setzen wir den Stecker wieder ein, wenn wir keinen anderen nehmen k√∂nnten. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      RunDeadlock,         . private void RunStarvation(int i, CancellationToken token) { while (true) { bool hasTwoForks = false; var waitTime = TimeSpan.FromMilliseconds(50); //      : bool hasLeft = forks[Left(i)] == i + 1; if (hasLeft || TakeFork(Left(i), i + 1, waitTime)) { if (TakeFork(Right(i), i + 1, TimeSpan.Zero)) hasTwoForks = true; else PutFork(Left(i)); //      . } if (!hasTwoForks) { if (token.IsCancellationRequested) break; continue; } eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); bool goodPhilosopher = i % 2 == 0; //        : if (goodPhilosopher) PutFork(Left(i)); //      ,      . PutFork(Right(i)); Think(i); if (token.IsCancellationRequested) break; } } //     . bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null) { return SpinWait.SpinUntil( () =&gt; Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0, waitTime ?? TimeSpan.FromMilliseconds(-1) ); }</span></span></code> </pre> <br><p>  In diesem Code ist es wichtig, dass zwei von vier Philosophen vergessen, ihre linke Gabel zu setzen.  Und es stellt sich heraus, dass sie mehr essen, w√§hrend andere anfangen zu verhungern, obwohl die Str√∂me die gleiche Priorit√§t haben.  Hier verhungern sie nicht wirklich, weil  schlechte Philosophen legen manchmal ihre Gabeln zur√ºck.  Es stellt sich heraus, dass die Guten etwa f√ºnfmal weniger essen als die Schlechten.  Ein kleiner Fehler im Code f√ºhrt also zu einem Leistungsabfall.  Hier ist anzumerken, dass eine seltene Situation m√∂glich ist, wenn alle Philosophen die linke Gabel nehmen, es gibt keine rechte, sie setzen die linke, warten, nehmen die linke wieder usw.  Diese Situation ist auch Hunger, eher wie ein Stillstand.  Ich konnte es nicht wiederholen.  Unten sehen Sie ein Bild f√ºr eine Situation, in der zwei schlechte Philosophen beide Gabeln genommen haben und zwei gute Philosophen verhungern. </p><br><p><img src="https://habrastorage.org/webt/2v/iw/b_/2viwb_qgxqznj1timeklnwscluw.png" alt="Hunger"></p><br><p>  Hier k√∂nnen Sie sehen, dass Threads manchmal aufwachen und versuchen, eine Ressource zu erhalten.  Zwei der vier Kerne tun nichts (die gr√ºne Grafik oben). </p><br><h3 id="smert-filosofa">  Der Tod des Philosophen </h3><br><p>  Nun, ein weiteres Problem, das das herrliche Abendessen der Philosophen unterbrechen kann, ist, wenn einer von ihnen pl√∂tzlich mit Gabeln in den H√§nden stirbt (und sie werden ihn so begraben).  Dann bleiben die Nachbarn ohne Mittagessen.  Sie k√∂nnen selbst <code>NullReferenceException</code> Beispielcode f√ºr diesen Fall <code>NullReferenceException</code> Beispielsweise wird eine <code>NullReferenceException</code> ausgel√∂st, nachdem der Philosoph die Gabeln genommen hat.  <code>AppDomain.CurrentDomain.UnhandledException</code> wird die Ausnahme nicht verarbeitet und der aufrufende Code f√§ngt sie einfach nicht ab (daf√ºr <code>AppDomain.CurrentDomain.UnhandledException</code> usw.).  Daher sind Fehlerbehandlungsroutinen in den Threads selbst und mit der richtigen Beendigung erforderlich. </p><br><h2 id="oficiant">  Kellner </h2><br><p>  Wie l√∂sen wir dieses Problem mit Deadlocks, Hunger und Tod?  Wir werden nur einem Philosophen erlauben, sich zu gabeln und den gegenseitigen Ausschluss von Fl√ºssen f√ºr diesen Ort hinzuzuf√ºgen.  Wie kann man das machen?  Angenommen, ein Kellner steht neben den Philosophen, der einem Philosophen die Erlaubnis gibt, Gabeln zu nehmen.  Wie machen wir diesen Kellner und wie stellen ihm Philosophen interessante Fragen? </p><br><p>  Der einfachste Weg ist, wenn die Philosophen den Kellner einfach st√§ndig um Zugang zu den Gabeln bitten.  Das hei√üt,  Jetzt warten Philosophen nicht auf einen Stecker in der N√§he, sondern warten oder fragen einen Kellner.  Erstens verwenden wir hierf√ºr nur User Space. Dabei verwenden wir keine Interrupts, um Prozeduren aus dem Kernel aufzurufen (dazu weiter unten). </p><br><h3 id="resheniya-v-prostranstve-polzovatelya">  User Space-L√∂sungen </h3><br><p>  Hier werden wir das Gleiche tun wie fr√ºher mit einer Gabel und zwei Philosophen, wir werden uns in einem Zyklus drehen und warten.  Aber jetzt werden es alle Philosophen sein und als ob nur eine Gabel, d.h.  Wir k√∂nnen sagen, dass es nur diesen Philosophen geben wird, der diese "goldene Gabel" vom Kellner genommen hat.  Daf√ºr verwenden wir SpinLock. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SpinLock spinLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinLock(); <span class="hljs-comment"><span class="hljs-comment">//  "" private void RunSpinLock(int i, CancellationToken token) { while (true) { //    busy waiting.   try,  //        SpinLock. bool hasLock = false; spinLock.Enter(ref hasLock); try { //       (mutual exclusion). forks[Left(i)] = i + 1; //   ,  . forks[Right(i)] = i + 1; eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); forks[Left(i)] = 0; forks[Right(i)] = 0; } finally { if(hasLock) spinLock.Exit(); //     . } Think(i); if (token.IsCancellationRequested) break; } }</span></span></code> </pre> <br><p>  <code>SpinLock</code> ist ein Blocker, der grob gesagt dasselbe ist, <code>while(true) { if (!lock) break; }</code>  <code>while(true) { if (!lock) break; }</code> , aber mit noch mehr "Magie" als in <code>SpinWait</code> (das dort verwendet wird).  Jetzt wei√ü er, wie man diejenigen z√§hlt, die warten, sie ein wenig einschl√§fert und vieles mehr.  etc. Im Allgemeinen tut alles m√∂glich, um zu optimieren.  Wir m√ºssen uns jedoch daran erinnern, dass dies immer noch derselbe aktive Zyklus ist, der Prozessorressourcen verbraucht und einen Thread beibeh√§lt, der zum Hunger f√ºhren kann, wenn einer der Philosophen Vorrang vor anderen hat, aber keine goldene Gabel hat (Priority Inversion-Problem).  Daher verwenden wir es nur f√ºr sehr sehr kurze √Ñnderungen im gemeinsam genutzten Speicher, ohne dass Aufrufe von Drittanbietern, verschachtelte Sperren usw. √úberraschungen verursachen. </p><br><p><img src="https://habrastorage.org/webt/ev/wu/kk/evwukkxrcgfutky1cihoe5dns0e.png" alt="Spinlock"></p><br><p>  Abbildung f√ºr <code>SpinLock</code> .  B√§che "k√§mpfen" st√§ndig um die goldene Gabel.  Fehler treten auf - in der Abbildung der ausgew√§hlte Bereich.  Die Kerne sind nicht voll ausgelastet: nur etwa 2/3 dieser vier F√§den. </p><br><p>  Eine andere L√∂sung w√§re, nur <code>Interlocked.CompareExchange</code> mit der gleichen aktiven Erwartung zu verwenden, wie im obigen Code gezeigt (bei hungernden Philosophen), aber dies k√∂nnte, wie bereits erw√§hnt, theoretisch zum Blockieren f√ºhren. </p><br><p>  √úber <code>Interlocked</code> Es ist erw√§hnenswert, dass es nicht nur <code>CompareExchange</code> , sondern auch andere Methoden zum atomaren Lesen UND Schreiben.  Durch Wiederholen der √Ñnderungen f√ºr den Fall, dass ein anderer Thread seine √Ñnderungen vornehmen kann (Lesen 1, Lesen 2, Schreiben 2, Schreiben 1 ist schlecht), kann er f√ºr komplexe √Ñnderungen eines Werts verwendet werden (Interlocked Anything-Muster). </p><br><h3 id="resheniya-v-rezhime-yadra">  Kernel-Modus-L√∂sungen </h3><br><p>  Um zu vermeiden, dass Ressourcen in einer Schleife verloren gehen, sehen wir uns an, wie Sie einen Stream blockieren k√∂nnen.  Mit anderen Worten, wenn wir unser Beispiel fortsetzen, werden wir sehen, wie der Kellner den Philosophen einschl√§fert und ihn nur dann weckt, wenn es n√∂tig ist.  Lassen Sie uns zun√§chst sehen, wie dies im Kernel-Modus des Betriebssystems erfolgt.  Alle Strukturen dort erweisen sich h√§ufig als langsamer als die im Benutzerbereich.  Mehrfach langsamer, zum Beispiel kann <code>AutoResetEvent</code> 53-mal langsamer sein als <code>SpinLock</code> [Richter].  Mit ihrer Hilfe k√∂nnen Sie Prozesse im gesamten System synchronisieren, ob verwaltet oder nicht. </p><br><p>  Die Hauptkonstruktion hier ist das Semaphor, das Dijkstroy vor mehr als einem halben Jahrhundert vorgeschlagen hat.  Ein Semaphor ist in einfachen Worten eine positive ganze Zahl, die von einem System gesteuert wird, und zwei Operationen daran - Erh√∂hen und Verringern.  Wenn die Reduzierung nicht funktioniert, Null, wird der aufrufende Thread blockiert.  Wenn die Anzahl durch einen anderen aktiven Thread / Prozess erh√∂ht wird, werden die Threads √ºbersprungen und das Semaphor verringert sich erneut um die Anzahl der √ºbergebenen Threads.  Sie k√∂nnen sich Z√ºge in einem Engpass mit einem Semaphor vorstellen.  .NET bietet verschiedene Designs mit √§hnlichen Funktionen: <code>AutoResetEvent</code> , <code>ManualResetEvent</code> , <code>Mutex</code> und <code>Semaphore</code> .  Wir werden <code>AutoResetEvent</code> , dies ist die einfachste dieser Konstruktionen: Nur zwei Werte sind 0 und 1 (false, true).  Die <code>WaitOne()</code> -Methode blockiert den aufrufenden Thread, wenn der Wert 0 war, und wenn 1, wird er auf 0 gesenkt und √ºbersprungen.  Und die <code>Set()</code> -Methode erh√∂ht sich auf 1 und √ºberspringt eine Wartezeit, die sich wieder auf 0 senkt. Sie wirkt wie ein Drehkreuz in der U-Bahn. </p><br><p>  Wir werden die L√∂sung komplizieren und das Schloss f√ºr jeden Philosophen und nicht f√ºr alle gleichzeitig verwenden.  Das hei√üt,  Jetzt kann es mehrere Philosophen gleichzeitig geben und nicht einen.  Aber wieder blockieren wir den Zugang zum Tisch, um Gabeln richtig zu nehmen und Rennen zu vermeiden (Rennbedingungen). </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    . // : new AutoResetEvent(true)  . private AutoResetEvent[] philosopherEvents; //     /   . private AutoResetEvent tableEvent = new AutoResetEvent(true); //  . public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); //  . // .    . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); //     . Think(i); if (token.IsCancellationRequested) break; } } //    . void TakeForks(int i) { bool hasForks = false; while (!hasForks) //    (  ). { //    ,    . tableEvent.WaitOne(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) forks[Left(i)] = forks[Right(i)] = i + 1; hasForks = forks[Left(i)] == i + 1 &amp;&amp; forks[Right(i)] == i + 1; if (hasForks) //   ,   .  Set //  ,   true. philosopherEvents[i].Set(); //   .    tableEvent  false. tableEvent.Set(); //   true,  ,   false,    Set  . philosopherEvents[i].WaitOne(); } } //     . void PutForks(int i) { tableEvent.WaitOne(); //    . forks[Left(i)] = 0; //  ,     ,  AutoResetEvent  true. philosopherEvents[LeftPhilosopher(i)].Set(); forks[Right(i)] = 0; philosopherEvents[RightPhilosopher(i)].Set(); tableEvent.Set(); }</span></span></code> </pre> <br><p>  Um zu verstehen, was hier passiert, betrachten Sie den Fall, in dem der Philosoph die Gabeln nicht genommen hat, dann werden seine Handlungen so sein.  Er wartet auf den Zugang zum Tisch.  Nachdem er es erhalten hat, versucht er die Gabeln zu nehmen.  Hat nicht funktioniert.  Er gew√§hrt Zugang zum Tisch (gegenseitiger Ausschluss).  Und es passiert sein "Drehkreuz" ( <code>AutoResetEvent</code> ) (zuerst sind sie ge√∂ffnet).  Es tritt wieder in den Zyklus ein, weil  Er hat keine Gabeln.  Versucht sie zu nehmen und bleibt an seinem Drehkreuz stehen.  Ein gl√ºcklicherer Nachbar rechts oder links, der mit dem Essen fertig ist, √∂ffnet unseren Philosophen und "√∂ffnet sein Drehkreuz".  Unser Philosoph gibt es zum zweiten Mal (und er schlie√üt sich dahinter).  Versucht zum dritten Mal, die Gabeln zu nehmen.  Viel Gl√ºck.  Und geht an seinem Drehkreuz vorbei, um zu speisen. </p><br><p>  Wenn ein solcher Code zuf√§llige Fehler enth√§lt (sie sind immer vorhanden), beispielsweise ein Nachbar falsch angegeben ist oder f√ºr alle das gleiche <code>AutoResetEvent</code> Objekt <code>AutoResetEvent</code> wird ( <code>Enumerable.Repeat</code> ), warten Philosophen auf die Entwickler, weil  Fehler in einem solchen Code zu finden, ist eine ziemlich schwierige Aufgabe.  Ein weiteres Problem bei dieser L√∂sung ist, dass sie nicht garantiert, dass ein Philosoph nicht verhungert. </p><br><h3 id="gibridnye-resheniya">  Hybridl√∂sungen </h3><br><p>  Wir haben zwei Ans√§tze zur Synchronisation untersucht, wenn wir im Benutzermodus bleiben und uns in einer Schleife drehen und wenn wir einen Thread durch den Kernel blockieren.  Die erste Methode eignet sich f√ºr kurze Schl√∂sser, die zweite f√ºr lange.  Oft m√ºssen Sie zuerst kurz warten, bis sich eine Variable in der Schleife √§ndert, und dann den Thread blockieren, wenn die Wartezeit lang ist.  Dieser Ansatz wird in der sogenannten implementiert  Hybrid-Designs.  Es gibt die gleichen Konstrukte wie f√ºr den Kernel-Modus, aber jetzt mit einer Schleife im Benutzermodus: <code>SemaphorSlim</code> , <code>ManualResetEventSlim</code> usw. Die beliebteste Konstruktion hier ist <code>Monitor</code> , weil  C # hat eine bekannte Sperrsyntax.  <code>Monitor</code> ist das gleiche Semaphor mit einem Maximalwert von 1 (Mutex), aber mit Unterst√ºtzung f√ºr das Warten in einer Schleife, Rekursion, Muster der Bedingungsvariablen (siehe unten) usw. Schauen wir uns eine L√∂sung damit an. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   . private readonly object _lock = new object(); //   . private DateTime?[] _waitTimes = new DateTime?[philosophersAmount]; public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } //     Condition Variable . bool CanIEat(int i) { //   : if (forks[Left(i)] != 0 &amp;&amp; forks[Right(i)] != 0) return false; var now = DateTime.Now; // ,     ,  . foreach(var p in new int[] {LeftPhilosopher(i), RightPhilosopher(i)}) if (_waitTimes[p] != null &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i]) return false; return true; } void TakeForks(int i) { //   .   : lock(_lock) {..}. //   try,     . bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { _waitTimes[i] = DateTime.Now; // Condition Variable .  ,    //  .    -  Pulse / PulseAll. while (!CanIEat(i)) Monitor.Wait(_lock); forks[Left(i)] = i + 1; forks[Right(i)] = i + 1; _waitTimes[i] = null; } finally { if (lockTaken) Monitor.Exit(_lock); } } void PutForks(int i) { //   : lock (_lock) {..}. bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { forks[Left(i)] = 0; forks[Right(i)] = 0; //        Monitor.Exit. Monitor.PulseAll(_lock); } finally { if (lockTaken) Monitor.Exit(_lock); } }</span></span></code> </pre> <br><p>  Hier sperren wir wieder den gesamten Tisch f√ºr den Zugang zu den Gabeln, aber jetzt entsperren wir alle B√§che auf einmal und nicht die Nachbarn, wenn jemand mit dem Essen fertig ist.  Das hei√üt,  Zuerst isst und blockiert jemand die Nachbarn, und wenn dieser fertig ist, aber sofort wieder essen will, geht er ins Schloss und weckt seine Nachbarn, weil  seine Wartezeit ist k√ºrzer. </p><br><p>  So vermeiden wir die Blockaden und den Hunger eines Philosophen.  Wir verwenden eine Schleife f√ºr eine kurze Wartezeit und blockieren den Fluss f√ºr eine lange Wartezeit.  Das Entsperren auf einmal funktioniert langsamer als wenn nur der Nachbar entsperrt w√ºrde, wie in der L√∂sung mit <code>AutoResetEvent</code> , aber der Unterschied sollte nicht gro√ü sein, weil  Threads sollten zuerst im Benutzermodus bleiben. </p><br><p>  Die Syntaxsperre h√§lt unangenehme √úberraschungen bereit.  Sie empfehlen die direkte Verwendung von <code>Monitor</code> [Richter] [Eric Lippert].  Eine davon ist, dass die <code>lock</code> <code>Monitor</code> immer beendet, auch wenn es eine Ausnahme gab, und dann kann ein anderer Thread den Status des gemeinsam genutzten Speichers √§ndern.  In solchen F√§llen ist es oft besser, zum Deadlock zu gehen oder das Programm irgendwie sicher abzuschlie√üen.  Eine weitere √úberraschung ist, dass Monitor Synchronisationsbl√∂cke ( <code>SyncBlock</code> ) verwendet, die sich in allen Objekten befinden.  Wenn Sie also das falsche Objekt ausw√§hlen, k√∂nnen Sie leicht einen Deadlock erhalten (z. B. wenn Sie die internierte Zeichenfolge sperren).  Wir verwenden daf√ºr immer ein verstecktes Objekt. </p><br><p>  Bedingungsvariables Muster erm√∂glicht es Ihnen, die Erwartung einer komplexen Bedingung pr√§ziser umzusetzen.  In .NET ist es meiner Meinung nach unvollst√§ndig, weil  Theoretisch sollte es mehrere Warteschlangen f√ºr mehrere Variablen geben (wie in Posix-Threads) und nicht f√ºr eine Sperre.  Dann k√∂nnte man sie f√ºr alle Philosophen machen.  Aber auch in dieser Form k√∂nnen Sie den Code reduzieren. </p><br><h3 id="mnogo-filosofov-ili-async--await">  Viele Philosophen oder <code>async</code> / <code>await</code> </h3><br><p>  Ok, jetzt k√∂nnen wir Threads effektiv blockieren.  Aber was ist, wenn wir viele Philosophen haben?  100?  10000?  Zum Beispiel haben wir 100.000 Anfragen an einen Webserver erhalten.  Das Erstellen eines Streams f√ºr jede Anforderung ist weil  So viele Threads werden nicht parallel ausgef√ºhrt.  Es werden nur so viele logische Kerne ausgef√ºhrt (ich habe 4).  Und alle anderen werden einfach Ressourcen in Anspruch nehmen.  Eine L√∂sung f√ºr dieses Problem ist das Async / Wait-Muster.  Die Idee ist, dass eine Funktion keinen Stream enth√§lt, wenn Sie warten m√ºssen, bis er fortgesetzt wird.  Und wenn sie dies tut, passiert etwas, sie setzt ihre Hinrichtung fort (aber nicht unbedingt im selben Thread!).  In unserem Fall warten wir auf den Stecker. </p><br><p>  <code>SemaphoreSlim</code> verf√ºgt <code>WaitAsync()</code> √ºber eine <code>WaitAsync()</code> -Methode.  Hier ist eine Implementierung mit diesem Muster. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  . -  : Task.Run(() =&gt; Run(i, cancelTokenSource.Token)); //  . //   async --      . public async Task Run(int i, CancellationToken token) { while (true) { // await --   - . await TakeForks(i); //  await,     . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); //      . await PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } async Task TakeForks(int i) { bool hasForks = false; while (!hasForks) { //    : await _tableSemaphore.WaitAsync(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) { forks[Left(i)] = i+1; forks[Right(i)] = i+1; hasForks = true; } _tableSemaphore.Release(); //  ,    : if (!hasForks) await _philosopherSemaphores[i].WaitAsync(); } } //       . async Task PutForks(int i) { await _tableSemaphore.WaitAsync(); forks[Left(i)] = 0; // "" ,   "". _philosopherSemaphores[LeftPhilosopher(i)].Release(); forks[Right(i)] = 0; _philosopherSemaphores[RightPhilosopher(i)].Release(); _tableSemaphore.Release(); }</span></span></code> </pre> <br><p>   <code>async</code> / <code>await</code>     ,      <code>Task</code> .      ,     ,     Task.  ,  ,  .   ,    ,   ,   ,   .         .      <code>async</code> / <code>await</code> . </p><br><p> .  100     4  , 8 .    Monitor   4  ,     .    4    2.    async / await   100,       6.8 . ,      6         .    Monitor    . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>      , .NET    .  , , ,   .     .    ,     ,   , TPL Dataflow, Reactive , Software Transaction   . </p><br><h2 id="istochniki">  Quellen </h2><br><ul><li>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Concurrency Visualizer</a> </li><li> MSDN: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Threading</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchronous programming patterns</a>  .  andere </li><li> [] ‚Äî CLR via C#, Jeffrey Richter </li><li> [ ] ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> lock</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li>  ‚Äî "  ", .  </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447898/">https://habr.com/ru/post/de447898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447886/index.html">Nginx-Protokollanalyse mit Amazon Athena und Cube.js</a></li>
<li><a href="../de447890/index.html">Gott sei Dank bin ich kein Manager</a></li>
<li><a href="../de447892/index.html">Zwei neue PHDays-Wettbewerbe: IDS-Bypass und Factory-Hacking</a></li>
<li><a href="../de447894/index.html">MODX Digest # 3 (25. M√§rz - 8. April 2019)</a></li>
<li><a href="../de447896/index.html">Bilder aus groben Skizzen: Genau so funktioniert das neuronale Netzwerk NVIDIA GauGAN</a></li>
<li><a href="../de447900/index.html">Schlie√üen Sie ADL-Kontakte</a></li>
<li><a href="../de447902/index.html">GitHub hat das Repository-Dienstprogramm-Repository und das gesamte Erstellerkonto vollst√§ndig "gel√∂scht"</a></li>
<li><a href="../de447904/index.html">Experten von Positive Technologies identifizieren Versuche, kritische Schwachstellen in Confluence massenhaft auszunutzen</a></li>
<li><a href="../de447906/index.html">Aktuelle Innovationen: Was erwartet Sie 2019 vom Rechenzentrumsmarkt?</a></li>
<li><a href="../de447908/index.html">Es sollten zwei M√∂glichkeiten funktionieren, Belohnungen f√ºr Werbung in Handyspielen oder Robotern zu sammeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>