<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüëß üë©üèø‚ÄçüöÄ üò∫ Wie wir Lambda-Ausdr√ºcke in IntelliJ IDEA finden ‚ôäÔ∏è üîö üëáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Codesuche und Navigation sind wichtige Merkmale jeder IDE. In Java ist eine der h√§ufig verwendeten Suchoptionen die Suche nach allen Implementierungen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir Lambda-Ausdr√ºcke in IntelliJ IDEA finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/"><p><img alt="Geben Sie Hierarchie in IntelliJ IDEA ein" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Codesuche und Navigation sind wichtige Merkmale jeder IDE.  In Java ist eine der h√§ufig verwendeten Suchoptionen die Suche nach allen Implementierungen einer Schnittstelle.  Diese Funktion wird h√§ufig als Typhierarchie bezeichnet und sieht genauso aus wie das Bild rechts. </p><br><p>  Es ist ineffizient, alle Projektklassen zu durchlaufen, wenn diese Funktion aufgerufen wird.  Eine M√∂glichkeit besteht darin, die gesamte Klassenhierarchie w√§hrend der Kompilierung im Index zu speichern, da der Compiler sie trotzdem erstellt.  Wir tun dies, wenn die Kompilierung von der IDE ausgef√ºhrt und beispielsweise nicht an Gradle delegiert wird.  Dies funktioniert jedoch nur, wenn nach der Kompilierung im Modul nichts ge√§ndert wurde.  Im Allgemeinen ist der Quellcode der aktuellste Informationsanbieter, und die Indizes basieren auf dem Quellcode. </p><br><p> Es ist eine einfache Aufgabe, unmittelbare Kinder zu finden, wenn es sich nicht um eine funktionale Schnittstelle handelt.  Bei der Suche nach Implementierungen der <code>Foo</code> Schnittstelle m√ºssen alle Klassen gefunden werden, die <code>implements Foo</code> haben <code>implements Foo</code> und Schnittstellen, die <code>extends Foo</code> , sowie <code>new Foo(...) {...}</code> anonyme <code>new Foo(...) {...}</code> -Klassen.  Dazu reicht es aus, im Voraus einen Syntaxbaum f√ºr jede Projektdatei zu erstellen, die entsprechenden Konstrukte zu finden und sie einem Index hinzuzuf√ºgen. <a name="habracut"></a>  Hier gibt es jedoch eine Schwierigkeit: M√∂glicherweise suchen Sie nach der Schnittstelle <code>com.example.goodcompany.Foo</code> , w√§hrend <code>org.example.evilcompany.Foo</code> tats√§chlich verwendet wird.  K√∂nnen wir den vollst√§ndigen Namen der √ºbergeordneten Schnittstelle im Voraus in den Index einf√ºgen?  Es kann schwierig sein.  Die Datei, in der die Schnittstelle verwendet wird, sieht beispielsweise folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Wenn Sie nur die Datei betrachten, ist es unm√∂glich zu sagen, wie der tats√§chliche vollqualifizierte Name von <code>Foo</code> lautet.  Wir m√ºssen uns den Inhalt mehrerer Pakete ansehen.  Und jedes Paket kann an mehreren Stellen im Projekt definiert werden (z. B. in mehreren JAR-Dateien).  Wenn wir bei der Analyse dieser Datei eine korrekte Symbolaufl√∂sung durchf√ºhren, nimmt die Indizierung viel Zeit in Anspruch.  Das Hauptproblem ist jedoch, dass der auf <code>MyFoo.java</code> Index auch von anderen Dateien abh√§ngt.  Wir k√∂nnen die Deklaration der <code>Foo</code> Schnittstelle beispielsweise vom Paket <code>org.example.foo</code> in das Paket <code>org.example.bar</code> , ohne etwas in der Datei <code>org.example.bar</code> zu √§ndern, aber der vollst√§ndig qualifizierte Name von <code>Foo</code> √§ndert sich. </p><br><p>  In IntelliJ IDEA h√§ngen Indizes nur vom Inhalt einer einzelnen Datei ab.  Einerseits ist es sehr praktisch: Der einer bestimmten Datei zugeordnete Index wird ung√ºltig, wenn die Datei ge√§ndert wird.  Auf der anderen Seite gibt es erhebliche Einschr√§nkungen f√ºr das, was in den Index aufgenommen werden kann.  Beispielsweise k√∂nnen die vollst√§ndig qualifizierten Namen der √ºbergeordneten Klassen nicht zuverl√§ssig im Index gespeichert werden.  Aber im Allgemeinen ist es nicht so schlimm.  Wenn wir eine Typhierarchie anfordern, k√∂nnen wir alles, was unserer Anfrage entspricht, durch einen Kurznamen finden und dann die richtige Symbolaufl√∂sung f√ºr diese Dateien durchf√ºhren und feststellen, ob dies das ist, wonach wir suchen.  In den meisten F√§llen gibt es nicht zu viele redundante Symbole und die √úberpr√ºfung dauert nicht lange. </p><br><p><img alt="Hierarchie der funktionalen Schnittstelle in IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Die Dinge √§ndern sich jedoch, wenn die Klasse, deren Kinder wir suchen, eine funktionale Schnittstelle ist.  Zus√§tzlich zu den expliziten und anonymen Unterklassen gibt es dann Lambda-Ausdr√ºcke und Methodenreferenzen.  Was setzen wir jetzt in den Index ein und was soll bei der Suche ausgewertet werden? </p><br><p>  Nehmen wir an, wir haben eine funktionale Schnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Der Code enth√§lt verschiedene Lambda-Ausdr√ºcke.  Zum Beispiel: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p>  Dies bedeutet, dass wir Lambdas schnell herausfiltern k√∂nnen, die eine unangemessene Anzahl von Parametern oder einen eindeutig unangemessenen R√ºckgabetyp haben, z. B. void statt non void.  Es ist normalerweise unm√∂glich, den R√ºckgabetyp genauer zu bestimmen.  In <code>s -&gt; list.add(s)</code> Sie beispielsweise <code>list</code> aufl√∂sen und <code>add</code> und m√∂glicherweise eine regul√§re Typinferenzprozedur ausf√ºhren.  Es braucht Zeit und h√§ngt vom Inhalt anderer Dateien ab. </p><br><p>  Wir haben Gl√ºck, wenn die Funktionsschnittstelle f√ºnf Argumente enth√§lt.  Wenn jedoch nur einer ben√∂tigt wird, h√§lt der Filter eine gro√üe Anzahl unn√∂tiger Lambdas.  Es ist noch schlimmer, wenn es um Methodenreferenzen geht.  √úbrigens kann man nicht sagen, ob eine Methodenreferenz geeignet ist oder nicht. </p><br><p>  Um die Dinge klar zu machen, k√∂nnte es sich lohnen, einen Blick auf die Umgebung des Lambda zu werfen.  Manchmal funktioniert es.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  In all diesen F√§llen kann der Kurzname der entsprechenden Funktionsschnittstelle aus der aktuellen Datei ermittelt und in den Index neben dem Funktionsausdruck eingef√ºgt werden, sei es ein Lambda oder eine Methodenreferenz.  Leider decken diese F√§lle in realen Projekten einen sehr kleinen Prozentsatz aller Lambdas ab.  In den meisten F√§llen werden Lambdas als Methodenargumente verwendet: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Welches der drei Lambdas kann <code>StringConsumer</code> enthalten?  Offensichtlich keine.  Hier haben wir eine Stream-API-Kette, die nur funktionale Schnittstellen aus der Standardbibliothek enth√§lt und keinen benutzerdefinierten Typ haben kann. </p><br><p>  Die IDE sollte jedoch in der Lage sein, den Trick zu durchschauen und uns eine genaue Antwort zu geben.  Was ist, wenn <code>list</code> nicht genau <code>java.util.List</code> ist und <code>list.stream()</code> etwas anderes als <code>java.util.stream.Stream</code> zur√ºckgibt?  Dann m√ºssen wir die <code>list</code> aufl√∂sen, was bekanntlich nicht nur auf der Grundlage des Inhalts der aktuellen Datei zuverl√§ssig durchgef√ºhrt werden kann.  Und selbst wenn wir dies tun, sollte die Suche nicht auf der Implementierung der Standardbibliothek beruhen.  Was ist, wenn wir in diesem speziellen Projekt <code>java.util.List</code> durch eine eigene Klasse ersetzt haben?  Die Suche muss dies ber√ºcksichtigen.  Und nat√ºrlich werden Lambdas nicht nur in Standardstr√∂men verwendet: Es gibt viele andere Methoden, an die sie √ºbergeben werden. </p><br><p>  Infolgedessen k√∂nnen wir den Index nach einer Liste aller Java-Dateien abfragen, die Lambdas mit der erforderlichen Anzahl von Parametern und einem g√ºltigen R√ºckgabetyp verwenden (tats√§chlich suchen wir nur nach vier Optionen: void, non-void, boolean und beliebig).  Und was kommt als n√§chstes?  M√ºssen wir f√ºr jede dieser Dateien einen vollst√§ndigen PSI-Baum (eine Art Analysebaum mit Symbolaufl√∂sung, Typinferenz und anderen intelligenten Funktionen) erstellen und eine korrekte Typinferenz f√ºr Lambdas durchf√ºhren?  Bei einem gro√üen Projekt wird es ewig dauern, bis die Liste aller Schnittstellenimplementierungen angezeigt wird, auch wenn es nur zwei davon gibt. </p><br><p>  Wir m√ºssen also die folgenden Schritte ausf√ºhren: </p><br><ul><li>  Fragen Sie den Index (nicht teuer) </li><li>  PSI erstellen (teuer) </li><li>  Infer Lambda-Typ (sehr teuer) </li></ul><br><p>  F√ºr Java 8 und h√∂her ist die Typinferenz eine √§u√üerst kostspielige Operation.  In einer komplexen Aufrufkette kann es viele generische Substitutionsparameter geben, deren Werte mithilfe des in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 18</a> der Spezifikation beschriebenen Hard-Hitting-Verfahrens ermittelt werden m√ºssen.  F√ºr die aktuelle Datei kann dies im Hintergrund erfolgen, aber die Verarbeitung von Tausenden unge√∂ffneten Dateien auf diese Weise w√§re eine teure Aufgabe. </p><br><p>  Hier ist es jedoch m√∂glich, Ecken leicht zu schneiden: In den meisten F√§llen ben√∂tigen wir den Betontyp nicht.  Sofern eine Methode keinen generischen Parameter akzeptiert, an den das Lambda √ºbergeben wird, kann der letzte Schritt der Parametersubstitution vermieden werden.  Wenn wir auf den Lambda-Typ <code>java.util.function.Function&lt;T, R&gt;</code> , m√ºssen wir die Werte der Substitutionsparameter <code>T</code> und <code>R</code> nicht auswerten: Es ist bereits klar, ob das Lambda in die Suchergebnisse aufgenommen werden soll oder nicht.  Bei einer Methode wie dieser funktioniert dies jedoch nicht: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Diese Methode kann mit <code>doSmth(Runnable.class, () -&gt; {})</code> aufgerufen werden.  Dann wird der Lambda-Typ als <code>T</code> , eine Substitution ist noch erforderlich.  Dies ist jedoch ein seltener Fall.  Wir k√∂nnen hier tats√§chlich etwas CPU-Zeit sparen, aber nur etwa 10%, so dass das Problem im Wesentlichen nicht gel√∂st wird. </p><br><p>  Wenn die genaue Typinferenz zu kompliziert ist, kann sie alternativ angen√§hert werden.  Lassen Sie es anders als in der Spezifikation vorgeschlagen nur f√ºr die gel√∂schten Klassentypen funktionieren und reduzieren Sie die Einschr√§nkungen nicht, sondern folgen Sie einfach einer Aufrufkette.  Solange der gel√∂schte Typ keine generischen Parameter enth√§lt, ist alles in Ordnung.  Betrachten wir den Stream aus dem obigen Beispiel und bestimmen Sie, ob das letzte Lambda <code>StringConsumer</code> implementiert: </p><br><ul><li>  Listenvariable -&gt; Typ <code>java.util.List</code> </li><li>  <code>List.stream()</code> -Methode ‚Üí Typ <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -Methode -&gt; Typ <code>java.util.stream.Stream</code> , <code>filter</code> m√ºssen nicht ber√ºcksichtigt <code>filter</code> </li><li>  In √§hnlicher Weise ist die <code>Stream.map(...)</code> -Methode ‚Üí <code>java.util.stream.Stream</code> Typ </li><li>  <code>Stream.forEach(...)</code> -Methode ‚Üí Eine solche Methode existiert, ihr Parameter hat den <code>Consumer</code> Typ, der offensichtlich nicht <code>StringConsumer</code> . </li></ul><br><p>  Und so k√∂nnten wir ohne regul√§re Typinferenz auskommen.  Mit diesem einfachen Ansatz ist es jedoch leicht, auf √ºberladene Methoden zu sto√üen.  Wenn wir keine ordnungsgem√§√üe Typinferenz durchf√ºhren, k√∂nnen wir nicht die richtige √ºberladene Methode ausw√§hlen.  Manchmal ist es jedoch m√∂glich: Wenn Methoden eine andere Anzahl von Parametern haben.  Zum Beispiel: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Hier k√∂nnen wir das sehen: </p><br><ul><li>  Es gibt zwei <code>CompletableFuture.supplyAsync</code> Methoden.  Der erste nimmt ein Argument und der zweite zwei, also w√§hlen wir den zweiten.  Es gibt <code>CompletableFuture</code> . </li><li>  Es gibt auch zwei <code>thenRunAsync</code> Methoden, und wir k√∂nnen auf √§hnliche Weise die ausw√§hlen, die ein Argument <code>thenRunAsync</code> .  Der entsprechende Parameter hat <code>Runnable</code> Typ <code>Runnable</code> , <code>Runnable</code> er ist kein <code>StringConsumer</code> . </li></ul><br><p>  Wenn mehrere Methoden dieselbe Anzahl von Parametern verwenden oder eine variable Anzahl von Parametern haben, aber angemessen aussehen, m√ºssen wir alle Optionen durchsuchen.  Oft ist es nicht so be√§ngstigend: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> erstellt offensichtlich <code>java.lang.StringBuilder</code> .  F√ºr Konstruktoren l√∂sen wir die Referenz weiterhin auf, aber eine komplexe Typinferenz ist hier nicht erforderlich.  Selbst wenn es <code>new Foo&lt;&gt;(x, y, z)</code> g√§be, w√ºrden wir die Werte der Typparameter nicht ableiten, da nur <code>Foo</code> f√ºr uns von Interesse ist. </li><li>  Es gibt viele <code>StringBuilder.append</code> Methoden, die ein Argument annehmen, aber alle geben den Typ <code>java.lang.StringBuilder</code> , sodass uns die Typen <code>foo</code> und <code>bar</code> egal sind. </li><li>  Es gibt eine <code>StringBuilder.chars</code> Methode, die <code>java.util.stream.IntStream</code> zur√ºckgibt. </li><li>  Es gibt eine einzige <code>IntStream.forEach</code> Methode, die <code>IntConsumer</code> Typ <code>IntConsumer</code> . </li></ul><br><p>  Auch wenn noch mehrere Optionen verf√ºgbar sind, k√∂nnen Sie alle verfolgen.  Beispielsweise kann der an <code>ForkJoinPool.getInstance().submit(...)</code> Lambda-Typ <code>ForkJoinPool.getInstance().submit(...)</code> <code>Runnable</code> oder <code>Callable</code> . Wenn wir nach einer anderen Option suchen, k√∂nnen wir dieses Lambda dennoch verwerfen. </p><br><p>  Es wird schlimmer, wenn die Methode einen generischen Parameter zur√ºckgibt.  Dann schl√§gt die Prozedur fehl und Sie m√ºssen eine ordnungsgem√§√üe Typinferenz durchf√ºhren.  Wir haben jedoch einen Fall unterst√ºtzt.  Es ist in meiner StreamEx-Bibliothek gut dargestellt, die eine <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> Extraktionsklasse <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> enth√§lt, die Methoden wie den <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Normalerweise arbeiten Leute mit einer konkreten <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> -Klasse.  In diesem Fall k√∂nnen Sie den Typparameter ersetzen und feststellen, dass <code>S = StreamEx</code> . </p><br><p>  Auf diese Weise haben wir in vielen F√§llen die kostspielige Typinferenz beseitigt.  Aber wir haben nichts mit dem Aufbau von PSI gemacht.  Es ist entt√§uschend, eine Datei mit 500 Codezeilen analysiert zu haben, um festzustellen, dass das Lambda in Zeile 480 nicht mit unserer Abfrage √ºbereinstimmt.  Kommen wir zur√ºck zu unserem Stream: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Wenn <code>list</code> eine lokale Variable, ein Methodenparameter oder ein Feld in der aktuellen Klasse ist, die sich bereits in der Indizierungsphase befindet, k√∂nnen wir ihre Deklaration finden und feststellen, dass der Kurztypname <code>List</code> .  Dementsprechend k√∂nnen wir die folgenden Informationen in den Index f√ºr das letzte Lambda aufnehmen: </p><br><blockquote>  Dieser Lambda-Typ ist ein Parametertyp einer <code>forEach</code> Methode, die ein Argument verwendet, das f√ºr das Ergebnis einer <code>map</code> Methode aufgerufen wird, die ein Argument verwendet, und das Ergebnis einer <code>filter</code> , die ein Argument verwendet, das f√ºr das Ergebnis einer <code>stream</code> Methode aufgerufen wird Dies erfordert keine Argumente, die f√ºr ein <code>List</code> Objekt aufgerufen werden. </blockquote><p>  Alle diese Informationen sind aus der aktuellen Datei verf√ºgbar und k√∂nnen daher in den Index aufgenommen werden.  W√§hrend der Suche fordern wir solche Informationen zu allen Lambdas aus dem Index an und versuchen, den Lambda-Typ wiederherzustellen, ohne einen PSI zu erstellen.  Zuerst m√ºssen wir eine globale Suche nach Klassen mit dem kurzen <code>List</code> .  Offensichtlich finden wir nicht nur <code>java.util.List</code> sondern auch <code>java.awt.List</code> oder etwas aus dem Projektcode.  Als n√§chstes durchlaufen alle diese Klassen das gleiche ungef√§hre Typinferenzverfahren, das wir zuvor verwendet haben.  Redundante Klassen werden oft schnell herausgefiltert.  Zum Beispiel hat <code>java.awt.List</code> keine <code>stream</code> Methode, daher wird sie ausgeschlossen.  Aber selbst wenn etwas Redundantes √ºbrig bleibt und wir mehrere Kandidaten f√ºr den Lambda-Typ finden, ist es wahrscheinlich, dass keiner von ihnen mit der Suchabfrage √ºbereinstimmt, und wir werden dennoch vermeiden, ein vollst√§ndiges PSI zu erstellen. </p><br><p>  Die globale Suche kann sich als zu kostspielig herausstellen (wenn ein Projekt zu viele <code>List</code> enth√§lt), oder der Anfang der Kette kann nicht im Kontext einer Datei (z. B. eines Felds einer √ºbergeordneten Klasse) oder der Datei aufgel√∂st werden Kette k√∂nnte brechen, wenn die Methode einen generischen Parameter zur√ºckgibt.  Wir werden nicht aufgeben und versuchen, mit der globalen Suche nach der n√§chsten Methode der Kette von vorne zu beginnen.  F√ºr die <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> geht die folgende Anweisung zum Index: </p><br><blockquote>  Dieser Lambda-Typ ist der Typ des einzelnen Parameters einer <code>updateAndGet</code> Methode, der als Ergebnis einer <code>get</code> Methode mit einem Parameter aufgerufen wird, der f√ºr ein <code>Map</code> Objekt aufgerufen wird. </blockquote><p>  Stellen Sie sich vor, wir haben Gl√ºck und das Projekt hat nur einen Kartentyp - <code>java.util.Map</code> .  Es hat zwar eine <code>get(Object)</code> -Methode, gibt aber leider einen generischen Parameter <code>V</code>  Dann verwerfen wir die Kette und suchen global nach der <code>updateAndGet</code> Methode mit einem Parameter (nat√ºrlich unter Verwendung des Index).  Wir freuen uns, dass das Projekt nur drei solcher Methoden enth√§lt: in den Klassen <code>AtomicInteger</code> , <code>AtomicLong</code> und <code>AtomicReference</code> mit den Parametertypen <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> bzw. <code>UnaryOperator</code> .  Wenn wir nach einem anderen Typ suchen, haben wir bereits festgestellt, dass dieses Lambda nicht mit der Anforderung √ºbereinstimmt, und wir m√ºssen den PSI nicht erstellen. </p><br><p>  √úberraschenderweise ist dies ein gutes Beispiel f√ºr eine Funktion, die mit der Zeit langsamer arbeitet.  Wenn Sie beispielsweise nach Implementierungen einer funktionalen Schnittstelle suchen und nur drei davon in Ihrem Projekt haben, dauert es zehn Sekunden, bis IntelliJ IDEA sie findet.  Sie erinnern sich, dass ihre Nummer vor drei Jahren dieselbe war, aber die IDE lieferte Ihnen die Suchergebnisse in nur zwei Sekunden auf demselben Computer.  Und obwohl Ihr Projekt riesig ist, ist es in diesen Jahren nur um f√ºnf Prozent gewachsen.  Es ist vern√ºnftig, dar√ºber zu meckern, was die IDE-Entwickler falsch gemacht haben, um es so schrecklich langsam zu machen. </p><br><p>  W√§hrend wir vielleicht gar nichts ge√§ndert haben.  Die Suche funktioniert genauso wie vor drei Jahren.  Die Sache ist, dass Sie vor drei Jahren gerade auf Java 8 umgestiegen sind und nur hundert Lambdas in Ihrem Projekt hatten.  Inzwischen haben Ihre Kollegen anonyme Klassen in Lambdas verwandelt, Streams oder eine reaktive Bibliothek verwendet.  Infolgedessen gibt es anstelle von hundert Lambdas zehntausend.  Und jetzt muss die IDE hundertmal mehr Optionen durchsuchen, um die drei erforderlichen zu finden. </p><br><p>  Ich sagte "wir k√∂nnten", weil wir nat√ºrlich von Zeit zu Zeit zu dieser Suche zur√ºckkehren und versuchen, sie zu beschleunigen.  Aber es ist, als w√ºrde man den Bach oder besser den Wasserfall hinauf rudern.  Wir bem√ºhen uns sehr, aber die Anzahl der Lambdas in Projekten w√§chst sehr schnell. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451754/">https://habr.com/ru/post/de451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451742/index.html">Einen Tag vor DotNext 2019 Piter. Kostenlose Broadcast-Ank√ºndigung</a></li>
<li><a href="../de451746/index.html">MegaSlerm f√ºr Ingenieure und Architekten Kubernetes</a></li>
<li><a href="../de451748/index.html">√úberwachen des SSD-Status in Qsan-Arrays</a></li>
<li><a href="../de451750/index.html">Buch "Elasticsearch, Kibana, Logstash und Suchmaschinen der n√§chsten Generation"</a></li>
<li><a href="../de451752/index.html">30. Jahrestag der grassierenden Unsicherheit</a></li>
<li><a href="../de451758/index.html">Zus√§tzliche Uplinks in der Intel C620-Systemlogikarchitektur</a></li>
<li><a href="../de451760/index.html">Mit Golang Microservices in The Economist erstellen: Eine Retrospektive</a></li>
<li><a href="../de451766/index.html">Heisenbug 2019 Piter: Was wird in der kostenlosen Sendung passieren und was nur auf der Veranstaltung</a></li>
<li><a href="../de451768/index.html">Verbesserung der Arbeit von Wi-Fi. Allgemeine Grunds√§tze und n√ºtzliche Dinge</a></li>
<li><a href="../de451770/index.html">Veeam Backup & Replication: N√ºtzliche Tipps, um Backups und Replikate funktionsf√§hig zu machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>