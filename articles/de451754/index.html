<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 👩🏿‍🚀 😺 Wie wir Lambda-Ausdrücke in IntelliJ IDEA finden ♊️ 🔚 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Codesuche und Navigation sind wichtige Merkmale jeder IDE. In Java ist eine der häufig verwendeten Suchoptionen die Suche nach allen Implementierungen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir Lambda-Ausdrücke in IntelliJ IDEA finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/"><p><img alt="Geben Sie Hierarchie in IntelliJ IDEA ein" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Codesuche und Navigation sind wichtige Merkmale jeder IDE.  In Java ist eine der häufig verwendeten Suchoptionen die Suche nach allen Implementierungen einer Schnittstelle.  Diese Funktion wird häufig als Typhierarchie bezeichnet und sieht genauso aus wie das Bild rechts. </p><br><p>  Es ist ineffizient, alle Projektklassen zu durchlaufen, wenn diese Funktion aufgerufen wird.  Eine Möglichkeit besteht darin, die gesamte Klassenhierarchie während der Kompilierung im Index zu speichern, da der Compiler sie trotzdem erstellt.  Wir tun dies, wenn die Kompilierung von der IDE ausgeführt und beispielsweise nicht an Gradle delegiert wird.  Dies funktioniert jedoch nur, wenn nach der Kompilierung im Modul nichts geändert wurde.  Im Allgemeinen ist der Quellcode der aktuellste Informationsanbieter, und die Indizes basieren auf dem Quellcode. </p><br><p> Es ist eine einfache Aufgabe, unmittelbare Kinder zu finden, wenn es sich nicht um eine funktionale Schnittstelle handelt.  Bei der Suche nach Implementierungen der <code>Foo</code> Schnittstelle müssen alle Klassen gefunden werden, die <code>implements Foo</code> haben <code>implements Foo</code> und Schnittstellen, die <code>extends Foo</code> , sowie <code>new Foo(...) {...}</code> anonyme <code>new Foo(...) {...}</code> -Klassen.  Dazu reicht es aus, im Voraus einen Syntaxbaum für jede Projektdatei zu erstellen, die entsprechenden Konstrukte zu finden und sie einem Index hinzuzufügen. <a name="habracut"></a>  Hier gibt es jedoch eine Schwierigkeit: Möglicherweise suchen Sie nach der Schnittstelle <code>com.example.goodcompany.Foo</code> , während <code>org.example.evilcompany.Foo</code> tatsächlich verwendet wird.  Können wir den vollständigen Namen der übergeordneten Schnittstelle im Voraus in den Index einfügen?  Es kann schwierig sein.  Die Datei, in der die Schnittstelle verwendet wird, sieht beispielsweise folgendermaßen aus: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Wenn Sie nur die Datei betrachten, ist es unmöglich zu sagen, wie der tatsächliche vollqualifizierte Name von <code>Foo</code> lautet.  Wir müssen uns den Inhalt mehrerer Pakete ansehen.  Und jedes Paket kann an mehreren Stellen im Projekt definiert werden (z. B. in mehreren JAR-Dateien).  Wenn wir bei der Analyse dieser Datei eine korrekte Symbolauflösung durchführen, nimmt die Indizierung viel Zeit in Anspruch.  Das Hauptproblem ist jedoch, dass der auf <code>MyFoo.java</code> Index auch von anderen Dateien abhängt.  Wir können die Deklaration der <code>Foo</code> Schnittstelle beispielsweise vom Paket <code>org.example.foo</code> in das Paket <code>org.example.bar</code> , ohne etwas in der Datei <code>org.example.bar</code> zu ändern, aber der vollständig qualifizierte Name von <code>Foo</code> ändert sich. </p><br><p>  In IntelliJ IDEA hängen Indizes nur vom Inhalt einer einzelnen Datei ab.  Einerseits ist es sehr praktisch: Der einer bestimmten Datei zugeordnete Index wird ungültig, wenn die Datei geändert wird.  Auf der anderen Seite gibt es erhebliche Einschränkungen für das, was in den Index aufgenommen werden kann.  Beispielsweise können die vollständig qualifizierten Namen der übergeordneten Klassen nicht zuverlässig im Index gespeichert werden.  Aber im Allgemeinen ist es nicht so schlimm.  Wenn wir eine Typhierarchie anfordern, können wir alles, was unserer Anfrage entspricht, durch einen Kurznamen finden und dann die richtige Symbolauflösung für diese Dateien durchführen und feststellen, ob dies das ist, wonach wir suchen.  In den meisten Fällen gibt es nicht zu viele redundante Symbole und die Überprüfung dauert nicht lange. </p><br><p><img alt="Hierarchie der funktionalen Schnittstelle in IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Die Dinge ändern sich jedoch, wenn die Klasse, deren Kinder wir suchen, eine funktionale Schnittstelle ist.  Zusätzlich zu den expliziten und anonymen Unterklassen gibt es dann Lambda-Ausdrücke und Methodenreferenzen.  Was setzen wir jetzt in den Index ein und was soll bei der Suche ausgewertet werden? </p><br><p>  Nehmen wir an, wir haben eine funktionale Schnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Der Code enthält verschiedene Lambda-Ausdrücke.  Zum Beispiel: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p>  Dies bedeutet, dass wir Lambdas schnell herausfiltern können, die eine unangemessene Anzahl von Parametern oder einen eindeutig unangemessenen Rückgabetyp haben, z. B. void statt non void.  Es ist normalerweise unmöglich, den Rückgabetyp genauer zu bestimmen.  In <code>s -&gt; list.add(s)</code> Sie beispielsweise <code>list</code> auflösen und <code>add</code> und möglicherweise eine reguläre Typinferenzprozedur ausführen.  Es braucht Zeit und hängt vom Inhalt anderer Dateien ab. </p><br><p>  Wir haben Glück, wenn die Funktionsschnittstelle fünf Argumente enthält.  Wenn jedoch nur einer benötigt wird, hält der Filter eine große Anzahl unnötiger Lambdas.  Es ist noch schlimmer, wenn es um Methodenreferenzen geht.  Übrigens kann man nicht sagen, ob eine Methodenreferenz geeignet ist oder nicht. </p><br><p>  Um die Dinge klar zu machen, könnte es sich lohnen, einen Blick auf die Umgebung des Lambda zu werfen.  Manchmal funktioniert es.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  In all diesen Fällen kann der Kurzname der entsprechenden Funktionsschnittstelle aus der aktuellen Datei ermittelt und in den Index neben dem Funktionsausdruck eingefügt werden, sei es ein Lambda oder eine Methodenreferenz.  Leider decken diese Fälle in realen Projekten einen sehr kleinen Prozentsatz aller Lambdas ab.  In den meisten Fällen werden Lambdas als Methodenargumente verwendet: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Welches der drei Lambdas kann <code>StringConsumer</code> enthalten?  Offensichtlich keine.  Hier haben wir eine Stream-API-Kette, die nur funktionale Schnittstellen aus der Standardbibliothek enthält und keinen benutzerdefinierten Typ haben kann. </p><br><p>  Die IDE sollte jedoch in der Lage sein, den Trick zu durchschauen und uns eine genaue Antwort zu geben.  Was ist, wenn <code>list</code> nicht genau <code>java.util.List</code> ist und <code>list.stream()</code> etwas anderes als <code>java.util.stream.Stream</code> zurückgibt?  Dann müssen wir die <code>list</code> auflösen, was bekanntlich nicht nur auf der Grundlage des Inhalts der aktuellen Datei zuverlässig durchgeführt werden kann.  Und selbst wenn wir dies tun, sollte die Suche nicht auf der Implementierung der Standardbibliothek beruhen.  Was ist, wenn wir in diesem speziellen Projekt <code>java.util.List</code> durch eine eigene Klasse ersetzt haben?  Die Suche muss dies berücksichtigen.  Und natürlich werden Lambdas nicht nur in Standardströmen verwendet: Es gibt viele andere Methoden, an die sie übergeben werden. </p><br><p>  Infolgedessen können wir den Index nach einer Liste aller Java-Dateien abfragen, die Lambdas mit der erforderlichen Anzahl von Parametern und einem gültigen Rückgabetyp verwenden (tatsächlich suchen wir nur nach vier Optionen: void, non-void, boolean und beliebig).  Und was kommt als nächstes?  Müssen wir für jede dieser Dateien einen vollständigen PSI-Baum (eine Art Analysebaum mit Symbolauflösung, Typinferenz und anderen intelligenten Funktionen) erstellen und eine korrekte Typinferenz für Lambdas durchführen?  Bei einem großen Projekt wird es ewig dauern, bis die Liste aller Schnittstellenimplementierungen angezeigt wird, auch wenn es nur zwei davon gibt. </p><br><p>  Wir müssen also die folgenden Schritte ausführen: </p><br><ul><li>  Fragen Sie den Index (nicht teuer) </li><li>  PSI erstellen (teuer) </li><li>  Infer Lambda-Typ (sehr teuer) </li></ul><br><p>  Für Java 8 und höher ist die Typinferenz eine äußerst kostspielige Operation.  In einer komplexen Aufrufkette kann es viele generische Substitutionsparameter geben, deren Werte mithilfe des in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 18</a> der Spezifikation beschriebenen Hard-Hitting-Verfahrens ermittelt werden müssen.  Für die aktuelle Datei kann dies im Hintergrund erfolgen, aber die Verarbeitung von Tausenden ungeöffneten Dateien auf diese Weise wäre eine teure Aufgabe. </p><br><p>  Hier ist es jedoch möglich, Ecken leicht zu schneiden: In den meisten Fällen benötigen wir den Betontyp nicht.  Sofern eine Methode keinen generischen Parameter akzeptiert, an den das Lambda übergeben wird, kann der letzte Schritt der Parametersubstitution vermieden werden.  Wenn wir auf den Lambda-Typ <code>java.util.function.Function&lt;T, R&gt;</code> , müssen wir die Werte der Substitutionsparameter <code>T</code> und <code>R</code> nicht auswerten: Es ist bereits klar, ob das Lambda in die Suchergebnisse aufgenommen werden soll oder nicht.  Bei einer Methode wie dieser funktioniert dies jedoch nicht: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Diese Methode kann mit <code>doSmth(Runnable.class, () -&gt; {})</code> aufgerufen werden.  Dann wird der Lambda-Typ als <code>T</code> , eine Substitution ist noch erforderlich.  Dies ist jedoch ein seltener Fall.  Wir können hier tatsächlich etwas CPU-Zeit sparen, aber nur etwa 10%, so dass das Problem im Wesentlichen nicht gelöst wird. </p><br><p>  Wenn die genaue Typinferenz zu kompliziert ist, kann sie alternativ angenähert werden.  Lassen Sie es anders als in der Spezifikation vorgeschlagen nur für die gelöschten Klassentypen funktionieren und reduzieren Sie die Einschränkungen nicht, sondern folgen Sie einfach einer Aufrufkette.  Solange der gelöschte Typ keine generischen Parameter enthält, ist alles in Ordnung.  Betrachten wir den Stream aus dem obigen Beispiel und bestimmen Sie, ob das letzte Lambda <code>StringConsumer</code> implementiert: </p><br><ul><li>  Listenvariable -&gt; Typ <code>java.util.List</code> </li><li>  <code>List.stream()</code> -Methode → Typ <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -Methode -&gt; Typ <code>java.util.stream.Stream</code> , <code>filter</code> müssen nicht berücksichtigt <code>filter</code> </li><li>  In ähnlicher Weise ist die <code>Stream.map(...)</code> -Methode → <code>java.util.stream.Stream</code> Typ </li><li>  <code>Stream.forEach(...)</code> -Methode → Eine solche Methode existiert, ihr Parameter hat den <code>Consumer</code> Typ, der offensichtlich nicht <code>StringConsumer</code> . </li></ul><br><p>  Und so könnten wir ohne reguläre Typinferenz auskommen.  Mit diesem einfachen Ansatz ist es jedoch leicht, auf überladene Methoden zu stoßen.  Wenn wir keine ordnungsgemäße Typinferenz durchführen, können wir nicht die richtige überladene Methode auswählen.  Manchmal ist es jedoch möglich: Wenn Methoden eine andere Anzahl von Parametern haben.  Zum Beispiel: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Hier können wir das sehen: </p><br><ul><li>  Es gibt zwei <code>CompletableFuture.supplyAsync</code> Methoden.  Der erste nimmt ein Argument und der zweite zwei, also wählen wir den zweiten.  Es gibt <code>CompletableFuture</code> . </li><li>  Es gibt auch zwei <code>thenRunAsync</code> Methoden, und wir können auf ähnliche Weise die auswählen, die ein Argument <code>thenRunAsync</code> .  Der entsprechende Parameter hat <code>Runnable</code> Typ <code>Runnable</code> , <code>Runnable</code> er ist kein <code>StringConsumer</code> . </li></ul><br><p>  Wenn mehrere Methoden dieselbe Anzahl von Parametern verwenden oder eine variable Anzahl von Parametern haben, aber angemessen aussehen, müssen wir alle Optionen durchsuchen.  Oft ist es nicht so beängstigend: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> erstellt offensichtlich <code>java.lang.StringBuilder</code> .  Für Konstruktoren lösen wir die Referenz weiterhin auf, aber eine komplexe Typinferenz ist hier nicht erforderlich.  Selbst wenn es <code>new Foo&lt;&gt;(x, y, z)</code> gäbe, würden wir die Werte der Typparameter nicht ableiten, da nur <code>Foo</code> für uns von Interesse ist. </li><li>  Es gibt viele <code>StringBuilder.append</code> Methoden, die ein Argument annehmen, aber alle geben den Typ <code>java.lang.StringBuilder</code> , sodass uns die Typen <code>foo</code> und <code>bar</code> egal sind. </li><li>  Es gibt eine <code>StringBuilder.chars</code> Methode, die <code>java.util.stream.IntStream</code> zurückgibt. </li><li>  Es gibt eine einzige <code>IntStream.forEach</code> Methode, die <code>IntConsumer</code> Typ <code>IntConsumer</code> . </li></ul><br><p>  Auch wenn noch mehrere Optionen verfügbar sind, können Sie alle verfolgen.  Beispielsweise kann der an <code>ForkJoinPool.getInstance().submit(...)</code> Lambda-Typ <code>ForkJoinPool.getInstance().submit(...)</code> <code>Runnable</code> oder <code>Callable</code> . Wenn wir nach einer anderen Option suchen, können wir dieses Lambda dennoch verwerfen. </p><br><p>  Es wird schlimmer, wenn die Methode einen generischen Parameter zurückgibt.  Dann schlägt die Prozedur fehl und Sie müssen eine ordnungsgemäße Typinferenz durchführen.  Wir haben jedoch einen Fall unterstützt.  Es ist in meiner StreamEx-Bibliothek gut dargestellt, die eine <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> Extraktionsklasse <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> enthält, die Methoden wie den <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Normalerweise arbeiten Leute mit einer konkreten <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> -Klasse.  In diesem Fall können Sie den Typparameter ersetzen und feststellen, dass <code>S = StreamEx</code> . </p><br><p>  Auf diese Weise haben wir in vielen Fällen die kostspielige Typinferenz beseitigt.  Aber wir haben nichts mit dem Aufbau von PSI gemacht.  Es ist enttäuschend, eine Datei mit 500 Codezeilen analysiert zu haben, um festzustellen, dass das Lambda in Zeile 480 nicht mit unserer Abfrage übereinstimmt.  Kommen wir zurück zu unserem Stream: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Wenn <code>list</code> eine lokale Variable, ein Methodenparameter oder ein Feld in der aktuellen Klasse ist, die sich bereits in der Indizierungsphase befindet, können wir ihre Deklaration finden und feststellen, dass der Kurztypname <code>List</code> .  Dementsprechend können wir die folgenden Informationen in den Index für das letzte Lambda aufnehmen: </p><br><blockquote>  Dieser Lambda-Typ ist ein Parametertyp einer <code>forEach</code> Methode, die ein Argument verwendet, das für das Ergebnis einer <code>map</code> Methode aufgerufen wird, die ein Argument verwendet, und das Ergebnis einer <code>filter</code> , die ein Argument verwendet, das für das Ergebnis einer <code>stream</code> Methode aufgerufen wird Dies erfordert keine Argumente, die für ein <code>List</code> Objekt aufgerufen werden. </blockquote><p>  Alle diese Informationen sind aus der aktuellen Datei verfügbar und können daher in den Index aufgenommen werden.  Während der Suche fordern wir solche Informationen zu allen Lambdas aus dem Index an und versuchen, den Lambda-Typ wiederherzustellen, ohne einen PSI zu erstellen.  Zuerst müssen wir eine globale Suche nach Klassen mit dem kurzen <code>List</code> .  Offensichtlich finden wir nicht nur <code>java.util.List</code> sondern auch <code>java.awt.List</code> oder etwas aus dem Projektcode.  Als nächstes durchlaufen alle diese Klassen das gleiche ungefähre Typinferenzverfahren, das wir zuvor verwendet haben.  Redundante Klassen werden oft schnell herausgefiltert.  Zum Beispiel hat <code>java.awt.List</code> keine <code>stream</code> Methode, daher wird sie ausgeschlossen.  Aber selbst wenn etwas Redundantes übrig bleibt und wir mehrere Kandidaten für den Lambda-Typ finden, ist es wahrscheinlich, dass keiner von ihnen mit der Suchabfrage übereinstimmt, und wir werden dennoch vermeiden, ein vollständiges PSI zu erstellen. </p><br><p>  Die globale Suche kann sich als zu kostspielig herausstellen (wenn ein Projekt zu viele <code>List</code> enthält), oder der Anfang der Kette kann nicht im Kontext einer Datei (z. B. eines Felds einer übergeordneten Klasse) oder der Datei aufgelöst werden Kette könnte brechen, wenn die Methode einen generischen Parameter zurückgibt.  Wir werden nicht aufgeben und versuchen, mit der globalen Suche nach der nächsten Methode der Kette von vorne zu beginnen.  Für die <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> geht die folgende Anweisung zum Index: </p><br><blockquote>  Dieser Lambda-Typ ist der Typ des einzelnen Parameters einer <code>updateAndGet</code> Methode, der als Ergebnis einer <code>get</code> Methode mit einem Parameter aufgerufen wird, der für ein <code>Map</code> Objekt aufgerufen wird. </blockquote><p>  Stellen Sie sich vor, wir haben Glück und das Projekt hat nur einen Kartentyp - <code>java.util.Map</code> .  Es hat zwar eine <code>get(Object)</code> -Methode, gibt aber leider einen generischen Parameter <code>V</code>  Dann verwerfen wir die Kette und suchen global nach der <code>updateAndGet</code> Methode mit einem Parameter (natürlich unter Verwendung des Index).  Wir freuen uns, dass das Projekt nur drei solcher Methoden enthält: in den Klassen <code>AtomicInteger</code> , <code>AtomicLong</code> und <code>AtomicReference</code> mit den Parametertypen <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> bzw. <code>UnaryOperator</code> .  Wenn wir nach einem anderen Typ suchen, haben wir bereits festgestellt, dass dieses Lambda nicht mit der Anforderung übereinstimmt, und wir müssen den PSI nicht erstellen. </p><br><p>  Überraschenderweise ist dies ein gutes Beispiel für eine Funktion, die mit der Zeit langsamer arbeitet.  Wenn Sie beispielsweise nach Implementierungen einer funktionalen Schnittstelle suchen und nur drei davon in Ihrem Projekt haben, dauert es zehn Sekunden, bis IntelliJ IDEA sie findet.  Sie erinnern sich, dass ihre Nummer vor drei Jahren dieselbe war, aber die IDE lieferte Ihnen die Suchergebnisse in nur zwei Sekunden auf demselben Computer.  Und obwohl Ihr Projekt riesig ist, ist es in diesen Jahren nur um fünf Prozent gewachsen.  Es ist vernünftig, darüber zu meckern, was die IDE-Entwickler falsch gemacht haben, um es so schrecklich langsam zu machen. </p><br><p>  Während wir vielleicht gar nichts geändert haben.  Die Suche funktioniert genauso wie vor drei Jahren.  Die Sache ist, dass Sie vor drei Jahren gerade auf Java 8 umgestiegen sind und nur hundert Lambdas in Ihrem Projekt hatten.  Inzwischen haben Ihre Kollegen anonyme Klassen in Lambdas verwandelt, Streams oder eine reaktive Bibliothek verwendet.  Infolgedessen gibt es anstelle von hundert Lambdas zehntausend.  Und jetzt muss die IDE hundertmal mehr Optionen durchsuchen, um die drei erforderlichen zu finden. </p><br><p>  Ich sagte "wir könnten", weil wir natürlich von Zeit zu Zeit zu dieser Suche zurückkehren und versuchen, sie zu beschleunigen.  Aber es ist, als würde man den Bach oder besser den Wasserfall hinauf rudern.  Wir bemühen uns sehr, aber die Anzahl der Lambdas in Projekten wächst sehr schnell. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451754/">https://habr.com/ru/post/de451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451742/index.html">Einen Tag vor DotNext 2019 Piter. Kostenlose Broadcast-Ankündigung</a></li>
<li><a href="../de451746/index.html">MegaSlerm für Ingenieure und Architekten Kubernetes</a></li>
<li><a href="../de451748/index.html">Überwachen des SSD-Status in Qsan-Arrays</a></li>
<li><a href="../de451750/index.html">Buch "Elasticsearch, Kibana, Logstash und Suchmaschinen der nächsten Generation"</a></li>
<li><a href="../de451752/index.html">30. Jahrestag der grassierenden Unsicherheit</a></li>
<li><a href="../de451758/index.html">Zusätzliche Uplinks in der Intel C620-Systemlogikarchitektur</a></li>
<li><a href="../de451760/index.html">Mit Golang Microservices in The Economist erstellen: Eine Retrospektive</a></li>
<li><a href="../de451766/index.html">Heisenbug 2019 Piter: Was wird in der kostenlosen Sendung passieren und was nur auf der Veranstaltung</a></li>
<li><a href="../de451768/index.html">Verbesserung der Arbeit von Wi-Fi. Allgemeine Grundsätze und nützliche Dinge</a></li>
<li><a href="../de451770/index.html">Veeam Backup & Replication: Nützliche Tipps, um Backups und Replikate funktionsfähig zu machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>