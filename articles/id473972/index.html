<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è üêç üë®üèΩ‚Äç‚úàÔ∏è Atas perintah pengembang Tertanam: mencari bug di Amazon FreeRTOS üë©‚Äçüç≥ üé° ‚ò£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap orang yang memprogram pengendali mikrokontroler mungkin tahu tentang FreeRTOS, atau setidaknya mendengar tentang sistem operasi ini. Orang-oran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atas perintah pengembang Tertanam: mencari bug di Amazon FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473972/">  Setiap orang yang memprogram pengendali mikrokontroler mungkin tahu tentang FreeRTOS, atau setidaknya mendengar tentang sistem operasi ini.  Orang-orang Amazon memutuskan untuk memperluas kemampuan sistem operasi ini untuk bekerja dengan layanan AWS Internet of Things - ini adalah bagaimana Amazon FreeRTOS muncul.  Kami, pengembang alat analisis kode PVS-Studio, diminta memeriksa proyek-proyek ini melalui pos dan dalam komentar di bawah artikel.  Nah, Anda bertanya - kami melakukannya.  Apa yang terjadi - baca terus. <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/efa/d2f/8d2efad2f7885ec13add7368f6d2ff96.png" alt="Gambar 3"></div><a name="habracut"></a><br><h2>  Sedikit tentang proyek </h2><br>  Untuk memulai, saya akan memberi tahu Anda sedikit tentang "ayah" dari proyek yang diperiksa - FreeRTOS (Anda dapat menemukan kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Seperti yang dikatakan Wikipedia, FreeRTOS adalah sistem operasi waktu-nyata multi-tasking untuk sistem tertanam. <br><br>  Itu ditulis dalam C tua yang baik, yang tidak mengejutkan - sistem operasi ini harus bekerja dalam kondisi khas mikrokontroler: daya komputasi rendah, sejumlah kecil RAM, dan sejenisnya.  Bahasa C memungkinkan Anda untuk bekerja dengan sumber daya pada tingkat rendah dan memiliki kinerja tinggi, sehingga sangat cocok untuk pengembangan OS semacam itu. <br><br>  Sekarang kembali ke Amazon, yang tidak tinggal diam dan berkembang di berbagai bidang yang menjanjikan.  Sebagai contoh, Amazon sedang mengembangkan mesin AAA game Amazon Lumberyard, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uji</a> . <br><br>  Salah satu bidang tersebut adalah Internet of Things (Internet of Things, IoT).  Untuk mengembangkan di bidang ini, Amazon memutuskan untuk menulis sistem operasinya sendiri - dan mereka mengambil kernel FreeRTOS sebagai basis. <br><br>  Sistem yang dihasilkan - Amazon FreeRTOS - diposisikan sebagai "menyediakan kemampuan untuk terhubung dengan aman ke Amazon Web Services, seperti AWS IoT Core atau AWS IoT Greengrass."  Kode sumber untuk proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini disimpan</a> di Github. <br><br>  Pada artikel ini, kita akan memeriksa apakah ada kesalahan dalam FreeRTOS, serta seberapa aman sistem operasi dari Amazon dalam hal analisis kode statis. <br><br><h2>  Bagaimana ceknya </h2><br>  Kode diperiksa menggunakan alat pencarian kesalahan otomatis: Penganalisis kode statis PVS-Studio.  Itu mampu mendeteksi kesalahan dalam program yang ditulis dalam C, C ++, C # dan Java. <br><br>  Sebelum memulai analisis, Anda perlu merakit proyek - jadi saya akan yakin bahwa saya memiliki semua dependensi yang diperlukan dan semuanya sesuai dengan proyek.  Ada beberapa cara untuk memverifikasi proyek - misalnya, menggunakan sistem pemantauan kompilasi.  Saya melakukan analisis menggunakan plug-in untuk Visual Studio - ada baiknya repositori dari kedua proyek memiliki satu set file proyek yang membuatnya mudah dibangun di bawah Windows. <br><br>  Yang saya butuhkan hanyalah mengumpulkan proyek untuk memastikan bahwa ada semua yang diperlukan untuk verifikasi.  Selanjutnya, saya meluncurkan analisis dan voila!  - di depan saya laporan analisa yang sudah jadi. <br><br>  Perpustakaan pihak ketiga yang termasuk dalam proyek-proyek ini juga dapat mengandung kesalahan, dan mereka, tentu saja, juga dapat mempengaruhi operasi program.  Namun, saya mengecualikan mereka dari analisis demi kemurnian narasi. <br><br>  Jadi, proyek dianalisis, laporan diterima, kesalahan menarik ditulis.  Saatnya beralih ke analisis mereka! <br><br><h2>  Apa yang menyembunyikan FreeRTOS </h2><br>  Awalnya, saya berharap untuk menulis dua artikel terpisah: satu untuk setiap sistem operasi.  Saya sudah menggosok tangan saya, bersiap untuk menulis artikel bagus tentang FreeRTOS.  Mengantisipasi deteksi bahkan beberapa kesalahan berair (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-457</a> ), saya bersemangat melihat beberapa peringatan penganalisa, dan ... dan tidak ada.  Saya tidak menemukan kesalahan yang menarik. <br><br>  Banyak peringatan yang dikeluarkan analis tidak relevan untuk FreeRTOS.  Sebagai contoh, peringatan tersebut adalah kekurangan 64-bit seperti casting <i>size_t</i> ke <i>uint32_t</i> .  Ini karena fakta bahwa FreeRTOS dirancang untuk bekerja pada perangkat dengan ukuran pointer tidak lebih dari 32 bit. <br><br>  Saya hati-hati memeriksa semua peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1027 yang</a> terkait dengan gips antara pointer ke struktur yang tidak terkait.  Jika struktur yang dapat direduksi memiliki keselarasan yang sama, maka gips semacam itu bukan kesalahan.  Dan saya tidak menemukan satu pun pemain berbahaya! <br><br>  Semua tempat mencurigakan lainnya terkait dengan gaya pengkodean, atau dilengkapi dengan komentar yang menjelaskan mengapa ini dilakukan persis di sini dan mengapa ini bukan kesalahan. <br><br>  Secara umum, saya ingin menghubungi pengembang FreeRTOS.  Kalian benar-benar hebat!  Kami hampir tidak pernah bertemu proyek yang bersih dan berkualitas tinggi seperti milik Anda.  Dan saya sangat senang membaca kode yang bersih, rapi, dan terdokumentasi dengan baik.  Angkat topi untukmu. <br><br>  Meskipun saya tidak dapat menemukan kesalahan yang menarik hari itu, saya mengerti bahwa saya tidak akan berhenti di situ.  Saya pulang dengan keyakinan kuat bahwa sesuatu yang menarik akan ditemukan dalam versi dari Amazon 100%, dan bahwa besok saya pasti akan mengumpulkan cukup banyak kesalahan untuk artikel tersebut.  Seperti yang mungkin Anda tebak, saya benar. <br><br><h2>  Apa yang menyembunyikan Amazon FreeRTOS </h2><br>  Versi sistem Amazon ternyata ... dengan kata lain, sedikit lebih buruk.  Warisan FreeRTOS tetap sama bersihnya, tetapi revisi baru ternyata cukup menarik. <br><br>  Di beberapa tempat, logika program dilanggar, di suatu tempat salah bekerja dengan pointer.  Di beberapa tempat, kode dapat menyebabkan perilaku yang tidak terdefinisi, tetapi di suatu tempat programmer tidak tahu tentang pola kesalahan yang ia buat.  Saya bahkan menemukan beberapa potensi kerentanan serius. <br><br>  Sesuatu yang saya tunda dengan pengantar.  Ayo mulai parsing bug! <br><br><h3>  Pelanggaran logika program </h3><br>  Mari kita mulai dengan area masalah, yang dengan jelas menunjukkan bahwa program tidak berjalan persis seperti yang diharapkan oleh programmer.  Tempat pertama seperti itu akan merupakan karya mencurigakan dengan sebuah array: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Pool of request and associated response buffers, * handles, and configurations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _requestPool_t _requestPool = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _scheduleAsyncRequest(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqIndex, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currentRange) { .... <span class="hljs-comment"><span class="hljs-comment">/* Set the user private data to use in the asynchronous callback context. */</span></span> _requestPool.pRequestDatas[reqIndex].pConnHandle = &amp;_connHandle; _requestPool.pRequestDatas[reqIndex].pConnConfig = &amp;_connConfig; _requestPool.pRequestDatas[reqIndex].reqNum = reqIndex; _requestPool.pRequestDatas[reqIndex].currRange = currentRange; _requestPool.pRequestDatas[reqIndex].currDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; _requestPool.pRequestDatas[reqIndex].numReqBytes = numReqBytes; .... _requestPool.pRequestDatas-&gt;scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  PVS-Studio mengeluarkan dua peringatan untuk kode ini: <br><br><ul><li>  V619 Array '_requestPool.pRequestDatas' digunakan sebagai penunjuk ke objek tunggal.  iot_demo_https_s3_download_async.c 973 </li><li>  V574 Pointer '_requestPool.pRequestDatas' digunakan secara bersamaan sebagai array dan sebagai pointer ke objek tunggal.  Periksa baris: 931, 973. iot_demo_https_s3_download_async.c 973 </li></ul><br>  Untuk jaga-jaga, izinkan saya mengingatkan Anda: nama array adalah pointer ke elemen pertama.  Yaitu, jika <i>_requestPool.pRequestDatas</i> adalah array struktur, maka <i>_requestPool.pRequestDatas [i] .scheduled</i> adalah akses ke anggota <i>terjadwal</i> dari struktur ke- <i>l</i> array.  Dan jika Anda menulis <i>_requestPool.pRequestDatas-&gt; terjadwal</i> , ini akan berarti akses ke anggota <i>terjadwal</i> dari struktur pertama array. <br><br>  Inilah yang terjadi pada cuplikan kode di atas.  Baris terakhir selalu mengubah nilai hanya untuk anggota struktur pertama array.  Dengan sendirinya, panggilan ini sudah mencurigakan, tetapi situasi di sini bahkan lebih jelas: seluruh seluruh fungsi, array <i>_requestPool.pRequestDatas</i> diakses oleh indeks, dan hanya pada akhir operasi pengindeksan yang lupa untuk diterapkan. <br><br>  Seperti yang saya pahami, baris terakhir akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">_requestPool.pRequestDatas[reqIndex].scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Kesalahan berikut terletak pada fungsi kecil, jadi saya akan memberikannya secara keseluruhan: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Return true if the string " pcString" is found * inside the token pxTok in JSON file pcJson. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prvGGDJsoneq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcJson, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">jsmntok_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTok, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcString )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStringSize = ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;end - ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;start; BaseType_t xStatus = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pxTok-&gt;type == JSMN_STRING ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( pcString ) == ulStringSize ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>( &amp;pcJson[ pxTok-&gt;start ], <span class="hljs-comment"><span class="hljs-comment">// &lt;= pcString, ulStringSize ) == 0 ) { xStatus = pdTRUE; } } } return xStatus; }</span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V642 [CWE-197] Menyimpan hasil fungsi 'strncmp' di dalam variabel tipe 'pendek' tidak tepat.  Bit signifikan bisa hilang melanggar logika program.  aws_greengrass_discovery.c 637 <br><br>  Mari kita lihat definisi fungsi strncmp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span></span>;</code> </pre> <br>  Dalam contoh, hasil dari tipe <i>int</i> , yang ukurannya 32 bit, dikonversi ke variabel tipe <i>int16_t</i> .  Dengan konversi "penyempitan" seperti itu, bit paling signifikan dari nilai pengembalian akan hilang.  Misalnya, jika fungsi <i>strncmp</i> mengembalikan <i>0x00010000</i> , maka yang akan <i>hilang</i> selama konversi, dan kondisinya akan terpenuhi. <br><br>  Bahkan, aneh melihat para pemain dalam kondisi seperti itu.  Mengapa bahkan melakukannya jika Anda dapat membandingkan <i>int</i> normal dengan nol?  Di sisi lain, jika programmer secara sadar ingin fungsi tersebut terkadang mengembalikan <i>true</i> , bahkan jika tidak, maka mengapa perilaku rumit ini tidak dijelaskan oleh komentar?  Tapi kemudian ini sudah bookmark.  Secara umum, saya cenderung percaya bahwa ini adalah kesalahan.  Apa yang kamu pikirkan <br><br><h3>  Perilaku dan petunjuk yang tidak terdefinisi </h3><br>  Sekarang akan ada contoh yang agak besar.  Itu menyembunyikan potensi referensi dari pointer nol: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _networkReceiveCallback(....) { IotHttpsReturnCode_t status = IOT_HTTPS_OK; _httpsResponse_t* pCurrentHttpsResponse = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IotLink_t* pQItem = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* Get the response from the response queue. */</span></span> IotMutex_Lock(&amp;(pHttpsConnection-&gt;connectionMutex)); pQItem = IotDeQueue_PeekHead(&amp;(pHttpsConnection-&gt;respQ)); IotMutex_Unlock(&amp;(pHttpsConnection-&gt;connectionMutex)); <span class="hljs-comment"><span class="hljs-comment">/* If the receive callback is invoked * and there is no response expected, * then this a violation of the HTTP/1.1 protocol. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pQItem == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { IotLogError(....); fatalDisconnect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; status = IOT_HTTPS_NETWORK_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> iotCleanup; } .... iotCleanup : <span class="hljs-comment"><span class="hljs-comment">/* Report errors back to the application. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != IOT_HTTPS_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pCurrentHttpsResponse-&gt;isAsync &amp;&amp; pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback) { pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback(....); } pCurrentHttpsResponse-&gt;syncStatus = status; } .... }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V522 [CWE-690] Mungkin ada dereferensi dari penunjuk null potensial 'pCurrentHttpsResponse'.  iot_https_client.c 1184 <br><br>  Dereferensi masalah ada di bagian paling bawah <i>jika</i> .  Mari kita lihat apa yang terjadi di sini. <br><br>  Pada awal fungsi, <i>variabel pCurrentHttpsResponse</i> dan <i>pQItem</i> diinisialisasi ke <i>NULL</i> , dan variabel <i>status</i> <i>diinisialisasi</i> ke <i>IOT_HTTPS_OK</i> , yang berarti semuanya berjalan dengan lancar. <br><br>  Selanjutnya, <i>pQItem</i> diberi nilai yang dikembalikan dari fungsi <i>IotDeQueue_PeekHead</i> , yang mengembalikan pointer ke awal antrian yang terhubung dua kali lipat. <br><br>  Apa yang terjadi jika antrian kosong?  Dalam hal ini, fungsi <i>IotDeQueue_PeekHead</i> akan mengembalikan <i>NULL</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotDeQueue_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotDeQueue_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pQueue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IotListDouble_PeekHead(pQueue); } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotListDouble_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotListDouble_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pList)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* @[declare_linear_containers_list_double_peekhead] */</span></span></span><span class="hljs-function"> </span></span>{ IotLink_t* pHead = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pList != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IotListDouble_IsEmpty(pList) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { pHead = pList-&gt;pNext; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pHead; }</code> </pre> <br>  Selanjutnya, kondisi <i>pQItem == NULL</i> puas, dan aliran kontrol <i>berlanjut</i> melalui <i>goto</i> ke bagian bawah dari fungsi body.  Pada saat ini, pointer <i>pCurrentHttpsResponse</i> akan tetap nol, dan <i>statusnya</i> tidak lagi sama dengan <i>IOT_HTTPS_OK</i> .  Akibatnya, kita akan jatuh ke cabang itu <i>jika</i> , dan ... lulus!  Konsekuensi dereferencing ini, Anda sendiri tahu. <br><br>  Baiklah  Itu adalah contoh yang sedikit berornamen.  Sekarang saya bawa perhatian Anda potensi dereferencing yang sangat sederhana dan dapat dipahami: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PKI_mbedTLSSignatureToPkcs11Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxSignaturePKCS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxMbedSignature )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * pxNextLength; <span class="hljs-comment"><span class="hljs-comment">/* The 4th byte contains the length of the R component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ucSigComponentLength = pxMbedSignature[ <span class="hljs-number"><span class="hljs-number">3</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( ( pxSignaturePKCS == NULL ) || ( pxMbedSignature == NULL ) ) { xReturn = FAILURE; } .... }</span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V595 [CWE-476] Pointer 'pxMbedSignature' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 52, 54. iot_pki_utils.c 52 <br><br>  Fungsi ini mendapat dua petunjuk untuk <i>uint8_t</i> .  Kedua petunjuk diperiksa untuk <i>NULL</i> , yang merupakan praktik yang baik - situasi seperti itu harus segera diselesaikan. <br><br>  Tapi ini sialnya: pada saat <i>pxMbedSignature</i> dicentang, itu sudah akan direferensikan secara harfiah satu baris di atas.  Ta-daa! <br><br>  Contoh lain dari kode spekulatif: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CK_RV </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vAppendSHA256AlgorithmIdentifierSequence</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x32ByteHashedMessage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x51ByteHashOidBuffer )</span></span></span><span class="hljs-function"> </span></span>{ CK_RV xResult = CKR_OK; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> xOidSequence[] = pkcs11STUFF_APPENDED_TO_RSA_SIG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( x32ByteHashedMessage == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) || ( x51ByteHashOidBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) { xResult = CKR_ARGUMENTS_BAD; } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( x51ByteHashOidBuffer, xOidSequence, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;x51ByteHashOidBuffer[ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ], x32ByteHashedMessage, <span class="hljs-number"><span class="hljs-number">32</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xResult; }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V1004 [CWE-628] Pointer 'x51ByteHashOidBuffer' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 275, 280. iot_pkcs11.c 280 </li><li>  V1004 [CWE-628] Pointer 'x32ByteHashedMessage' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 275, 281. iot_pkcs11.c 281 </li></ul><br>  Penganalisa memperingatkan bahwa parameter fungsi yang pointer digunakan tidak aman setelah mereka diuji untuk <i>NULL</i> .  Memang, argumen diperiksa, tetapi jika salah satu dari mereka ternyata <i>NULL</i> , tidak ada tindakan yang diambil, kecuali untuk menulis ke <i>xResult</i> .  Sepotong kode ini sepertinya mengatakan: ‚ÄúYa, itu berarti argumennya ternyata buruk.  Kami akan menuliskannya sekarang, selagi Anda melanjutkan, lanjutkan. " <br><br>  Intinya: <i>NULL</i> akan diteruskan ke <i>memcpy</i> .  Apa yang bisa terjadi dengan ini?  Di mana nilai-nilai akan disalin dan yang mana?  Bahkan, menebak tentang hal ini tidak layak, karena  standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan jelas menyatakan</a> bahwa panggilan semacam itu mengarah pada perilaku yang tidak terdefinisi (lihat paragraf 1). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/7d6/856/cf77d6856666f6a1529a1744832bd5bf.png" alt="Gambar 2"></div><br><br>  Laporan analisa masih berisi contoh operasi yang salah dengan pointer yang saya temukan di Amazon FreeRTOS, tapi saya pikir contoh yang diberikan sudah cukup untuk menunjukkan kepada Anda kemampuan PVS-Studio dalam mendeteksi kesalahan tersebut.  Pertimbangkan sesuatu yang baru. <br><br><h3>  BENAR! = 1 </h3><br>  Beberapa kesalahan yang saya temukan terkait dengan satu pola, yang, sayangnya, sering dilupakan. <br><br>  Faktanya adalah bahwa tipe <i>bool</i> (dari C ++) berbeda dari tipe <i>BOOL</i> (biasanya digunakan dalam C).  Yang pertama hanya bisa berisi <i>benar</i> atau <i>salah</i> .  Yang kedua adalah typedef dari beberapa tipe integer ( <i>int</i> , <i>long</i> , etc.).  Baginya, "false" adalah nilai <i>0</i> , dan "true" adalah nilai selain nol. <br><br>  Karena tidak ada tipe Boolean bawaan di C, konstanta ini didefinisikan untuk kenyamanan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FALSE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRUE 1</span></span></code> </pre> <br>  Sekarang pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mbedtls_hardware_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* output, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* olen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lStatus = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; HCRYPTPROV hProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Unferenced parameter. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)data; <span class="hljs-comment"><span class="hljs-comment">/* * This is port-specific for the Windows simulator, * so just use Crypto API. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptAcquireContextA( &amp;hProv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptGenRandom(hProv, len, output)) { lStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; *olen = len; } CryptReleaseContext(hProv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lStatus; }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V676 [CWE-253] Tidak benar membandingkan variabel tipe BOOL dengan TRUE.  aws_entropy_hardware_poll.c 48 </li><li>  V676 [CWE-253] Tidak benar membandingkan variabel tipe BOOL dengan TRUE.  Ekspresi yang benar adalah: 'FALSE! = CryptGenRandom (hProv, len, output)'.  aws_entropy_hardware_poll.c 51 </li></ul><br>  Menemukan kesalahan?  Dan itu :) Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>CryptAcquireContextA</i></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>CryptGenRandom</i></a> adalah fungsi standar dari header <i>wincrypt.h</i> .  Jika berhasil, mereka mengembalikan nilai bukan nol.  Saya tekankan - <i>bukan nol</i> .  Jadi, secara teoritis, ini bisa berupa nilai selain nol: <i>1</i> , <i>314</i> , <i>42</i> , <i>420</i> . <br><br>  Rupanya, programmer yang menulis fungsi dari contoh tidak memikirkannya, dan sebagai hasilnya, nilai yang diperoleh dibandingkan dengan kesatuan. <br><br>  Dengan probabilitas apa kondisi <i>TRUE == CryptGenRandom (....)</i> tidak terpenuhi?  Sulit dikatakan.  Mungkin <i>CryptGenRandom</i> mengembalikan unit lebih sering daripada nilai-nilai lain, dan mungkin selalu mengembalikan hanya satu.  Kita tidak tahu pasti: penerapan fungsi kriptografis ini disembunyikan dari mata programmer fana :) <br><br>  Penting untuk diingat bahwa perbandingan semacam itu berpotensi berbahaya.  Dan bukannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == GetBOOL())</code> </pre> <br>  gunakan opsi yang lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE != GetBOOL())</code> </pre> <br><h3>  Masalah Optimasi </h3><br>  Beberapa peringatan penganalisa telah dikaitkan dengan konstruksi yang berjalan lambat.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> V817 Lebih efisien untuk mencari karakter '/' daripada string.  iot_demo_https_common.c 205 <br><br>  Secara singkat dan jelas, bukan?  Fungsi <i>strstr di</i> sini digunakan untuk mencari hanya satu karakter, yang diteruskan ke parameter sebagai string (itu dilampirkan dalam tanda kutip ganda). <br><br>  Tempat ini dapat berpotensi dioptimalkan dengan mengganti <i>strstr</i> dengan <i>strchr</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); .... }</code> </pre> <br>  Maka pencarian akan bekerja sedikit lebih cepat.  Agak, tapi bagus. <br><br>  Optimalisasi semacam itu, tentu saja, bagus, dan penganalisa telah menemukan tempat lain yang dapat dioptimalkan dengan lebih jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vRunOTAUpdateDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { .... xConnectInfo.cleanSession = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xConnectInfo.clientIdentifierLength = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(clientcredentialIOT_THING_NAME); xConnectInfo.pClientIdentifier = clientcredentialIOT_THING_NAME; .... } }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V814 Penurunan kinerja.  Fungsi 'strlen' disebut beberapa kali di dalam tubuh loop.  aws_iot_ota_update_demo.c 235 <br><br>  Hmmm ... Di dalam loop, pada setiap iterasi, <i>strlen</i> disebut, yang setiap kali menghitung panjang garis yang sama.  Bukan operasi yang paling efisien :) <br><br>  Mari kita lihat definisi <i>clientcredentialIOT_THING_NAME</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * @brief Host name. * * @todo Set this to the unique name of your IoT Thing. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> clientcredentialIOT_THING_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br>  Pengguna diminta untuk memasukkan nama perangkatnya di sini.  Secara default, ini kosong, dan dalam hal ini, semuanya baik-baik saja.  Tetapi bagaimana jika pengguna ingin memasukkan nama panjang dan indah di sana?  Sebagai contoh, saya ingin menyebut gagasan saya " <i>Mesin Kopi yang Bergairah dan Canggih BarBarista-N061E Edisi Tertinggi</i> ".  Bisakah Anda bayangkan betapa terkejutnya saya jika setelah itu mesin kopi saya yang indah mulai bekerja sedikit lebih lambat?  Kekacauan! <br><br>  Untuk memperbaiki kesalahan, <i>strlen</i> harus dikeluarkan dari badan loop.  Lagi pula, nama perangkat tidak berubah saat program sedang berjalan.  Ehhh, ini akan menjadi <i>constexpr</i> dari C ++ ... <br><br>  Oke, oke, saya akui: di sini saya sedikit menebal.  Seperti kolega saya Andrei Karpov catat, kompiler modern tahu apa <i>strlen</i> dan dia secara pribadi mengamati bagaimana mereka hanya menggunakan konstanta dalam kode biner, jika mereka mengerti bahwa panjang string tidak dapat berubah.  Jadi ada probabilitas tinggi bahwa dalam mode build versi rilis, alih-alih perhitungan nyata dari panjang string, nilai yang dihitung sebelumnya hanya akan digunakan.  Namun, ini tidak selalu berhasil, jadi menulis kode seperti itu bukan praktik yang baik. <br><br><h2>  Beberapa kata tentang MISRA </h2><br>  Alat analisis PVS-Studio memiliki seperangkat aturan besar yang memungkinkan Anda memeriksa kode Anda untuk kesesuaian dengan standar MISRA C dan MISRA C ++.  Apa standar ini? <br><br>  MISRA adalah standar pengkodean untuk sistem tertanam yang sangat responsif.  Ini berisi seperangkat aturan ketat dan pedoman untuk menulis kode dan mengatur proses pengembangan.  Ada beberapa aturan ini, dan mereka ditujukan tidak hanya untuk menghilangkan kesalahan serius, tetapi juga pada berbagai "bau kode", serta penulisan kode yang paling mudah dipahami dan dibaca. <br><br>  Dengan demikian, mengikuti standar MISRA tidak hanya membantu menghindari kesalahan dan kerentanan, tetapi juga secara signifikan - signifikan!  - mengurangi kemungkinan kemunculannya dalam kode yang ada. <br><br>  MISRA digunakan dalam industri kedirgantaraan, medis, otomotif dan militer - di mana kehidupan manusia bergantung pada kualitas perangkat lunak yang disematkan. <br><br>  Tampaknya, pengembang FreeRTOS Amazon mengetahui standar ini, dan sebagian besar mengikutinya.  Itu benar: jika Anda menulis OS berbasis luas untuk sistem embedded, maka Anda harus memikirkan keamanan. <br><br>  Namun, saya menemukan beberapa pelanggaran terhadap standar MISRA.  Di sini saya tidak akan memberikan contoh aturan seperti "jangan gunakan serikat" atau "fungsi seharusnya hanya memiliki satu pengembalian di akhir tubuh" - sayangnya, mereka tidak spektakuler, seperti kebanyakan aturan MISRA.  Saya lebih baik memberi Anda contoh-contoh pelanggaran yang berpotensi menyebabkan konsekuensi serius. <br><br>  Mari kita mulai dengan makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FreeRTOS_ms_to_tick(ms) ( ( ms * configTICK_RATE_HZ + 500 ) / 1000 )</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOCKETS_htonl( ulIn ) ( ( uint32_t ) \ ( ( ( ulIn &amp; 0xFF ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24 ) | ( ( ulIn &amp; 0xFF00 ) &lt;&lt; 8 ) \ | ( ( ulIn &amp; 0xFF0000 ) &gt;&gt; 8 ) | ( ( ulIn &amp; 0xFF000000 ) &gt;&gt; 24 ) ) )</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEFT_ROTATE( x, c ) ( ( x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; c ) | ( x &gt;&gt; ( 32 - c ) ) )</span></span></span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'ms' dari makro 'FreeRTOS_ms_to_tick'.  FreeRTOS_IP.h 201 </li><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'ulIn' dari makro 'SOCKETS_htonl'.  iot_secure_sockets.h 512 </li><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'x', 'c' dari makro 'LEFT_ROTATE'.  iot_device_metrics.c 90 </li></ul><br>  Ya, ini persis seperti yang Anda pikirkan.  Parameter makro ini tidak dibungkus dengan tanda kurung.  Jika seseorang secara tidak sengaja menulis sesuatu seperti <br><br><pre> <code class="cpp hljs">val = LEFT_ROTATE(A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span>, B);</code> </pre> <br>  maka makro "panggilan" semacam itu akan terbuka di: <br><br><pre> <code class="cpp hljs">val = ( ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; B ) | ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; ( <span class="hljs-number"><span class="hljs-number">32</span></span> - B ) ) );</code> </pre> <br>  Ingat prioritas operasi?  Pertama, pergeseran bitwise dilakukan, dan hanya setelah itu bitwise ‚Äúatau‚Äù.  Karena itu, logika program akan dilanggar.  Contoh yang lebih sederhana: apa yang terjadi jika ekspresi " <i>x + y</i> " dilewatkan ke makro <i>FreeRTOS_ms_to_tick</i> ?  Salah satu tujuan utama MISRA adalah untuk mencegah terjadinya situasi seperti itu. <br><br>  Seseorang mungkin keberatan: "jika Anda memiliki programmer yang tidak tahu tentang ini, maka tidak ada standar yang akan menyelamatkan Anda!" Dan saya tidak akan setuju dengan ini.  Pemrogram juga manusia, dan tidak peduli seberapa berpengalaman seseorang, ia juga bisa lelah dan membuat kesalahan di akhir hari kerja.  Ini adalah salah satu alasan MISRA sangat merekomendasikan penggunaan alat analisis otomatis untuk memvalidasi proyek terhadap standar. <br><br>  Saya beralih ke pengembang Amazon FreeRTOS: PVS-Studio menemukan 12 makro yang lebih tidak aman, jadi Anda lebih berhati-hati di sana bersama mereka :) <br><br>  Pelanggaran MISRA lain yang menarik: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Callback for an asynchronous request to notify * that the response is complete. * * @param[in] 0pPrivData - User private data configured * with the HTTPS Client library request configuration. * @param[in] respHandle - Identifier for the current response finished. * @param[in] rc - Return code from the HTTPS Client Library * signaling a possible error. * @param[in] status - The HTTP response status. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _responseCompleteCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pPrivData, IotHttpsResponseHandle_t respHandle, IotHttpsReturnCode_t rc, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> status) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* pUploadSuccess = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>*)pPrivData; <span class="hljs-comment"><span class="hljs-comment">/* When the remote server response with 200 OK, the file was successfully uploaded. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == IOT_HTTPS_STATUS_OK) { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Post to the semaphore that the upload is finished. */</span></span> IotSemaphore_Post(&amp;(_uploadFinishedSem)); }</code> </pre> <br>  Bisakah Anda menemukan kesalahan sendiri? <br><br>  <b>Peringatan PVS-Studio:</b> V2537 [MISRA C 2.7] Fungsi tidak boleh memiliki parameter yang tidak digunakan.  Pertimbangkan memeriksa parameter: 'rc'.  iot_demo_https_s3_upload_async.c 234 <br><br>  Lihatlah lebih dekat: parameter <i>rc</i> tidak digunakan di mana saja di badan fungsi.  Selain itu, dalam komentar tentang fungsi itu secara eksplisit ditulis bahwa parameter ini adalah kode pengembalian fungsi lain, dan bahwa itu dapat menandakan kesalahan.  Lalu mengapa parameter ini tidak diproses dengan cara apa pun?  Jelas ada sesuatu yang salah di sini. <br><br>  Namun, bahkan tanpa komentar tersebut, parameter yang tidak digunakan sering menunjukkan logika program rusak.  Kalau tidak, mengapa mereka diperlukan dalam tanda tangan fungsi? <br><br>  Di sini saya telah memberikan fungsi kecil yang cocok untuk contoh di artikel.  Selain dia, saya menemukan 10 parameter yang tidak digunakan lagi.  Banyak dari mereka yang digunakan dalam fungsi yang lebih besar, dan menemukannya bukanlah hal yang mudah. <br><br>  Sangat mencurigakan bahwa mereka tidak ditemukan sebelumnya.  Memang, kompiler dapat dengan mudah mendeteksi kasus-kasus seperti itu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/6c7/bb9/b806c7bb94c335ce2712e9b46cffc560.png" alt="Gambar 1"></div><br><br><h2>  Kesimpulan </h2><br>  Ini tidak semua bidang masalah yang ditemukan oleh penganalisa, tetapi artikel itu sudah cukup besar.  Saya berharap bahwa berkat itu, pengembang Amazon FreeRTOS akan dapat memperbaiki beberapa kekurangan, dan mungkin bahkan ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencoba PVS-Studio</a> sendiri.  Dengan cara ini, dimungkinkan untuk mempelajari peringatan secara lebih menyeluruh, dan memang, bekerja dengan antarmuka yang nyaman jauh lebih mudah daripada melihat laporan teks. <br><br>  Terima kasih telah membaca artikel kami!  Sampai jumpa di edisi berikutnya: D <br><br>  PS Kebetulan artikel ini diterbitkan pada tanggal 31 Oktober.  Karena itu, saya berharap semua orang selamat Halloween! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: George Gribkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atas permintaan Pengembang Tertanam: Mendeteksi Kesalahan di Amazon FreeRTOS</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473972/">https://habr.com/ru/post/id473972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473956/index.html">Informasi rahasia dari perusahaan telepon pengedar narkoba</a></li>
<li><a href="../id473958/index.html">Jepang dari NICT memperkenalkan cluster serat yang bekerja dengan bandwidth 1 Pbit / s</a></li>
<li><a href="../id473960/index.html">Strategi Pelokalan Konten</a></li>
<li><a href="../id473962/index.html">Mode gelap sekarang ada di mana-mana. Apakah ini sangat berguna? (di akhir post survey)</a></li>
<li><a href="../id473966/index.html">Atas permintaan Pengembang Tertanam: Mendeteksi Kesalahan di Amazon FreeRTOS</a></li>
<li><a href="../id473974/index.html">Intercom'19 - sebuah konferensi tentang otomatisasi komunikasi dari Voximplant akan diadakan pada 14 November</a></li>
<li><a href="../id473976/index.html">AWS Elasticsearch: Produk Cacat Secara fundamental</a></li>
<li><a href="../id473978/index.html">Seperti rasa sakit, rasa sakit, kasir sebagai layanan 2: 0</a></li>
<li><a href="../id473980/index.html">Teknologi dan dunia nyata: 4 Start-up yang mengubah masa depan desain interior</a></li>
<li><a href="../id473982/index.html">NB-IoT: bagaimana cara kerjanya? Bagian 3: SCEF - jendela akses tunggal ke layanan operator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>