<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∏ üî§ üë∂üèæ Objekt durch var ersetzen: Was k√∂nnte schief gehen? üë©üèº‚Äçüî¨ üñ≤Ô∏è üò¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin k√ºrzlich auf eine Situation gesto√üen, in der das Ersetzen von Object durch var in einem Java 10-Programm zur Laufzeit eine Ausnahme ausl√∂st. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Objekt durch var ersetzen: Was k√∂nnte schief gehen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469111/"><p>  Ich bin k√ºrzlich auf eine Situation gesto√üen, in der das Ersetzen von Object durch var in einem Java 10-Programm zur Laufzeit eine Ausnahme ausl√∂st.  Ich interessierte mich daf√ºr, auf wie viele verschiedene Arten dieser Effekt erzielt werden kann, und wandte mich an die Community: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1174191219620089856"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Es stellte sich heraus, dass Sie den Effekt auf verschiedene Arten erzielen k√∂nnen.  Obwohl alle etwas kompliziert sind, ist es interessant, sich am Beispiel einer solchen Aufgabe an die verschiedenen Feinheiten der Sprache zu erinnern.  Mal sehen, welche Methoden gefunden wurden. </p><a name="habracut"></a><br><h2 id="uchastniki">  Mitglieder </h2><br><p>  Unter den Befragten waren viele ber√ºhmte und nicht sehr Menschen.  Dies ist Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bsideup</a> Egorov, Pivotal-Mitarbeiter, Redner, einer der Sch√∂pfer von Testcontainern.  Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Polishchuk</a> , ber√ºhmt f√ºr Berichte √ºber das blutige Unternehmen.  Auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nikita Artyushov</a> von Google bemerkt;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Mikhailov</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maccimo</a> .  Besonders gefreut hat mich aber die Ankunft von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wouter Coekaerts</a> .  Er ist bekannt f√ºr seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel im letzten Jahr</a> , in dem er durch das Java-Typensystem ging und erz√§hlte, wie hoffnungslos es kaputt war.  Einige dieser Artikel haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jbaruch</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ich</a> sogar in der vierten Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Puzzlers verwendet</a> . </p><br><h2 id="zadacha-i-resheniya">  Aufgabe und L√∂sungen </h2><br><p> Das Wesentliche unserer Aufgabe ist also: Es gibt ein Java-Programm, in dem eine Variable der Form <code>Object x = ...</code> <code>java.lang.Object</code> ist (ehrlicher Standard <code>java.lang.Object</code> , keine Typersetzungen).  Das Programm kompiliert, f√ºhrt und druckt so etwas wie "Ok".  Wir ersetzen <code>Object</code> durch <code>var</code> und erfordern eine automatische Typinferenz. Danach wird das Programm weiter kompiliert, st√ºrzt jedoch beim Start mit einer Ausnahme ab. </p><br><p>  L√∂sungen k√∂nnen grob in zwei Gruppen unterteilt werden.  Im ersten Fall wird die Variable nach dem Ersetzen durch var primitiv (dh sie war urspr√ºnglich Autoboxing).  Der zweite Typ bleibt Objekt, aber spezifischer als <code>Object</code> .  Hier k√∂nnen Sie eine interessante Untergruppe hervorheben, die Generika verwendet. </p><br><h3 id="boksing">  Boxen </h3><br><p>  Wie kann man ein Objekt von einem Grundelement unterscheiden?  Es gibt viele verschiedene M√∂glichkeiten.  Am einfachsten ist es, die Identit√§t zu √ºberpr√ºfen.  Diese L√∂sung wurde von Nikita vorgeschlagen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Wenn <code>x</code> ein Objekt ist, kann es unter Bezugnahme auf das neue Objekt <code>new Integer(1000)</code> sicherlich nicht gleich sein.  Und wenn es sich um ein Grundelement handelt, entfaltet sich nach den Regeln der Sprache die <code>new Integer(1000)</code> sofort auch zu einem Grundelement, und Zahlen werden als Grundelemente verglichen. </p><br><p>  Ein anderer Weg sind √ºberladene Methoden.  Sie k√∂nnen Ihre eigenen schreiben, aber Sergey hat eine elegantere Option gefunden: Verwenden Sie die Standardbibliothek.  Die <code>List.remove</code> Methode ist <code>List.remove</code> , √ºberladen und kann entweder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Element nach Index</a> entfernen, wenn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Grundelement</a> √ºbergeben wird, oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Element nach Wert,</a> wenn ein Objekt √ºbergeben wird.  Dies hat wiederholt zu Fehlern in realen Programmen gef√ºhrt, wenn Sie <code>List&lt;Integer&gt;</code> .  F√ºr unsere Aufgabe k√∂nnte die L√∂sung folgenderma√üen aussehen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; List&lt;?&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.remove(x); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Jetzt versuchen wir, das nicht vorhandene Element 1000 aus der leeren Liste zu entfernen. Dies ist nur eine nutzlose Aktion.  Wenn wir <code>Object</code> durch <code>var</code> ersetzen, rufen wir eine andere Methode auf, mit der das Element mit dem Index 1000 entfernt wird. Dies f√ºhrt bereits zu <code>IndexOutOfBoundsException</code> . </p><br><p>  Die dritte Methode ist der Typkonvertierungsoperator.  Wir k√∂nnen ein anderes Grundelement erfolgreich in einen Grundelementtyp konvertieren, aber ein Objekt wird nur konvertiert, wenn es einen Wrapper √ºber denselben Typ gibt, in den wir konvertieren werden (dann wird Anboxing stattfinden).  Eigentlich brauchen wir den gegenteiligen Effekt: Eine Ausnahme ist im Fall eines Grundelements und nicht im Fall eines Objekts, aber mit Try-Catch ist dies leicht zu erreichen, was Viktor verwendet hat: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Oops :"</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)x); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassCastException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Hier ist <code>ClassCastException</code> das erwartete Verhalten, dann wird das Programm normal beendet.  Aber nach der Verwendung von <code>var</code> verschwindet diese Ausnahme und wir werfen etwas anderes.  Ich frage mich, ob dies vom echten Code des blutigen Unternehmens inspiriert ist. </p><br><p>  Eine andere Option zur Typkonvertierung wurde von Wouter vorgeschlagen.  Sie k√∂nnen die seltsame Logik des Operators verwenden <code>?:</code> .  Der Code liefert zwar nur unterschiedliche Ergebnisse, daher m√ºssen Sie ihn irgendwie √§ndern, damit es eine Ausnahme gibt.  So scheint es mir ganz elegant: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; System.out.println(String.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ? x : <span class="hljs-number"><span class="hljs-number">100000000000L</span></span>).substring(<span class="hljs-number"><span class="hljs-number">12</span></span>) + <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Der Unterschied zwischen dieser Methode besteht darin, dass wir den Wert von <code>x</code> direkt verwenden, sondern dass der Typ <code>x</code> den Typ des Ausdrucks <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> .  Wenn <code>x</code> ein <code>Object</code> , dann ist der Typ des gesamten Ausdrucks <code>Object</code> , und dann haben wir nur Boxing. <code>String.valueOf()</code> gibt <code>String.valueOf()</code> Zeichenfolge von <code>100000000000</code> , f√ºr die <code>substring(12)</code> eine leere Zeichenfolge ist.  Wenn Sie <code>var</code> , wird der Typ <code>x</code> <code>double</code> und daher der Typ <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> ebenfalls <code>double</code> , <code>1.0E11</code> <code>100000000000L</code> wird zu <code>1.0E11</code> , wo es viel weniger als 12 Zeichen sind. Das Aufrufen von <code>substring</code> f√ºhrt also zu einer <code>StringIndexOutOfBoundsException</code> . </p><br><p>  Schlie√ülich nutzen wir die Tatsache, dass eine Variable nach der Erstellung tats√§chlich ge√§ndert werden kann.  Und in der Objektvariablen k√∂nnen Sie im Gegensatz zum Grundelement <code>null</code> setzen.  Das Einf√ºgen von <code>null</code> in eine Variable ist einfach, es gibt viele M√∂glichkeiten.  Aber auch hier verfolgte Wouter einen kreativen Ansatz mit der l√§cherlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Integer.getInteger</code></a> Methode: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Integer.getInteger(<span class="hljs-string"><span class="hljs-string">"moo"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Nicht jeder wei√ü, dass diese Methode eine Systemeigenschaft namens <code>moo</code> liest und, falls vorhanden, versucht, sie in eine Zahl umzuwandeln, andernfalls wird <code>null</code> .  Wenn keine Eigenschaft vorhanden ist, weisen wir dem Objekt stillschweigend <code>null</code> zu, fallen jedoch von <code>NullPointerException</code> wenn versucht wird, es einem Grundelement zuzuweisen (dort erfolgt ein automatisches Anboxing).  Es h√§tte nat√ºrlich einfacher sein k√∂nnen.  Grobe Version <code>x = null;</code>  Es wird nicht gecrawlt - es wird nicht kompiliert, aber der Compiler wird es jetzt verschlucken: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = (Integer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><h3 id="obektnyy-tip">  Objekttyp </h3><br><p>  Angenommen, Sie k√∂nnen nicht mehr mit Grundelementen spielen.  Was k√∂nnen Sie noch denken? </p><br><p>  Nun, erstens die einfachste von Dmitry vorgeschlagene Methode zur √úberladung von Methoden: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; sayWhat(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }</code> </pre> <br><p>  Die Verkn√ºpfung √ºberladener Methoden in Java erfolgt statisch in der Kompilierungsphase.  Die sayWhat <code>sayWhat(Object)</code> -Methode wird <code>sayWhat(Object)</code> Wenn wir jedoch automatisch auf den Typ <code>x</code> schlie√üen, wird der <code>String</code> <code>sayWhat(String)</code> , und daher wird die spezifischere <code>sayWhat(String)</code> -Methode verkn√ºpft. </p><br><p>  Eine andere M√∂glichkeit, einen mehrdeutigen Aufruf in Java durchzuf√ºhren, ist die Verwendung variabler Argumente (varargs).  Wouter erinnerte sich noch einmal daran: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] {}; Arrays.asList(x).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Wenn der Variablentyp <code>Object</code> , h√§lt der Compiler es f√ºr ein Variablenargument und umschlie√üt das Array mit einem anderen Array eines Elements, sodass <code>get()</code> erfolgreich erf√ºllt wird.  Wenn Sie <code>var</code> , wird der Typ <code>Object[]</code> angezeigt, und es erfolgt keine zus√§tzliche Umh√ºllung.  Auf diese Weise erhalten wir eine leere Liste und der Aufruf von <code>get()</code> schl√§gt fehl. </p><br><p>  Maccimo entschied sich f√ºr Hardcore: Er beschloss, <code>println</code> √ºber die MethodHandle-API aufzurufen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle mh = lookup.findVirtual( PrintStream.class, <span class="hljs-string"><span class="hljs-string">"println"</span></span>, MethodType.methodType(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>.class, Object.class)); mh.invokeExact(System.out, x);</code> </pre> <br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>invokeExact</code></a> Methode und mehrere andere Methoden aus dem <code>java.lang.invoke</code> haben die sogenannte "polymorphe Signatur".  Obwohl es als die √ºbliche vararg <code>invokeExact(Object... args)</code> Methode <code>invokeExact(Object... args)</code> deklariert ist, tritt es beim Standard-Array-Packen nicht auf.  Stattdessen wird im Bytecode eine Signatur generiert, die den tats√§chlich √ºbergebenen Argumenttypen entspricht.  Die <code>invokeExact</code> Methode wurde f√ºr den superschnellen Aufruf von Methodenhandles entwickelt, sodass keine Standardargumenttransformationen wie Casting oder Boxing ausgef√ºhrt werden.  Es wird erwartet, dass der Typ der Handle-Methode genau mit der Aufrufsignatur √ºbereinstimmt.  Dies wird zur Laufzeit √ºberpr√ºft, und da im Fall von <code>var</code> √úbereinstimmung unterbrochen ist, erhalten wir eine <code>WrongMethodTypeException</code> . </p><br><h3 id="dzheneriki">  Generika </h3><br><p>  Nat√ºrlich kann die Parametrisierung von Typen jeder Aufgabe in Java ein Funkeln verleihen.  Dmitry brachte eine L√∂sung mit, die dem Code √§hnelte, auf den ich urspr√ºnglich gesto√üen war.  Dmitrys Entscheidung ist ausf√ºhrlich, also werde ich zeigen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = foo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder()); System.out.println(x); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; }</code> </pre> <br><p>  Typ <code>T</code> wird als <code>StringBuilder</code> ausgegeben, aber in diesem Code muss der Compiler keine Typpr√ºfung am Dial-Peer in den Bytecode einf√ºgen.  Es reicht ihm, dass <code>StringBuilder</code> <code>Object</code> zugewiesen werden kann, was bedeutet, dass alles in Ordnung ist.  Niemand ist dagegen, dass die Methode mit dem R√ºckgabewert <code>StringBuilder</code> die Zeichenfolge tats√§chlich zur√ºckgegeben hat, wenn Sie das Ergebnis ohnehin einer Variablen vom Typ <code>Object</code> zugewiesen haben.  Der Compiler warnt ehrlich, dass Sie eine ungepr√ºfte Besetzung haben, was bedeutet, dass er seine H√§nde w√§scht.  Wenn Sie <code>x</code> durch <code>var</code> ersetzen <code>var</code> Typ <code>x</code> jedoch auch als <code>StringBuilder</code> angezeigt. Ohne Typpr√ºfung ist dies nicht mehr m√∂glich, da das Zuweisen von etwas anderem zur <code>StringBuilder</code> Typvariablen wertlos ist.  Infolgedessen st√ºrzt <code>var</code> Programm nach dem Wechsel zu <code>var</code> sicher mit einer <code>ClassCastException</code> . </p><br><p>  Wouter schlug eine Variante dieser L√∂sung mit Standardmethoden vor: </p><br><pre> <code class="java hljs">Object o = ((List&lt;String&gt;)(List)List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>)).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Zum Schluss noch eine Option von Wouter: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">""</span></span>; TreeSet&lt;?&gt; set = Stream.of(x) .collect(toCollection(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;((a, b) -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (set.contains(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Hier wird der Stream-Typ je nach Verwendung von <code>var</code> oder <code>Object</code> entweder als <code>Stream&lt;Object&gt;</code> oder als <code>Stream&lt;String&gt;</code> angezeigt.  Dementsprechend werden der <code>TreeSet</code> Typ und der Komparator-Lambda-Typ angezeigt.  Im Fall von <code>var</code> m√ºssen Zeichenfolgen zum Lambda kommen. Wenn also eine Lambda-Laufzeitdarstellung generiert wird, wird automatisch eine <code>ClassCastException</code> eingef√ºgt, die eine <code>ClassCastException</code> wenn versucht wird, eine Einheit in eine Zeichenfolge <code>ClassCastException</code> . </p><br><p>  Im Allgemeinen war das Ergebnis sehr langweilig.  Wenn Sie grundlegend andere Methoden finden k√∂nnen, um <code>var</code> zu brechen, schreiben Sie in die Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469111/">https://habr.com/ru/post/de469111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469095/index.html">ML.NET- und Model Builder-Updates ver√∂ffentlicht: Was ist neu?</a></li>
<li><a href="../de469097/index.html">CentOS 8 Webserver mit PHP7, Node.js und Redis</a></li>
<li><a href="../de469099/index.html">Testaufgaben beim Interview des Entwicklers - macht das Sinn?</a></li>
<li><a href="../de469101/index.html">Englisch lernen: wie man lernt, als Muttersprachler zu sprechen</a></li>
<li><a href="../de469109/index.html">Holzspielzeug, Teil Drei - 1989</a></li>
<li><a href="../de469115/index.html">Discovery.js-Handbuch: Schnellstart</a></li>
<li><a href="../de469117/index.html">Programmierung unter BC 0010 im Jahr 2019</a></li>
<li><a href="../de469119/index.html">Die IPv4-Adressen in RIPE sind beendet. V√∂llig vorbei ...</a></li>
<li><a href="../de469125/index.html">Dunkles Thema von Thunderbird als Grund, einen Code-Analysator auszuf√ºhren</a></li>
<li><a href="../de469127/index.html">Optimierung oder wie man sich nicht in den Fu√ü schie√üt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>