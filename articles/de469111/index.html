<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏸 🔤 👶🏾 Objekt durch var ersetzen: Was könnte schief gehen? 👩🏼‍🔬 🖲️ 😦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin kürzlich auf eine Situation gestoßen, in der das Ersetzen von Object durch var in einem Java 10-Programm zur Laufzeit eine Ausnahme auslöst. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Objekt durch var ersetzen: Was könnte schief gehen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469111/"><p>  Ich bin kürzlich auf eine Situation gestoßen, in der das Ersetzen von Object durch var in einem Java 10-Programm zur Laufzeit eine Ausnahme auslöst.  Ich interessierte mich dafür, auf wie viele verschiedene Arten dieser Effekt erzielt werden kann, und wandte mich an die Community: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1174191219620089856"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Es stellte sich heraus, dass Sie den Effekt auf verschiedene Arten erzielen können.  Obwohl alle etwas kompliziert sind, ist es interessant, sich am Beispiel einer solchen Aufgabe an die verschiedenen Feinheiten der Sprache zu erinnern.  Mal sehen, welche Methoden gefunden wurden. </p><a name="habracut"></a><br><h2 id="uchastniki">  Mitglieder </h2><br><p>  Unter den Befragten waren viele berühmte und nicht sehr Menschen.  Dies ist Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bsideup</a> Egorov, Pivotal-Mitarbeiter, Redner, einer der Schöpfer von Testcontainern.  Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Polishchuk</a> , berühmt für Berichte über das blutige Unternehmen.  Auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nikita Artyushov</a> von Google bemerkt;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Mikhailov</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maccimo</a> .  Besonders gefreut hat mich aber die Ankunft von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wouter Coekaerts</a> .  Er ist bekannt für seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel im letzten Jahr</a> , in dem er durch das Java-Typensystem ging und erzählte, wie hoffnungslos es kaputt war.  Einige dieser Artikel haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jbaruch</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ich</a> sogar in der vierten Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Puzzlers verwendet</a> . </p><br><h2 id="zadacha-i-resheniya">  Aufgabe und Lösungen </h2><br><p> Das Wesentliche unserer Aufgabe ist also: Es gibt ein Java-Programm, in dem eine Variable der Form <code>Object x = ...</code> <code>java.lang.Object</code> ist (ehrlicher Standard <code>java.lang.Object</code> , keine Typersetzungen).  Das Programm kompiliert, führt und druckt so etwas wie "Ok".  Wir ersetzen <code>Object</code> durch <code>var</code> und erfordern eine automatische Typinferenz. Danach wird das Programm weiter kompiliert, stürzt jedoch beim Start mit einer Ausnahme ab. </p><br><p>  Lösungen können grob in zwei Gruppen unterteilt werden.  Im ersten Fall wird die Variable nach dem Ersetzen durch var primitiv (dh sie war ursprünglich Autoboxing).  Der zweite Typ bleibt Objekt, aber spezifischer als <code>Object</code> .  Hier können Sie eine interessante Untergruppe hervorheben, die Generika verwendet. </p><br><h3 id="boksing">  Boxen </h3><br><p>  Wie kann man ein Objekt von einem Grundelement unterscheiden?  Es gibt viele verschiedene Möglichkeiten.  Am einfachsten ist es, die Identität zu überprüfen.  Diese Lösung wurde von Nikita vorgeschlagen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Wenn <code>x</code> ein Objekt ist, kann es unter Bezugnahme auf das neue Objekt <code>new Integer(1000)</code> sicherlich nicht gleich sein.  Und wenn es sich um ein Grundelement handelt, entfaltet sich nach den Regeln der Sprache die <code>new Integer(1000)</code> sofort auch zu einem Grundelement, und Zahlen werden als Grundelemente verglichen. </p><br><p>  Ein anderer Weg sind überladene Methoden.  Sie können Ihre eigenen schreiben, aber Sergey hat eine elegantere Option gefunden: Verwenden Sie die Standardbibliothek.  Die <code>List.remove</code> Methode ist <code>List.remove</code> , überladen und kann entweder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Element nach Index</a> entfernen, wenn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Grundelement</a> übergeben wird, oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Element nach Wert,</a> wenn ein Objekt übergeben wird.  Dies hat wiederholt zu Fehlern in realen Programmen geführt, wenn Sie <code>List&lt;Integer&gt;</code> .  Für unsere Aufgabe könnte die Lösung folgendermaßen aussehen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; List&lt;?&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.remove(x); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Jetzt versuchen wir, das nicht vorhandene Element 1000 aus der leeren Liste zu entfernen. Dies ist nur eine nutzlose Aktion.  Wenn wir <code>Object</code> durch <code>var</code> ersetzen, rufen wir eine andere Methode auf, mit der das Element mit dem Index 1000 entfernt wird. Dies führt bereits zu <code>IndexOutOfBoundsException</code> . </p><br><p>  Die dritte Methode ist der Typkonvertierungsoperator.  Wir können ein anderes Grundelement erfolgreich in einen Grundelementtyp konvertieren, aber ein Objekt wird nur konvertiert, wenn es einen Wrapper über denselben Typ gibt, in den wir konvertieren werden (dann wird Anboxing stattfinden).  Eigentlich brauchen wir den gegenteiligen Effekt: Eine Ausnahme ist im Fall eines Grundelements und nicht im Fall eines Objekts, aber mit Try-Catch ist dies leicht zu erreichen, was Viktor verwendet hat: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Oops :"</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)x); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassCastException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Hier ist <code>ClassCastException</code> das erwartete Verhalten, dann wird das Programm normal beendet.  Aber nach der Verwendung von <code>var</code> verschwindet diese Ausnahme und wir werfen etwas anderes.  Ich frage mich, ob dies vom echten Code des blutigen Unternehmens inspiriert ist. </p><br><p>  Eine andere Option zur Typkonvertierung wurde von Wouter vorgeschlagen.  Sie können die seltsame Logik des Operators verwenden <code>?:</code> .  Der Code liefert zwar nur unterschiedliche Ergebnisse, daher müssen Sie ihn irgendwie ändern, damit es eine Ausnahme gibt.  So scheint es mir ganz elegant: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; System.out.println(String.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ? x : <span class="hljs-number"><span class="hljs-number">100000000000L</span></span>).substring(<span class="hljs-number"><span class="hljs-number">12</span></span>) + <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Der Unterschied zwischen dieser Methode besteht darin, dass wir den Wert von <code>x</code> direkt verwenden, sondern dass der Typ <code>x</code> den Typ des Ausdrucks <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> .  Wenn <code>x</code> ein <code>Object</code> , dann ist der Typ des gesamten Ausdrucks <code>Object</code> , und dann haben wir nur Boxing. <code>String.valueOf()</code> gibt <code>String.valueOf()</code> Zeichenfolge von <code>100000000000</code> , für die <code>substring(12)</code> eine leere Zeichenfolge ist.  Wenn Sie <code>var</code> , wird der Typ <code>x</code> <code>double</code> und daher der Typ <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> ebenfalls <code>double</code> , <code>1.0E11</code> <code>100000000000L</code> wird zu <code>1.0E11</code> , wo es viel weniger als 12 Zeichen sind. Das Aufrufen von <code>substring</code> führt also zu einer <code>StringIndexOutOfBoundsException</code> . </p><br><p>  Schließlich nutzen wir die Tatsache, dass eine Variable nach der Erstellung tatsächlich geändert werden kann.  Und in der Objektvariablen können Sie im Gegensatz zum Grundelement <code>null</code> setzen.  Das Einfügen von <code>null</code> in eine Variable ist einfach, es gibt viele Möglichkeiten.  Aber auch hier verfolgte Wouter einen kreativen Ansatz mit der lächerlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Integer.getInteger</code></a> Methode: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Integer.getInteger(<span class="hljs-string"><span class="hljs-string">"moo"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Nicht jeder weiß, dass diese Methode eine Systemeigenschaft namens <code>moo</code> liest und, falls vorhanden, versucht, sie in eine Zahl umzuwandeln, andernfalls wird <code>null</code> .  Wenn keine Eigenschaft vorhanden ist, weisen wir dem Objekt stillschweigend <code>null</code> zu, fallen jedoch von <code>NullPointerException</code> wenn versucht wird, es einem Grundelement zuzuweisen (dort erfolgt ein automatisches Anboxing).  Es hätte natürlich einfacher sein können.  Grobe Version <code>x = null;</code>  Es wird nicht gecrawlt - es wird nicht kompiliert, aber der Compiler wird es jetzt verschlucken: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = (Integer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><h3 id="obektnyy-tip">  Objekttyp </h3><br><p>  Angenommen, Sie können nicht mehr mit Grundelementen spielen.  Was können Sie noch denken? </p><br><p>  Nun, erstens die einfachste von Dmitry vorgeschlagene Methode zur Überladung von Methoden: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; sayWhat(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }</code> </pre> <br><p>  Die Verknüpfung überladener Methoden in Java erfolgt statisch in der Kompilierungsphase.  Die sayWhat <code>sayWhat(Object)</code> -Methode wird <code>sayWhat(Object)</code> Wenn wir jedoch automatisch auf den Typ <code>x</code> schließen, wird der <code>String</code> <code>sayWhat(String)</code> , und daher wird die spezifischere <code>sayWhat(String)</code> -Methode verknüpft. </p><br><p>  Eine andere Möglichkeit, einen mehrdeutigen Aufruf in Java durchzuführen, ist die Verwendung variabler Argumente (varargs).  Wouter erinnerte sich noch einmal daran: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] {}; Arrays.asList(x).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Wenn der Variablentyp <code>Object</code> , hält der Compiler es für ein Variablenargument und umschließt das Array mit einem anderen Array eines Elements, sodass <code>get()</code> erfolgreich erfüllt wird.  Wenn Sie <code>var</code> , wird der Typ <code>Object[]</code> angezeigt, und es erfolgt keine zusätzliche Umhüllung.  Auf diese Weise erhalten wir eine leere Liste und der Aufruf von <code>get()</code> schlägt fehl. </p><br><p>  Maccimo entschied sich für Hardcore: Er beschloss, <code>println</code> über die MethodHandle-API aufzurufen: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle mh = lookup.findVirtual( PrintStream.class, <span class="hljs-string"><span class="hljs-string">"println"</span></span>, MethodType.methodType(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>.class, Object.class)); mh.invokeExact(System.out, x);</code> </pre> <br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>invokeExact</code></a> Methode und mehrere andere Methoden aus dem <code>java.lang.invoke</code> haben die sogenannte "polymorphe Signatur".  Obwohl es als die übliche vararg <code>invokeExact(Object... args)</code> Methode <code>invokeExact(Object... args)</code> deklariert ist, tritt es beim Standard-Array-Packen nicht auf.  Stattdessen wird im Bytecode eine Signatur generiert, die den tatsächlich übergebenen Argumenttypen entspricht.  Die <code>invokeExact</code> Methode wurde für den superschnellen Aufruf von Methodenhandles entwickelt, sodass keine Standardargumenttransformationen wie Casting oder Boxing ausgeführt werden.  Es wird erwartet, dass der Typ der Handle-Methode genau mit der Aufrufsignatur übereinstimmt.  Dies wird zur Laufzeit überprüft, und da im Fall von <code>var</code> Übereinstimmung unterbrochen ist, erhalten wir eine <code>WrongMethodTypeException</code> . </p><br><h3 id="dzheneriki">  Generika </h3><br><p>  Natürlich kann die Parametrisierung von Typen jeder Aufgabe in Java ein Funkeln verleihen.  Dmitry brachte eine Lösung mit, die dem Code ähnelte, auf den ich ursprünglich gestoßen war.  Dmitrys Entscheidung ist ausführlich, also werde ich zeigen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = foo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder()); System.out.println(x); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; }</code> </pre> <br><p>  Typ <code>T</code> wird als <code>StringBuilder</code> ausgegeben, aber in diesem Code muss der Compiler keine Typprüfung am Dial-Peer in den Bytecode einfügen.  Es reicht ihm, dass <code>StringBuilder</code> <code>Object</code> zugewiesen werden kann, was bedeutet, dass alles in Ordnung ist.  Niemand ist dagegen, dass die Methode mit dem Rückgabewert <code>StringBuilder</code> die Zeichenfolge tatsächlich zurückgegeben hat, wenn Sie das Ergebnis ohnehin einer Variablen vom Typ <code>Object</code> zugewiesen haben.  Der Compiler warnt ehrlich, dass Sie eine ungeprüfte Besetzung haben, was bedeutet, dass er seine Hände wäscht.  Wenn Sie <code>x</code> durch <code>var</code> ersetzen <code>var</code> Typ <code>x</code> jedoch auch als <code>StringBuilder</code> angezeigt. Ohne Typprüfung ist dies nicht mehr möglich, da das Zuweisen von etwas anderem zur <code>StringBuilder</code> Typvariablen wertlos ist.  Infolgedessen stürzt <code>var</code> Programm nach dem Wechsel zu <code>var</code> sicher mit einer <code>ClassCastException</code> . </p><br><p>  Wouter schlug eine Variante dieser Lösung mit Standardmethoden vor: </p><br><pre> <code class="java hljs">Object o = ((List&lt;String&gt;)(List)List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>)).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Zum Schluss noch eine Option von Wouter: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">""</span></span>; TreeSet&lt;?&gt; set = Stream.of(x) .collect(toCollection(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;((a, b) -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (set.contains(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Hier wird der Stream-Typ je nach Verwendung von <code>var</code> oder <code>Object</code> entweder als <code>Stream&lt;Object&gt;</code> oder als <code>Stream&lt;String&gt;</code> angezeigt.  Dementsprechend werden der <code>TreeSet</code> Typ und der Komparator-Lambda-Typ angezeigt.  Im Fall von <code>var</code> müssen Zeichenfolgen zum Lambda kommen. Wenn also eine Lambda-Laufzeitdarstellung generiert wird, wird automatisch eine <code>ClassCastException</code> eingefügt, die eine <code>ClassCastException</code> wenn versucht wird, eine Einheit in eine Zeichenfolge <code>ClassCastException</code> . </p><br><p>  Im Allgemeinen war das Ergebnis sehr langweilig.  Wenn Sie grundlegend andere Methoden finden können, um <code>var</code> zu brechen, schreiben Sie in die Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469111/">https://habr.com/ru/post/de469111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469095/index.html">ML.NET- und Model Builder-Updates veröffentlicht: Was ist neu?</a></li>
<li><a href="../de469097/index.html">CentOS 8 Webserver mit PHP7, Node.js und Redis</a></li>
<li><a href="../de469099/index.html">Testaufgaben beim Interview des Entwicklers - macht das Sinn?</a></li>
<li><a href="../de469101/index.html">Englisch lernen: wie man lernt, als Muttersprachler zu sprechen</a></li>
<li><a href="../de469109/index.html">Holzspielzeug, Teil Drei - 1989</a></li>
<li><a href="../de469115/index.html">Discovery.js-Handbuch: Schnellstart</a></li>
<li><a href="../de469117/index.html">Programmierung unter BC 0010 im Jahr 2019</a></li>
<li><a href="../de469119/index.html">Die IPv4-Adressen in RIPE sind beendet. Völlig vorbei ...</a></li>
<li><a href="../de469125/index.html">Dunkles Thema von Thunderbird als Grund, einen Code-Analysator auszuführen</a></li>
<li><a href="../de469127/index.html">Optimierung oder wie man sich nicht in den Fuß schießt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>