<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍨 👩🏽‍🤝‍👨🏻 💪🏿 Classificações de Câmbio 🕓 👇🏼 🌳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você descrever em algumas frases sobre qual princípio as trocas de classificação funcionam, então: 



1. Elementos de matriz são comparados em par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classificações de Câmbio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414653/"><div style="text-align:center;"><img width="700" height="312" src="https://habrastorage.org/webt/cf/xj/x_/cfxjx_qzr1qqhjmwvqz8eyygnxm.png"></div><br><br>  Se você descrever em algumas frases sobre qual princípio as trocas de classificação funcionam, então: <br><br><ol><li>  Elementos de matriz são comparados em pares </li><li>  Se o elemento à esquerda <sup>* for</sup> maior que o elemento à direita, os elementos serão trocados </li><li>  Repita as etapas 1 a 2 até a matriz ser classificada </li></ol><br>  <sup><em>* - o elemento à esquerda significa aquele do par comparado, mais próximo da borda esquerda da matriz.</em></sup>  <sup><em>Consequentemente, o elemento à direita está mais próximo da borda direita.</em></sup> <br><a name="habracut"></a><br>  Peço desculpas imediatamente por repetir material conhecido. É improvável que pelo menos um dos algoritmos deste artigo seja uma revelação para você.  Sobre essas classificações em Habré, ele já foi escrito várias vezes (inclusive eu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> ) e pergunta por que novamente para voltar a esse tópico?  Mas desde que decidi escrever uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">série coerente de artigos sobre todas as classificações no mundo</a> , tenho que passar pelos métodos de troca, mesmo na versão expressa.  Ao considerar as seguintes classes, já haverá muitos novos (e poucas pessoas sabem) algoritmos que merecem artigos interessantes separados. <br><br>  Tradicionalmente, "trocadores" incluem classificações nas quais os elementos mudam (pseudo) aleatoriamente (bogosort, bozosort, permsort, etc.).  No entanto, eu não os incluí nesta classe, pois eles não têm comparações.  Haverá um artigo separado sobre essas classificações, onde filosofamos muito sobre a teoria das probabilidades, combinatória e morte térmica do Universo. <br><br><h1>  Tipo parvo :: Tipo Stooge </h1><br><img width="342" height="96" src="https://habrastorage.org/web/eb5/6f6/820/eb56f6820b904324a5df67714e2c8866.gif"><br><br><ol><li>  Compare (e, se necessário, altere) os elementos nas extremidades da sub-matriz. </li><li>  Pegamos dois terços do subarray desde o início e aplicamos o algoritmo geral a esses 2/3 recursivamente. </li><li>  Pegamos dois terços da sub-matriz do seu final e aplicamos o algoritmo geral a esses 2/3 recursivamente. </li><li>  E, novamente, pegamos dois terços da sub-matriz desde o início e aplicamos o algoritmo geral a esses 2/3 recursivamente. </li></ol><br>  Inicialmente, uma sub-matriz é uma matriz inteira.  E então a recursão divide o subarray pai em 2/3, faz comparações / trocas nas extremidades dos segmentos fragmentados e, eventualmente, organiza tudo. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j = None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: j = len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &lt; data[i]: data[i], data[j] = data[j], data[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j - i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: t = (j - i + <span class="hljs-number"><span class="hljs-number">1</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> stooge_rec(data, i, j - t) stooge_rec(data, i + t, j) stooge_rec(data, i, j - t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stooge_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Parece esquizofrênico, mas, no entanto, é 100% correto. <br><br><h1>  Classificação lenta :: Classificação lenta </h1><br><img width="342" height="96" src="https://habrastorage.org/web/f31/348/4f5/f313484f5bd44ea09b50e899e3d90548.gif"><br><br>  E aqui observamos o misticismo recursivo: <br><br><ol><li>  Se o subarray consistir em um elemento, concluiremos a recursão. </li><li>  Se um subarray consistir em dois ou mais elementos, divida-o ao meio. </li><li>  Aplicamos o algoritmo recursivamente à metade esquerda. </li><li>  Aplicamos o algoritmo recursivamente à metade direita. </li><li>  Os elementos nas extremidades da sub-matriz são comparados (e alterados, se necessário). </li><li>  Aplicamos recursivamente o algoritmo a uma sub-matriz sem o último elemento. </li></ol><br><br>  Inicialmente, uma sub-matriz é a matriz inteira.  E a recursão continuará diminuindo pela metade, comparando e alterando até classificar tudo. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i, j)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data m = (i + j) // <span class="hljs-number"><span class="hljs-number">2</span></span> slow_rec(data, i, m) slow_rec(data, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[m] &gt; data[j]: data[m], data[j] = data[j], data[m] slow_rec(data, i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slow_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Parece bobagem, mas a matriz está ordenada. <br><br><h3>  Por que o StoogeSort e o SlowSort estão funcionando corretamente? </h3><br>  Um leitor curioso fará uma pergunta razoável: por que esses dois algoritmos funcionam?  Eles parecem simples, mas não é muito óbvio que você possa classificar algo assim. <br><br>  Vamos primeiro dar uma olhada na classificação lenta.  O último ponto desse algoritmo sugere que os esforços recursivos da classificação lenta visam apenas colocar o maior elemento do subarray na posição mais à direita.  Isso é especialmente perceptível se você aplicar o algoritmo a uma matriz com pedidos pendentes: <br><br><img width="342" height="96" src="https://habrastorage.org/webt/lk/mx/nu/lkmxnutci_ufoymes6b4rksoqua.gif"><br><br>  É claramente visto que em todos os níveis de recursão, os máximos migram rapidamente para a direita.  Então esses máximos, onde estão onde são necessários, são desligados do jogo: o algoritmo se autodenomina - mas sem o último elemento. <br><br>  No tipo Stooge, uma mágica semelhante acontece: <br><br><img width="672" height="454" src="https://habrastorage.org/webt/d-/pd/vj/d-pdvj8zcvmnlywcedlhkmhyfku.png"><br><br>  De fato, a ênfase também é colocada nos elementos máximos.  Somente a classificação Lenta os move para o final, um por um, e a classificação Stooge empurra um terço dos elementos do sub-arranjo (o maior deles) empurra o terço mais à direita do espaço celular. <br><br>  Nos voltamos para algoritmos, onde tudo já é bastante óbvio. <br><br><h1>  Classificação estúpida :: Classificação estúpida </h1><br><img width="336" height="109" src="https://habrastorage.org/webt/sz/i3/hh/szi3hhaimi67d84kjaivphl4a9q.gif"><br><br>  Triagem muito cuidadosa.  Vai do início da matriz até o fim e compara os elementos vizinhos.  Se dois elementos vizinhos precisassem ser trocados, por precaução, a classificação retornará ao início da matriz e começará novamente. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stupid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; data[i]: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Classificação do Gnome :: Classificação do Gnome </h1><br><img width="570" height="95" src="https://habrastorage.org/web/2af/c2a/b73/2afc2ab738d54ca1b65a0bbcac9eaa19.gif"><br><br>  Quase a mesma coisa, mas a classificação durante a troca não retorna ao início da matriz, mas leva apenas um passo para trás.  Acontece que isso é suficiente para resolver tudo. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Classificação otimizada de anões </h3><br><img width="570" height="95" src="https://habrastorage.org/web/37c/91c/9fc/37c91c9fcffd4b1a9d1f225171bbdc64.gif"><br><br>  Mas você pode economizar não apenas no recuo, mas também ao avançar.  Com várias trocas consecutivas, você precisa dar o máximo de passos para trás.  E então você precisa voltar (comparando ao longo do caminho os elementos que já estão ordenados em relação um ao outro).  Se você se lembrar da posição em que as trocas começaram, poderá saltar imediatamente para essa posição quando as trocas forem concluídas. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, j, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span>: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Classificação da bolha :: Classificação da bolha </h1><br><img width="570" height="95" src="https://habrastorage.org/web/b68/67d/5b7/b6867d5b7d064421b5f7b1f6fae6d058.gif"><br><br>  Diferentemente da classificação estúpida e gnômica, ao trocar elementos na bolha, nenhum retorno ocorre - ele continua avançando.  Chegando ao final, o maior elemento da matriz é movido para o final. <br><br>  Em seguida, o processo de classificação repete todo o processo novamente, como resultado do qual o segundo elemento na antiguidade está em último lugar.  Na próxima iteração, o terceiro maior elemento é o terceiro do final, etc. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> changed: changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Classificação de bolha otimizada </h3><br><img width="570" height="95" src="https://habrastorage.org/web/ca0/9e7/20f/ca09e720f56c417bbbb8204aa8c35a7d.gif"><br><br>  Você pode lucrar um pouco com os passes no início da matriz.  No processo, os primeiros elementos são ordenados temporariamente um em relação ao outro (essa peça classificada muda constantemente de tamanho - diminui, aumenta).  Isso é facilmente corrigido e, com uma nova iteração, você pode simplesmente pular um grupo desses elementos. <br>  <sub><em>(Adicionarei a implementação testada no Python aqui um pouco mais tarde. Não tive tempo para prepará-la.)</em></sub> <br><br><br><h1>  Classificação Shaker :: Classificação Shaker <br>  (Tipo Cocktail :: Tipo Cocktail) </h1><br><img width="570" height="95" src="https://habrastorage.org/web/616/739/0f8/6167390f8005452e8dbcbeeacb5c95fc.gif"><br><br>  Uma espécie de bolha.  Na primeira passagem, como de costume - empurre o máximo até o fim.  Então damos uma volta brusca e empurramos o mínimo para o começo.  As áreas marginais classificadas da matriz aumentam de tamanho após cada iteração. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> up = range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (up, reversed(up)): swapped = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] swapped = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> swapped: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Classificação ímpar-par :: Classificação ímpar-par </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yn/9t/oy/yn9toy8yjzuud4azxdffcb-6mwm.gif"><br><br>  Mais uma vez, iterações sobre comparação pareada de elementos vizinhos ao mover da esquerda para a direita.  Primeiro, compare os pares nos quais o primeiro elemento é ímpar na contagem e o segundo é par (ou seja, o primeiro e o segundo, o terceiro e o quarto, o quinto e o sexto, etc.).  E então vice-versa - par + ímpar (segundo e terceiro, quarto e quinto, sexto e sétimo, etc.).  Nesse caso, muitos elementos grandes da matriz em uma iteração ao mesmo tempo dão um passo à frente (na bolha, o maior da iteração chega ao fim, mas o restante dos quase grandes quase permanece no lugar). <br><br>  A propósito, este era originalmente um tipo paralelo com O (n) complexidade.  Será necessário implementar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AlgoLab</a> na seção "Classificação paralela". <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd_even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> n = len(data) isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isSorted == <span class="hljs-number"><span class="hljs-number">0</span></span>: isSorted = <span class="hljs-number"><span class="hljs-number">1</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Classificação do pente :: Classificação do pente </h1><br><img width="570" height="95" src="https://habrastorage.org/web/52f/41b/2fb/52f41b2fbd024cf8b9dfdba8d0dbd239.gif"><br><br>  A modificação mais bem sucedida da bolha.  O algoritmo de velocidade compete com a classificação rápida. <br><br>  Em todas as variações anteriores, comparamos os vizinhos.  E aqui, primeiro, são considerados pares de elementos que estão a uma distância máxima um do outro.  A cada nova iteração, essa distância diminui uniformemente. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> gap = len(data) swaps = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> gap &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swaps: gap = max(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(gap / <span class="hljs-number"><span class="hljs-number">1.25</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># minimum gap is 1 swaps = False for i in range(len(data) - gap): j = i + gap if data[i] &gt; data[j]: data[i], data[j] = data[j], data[i] swaps = True return data</span></span></code> </pre> <br><br><h1>  Classificação rápida :: Classificação rápida </h1><br><img width="684" height="95" src="https://habrastorage.org/webt/b1/xb/ve/b1xbvefydxsfynp91mnxaxluvfe.gif"><br><br>  Bem, o algoritmo de troca mais avançado. <br><br><ol><li>  Divida a matriz ao meio.  O elemento do meio é a referência. </li><li>  Passamos da borda esquerda da matriz para a direita, até encontrarmos um elemento que é maior que o de referência. </li><li>  Passamos da borda direita da matriz para a esquerda até encontrarmos um elemento menor que o de referência. </li><li>  Trocamos os dois elementos encontrados nos pontos 2 e 3. </li><li>  Continuamos a executar os itens 2-3-4 até que uma reunião ocorra como resultado do movimento mútuo. </li><li>  No ponto de encontro, a matriz é dividida em duas partes.  Para cada parte, aplicamos recursivamente um algoritmo de classificação rápida. </li></ol><br>  Por que isso funciona?  À esquerda do ponto de encontro, existem elementos menores ou iguais ao ponto de referência.  À direita do ponto de encontro, existem elementos maiores ou iguais à referência.  Ou seja, qualquer elemento do lado esquerdo é menor ou igual a qualquer elemento do lado direito.  Portanto, no ponto de encontro, a matriz pode ser dividida com segurança em dois subarrays e classificar cada subarray de maneira semelhante recursivamente. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> less = [] pivotList = [] more = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivot = data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; pivot: less.append(i) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i &gt; pivot: more.append(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivotList.append(i) less = quick(less) more = quick(more) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> less + pivotList + more</code> </pre> <br><br><h1>  K-sort :: K-sort </h1><br>  Em Habré, é publicada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma tradução de</a> um dos artigos, que relata a modificação do QuickSort, que supera a classificação piramidal em 7 milhões de elementos.  A propósito, isso por si só é uma conquista duvidosa, porque a classificação piramidal clássica não quebra os recordes de desempenho.  Em particular, sua complexidade assintótica sob nenhuma circunstância atinge O (n) (uma característica deste algoritmo). <br><br>  Mas a coisa é diferente.  De acordo com o pseudocódigo do autor (e obviamente incorreto), geralmente não é possível entender qual é, de fato, a principal idéia do algoritmo.  Pessoalmente, tive a impressão de que os autores são alguns criminosos que agiram de acordo com este método: <br><ol><li>  Declaramos a invenção de um algoritmo de super-classificação. </li><li>  Reforçamos a declaração com um pseudo-código não funcional e incompreensível (como inteligente e claro, mas os tolos ainda não conseguem entender). </li><li>  Apresentamos gráficos e tabelas que supostamente demonstram a velocidade prática do algoritmo em big data.  Devido à falta de um código realmente funcional, ninguém ainda poderá verificar ou refutar esses cálculos estatísticos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Publicamos bobagens</a> em Arxiv.org sob o disfarce de um artigo científico. </li><li>  LUCRO !!! </li></ol><br>  Talvez eu esteja falando em vão para as pessoas e, de fato, o algoritmo está funcionando?  Alguém pode explicar como o k-sort funciona? <br><br>  <strong>UPD</strong>  <strong>Minhas acusações completas de classificar autores de fraude acabaram sendo infundadas :) O usuário <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">jetsys</a> descobriu o pseudo-código do algoritmo, escreveu uma versão de trabalho em PHP e me enviou em mensagens privadas:</strong> <br><br><div class="spoiler">  <b class="spoiler_title">Classificação K em PHP</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a,$left,$right)</span></span></span></span>{ $ke=$a[$left]; $i=$left; $j=$right+<span class="hljs-number"><span class="hljs-number">1</span></span>; $k=$p=$left+<span class="hljs-number"><span class="hljs-number">1</span></span>; $temp=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j-$i&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($ke&lt;=$a[$p]){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($p!=$j) &amp;&amp; ($j!=($right+<span class="hljs-number"><span class="hljs-number">1</span></span>))){ $a[$j]=$a[$p]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($j==($right+<span class="hljs-number"><span class="hljs-number">1</span></span>)){ $temp=$a[$p]; } $j--; $p=$j; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a[$i]=$a[$p]; $i++; $k++; $p=$k; } } $a[$i]=$ke; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($temp) $a[$i+<span class="hljs-number"><span class="hljs-number">1</span></span>]=$temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($left&lt;($i<span class="hljs-number"><span class="hljs-number">-1</span></span>)) _ksort($a,$left,$i<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($right&gt;($i+<span class="hljs-number"><span class="hljs-number">1</span></span>)) _ksort($a,$i+<span class="hljs-number"><span class="hljs-number">1</span></span>,$right); }</code> </pre> </div></div><br><br><h2>  Anúncio </h2><br>  Era tudo uma teoria, é hora de começar a praticar.  O próximo artigo está testando trocas de classificação em diferentes conjuntos de dados.  Vamos descobrir: <br><br><ul><li>  Que classificação é a pior - boba, sem graça ou sem graça? </li><li>  Otimizações e modificações na classificação de bolhas realmente ajudam? </li><li>  Sob quais condições os algoritmos lentos são facilmente rápidos na velocidade do QuickSort? </li></ul><br><br>  E quando descobrimos as respostas para essas perguntas mais importantes, podemos começar a estudar as próximas aulas - tipos de inserção. <br><br><h1>  Referências </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativo AlgoLab do Excel</a> , com o qual você pode visualizar passo a passo a visualização desses tipos (e não apenas deles). <br><br>  <b>Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Parvo</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pateta</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Lento</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Anão</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Gnomo</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Bolha</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Bolha</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Agitador</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Agitador</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Ímpar</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Par</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pente</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Pente</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Rápido</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Rápido</a></nobr> <br><br><h3>  Artigos da série </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativo Excel AlgoLab.xlsm</a> </li><li>  <b>Classificações de Câmbio</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação de Classificação do Exchange</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificações de inserção</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificar por seleção</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mesclar classificações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificar por distribuição</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificação híbrida</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414653/">https://habr.com/ru/post/pt414653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414639/index.html">Serviços de hackers na Internet escura</a></li>
<li><a href="../pt414641/index.html">Domando XBRL: Notas dos analistas</a></li>
<li><a href="../pt414643/index.html">Codificação da loja: vencedores do hackathon M.SMART</a></li>
<li><a href="../pt414645/index.html">ONETRAK - pulseiras inteligentes e muito mais</a></li>
<li><a href="../pt414651/index.html">Scanner 3D Shining 3D Einscan SE. Visão geral do scanner 3D</a></li>
<li><a href="../pt414655/index.html">Roteador virtual DD-WRT x86 no VirtualBox</a></li>
<li><a href="../pt414657/index.html">Protocolo AMF3 perigoso</a></li>
<li><a href="../pt414661/index.html">O veículo de lançamento Soyuz-5SL funcionará com motores de estilo soviético</a></li>
<li><a href="../pt414663/index.html">Burnout profissional: uma palavra para especialistas</a></li>
<li><a href="../pt414667/index.html">[Tema de mini-fã] Tabela do campeonato da FIFA no terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>