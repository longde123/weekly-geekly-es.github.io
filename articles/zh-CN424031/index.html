<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍚 🤰🏻 👩🏼‍✈️ 使用JAX-RS进行反应式编程 🗾 🤟 🤬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 

 去年， Java Enterprise Developer课程已经成功启动，并且我们想与您分享该主题的最新资料，其中讨论了异步方法的使用以及开发响应式响应应用程序的阶段。 

 走吧 

 起初，响应式编程听起来像新兴范式的名称，但实际上是指一种编程方法，其中使用面向事件的方法来处理...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用JAX-RS进行反应式编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424031/">大家好！ <br><br> 去年， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java Enterprise Developer</a>课程已经成功启动，并且我们想与您分享该主题的最新资料，其中讨论了异步方法的使用以及开发响应式响应应用程序的阶段。 <br><br> 走吧 <br><br> 起初，响应式编程听起来像新兴范式的名称，但实际上是指一种编程方法，其中使用面向事件的方法来处理异步数据流。 基于持续不断的数据，反应性系统通过执行一系列事件来响应它们。 <br> 响应式编程遵循“观察者”设计模式，该模式可以定义如下：如果一个对象的状态发生变化，则将通知所有其他对象并相应地对其进行更新。 因此，不是轮询事件的更改，而是异步推送事件，以便观察者可以对其进行处理。 在此示例中，观察者是在调度事件时执行的功能。 提到的数据流是实际可观察​​到的。 <br><br> 几乎所有语言和框架都在其生态系统中使用此方法，并且Java的最新版本也不例外。 在本文中，我将解释如何使用Java EE 8和Java 8功能中的最新版本的JAX-RS应用反应式编程。 <br><br><img src="https://habrastorage.org/webt/zp/g6/dr/zpg6dry4ynjfjnr6y6fkmkluoea.png"><a name="habracut"></a><br><br>  <b>喷气宣言</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jet宣言</a>列出了四个基本方面，即应用程序需要更加灵活，松耦合，易于扩展并因此具有响应能力。 它指出，应用程序必须具有响应能力，灵活性（因此具有可伸缩性），弹性和消息驱动能力。 <br><br> 基本目标是真正响应的应用程序。 假设有一个应用程序，其中一个大线程参与处理用户请求，并且在完成工作之后，该线程将响应发送回原始请求者。 当应用程序收到的请求数超出其处理能力时，此线程将成为瓶颈，并且该应用程序将失去其以前的响应能力。 为了保持响应能力，应用程序必须是可伸缩的和可恢复的。 可持续性可以被视为具有自动恢复功能的应用程序。 根据大多数开发人员的经验，只有消息驱动的体系结构才能使应用程序具有可伸缩性，弹性和响应能力。 <br><br> 在Java 8和Java EE 8中引入了反应式编程。Java引入了诸如<code>CompletionStage</code>及其实现<code>CompletableFuture</code>概念，并且Java开始在规范中使用这些功能，例如JAX-RS中的Reactive Client API。 <br><br>  <b>JAX-RS 2.1反应性客户端API</b> <br><br> 让我们看看如何在Java EE 8应用程序中使用反应式编程。要了解该过程，您需要一些Java EE API的基础知识。 <br><br>  JAX-RS 2.1引入了一种新的方法来创建支持响应式编程的REST客户端。  JAX-RS中提供的默认调用程序实现是同步的，这意味着创建的客户端将向服务器的端点发送阻塞调用。 清单1给出了一个示例实现。 <br><br> 清单1 <br><br><pre> <code class="java hljs">Response response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .get();</code> </pre> <br> 从2.0版开始，JAX-RS提供对在客户端API上创建异步调用程序的支持，只需调用<code>async()</code>方法即可，如清单2所示。 <br><br> 清单2 <br><br><pre> <code class="java hljs">Future&lt;Response&gt; response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .async() .get();</code> </pre> <br> 在客户端上使用异步调用程序将返回类型为<code>javax.ws.rs.core.Response</code>的<code>Future</code>实例。 这可能导致通过调用<code>future.get()</code>来轮询响应，或者注册在HTTP响应可用时将调用的回调。 两种实现方式都适合异步编程，但是如果要将回调分组或向这些异步执行最小值添加条件大小写，事情通常会变得复杂。 <br><br>  JAX-RS 2.1通过用于构建客户端的新JAX-RS Reactive Client API提供了一种克服这些问题的反应方式。 就像在客户端构建期间调用<code>rx()</code>方法一样简单。 在清单3中， <code>rx()</code>方法返回在客户端执行期间存在的反应式调用程序，并且客户端返回类型为<code>CompletionStage.rx()</code>的响应，该响应允许通过简单调用从同步调用程序过渡到异步调用程序。 <br><br> 清单3 <br><br><pre> <code class="java hljs">CompletionStage&lt;Response&gt; response = ClientBuilder.newClient() .target(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/service-url"</span></span>) .request() .rx() .get();</code> </pre> <br>  <code>CompletionStage&lt;&gt;</code>是Java 8中引入的新接口。顾名思义， <code>CompletionStage&lt;&gt;</code>表示一个计算，可以作为较大计算框架的一个步骤。 这是唯一一个使用JAX-RS的Java 8反应性代表。 <br> 接收到响应实例之后，我可以调用<code>AcceptAsync()</code> ，在其中提供一段代码，当响应可用时，它将异步执行，如清单4所示。 <br><br> 清单4 <br><br><pre> <code class="java hljs">response.thenAcceptAsync(res -&gt; { Temperature t = res.readEntity(Temperature.class); <span class="hljs-comment"><span class="hljs-comment">//do stuff with t });</span></span></code> </pre> <br>  <b>向端点REST添加反应性</b> <br><br> 反应性方法不仅限于JAX-RS中的客户端； 它也可以在服务器端使用。 例如，首先，我将创建一个简单的脚本，在其中可以请求一个目的地的位置列表。 对于每个位置，我将使用位置数据进行单独调用到另一个点以获取温度值。 目的地的交互将如图1所示。 <br><br><img src="https://habrastorage.org/webt/rd/zr/cr/rdzrcrvbeyyfkp_bc5szid_t9au.png"><br>  <i>图1.目标点之间的交互</i> <br><br> 首先，我只定义域模型，然后定义每个模型的服务。 清单5显示了如何定义<code>Forecast</code>类，该类包装了<code>Location</code>和<code>Temperature</code>类。 <br><br> 清单5 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Temperature</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Double temperature; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String scale; <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters } public class Location { String name; public Location() {} public Location(String name) { this.name = name; } // getters &amp; setters } public class Forecast { private Location location; private Temperature temperature; public Forecast(Location location) { this.location = location; } public Forecast setTemperature( final Temperature temperature) { this.temperature = temperature; return this; } // getters }</span></span></code> </pre> <br> 为了包装预测列表，清单6中实现了<code>ServiceResponse</code>类。 <br><br> 清单6 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> processingTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Forecast&gt; forecasts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setProcessingTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> processingTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingTime = processingTime; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServiceResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forecasts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Forecast&gt; forecasts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecasts = forecasts; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// getters }</span></span></code> </pre> <br> 清单7中所示<code>LocationResource</code>定义了三个用<code>/location</code>路径返回的示例位置。 <br><br> 清单7 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocationResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Location&gt; locations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"London"</span></span>)); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span>)); locations.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-string"><span class="hljs-string">"Prague"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericEntity&lt;List&lt;Location&gt;&gt;(locations){}).build(); } }</code> </pre> <br> 清单8中显示<code>TemperatureResource</code>返回给定位置的30到50之间的随机生成的温度值。 已将500 ms的延迟添加到实现中，以模拟传感器读取。 <br><br> 清单8 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/temperature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemperatureResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/{city}"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"city"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String cityName) </span></span>{ Temperature temperature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Temperature(); temperature.setTemperature((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(<span class="hljs-number"><span class="hljs-number">20</span></span>) + <span class="hljs-number"><span class="hljs-number">30</span></span>)); temperature.setScale(<span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ignored) { ignored.printStackTrace(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(temperature).build(); } }</code> </pre> <br> 首先，我将展示同步<code>ForecastResource</code>的实现（请参见清单9），该实现返回所有位置。 然后，对于每个位置，他致电温度服务部门以摄氏度为单位获取值。 <br><br> 清单9 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/forecast"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForecastResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget locationTarget; <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"temperature/{city}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget temperatureTarget; <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocationsWithTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime = System.currentTimeMillis(); ServiceResponse response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceResponse(); List&lt;Location&gt; locations = locationTarget .request() .get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericType&lt;List&lt;Location&gt;&gt;(){}); locations.forEach(location -&gt; { Temperature temperature = temperatureTarget .resolveTemplate(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, location.getName()) .request() .get(Temperature.class); response.getForecasts().add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Forecast(location).setTemperature(temperature)); }); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> endTime = System.currentTimeMillis(); response.setProcessingTime(endTime - startTime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok(response).build(); } }</code> </pre> <br> 当将预测目标请求为<code>/forecast</code> ，您将获得类似于清单10所示的输出。请注意，请求处理时间为1.533 ms，这是合乎逻辑的，因为来自三个不同位置的温度值同步请求总计为1.5。毫秒 <br><br> 清单10 <br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"forecasts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"London"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">38</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Prague"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">46</span></span> } } ], <span class="hljs-string"><span class="hljs-string">"processingTime"</span></span>: <span class="hljs-number"><span class="hljs-number">1533</span></span> }</code> </pre><br> 到目前为止，一切都按计划进行。 现在是时候在服务器端引入反应式编程了，可以在接收到所有位置之后并行调用每个位置。 这可以明显改善前面显示的同步流。 清单11中完成了该操作，其中显示了被动预测服务版本的定义。 <br><br> 清单11 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/reactiveForecast"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForecastReactiveResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"location"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget locationTarget; <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"temperature/{city}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebTarget temperatureTarget; <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.APPLICATION_JSON) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocationsWithTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Suspended </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AsyncResponse async)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">//   (stage)    CompletionStage&lt;List&lt;Location&gt;&gt; locationCS = locationTarget.request() .rx() .get(new GenericType&lt;List&lt;Location&gt;&gt;() {}); //      , //  ,   , //    CompletionStage final CompletionStage&lt;List&lt;Forecast&gt;&gt; forecastCS = locationCS.thenCompose(locations -&gt; { //      //   ompletionStage List&lt;CompletionStage&lt;Forecast&gt;&gt; forecastList = //      //     locations.stream().map(location -&gt; { //     //      //    final CompletionStage&lt;Temperature&gt; tempCS = temperatureTarget .resolveTemplate("city", location.getName()) .request() .rx() .get(Temperature.class); //   CompletableFuture,   //    //      return CompletableFuture.completedFuture( new Forecast(location)) .thenCombine(tempCS, Forecast::setTemperature); }).collect(Collectors.toList()); //    CompletableFuture, //     completable future //  return CompletableFuture.allOf( forecastList.toArray( new CompletableFuture[forecastList.size()])) .thenApply(v -&gt; forecastList.stream() .map(CompletionStage::toCompletableFuture) .map(CompletableFuture::join) .collect(Collectors.toList())); }); //   ServiceResponse, //       //    . //   future    // forecastCS,    //      CompletableFuture.completedFuture( new ServiceResponse()) .thenCombine(forecastCS, ServiceResponse::forecasts) .whenCompleteAsync((response, throwable) -&gt; { response.setProcessingTime( System.currentTimeMillis() - startTime); async.resume(response); }); } }</span></span></code> </pre> <br> 乍一看，响应式实现似乎很复杂，但是经过更仔细的研究，您会发现它很简单。 在<code>ForecastReactiveResource</code>的实现中<code>ForecastReactiveResource</code>我首先使用JAX-RS Reactive Client API创建对定位服务的客户端调用。 正如我上面提到的，这是Java EE 8的附加组件，它有助于使用<code>rx()</code>方法创建响应式调用。 <br><br> 现在，我将根据位置创建一个新阶段，以汇总预测列表。 它们将作为一个预测列表存储在一个称为<code>forecastCS</code>大型完成阶段中。 最终，我将仅使用<code>forecastCS</code>创建服务调用响应。 <br><br> 现在，让我们以变量<code>forecastList</code>定义的完成阶段列表的形式收集<code>forecastList</code> 。 为了为每个预测创建一个完成阶段，我按位置传递数据，然后再次使用JAX-RS Reactive Client API创建<code>tempCS</code>变量，该API调用城市名称的温度服务。 在这里，我使用<code>resolveTemplate()</code>方法构建客户端，这使我可以将城市名称作为参数传递给收集器。 <br><br> 作为流式传输的最后一步，我调用<code>CompletableFuture.completedFuture()</code> ，并将新的<code>Forecast</code>实例作为参数传递。 我将这一未来与<code>tempCS</code>阶段结合在一起，以便获得所监视位置的温度值。 <br><br> 清单11中的<code>CompletableFuture.allOf()</code>方法将完成阶段列表转换为<code>forecastCS</code> 。 当所有提供的可完成的将来对象完成时，执行此步骤将返回一个大型的可完成的将来实例。 <br><br> 服务响应是<code>ServiceResponse</code>类的实例，因此我创建了一个完成的Future，然后将<code>forecastCS</code>完成阶段与预测列表结合起来并计算服务响应时间。 <br><br> 当然，反应式编程会强制服务器端仅异步运行； 在服务器将响应发送回请求者之前，客户端将一直处于阻塞状态。 为了克服此问题，服务器发送事件（SSE）可用于在响应可用时立即部分发送响应，以便将每个位置的温度值一个一个地传输到客户端。  <code>ForecastReactiveResource</code>的输出将类似于清单12中的输出。如输出中所示，处理时间为515 ms，这是从一个位置获取温度值的理想运行时间。 <br><br> 清单12 <br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"forecasts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"London"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">49</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Istanbul"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"location"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Prague"</span></span> }, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: { <span class="hljs-string"><span class="hljs-string">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"Celsius"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span> } } ], <span class="hljs-string"><span class="hljs-string">"processingTime"</span></span>: <span class="hljs-number"><span class="hljs-number">515</span></span> }</code> </pre> <br>  <b>结论</b> <br><br> 在本文的示例中，我首先展示了一种使用位置和温度服务获取预报的同步方法。 然后，我转到了反应性方法，以便在服务调用之间执行异步处理。 当您将Java EE 8中的JAX-RS Reactive Client API与Jav​​a 8中可用的<code>CompletionStage</code>和<code>CompletableFuture</code>类一起使用时，由于响应式编程，异步处理的功能会松散。 <br><br> 响应式编程不仅仅是从同步模型中实现异步模型。 它还简化了嵌套阶段等概念的使用。 使用的次数越多，在并行编程中管理复杂的脚本就越容易。 <br><br> 结束 <br><br> 谢谢您的关注。 与往常一样，我们正在等待您的评论和问题。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424031/">https://habr.com/ru/post/zh-CN424031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424021/index.html">自学编程的挑战以及如何克服它们</a></li>
<li><a href="../zh-CN424023/index.html">我们使用Fastlane自动组装iOS应用程序</a></li>
<li><a href="../zh-CN424025/index.html">在大型React应用程序中进行路由</a></li>
<li><a href="../zh-CN424027/index.html">学习对抗策略，技巧和常识（ATT @ CK）。 企业策略。 第二部分</a></li>
<li><a href="../zh-CN424029/index.html">关于懒惰</a></li>
<li><a href="../zh-CN424033/index.html">Kotlin在做什么：采访Andrei Breslav</a></li>
<li><a href="../zh-CN424035/index.html">2019年是英特尔停止的一年</a></li>
<li><a href="../zh-CN424037/index.html">GraphQL简介</a></li>
<li><a href="../zh-CN424039/index.html">登陆外星人后的密码学</a></li>
<li><a href="../zh-CN424041/index.html">细胞生物学简介</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>