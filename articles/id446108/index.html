<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏫 💪🏼 🌫️ Blok bangunan aplikasi terdistribusi. Pendekatan pertama 🙌 🏠 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel terakhir , kami memeriksa fondasi teoritis arsitektur reaktif. Saatnya berbicara tentang aliran data, cara untuk menerapkan sistem Erlan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blok bangunan aplikasi terdistribusi. Pendekatan pertama</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446108/"><p><img src="https://habrastorage.org/webt/id/fv/eo/idfveo9cmr8y2uyidusx29gwvtc.jpeg"></p><br><p> Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kami memeriksa fondasi teoritis arsitektur reaktif.  Saatnya berbicara tentang aliran data, cara untuk menerapkan sistem Erlang / Elixir reaktif, dan pola pesan di dalamnya: </p><br><ul><li>  Minta tanggapan </li><li>  Tanggapan Chunked Permintaan </li><li>  Respon dengan Permintaan </li><li>  Publikasikan-berlangganan </li><li>  Berlangganan Terbitkan-terbalik </li><li>  Distribusi tugas <a name="habracut"></a></li></ul><br><h2 id="soa-msa-i-obmen-soobscheniyami">  SOA, MSA, dan Pesan </h2><br><p>  SOA, MSA - arsitektur sistem yang menentukan aturan untuk membangun sistem, sementara olahpesan menyediakan primitif untuk implementasinya. </p><br><p>  Saya tidak ingin mempromosikan arsitektur sistem pembangunan ini atau itu.  Saya mendukung penggunaan praktik yang paling efektif dan bermanfaat untuk proyek dan bisnis tertentu.  Apapun paradigma yang kita pilih, lebih baik membuat blok sistem dengan memperhatikan cara Unix: komponen dengan konektivitas minimal yang bertanggung jawab atas entitas individu.  Metode API melakukan tindakan paling sederhana dengan entitas. </p><br><p>  Pesan - sesuai namanya, adalah perantara pesan.  Tujuan utamanya adalah untuk menerima dan memberikan pesan.  Dia bertanggung jawab atas antarmuka untuk mengirim informasi, pembentukan saluran logis untuk mentransmisikan informasi dalam sistem, perutean dan penyeimbangan, serta pemrosesan kegagalan di tingkat sistem. <br>  Olahpesan yang dikembangkan tidak mencoba untuk bersaing atau mengganti rabbitmq.  Fitur utamanya: </p><br><ul><li>  Distribusi <br>  Poin pertukaran dapat dibuat pada semua node cluster, sedekat mungkin dengan kode yang menggunakannya. </li><li>  Kesederhanaan. <br>  Fokus pada meminimalkan kode boilerplate dan kegunaan. </li><li>  Performa terbaik. <br>  Kami tidak mencoba mengulangi fungsionalitas rabbitmq, tetapi hanya menyoroti lapisan arsitektur dan transportasi, yang sesederhana mungkin dalam OTP, meminimalkan biaya. </li><li>  Fleksibilitas. <br>  Setiap layanan dapat menggabungkan banyak templat pertukaran. </li><li>  Toleransi kesalahan yang melekat dalam desain. </li><li>  Skalabilitas. <br>  Perpesanan tumbuh bersama aplikasi.  Saat beban meningkat, Anda dapat memindahkan titik pertukaran ke masing-masing mesin. </li></ul><br><p>  <em>Komentar.</em>  Dari sudut pandang organisasi kode, meta-proyek sangat cocok untuk sistem yang kompleks dengan Erlang / Elixir.  Semua kode proyek dalam satu repositori - proyek payung.  Pada saat yang sama, layanan-layanan mikroseperti terisolasi mungkin dan melakukan operasi sederhana yang bertanggung jawab atas entitas yang terpisah.  Dengan pendekatan ini, mudah untuk mendukung API dari seluruh sistem, cukup membuat perubahan, lebih mudah untuk menulis unit dan tes integrasi. </p><br><p>  Komponen sistem berinteraksi secara langsung atau melalui broker.  Dari perspektif perpesanan, setiap layanan memiliki beberapa fase kehidupan: </p><br><ul><li>  Inisialisasi layanan. <br>  Pada tahap ini, konfigurasi dan peluncuran proses pelaksanaan layanan dan dependensi berlangsung. </li><li>  Menciptakan titik pertukaran. <br>  Layanan dapat menggunakan titik pertukaran statis yang ditentukan dalam konfigurasi simpul, atau membuat titik pertukaran secara dinamis. </li><li>  Pendaftaran layanan. <br>  Agar layanan dapat memenuhi permintaan layanan, layanan harus didaftarkan pada titik pertukaran. </li><li>  Berfungsi normal. <br>  Layanan menghasilkan pekerjaan yang bermanfaat. </li><li>  Shutdown. <br>  Ada 2 jenis shutdown: reguler dan darurat.  Dengan layanan reguler, ia terputus dari titik pertukaran dan berhenti.  Dalam kasus darurat, olahpesan menjalankan salah satu skenario failover. </li></ul><br><p>  Kelihatannya cukup rumit, tetapi tidak semuanya menakutkan dalam kode.  Contoh kode dengan komentar akan diberikan dalam analisis template beberapa saat kemudian. </p><br><h2 id="exchanges">  Pertukaran </h2><br><p>  Pertukaran poin adalah proses pengiriman pesan yang mengimplementasikan logika berinteraksi dengan komponen-komponen dalam templat pengiriman pesan.  Dalam semua contoh di bawah ini, komponen berinteraksi melalui titik pertukaran, kombinasi yang membentuk pesan. </p><br><h2 id="message-exchange-patterns-meps">  Pola pertukaran pesan (MEP) </h2><br><p>  Secara global, pola berbagi dapat dibagi menjadi dua arah dan satu arah.  Yang pertama menyiratkan respon terhadap pesan yang diterima, yang terakhir tidak.  Contoh klasik dari pola dua arah dalam arsitektur client-server adalah pola Request-response.  Pertimbangkan templat dan modifikasinya. </p><br><h3 id="requestresponse-ili-rpc">  Permintaan - respons atau RPC </h3><br><p>  RPC digunakan ketika kita perlu mendapatkan respons dari proses lain.  Proses ini dapat diluncurkan di situs yang sama atau berlokasi di benua yang berbeda.  Di bawah ini adalah diagram interaksi klien dan server melalui olahpesan. </p><br><p><img src="https://habrastorage.org/webt/pz/x9/hx/pzx9hxfkk0szgfugtdbpc1hwrak.png"></p><br><p>  Karena pengiriman pesan sama sekali tidak sinkron, untuk klien pertukaran dibagi menjadi 2 fase: </p><br><ol><li><p>  Permintaan Pengajuan </p><br><pre><code class="erlang hljs">messaging:request(Exchange, ResponseMatchingTag, RequestDefinition, HandlerProcess).</code> </pre> <br><p>  <em>Exchange</em> - nama unik untuk titik pertukaran <br>  <em>ResponseMatchingTag</em> - Label lokal untuk menangani respons.  Misalnya, dalam hal mengirim beberapa permintaan identik milik pengguna yang berbeda. <br>  <em>RequestDefinition</em> - tubuh permintaan <br>  <em>HandlerProcess</em> - PID handler.  Proses ini akan menerima respons dari server. </p><br></li><li><p>  Pemrosesan tanggapan </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = EXCHANGE, tag = ResponseMatchingTag,message = ResponsePayload}, State)</span></span></span></span></code> </pre> <br><p>  <em>ResponsePayload</em> - respons server. </p><br></li></ol><br><p>  Untuk server, prosesnya juga terdiri dari 2 fase: </p><br><ol><li>  Inisialisasi Titik Tukar </li><li>  Memproses permintaan masuk </li></ol><br><p>  Mari ilustrasikan template ini dengan kode.  Misalkan kita perlu mengimplementasikan layanan sederhana yang menyediakan satu-satunya metode waktu yang tepat. </p><br><h4 id="kod-servera">  Kode server </h4><br><p>  Keluarkan definisi API layanan di api.hrl: </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% ===================================================== %% entities %% ===================================================== -record(time, { unixtime :: non_neg_integer(), datetime :: binary() }). -record(time_error, { code :: non_neg_integer(), error :: term() }). %% ===================================================== %% methods %% ===================================================== -record(time_req, { opts :: term() }). -record(time_resp, { result :: #time{} | #time_error{} }).</span></span></code> </pre> <br><p>  Tentukan pengontrol layanan di time_controller.erl </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%%      .     gen_server    . %%  gen_server init(Args) -&gt; %%     messaging:monitor_exchange(req_resp, ?EXCHANGE, default, self()) {ok, #{}}. %%       .    ,      . handle_info(#exchange_die{exchange = ?EXCHANGE}, State) -&gt; erlang:send(self(), monitor_exchange), {noreply, State}; %%  API handle_info(#time_req{opts = _Opts}, State) -&gt; messaging:response_once(Client, #time_resp{ result = #time{ unixtime = time_utils:unixtime(now()), datetime = time_utils:iso8601_fmt(now())} }); {noreply, State}; %%   gen_server terminate(_Reason, _State) -&gt; messaging:demonitor_exchange(req_resp, ?EXCHANGE, default, self()), ok.</span></span></code> </pre> <br><h4 id="kod-klienta">  Kode pelanggan </h4><br><p>  Untuk mengirim permintaan ke layanan, Anda dapat memanggil API permintaan perpesanan di mana saja di klien: </p><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> messaging:request(?EXCHANGE, tag, #time_req{opts = #{}}, self()) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; ok; _ -&gt; <span class="hljs-comment"><span class="hljs-comment">%% repeat or fail logic end</span></span></code> </pre> <br><p>  Dalam sistem terdistribusi, konfigurasi komponen bisa sangat berbeda dan pada saat pesan permintaan belum dimulai, atau pengontrol layanan tidak akan siap untuk melayani permintaan.  Karena itu, kita perlu memeriksa respons pesan dan menangani kasus kegagalan. <br>  Setelah pengiriman berhasil, klien akan menerima respons atau kesalahan dari layanan. <br>  Tangani kedua kasus di handle_info: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time{unixtime = Utime}}}, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> ?debugVal(Utime), {noreply, State}; handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time_error{code = ErrorCode}}}, State) -&gt; ?debugVal({error, ErrorCode}), {noreply, State};</code> </pre> <br><h3 id="request-chunked-response">  Tanggapan Chunked Permintaan </h3><br><p>  Lebih baik tidak membiarkan pengiriman pesan besar.  Operasi responsif dan stabil seluruh sistem tergantung pada ini.  Jika respons terhadap permintaan memakan banyak memori, maka pengelompokan menjadi beberapa bagian adalah wajib. </p><br><p><img src="https://habrastorage.org/webt/dj/zv/6_/djzv6_lvreaj-iieegxoqemx-vi.png"></p><br><p>  Berikut adalah beberapa contoh kasus tersebut: </p><br><ul><li>  Komponen bertukar data biner, seperti file.  Membagi jawaban menjadi bagian-bagian kecil membantu Anda bekerja secara efisien dengan file dari berbagai ukuran dan tidak menangkap kelebihan memori. </li><li>  Daftar.  Sebagai contoh, kita perlu memilih semua catatan dari tabel besar dalam database dan mentransfernya ke komponen lain. </li></ul><br><p>  Saya menyebut jawaban ini lokomotif.  Bagaimanapun, 1024 1 MB pesan lebih baik daripada satu pesan 1 GB. </p><br><p>  Di kluster Erlang, kami mendapatkan keuntungan tambahan - mengurangi beban pada titik pertukaran dan jaringan, karena jawaban segera dikirim ke penerima, melewati titik pertukaran. </p><br><h3 id="response-with-request">  Respon dengan Permintaan </h3><br><p>  Ini adalah modifikasi yang cukup langka dari pola RPC untuk membangun sistem interaktif. </p><br><p><img src="https://habrastorage.org/webt/dg/t5/kt/dgt5ktnzqdttmiqv8jne7h6lneg.png"></p><br><h3 id="publish-subscribe-data-distribution-tree">  Terbitkan-berlangganan (pohon distribusi data) </h3><br><p>  Sistem yang berorientasi pada peristiwa memberikan data kepada konsumen ketika data tersedia.  Dengan demikian, sistem lebih cenderung mendorong model daripada menarik atau polling.  Fitur ini memungkinkan Anda untuk tidak membuang sumber daya dengan terus-menerus bertanya dan menunggu data. <br>  Gambar tersebut menunjukkan proses pendistribusian pesan ke konsumen yang berlangganan topik tertentu. </p><br><p><img src="https://habrastorage.org/webt/yg/sp/lx/ygsplxxerjwdvci5gk3hhdn2jay.png"></p><br><p>  Contoh klasik dari penggunaan templat ini adalah distribusi negara: dunia game dalam game komputer, data pasar pertukaran, informasi yang berguna dalam umpan data. </p><br><p>  Pertimbangkan kode pelanggan: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Args)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%%   ,  = key messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {ok, #{}}. handle_info(#exchange_die{exchange = ?SUBSCRIPTION}, State) -&gt; %%    ,    messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {noreply, State}; %%    handle_info(#'$msg'{exchange = ?SUBSCRIPTION, message = Msg}, State) -&gt; ?debugVal(Msg), {noreply, State}; %%    -     terminate(_Reason, _State) -&gt; messaging:unsubscribe(?SUBSCRIPTION, key, tag, self()), ok.</span></span></code> </pre> <br><p>  Sumber dapat memanggil fungsi publikasi posting di tempat yang nyaman: </p><br><pre> <code class="erlang hljs">messaging:publish_message(Exchange, Key, Message).</code> </pre> <br><p>  <em>Exchange</em> - nama titik pertukaran, <br>  <em>Kunci</em> - kunci perutean <br>  <em>Pesan</em> - payload </p><br><h2 id="inverted-publish-subscribe">  Berlangganan Terbitkan-terbalik </h2><br><p><img src="https://habrastorage.org/webt/5h/qz/uq/5hqzuqda_rzuvaphv2q3nqjnvcg.png"></p><br><p>  Dengan memperluas pub-sub, Anda bisa mendapatkan pola yang nyaman untuk masuk.  Himpunan sumber dan konsumen bisa sangat berbeda.  Angka tersebut menunjukkan kasus dengan satu konsumen dan banyak sumber. </p><br><h2 id="task-distribution-pattern">  Pola distribusi tugas </h2><br><p>  Di hampir setiap proyek, tugas pemrosesan yang ditangguhkan muncul, seperti menghasilkan laporan, mengirimkan pemberitahuan, menerima data dari sistem pihak ketiga.  Throughput suatu sistem yang melakukan tugas-tugas ini mudah diukur dengan menambahkan penangan.  Yang tersisa bagi kami adalah membentuk sekelompok penangan dan mendistribusikan tugas secara merata di antara mereka. </p><br><p>  Pertimbangkan situasi yang muncul dengan contoh 3 penangan.  Bahkan pada tahap pendistribusian tugas, muncul pertanyaan tentang keadilan distribusi dan luapan para penangan.  Distribusi round-robin akan bertanggung jawab atas keadilan, dan untuk menghindari situasi luapan penangan, kami memperkenalkan batasan <em>prefetch_limit</em> .  Dalam mode sementara, <em>prefetch_limit</em> akan mencegah satu penangan menerima semua tugas. </p><br><p>  Pesan mengelola antrian dan prioritas pemrosesan.  Penangan menerima tugas saat tersedia.  Tugas mungkin berhasil atau gagal: </p><br><ul><li>  <code>messaging:ack(Tack)</code> - dipanggil jika pemrosesan pesan berhasil </li><li>  <code>messaging:nack(Tack)</code> - dipanggil dalam semua situasi darurat.  Setelah tugas kembali, perpesanan akan mentransfernya ke penangan lain. </li></ul><br><p><img src="https://habrastorage.org/webt/w6/yi/hc/w6yihc6yyunvigevthjggejkwjq.png"></p><br><p>  Misalkan kegagalan kompleks terjadi selama pemrosesan tiga tugas: penangan 1, setelah menerima tugas, jatuh sebelum dapat berkomunikasi ke titik pertukaran.  Dalam hal ini, titik pertukaran setelah batas waktu ack berakhir akan mentransfer pekerjaan ke penangan lain.  Handler 3 karena alasan tertentu meninggalkan tugas dan mengirim nack, sebagai akibatnya, tugas tersebut juga diteruskan ke handler lain yang berhasil menyelesaikannya. </p><br><h2 id="predvaritelnyy-itog">  Hasil awal </h2><br><p>  Kami membongkar blok bangunan dasar dari sistem terdistribusi dan mendapatkan pemahaman dasar tentang aplikasi mereka di Erlang / Elixir. </p><br><p>  Dengan menggabungkan pola-pola dasar, Anda dapat membangun paradigma kompleks untuk menyelesaikan masalah yang muncul. </p><br><p>  Pada bagian akhir dari siklus, kami akan mempertimbangkan masalah umum dari organisasi layanan, perutean dan penyeimbangan, dan juga berbicara tentang sisi praktis skalabilitas dan toleransi kesalahan sistem. </p><br><p>  Akhir dari bagian kedua. </p><br><p>  Foto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Marius Christensen</a> <br>  Ilustrasi disiapkan oleh web berikutnyaencediagrams.com </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446108/">https://habr.com/ru/post/id446108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446096/index.html">Buku "TasteVill: Cara membuat revolusi di ritel, melakukan segala sesuatu yang salah"</a></li>
<li><a href="../id446098/index.html">Pusat kontrol penerbangan Soviet pada masa "Vostok" dan "Matahari Terbit"</a></li>
<li><a href="../id446100/index.html">Secara otomatis membuat file pelokalan Android dan iOS dari Excel spreadsheet</a></li>
<li><a href="../id446104/index.html">Paradoks Python</a></li>
<li><a href="../id446106/index.html">Oleg Shelaev tentang GraalVM di jug.msk.ru</a></li>
<li><a href="../id446110/index.html">WavesKit - PHP Waves Blockchain Framework</a></li>
<li><a href="../id446112/index.html">WavesKit - Kerangka kerja PHP untuk bekerja dengan Waves Platform</a></li>
<li><a href="../id446114/index.html">Modem berusia 50 tahun: tampilan bagian dalam</a></li>
<li><a href="../id446116/index.html">Pilihan buku tentang cara belajar, berpikir, dan membuat keputusan yang efektif</a></li>
<li><a href="../id446118/index.html">Open Rack v3: apa yang diharapkan dari standar arsitektur rak server baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>