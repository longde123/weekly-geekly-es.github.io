<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà ü§æ üß£ Les secrets de l'informatique GPU impossible üõë üîä üò≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Notre exp√©rience dans l'utilisation d'un cluster informatique de 480 GPU AMD RX 480 pour r√©soudre des probl√®mes math√©matiques. Comme probl√®me, nous av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les secrets de l'informatique GPU impossible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/combox/blog/425731/"> Notre exp√©rience dans l'utilisation d'un cluster informatique de 480 GPU AMD RX 480 pour r√©soudre des probl√®mes math√©matiques.  Comme probl√®me, nous avons pris la preuve du th√©or√®me d'un article du professeur A. Chudnov  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©compositions cycliques d'ensembles s√©parant les digraphes et les classes cycliques de jeux avec un gain garanti</a> ."  La t√¢che consiste √† trouver le nombre minimum de participants dans une coalition dans des jeux de coalition de type Nim, ce qui garantit la victoire de l'un des partis. <br><br><img src="https://habrastorage.org/webt/jc/gm/wj/jcgmwjouxeywvjyjlxa8vec5s5c.jpeg"><br><a name="habracut"></a><br><h3>  D√©veloppement CPU </h3><br>  Le premier processeur qui a vraiment obtenu une distribution de masse est le 8086 d'Intel, d√©velopp√© en 1978.  La vitesse d'horloge de 8086 n'√©tait que de 8 MHz.  Quelques ann√©es plus tard, les premiers processeurs sont apparus √† l'int√©rieur desquels se trouvaient 2, 4 et m√™me 8 c≈ìurs.  Chaque noyau a permis √† son code d'√™tre ex√©cut√© ind√©pendamment des autres.  √Ä titre de comparaison, le processeur Intel Core i9-7980XE moderne fonctionne √† une fr√©quence de 2,6 GHz et contient 18 c≈ìurs.  Comme vous pouvez le constater, les progr√®s ne s'arr√™tent pas! <br><br><h3>  D√©veloppement GPU </h3><br>  Parall√®lement au d√©veloppement de processeurs centraux, des cartes vid√©o ont √©galement √©t√© d√©velopp√©es.  Fondamentalement, leurs caract√©ristiques sont importantes pour les jeux informatiques, o√π les nouvelles technologies sont particuli√®rement color√©es et o√π le rendu des images 3D approche progressivement de la qualit√© photographique.  Au d√©but du d√©veloppement des jeux informatiques, le calcul de l'image a √©t√© effectu√© sur le CPU, mais l'inventivit√© des d√©veloppeurs de graphismes 3D a rapidement √©t√© atteinte, qui a r√©ussi √† optimiser m√™me les choses √©videntes ( <i>InvSqrt () en est un</i> bon exemple).  Ainsi, des coprocesseurs avec un ensemble sp√©cial d'instructions pour effectuer des calculs 3D ont commenc√© √† appara√Ætre sur les cartes vid√©o.  Au fil du temps, le nombre de ces √©quipes a augment√©, ce qui, d'une part, a permis de travailler avec plus de souplesse et d'efficacit√© avec l'image, et d'autre part, a compliqu√© le processus de d√©veloppement. <br><br>  Depuis 1996, des acc√©l√©rateurs graphiques S3 ViRGE, 3dfx Voodoo, Diamond Monster et d'autres ont commenc√© √† √™tre produits.  En 1999, nVidia a sorti le processeur GeForce 256, introduisant le terme GPU - un processeur graphique.  Il est d√©j√† universel, il peut g√©rer des calculs g√©om√©triques, des transformations de coordonn√©es, le placement de points d'√©clairage et travailler avec des polygones.  La diff√©rence entre le GPU et les autres puces graphiques √©tait qu'√† l'int√©rieur, en plus des commandes sp√©cialis√©es, il y avait un ensemble de commandes standard avec lesquelles vous pouviez impl√©menter votre propre algorithme de rendu.  Cela a donn√© un avantage significatif, car il a permis d'ajouter des effets sp√©ciaux, et pas seulement ceux qui sont d√©j√† programm√©s dans la carte vid√©o.  √Ä partir de la GeForce 8000/9000, les processeurs de flux sont apparus dans le GPU - des ordinateurs √† part enti√®re.  Leur nombre variait de 16 √† 128 selon les mod√®les: dans la terminologie moderne, ils sont appel√©s unit√©s de shader unifi√©es, ou simplement unit√©s de shader.  Les GPU AMD Vega 64 fabriqu√©s aujourd'hui contiennent 4096 unit√©s de shader et la fr√©quence d'horloge peut atteindre 1536 MHz! <br><br><h3>  Que contient un GPU? </h3><br><img align="right" src="https://habrastorage.org/webt/my/rm/lc/myrmlcjalz2qiygw-qg-vdp4o18.png">  L'architecture GPU diff√®re de la CPU par un grand nombre de c≈ìurs et un ensemble minimaliste d'instructions destin√©es principalement √† l'informatique vectorielle.  Au niveau de l'architecture, les probl√®mes de fonctionnement en parall√®le d'un grand nombre de c≈ìurs et d'acc√®s simultan√© √† la m√©moire ont √©t√© r√©solus.  Les GPU modernes contiennent de 2 √† 4 000 unit√©s de shader, qui sont combin√©es en unit√©s de calcul (unit√© de calcul).  En informatique parall√®le, le probl√®me de l'acc√®s simultan√© √† la m√©moire est particuli√®rement aigu.  Si chacun des processeurs de flux essaie d'√©crire dans la cellule de m√©moire, ces commandes se retrouveront dans le verrou et devront √™tre mises en file d'attente, ce qui r√©duira consid√©rablement les performances.  Par cons√©quent, les processeurs de flux ex√©cutent des instructions en petits groupes: tandis qu'un groupe effectue les calculs, l'autre charge les registres, etc.  Vous pouvez √©galement combiner les c≈ìurs en groupes de travail avec une m√©moire partag√©e et des m√©canismes de synchronisation interne. <br><br>  Une autre caract√©ristique importante du GPU est la pr√©sence de registres vectoriels et d'ALU vectorielles, qui peuvent effectuer des op√©rations simultan√©ment pour plusieurs composants du vecteur.  C'est principalement n√©cessaire pour les graphiques 3D, mais comme notre monde est en trois dimensions, rien ne nous emp√™che de l'utiliser pour de nombreux calculs physiques.  En pr√©sence d'ALU vectorielles libres, elles peuvent √©galement √™tre utilis√©es pour calculer des quantit√©s scalaires. <br><br><h3>  Ils sont tellement diff√©rents, CPU et GPU </h3><br>  Pour le fonctionnement complet du syst√®me informatique, les deux types d'appareils sont importants.  Par exemple, nous ex√©cutons un programme √©tape par √©tape, un certain algorithme s√©quentiel.  Il n'y a aucun moyen d'effectuer la cinqui√®me √©tape de l'algorithme, donc les donn√©es correspondant sont calcul√©es √† l'√©tape quatre.  Dans ce cas, il est plus efficace d'utiliser un processeur avec un grand cache et une vitesse d'horloge √©lev√©e.  Mais il existe des classes enti√®res de t√¢ches qui se pr√™tent bien √† la parall√©lisation.  Dans ce cas, l'efficacit√© du GPU est √©vidente.  L'exemple le plus courant est le calcul des pixels d'une image rendue.  La proc√©dure pour chaque pixel est presque la m√™me, les donn√©es sur les objets 3D et les textures sont situ√©es dans la RAM de la carte vid√©o et chaque processeur de flux peut calculer ind√©pendamment sa propre partie de l'image. <br><br>  Voici un exemple d'une t√¢che moderne - la formation d'un r√©seau neuronal.  Un grand nombre de neurones identiques doivent √™tre entra√Æn√©s, c'est-√†-dire pour changer les coefficients de poids de chaque neurone.  Apr√®s de tels changements, il est n√©cessaire de passer des s√©quences de test √† travers le r√©seau neuronal pour la formation et d'obtenir des vecteurs d'erreur.  Ces calculs conviennent bien au GPU.  Chaque processeur de flux peut se comporter comme un neurone et lors du calcul il ne sera pas n√©cessaire de construire la solution de mani√®re s√©quentielle, tous nos calculs se feront simultan√©ment.  Un autre exemple est le calcul des flux a√©rodynamiques.  Il est n√©cessaire de conna√Ætre le comportement possible du pont con√ßu sous l'influence du vent, de simuler sa stabilit√© a√©rodynamique, de trouver les sites d'installation optimaux pour les car√©nages pour ajuster le d√©bit d'air ou pour calculer la r√©sistance √† la r√©sonance du vent.  Vous vous souvenez du c√©l√®bre ¬´pont dansant¬ª de Volgograd?  Je pense que personne ne voudrait √™tre √† ce moment sur le pont ... <br><br>  Le comportement du flux d'air en chaque point peut √™tre d√©crit par les m√™mes √©quations math√©matiques et r√©soudre ces √©quations en parall√®le sur un grand nombre de c≈ìurs. <br><br><h3>  GPU entre les mains des programmeurs </h3><br>  Pour effectuer des calculs sur le GPU, un langage sp√©cial et un compilateur sont utilis√©s.  Il existe plusieurs cadres pour effectuer un calcul GPU g√©n√©ral: OpenCL, CUDA, C ++ AMP, OpenACC.  Les deux premiers ont √©t√© largement utilis√©s, mais l'utilisation de CUDA n'est limit√©e que par les GPU de nVidia. <br><br>  OpenCL a √©t√© publi√© en 2009 par Apple.  Plus tard, Intel, IBM, AMD, Google et nVidia ont rejoint le groupe Khronos et ont annonc√© leur soutien √† la norme commune.  Depuis lors, une nouvelle version de la norme appara√Æt tous les ans et demi √† deux ans et chacune apporte des am√©liorations de plus en plus s√©rieuses. <br><br>  √Ä ce jour, le langage OpenCL C ++ version 2.2 est conforme √† la norme C ++ 14, prend en charge l'ex√©cution simultan√©e de plusieurs programmes au sein de l'appareil, l'interaction entre eux via des files d'attente et des pipelines internes et permet une gestion flexible des tampons et de la m√©moire virtuelle. <br><br><h3>  T√¢ches r√©elles </h3><br>  Un probl√®me int√©ressant de la th√©orie des jeux, √† la solution de laquelle nous avons particip√©, est la preuve du th√©or√®me d'un article du professeur A. Chudnov  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©compositions cycliques d'ensembles s√©parant les digraphes et les classes cycliques de jeux avec un gain garanti</a> ."  La t√¢che consiste √† trouver le nombre minimum de participants dans une coalition dans des jeux de coalition de type Nim, ce qui garantit la victoire de l'un des partis. <br><br>  D'un point de vue math√©matique, il s'agit d'une recherche d'une s√©quence cyclique de support.  Si vous repr√©sentez la s√©quence sous la forme d'une liste de z√©ros et de uns, la v√©rification de la prise en charge peut √™tre impl√©ment√©e par des op√©rations logiques au niveau du bit.  Du point de vue de la programmation, une telle s√©quence est un long registre, par exemple 256 bits.  Le moyen le plus fiable pour r√©soudre ce probl√®me est de trier toutes les options sauf l'impossible pour des raisons √©videntes. <br><br>  Les objectifs de la r√©solution du probl√®me sont des probl√®mes de traitement efficace du signal (d√©tection, synchronisation, mesure de coordonn√©es, codage, etc.). <br><br>  La difficult√© de r√©soudre ce probl√®me est de trier un grand nombre d'options.  Par exemple, si nous recherchons une solution pour n = 25, alors c'est 25 bits, et si n = 100, alors c'est d√©j√† 100 bits.  Si nous prenons le nombre de toutes les combinaisons possibles, alors pour n = 25 c'est 2 ^ 25 = 33 554 432, et pour n = 100 c'est d√©j√† 2 ^ 100 = 1 267 650 600 228 229 401 496 703 205 376 combinaisons.  L'augmentation de la complexit√© est tout simplement colossale! <br><br>  Cette t√¢che est bien parall√©lis√©e, ce qui signifie qu'elle est id√©ale pour notre cluster GPU. <br><br><h3>  Programmeurs vs math√©matiques </h3><br>  Initialement, les math√©maticiens ont r√©solu ce probl√®me dans Visual Basic dans Excel, ils ont donc r√©ussi √† obtenir des solutions principales, mais les faibles performances des langages de script ne nous ont pas permis d'aller de l'avant.  La d√©cision de n = 80 a pris un mois et demi ... Nous inclinons la t√™te devant ces patients. <br><br>  La premi√®re √©tape, nous avons impl√©ment√© l'algorithme de t√¢che en C et l'avons lanc√© sur le CPU.  Au cours du processus, il s'est av√©r√© que beaucoup de choses peuvent √™tre optimis√©es lorsque vous travaillez avec des s√©quences de bits. <br>  Ensuite, nous avons optimis√© la zone de recherche et √©limin√© les doublons.  De plus, une analyse du code assembleur g√©n√©r√© par le compilateur et une optimisation du code pour les fonctionnalit√©s du compilateur ont donn√© un bon r√©sultat.  Tout cela a permis d'obtenir une augmentation significative de la vitesse des calculs. <br><br>  L'√©tape suivante de l'optimisation a √©t√© le profilage.  La mesure du temps d'ex√©cution de diff√©rentes sections du code a montr√© que dans certaines branches de l'algorithme, la charge sur la m√©moire augmentait consid√©rablement, ainsi qu'une ramification excessive du programme a √©t√© r√©v√©l√©e.  En raison de ce ¬´petit¬ª d√©faut, pr√®s d'un tiers de la puissance du processeur n'a pas √©t√© utilis√©. <br><br>  Un aspect tr√®s important de la r√©solution de ces probl√®mes est la pr√©cision de l'√©criture du code.  Personne ne conna√Æt les bonnes r√©ponses √† ce probl√®me et, par cons√©quent, il n'y a pas de vecteurs de test.  Il n'y a que la premi√®re partie de la gamme de solutions que les math√©maticiens ont trouv√©es.  La fiabilit√© des nouvelles solutions ne peut √™tre garantie que par la pr√©cision de l'√©criture du code. <br><br>  La phase de pr√©paration du programme pour la solution sur le GPU est donc arriv√©e et le code a √©t√© modifi√© pour fonctionner dans plusieurs threads.  Le programme de contr√¥le est d√©sormais engag√© dans la r√©partition des t√¢ches entre les threads.  Dans un environnement multi-thread, la vitesse de calcul a √©t√© multipli√©e par 5!  Ceci a √©t√© r√©alis√© gr√¢ce au fonctionnement simultan√© de 4 threads et √† la combinaison de fonctions. <br><br>  √Ä ce stade, la d√©cision a fait les bons calculs jusqu'√† n = 80 en 10 minutes, alors que dans Excel, ces calculs ont pris un mois et demi!  Petite victoire! <br><br><h3>  GPU et OpenCL </h3><br>  Il a √©t√© d√©cid√© d'utiliser OpenCL version 1.2 pour assurer une compatibilit√© maximale entre les diff√©rentes plates-formes.  Le d√©bogage initial a √©t√© effectu√© sur le processeur d'Intel, puis sur le GPU d'Intel.  Ensuite, ils sont pass√©s au GPU d'AMD. <br><br>  La norme OpenCL 1.2 prend en charge les variables enti√®res de 64 bits.  La dimension 128 bits est prise en charge de mani√®re limit√©e par AMD, mais se compile en deux nombres 64 bits.  Pour des raisons de compatibilit√© et pour optimiser les performances, il a √©t√© d√©cid√© de pr√©senter un nombre 256 bits comme un groupe de nombres 32 bits, op√©rations logiques au niveau du bit sur lesquelles sont effectu√©es le plus rapidement possible sur le GPU ALU interne. <br>  Un programme OpenCL contient un noyau - une fonction qui est le point d'entr√©e d'un programme.  Les donn√©es √† traiter sont t√©l√©charg√©es de la CPU vers la RAM de la carte vid√©o et transf√©r√©es au noyau sous forme de tampons - pointeurs vers un tableau de donn√©es d'entr√©e et de sortie.  Pourquoi un tableau?  Nous effectuons un calcul haute performance, nous avons besoin de nombreuses t√¢ches qui sont effectu√©es simultan√©ment.  Le noyau s'ex√©cute sur le p√©riph√©rique dans plusieurs instances.  Chaque c≈ìur conna√Æt son identifiant et prend sa propre entr√©e dans un tampon partag√©.  Le cas o√π la solution la plus simple est la plus efficace.  OpenCL n'est pas seulement un langage, mais aussi un cadre complet dans lequel tous les d√©tails de l'informatique scientifique et des jeux sont soigneusement pens√©s.  Cela facilite la vie du d√©veloppeur.  Par exemple, vous pouvez d√©marrer de nombreux threads, le gestionnaire de t√¢ches les placera sur l'appareil lui-m√™me.  Les t√¢ches qui n'ont pas d√©marr√© l'ex√©cution imm√©diate seront mises en file d'attente et lanc√©es √† mesure que les unit√©s de calcul deviennent libres.  Chaque instance du noyau a son propre espace dans le tampon de sortie, o√π elle place la r√©ponse √† la fin du travail. <br><br>  La t√¢che principale du gestionnaire OpenCL est d'assurer l'ex√©cution parall√®le de plusieurs instances du noyau.  L'exp√©rience scientifique et pratique accumul√©e au fil des d√©cennies est appliqu√©e ici.  Alors que certains c≈ìurs chargent des donn√©es dans des registres, une autre partie √† l'heure actuelle fonctionne avec la m√©moire ou effectue des calculs - en cons√©quence, le c≈ìur du GPU est toujours enti√®rement charg√©. <br>  Le compilateur OpenCL fait un bon travail d'optimisation, mais il est plus facile pour un d√©veloppeur d'influencer les performances.  L'optimisation du GPU va dans deux directions: acc√©l√©rer l'ex√©cution du code et la possibilit√© de le parall√©liser.  La fa√ßon dont le code est parall√©lis√© par le compilateur d√©pend de plusieurs choses: le nombre de registres de travail occup√©s (qui sont situ√©s dans la m√©moire GPU la plus lente - globale), la taille du code compil√© (vous devez tenir dans 32 Ko de cache), le nombre de registres vectoriels et scalaires utilis√©s. <br><br><h3>  GPU ComBox A-480 ou un million de c≈ìurs </h3><br>  C'est la partie la plus int√©ressante du projet, lorsque nous sommes pass√©s d'Excel √† un cluster informatique compos√© de 480 cartes graphiques AMD RX 480. Grand, rapide, efficace.  Compl√®tement pr√™t √† accomplir la t√¢che et √† obtenir ces r√©sultats que le monde n'a jamais vus auparavant. <br><br>  Je voudrais noter qu'√† toutes les √©tapes de l'am√©lioration et de l'optimisation du code, nous avons commenc√© la recherche d'une solution d√®s le d√©but et compar√© les r√©ponses de la nouvelle version avec les pr√©c√©dentes.  Cela nous a permis de nous assurer que l'optimisation et les am√©liorations du code n'introduisaient pas d'erreurs dans les solutions.  Ici, vous devez comprendre qu'il n'y a pas de bonnes r√©ponses √† la fin du manuel et que personne au monde ne les conna√Æt. <br>  Le lancement sur le cluster a confirm√© nos hypoth√®ses sur la vitesse des solutions: la recherche de s√©quences pour n&gt; 100 a pris environ une heure.  C'√©tait incroyable de voir comment de nouvelles solutions √©taient sur le cluster ComBox A-480 en quelques minutes, tandis que sur le CPU, cela a pris de nombreuses heures. <br><br>  En seulement deux heures de cluster informatique, nous avons obtenu toutes les solutions jusqu'√† n = 127.  Une v√©rification des solutions a montr√© que les r√©ponses obtenues sont fiables et correspondent aux th√©or√®mes du professeur A. Chudnov √©nonc√©s dans l'article <br><br><h3>  Evolution de la vitesse </h3><br>  Si vous examinez le gain de performances au cours de la r√©solution du probl√®me, les r√©sultats sont approximativement les suivants: <br><br><ul><li>  un mois et demi √† n = 80 dans Excel; </li><li>  une heure √† n = 80 sur Core i5 avec un programme C ++ optimis√©; </li><li>  10 minutes √† n = 80 sur Core i5 en utilisant le multithreading; </li><li>  10 minutes √† n = 100 sur un GPU AMD RX 480; </li><li>  120 minutes √† n = 127 sur le ComBox A-480. </li></ul><br><h3>  Perspectives et avenir </h3><br>  De nombreuses t√¢ches √† l'intersection de la science et de la pratique sont en attente pour am√©liorer notre vie.  Le march√© de la location de puissance informatique ne fait qu'√©merger et le besoin de calcul parall√®le continue de cro√Ætre. <br><br>  Applications possibles du calcul parall√®le: <br><br><ul><li>  t√¢ches de contr√¥le automatique des v√©hicules et des drones; </li><li>  calculs des caract√©ristiques a√©rodynamiques et hydrodynamiques; </li><li>  reconnaissance vocale et images visuelles; </li><li>  formation au r√©seau de neurones; </li><li>  t√¢ches d'astronomie et d'astronautique; </li><li>  analyse statistique et corr√©lation des donn√©es; </li><li>  pliage des compos√©s prot√©ine-prot√©ine; </li><li>  diagnostic pr√©coce des maladies gr√¢ce √† l'IA. </li></ul><br>  Une autre direction est le cloud computing sur le GPU.  Par exemple, des g√©ants comme Amazon, IBM et Google louent leur puissance de calcul au GPU.  Aujourd'hui, nous pouvons affirmer avec confiance que l'avenir du calcul parall√®le haute performance appartiendra aux clusters GPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425731/">https://habr.com/ru/post/fr425731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425719/index.html">Le c√©leri dans les projets charg√©s: un peu de pratique</a></li>
<li><a href="../fr425723/index.html">Facebook d√©veloppe activement un service de recherche d'emploi et d'embauche d'employ√©s sur un r√©seau social</a></li>
<li><a href="../fr425725/index.html">√âtui pour brevets Nintendo - Game Boy</a></li>
<li><a href="../fr425727/index.html">Jusqu'√† la prochaine fois</a></li>
<li><a href="../fr425729/index.html">Hackathon Pro Welcome: comment a √©t√© le premier organisme de bienfaisance SmartMail Hack</a></li>
<li><a href="../fr425737/index.html">Cartes sur la table: comment choisir un fournisseur de cartes pour une application mobile</a></li>
<li><a href="../fr425739/index.html">Microsoft annonce Project xCloud - un service de streaming de jeu de pointe</a></li>
<li><a href="../fr425741/index.html">Docotic.Pdf: Quels probl√®mes PVS-Studio d√©tecte-t-il dans un projet mature?</a></li>
<li><a href="../fr425743/index.html">Psychoth√©rapie Mars dans la maison de Saturne et injections intrac√©r√©brales de psilocybine hom√©opathique</a></li>
<li><a href="../fr425747/index.html">Qu'est-il arriv√© √† ¬´Timur et son √©quipe¬ª ou √† propos du Partenariat des techniciens militants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>