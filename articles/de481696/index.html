<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏽 👐 ☃️ Regelwächter: Dynamische Prüfungen für Go 🚴🏾 🥝 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich über die neue statische Analysebibliothek (und das Hilfsprogramm) von go-ruleguard sprechen, die gogrep für die Verwendung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Regelwächter: Dynamische Prüfungen für Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481696/"><p><img src="https://habrastorage.org/webt/b5/p-/sq/b5p-sqgr-9b1e5mimtxaftmryau.png"></p><br><p> In diesem Artikel werde ich über die neue statische Analysebibliothek (und das Hilfsprogramm) von <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> sprechen, die <a href="https://github.com/mvdan/gogrep"><code>gogrep</code></a> für die Verwendung in Linters anpasst. </p><br><p>  Besonderheit: Sie beschreiben die Regeln der statischen Analyse auf einem speziellen Go-like DSL, das zu Beginn von <code>ruleguard</code> zu einer Reihe von Diagnosen wird.  Dies ist möglicherweise eines der am einfachsten konfigurierbaren Tools für die Implementierung benutzerdefinierter Inspektionen für Go. </p><br><p>  Als Bonus werden wir über <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> und seine <a href="https://github.com/go-lintpack/lintpack">Vorgänger</a> sprechen. </p><a name="habracut"></a><br><h1 id="rasshiryaemost-staticheskogo-analiza">  Erweiterbarkeit der statischen Analyse </h1><br><p>  Es gibt <a href="https://github.com/golangci/awesome-go-linters">viele</a> Linters für Go, von denen einige erweitert werden können.  Um den Linter zu erweitern, müssen Sie normalerweise Go-Code mit der speziellen Linter-API schreiben. </p><br><p>  Es gibt zwei Möglichkeiten: <a href="https://golang.org/pkg/plugin/">Go Plugins</a> und Monolith.  Der Monolith impliziert, dass alle Schecks (einschließlich Ihrer persönlichen) in der Kompilierungsphase verfügbar sind. </p><br><p>  Für die Erweiterung von <a href="https://github.com/mgechev/revive"><code>revive</code></a> müssen neue Überprüfungen in den Kernel aufgenommen werden.  <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> kann darüber hinaus Plug-ins, mit denen Sie Erweiterungen unabhängig vom Hauptcode sammeln können.  Beide Ansätze implizieren, dass Sie die Manipulationen <a href="https://golang.org/pkg/go/ast/"><code>go/ast</code></a> und <a href="https://golang.org/pkg/go/types/"><code>go/types</code></a> unter Verwendung der linter-API in Go implementieren.  Selbst einfache Prüfungen erfordern <a href="">viel Code</a> . </p><br><p>  <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> zielt darauf ab, das Bild dadurch zu vereinfachen, dass der "Rahmen" des Linter nahezu identisch wird, löst jedoch nicht das Problem der Komplexität der technischen Implementierung der Diagnose selbst. </p><br><div class="spoiler">  <b class="spoiler_title">Exkurs zu `loader` und` go / packages`</b> <div class="spoiler_text"><hr><br><p>  Wenn Sie einen Analyzer für Go schreiben, besteht Ihr letztes Ziel darin, mit AST und Typen zu interagieren. Bevor Sie dies tun können, muss der Quellcode jedoch auf die richtige Weise "geladen" werden.  Zur Vereinfachung umfasst das Konzept des Ladens das <a href="https://golang.org/pkg/go/parser/">Parsen</a> , die Typprüfung und das <a href="https://golang.org/pkg/go/importer/">Importieren von Abhängigkeiten</a> . </p><br><p>  Der erste Schritt zur Vereinfachung dieser Pipeline war das <a href="https://godoc.org/golang.org/x/tools/go/loader"><code>go/loader</code></a> Paket, mit dem Sie über ein paar Aufrufe alles "herunterladen" können, was Sie benötigen.  Alles war fast in Ordnung, und dann wurde er zugunsten von <a href="https://godoc.org/golang.org/x/tools/go/packages"><code>go/packages</code></a> veraltet.  <code>go/packages</code> hat eine leicht verbesserte API und funktioniert theoretisch gut mit Modulen. </p><br><p>  Nun ist es am besten, keine der oben genannten Methoden direkt zum Schreiben von Analysatoren zu verwenden, da <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> <code>go/packages</code> etwas gab, das keine der vorherigen Lösungen hatte - eine Struktur für Ihr Programm.  Jetzt können wir das vorgegebene <code>go/analysis</code> Paradigma verwenden und Analysegeräte effizienter wiederverwenden.  Dieses Paradigma ist umstritten. <code>go/analysis</code> eignet sich beispielsweise gut für die Analyse auf der Ebene eines Pakets und seiner Abhängigkeiten. Eine globale Analyse ohne raffinierte technische Tricks ist jedoch nicht einfach. </p><br><p>  <code>go/analysis</code> vereinfacht auch das <a href="https://godoc.org/golang.org/x/tools/go/analysis/analysistest">Testen von Analysegeräten</a> . </p><br><hr></div></div><br><h1 id="chto-zhe-takoe-ruleguard">  Was ist Herrscher? </h1><br><p><img src="https://habrastorage.org/webt/zp/ym/rj/zpymrjjb8zkqa_c069ccd-yf3xg.png"></p><br><p>  <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> ist ein statisches Analysedienstprogramm, das standardmäßig keine einzelne Prüfung enthält. </p><br><p>  Die Regeln für die <code>ruleguard</code> zu Beginn aus einer speziellen <code>gorules</code> Datei <code>gorules</code> , die deklarativ die <code>gorules</code> beschreibt, für die Warnungen ausgegeben werden sollen.  Diese Datei kann von Benutzern des <code>ruleguard</code> frei bearbeitet werden. </p><br><p>  Es ist nicht notwendig, <code>gorules</code> Steuerprogramm <code>gorules</code> zu <code>gorules</code> , um neue Schecks zu verbinden, daher können die Regeln von <code>gorules</code> als <a href="https://habr.com/ru/company/vk/blog/473718/">dynamisch bezeichnet werden</a> . </p><br><p>  Das <code>ruleguard</code> Kontrolle der <code>ruleguard</code> sieht folgendermaßen aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/analyzer"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/tools/go/analysis/singlechecker"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { singlechecker.Main(analyzer.Analyzer) }</code> </pre> <br><p>  Gleichzeitig wird der <code>analyzer</code> über das Paket <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/ruleguard"><code>ruleguard</code></a> implementiert, das Sie verwenden müssen, wenn Sie ihn als Bibliothek verwenden möchten. </p><br><h1 id="ruleguard-vs-revive">  Herrscher VS wiederbeleben </h1><br><p>  Nehmen wir ein einfaches, aber realistisches Beispiel: Nehmen wir an, wir möchten <a href="https://golang.org/pkg/runtime/"><code>runtime.GC()</code></a> -Aufrufe in unseren Programmen vermeiden.  In revive gibt es dafür bereits eine eigene Diagnose, sie heißt <code>"call-to-gc"</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Call-to-GC-Implementierung (70 Zeilen in Elven)</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"go/ast"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/mgechev/revive/lint"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// CallToGCRule lints calls to the garbage collector. type CallToGCRule struct{} // Apply applies the rule to given file. func (r *CallToGCRule) Apply(file *lint.File, _ lint.Arguments) []lint.Failure { var failures []lint.Failure onFailure := func(failure lint.Failure) { failures = append(failures, failure) } var gcTriggeringFunctions = map[string]map[string]bool{ "runtime": map[string]bool{"GC": true}, } w := lintCallToGC{onFailure, gcTriggeringFunctions} ast.Walk(w, file.AST) return failures } // Name returns the rule name. func (r *CallToGCRule) Name() string { return "call-to-gc" } type lintCallToGC struct { onFailure func(lint.Failure) gcTriggeringFunctions map[string]map[string]bool } func (w lintCallToGC) Visit(node ast.Node) ast.Visitor { ce, ok := node.(*ast.CallExpr) if !ok { return w // nothing to do, the node is not a call } fc, ok := ce.Fun.(*ast.SelectorExpr) if !ok { return nil // nothing to do, the call is not of the form pkg.func(...) } id, ok := fc.X.(*ast.Ident) if !ok { return nil // in case X is not an id (it should be!) } fn := fc.Sel.Name pkg := id.Name if !w.gcTriggeringFunctions[pkg][fn] { return nil // it isn't a call to a GC triggering function } w.onFailure(lint.Failure{ Confidence: 1, Node: node, Category: "bad practice", Failure: "explicit call to the garbage collector", }) return w }</span></span></code> </pre> <br><hr></div></div><br><p>  Vergleichen Sie nun, wie das in <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callToGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { m.Match(<span class="hljs-string"><span class="hljs-string">`runtime.GC()`</span></span>).Report(<span class="hljs-string"><span class="hljs-string">`explicit call to the garbage collector`</span></span>) }</code> </pre> <br><p>  Nichts mehr, nur was wirklich wichtig ist - <code>runtime.GC</code> und die Nachricht, die ausgegeben werden muss, falls die Regel ausgelöst wird. </p><br><p>  Sie fragen sich vielleicht: Ist das alles?  Ich habe speziell mit einem so einfachen Beispiel begonnen, um zu zeigen, wie viel Code für eine sehr triviale Diagnose im Fall des herkömmlichen Ansatzes erforderlich sein könnte.  Ich verspreche, es wird spannendere Beispiele geben. </p><br><h1 id="quick-start">  Schnellstart </h1><br><p>  <code>go-critic</code> verfügt über eine <a href="https://go-critic.github.io/overview"><code>rangeExprCopy</code></a> Diagnose, die potenziell unerwartete Array-Kopien im Code findet. </p><br><p>  Dieser Code wird über eine <strong>Kopie des</strong> Arrays iteriert: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xs [<span class="hljs-number"><span class="hljs-number">2048</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, x := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> xs { <span class="hljs-comment"><span class="hljs-comment">// Copies 2048 bytes // Loop body. }</span></span></code> </pre> <br><p>  Die Lösung für dieses Problem besteht darin, ein Zeichen hinzuzufügen: </p><br><pre> <code class="diff hljs"> var xs [2048]byte - for _, x := range xs { // Copies 2048 bytes + for _, x := range &amp;xs { // No copy // Loop body. }</code> </pre> <br><p>  Höchstwahrscheinlich benötigen Sie dieses Kopieren nicht und die Leistung der korrigierten Version ist immer besser.  Sie können warten, bis der Go-Compiler besser wird, oder Sie können solche Stellen im Code erkennen und sie heute mit demselben <code>go-critic</code> korrigieren. </p><br><p>  Diese Diagnose kann in der <code>gorules</code> Sprache ( <code>rules.go</code> Datei) <code>rules.go</code> werden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { m.Match(<span class="hljs-string"><span class="hljs-string">`for $_, $_ := range $x { $*_ }`</span></span>, <span class="hljs-string"><span class="hljs-string">`for $_, $_ = range $x { $*_ }`</span></span>). Where(m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>].Addressable &amp;&amp; m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>].Type.Size &gt;= <span class="hljs-number"><span class="hljs-number">128</span></span>). Report(<span class="hljs-string"><span class="hljs-string">`$x copy can be avoided with &amp;$x`</span></span>). At(m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>]). Suggest(<span class="hljs-string"><span class="hljs-string">`&amp;$x`</span></span>) }</code> </pre> <br><p>  Die Regel findet alle <code>for-range</code> Schleifen, in denen beide iterierbaren Variablen verwendet werden (dies ist der Fall, der zum Kopieren führt).  Der iterierbare Ausdruck <code>$x</code> muss <a href="https://golang.org/ref/spec"><code>addressable</code></a> und größer als der ausgewählte Schwellenwert in Bytes sein. </p><br><p>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Report()</code></a> definiert die Nachricht, die an den Benutzer ausgegeben werden soll, und <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Suggest()</code></a> beschreibt eine <code>quickfix</code> Vorlage, die in Ihrem Editor über <a href="https://github.com/golang/tools/tree/master/gopls">gopls</a> (LSP) sowie interaktiv verwendet werden kann, wenn <code>ruleguard</code> mit dem Argument <code>ruleguard</code> aufgerufen wird (wir werden darauf zurückkommen).  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>At()</code></a> hängt die Warnung <strong>und den</strong> <code>quickfix</code> an einen bestimmten Teil der Vorlage an.  Wir brauchen dies, um <code>$x</code> durch <code>&amp;$x</code> zu ersetzen, anstatt die gesamte Schleife neu zu schreiben. </p><br><p>  Sowohl <code>Report()</code> als auch <code>Suggest()</code> akzeptieren eine Zeichenfolge, in die die von der Vorlage aus <code>Match()</code> erfassten Ausdrücke interpoliert werden können.  Die vordefinierte Variable <code>$$</code> bedeutet "alle erfassten Fragmente" (als <code>$0</code> in regulären Ausdrücken). </p><br><p>  Erstellen Sie die Datei <code>rangecopy.go</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-comment"><span class="hljs-comment">// sizeof(builtins[...]) = 240 on x86-64 var builtins = [...]string{ "append", "cap", "close", "complex", "copy", "delete", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", } func builtinID(name string) int { for i, s := range builtins { if s == name { return i } } return -1 }</span></span></code> </pre> <br><p>  Jetzt können wir <code>ruleguard</code> : </p><br><pre> <code class="bash hljs">$ ruleguard -rules rules.go -fix rangecopy.go rangecopy.go:12:20: builtins copy can be avoided with &amp;builtins</code> </pre> <br><p>  Wenn wir uns danach <code>rangecopy.go</code> , werden wir eine feste Version sehen, da <code>ruleguard</code> mit dem Parameter <code>ruleguard</code> aufgerufen wurde. </p><br><p>  Die einfachsten Regeln können <code>gorules</code> werden, ohne eine <code>gorules</code> Datei zu erstellen: </p><br><pre> <code class="plaintext hljs">$ ruleguard -c 1 -e 'm.Match(`return -1`)' rangecopy.go rangecopy.go:17:2: return -1 16 } 17 return -1 18 }</code> </pre> <br><p>  Dank der Verwendung von <a href="https://godoc.org/golang.org/x/tools/go/analysis/singlechecker"><code>go/analysis/singlechecker</code></a> haben wir die Option <code>-c</code> , mit der wir die angegebenen Kontextzeilen zusammen mit der Warnung selbst anzeigen können.  Die Steuerung dieses Parameters ist ein wenig eingängig: Der Standardwert ist <code>-c=-1</code> , was bedeutet, dass "kein Kontext" <code>-c=0</code> , und <code>-c=0</code> gibt eine Kontextzeile aus (die von der Diagnose angegebene). </p><br><p>  Hier sind einige weitere interessante <code>gorules</code> : </p><br><ul><li>  <a href="">Geben Sie Vorlagen ein</a> , mit denen Sie die erwarteten Typen angeben können.  Beispielsweise beschreibt die Ausdruckszuordnung <code>map[$t]$t</code> alle Zuordnungen, für die der Werttyp mit dem Typ des Schlüssels übereinstimmt, und <code>*[$len]$elem</code> erfasst alle Zeiger auf Arrays. </li><li>  Innerhalb einer einzelnen Funktion kann es mehrere Regeln geben, <br>  und die Funktionen selbst sollten Regelgruppen genannt <a href="">werden</a> . </li><li>  Die Regeln in der Gruppe werden nacheinander in der Reihenfolge angewendet, in der sie definiert sind.  Die erste Regel, die ausgelöst wird, bricht den Vergleich mit den übrigen Regeln ab.  Dies ist weniger für die Optimierung als vielmehr für die Spezialisierung von Regeln für bestimmte Fälle wichtig.  Ein Beispiel, in dem dies nützlich ist, ist die Regel, <code>$x=$x+$y</code> in <code>$x+=$y</code> umzuschreiben. In dem Fall mit <code>$y=1</code> möchten Sie <code>$x++</code> und nicht <code>$x+=1</code> anbieten. </li></ul><br><p>  Weitere Informationen zum verwendeten DSL finden Sie in <a href=""><code>docs/gorules.md</code></a> . </p><br><h1 id="eschyo-bolshe-primerov">  Weitere Beispiele </h1><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//     json.Decoder. // . http://golang.org/issue/36225 m.Match(`json.NewDecoder($_).Decode($_)`). Report(`this json.Decoder usage is erroneous`) //   unconvert,    . m.Match(`time.Duration($x) * time.Second`). Where(m["x"].Const). Suggest(`$x * time.Second`) //   fmt.Sprint()    String(), //   $x  . m.Match(`fmt.Sprint($x)`). Where(m["x"].Type.Implements(`fmt.Stringer`)). Suggest(`$x.String()`) //   . m.Match(`!($x != $y)`).Suggest(`$x == $y`) m.Match(`!($x == $y)`).Suggest(`$x != $y`) }</span></span></code> </pre> <br><p>  Wenn für die Regel kein <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Report()</code></a> -Aufruf vorhanden ist, wird die von <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Suggest()</code></a> ausgegebene Nachricht verwendet.  Dies ermöglicht in einigen Fällen die Vermeidung von Doppelspurigkeiten. </p><br><p>  Typfilter und Unterausdrücke können verschiedene Eigenschaften prüfen.  Beispielsweise sind die Eigenschaften <code>Pure</code> und <code>Const</code> nützlich: </p><br><ul><li>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Var.Pure</code></a> bedeutet, dass der Ausdruck keine Nebenwirkungen hat. </li><li>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Var.Const</code></a> bedeutet, dass der Ausdruck in einem konstanten Kontext verwendet werden kann (z. B. die Dimension eines Arrays). </li></ul><br><p>  Für <code>package-qualified</code> Namen unter <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Where()</code></a> -Bedingungen müssen Sie die <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Import()</code></a> -Methode verwenden.  Der Einfachheit halber wurden alle Standardpakete für Sie importiert, sodass im obigen Beispiel keine zusätzlichen Importe erforderlich sind. </p><br><h1 id="goanalysis-quickfix-actions">  <code>go/analysis</code> Quickfix-Aktionen </h1><br><p>  Support für <code>quickfix</code> von <code>go/analysis</code> für uns <code>quickfix</code> . </p><br><p>  Im <code>go/analysis</code> Modell generiert der Analysator <a href="https://godoc.org/golang.org/x/tools/go/analysis">Diagnosen</a> und <a href="https://godoc.org/golang.org/x/tools/go/analysis">Fakten</a> .  Die Diagnose wird an die Benutzer gesendet, und die Fakten sind für die Verwendung durch andere Analysegeräte vorgesehen. </p><br><p>  Die Diagnose kann eine Reihe von <a href="https://godoc.org/golang.org/x/tools/go/analysis">vorgeschlagenen Korrekturen enthalten</a> , von denen jede beschreibt, wie die Quellcodes im angegebenen Bereich geändert werden, um das von der Diagnose festgestellte Problem zu beheben. </p><br><p>  Die offizielle Beschreibung finden Sie unter <a href=""><code>go/analysis/doc/suggested_fixes.md</code></a> . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p><img src="https://habrastorage.org/webt/m3/bs/zw/m3bszwzp2nwkxrnxdnenypatyjk.png"></p><br><p>  Versuchen Sie es mit <code>ruleguard</code> für Ihre Projekte. Wenn Sie einen Fehler finden oder nach einer neuen Funktion fragen möchten, <a href="https://github.com/quasilyte/go-ruleguard/issues/new">öffnen Sie ein Problem</a> . </p><br><p>  Wenn Sie immer noch Schwierigkeiten haben, eine Anwendung für die <code>ruleguard</code> finden, finden Sie hier einige Beispiele: </p><br><ul><li>  Implementieren Sie Ihre eigene Diagnose für Go. </li><li>  Aktualisieren oder refaktorisieren Sie den Code automatisch mit <code>-fix</code> . </li><li>  Erfassung von <a href=""><code>-json</code></a> mit <a href=""><code>-json</code></a> Verarbeitung des <a href=""><code>-json</code></a> . </li></ul><br><p>  Entwicklungspläne für <code>ruleguard</code> in naher Zukunft: </p><br><ul><li>  <code>ruleguard</code> <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> <code>ruleguard</code> in <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> , um sie zu erweitern. </li><li>  Probieren Sie Ideen aus der <a href="https://github.com/quasilyte/talks/tree/master/2019-7-Oct-moscow">Ähnlichkeitsanalyse</a> von <a href="https://github.com/quasilyte/talks/tree/master/2019-7-Oct-moscow">Applied Go-Code aus</a> . </li><li>  Fügen Sie DSL neue Funktionen hinzu.  <a href="https://github.com/quasilyte/go-ruleguard/issues/28">Submatches</a> können eine nützliche Ergänzung sein. </li></ul><br><h1 id="poleznye-ssylki-i-resursy">  Nützliche Links und Ressourcen </h1><br><ul><li>  Empfohlene Beispielregeldatei: <a href=""><code>rules.go</code></a> </li><li> <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code> dsl/fluent</code></a> </li> <li> <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/ruleguard"><code> ruleguard</code></a> </li> <li>  Gebrauchte AST <a href="https://github.com/mvdan/gogrep"><code>mvdan/gogrep</code></a> : <a href="https://github.com/mvdan/gogrep"><code>mvdan/gogrep</code></a> </li><li>  <a href="https://habr.com/ru/company/vk/blog/473718/">Dynamische Überprüfungen in NoVerify</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481696/">https://habr.com/ru/post/de481696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481680/index.html">TodoMVC auf dap schreiben. Teil 2</a></li>
<li><a href="../de481684/index.html">Ein Laptop von Powerbank?</a></li>
<li><a href="../de481688/index.html">Warum Java lernen und wie man es effizient macht. Yandex-Bericht</a></li>
<li><a href="../de481692/index.html">Verwenden von Intel Processor Trace zur Verfolgung des Systemverwaltungsmoduscodes</a></li>
<li><a href="../de481694/index.html">Mein Weg zur Partitionierung in PostgreSQL</a></li>
<li><a href="../de481698/index.html">WebRTC-Streaming in und um die virtuelle Realität</a></li>
<li><a href="../de481700/index.html">Über eine Tante</a></li>
<li><a href="../de481702/index.html">Vom Toaster bis zur Drohne. Wie ist das Internet der Dinge entstanden und warum hat es erst 30 Jahre später gefeuert?</a></li>
<li><a href="../de481704/index.html">Dies ist die Norm - 2: wie normale Karten gebacken werden</a></li>
<li><a href="../de481706/index.html">Verlorene Quantencomputer im Rennen und ihre fatalen Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>