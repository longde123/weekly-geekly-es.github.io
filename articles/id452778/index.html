<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😉 📻 📞 Cara mempercepat pembongkaran LZ4 di ClickHouse 👐🏿 🧑🏿‍🤝‍🧑🏾 😄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat menjalankan kueri di ClickHouse, Anda dapat melihat bahwa di profiler, di salah satu tempat pertama, fungsi LZ_decompress_fast sering terlihat. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mempercepat pembongkaran LZ4 di ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/452778/"> Saat menjalankan kueri di ClickHouse, Anda dapat melihat bahwa di profiler, di salah satu tempat pertama, fungsi LZ_decompress_fast sering terlihat.  Mengapa ini terjadi?  Pertanyaan ini menjadi alasan bagi keseluruhan penelitian untuk memilih algoritma dekompresi terbaik.  Di sini saya menerbitkan seluruh penelitian, dan versi singkat dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> saya di HighLoad ++ Siberia. <br><br>  Data ClickHouse disimpan dalam bentuk terkompresi.  Dan selama eksekusi permintaan ClickHouse mencoba melakukan hampir tidak ada - menggunakan sumber daya CPU minimum.  Itu terjadi bahwa semua perhitungan yang bisa memakan waktu cukup lama sudah dioptimalkan dengan baik, dan permintaan ditulis dengan baik oleh pengguna.  Kemudian tetap melakukan rilis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/057/302/aba/057302aba5041790af404c2c781c4dd3.png"><br><br>  Pertanyaannya adalah - mengapa pembongkaran LZ4 bisa menjadi hambatan?  Tampaknya LZ4 adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma yang sangat ringan</a> : tingkat kompresi, tergantung pada data, biasanya berkisar antara 1 hingga 3 GB / s per inti prosesor.  Ini secara signifikan lebih dari kecepatan subsistem disk.  Selain itu, kami menggunakan semua kernel yang tersedia, dan skala ekspansi secara linear di semua kernel fisik. <br><a name="habracut"></a><br>  Tetapi ada dua hal yang perlu diingat.  Pertama, data terkompresi dibaca dari disk, dan tingkat kompresi diberikan dalam jumlah data yang tidak terkompresi.  Jika rasio kompresi cukup besar, maka hampir tidak ada yang perlu dibaca dari disk.  Tetapi pada saat yang sama, banyak data terkompresi dihasilkan, dan tentu saja, ini mempengaruhi konsumsi CPU: jumlah pekerjaan kompresi data dalam kasus LZ4 hampir sebanding dengan volume data terkompresi itu sendiri. <br><br>  Kedua, membaca data dari disk mungkin tidak diperlukan sama sekali jika data ada dalam cache.  Untuk melakukan ini, Anda bisa mengandalkan cache halaman atau menggunakan cache Anda sendiri.  Dalam database kolom, menggunakan cache lebih efisien karena faktanya tidak semua kolom termasuk di dalamnya, tetapi hanya yang sering digunakan.  Inilah sebabnya mengapa LZ4, dalam hal beban CPU, sering menjadi hambatan. <br><br>  Karena itu dua pertanyaan lagi.  Jika kompresi data "melambat", maka mungkin mereka tidak boleh dikompresi sama sekali?  Namun dalam praktiknya, anggapan ini tidak ada artinya.  Baru-baru ini di ClickHouse hanya dimungkinkan untuk mengkonfigurasi dua opsi kompresi data - LZ4 dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zstandard</a> .  Standarnya adalah LZ4.  Dengan beralih ke Zstandard, Anda dapat membuat kompresi lebih kuat dan lebih lambat.  Tetapi tidak mungkin untuk sepenuhnya menonaktifkan kompresi hingga saat ini - LZ4 dianggap sebagai minimum yang wajar, yang selalu dapat digunakan.  Itu sebabnya saya sangat suka LZ4.  :) <br><br>  Namun baru-baru ini, seorang asing muncul di obrolan berbahasa Inggris ClickHouse, yang mengatakan bahwa ia memiliki subsistem disk yang sangat cepat (NVMe SSD) dan semuanya tergantung pada kompresi - alangkah baiknya untuk dapat mematikannya.  Saya menjawab bahwa tidak ada kemungkinan seperti itu, tetapi mudah untuk ditambahkan.  Beberapa hari kemudian kami menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan kumpulan</a> , yang menerapkan metode <code>none</code> kompresi.  Saya meminta hasilnya - seberapa banyak ini membantu, seberapa cepat permintaan.  Orang itu mengatakan bahwa fitur baru ini ternyata tidak berguna dalam praktik, karena data tanpa kompresi mulai memakan terlalu banyak ruang. <br><br>  Pertanyaan kedua yang muncul adalah: jika ada cache, mengapa tidak menyimpan data yang sudah terkompresi di dalamnya?  Ini diperbolehkan - dalam banyak kasus akan mungkin untuk menghilangkan kebutuhan untuk dekompresi.  Dan di ClickHouse ada cache seperti itu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache dari blok yang diperluas</a> .  Namun sayang untuk menghabiskan banyak RAM di sana karena efisiensinya yang rendah.  Itu membenarkan dirinya hanya pada permintaan kecil, berturut-turut yang menggunakan data yang hampir sama. <br><br>  Pertimbangan umum: data harus dikompresi, sebaiknya selalu.  Selalu bakar mereka ke disk yang dikompresi.  Mengirimkan melalui jaringan juga dengan kompresi.  Menurut pendapat saya, kompresi default harus dianggap dibenarkan bahkan ketika mentransfer ke jaringan 10-gigabit tanpa kelebihan langganan dalam pusat data, dan mentransfer data tanpa kompresi antara pusat data umumnya tidak dapat diterima. <br><br><h3>  Mengapa LZ4? </h3><br>  Mengapa LZ4 digunakan?  Apakah mungkin untuk memilih sesuatu yang lebih mudah?  Pada prinsipnya, itu mungkin, dan itu benar dan bermanfaat.  Tapi mari kita lihat dulu kelas algoritma apa yang dimiliki LZ4. <br><br>  Pertama, itu tidak tergantung pada tipe data.  Misalnya, jika Anda tahu sebelumnya bahwa Anda akan memiliki array bilangan bulat, maka Anda dapat menggunakan salah satu dari banyak varian algoritma VarInt - itu akan lebih efisien pada CPU.  Kedua, LZ4 tidak terlalu bergantung pada asumsi yang diperlukan pada model data.  Misalkan Anda memiliki serangkaian waktu pembacaan sensor - array dengan jumlah tipe float.  Kemudian Anda dapat menghitung delta dan kemudian kompres lebih lanjut, dan ini akan lebih efisien dalam hal rasio kompresi. <br><br>  Artinya, LZ4 dapat digunakan tanpa masalah untuk setiap byte array - untuk file apa pun.  Tentu saja, ia memiliki spesialisasi sendiri (lebih lanjut tentang itu di bawah), dan dalam beberapa kasus penggunaannya tidak ada artinya.  Tetapi jika Anda menyebutnya algoritma tujuan umum, ini akan menjadi kesalahan kecil.  Dan perhatikan bahwa, berkat perangkat internal, LZ4 secara otomatis mengimplementasikan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RLE</a> sebagai kasus khusus. <br><br>  Pertanyaan lain: apakah LZ4 algoritma yang paling optimal dari kelas ini untuk kombinasi kecepatan dan gaya kompresi?  Algoritma semacam ini disebut pareto frontier - ini berarti bahwa tidak ada algoritma lain yang benar-benar lebih baik dalam satu indikator dan tidak lebih buruk pada yang lain (dan bahkan pada berbagai dataset).  Ada algoritma yang lebih cepat, tetapi memberikan rasio kompresi yang lebih rendah, dan ada yang kompres lebih banyak, tetapi pada saat yang sama kompres atau dekompresi lebih lambat. <br><br>  Faktanya, LZ4 bukan perbatasan pareto.  Ada opsi yang sedikit lebih baik.  Misalnya, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LZTURBO</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">powturbo</a> tertentu.  Tidak ada keraguan dalam keandalan hasil berkat komunitas di encode.ru (forum terbesar dan kira-kira satu-satunya untuk kompresi data).  Tetapi pengembang tidak mendistribusikan kode sumber atau binari, tetapi hanya memberikannya kepada lingkaran orang terbatas untuk pengujian atau untuk banyak uang (seperti belum ada yang membayar sejauh ini).  Juga patut diperhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lizard</a> (sebelumnya LZ5) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Density</a> .  Mereka dapat bekerja sedikit lebih baik daripada LZ4 ketika memilih beberapa level kompresi.  Perhatikan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LZSSE</a> - hal yang sangat menarik.  Namun, lebih baik melihatnya setelah membaca artikel ini. <br><br><h3>  Bagaimana cara kerja LZ4? </h3><br>  Mari kita lihat bagaimana LZ4 bekerja secara umum.  Ini adalah salah satu implementasi dari algoritma LZ77: L dan Z menunjukkan nama-nama penulis (Lempel dan Ziv), dan 77 - pada tahun 1977, ketika algoritma tersebut dipublikasikan.  Ini memiliki banyak implementasi lain: QuickLZ, FastLZ, BriefLZ, LZF, LZO, serta gzip dan zip saat menggunakan level kompresi rendah. <br><br>  Blok data yang dikompres menggunakan LZ4 berisi urutan catatan (perintah, instruksi) dari dua jenis: <br><br><ol><li>  Literal: "ambil N byte berikutnya apa adanya dan salin ke hasilnya." </li><li>  Match (pertandingan): "ambil N byte yang sudah didekompresi oleh offset offset dari posisi saat ini." </li></ol><br>  Sebuah contoh  Sebelum kompresi: <br> <code>Hello world Hello</code> <br> <br>  Setelah kompresi: <br> <code>literals 12 "Hello world " match 5 12</code> <br> <br>  Jika kita mengambil blok terkompresi dan melewatinya dengan kursor, menjalankan perintah ini, maka kita akan mendapatkan data awal yang tidak terkompresi sebagai hasilnya. <br><br>  Kami secara kasar melihat bagaimana data tersebut didekompresi.  Intinya juga jelas: untuk melakukan kompresi, algoritma mengkodekan urutan byte berulang menggunakan kecocokan. <br><br>  Hapus dan beberapa properti.  Algoritma ini berorientasi byte - tidak membedah byte individual, tetapi hanya menyalinnya secara keseluruhan.  Di sinilah letak perbedaan, misalnya, dari pengkodean entropi.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zstd</a> adalah komposisi LZ77 dan pengkodean entropi. <br><br>  Perhatikan bahwa ukuran blok terkompresi tidak dipilih terlalu besar sehingga tidak menghabiskan banyak RAM selama pembongkaran;  agar tidak memperlambat akses acak dalam file terkompresi (yang terdiri dari banyak blok terkompresi);  dan kadang-kadang agar blok cocok dengan beberapa cache CPU.  Misalnya, Anda dapat memilih 64 KB - jadi buffer untuk data terkompresi dan tidak terkompresi akan muat dalam cache L2 dan setengahnya akan tetap. <br><br>  Jika kita perlu mengompres file yang lebih besar, kita hanya akan menggabungkan blok terkompresi.  Pada saat yang sama, di sebelah setiap blok terkompresi, lebih nyaman untuk menempatkan data tambahan - ukuran, jumlah cek. <br><br>  Offset maksimum untuk pertandingan terbatas, dalam LZ4 - 64 kilobyte.  Nilai ini disebut jendela geser.  Memang, ini berarti bahwa ketika kursor bergerak maju, kecocokan bisa berada dalam jendela berukuran 64 kilobyte dengan kursor, yang bergerak dengan kursor. <br><br>  Sekarang mari kita lihat bagaimana mengompres data - dengan kata lain, bagaimana menemukan urutan yang cocok dalam suatu file.  Tentu saja, Anda dapat menggunakan sufiks trie (hebat jika Anda pernah mendengarnya).  Ada beberapa opsi di mana urutan pencocokan terpanjang dijamin berada di antara byte sebelumnya dalam proses kompresi.  Ini disebut penguraian optimal dan memberikan rasio kompresi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hampir</a> lebih baik untuk format blok terkompresi tetap.  Tetapi ada opsi yang lebih efektif - ketika kami menemukan kecocokan yang cukup baik dalam data, tetapi belum tentu yang terpanjang.  Cara paling efisien untuk menemukannya adalah dengan menggunakan tabel hash. <br><br>  Untuk melakukan ini, kita pergi melalui blok data sumber dengan kursor dan mengambil beberapa byte setelah kursor.  Misalnya, 4 byte.  Hash mereka dan letakkan di tabel hash offset dari awal blok - di mana 4 byte ini bertemu.  Nilai 4 disebut min-match - dengan bantuan tabel hash seperti itu kita dapat menemukan kecocokan setidaknya 4 byte. <br><br>  Jika kita melihat tabel hash, dan sudah ada catatan di sana, dan jika offset tidak melebihi jendela geser, maka kita memeriksa berapa banyak byte yang cocok setelah empat byte ini.  Mungkin ada lebih banyak yang bertepatan.  Mungkin juga tabrakan telah terjadi di tabel hash dan tidak ada yang cocok.  Ini normal - Anda cukup mengganti nilai di tabel hash dengan yang baru.  Tabrakan di tabel hash hanya akan menghasilkan rasio kompresi yang lebih rendah karena ada lebih sedikit kecocokan.  Omong-omong, tabel hash semacam ini (dengan ukuran tetap dan tanpa resolusi tabrakan) disebut tabel cache, tabel cache.  Ini juga logis - jika terjadi tabrakan, tabel cache hanya lupa tentang catatan lama. <br><blockquote>  Tugas untuk pembaca yang penuh perhatian.  Biarkan data menjadi array angka seperti UInt32 dalam format endian kecil, yang merupakan bagian dari urutan bilangan asli: 0, 1, 2 ... Jelaskan mengapa ketika menggunakan LZ4 data ini tidak dikompresi (jumlah data terkompresi tidak kurang dari jumlah data yang tidak terkompresi). </blockquote><h3>  Cara mempercepat </h3><br>  Jadi, saya ingin mempercepat pembongkaran LZ4.  Mari kita lihat seperti apa siklus bongkar muat itu.  Inilah loop dalam pseudocode: <br><br><pre>  sementara (...)
 {
     baca (input_pos, literal_length, match_length);<font></font>
<font></font>
     salin (output_pos, input_pos, literal_length);
     output_pos + = literal_length;<font></font>
<font></font>
     baca (input_pos, match_offset);<font></font>
<font></font>
     salin (output_pos, output_pos - match_offset,
         match_length);
     output_pos + = match_length;
 } </pre><br>  Format LZ4 dirancang sehingga literal dan cocok berganti dalam file terkompresi.  Dan tentu saja, literal selalu didahulukan (karena sejak awal pertandingan tidak memiliki tempat untuk mendapatkan dari).  Oleh karena itu, panjangnya dikodekan bersama. <br><br>  Faktanya, semuanya sedikit lebih rumit.  Satu byte dibaca dari file, dan dua nibble diambil darinya, di mana angka 0 hingga 15 dikodekan.Jika angka yang sesuai tidak sama dengan 15, maka itu dianggap sebagai panjang literal dan cocok, masing-masing.  Dan jika 15, maka panjangnya lebih panjang dan dikodekan dalam byte berikut.  Kemudian byte selanjutnya dibaca, dan nilainya ditambahkan ke panjangnya.  Selanjutnya, jika itu sama dengan 255, maka kita melanjutkan - kita membaca byte berikutnya dengan cara yang sama. <br><br>  Perhatikan bahwa rasio kompresi maksimum untuk format LZ4 tidak mencapai 255. Dan pengamatan kedua (tidak berguna): jika data Anda sangat berlebihan, maka menggunakan LZ4 akan menggandakan rasio kompresi yang meningkat dua kali lipat. <br><br>  Ketika kita membaca panjang literal (dan kemudian juga panjang korek api dan offset korek api), untuk mengosongkannya cukup dengan menyalin dua keping memori saja. <br><br><h3>  Cara menyalin sepotong memori </h3><br>  Tampaknya Anda dapat menggunakan fungsi <code>memcpy</code> , yang hanya dirancang untuk menyalin keping memori.  Tetapi ini tidak optimal dan masih salah. <br><br>  Mengapa penggunaan fungsi memcpy suboptimal?  Karena dia: <br><br><ol><li>  biasanya terletak di perpustakaan libc (dan perpustakaan libc biasanya terhubung secara dinamis, dan panggilan memcpy akan masuk secara tidak langsung, melalui PLT), </li><li>  tidak sejalan dengan argumen ukuran yang tidak diketahui dalam waktu kompilasi, </li><li>  membuat banyak upaya untuk dengan benar memproses "ekor" dari fragmen memori yang tidak kelipatan dari ukuran kata mesin atau register. </li></ol><br>  Poin terakhir adalah yang paling penting.  Misalkan kita meminta fungsi memcpy untuk menyalin tepat 5 byte.  Akan sangat bagus untuk menyalin 8 byte sekaligus, menggunakan dua instruksi movq untuk ini. <br><br> <code>Hello world <font color="#0fc000">Hello</font> <font color="#ff0000">wo</font> ... <br> ^^^^^ <font color="#ff0000">^^^</font> - src <br> ^^^^^ <font color="#ff0000">^^^</font> - dst</code> <br> <br>  Tapi kemudian kita akan menyalin tiga byte tambahan - yaitu, kita akan menulis di luar negeri buffer yang ditransfer.  Fungsi <code>memcpy</code> tidak memiliki hak untuk melakukan ini - memang, karena kami akan menimpa beberapa data dalam program kami, akan ada "bagian" dari memori.  Dan jika kita menulis di alamat yang tidak selaras, maka byte tambahan ini dapat ditemukan pada halaman memori virtual yang tidak terisi atau pada halaman tanpa akses tulis.  Lalu kita mendapatkan segfault (itu bagus). <br><br>  Tetapi dalam kasus kami, kami hampir selalu dapat menulis byte tambahan.  Kita dapat membaca byte tambahan di buffer input selama byte tambahan terletak di dalamnya sepenuhnya.  Dalam kondisi yang sama, kita dapat menulis byte tambahan ke buffer output - karena pada iterasi selanjutnya kita akan menimpanya. <br><br>  Optimasi ini sudah dalam implementasi LZ4 asli: <br><br><pre>  inline void copy8 (UInt8 * dst, const UInt8 * src)
 {
     memcpy (dst, src, 8);  /// Sebenarnya, memcpy tidak dipanggil di sini.
 }<font></font>
<font></font>
 inline void wildCopy8 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     lakukan
     {
         copy8 (dst, src);
         dst + = 8;
         src + = 8;
     } while (dst &lt;dst_end);
 } </pre><br>  Untuk memanfaatkan optimisasi ini, Anda hanya perlu memverifikasi bahwa kami cukup jauh dari batas buffer.  Ini harus gratis, karena kami sudah memeriksa bahwa batas buffer terlampaui.  Dan pemrosesan beberapa byte terakhir - "ekor" dari data - dapat dilakukan setelah loop utama. <br><br>  Namun, masih ada beberapa kehalusan.  Ada dua salinan dalam siklus - literal dan kecocokan.  Tetapi ketika menggunakan fungsi LZ4_decompress_fast (bukan LZ4_decompress_safe), pemeriksaan dilakukan sekali - ketika kita perlu menyalin literal.  Saat menyalin pertandingan, pemeriksaan tidak dilakukan, tetapi dalam <a href="">spesifikasi format LZ4</a> ada beberapa kondisi yang memungkinkannya untuk dihindari: <br><br><blockquote>  5 byte terakhir selalu literal <br>  Pertandingan terakhir harus dimulai setidaknya 12 byte sebelum akhir blok. <br>  Akibatnya, sebuah blok dengan kurang dari 13 byte tidak dapat dikompres. </blockquote><br>  Data input yang dipilih secara khusus dapat menyebabkan drive memori.  Jika Anda menggunakan fungsi LZ4_decompress_fast, Anda perlu perlindungan terhadap data yang buruk.  Data yang dikompresi harus setidaknya merupakan jumlah pemeriksaan.  Dan jika Anda membutuhkan perlindungan terhadap penyerang, maka gunakan fungsi LZ4_decompress_safe.  Pilihan lain: mengambil fungsi hash kriptografi sebagai jumlah cek, tetapi hampir pasti akan membunuh semua kinerja;  baik mengalokasikan lebih banyak memori untuk buffer;  baik mengalokasikan memori untuk buffer dengan panggilan terpisah ke mmap dan membuat halaman penjaga. <br><br>  Ketika saya melihat kode yang menyalin data 8 byte, saya langsung bertanya - mengapa tepatnya 8 byte?  Anda dapat menyalin 16 byte menggunakan register SSE: <br><br><pre>  inline void copy16 (UInt8 * dst, const UInt8 * src)
 {
 #jika __SSE2__
     _mm_storeu_si128 (reinterpret_cast &lt;__ m128i *&gt; (dst),
         _mm_loadu_si128 (reinterpret_cast &lt;const __m128i *&gt; (src)));
 #else
     memcpy (dst, src, 16);
 #endif
 }<font></font>
<font></font>
 inline void wildCopy16 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     lakukan
     {
         copy16 (dst, src);
         dst + = 16;
         src + = 16;
     } while (dst &lt;dst_end);
 } </pre><br>  Menyalin 32 byte untuk AVX dan 64 byte untuk AVX-512 bekerja dengan cara yang sama.  Selain itu, Anda dapat memperluas siklus beberapa kali.  Jika Anda pernah melihat bagaimana <code>memcpy</code> diimplementasikan, maka inilah pendekatan yang tepat.  (Omong-omong, kompiler dalam kasus ini tidak akan memperluas atau membuat vektor loop, ini akan membutuhkan penyisipan pemeriksaan rumit.) <br><br>  Mengapa ini tidak dilakukan dalam implementasi LZ4 asli?  Pertama, tidak jelas apakah ini lebih baik atau lebih buruk.  Hasilnya tergantung pada ukuran fragmen yang perlu disalin.  Tiba-tiba mereka semua pendek dan kerja ekstra akan sia-sia?  Dan kedua, itu menghancurkan kondisi tersebut dalam format LZ4 yang memungkinkan Anda untuk menghindari brunch yang tidak perlu di loop dalam. <br><br>  Namun demikian, kami akan tetap mengingat opsi ini untuk saat ini. <br><br><h3>  Salinan rumit </h3><br>  Kembali ke pertanyaan - apakah selalu mungkin untuk menyalin data dengan cara ini?  Misalkan kita perlu menyalin kecocokan - yaitu, menyalin sepotong memori dari buffer output yang diimbangi di belakang kursor ke posisi kursor ini. <br><br>  Bayangkan kasing sederhana - Anda perlu menyalin 5 byte pada offset 12: <br><br> <code><font color="#0fc000">Hello</font> world ........... <br> ^^^^^ - src <br> ^^^^^ - dst <br> <br> Hello world <font color="#0fc000">Hello</font> <font color="#a8a8a8">wo</font> ... <br> ^^^^^ - src <br> ^^^^^ - dst</code> <br> <br>  Tetapi ada kasus yang lebih rumit - ketika kita perlu menyalin sepotong memori yang panjangnya lebih besar dari offset.  Yaitu, sebagian mengindikasikan data yang belum ditulis ke buffer output. <br><br>  Salin 10 byte pada offset 3: <br><br> <code><font color="#0fc000">abc</font> ............. <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst <br> <br> abc <font color="#0fc000">abcabcabca</font> ... <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst</code> <br> <br>  Dalam proses kompresi, kami memiliki semua data, dan kecocokan tersebut dapat ditemukan.  Fungsi <code>memcpy</code> tidak cocok untuk menyalinnya: ia tidak mendukung kasing ketika rentang fragmen memori berpotongan.  By the way, fungsi <code>memmove</code> juga tidak cocok, karena fragmen memori dari mana untuk mendapatkan data belum sepenuhnya diinisialisasi.  Anda perlu menyalin seolah-olah kami menyalin dengan byte. <br><br><pre>  op [0] = cocok [0];
 op [1] = cocok [1];
 op [2] = cocok [2];
 op [3] = cocok [3];
 ... </pre><br><br>  Begini cara kerjanya: <br><br> <code><font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ............ <br> ^ - src <br> ^ - dst <br> <br> a <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........... <br> ^ - src <br> ^ - dst <br> <br> ab <font color="#0fc000">c</font> ab <font color="#0fc000">c</font> .......... <br> ^ - src <br> ^ - dst <br> <br> abc <font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ......... <br> ^ - src <br> ^ - dst <br> <br> abca <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........ <br> ^ - src <br> ^ - dst</code> <br> <br>  Artinya, kita harus membuat urutan yang berulang.  Dalam implementasi LZ4 asli, kode yang sangat tidak dapat dimengerti ditulis untuk ini: <br><br><pre>  const unsigned dec32table [] = {0, 1, 2, 1, 4, 4, 4, 4};
 dec64tabel kon int [] = {0, 0, 0, -1, 0, 1, 2, 3};<font></font>
<font></font>
 const int dec64 = dec64table [offset];
 op [0] = cocok [0];
 op [1] = cocok [1];
 op [2] = cocok [2];
 op [3] = cocok [3];
 match + = dec32table [offset];
 memcpy (op + 4, match, 4);
 cocok - = dec64; </pre><br>  Kami menyalin 4 byte pertama byte-demi-bit, bergeser dengan beberapa angka ajaib, menyalin 4 byte berikutnya secara keseluruhan, menggeser pointer untuk mencocokkan dengan angka ajaib lainnya.  Penulis kode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jan Collet</a> ), untuk beberapa alasan konyol, lupa untuk meninggalkan komentar tentang apa artinya ini.  Selain itu, nama variabel membingungkan.  Keduanya disebut tabel dec ..., tetapi kami menambahkan satu dan mengurangi yang lain.  Selain itu, yang lain tidak ditandatangani, dan yang lainnya adalah int.  Namun, ada baiknya membayar upeti: baru-baru ini, penulis memperbaiki tempat ini dalam kode. <br><br>  Begini cara kerjanya.  Salin 4 byte pertama byte: <br><br> <code>abc <font color="#0fc000">abca</font> ......... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>  Sekarang Anda dapat menyalin 4 byte sekaligus: <br><br> <code>abcabca <font color="#0fc000">bcab</font> ..... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>  Anda dapat melanjutkan seperti biasa dengan menyalin 8 byte sekaligus: <br><br> <code>abcabcabcab <font color="#0fc000">cabcabca</font> ..... <br> ^^^^^^^^ - src <br> ^^^^^^^^ - dst</code> <br> <br>     ,      —   .   : <br><br><pre> inline void copyOverlap8(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    /// Or if 4 % n is zero, we use n.<font></font>
    /// It gives equivalent result, but is better CPU friendly for unknown reason.<font></font>
    static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
} </pre><br> ,  ,   . ,     ,     —   16 . <br><br>    « »    ,     ( <code>offset &lt; 16</code>   ,  <code>offset &lt; 8</code> ).  ()     16-   : <br><br><pre> inline void copyOverlap16(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    static constexpr int shift1[]<font></font>
        = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[]<font></font>
        = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 16 % n - 8 % n<font></font>
    static constexpr int shift3[]<font></font>
        = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
    memcpy(op + 8, match, 8);<font></font>
    match += shift3[offset];<font></font>
} </pre><br>       ?  ,        SIMD-,       16 ,         ( 1  15). ,   ,      . <br><br>    —   <code>pshufb</code> (  packed shuffle bytes)    SSSE3 (  S).    16- .      .   — «»:       0  15 —    ,       . ,      127 —     . <br><br>  Berikut ini sebuah contoh: <br><br><pre> xmm0: abc.............<font></font>
xmm1: 0120120120120120<font></font>
<font></font>
pshufb %xmm1, %xmm0<font></font>
<font></font>
xmm0: abcabcabcabcabca </pre><br>           —      !      : <br><br><pre> inline void copyOverlap16Shuffle(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
#ifdef __SSSE3__<font></font>
<font></font>
    static constexpr UInt8 __attribute__((__aligned__(16))) masks[] =<font></font>
    {<font></font>
        0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /* offset = 0, not used as mask, but for shift amount instead */<font></font>
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* offset = 1 */<font></font>
        0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,<font></font>
        0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,<font></font>
        0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0,<font></font>
        0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0,<font></font>
    };<font></font>
<font></font>
    _mm_storeu_si128(reinterpret_cast&lt;__m128i *&gt;(op),<font></font>
        _mm_shuffle_epi8(<font></font>
            _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(match)),<font></font>
            _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(masks) + offset)));<font></font>
<font></font>
    match += masks[offset];<font></font>
<font></font>
#else<font></font>
    copyOverlap16(op, match, offset);<font></font>
#endif<font></font>
} </pre><br>  <code>_mm_shuffle_epi8</code> —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intrinsic</a> ,    <code>pshufb</code> . <br><br>          ,    ?  SSSE3 —    ,   2006 .  AVX2  ,      32 ,      16- .     packed shuffle bytes,  vector permute bytes —  ,    .  AVX-512 VBMI    ,    64 ,        .      ARM NEON —   vtbl (vector table lookup),     8 . <br><br>  ,    <code>pshufb</code>  64- MMX-,   8 .         . ,        ,   16  (  ). <br><br>   Highload++ Siberia         ,    8          (  ) —       ! <br><br><h3>    if </h3><br> ,    ,   16 .         ? <br><br>  ,       .      ,           ,  ,         .    ,     . <br><br> ,    . , ,    ,      65 536 .        65 536    .           , ,  65 551 .  ,  ,       96   128  —     .     ,           «»      mmap    (     madvice).      - page faults.         ,    . <br><br><h3>   ? </h3><br> ,    ,     : <br><br><ol><li>   16   8. </li><li>  shuffle-   <code>offset &lt; 16</code> . </li><li>    if. </li></ol><br>              . <br><br>  Contoh 1: <br> Xeon E2650v2,  .,  AppVersion. <br> reference: 1.67 GB/sec. <br> 16 bytes, shuffle: 2.94 GB/sec ( 76% ). <br><br>  Contoh 2: <br> Xeon E2650v2,  .,  ShowsSumPosition. <br> reference: 2.30 GB/sec. <br> 16 bytes, shuffle: 1.91 GB/sec ( 20% ). <br><br>   ,         .     ,    .   - ,   .   ,      .     —       16 .  :    ,     ,   . <br><br>   ,     C++      :  8-  16-  ;     shuffle-. <br><br><pre> template &lt;size_t copy_amount, bool use_shuffle&gt;<font></font>
void NO_INLINE decompressImpl(<font></font>
     const char * const source,<font></font>
     char * const dest,<font></font>
     size_t dest_size) </pre><br>        ,         shuffle  .     ,   : <br><br><pre> sudo echo 'performance' | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor<font></font>
kill -STOP $(pidof firefox) $(pidof chromium) </pre><br>        «»  (c  Xeon E5645),           ,    . ,         ,    .    ,    shuffle-,   ,      16- . <br><br>         : <br><br><pre> sudo kill -STOP $(pidof python) $(pidof perl) $(pgrep -u skynet) $(pidof cqudp-client) </pre><br>    .    thermal throttling  power capping. <br><br><h3>     </h3><br> ,      ,        .         ,         ,    .       .       , ,     .   : ClickHouse      ,       ,         .       ,             (       —  ?).      . <br><br>      ,    ,      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">« »</a> .   ,      ,           ,    . <br><br>      ,   .        .       -        .             —   ClickHouse      64 . ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   .) <br><br>  ,     « », ,    .      ,     ,   ,   -   .           .            ,          ,    .      . <br><br>         ,          ,       .    «»     ,    .     ,        .    Thompson Sampling. <br><br> ,   ,    .  —      :  ,  .          .     ,     .       ,           C++.     — ,     -   ,   ;     . <br><br>     ?      ,       .    . -,      ,         . -,  ,   ,   «» . <br><br> ,  ,           Thompson Sampling —   (   ,        ).   ,         ,         - ,     ,      .           ,     . <br><br>   ,   «» .   ,     ,        «»,     .      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> .    ,     ,       . <br><br>       ,   ,    ,    ,   «»: <br><br><pre> /// For better convergence, we don't use proper estimate of stddev.<font></font>
/// We want to eventually separate between two algorithms even in case<font></font>
/// when there is no statistical significant difference between them.<font></font>
double sigma() const<font></font>
{<font></font>
    return mean() / sqrt(adjustedCount());<font></font>
}<font></font>
<font></font>
double sample(pcg64 &amp; rng) const<font></font>
{<font></font>
     ...<font></font>
    return std::normal_distribution&lt;&gt;(mean(), sigma())(rng);<font></font>
} </pre><br>    ,       —    memory latencies. <br><br>   ,         ,       —    LZ4    . <br><br>  ,    : <br> — reference (baseline):  LZ4   ; <br> — variant 0:   8 ,   shuffle; <br> — variant 1:   8 ,  shuffle; <br> — variant 2:   16 ,   shuffle; <br> — variant 3:   16 ,  shuffle; <br> — «» ,            . <br><br><h3>    CPU </h3><br>       CPU,    ,  .  ,   CPU   ? <br><br>         ClickHouse   ,  256    100    ( 256  ).  ,  CPU  ,      .      CPU: <br> — Intel® Xeon® CPU E5-2650 v2 @ 2.60GHz <br> — Intel® Xeon® CPU E5-2660 v4 @ 2.00GHz <br> — Intel® Xeon® CPU E5-2660 0 @ 2.20GHz <br> — Intel® Xeon® CPU E5645 @ 2.40GHz <br> — Intel Xeon E312xx (Sandy Bridge) <br> — AMD Opteron(TM) Processor 6274 <br> — AMD Opteron(tm) Processor 6380 <br> — Intel® Xeon® CPU E5-2683 v4 @ 2.10GHz <br> — Intel® Xeon® CPU E5530 @ 2.40GHz <br> — Intel® Xeon® CPU E5440 @ 2.83GHz <br> — Intel® Xeon® CPU E5-2667 v2 @ 3.30GHz <br><br>    — ,   R&amp;D: <br> — AMD EPYC 7351 16-Core Processor —    AMD. <br> — Cavium ThunderX2 —     x86,  AArch64.    SIMD-   .    224   56  . <br><br>  13 ,        256   6  (reference, 0, 1, 2, 3, adaptive),    10 ,   .  199 680 ,    . <br><br> ,    CPU  .         :      LZ4    (   —  ).  ,  Cavium   .       ClickHouse,   «» Xeon E5-2650 v2         ,      ,   ClickHouse    x86. <br><br><pre> ┌─cpu───────────────────┬──ref─┬─adapt─┬──max─┬─best─┬─adapt_boost─┬─max_boost─┬─adapt_over_max─┐<font></font>
│ E5-2667 v2 @ 3.30GHz │ 2.81 │ 3.19 │ 3.15 │ 3 │ 1.14 │ 1.12 │ 1.01 │<font></font>
│ E5-2650 v2 @ 2.60GHz │ 2.5 │ 2.84 │ 2.81 │ 3 │ 1.14 │ 1.12 │ 1.01 │<font></font>
│ E5-2683 v4 @ 2.10GHz │ 2.26 │ 2.63 │ 2.59 │ 3 │ 1.16 │ 1.15 │ 1.02 │<font></font>
│ E5-2660 v4 @ 2.00GHz │ 2.15 │ 2.49 │ 2.46 │ 3 │ 1.16 │ 1.14 │ 1.01 │<font></font>
│ AMD EPYC 7351 │ 2.03 │ 2.44 │ 2.35 │ 3 │ 1.20 │ 1.16 │ 1.04 │<font></font>
│ E5-2660 0 @ 2.20GHz │ 2.13 │ 2.39 │ 2.37 │ 3 │ 1.12 │ 1.11 │ 1.01 │<font></font>
│ E312xx (Sandy Bridge) │ 1.97 │ 2.2 │ 2.18 │ 3 │ 1.12 │ 1.11 │ 1.01 │<font></font>
│ E5530 @ 2.40GHz │ 1.65 │ 1.93 │ 1.94 │ 3 │ 1.17 │ 1.18 │ 0.99 │<font></font>
│ E5645 @ 2.40GHz │ 1.65 │ 1.92 │ 1.94 │ 3 │ 1.16 │ 1.18 │ 0.99 │<font></font>
│ AMD Opteron 6380 │ 1.47 │ 1.58 │ 1.56 │ 1 │ 1.07 │ 1.06 │ 1.01 │<font></font>
│ AMD Opteron 6274 │ 1.15 │ 1.35 │ 1.35 │ 1 │ 1.17 │ 1.17 │ 1 │<font></font>
│ E5440 @ 2.83GHz │ 1.35 │ 1.33 │ 1.42 │ 1 │ 0.99 │ 1.05 │ 0.94 │<font></font>
│ Cavium ThunderX2 │ 0.84 │ 0.87 │ 0.87 │ 0 │ 1.04 │ 1.04 │ 1 │<font></font>
└───────────────────────┴──────┴───────┴──────┴──────┴─────────────┴───────────┴────────────────┘ </pre><br> ref, adapt, max —       (,            ). best —      ,  0  3. adapt_boost —        baseline. max_boost —          baseline. adapt_over_max —         . <br><br>  ,    x86      12–20%.   ARM    4%,   ,         .  ,        «»              Intel. <br><br><h3>  Kesimpulan </h3><br>       . ,   LZ4     12–20%,            .           .      ,         . <br><br>    ,     ,    «» ,    ZStandard level 1  LZ4:      IO    . <br><br>           — ,      .          ,       . <br><br>    :         . LZ4    ,   Lizard, Density  LZSSE  ,    . ,    LZ4      LZSSE  ClickHouse. <br><br>       LZ4 :         .          :      ,   .             . ,   inc-  dec-   <a href=""></a> .  ,           12–15%     32 ,    16,   .       32  —     ,     <a href=""> </a> . <br><br>       ,  ,          page cache  userspace (   mmap,    O_DIRECT  userspace page cache —     ),      - (  CityHash128  CRC32-C,    HighwayHash, FARSH  XXH3).         ,       . <br><br>   ,     master,            .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  HighLoad++ Siberia,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452778/">https://habr.com/ru/post/id452778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452766/index.html">Teknologi Streaming progresif, atau cara menonton video 4k melalui jaringan, tanpa friez</a></li>
<li><a href="../id452768/index.html">Cara mendesain produk jika Anda memutuskan untuk memasuki pasar luar negeri</a></li>
<li><a href="../id452772/index.html">5 Teknik Pengujian Lanjut</a></li>
<li><a href="../id452774/index.html">Dell XPS 13 9380: laptop andal dan sangat ringkas untuk bisnis yang serius</a></li>
<li><a href="../id452776/index.html">N.M.D. (Bukan Bisnis Saya)</a></li>
<li><a href="../id452780/index.html">Mobius 2019 Piter: Streaming Langsung Gratis dan Lainnya</a></li>
<li><a href="../id452788/index.html">Perjuangan untuk kualitas dalam aplikasi web, depresi, naga dan Westeros</a></li>
<li><a href="../id452790/index.html">OpenCV 4.0 dan 4.1 - apa yang baru?</a></li>
<li><a href="../id452792/index.html">Ulasan SSD Solid State untuk Pengguna Perusahaan Kingston DC500R</a></li>
<li><a href="../id452794/index.html">Tentang pelokalan produk. Bagian satu: mulai dari mana?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>