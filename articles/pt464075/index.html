<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜé üåÇ ‚úãüèª Introdu√ß√£o ao C. Mensagem do s√©culo passado ‚ò¶Ô∏è üõåüèº üíÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio 
 Nos meus coment√°rios, me referi v√°rias vezes ao livro de Andrew Tanenbaum Operating Systems Design and Implementation, sua primeira edi√ß√£o,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o ao C. Mensagem do s√©culo passado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Pref√°cio </h3><br>  Nos meus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coment√°rios, me</a> referi v√°rias vezes ao livro de Andrew Tanenbaum Operating Systems Design and Implementation, sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira edi√ß√£o,</a> e como C √© representado nele.  E esses coment√°rios sempre foram de interesse.  Decidi que era hora de publicar uma tradu√ß√£o desta introdu√ß√£o em C.  Ainda √© relevante.  Embora certamente haja quem n√£o tenha ouvido falar sobre a linguagem de programa√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PL / 1</a> , e talvez at√© sobre o sistema operacional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minix</a> . <br><br>  Essa descri√ß√£o tamb√©m √© interessante do ponto de vista hist√≥rico e para entender at√© que ponto a linguagem C foi desde o nascimento e o setor de TI como um todo. <br><a name="habracut"></a><br>  Quero fazer imediatamente uma reserva de que meu segundo idioma √© o franc√™s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="imagem"><br><br>  Mas isso √© compensado por 46 anos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">experi√™ncia em programa√ß√£o</a> . <br>  Ent√£o, vamos come√ßar, √© a vez de Andrew Tanenbaum. <br><br><h3>  Introdu√ß√£o √† linguagem C (pp. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  A linguagem de programa√ß√£o C foi criada por Dennis Ritchie, da AT&amp;T Bell Laboratories, como uma linguagem de programa√ß√£o de alto n√≠vel para o desenvolvimento do sistema operacional UNIX.  Atualmente, o idioma √© amplamente utilizado em v√°rios campos.  C √© especialmente popular entre os programadores de sistemas, pois permite escrever programas de maneira simples e concisa. <br><br>  O livro principal que descreve a linguagem C √© o livro de Brian Kernigan e Dennis Ritchie, The C Programming Language (1978).  Os livros na l√≠ngua C foram escritos por Bolon (1986), Gehani (1984), Hancock e Krieger (1986), Harbison e Steele (1984) e muitos outros. <br><br>  Neste ap√™ndice, tentaremos dar uma introdu√ß√£o bastante completa ao C, para que aqueles que est√£o familiarizados com idiomas de alto n√≠vel, como Pascal, PL / 1 ou Modula 2, possam entender a maior parte do c√≥digo MINIX fornecido neste livro.  Os recursos C que n√£o s√£o usados ‚Äã‚Äãno MINIX n√£o s√£o discutidos aqui.  Numerosos pontos sutis omitidos.  A √™nfase est√° na leitura de programas em C, em vez de escrever c√≥digo. <br><br><h3>  A.1  No√ß√µes b√°sicas de linguagem C </h3><br>  Um programa C consiste em um conjunto de procedimentos (geralmente chamados de fun√ß√µes, mesmo que eles n√£o retornem valores).  Esses procedimentos cont√™m declara√ß√µes, operadores e outros elementos que juntos informam ao computador o que fazer.  A Figura A-1 mostra um pequeno procedimento no qual tr√™s vari√°veis ‚Äã‚Äãinteiras s√£o declaradas e atribu√≠das valores.  O nome do procedimento √© principal.  O procedimento n√£o possui par√¢metros formais, conforme indicado pela aus√™ncia de identificadores entre os colchetes atr√°s do nome do procedimento.  O corpo do procedimento √© colocado entre chaves ({}).  Este exemplo mostra que C possui vari√°veis ‚Äã‚Äãe que essas vari√°veis ‚Äã‚Äãdevem ser declaradas antes do uso.  C tamb√©m possui operadores, neste exemplo, s√£o operadores de atribui√ß√£o.  Todas as instru√ß√µes devem terminar com ponto e v√≠rgula (ao contr√°rio de Pascal, que usa dois pontos entre as instru√ß√µes, n√£o depois delas). <br><br>  Os coment√°rios come√ßam com os caracteres "/ *" e terminam com os caracteres "* /" e podem se estender por v√°rias linhas. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  O procedimento cont√©m tr√™s constantes.  Constante 10 na primeira tarefa <br>  √© uma constante decimal comum.  A constante 015 √© uma constante octal <br>  (igual a 13 em decimal).  As constantes octais sempre come√ßam em zero.  A constante 0xFF √© uma constante hexadecimal (igual a 255 decimal).  As constantes hexadecimais sempre come√ßam com 0x.  Todos os tr√™s tipos s√£o usados ‚Äã‚Äãem C. <br><br><h3>  A.2  Tipos de dados b√°sicos </h3><br>  C possui dois tipos principais de dados (vari√°veis): um n√∫mero inteiro e um caractere, declarados como int e char, respectivamente.  N√£o h√° vari√°vel booleana separada.  A vari√°vel int √© usada como uma vari√°vel booleana.  Se essa vari√°vel contiver 0, significa falso / falso e qualquer outro valor significa verdadeiro / verdadeiro.  C tamb√©m possui tipos de ponto flutuante, mas o MINIX n√£o os utiliza. <br><br>  Voc√™ pode aplicar "adjetivos" curtos, longos ou n√£o assinados a um tipo int que define um intervalo de valores (intervalo dependente do compilador).  A maioria dos processadores 8088 usa n√∫meros inteiros de 16 bits para int e short int e n√∫meros inteiros de 32 bits para int longo.  Inteiros n√£o assinados (int n√£o assinado) no processador 8088 t√™m um intervalo de 0 a 65535, e n√£o de -32768 a +32767, como √© o caso de n√∫meros inteiros comuns (int).  Um personagem leva 8 bits. <br><br>  O especificador de registro tamb√©m √© permitido para int e char, e √© uma dica para o compilador de que a vari√°vel declarada deve ser colocada no registro para que o programa funcione mais rapidamente. <br><br>  Alguns an√∫ncios s√£o mostrados na fig.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  A convers√£o entre tipos √© permitida.  Por exemplo, o operador <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  permitido mesmo que eu seja do tipo int e flag_pole seja longo.  Em muitos casos <br>  √© necess√°rio ou √∫til for√ßar convers√µes entre tipos de dados.  Para a convers√£o for√ßada, basta colocar o tipo de destino entre colchetes na frente da express√£o para convers√£o.  Por exemplo: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  instrui a converter o n√∫mero inteiro i para muito antes de pass√°-lo como um par√¢metro para o procedimento p, que espera o par√¢metro longo. <br><br>  Ao converter entre tipos, preste aten√ß√£o ao sinal. <br>  Ao converter um caractere em um n√∫mero inteiro, alguns compiladores tratam os caracteres como assinados, ou seja, de - 128 a +127, enquanto outros os tratam como <br>  n√£o assinado, ou seja, de 0 a 255. No MINIX, express√µes como <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  que converte de (caractere) em um n√∫mero inteiro e executa um AND l√≥gico <br>  (e comercial) com a constante octal 0377. O resultado √© que os altos 8 bits <br>  s√£o definidos como zero, for√ßando c a ser considerado como um n√∫mero n√£o assinado de 8 bits, no intervalo de 0 a 255. <br><br><h3>  A.3  Tipos de compostos e ponteiros </h3><br>  Nesta se√ß√£o, examinaremos quatro maneiras de criar tipos de dados mais complexos: matrizes, estruturas, uni√µes e ponteiros.  Uma matriz √© uma cole√ß√£o / conjunto de elementos do mesmo tipo.  Todas as matrizes em C come√ßam com o elemento 0. <br><br>  An√∫ncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  declara uma matriz a com 10 n√∫meros inteiros a serem armazenados nos elementos da matriz de [0] a [9].  Segundo, matrizes podem ter tr√™s ou mais dimens√µes, mas n√£o s√£o usadas no MINIX. <br>  Uma estrutura √© uma cole√ß√£o de vari√°veis, geralmente de v√°rios tipos.  A estrutura em C √© semelhante ao registro em Pascal.  Operador <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  declara s como uma estrutura contendo dois membros, o inteiro ie o caractere c. <br><br>  Para atribuir o membro i da estrutura s a 6, escreva a seguinte express√£o: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  onde o operador de ponto indica que o elemento i pertence √† estrutura s. <br>  Um sindicato tamb√©m √© um conjunto de membros, semelhante a uma estrutura, exceto que a qualquer momento apenas um deles pode estar em um sindicato.  An√∫ncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  significa que voc√™ pode ter um n√∫mero inteiro ou caractere, mas n√£o ambos.  O compilador deve alocar espa√ßo suficiente para a combina√ß√£o, para que possa acomodar o maior elemento de combina√ß√£o (do ponto de vista da mem√≥ria ocupada).  As uni√µes s√£o usadas apenas em dois locais no MINIX (para definir uma mensagem como uma uni√£o de v√°rias estruturas diferentes e para definir um bloco de disco como uma uni√£o de um bloco de dados, bloco de n√≥ i, bloco de cat√°logo, etc.). <br><br>  Ponteiros s√£o usados ‚Äã‚Äãpara armazenar endere√ßos de m√°quinas em C.  Eles s√£o usados ‚Äã‚Äãcom muita, muita frequ√™ncia.  Um asterisco (*) √© usado para indicar um ponteiro nos an√∫ncios.  An√∫ncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  declara um n√∫mero inteiro i, um ponteiro para um n√∫mero inteiro pi, uma matriz a de 10 elementos, uma matriz b de 10 ponteiros para n√∫meros inteiros e um ponteiro para um ponteiro ppi para um n√∫mero inteiro. <br><br>  As regras de sintaxe exata para declara√ß√µes complexas que combinam matrizes, ponteiros e outros tipos s√£o um tanto complexas.  Felizmente, o MINIX usa apenas declara√ß√µes simples. <br><br>  A Figura A-3 mostra a declara√ß√£o de uma matriz z de estruturas de tabela struct, cada uma das quais possui <br>  tr√™s membros, n√∫mero inteiro i, ponteiro cp para caractere e caractere c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Matrizes de estruturas s√£o comuns no MINIX.  Al√©m disso, a tabela de nomes pode ser declarada como uma estrutura de tabela struct que pode ser usada em declara√ß√µes subsequentes.  Por exemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  declara p um ponteiro para uma estrutura de tabela struct e sugere salv√°-lo <br>  em registro.  Durante a execu√ß√£o do programa, p pode indicar, por exemplo, z [4] ou <br>  para qualquer outro elemento em z, todos os 20 elementos dos quais s√£o estruturas do tipo struct table. <br><br>  Para fazer um ponteiro para z [4], basta escrever <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  onde o "e comercial" como operador un√°rio (mon√°dico) significa "pegue o endere√ßo do que se segue".  Copie o valor do membro i para a vari√°vel inteira n <br>  a estrutura apontada por p pode ser feita da seguinte maneira: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Observe que a seta √© usada para acessar um membro da estrutura por meio de um ponteiro.  Se usarmos a vari√°vel z, devemos usar o operador dot: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  A diferen√ßa √© que z [4] √© uma estrutura e o operador de ponto seleciona os elementos <br>  diretamente de tipos compostos (estruturas, matrizes).  Usando ponteiros, n√£o selecionamos um participante diretamente.  O ponteiro instrui voc√™ a selecionar primeiro uma estrutura e somente depois selecionar um membro dessa estrutura. <br><br>  √Äs vezes, √© conveniente atribuir um nome a um tipo composto.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  define unshort como curto n√£o assinado (n√∫mero inteiro curto n√£o assinado).  Agora unshort pode ser usado no programa como o tipo principal.  Por exemplo <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  declara um n√∫mero inteiro sem sinal curto, um ponteiro para um n√∫mero inteiro sem sinal curto e <br>  uma matriz de n√∫meros inteiros curtos e n√£o assinados. <br><br><h3>  A.4  Operadores </h3><br>  Os procedimentos em C cont√™m declara√ß√µes e declara√ß√µes.  J√° vimos as declara√ß√µes, agora vamos considerar os operadores.  O objetivo dos operadores condicionais e de loop √© essencialmente o mesmo que em outros idiomas.  A Figura A - 4 mostra v√°rios exemplos deles.  A √∫nica coisa que vale a pena prestar aten√ß√£o √© que os chavetas s√£o usadas para agrupar operadores, e a instru√ß√£o while tem duas formas, a segunda das quais √© semelhante √† declara√ß√£o repetida de Pascal. <br><br>  C tamb√©m possui uma declara√ß√£o for, mas n√£o se parece com uma declara√ß√£o for em qualquer outro idioma.  A instru√ß√£o for tem o seguinte formato: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  O mesmo pode ser expresso atrav√©s da instru√ß√£o while: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  Como exemplo, considere a seguinte declara√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Este operador define os primeiros n elementos da matriz a como zero.  A execu√ß√£o do operador come√ßa definindo i como zero (isso √© feito fora do loop).  Em seguida, o operador √© repetido at√© i &lt;n, enquanto executa a atribui√ß√£o e o aumento de i.  Obviamente, em vez de o operador atribuir um valor ao elemento atual de uma matriz zero, pode haver um operador composto (bloco) entre colchetes. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C tamb√©m possui um operador semelhante ao operador de caso em Pascal.  Esta √© uma declara√ß√£o de op√ß√£o.  Um exemplo √© mostrado na Figura A-5.  Dependendo do valor da express√£o especificada na op√ß√£o, uma ou outra instru√ß√£o de caso √© selecionada. <br><br>  Se a express√£o n√£o corresponder a nenhuma das instru√ß√µes de caso, a instru√ß√£o padr√£o ser√° selecionada. <br><br>  Se a express√£o n√£o estiver associada a nenhuma instru√ß√£o case e a instru√ß√£o padr√£o estiver ausente, a execu√ß√£o continuar√° na pr√≥xima instru√ß√£o ap√≥s a instru√ß√£o switch. <br><br>  Deve-se observar que, para sair do bloco do caso, use a instru√ß√£o break.  Se n√£o houver instru√ß√£o de interrup√ß√£o, o pr√≥ximo bloco de caso ser√° executado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  A instru√ß√£o break tamb√©m atua dentro dos loops for e while.  Deve-se lembrar que, se a instru√ß√£o break estiver dentro de uma s√©rie de loops aninhados, a sa√≠da ser√° apenas um n√≠vel acima. <br><br>  Uma declara√ß√£o relacionada √© a instru√ß√£o continue, que n√£o sai do loop, <br>  mas causa a conclus√£o da itera√ß√£o atual e o in√≠cio da pr√≥xima itera√ß√£o <br>  imediatamente.  Este √© essencialmente um retorno ao topo do loop. <br><br>  C possui procedimentos que podem ser chamados com ou sem par√¢metros. <br>  Segundo Kernigan e Ritchie (p. 121), n√£o √© permitido transferir matrizes, <br>  estruturas ou procedimentos como par√¢metros, embora passe indicadores para tudo isso <br>  permitido.  Existe ou n√£o um livro (ele aparecer√° na minha mem√≥ria: - ‚ÄúSe houver vida em Marte, se n√£o houver vida em Marte‚Äù), muitos compiladores C permitem estruturas como par√¢metros. <br>  O nome da matriz, se for escrito sem um √≠ndice, significa um ponteiro para uma matriz, o que simplifica a transfer√™ncia de um ponteiro da matriz.  Assim, se a √© o nome de uma matriz de qualquer tipo, pode ser passado para g escrevendo <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Esta regra se aplica apenas a matrizes; essa regra n√£o se aplica a estruturas. <br>  Os procedimentos podem retornar valores executando uma instru√ß√£o de retorno.  Essa instru√ß√£o pode conter uma express√£o, cujo resultado ser√° retornado como o valor do procedimento, mas o chamador pode ignorar com seguran√ßa o valor de retorno.  Se o procedimento retornar um valor, o valor do tipo ser√° gravado antes do nome do procedimento, conforme mostrado na Fig.  A-6.  Como os par√¢metros, os procedimentos n√£o podem retornar matrizes, estruturas ou procedimentos, mas podem retornar ponteiros para eles.  Esta regra foi projetada para uma implementa√ß√£o mais eficiente - todos os par√¢metros e resultados sempre correspondem a uma palavra de m√°quina (na qual o endere√ßo est√° armazenado).  Compiladores que permitem o uso de estruturas como par√¢metros geralmente tamb√©m permitem seu uso como valores de retorno. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C n√£o possui E / S incorporada.  A entrada / sa√≠da √© implementada chamando as fun√ß√µes da biblioteca, as mais comuns s√£o ilustradas abaixo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (¬´x=% dy = %oz = %x \n¬ª, x, y, z);</code> </pre> <br>  O primeiro par√¢metro √© a sequ√™ncia de caracteres entre aspas (na verdade, essa √© uma matriz de caracteres). <br><br>  Qualquer caractere que n√£o seja uma porcentagem √© simplesmente impresso como est√°. <br><br>  Quando ocorre uma porcentagem, o seguinte par√¢metro √© impresso no formul√°rio definido pela letra ap√≥s a porcentagem: <br><blockquote>  d - imprime como um n√∫mero inteiro decimal <br>  o - imprime como um n√∫mero inteiro octal <br>  u - imprime como um n√∫mero inteiro decimal n√£o assinado <br>  x - imprime como um n√∫mero inteiro hexadecimal <br>  s - imprime como uma sequ√™ncia de caracteres <br>  c - imprimir como um caractere </blockquote>  As letras D, 0 e X tamb√©m s√£o permitidas para impress√£o decimal, octal e hexadecimal de n√∫meros longos. <br><br><h3>  A.5  Express√µes </h3><br>  Express√µes s√£o criadas pela combina√ß√£o de operandos e operadores. <br><br>  Operadores aritm√©ticos, como + e -, e operadores relacionais, como &lt; <br>  e&gt; semelhantes aos seus colegas em outros idiomas.  Operador% <br>  m√≥dulo usado.  Vale a pena notar que o operador de igualdade √© == e o operador de desigualdade √©!  =.  Para verificar se aeb s√£o iguais, voc√™ pode escrever assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C tamb√©m permite combinar o operador de atribui√ß√£o com outros operadores, portanto <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  equivalente a grava√ß√£o <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Outros operadores tamb√©m podem ser combinados dessa maneira. <br><br>  C possui operadores para manipular bits de uma palavra.  S√£o permitidos turnos e opera√ß√µes l√≥gicas bit a bit.  Os operadores de turno esquerdo e direito s√£o &lt;&lt; <br>  e &gt;&gt;, respectivamente.  Operadores l√≥gicos bit a bit &amp;, |  e ^, que s√£o l√≥gicos AND (AND), incluindo OR (OR) e OR exclusivo (XOP), respectivamente.  Se i tiver o valor 035 (octal), a express√£o i &amp; 06 ter√° o valor 04 (octal).  Outro exemplo, se i = 7, ent√£o <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  e obtenha 074 para j. <br>  Outro grupo importante de operadores s√£o os operadores un√°rios, cada um dos quais aceita apenas um operando.  Como operador un√°rio, &amp; comercial &amp; obt√©m o endere√ßo de uma vari√°vel. <br><br>  Se p √© um ponteiro para um n√∫mero inteiro e i √© um n√∫mero inteiro, o operador <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  calcula o endere√ßo ie armazena-o na vari√°vel p. <br>  O oposto de pegar um endere√ßo √© um operador que pega um ponteiro como entrada e calcula o valor nesse endere√ßo.  Se atribuirmos o endere√ßo i ao ponteiro p, ent√£o * p ter√° o mesmo significado que i. <br><br>  Em outras palavras, como operador un√°rio, um asterisco √© seguido por um ponteiro (ou <br>  express√£o que fornece um ponteiro) e retorna o valor do elemento para o qual ele aponta.  Se eu tiver um valor 6, o operador <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  atribuir√° j o n√∫mero 6. <br>  O operador!  (o ponto de exclama√ß√£o √© o operador de nega√ß√£o) retorna 0 se o operando for diferente de zero e 1 se o operador for 0. <br><br>  √â usado principalmente em instru√ß√µes if, por exemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  verifica o valor de x.  Se x √© zero (falso), ent√£o k recebe o valor 0. Na verdade, o operador!  cancela a condi√ß√£o seguinte, assim como o operador n√£o em Pascal. <br><br>  O operador ~ √© um operador de complemento bit a bit.  Cada 0 em seu operando <br>  se torna 1 e cada 1 se torna 0. <br><br>  O operador sizeof relata o tamanho do seu operando em bytes.  Em rela√ß√£o a <br>  uma matriz de 20 n√∫meros inteiros a em um computador com n√∫meros inteiros de 2 bytes, por exemplo sizeof a ter√° um valor de 40. <br><br>  O √∫ltimo grupo de operadores s√£o os operadores de aumento e redu√ß√£o. <br><br>  Operador <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  significa um aumento na p.  Quanto p aumentar√° depende do seu tipo. <br>  Inteiros ou caracteres aumentam em 1, mas ponteiros aumentam em <br>  o tamanho do objeto apontado dessa maneira, se a √© uma matriz de estruturas ep √© um ponteiro para uma dessas estruturas, e escrevemos <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  para fazer p apontar para uma das estruturas da matriz, depois de aumentar p <br>  ir√° apontar para um [4] n√£o importa o tamanho das estruturas.  Operador <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  semelhante ao operador p ++, exceto pelo fato de diminuir em vez de aumentar o valor do operando. <br><br>  Em declara√ß√£o <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  onde ambas as vari√°veis ‚Äã‚Äãs√£o n√∫meros inteiros, o valor original de k √© atribu√≠do a n e <br>  somente ent√£o k aumenta.  Em declara√ß√£o <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k aumenta primeiro e, em seguida, seu novo valor √© armazenado em n. <br><br>  Assim, um operador ++ (ou -) pode ser escrito antes ou depois do seu operando, o que resulta em v√°rios valores. <br><br>  A √∫ltima afirma√ß√£o √© essa?  (ponto de interroga√ß√£o) que seleciona uma das duas alternativas <br>  separados por dois pontos.  Por exemplo, um operador, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  compara x com y.  Se x √© menor que y, ent√£o eu obt√©m o valor 6;  caso contr√°rio, a vari√°vel i obt√©m o valor k + 1. Os colchetes s√£o opcionais. <br><br><h3>  A.6  Estrutura do programa </h3><br>  Um programa C consiste em um ou mais arquivos que cont√™m procedimentos e declara√ß√µes. <br>  Esses arquivos podem ser compilados individualmente em arquivos de objetos, que s√£o ent√£o vinculados entre si (usando o vinculador) para formar um programa execut√°vel. <br>  Ao contr√°rio do Pascal, as declara√ß√µes de procedimentos n√£o podem ser aninhadas, portanto, todas elas s√£o gravadas no "n√≠vel superior" no arquivo do programa. <br><br>  √â permitido declarar vari√°veis ‚Äã‚Äãfora dos procedimentos, por exemplo, no in√≠cio do arquivo antes da primeira declara√ß√£o do procedimento.  Essas vari√°veis ‚Äã‚Äãs√£o globais e podem ser usadas em qualquer procedimento ao longo do programa, a menos que a palavra-chave est√°tica preceda a declara√ß√£o.  Nesse caso, essas vari√°veis ‚Äã‚Äãn√£o podem ser usadas em outro arquivo.  As mesmas regras se aplicam aos procedimentos.  Vari√°veis ‚Äã‚Äãdeclaradas dentro de um procedimento s√£o locais para o procedimento. <br>  O procedimento pode acessar a vari√°vel inteira v declarada em outro arquivo (desde que a vari√°vel n√£o seja est√°tica), declarando-a externa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Cada vari√°vel global deve ser declarada exatamente uma vez sem o atributo externo para alocar mem√≥ria para ela. <br><br>  Vari√°veis ‚Äã‚Äãpodem ser inicializadas quando declaradas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Matrizes e estruturas tamb√©m podem ser inicializadas.  Vari√°veis ‚Äã‚Äãglobais que n√£o s√£o explicitamente inicializadas recebem um valor padr√£o zero. <br><br><h3>  A.7  Pr√©-processador C </h3><br>  Antes de o arquivo de origem ser transferido para o compilador C, ele √© processado automaticamente <br>  um programa chamado pr√©-processador.  √â a sa√≠da do pr√©-processador, n√£o <br>  O programa original √© alimentado na entrada do compilador.  O pr√©-processador executa <br>  Tr√™s convers√µes b√°sicas em um arquivo antes de pass√°-lo ao compilador: <br><br>  1. Inclus√£o de arquivos. <br>  2. Defini√ß√£o e substitui√ß√£o de macros. <br>  3. Compila√ß√£o condicional. <br><br>  Todas as diretivas de pr√©-processador come√ßam com um sinal de n√∫mero (#) na 1¬™ coluna. <br>  Quando uma diretiva de exibi√ß√£o <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  atendido pelo pr√©-processador, inclui o arquivo prog.h, linha por linha, em <br>  o programa a ser passado para o compilador.  Quando a diretiva #include √© escrita como <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  o arquivo inclu√≠do √© pesquisado no diret√≥rio / usr / include em vez do diret√≥rio de trabalho.  √â pr√°tica comum em C agrupar as declara√ß√µes usadas por v√°rios arquivos em um arquivo de cabe√ßalho (geralmente com o sufixo .h) e inclu√≠-las sempre que necess√°rio. <br>  O pr√©-processador tamb√©m permite defini√ß√µes de macro.  Por exemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define a macro BLOCK_SIZE e atribui a ele um valor de 1024. A partir de agora, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada ocorr√™ncia de uma sequ√™ncia de 10 caracteres "BLOCK_SIZE" no arquivo ser√° </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substitu√≠da por uma sequ√™ncia de 4 caracteres "1024" antes que o compilador veja o arquivo com o programa. Por conven√ß√£o, os nomes de macro s√£o escritos em mai√∫sculas. Macros podem ter par√¢metros, mas na pr√°tica poucos o fazem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O terceiro recurso do pr√©-processador √© a compila√ß√£o condicional. O MINIX possui v√°rios </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locais onde o c√≥digo √© escrito especificamente para o processador 8088, e esse c√≥digo n√£o deve ser inclu√≠do ao compilar para outro processador. Essas se√ß√µes s√£o assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o caractere i8088 estiver definido, as instru√ß√µes entre as duas diretivas de pr√©-processador #ifdef i8088 e #endif ser√£o inclu√≠das na sa√≠da do pr√©-processador; </font><font style="vertical-align: inherit;">caso contr√°rio, eles s√£o ignorados. </font><font style="vertical-align: inherit;">Chamando o compilador com o comando</font></font><br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou incluindo uma declara√ß√£o no programa </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos o s√≠mbolo i8088, para que todo o c√≥digo dependente do 8088 seja inclu√≠do. </font><font style="vertical-align: inherit;">√Ä medida que o MINIX se desenvolve, ele pode adquirir um c√≥digo especial para 68000s e outros processadores que tamb√©m ser√£o processados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como um exemplo de como o pr√©-processador funciona, considere o programa Fig. </font><font style="vertical-align: inherit;">A-7 (a). </font><font style="vertical-align: inherit;">Inclui um arquivo prog.h, cujo conte√∫do √© o seguinte:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Imagine que o compilador foi chamado por um comando </font></font><br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o arquivo ter passado pelo pr√©-processador, a sa√≠da ser√° mostrada na Fig. </font><font style="vertical-align: inherit;">A-7 (b). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â essa sa√≠da, e n√£o o arquivo de origem, que √© fornecida como entrada para o compilador C.</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que o pr√©-processador fez seu trabalho e excluiu todas as linhas come√ßando com o sinal #. </font><font style="vertical-align: inherit;">Se o compilador fosse chamado assim</font></font><br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ent√£o outra impress√£o seria inclu√≠da. </font><font style="vertical-align: inherit;">Se fosse chamado assim:</font></font><br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ent√£o nenhuma impress√£o seria inclu√≠da. </font><font style="vertical-align: inherit;">(O leitor pode refletir sobre o que aconteceria se o compilador fosse chamado com os dois sinalizadores -D.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.8 </font><font style="vertical-align: inherit;">Express√µes idiom√°ticas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta se√ß√£o, examinaremos v√°rias constru√ß√µes t√≠picas de C, mas n√£o comuns em outras linguagens de programa√ß√£o. </font><font style="vertical-align: inherit;">Primeiro, considere o loop:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As vari√°veis ‚Äã‚Äãpeq s√£o geralmente ponteiros de caracteres, e n √© um contador. </font><font style="vertical-align: inherit;">O loop copia a cadeia de caracteres n de onde q aponta para onde p aponta. </font><font style="vertical-align: inherit;">A cada itera√ß√£o do loop, o contador diminui at√© atingir 0 e cada um dos ponteiros aumenta, de modo que apontam sequencialmente para as c√©lulas de mem√≥ria com um n√∫mero maior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro design comum:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que define os primeiros N elementos de a como 0. Uma maneira alternativa de escrever esse loop √© a seguinte: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta instru√ß√£o, o ponteiro inteiro p √© inicializado para apontar para o elemento zero da matriz. </font><font style="vertical-align: inherit;">O loop continua at√© que p atinja o endere√ßo do en√©simo elemento da matriz. </font><font style="vertical-align: inherit;">Uma constru√ß√£o de ponteiro √© muito mais eficiente que uma constru√ß√£o de matriz e, portanto, geralmente √© usada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os operadores de atribui√ß√£o podem aparecer em locais inesperados.</font></font> Por exemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro chama a fun√ß√£o f, depois atribui o resultado da chamada da fun√ß√£o a e, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalmente, verifica se √© verdadeiro (diferente de zero) ou falso (zero). </font><font style="vertical-align: inherit;">Se a n√£o for igual a zero, a condi√ß√£o ser√° satisfeita.</font></font> Operador <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, primeiro, o valor da vari√°vel b da vari√°vel ae depois verifica a se o valor √© diferente de zero. </font><font style="vertical-align: inherit;">E esse operador √© completamente diferente de</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que compara duas vari√°veis ‚Äã‚Äãe executa o operador se forem iguais. </font></font><br><br><h3>  Posf√°cio </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© tudo. </font><font style="vertical-align: inherit;">Voc√™ n√£o vai acreditar o quanto eu gostei de preparar este texto. </font><font style="vertical-align: inherit;">Quanto me lembrei de √∫til da mesma linguagem C. </font><font style="vertical-align: inherit;">Espero que voc√™ tamb√©m goste de mergulhar no maravilhoso mundo da linguagem C.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464075/">https://habr.com/ru/post/pt464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464053/index.html">Nota: algoritmo de sele√ß√£o e rota√ß√£o de trilhas</a></li>
<li><a href="../pt464055/index.html">Estudamos os dados coletados pelo Xiaomi Mi Band para o ano</a></li>
<li><a href="../pt464057/index.html">Hilbert, Lebesgue ... e o Vazio</a></li>
<li><a href="../pt464063/index.html">Cortando o cabo em 2019</a></li>
<li><a href="../pt464071/index.html">Revolu√ß√£o ou dor? Relat√≥rio de ganchos de rea√ß√£o do Yandex</a></li>
<li><a href="../pt464077/index.html">N√£o, voc√™ n√£o precisa de 50 km / s de delta ve. Voc√™ precisa de tecnologias aditivas (parte 1)</a></li>
<li><a href="../pt464079/index.html">Como fazer uma nave espacial de decolagem e aterrissagem horizontal sem tecnologia milagrosa</a></li>
<li><a href="../pt464083/index.html">Como o ITSM ajudar√° e quem aplica essa metodologia</a></li>
<li><a href="../pt464089/index.html">Automatizando solicita√ß√µes HTTP no contexto do Spring</a></li>
<li><a href="../pt464091/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 311 (de 12 a 18 de agosto)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>