<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚öïÔ∏è üè∞ üõÖ Zum Thema Multiplikation, Quadratwurzelextraktion, Importsubstitution und der Firma Milander üçë ‚ùóÔ∏è üê¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄûEntropie, eine ergodische Quelle, ein mehrdimensionaler Nachrichtenraum, Bits, Polysemie, der Markov-Prozess - all diese W√∂rter klingen sehr beeindru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zum Thema Multiplikation, Quadratwurzelextraktion, Importsubstitution und der Firma Milander</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437326/"><h4>  ‚ÄûEntropie, eine ergodische Quelle, ein mehrdimensionaler Nachrichtenraum, Bits, Polysemie, der Markov-Prozess - all diese W√∂rter klingen sehr beeindruckend, in welcher Reihenfolge auch immer sie platziert sind.  Wenn Sie sie in der richtigen Reihenfolge anordnen, erhalten sie einen bestimmten theoretischen Inhalt.  Und manchmal kann ein echter Spezialist mit seiner Hilfe eine L√∂sung f√ºr allt√§gliche praktische Probleme finden. ‚Äú <br><br>  John PIRS "Ich sehe kein √úbel" <br></h4><br>  Dieser Beitrag ist voll von Diskussionen √ºber die subtile Optimierung mathematischer Operationen auf MK mit begrenzten Ressourcen sowie subjektiven Bewertungen verschiedener Aspekte der Entwicklung eingebetteter Software. <br><br>  Diejenigen, die diese Warnung nicht erschreckte, frage ich unter Katze. <br><a name="habracut"></a><br>  Bevor wir das Verfahren zum Extrahieren einer Quadratwurzel aus einer ganzen Zahl beschreiben, die Operation umgekehrt zum Quadrieren und dementsprechend zum Multiplizieren, lassen Sie uns √ºber letzteres sprechen. <br><br>  Angenommen, wir haben die M√∂glichkeit, eine 8-Bit-Zahl mit einer 8-Bit-Zahl zu multiplizieren und ein 16-Bit-Ergebnis (8 * 8 = 16) zu erhalten. Wie k√∂nnen wir die Implementierung der Operation 16 * 16 = 32 basierend auf dieser Operation erhalten?  Der offensichtliche Weg ist, 16 als die Summe von zwei 8 darzustellen, dann erhalten wir <br><br> <code>(16)*(16)=(1(8)*256+2(8))*1(8)*256+2(8)) =1*1*256*256+1*2*256+2*1*256+2*2</code> <br> <br>  Wenn wir im resultierenden Ausdruck die Multiplikation durch 256 durch eine Linksverschiebung um 8 Stellen ersetzen, erhalten wir einen vollst√§ndig funktionierenden Algorithmus.  Sch√§tzen wir den Zeitaufwand f√ºr die Implementierung - wir ben√∂tigen 4 Multiplikationen von 8 * 8 = 16 und 4 Additionen von 4 Byte-Nummern 32 + 32 = 32.  F√ºr AVR vom MK-Typ erhalten wir 4 * 2 + 4 * 4 = 24 Zyklen, dies gilt jedoch f√ºr eine "Stirn" -L√∂sung.  Versuchen wir, das Ergebnis zu verbessern.  Die Tatsache, dass wir nicht 4, sondern 3 Additionen und eine Zuordnung ben√∂tigen, vereinfacht die Situation etwas, da das anf√§ngliche Nullstellen des Ergebnisses nicht erforderlich ist, wir es jedoch immer noch nicht ber√ºcksichtigt haben, obwohl es notwendig war und die Gesamtzeit 24 + 4 = 28 Zyklen betragen sollte.  Wenn wir jedoch das Vorhandensein einer Verschiebung in den ersten drei Termen ber√ºcksichtigen (wir haben jeweils, dass das Tief (zwei niedrige Bytes) Null ist und es keinen Sinn macht, es zum Ergebnis hinzuzuf√ºgen), m√ºssen wir nicht 4 Bytes hinzuf√ºgen, sondern drei und zwei, was sich verringert Ausf√ºhrungszeit f√ºr 1 * 2 + 2 = 4 Takte und 20 Takte.  Ferner k√∂nnen wir darauf achten, dass sich der erste und der letzte Term √ºberhaupt nicht √ºberschneiden, was es uns erm√∂glicht, die Nullstellung der oberen H√§lfte des Ergebnisses durch die Zuweisung des ersten Terms zu ersetzen und die Ausf√ºhrungszeit um weitere 2 Taktzyklen auf 18 zu reduzieren. Weiter unter Verwendung der Architekturmerkmale, n√§mlich des Vorhandenseins des Register√ºbertragungsbefehls Paare, speichern Sie zwei weitere Takte und das Endergebnis - 16 Takte anstelle der urspr√ºnglichen 28 - eine Kleinigkeit, aber sch√∂n. <br><br>  √Ñhnliche Optimierungsmethoden funktionieren f√ºr die Operation 32 * 32 = 32, f√ºr die Sie die Ausf√ºhrungszeit von den erwarteten 4 * 4 * (2 + 4) + 4 = 100 Taktzyklen auf (3 + 5 + 4 + 3) + (5 + 3) reduzieren k√∂nnen +3) + (4 + 3) + 3 = 36 Ma√ünahmen, was √ºberhaupt nicht schlecht ist.  Nun, am Ende der Betrachtung verschiedener Multiplikationsoptionen stellen wir fest, dass 16 * 16 = 16 in 3 + 3 + 3 = 9 Zyklen erhalten werden kann.  Beachten Sie, dass alle diese √úberlegungen nur unter der Annahme g√ºltig sind, dass es eine Operation 8 * 8 = 16 f√ºr 2 Takte gibt. Wenn sie sich nicht auf dem Ziel-MK befindet, wird die Ausf√ºhrungszeit aller anderen Versionen der Operation definitiv nicht schneller. <br><br>  Fassen wir die zur Durchf√ºhrung der Multiplikation erforderliche Zeit zusammen (8 * 8 = 8 2, 8 * 8 = 16 9, 16 * 16 = 16 16, 16 * 16 = 32 36) und betrachten wir nun das urspr√ºngliche Problem. <br><br>  Wir m√ºssen die quadratische Ganzzahlwurzel aus der 32-Bit-Zahl H extrahieren, dh die gr√∂√üte 16-Bit-Zahl n finden, so dass n * n &lt;= H.  Wir alle aus dem Sekundarschulkurs kennen die Methode der sukzessiven Approximation an die Quadratwurzel (n = (N / n '+ n) / 2), aber wenn wir sie verwenden, m√ºssen wir die ganzen Zahlen teilen, und dies ist eine sehr zeitaufw√§ndige Operation. <br><br>  Daher wurden andere Berechnungsschemata entwickelt, von denen eines die bitweise Approximationsmethode ist, die im Pseudocode wie folgt aussieht: <br><br><ul><li>  Anfangswerte -&gt; n = 0;  b = 0x8000; </li><li>  16 mal ausf√ºhren -&gt; wenn ((n + b) * (n + b)&gt; = H) n = n + b;  b = b &gt;&gt; 1; </li></ul><br>  Sie k√∂nnen die f√ºr diese Option aufgewendete Zeit 16 (Anzahl der Bits des Ergebnisses) * (2 (Organisation des Zyklus) +2 (Addition) + X (Multiplikation) +5 (Vergleich und L√∂sung) +2 (√Ñnderung des Ergebnisses) / 2 (Durchschnitt) sofort sch√§tzen Halbzeit) +2 (Bitverschiebung)) = 16 * (12 + X).  Sie fragen, warum in der Formel X anstelle der Zahl 16, und es stellt sich heraus, dass ein Hinterhalt auf uns wartete, da wir in C und nicht in Assembler schreiben.  Tatsache ist, dass es in der Standardbibliothek keine Multiplikationsoperation mit einer √Ñnderung der Bittiefe gibt und wir nicht 16 * 16 = 32 anwenden k√∂nnen, sondern 32 * 32 = 32 verwenden m√ºssen, was zu X = 36 anstelle von X = 16 f√ºhrt und die endg√ºltige Zahl 16 * ist 48 = 768 Taktzyklen zum Extrahieren des ganzzahligen Werts der Quadratwurzel einer 32-Bit-Zahl. <br><br>  Das ist nat√ºrlich viel besser als die Newton-Methode, aber ein bisschen viel, mal sehen, was getan werden kann. <br>  Es ist also offensichtlich, dass die meiste Zeit f√ºr die Berechnung des n√§chsten Multiplikationsergebnisses aufgewendet wird.  Nat√ºrlich k√∂nnen Sie es in Assembler umschreiben und die kosteng√ºnstigere Version der Multiplikation verwenden, um 16 * (12 + 16) = 448 Ticks zu erhalten, aber wir werden dies als letzten Ausweg belassen.  Betrachten Sie den Prozess genauer und stellen Sie fest, dass wir nicht die Multiplikation einer Zufallszahl selbst berechnen, sondern die Multiplikation des vorherigen Werts mit einer gewissen Zunahme, und das Quadrat des vorherigen Werts ist bekannt.  Daher k√∂nnen wir auf ein Differenzschema zur√ºckgreifen, das auf der Formel (n + b) * (n + b) = n * n + 2 * n * b + b * b basiert.  Auf den ersten Blick sieht es wie ein Spott aus - statt einer Multiplikation m√ºssen wir vier Teile und sogar zwei Additionen von langen (32-Bit) Zahlen machen.  Aber fangen wir an zu verstehen: Wir haben bereits n * n, b * b, wenn man ber√ºcksichtigt, dass b = b '/ 2 leicht zu erhalten ist, wie b' * b '/ 4 und √§hnlich 2 * n * b = 2 * n * b '/ 2. <br><br>  Das folgende Berechnungsschema ergibt sich: <br><br><ol><li>  Anfangswerte -&gt; nn = 0;  n = 0;  b = 0x8000;  bb = b * b; </li><li>  16 mal wiederholen -&gt; wenn (nn + n + bb&gt; = H) {n = n + b;  nn = nn + bb + n};  bb &gt;&gt; 2;  b&gt; 1; </li></ol><br>  Wir sch√§tzen die Implementierungskosten auf 16 * (2 (Organisation des Zyklus) +12 (Zuordnung und zwei Erg√§nzungen) +5 (Vergleich und L√∂sung) + (2 (Addition) +8 (zwei Erg√§nzungen)) / 2 (durchschnittliche Halbzeit) +8 (Verschiebung nach rechts um 2) +2 (Verschiebung nach rechts) = 16 * 34 = 544 Taktzyklen. Besser als bei falscher Multiplikation von 32 * 32, aber wir haben immer noch Reserven. <br><br>  Was sind sie - lassen Sie uns auf die teuerste Operation achten - addieren und vergleichen Sie insgesamt 17 Taktzyklen und wiederholen Sie die Hauptschleife des Algorithmus: <br>  2. 16 mal wiederholen -&gt; T = H-bb-n;  wenn (T&gt; = 0) {H = T;  n = n + b);};  bb &gt;&gt; 2;  b&gt; 1; <br>  Dann betr√§gt die Ausf√ºhrungszeit des Zyklus 16 * (2 (Organisation des Zyklus) +12 (Berechnung der neuen Differenz) +1 (Vergleich und L√∂sung) + ((4 (Zuordnung) +2 (Addition)) / 2 (durchschnittliche Halbzeit) +8 +2) = 16 * 28 = 448 Zyklen Wenn Sie die Besonderheiten der Architektur ber√ºcksichtigen, k√∂nnen Sie weitere 2 + 2 = 4 * 16 = 64 Zyklen speichern und innerhalb von weniger als 400 Zyklen halten. <br><br>  Wir erhalten sogar ein etwas besseres Ergebnis, als wenn wir die korrekte Multiplikation 16 * 16 = 32 verwenden, jedoch ohne Assembler "in reinem C".  Es gibt jedoch ein signifikantes Minus - wenn in der Version mit Multiplikation alles intuitiv ist, dann vermittelt die Variante mit einem Differenzschema ohne Kommentare den Eindruck einer Sitzung schwarzer Magie, die Sie w√§hlen sollten.  Beachten Sie auch, dass wir die Anzahl der Kennzahlen f√ºr zus√§tzlichen Speicher gegen Zwischenvariablen ausgetauscht haben, was normalerweise der Fall ist. <br><br>  Notwendiger Hinweis - Wir haben im Vergleich zu Multiplikationen (zeitweise) keinen signifikanten Gewinn erzielt, da wir eine schnelle Implementierung von 8 * 8 = 16 haben.  Wenn es im MK fehlt (und dies passiert) oder nicht so schnell (und das passiert auch), wird das Differenzschema um ein Vielfaches schneller, da nur Standardadditions- und -verschiebungsoperationen verwendet werden, die garantiert in jedem MK vorhanden sind. <br><br>  Es schien, dass es nicht besser funktionieren w√ºrde, aber es stellt sich heraus, dass es immer noch Reserven gibt, um die Leistung des Algorithmus zu steigern.  Versuchen wir, eine andere klassische Beschleunigungsmethode zu verwenden - Teilen und Erobern.  Was ist, wenn Sie zuerst die Quadratwurzel aus der √§lteren H√§lfte des Arguments extrahieren und dann verfeinern?  Zun√§chst zeigen wir, dass dies grunds√§tzlich m√∂glich ist.  In der Tat pr√§sentieren wir das Argument in der Form H = H '&lt;&lt; 16 + H' 'und das Ergebnis in der Form n = n' &lt;&lt; 8 + n ''.  Da n '' &lt;256 ist, ist sein Quadrat offensichtlich kleiner als das Quadrat der Zahl n = n '&lt;&lt; 8 + 256 = (n' + 1) &lt;&lt; 8.  Daraus folgt, dass der h√∂chste Teil des Ergebnisses die Quadratwurzel des h√∂chsten Teils des Arguments nicht √ºberschreitet. <br><br>  Die Umsetzung dieses Ansatzes bleibt dem neugierigen Leser √ºberlassen. <br>  Was bringt uns dieser Ansatz, weil die Gesamtzahl der Iterationen unver√§ndert bleibt - wir k√∂nnen die erste H√§lfte der Iterationen mit k√ºrzeren L√§ngen durchf√ºhren, was zu einer Verringerung der Zeitkosten f√ºhrt.  Dieser Ansatz kann auf die Variante mit Multiplikation und die Differenzvariante angewendet werden. Der Gesamtgewinn betr√§gt bis zu einem Viertel der gesamten Ausf√ºhrungszeit. <br><br>  Notwendiger Hinweis: Die Anwendbarkeit dieses Ansatzes ist √ºberhaupt nicht offensichtlich, wenn bei der Implementierung f√ºr MKs wie AVR eine Ausf√ºhrungsbeschleunigung stattfindet. Bei einigen Architekturen, z. B. f√ºr x86, trat jedoch eine unerwartete Verlangsamung des Betriebs auf.  Offensichtlich ist das Arbeiten mit nicht nativen Daten (16 Bit) in dieser Architektur zeitlich erheblich teurer als mit nativen (32 Bit).  Ich habe keine gr√ºndliche Studie durchgef√ºhrt, aber die Tatsache hat stattgefunden und ich sollte sie melden, um Missverst√§ndnisse zu vermeiden. <br><br>  Das ist aber noch nicht alles.  Da wir bereits den Weg der Trennung und Herrschaft eingeschlagen haben, gehen Sie doch weiter - extrahieren Sie die Wurzel Schritt f√ºr Schritt aus den Bits, beginnend mit den √§ltesten (in unserem Fall ist es kontraproduktiv, mit den j√ºngeren zu beginnen).  Das Algorithmusschema ist das gleiche - wir f√ºgen den n√§chsten Teil der Bits zum aktuellen Ergebnis hinzu und versuchen, das n√§chste Bit zum Ergebnis hinzuzuf√ºgen, um zu √ºberpr√ºfen, ob wir den Wurzelwert √ºberschritten haben.  Die Besonderheit ist, dass wir nur die hohen Bits des Arguments √ºberpr√ºfen k√∂nnen, bis wir zu den niedrigen Bits gelangen. <br><br>  Bei der Implementierung verwenden wir einen weiteren Trick: Anstatt unsere subtrahierten Zahlen nach rechts zu verschieben, verschieben wir unser dekrementiertes Argument nach links, die Bedeutung √§ndert sich nicht und die Geschwindigkeit steigt.  Es nimmt aufgrund von zwei Faktoren zu - 1) es reicht aus, nur 16-Bit-Zahlen zu subtrahieren (es gibt eine Besonderheit, und es muss ber√ºcksichtigt werden, aber wir erw√§gen eine Fallstudie, vout) und 2) wir m√ºssen das Quadrat des n√§chsten Bits nicht verschieben, da dies immer der Fall ist gleich eins.  Aber Sie m√ºssen f√ºr alles auf dieser Welt bezahlen und wir werden die erweiterte Differenz (6 Bytes) nach links und um 2 Bits pro Takt verschieben.  Wir betrachten den Pseudocode <br><br><ol><li>  Anfangswerte -&gt; n = 0;  H1 = 0; </li><li>  16 mal wiederholen -&gt; (H1, H) &lt;&lt; 2;  T = H1-n-1;  wenn (T&gt; 0) {H1 = T;  n = n + 2};  n &lt;&lt; 1; </li></ol><br>  und bewerten Sie die Ausf√ºhrungszeit, wobei Sie 16 * (12 (erweiterte Schicht) +4 (Berechnung der Differenz) +1 (L√∂sung) +2 (Zuweisung) +1 (Erh√∂hung) +2 (Verschiebung)) = 16 * 22 = 352 Ma√ünahmen erhalten Das Ergebnis ist nahezu perfekt.  Bei der Implementierung dieser Option gibt es kleine Fallstricke. Ich √ºberlasse dies erneut dem neugierigen Leser (nun, er bekommt den Job). <br><br>  Nun, zum Abschluss des Abschnitts, der mich dazu veranlasste, diesen Beitrag zu schreiben.  Es gibt eine wundervolle McuCpp-Bibliothek, die von Anton Chizhov verfasst wurde und in der Andriescu, basierend auf der Loki-Klasse der Autorenschaft, ungew√∂hnlich elegant ist (soweit Eleganz auf C ++ - Vorlagen angewendet werden kann). Arbeiten Sie mit Pins &lt;a ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/KonstantinChizhov/ Mcucpp</a> ¬ªIch habe gro√üen Respekt vor dem genannten Autor (beide) und habe k√ºrzlich im Zusammenhang mit den Umst√§nden, auf die ich sp√§ter noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehen</a> werde, die Quellen dieser Bibliothek angeschaut und erneut bewundert. <br><br>  Unter anderen Dateien sah ich jedoch template_utils.h, in der einige Hilfsroutinen implementiert waren, und unter ihnen eine ganzzahlige Wurzel einer 32-Bit-Zahl.  Die Tatsache, dass der einfachste sequentielle Approximationsalgorithmus mit Multiplikation verwendet wird, ist nicht be√§ngstigend, da dieser Algorithmus nicht so viel an Geschwindigkeit verliert, aber an Verst√§ndlichkeit viele Punkte voraus gibt und trotzdem gewinnt.  Aber die Tatsache, dass es etwas ungenau implementiert wurde (in Bezug auf die Leistung), hat mir nicht wirklich gefallen, weil "Kinder es sehen k√∂nnen".  Ungenauigkeit besteht darin, die ausgew√§hlte Zahl mit 32 Bit darzustellen, da wir sicher wissen, dass die Wurzel der 32-Bit-Zahl nicht √ºber 16 Bit hinausgeht. Warum m√ºssen wir also null Bytes verschieben?  Und genau dies ist der Fall, wenn der Compiler selbst niemals eine Optimierung erraten wird und dabei helfen sollte. <br><br>  Offensichtliche Funktionskonvertierung <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> add = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i = <span class="hljs-number"><span class="hljs-number">16</span></span>; i !=<span class="hljs-number"><span class="hljs-number">0</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rootGuess = result | add; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> guess = rootGuess * rootGuess; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= guess) { result = rootGuess; } add &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  erm√∂glicht es uns, 2 Zyklen bei einer Bitverschiebung und 2 Zyklen bei der Erstellung des n√§chsten Faktors f√ºr jeden Zyklus zu speichern, und die Organisation des Zyklus in der angegebenen Form umfasst weitere 4 Zyklen (ich wei√ü, dass der Compiler eine solche Optimierung f√ºr uns durchf√ºhren kann, aber warum nicht explizit helfen? ), was sehr gut f√ºr rein kosmetische Code√§nderungen geeignet ist, die die Verst√§ndlichkeit nicht im geringsten beeintr√§chtigen. <br><br>  Sp√§terer Hinweis - ein Kommentar lie√ü mich denken, dass es korrekter w√§re <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint_fast8_t</span></span> i= ...)</code> </pre> <br>  Danke Oleg f√ºr die Hilfe. <br><br>  Die Kirsche auf dem Kuchen ist die Funktion des Extrahierens der gesamten Quadratwurzel aus der Zeichennummer direkt darunter, die behauptet, ‚àö-1 = 65635 = -1 zu sein. Warum nicht, was schlimmer ist als jedes andere Ergebnis, ist dies f√ºr uns keine Ausnahme Ursache in MK, und die ganze Quadratwurzel einer negativen Zahl existiert nicht. <br><br>  Nun, die Schlussfolgerung, warum ich mich an die Bibliothek von Anton Chizhov gewandt habe.  Ich wurde von einem k√ºrzlich ver√∂ffentlichten Beitrag zum inl√§ndischen RTOS f√ºr MK unter dem Namen MAX (MultiAgent Coherent System) aufgefordert - siehe das Epigraph zu dem von seinen Erstellern beworbenen Beitrag, der auf MK portiert wurde, das von Milander produziert wurde.  Hinweis - Dieser Beitrag ist keineswegs Werbematerial und wird den Lesern bald klar.  Von den oben genannten mcucpp-Autoren des Betriebssystems wurde die Implementierung eines Ringpuffers verwendet (ohne die Vorteile der Anton-Bibliothek zu beeintr√§chtigen, muss ich sagen, dass dieser Teil keine Referenz ist und dies immer noch eine weiche Formulierung ist, √ºber die ich in einem anderen Beitrag geschrieben habe, den ich √ºberhaupt nicht ver√∂ffentlichen werde).  Da ich eng mit den Produktionsst√§tten von Milander zusammenarbeite, interessierte mich das Material und ich folgte dem Link zur Entwickler-Website. <br><br>  Hier beginnt der n√§chste Schrei Jaroslawnas. <br><br>  Letztes Jahr, als die Erstellung des inl√§ndischen RTOS zum ersten Mal angek√ºndigt wurde, habe ich eine Beschreibung des Softwareprodukts von dieser Website heruntergeladen, aber irgendwie haben meine H√§nde die Studie nicht erreicht.  Aufgrund meiner T√§tigkeit muss ich mich mit Haushaltskomponenten befassen (ich verstehe genug ...), daher w√§re es sch√∂n, die entsprechende Software zu haben.  Als ich mich daran erinnerte, wie der Direktor des Unternehmens in der Ver√∂ffentlichung des letzten Jahres √ºber die Millionen Rubel sprach, die f√ºr die Entwicklung ausgegeben wurden, und √ºber das gro√üe Team, das an der Entwicklung dieses Softwareprodukts arbeitete, entschied ich mich, die Testversion zum kostenlosen Download zur Verf√ºgung zu stellen, und hier teile ich die Ergebnisse. <br><br>  Zun√§chst hat sich das Volumen der Beschreibung f√ºr ein halbes Jahr fast halbiert (von 115 auf 55 Seiten), und wenn das Verschwinden von Anwendungen mit Screenshots, die den Prozess der Einf√ºhrung dritter Produkte aus der ‚ÄûProgrammbeschreibung‚Äú beschreiben, zu begr√º√üen ist, dann nicht das Erscheinungsbild dieser Materialien (deren Erstellung) Ich habe, obwohl nicht sehr bedeutsam, aber immer noch Zeit und Geld) in einem Dokument wie ‚ÄûOperator's Guide‚Äú verbracht. Ich pers√∂nlich bin ratlos.  Dar√ºber hinaus sehen wir im allerersten Satz des Dokuments eine deutliche Abweichung von der Wahrheit, da RTOS selbst in keiner Weise ‚ÄûProgramme erstellen‚Äú soll. Aus irgendeinem Grund haben sich die Autoren solche Aussagen in der vorherigen Version des Dokuments nicht erlaubt. Der Einfluss des Marketingdienstes ist zu sp√ºren.  Es liefert auch, dass, wenn sich die Beschreibung fr√ºher im Ordner / docs des Stammverzeichnisses befand und dies logisch war, sie jetzt in / toolchain / macs / docs versteckt ist. Nun, wie sie in meiner Jugend sagten: "Jeder ist auf seine Weise verr√ºckt", fahren wir fort. <br><br>  Ich beginne mit der Beschreibung, dem Quellcode (der freundlicherweise in der Testversion enthalten ist) und finde verwirrt, dass keine Treiber f√ºr Peripherieger√§te vorhanden sind, die f√ºr die Arbeit mit diesem Betriebssystem geeignet sind.  Zuerst habe ich vorgeschlagen, dass dies eine Funktion der Testversion ist, dann im Forum in den Informationen der Entwickler finde ich, dass es wirklich keine Treiber gibt, aber sie arbeiten daran.  Mehr als sechs Monate (sechs Monate, Carl, eigentlich fast ein Jahr) ab dem Zeitpunkt, an dem das Betriebssystem f√ºr MK ver√∂ffentlicht wurde, und sie arbeiten an Treibern.  Nat√ºrlich oder wie gesagt, es versteht sich von selbst, dass von keinem dritten Produkt (Dateisystem, Netzwerkstapel, USB-Stack) die Rede sein kann.  Eine lustige Idee der Autoren √ºber die Anforderungen an die Softwareentwicklung f√ºr MK, okay, fuhr wieder. <br><br>  Das hei√üt, das deklarierte Betriebssystem, dessen hervorgehobenes Merkmal die Organisation der Interaktion innerhalb eines Systems mit mehreren Controllern ist, verf√ºgt nicht √ºber native Mittel zum Organisieren dieser Interaktion.  Was wir unter dem Strich haben - und wir haben Aufgabenverwaltung, eigentlich einen Schuppen, minimalen Zeitaufwand und Mittel zum Synchronisieren von Aufgaben, und das ist alles - gelinde gesagt lustig.  Okay, wir werden weiter schauen, auch in einem solchen Satz von Komponenten sind interessante L√∂sungen m√∂glich, insbesondere wenn Sie bedenken, dass ich an einem Standort (nicht in der Firma des Herstellers) eine ‚ÄûPr√ºfung‚Äú des Quellcodes dieses Betriebssystems durch Bezugnahme gesehen habe.  In diesem Dokument hei√üt es, dass das Softwareprodukt keine Komponenten von Drittanbietern (Import) verwendet und original ist. Dies muss unbedingt sichergestellt werden. <br><br>  Die erste Beobachtung ist, dass, wenn Sie Original-ARM-Dateien verwenden, die im Quellcode-Paket enthalten sind, um auf eine bestimmte Cortex-M0-Architektur (1986 BE1T) zu portieren, dies der Verwendung von (importierten) Textfragmenten von Drittanbietern sehr √§hnlich ist - ich pers√∂nlich denke, dass dies die Verwendung ist, aber Ich wei√ü wahrscheinlich nicht alles.  Nun, und zweitens ist der Quellcode des Shedulers und der zugeh√∂rigen Task-Management-Komponenten wirklich originell und enth√§lt keine Analoga (zumindest kenne ich keine), aber dies ist die Art von Originalit√§t, wenn ich mich an den Satz des alten Schamanen aus dem Film "Der b√∂se Geist von Yambuya" erinnere der gro√üe J√§ger: "Schneiden Sie die Ohren ab, kochen Sie und essen Sie - h√§tten Sie geraten?" <br><br>  Ich werde versuchen zu erkl√§ren, dass beim Entwurf des Betriebssystems im Allgemeinen und des RTOS im Besonderen eines der schwierigen Probleme darin besteht, den Zugriff aller Prozesse im System auf eine gemeinsam genutzte Ressource - Prozessor-Laufzeit - sicherzustellen.   ,     (   )        ,    .           (            ,     ,       MPU),        . <br><br>    ,     ,      ,  ,          .           (1) , ,  FREE-RTOS     20        ,       ( ,       ,        ). <br><br>     , ,         60 (  ).  ,    .            (      )    ,     (,     )   ,  <br><br><ol><li>       (n)  </li><li>       ‚Äî  ,   20*(3*4)=240   .   , ,    ,    . </li></ol><br>  ,     ,       (     ,   ,   )             .  ,         ( , ).                 mcucpp (      ‚Äî   ),        . <br><br>     ‚Äî      -            ,           . <br><br>        (,   ,          ) -     ‚Äî .     (  ,     ,   ), ,    ( 2013) 1       ,    2019          . <br><br> ,       : <br><br><ol><li>  (  ,   )  ( ,   ,    ,  ,  ), </li><li>      (   ), </li><li>      ()      2, </li><li>       HAL, CMSIS (- ), </li><li>       , </li><li>        , </li><li>      (3rd part),  , </li><li>       , </li><li>       , </li><li>    ,     (,   ,     ..)     ¬´ ¬ª, </li><li>  ,   ,         (    , , MIT   ,  ¬´      ¬ª),        ,    (?). </li></ol><br> ,         ,   ,           5          (  , ,  10,            IDE).    ,        ,    . <br><br>    ,              , ,    . <br><br>    ,      ,   ()    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437326/">https://habr.com/ru/post/de437326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437316/index.html">Das Internet Development Institute hat Websites benannt, die seit dem 1. Februar m√∂glicherweise nicht mehr mit RuNet verbunden sind</a></li>
<li><a href="../de437318/index.html">Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation</a></li>
<li><a href="../de437320/index.html">2018 Media Sphere Development Index: Stagnation des Fernsehens, erh√∂htes Vertrauen in informelle Medien</a></li>
<li><a href="../de437322/index.html">Der Staat ist an BigDate beteiligt</a></li>
<li><a href="../de437324/index.html">Blutiger Kuss: Vasorelaxationseigenschaften des Speichels von Vampirflederm√§usen</a></li>
<li><a href="../de437330/index.html">devleads - √ºber Burnout sprechen</a></li>
<li><a href="../de437332/index.html">Zwei Prozent der ‚ÄûKatze‚Äú oder wer hat Meister Yoda fotografiert?</a></li>
<li><a href="../de437334/index.html">Was wird am 1. Februar passieren?</a></li>
<li><a href="../de437336/index.html">Von Penza nach Berlin: Geschichte des Umzugs des Testautomaten</a></li>
<li><a href="../de437342/index.html">So w√§hlen Sie eine Plattform f√ºr die Video√ºberwachung: Cloud vs. DVR / NVR / VMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>