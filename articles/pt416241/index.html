<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•´ ‚õΩÔ∏è üõí Recuperando n√≠veis do Super Mario Bros usando Python üëä üç≥ üíÉüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Para um novo projeto, eu precisava extrair dados de n√≠vel do cl√°ssico videogame de 1985 Super Mario Bros (SMB) . Mais especificamente,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recuperando n√≠veis do Super Mario Bros usando Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2>  1. Introdu√ß√£o </h2><br>  Para um novo projeto, eu precisava extrair dados de n√≠vel do cl√°ssico videogame de 1985 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Super Mario Bros (SMB)</a> .  Mais especificamente, eu queria extrair os gr√°ficos de fundo de cada n√≠vel do jogo sem uma interface, sprites em movimento etc. <br><br>  Obviamente, eu poderia colar as imagens do jogo e, possivelmente, automatizar o processo usando t√©cnicas de vis√£o de m√°quina.  Mas me pareceu mais interessante o m√©todo descrito abaixo, que permite explorar os elementos de n√≠vel que n√£o podem ser obtidos usando capturas de tela. <br><br>  Na primeira etapa do projeto, aprenderemos a linguagem assembler 6502 e um emulador escrito em Python.  O c√≥digo fonte completo est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><a name="habracut"></a><br><h2>  An√°lise do c√≥digo fonte </h2><br>  A engenharia reversa de qualquer programa √© muito mais simples se voc√™ tiver seu c√≥digo fonte, e n√≥s temos fontes SMB na forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">17 mil linhas de c√≥digo assembler 6502 (processador NES)</a> publicadas pela doppelganger.  Como a Nintendo nunca lan√ßou um release oficial de origem, o c√≥digo foi criado desmontando o c√≥digo da m√°quina SMB, decifrando dolorosamente o significado de cada parte, adicionando coment√°rios e nomes simb√≥licos significativos. <br><br>  Depois de fazer uma pesquisa r√°pida no arquivo, encontrei algo semelhante aos dados de n√≠vel que precis√°vamos: <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br>  Se voc√™ n√£o estiver familiarizado com o assembler, explicarei: tudo isso significa simplesmente "insira esse conjunto de bytes no programa compilado e permita que outras partes do programa se refiram a ele usando o s√≠mbolo <code>L_GroundArea6</code> ".  Voc√™ pode pegar esse fragmento como uma matriz na qual cada elemento √© um byte. <br><br>  A primeira coisa que voc√™ pode notar √© que o volume de dados √© muito pequeno (cerca de 100 bytes).  Portanto, exclu√≠mos todos os tipos de codifica√ß√£o, permitindo que voc√™ coloque arbitrariamente blocos no n√≠vel.  Depois de pesquisar um pouco, descobri que esses dados s√£o lidos (ap√≥s v√°rias opera√ß√µes de endere√ßamento indireto) no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AreaParserCore</a> .  Esse subprocedimento, por sua vez, chama muitos outros subprocedimentos, invocando subprocedimentos espec√≠ficos para cada tipo de objeto permitido na cena (por exemplo, <code>StaircaseObject</code> , <code>VerticalPipe</code> , <code>RowOfBricks</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i>Gr√°fico de chamada <code>AreaParserCore</code> para <code>AreaParserCore</code></i> <br><br>  O procedimento grava no <code>MetatileBuffer</code> : uma se√ß√£o de mem√≥ria de 13 bytes, que √© uma coluna de blocos em um n√≠vel, e cada byte representa um bloco separado.  Metatile √© um bloco de 16x16 a partir do qual os planos de fundo de um jogo SMB s√£o compostos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>N√≠vel com ret√¢ngulos circulados em torno de met√°teis</i> <br><br>  Eles s√£o chamados de metarquivos, porque cada um consiste em quatro blocos de 8x8 pixels, mas mais sobre isso abaixo. <br><br>  O fato de o decodificador trabalhar com objetos predefinidos explica o tamanho pequeno do n√≠vel: os dados do n√≠vel devem se referir apenas aos tipos de objetos e sua localiza√ß√£o, por exemplo, ‚Äúposicione o tubo no ponto (20, 16), v√°rios blocos no ponto (10, 5), ... "  No entanto, isso significa que √© necess√°rio muito c√≥digo para transformar dados brutos em metarquivos. <br><br>  Portar essa quantidade de c√≥digo para criar seu pr√≥prio desempacotador de n√≠vel levaria muito tempo, ent√£o vamos tentar uma abordagem diferente. <br><br><h2>  py65emu </h2><br>  Se tiv√©ssemos uma interface entre o Python e a linguagem assembler 6502, poder√≠amos chamar o subprocedimento <code>AreaParserCore</code> para cada coluna de n√≠vel e, em seguida, usar o Python mais compreens√≠vel para converter as informa√ß√µes do bloco na imagem desejada. <br><br>  Ent√£o o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">py65emu</a> aparece em cena - um emulador 6502 conciso com uma interface Python.  Veja como a mesma configura√ß√£o de mem√≥ria √© configurada no py65emu e no NES: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br>  Depois disso, podemos executar instru√ß√µes individuais usando o m√©todo <code>cpu.step()</code> , examinar a mem√≥ria usando <code>mmu.read()</code> , estudar os registros da m√°quina usando <code>cpu.ra</code> , <code>cpu.r.pc</code> , etc.  Al√©m disso, podemos gravar na mem√≥ria usando <code>mmu.write()</code> . <br><br>  Vale ressaltar que este √© apenas um emulador de processador NES: ele n√£o emula outro hardware, como PPU (Picture Processing Unit), portanto n√£o pode ser usado para emular o jogo inteiro.  No entanto, deve ser suficiente chamar o subprocedimento de an√°lise, porque ele n√£o usa nenhum outro dispositivo de hardware, exceto a CPU e a mem√≥ria. <br><br>  O plano √© configurar a CPU como mostrado acima e, para cada coluna de n√≠vel, inicialize as parti√ß√µes de mem√≥ria com os valores de entrada necess√°rios para o <code>AreaParserCore</code> , chame <code>AreaParserCore</code> e leia os dados da coluna novamente.  Ap√≥s concluir essas opera√ß√µes, usamos o Python para reunir o resultado em uma imagem finalizada. <br><br>  Mas antes disso, precisamos compilar a listagem na linguagem assembly em c√≥digo de m√°quina. <br><br><h2>  x816 </h2><br>  Conforme indicado no c√≥digo fonte, o assembler √© compilado usando x816.  O x816 √© um assembler 6502 do MS-DOS usado pela comunidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">homebrew</a> para hackers de NES e ROM.  Funciona muito bem no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DOSBox</a> . <br><br>  Juntamente com a ROM do programa, necess√°ria para o py65emu, o montador x816 cria um arquivo de caracteres que liga os caracteres √† sua localiza√ß√£o na mem√≥ria no espa√ßo de endere√ßo da CPU.  Aqui est√° um trecho do arquivo: <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br>  Aqui vemos que a fun√ß√£o <code>AreaParserCore</code> no c√≥digo-fonte pode ser acessada em <code>0x93fc</code> . <br><br>  Por conveni√™ncia, escrevi um analisador de arquivo de s√≠mbolo que corresponde aos nomes e endere√ßos dos s√≠mbolos: <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2>  Subprocedimentos </h2><br>  Conforme declarado no plano acima, queremos aprender como chamar o subprocedimento <code>AreaParserCore</code> do Python. <br><br>  Para entender a mec√¢nica de um subprocedimento, vamos examinar um pequeno subprocedimento e seu desafio correspondente: <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  A instru√ß√£o <code>jsr</code> (pula para a subrotina, "pula para a subrotina") <code>jsr</code> registro <code>jsr</code> PC na pilha e atribui a ele o valor do endere√ßo ao qual <code>WritePPUReg1</code> se refere.  O registro do PC informa ao processador o endere√ßo da pr√≥xima instru√ß√£o a ser carregada, de modo que a pr√≥xima instru√ß√£o executada ap√≥s a instru√ß√£o <code>jsr</code> seja a primeira linha do <code>WritePPUReg1</code> . <br><br>  No final da sub-rotina, a instru√ß√£o <code>rts</code> √© executada (retorno da sub-rotina, "retorno da sub-rotina").  Este comando remove o valor armazenado da pilha e o armazena no registro do PC, o que for√ßa a CPU a executar a instru√ß√£o ap√≥s a chamada <code>jsr</code> . <br><br>  Um √≥timo recurso dos subprocedimentos √© que voc√™ pode criar chamadas embutidas, ou seja, chamadas de subprocedimentos dentro dos subprocedimentos.  Os endere√ßos de retorno ser√£o colocados na pilha e exibidos na ordem correta, da mesma maneira que nas chamadas de fun√ß√£o em idiomas de alto n√≠vel. <br><br>  Aqui est√° o c√≥digo para executar a sub-rotina do Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br>  O c√≥digo salva o valor atual do ( <code>s</code> ) registrador ( <code>s</code> ) do ponteiro da pilha, emula uma chamada <code>jsr</code> e executa as instru√ß√µes at√© que a pilha retorne √† sua altura original, o que ocorre somente ap√≥s o retorno do primeiro subprocedimento.  Isso ser√° √∫til, porque agora temos uma maneira de chamar diretamente 6502 sub-rotinas do Python. <br><br>  No entanto, esquecemos algo: como passar valores de entrada para esse subprocedimento?  Precisamos dizer ao procedimento qual n√≠vel queremos renderizar e qual coluna precisamos analisar. <br><br>  Diferentemente das fun√ß√µes nas linguagens de alto n√≠vel, as sub-rotinas da linguagem de montagem 6502 n√£o podem receber dados de entrada especificados explicitamente.  Em vez disso, a entrada √© transmitida especificando os locais de mem√≥ria em algum lugar antes da chamada, que s√£o lidos dentro da chamada de subprocedimento.  Dado o tamanho do <code>AreaParserCore</code> , a engenharia reversa, a entrada necess√°ria, basta olhar o c√≥digo-fonte ser√° muito complexo e propenso a erros. <br><br><h2>  Valgrind para NES? </h2><br>  Para encontrar uma maneira de determinar os valores de entrada do <code>AreaParserCore</code> , usei a ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memcheck</a> para o Valgrind como exemplo.  A verifica√ß√£o de mem√≥ria reconhece opera√ß√µes de acesso √† mem√≥ria n√£o inicializada, armazenando a mem√≥ria de sombra em paralelo com cada fragmento da mem√≥ria alocada real.  A mem√≥ria de sombra registra se a grava√ß√£o foi feita na mem√≥ria real correspondente.  Se o programa ler para o endere√ßo no qual nunca gravou, ser√° gerado um erro de mem√≥ria n√£o inicializado.  Podemos executar o <code>AreaParserCore</code> com uma ferramenta que nos informa quais entradas precisam ser definidas antes de chamar o subprocedimento. <br><br>  De fato, escrever uma vers√£o simples do memcheck para py65emu √© muito f√°cil: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Aqui envolvemos a unidade de gerenciamento de mem√≥ria (MMU) do py65emu.  Essa classe cont√©m uma matriz <code>_uninitialized</code> , <code>_uninitialized</code> elementos nos informam se alguma vez foi gravada no byte correspondente da RAM emulada.  No caso de uma leitura n√£o inicializada, o endere√ßo da opera√ß√£o de leitura inv√°lida e o nome do caractere correspondente s√£o exibidos. <br><br>  Aqui est√£o os resultados da MMU <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> ao chamar <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> : <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br>  Observando o c√≥digo, voc√™ pode ver que muitos desses valores s√£o definidos pelo subprocedimento <code>InitializeArea</code> ; portanto, vamos executar o script novamente, chamando essa fun√ß√£o primeiro.  Repetindo esse processo, chegamos √† seguinte sequ√™ncia de chamadas, que requer apenas o n√∫mero do mundo e o n√∫mero da √°rea: <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br>  O c√≥digo grava as primeiras 48 colunas do n√≠vel Mundial 1-1 em <code>metatile_data</code> , usando o subprocedimento <code>IncrementColumnPos</code> para aumentar as vari√°veis ‚Äã‚Äãinternas necess√°rias para rastrear a coluna atual. <br><br>  E aqui est√° o conte√∫do de <code>metatile_data</code> sobreposto nas capturas de tela do jogo (bytes com o valor 0 n√£o s√£o mostrados): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br>  Obviamente, <code>metatile_data</code> corresponde claramente a informa√ß√µes de segundo plano. <br><br><h2>  Meta Graphics </h2><br>  (Para ver o resultado final, voc√™ pode prosseguir imediatamente para a se√ß√£o ‚ÄúConectando tudo junto‚Äù.) <br><br>  Agora vamos descobrir como transformar o n√∫mero recebido de metarquivos em imagens reais.  As etapas descritas abaixo foram inventadas analisando as fontes e lendo a documenta√ß√£o com o incr√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nesdev Wiki</a> . <br><br>  Para entender como renderizar cada met√°til, primeiro precisamos falar sobre paletas de cores do NES.  Geralmente, o PPU do console do NES pode renderizar 64 cores diferentes, mas o preto √© duplicado v√°rias vezes (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nesdev</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">obter detalhes</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br>  Cada n√≠vel de Mario pode usar apenas 10 dessas 64 cores como plano de fundo, divididas em 4 paletas de quatro cores;  A primeira cor √© sempre a mesma.  Aqui est√£o quatro paletas para o mundo 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br>  Vamos agora ver um exemplo bin√°rio de um n√∫mero de arquivo meta.  Aqui est√° o n√∫mero de metila da telha de pedra rachada, que √© a terra de n√≠vel 1-1 do mundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br>  O √≠ndice da paleta nos diz qual paleta usar ao renderizar o met√°til (no nosso caso, paleta 1).  O √≠ndice da paleta tamb√©m √© o √≠ndice das duas matrizes a seguir: <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br>  A combina√ß√£o dessas duas matrizes nos fornece um endere√ßo de 16 bits, que em nosso exemplo aponta para <code>Palette1_Mtiles</code> : <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br>  Quando voc√™ multiplica o √≠ndice met√°til por 4, ele se torna o √≠ndice dessa matriz.  Os dados s√£o formatados em 4 registros por linha; portanto, nosso exemplo met√°til refere-se √† vig√©sima linha, marcada com um coment√°rio de <code>cracked rock terrain</code> . <br><br>  As quatro entradas dessa linha s√£o, na verdade, identificadores de bloco: cada metatile consiste em quatro blocos de 8x8 pixels organizados na seguinte ordem - superior esquerdo, inferior esquerdo, superior direito e inferior direito.  Esses identificadores s√£o passados ‚Äã‚Äãdiretamente para o console do NES PPU.  O identificador refere-se a 16 bytes de dados no console do CHR-ROM e cada registro come√ßa com o endere√ßo <code>0x1000 + 16 * &lt; &gt;</code> : <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  O CHR-ROM √© um peda√ßo de mem√≥ria somente leitura que somente a PPU pode acessar.  √â separado do PRG-ROM, que armazena o c√≥digo do programa.  Portanto, os dados acima n√£o est√£o dispon√≠veis no c√≥digo fonte e devem ser obtidos no dump da ROM do jogo. <br><br>  16 bytes para cada bloco comp√µem um bloco 8x8 de 2 bits: o primeiro bit √© o primeiro 8 bytes e o segundo √© o segundo 8 bytes: <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br>  Vincule esses dados √† paleta 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ... e combine as pe√ßas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br>  Finalmente, conseguimos um bloco renderizado. <br><br><h2>  Juntando tudo </h2><br>  Repetindo este procedimento para cada arquivo meta, obtemos um n√≠vel completamente renderizado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br>  E, gra√ßas a isso, conseguimos extrair gr√°ficos de n√≠vel SMB usando Python! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416241/">https://habr.com/ru/post/pt416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416229/index.html">10 livros sobre marketing e t√≥picos relacionados que um designer deve ler</a></li>
<li><a href="../pt416231/index.html">Monitorando salas Zadarma Zabbix</a></li>
<li><a href="../pt416235/index.html">Criando componentes personalizados para o Bootstrap 4</a></li>
<li><a href="../pt416237/index.html">Como se tornar um designer: do freelancer de um albergue ao trabalho com as principais empresas e ao lan√ßamento do seu produto</a></li>
<li><a href="../pt416239/index.html">O papel e as fun√ß√µes do PMO em empresas de design</a></li>
<li><a href="../pt416243/index.html">Alternativas ao cobalto, este diamante sangrento das baterias</a></li>
<li><a href="../pt416245/index.html">Criamos um bot no Aimylogic para automatizar a loja online</a></li>
<li><a href="../pt416247/index.html">Como se preparar para uma viagem de neg√≥cios? Dicas do ISPsystem bizdedev</a></li>
<li><a href="../pt416251/index.html">Impress√£o 3D em camisetas</a></li>
<li><a href="../pt416253/index.html">Sketchfab, Unity, Blend4Web, PlayCanvas e agora Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>