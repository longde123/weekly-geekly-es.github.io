<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÄÑÔ∏è üëû üë©‚Äçüíª C√≥mo LLVM optimiza la funci√≥n üìî üëÇüèº üîõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El compilador de optimizaci√≥n de AOT generalmente est√° estructurado de esta manera: 



1. interfaz que convierte el c√≥digo fuente en representaci√≥n i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo LLVM optimiza la funci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433598/">  El compilador de optimizaci√≥n de AOT generalmente est√° estructurado de esta manera: <br><br><ol><li>  interfaz que convierte el c√≥digo fuente en representaci√≥n intermedia </li><li>  Canalizaci√≥n de optimizaci√≥n independiente de la m√°quina (IR): una secuencia de pasadas que reescribe IR para eliminar secciones y estructuras ineficientes que no pueden convertirse directamente en c√≥digo de m√°quina.  A veces esta parte se llama de gama media. </li><li>  Motor dependiente de la m√°quina para generar c√≥digo de ensamblaje o c√≥digo de m√°quina. </li></ol><br><img src="https://habrastorage.org/webt/dx/1k/k8/dx1kk8oxixxudiub62ffatlrpzq.jpeg"><br><br>  En algunos compiladores, el formato IR permanece sin cambios durante todo el proceso de optimizaci√≥n, en otros, su formato o cambios sem√°nticos.  En LLVM, el formato y la sem√°ntica son fijos y, por lo tanto, es posible ejecutar pases en cualquier orden sin el riesgo de compilaci√≥n incorrecta o bloqueos del compilador. <br><a name="habracut"></a><br>  La secuencia de pases de optimizaci√≥n fue desarrollada por los desarrolladores del compilador, con el objetivo de completar el trabajo en un tiempo aceptable.  Cambia de vez en cuando y, por supuesto, hay un conjunto diferente de pases para ejecutar en diferentes niveles de optimizaci√≥n.  Uno de los temas a largo plazo en la investigaci√≥n inform√°tica es el uso del aprendizaje autom√°tico u otros m√©todos para encontrar la mejor canalizaci√≥n de optimizaci√≥n para uso general y para aplicaciones espec√≠ficas para las que la canalizaci√≥n predeterminada no es muy adecuada. <br><br>  Los principios para dise√±ar los pasajes son el minimalismo y la ortogonalidad: cada pase debe hacer una cosa bien y su funcionalidad no debe solaparse.  En la pr√°ctica, los compromisos son a veces posibles.  En la pr√°ctica, cuando dos pases generan trabajo el uno para el otro, se pueden combinar en un pase m√°s grande.  Adem√°s, algunas funcionalidades de nivel IR, como plegar operadores constantes, son tan √∫tiles que no tiene sentido colocarlas en un paso separado, LLVM minimiza por defecto las operaciones constantes cuando se crea una instrucci√≥n. <br><br>  En esta publicaci√≥n veremos c√≥mo funcionan algunos pases de optimizaci√≥n de LLVM.  Quiero decir que lees <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta parte</a> sobre c√≥mo Clang compila la funci√≥n o que entiendes m√°s o menos c√≥mo funciona LLVM IR.  Comprender el formulario SSA (asignaci√≥n √∫nica est√°tica) es especialmente √∫til: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> le dar√° una introducci√≥n, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este libro</a> le dar√° m√°s informaci√≥n de la que le gustar√≠a saber.  Lea tambi√©n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencia del lenguaje LLVM</a> y una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de pases de optimizaci√≥n</a> . <br><br>  Veamos c√≥mo Clang / LLVM 6.0.1 optimiza este c√≥digo C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Al mismo tiempo, recordamos que la canalizaci√≥n de optimizaci√≥n es un lugar muy ocupado, y vamos a perder muchos momentos divertidos, como: <br><br>  La alineaci√≥n es una optimizaci√≥n simple pero muy importante que no ocurre en este ejemplo, porque  consideramos solo una funci√≥n.  Casi todas las optimizaciones espec√≠ficas para C ++, pero no para C. Auto-vectorizaci√≥n, lo que impide la salida anticipada del bucle <br><br>  En el texto a continuaci√≥n, omitir√© todos los pases que no realicen cambios en el c√≥digo.  Adem√°s, no analizaremos el backend, que tambi√©n hace mucho trabajo.  ¬°Pero incluso los pasajes restantes son muchos!  (Perd√≥n por las im√°genes, pero esta parece ser la mejor manera de evitar dificultades de formato). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ est√° el archivo IR</a> creado por Clang (elimin√© manualmente el atributo "optnone" que Clang insert√≥) y la l√≠nea de comando utilizada para ver el efecto de cada pase de optimizaci√≥n: <br><br><pre> <code class="bash hljs">opt -O2 -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-before-all -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-after-all is_sorted2.ll</code> </pre> <br>  El primer paso es la <a href="">simplificaci√≥n de CFG</a> (gr√°fico de flujo de control).  Como Clang no realiza la optimizaci√≥n, el IR que genera contiene opciones de optimizaci√≥n simples: <br><br><img src="https://habrastorage.org/webt/kn/xb/ow/knxbowtdwkjlcjaogvmo7rlzdtu.png"><br><br>  Aqu√≠, la unidad base 26 simplemente se mueve al bloque 27. Dichos bloques se pueden eliminar redirigiendo las referencias a ellos por el bloque de destino.  LLVM renumerar√° autom√°ticamente los bloques.  La lista completa de conversiones producidas por SimplifyCFG se encuentra en la parte superior del pasillo. <br><br> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <ul><li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> </ul> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <br>  La mayor√≠a de las oportunidades para la optimizaci√≥n de CFG aparecen como resultado del trabajo de otros pases LLVM.  Por ejemplo, eliminar la eliminaci√≥n del c√≥digo muerto y mover invariantes de bucle puede conducir f√°cilmente a bloques de bases vac√≠os. <br><br>  El siguiente pasaje, <a href="">SROA</a> (reemplazo escalar de agregados), es uno de los m√°s utilizados.  Su nombre genera cierta confusi√≥n porque SROA es solo una de sus funciones.  El pase verifica cada instrucci√≥n alloca (asignaci√≥n de memoria en la pila de funciones) e intenta convertirla en registros SSA.  Una instrucci√≥n alloca ( <i>es decir, una variable en la pila de</i> aprox. Transl.) Se convierte en muchos registros si se asigna est√°ticamente varias veces, y si alloca es una clase o estructura, se divide en componentes (esto se llama "escalar" reemplazo "mencionado en el nombre del pasaje).  Una versi√≥n simple de SROA se rendir√≠a a las variables de pila para las cuales se usa la operaci√≥n de tomar una direcci√≥n, pero la versi√≥n LLVM interact√∫a con un algoritmo de an√°lisis de alias y act√∫a de manera inteligente (aunque esto no es necesario en el siguiente ejemplo). <br><br><img src="https://habrastorage.org/webt/d9/qp/tt/d9qpttybpemz-gxsqew6orkzlj8.png"><br><br>  Despu√©s de SROA, las instrucciones de alloca (y las instrucciones correspondientes de carga y almacenamiento) desaparecen, y el c√≥digo se vuelve m√°s limpio y m√°s adecuado para optimizaciones posteriores (por supuesto, SROA no puede eliminar toda alloca en el caso general, esto solo sucede si el an√°lisis de puntero puede deshacerse por completo de los alias).  En el proceso, SROA inserta instrucciones phi en el c√≥digo.  Las instrucciones phi forman el n√∫cleo de la representaci√≥n SSA, y la falta de phi en el c√≥digo que genera Clang nos dice que Clang genera una versi√≥n trivial de SSA, en la que los bloques base est√°n conectados a trav√©s de la memoria y no a trav√©s de registros SSA. <br><br>  Lo que sigue es " <a href="">eliminaci√≥n temprana de subexpresiones comunes</a> ", CSE (eliminaci√≥n temprana de subexpresiones comunes).  CSE intenta eliminar los casos de subexpresiones excesivas que pueden ocurrir tanto en c√≥digo escrito por humanos como en c√≥digo parcialmente optimizado.  "Early CSE" es una versi√≥n r√°pida y f√°cil de CSE que identifica c√°lculos triviales redundantes. <br><br><img src="https://habrastorage.org/webt/zv/bk/ud/zvbkudo1n9njnkertwvr_agrkrq.png"><br><br>  Aqu√≠,% 10 y% 17 hacen lo mismo, es decir, el c√≥digo puede reescribirse para que se use un valor y se elimine el segundo.  Esto proporciona una idea de los beneficios de la SSA: cuando cada registro se asigna solo una vez, no existen versiones m√∫ltiples de un solo registro.  Por lo tanto, los c√°lculos redundantes se pueden detectar usando equivalencia sint√°ctica, sin usar un an√°lisis en profundidad del programa (este no es el caso de las ubicaciones de memoria que existen fuera del mundo SSA). <br><br>  A continuaci√≥n, se lanzan varios pases que no tienen ning√∫n efecto en nuestro caso, y luego se lanza el " <a href="">optimizador de variable global</a> ", que se describe a continuaci√≥n: <br><br> <code>     ,      .   ,        ,  ,     ,  ..</code> <br> <br>  Este pasaje realiza los siguientes cambios: <br><br><img src="https://habrastorage.org/webt/pz/nd/nm/pzndnmja1jgtbkw9acxrenagtku.png"><br><br>  Agreg√≥ un atributo de funci√≥n: metadatos utilizados por una parte del compilador para almacenar informaci√≥n sobre lo que podr√≠a ser √∫til para otra parte del compilador.  Puede leer sobre el prop√≥sito de este atributo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  A diferencia de otras optimizaciones que consideramos, el optimizador de variables globales es interprocedural; se ve completamente en el m√≥dulo LLVM.  Un m√≥dulo es (m√°s o menos) el equivalente de una unidad de compilaci√≥n en C y C ++.  En contraste con la optimizaci√≥n interprocedural, intraprocedural ve solo una funci√≥n a la vez. <br><br>  El siguiente pasaje combina instrucciones y se llama " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">combinador de instrucciones</a> ", InstCombine.  Esta es una colecci√≥n grande y diversa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizaciones</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mirilla</a> , que (generalmente) reescribe algunas instrucciones, combinadas con datos comunes, en una forma m√°s eficiente.  InstCombine no cambia el flujo de control de una funci√≥n.  En el ejemplo anterior, no cambi√≥ mucho: <br><br><img src="https://habrastorage.org/webt/ma/z2/ky/maz2ky8g_cis8kasz94_rlhzck4.png"><br><br>  Aqu√≠, en lugar de restar 1 de% 1, para calcular% 4, agregamos -1.  Esto no es optimizaci√≥n, sino canonicalizaci√≥n.  Cuando hay muchas maneras de hacer el c√°lculo, LLVM intenta llevarlo a la forma can√≥nica (a menudo elegida al azar) que los pases y backends posteriores esperan ver.  El segundo cambio realizado por InstCombine es la forma can√≥nica de dos operaciones de expansi√≥n con signo (la instrucci√≥n de texto), que calculan% 7 y% 11 convertido a expansi√≥n cero (zext).  Esta conversi√≥n es segura cuando el compilador puede probar que el sexto operando no es negativo.  En este caso, esto se debe a que la variable del bucle cambia de 0 a n (si n es negativo, el bucle no se ejecuta en absoluto).  El √∫ltimo cambio fue la adici√≥n del indicador "nuw" (sin ajuste sin firmar) a la instrucci√≥n que calcula% 10.  Podemos ver que esto es seguro, por el hecho de que (1) la variable del bucle siempre aumenta y (2) si la variable comienza desde cero y aumenta, quedar√≠a indefinida cuando el signo cambia en la intersecci√≥n INT_MAX antes de que alcance un desbordamiento sin signo, despu√©s de UINT_MAX.  Este indicador se puede usar para optimizaciones posteriores. <br><br>  A continuaci√≥n, SimplifyCFG comienza por segunda vez y elimina dos bloques base vac√≠os: <br><br><img src="https://habrastorage.org/webt/oa/jj/om/oajjom0adr5es0yccpze9nnkyzs.png"><br><br>  Luego, el pase "Deducir atributos de funci√≥n" anota la funci√≥n: <br><br><img src="https://habrastorage.org/webt/vj/s4/dm/vjs4dmr1paqb3s0yabk6ev-ycfq.png"><br><br>  "Norecurse" significa que la funci√≥n no est√° incluida en ninguna llamada recursiva, "solo lectura" significa que la funci√≥n no cambia el estado global.  El atributo de par√°metro "nocapture" significa que el par√°metro no se guarda en ning√∫n lugar despu√©s de salir de la funci√≥n, y "solo lectura" significa que la funci√≥n no modifica la memoria.  Puede ver una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atributos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de funciones</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atributos de par√°metros</a> . <br><br>  Luego, el pase " <a href="">rotar bucles</a> " mueve el c√≥digo en un intento de mejorar las condiciones para optimizaciones posteriores: <br><br><img src="https://habrastorage.org/webt/fd/qm/eg/fdqmegxzophmowskfsd-wpwjkmi.png"><br><br>  Aunque la diferencia parece intimidante, los cambios son en realidad peque√±os.  Podemos ver lo que sucedi√≥, de una manera m√°s legible, si le pedimos a LLVM que dibuje un gr√°fico de transferencia de control antes y despu√©s de pasar por los ciclos de rotaci√≥n.  Aqu√≠ est√° su vista antes (izquierda) y despu√©s (derecha): <br><br><img src="https://habrastorage.org/webt/ab/wb/8p/abwb8pofuvyvzu13vn278retos8.png"><br><br>  El c√≥digo original sigue la estructura de bucle que gener√≥ Clang: <br><br><pre> <code class="cpp hljs">initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Despu√©s de la ejecuci√≥n, el bucle se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">initializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT BODY: body modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT EXIT:</span></span></code> </pre> <br>  (Las correcciones propuestas por Johannes Durfert se enumeran a continuaci√≥n, ¬°gracias!) <br><br>  El prop√≥sito de la pasada de rotaci√≥n del bucle es eliminar una rama, lo que permite m√°s optimizaciones.  No encontr√© una mejor descripci√≥n de esta conversi√≥n en Internet. <br><br>  El pase de simplificaci√≥n de CFG minimiza dos bloques base que contienen solo instrucciones phi degeneradas (de entrada √∫nica): <br><br><img src="https://habrastorage.org/webt/vi/rp/tv/virptvmlal7fxobwfsagegvh9sa.png"><br><br>  El paso del combinador de instrucciones convierte ‚Äú% 4 = 0 s &lt;(% 1 - 1)‚Äù en ‚Äú% 4 =% 1 s&gt; 1 ‚Ä≥ (donde s &lt;y s&gt; son operaciones para comparar operandos firmados), esto transformaci√≥n √∫til, reduce la longitud de las cadenas de dependencia y tambi√©n puede crear instrucciones "muertas" (inalcanzables) (vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> que hace esto).  Esta pasada tambi√©n elimina las instrucciones triviales de phi que fueron agregadas por la pasada de rotaci√≥n del bucle. <br><br><img src="https://habrastorage.org/webt/5j/ds/vd/5jdsvdbgbxm2ycakdby1q9t9stm.png"><br><br>  El siguiente es el pasaje " <a href="">canonicalizar bucles naturales</a> ", que se describe en su propio c√≥digo fuente de la siguiente manera: <br><br> <code>          ,          . <br> <br>     (Loop pre-header) ,   ,      .      ,,  LICM. <br> <br>       ,   ,     (      )        (      ).   , ,  "store-sinking",   LICM. <br> <br>   ,               (backedge). <br> <br>  Indirectbr   .            ,      .    ,    ,     . <br> <br> ,   simplifycfg  ,   ,      ,         . <br> <br>  , ,  CFG,       . <br></code> <br><br>  Aqu√≠ vemos que se insert√≥ el bloque de salida: <br><br><img src="https://habrastorage.org/webt/k_/qb/v0/k_qbv0es1zxpy7-uprkg-qc0l5y.png"><br><br>  Luego sigue la " <a href="">simplificaci√≥n de la variable de bucle</a> ": <br><br> <code>       ( ,    ),    ,      . <br> <br>     ,     : <br> <br>       ,        . ,  'for (i = 7; i*i &lt; 1000; ++i)'   'for (i = 0; i != 25; ++i)'. <br> <br>          indvar        ,       .           ,     "". <br></code> <br>  El efecto de este pase ser√° cambiar la variable del bucle de 32 bits a 64 bits: <br><br><img src="https://habrastorage.org/webt/e9/o2/ta/e9o2tabc6zwddljjzvfqxevmnlm.png"><br><br>  No s√© por qu√© zext - previamente lanzado a la forma can√≥nica desde sext, regres√≥ nuevamente a sext. <br><br>  Ahora el pase de " <a href="">numeraci√≥n de valor global</a> " est√° realizando una optimizaci√≥n muy inteligente.  Una de las razones para escribir esta publicaci√≥n es el deseo de mostrarla.  ¬øPuedes verla aqu√≠? <br><br><img src="https://habrastorage.org/webt/xz/w9/qz/xzw9qzzlspziaetqokxpkgeajz4.png"><br><br>  Viste  S√≠, dos instrucciones de carga en el bucle de la izquierda, correspondientes a [i] y a [i + 1].  Aqu√≠, el GVN descubri√≥ que cargar un [i] no es necesario, porque un [i + 1] de una iteraci√≥n del bucle se puede transferir a la siguiente, como un [i].  Este simple truco reduce a la mitad el n√∫mero de lecturas de memoria realizadas por la funci√≥n.  Tanto LLVM como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GCC</a> han aprendido a realizar esta transformaci√≥n solo recientemente. <br><br>  Puede preguntarse si este truco funcionar√° si comparamos un [i] con un [i + 2].  Resulta que no, pero GCC puede asignar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hasta cuatro registros</a> para tales casos. <br><br>  Entonces comienza el pase de " <a href="">eliminaci√≥n de c√≥digo muerto de seguimiento de bits</a> ": <br><br> <code>    "Bit-Tracking Dead Code Elimination".   (,   ""  ""  ..) ""   .        ,    "" .</code> <br> <br>  Pero aqu√≠ resulta que tales trucos no son necesarios, porque el √∫nico c√≥digo muerto es la instrucci√≥n GEP (obtener el puntero del elemento), y est√° trivialmente muerto (el pase GVN elimin√≥ la instrucci√≥n de carga que utiliz√≥ la direcci√≥n calculada por esta instrucci√≥n): <br><br><img src="https://habrastorage.org/webt/wc/ya/kp/wcyakpozeya4ntmpbtgj8e49h0u.png"><br><br>  Ahora el algoritmo para combinar instrucciones ha colocado agregar en otra unidad base.  La l√≥gica por la cual esta transformaci√≥n se coloc√≥ en InstCombine no est√° clara para m√≠, tal vez no haya un lugar obvio donde se pueda colocar: <br><br><img src="https://habrastorage.org/webt/wl/5a/lf/wl5alf_cvrnvgdjtmrmeiqddvno.png"><br><br>  Algo m√°s extra√±o est√° sucediendo ahora: el pase de " <a href="">subprocesos de salto</a> " ha eliminado lo que el pase "canonicalizar bucles naturales" hab√≠a hecho antes: <br><br><img src="https://habrastorage.org/webt/8l/qo/wj/8lqowjsprlzfgnu9w_kilkckbvc.png"><br><br>  Luego volvemos a la forma can√≥nica: <br><br><img src="https://habrastorage.org/webt/-c/ax/ev/-caxev-fsfgtsrr10dhwmwizuzg.png"><br><br>  Y la simplificaci√≥n de CFG lo transforma de manera diferente: <br><br><img src="https://habrastorage.org/webt/6m/p6/c8/6mp6c8wo3tdsj4ylu5_iuycuktc.png"><br><br>  Y de regreso: <br><br><img src="https://habrastorage.org/webt/yn/jm/k3/ynjmk3lrtjxek1x2tmlsbdw2sfc.png"><br><br>  Y all√≠ de nuevo: <br><br><img src="https://habrastorage.org/webt/to/l2/jb/tol2jb-p3tatdxzdqpas_vsnkt0.png"><br><br>  Y de regreso: <br><br><img src="https://habrastorage.org/webt/xx/dd/o5/xxddo5fos6vgooq4g_mu4pvrss4.png"><br><br>  Y ahi: <br><br><img src="https://habrastorage.org/webt/nf/gp/qv/nfgpqvw4-oikia4hmkxok04vmwo.png"><br><br>  Y finalmente, ¬°hemos terminado con el midland!  El c√≥digo de la derecha es el c√≥digo que pasaremos (en nuestro caso) al backend x86-64. <br><br>  Puede que tenga curiosidad si las fluctuaciones en el comportamiento al final de la tuber√≠a son el resultado de un error del compilador, pero tengamos en cuenta que esta funci√≥n es muy, muy simple y hay muchos pases involucrados en su procesamiento, pero ni siquiera los mencion√© porque no realiz√≥ ning√∫n cambio en el c√≥digo.  A lo largo de la segunda mitad de la canalizaci√≥n de optimizaci√≥n, observamos principalmente casos degenerados para esta funci√≥n. <br><br>  Agradecimientos: algunos estudiantes en mi curso de compilaci√≥n en profundidad este oto√±o dejaron comentarios sobre un borrador de esta publicaci√≥n (y tambi√©n utilic√© este material para la tarea).  Revis√© las funciones discutidas aqu√≠ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> buen conjunto de conferencias sobre optimizaci√≥n de bucles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433598/">https://habr.com/ru/post/es433598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433582/index.html">¬øQu√© pasa si la participaci√≥n en las ganancias 30/70 deja de ser un est√°ndar de desarrollo de juegos?</a></li>
<li><a href="../es433586/index.html">C√≥mo no ganamos el hackathon</a></li>
<li><a href="../es433588/index.html">Incre√≠ble rendimiento de algoritmos paralelos C ++ 17. ¬øMito o realidad?</a></li>
<li><a href="../es433592/index.html">Informaci√≥n: Yandex.Phone</a></li>
<li><a href="../es433596/index.html">Error de Magellan: desbordamiento de b√∫fer o expedici√≥n alrededor del mundo usando SQLite FTS</a></li>
<li><a href="../es433600/index.html">Pixel 3 aprende a determinar la profundidad en fotos</a></li>
<li><a href="../es433602/index.html">La simplicidad matem√°tica puede ser la base de la velocidad de la evoluci√≥n.</a></li>
<li><a href="../es433604/index.html">Trabajo c√≥modo con Android Studio</a></li>
<li><a href="../es433606/index.html">Profundidades SIEM: correlaciones listas para usar. Parte 3.2. Metodolog√≠a de normalizaci√≥n de eventos</a></li>
<li><a href="../es433608/index.html">El auto del futuro. ¬øPantallas en lugar de vidrio autom√°tico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>