<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ“ ğŸ¤°ğŸ¿ ğŸš‡ Node.js dan rendering server dalam Airbnb ğŸ”– ğŸ‘Œ ğŸ’„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, terjemahan yang kami terbitkan hari ini, dikhususkan untuk kisah bagaimana Airbnb mengoptimalkan bagian server dari aplikasi web dengan memper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js dan rendering server dalam Airbnb</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418009/">  Materi, terjemahan yang kami terbitkan hari ini, dikhususkan untuk kisah bagaimana Airbnb mengoptimalkan bagian server dari aplikasi web dengan memperhatikan penggunaan teknologi rendering server yang semakin meningkat.  Selama beberapa tahun, perusahaan secara bertahap menggeser seluruh front-end ke arsitektur yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seragam</a> , yang menurutnya halaman web adalah struktur hirarki komponen Bereaksi yang diisi dengan data dari API mereka.  Secara khusus, selama proses ini ada pengabaian sistematis Ruby on Rails.  Faktanya, Airbnb berencana untuk beralih ke layanan baru hanya berdasarkan Node.js, berkat halaman yang disiapkan sepenuhnya yang diberikan pada server akan dikirimkan ke browser pengguna.  Layanan ini akan menghasilkan sebagian besar kode HTML untuk semua produk Airbnb.  Mesin rendering yang dimaksud berbeda dengan sebagian besar layanan backend yang digunakan oleh perusahaan karena fakta bahwa itu tidak ditulis dalam Ruby atau Java.  Namun, ini berbeda dari layanan Node.js tradisional yang penuh muatan, di mana model mental dan alat bantu yang digunakan di Airbnb dibuat. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rg/zm/64/rgzm64dbdvumj6ycekqpoxbqxhw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Platform Node.js</font> </h2><br>  Berpikir tentang platform Node.js, Anda dapat membayangkan bagaimana aplikasi tertentu, dibangun dengan mempertimbangkan kemampuan platform ini untuk pemrosesan data yang tidak sinkron, dengan cepat dan efisien melayani ratusan atau ribuan koneksi paralel.  Layanan mengeluarkan data yang dibutuhkan dari mana-mana dan memprosesnya sedikit sehingga memenuhi kebutuhan sejumlah besar pelanggan.  Pemilik aplikasi semacam itu tidak punya alasan untuk mengeluh, ia yakin dengan model ringan pemrosesan data simultan yang digunakan olehnya (dalam materi ini kami menggunakan kata "simultan" untuk mengirimkan istilah "bersamaan", untuk istilah "paralel" - "paralel").  Dia dengan sempurna menyelesaikan tugas yang ditetapkan untuknya. <br><br>  Server Side Rendering (SSR) mengubah ide-ide dasar yang mengarah ke visi yang sama dari masalah ini.  Jadi, rendering server membutuhkan banyak sumber daya komputasi.  Kode di lingkungan Node.js dieksekusi dalam satu utas, sebagai hasilnya, untuk memecahkan masalah komputasi (tidak seperti tugas I / O), kode tersebut dapat dieksekusi secara bersamaan, tetapi tidak secara paralel.  Platform Node.js mampu menangani sejumlah besar operasi I / O paralel, namun, ketika menyangkut komputasi, situasinya berubah. <br><br>  Karena ketika menerapkan rendering sisi server, bagian komputasi dari tugas pemrosesan permintaan meningkat dibandingkan dengan bagian yang terkait dengan input / output, permintaan yang masuk secara bersamaan akan mempengaruhi kecepatan respons server karena fakta bahwa mereka bersaing untuk sumber daya prosesor.  Perlu dicatat bahwa ketika menggunakan rendering asinkron, persaingan untuk sumber daya masih ada.  Rendering Asynchronous memecahkan respons suatu proses atau browser, tetapi tidak memperbaiki situasi dengan penundaan atau konkurensi.  Pada artikel ini, kami akan fokus pada model sederhana yang mencakup beban komputasi eksklusif.  Jika kita berbicara tentang beban campuran, yang mencakup operasi input / output dan perhitungan, maka permintaan yang masuk secara bersamaan akan meningkatkan penundaan, tetapi dengan mempertimbangkan keuntungan dari throughput sistem yang lebih tinggi. <br><br>  Pertimbangkan perintah dari bentuk <code>Promise.all([fn1, fn2])</code> .  Jika <code>fn1</code> atau <code>fn2</code> dijanjikan diselesaikan oleh subsistem I / O, maka selama pelaksanaan perintah ini adalah mungkin untuk mencapai eksekusi paralel operasi.  Ini terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96e/6f8/d81/96e6f8d8187475775542576cabbc51ca.png"></div><br>  <i><font color="#999999">Eksekusi paralel operasi melalui subsistem input / output</font></i> <br><br>  Jika <code>fn1</code> dan <code>fn2</code> adalah tugas komputasi, mereka akan dieksekusi sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e8/03d/803/8e803d80347cb302f3e86af0bbcd1e84.png"></div><br>  <i><font color="#999999">Tugas komputasi</font></i> <br><br>  Salah satu operasi harus menunggu penyelesaian operasi kedua, karena hanya ada satu utas di Node.js. <br><br>  Dalam hal rendering server, masalah ini terjadi ketika proses server harus memproses beberapa permintaan secara bersamaan.  Pemrosesan permintaan tersebut akan ditunda hingga permintaan yang diterima diproses lebih awal.  Ini tampilannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/03e/54f/13503e54f4aa44cd1481c0848e7406c7.png"></div><br>  <i><font color="#999999">Memproses permintaan bersamaan</font></i> <br><br>  Dalam praktiknya, pemrosesan permintaan seringkali terdiri dari banyak fase asinkron, bahkan jika mereka melibatkan beban komputasi yang serius pada sistem.  Ini dapat mengarah pada situasi yang lebih sulit dengan bergantian tugas untuk memproses permintaan tersebut. <br><br>  Misalkan kueri kami terdiri dari rantai tugas yang menyerupai ini: <code>renderPromise().then(out =&gt; formatResponsePromise(out)).then(body =&gt; res.send(body))</code> .  Ketika sepasang permintaan tersebut tiba di sistem, dengan interval kecil di antara mereka, kita dapat mengamati gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/ecf/070/958ecf0704405b06a60e230631ac7730.png"></div><br>  <i><font color="#999999">Memproses permintaan yang sampai pada interval kecil, masalah perjuangan untuk sumber daya prosesor</font></i> <br><br>  Dalam hal ini, dibutuhkan waktu dua kali lebih banyak untuk memproses setiap permintaan daripada yang dibutuhkan untuk memproses permintaan individu.  Dengan peningkatan jumlah permintaan yang diproses secara bersamaan, situasinya menjadi lebih buruk. <br><br>  Selain itu, salah satu tujuan khas implementasi SSR adalah kemampuan untuk menggunakan kode yang sama atau sangat mirip pada klien dan server.  Perbedaan serius antara lingkungan ini adalah bahwa lingkungan klien pada dasarnya adalah lingkungan di mana satu klien beroperasi, dan lingkungan server, berdasarkan sifatnya, adalah lingkungan multi-klien.  Apa yang bekerja dengan baik pada klien, seperti singletone atau pendekatan lain untuk menyimpan keadaan global aplikasi, menyebabkan kesalahan, kebocoran data, dan, secara umum, menjadi kebingungan, sementara memproses banyak permintaan yang tiba di server. <br><br>  Fitur-fitur ini menjadi masalah dalam situasi di mana Anda perlu memproses beberapa permintaan secara bersamaan.  Semuanya biasanya bekerja sangat normal di bawah beban yang lebih rendah di lingkungan yang nyaman dari lingkungan pengembangan, yang digunakan oleh satu klien secara pribadi seorang programmer. <br><br>  Ini mengarah ke situasi yang sangat berbeda dari contoh aplikasi Node.js klasik.  Perlu dicatat bahwa kami menggunakan runtime JavaScript untuk kumpulan perpustakaan kaya yang tersedia di dalamnya, dan karena fakta bahwa itu didukung oleh browser, dan bukan demi modelnya untuk pemrosesan data secara simultan.  Dalam aplikasi ini, model asinkron pemrosesan data simultan menunjukkan semua kelemahannya, tidak dikompensasi oleh keuntungan, yang sangat sedikit atau tidak sama sekali. <br><br><h2>  <font color="#3AC1EF">Tutorial Proyek Hypernova</font> </h2><br>  Layanan rendering baru kami, Hyperloop, akan menjadi layanan utama yang akan berinteraksi dengan pengguna Airbnb.  Akibatnya, keandalan dan kinerjanya memainkan peran penting dalam memastikan kenyamanan bekerja dengan sumber daya.  Saat memperkenalkan Hyperloop ke dalam produksi, kami memperhitungkan pengalaman yang kami peroleh saat bekerja dengan sistem rendering server kami sebelumnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hypernova</a> . <br><br>  Hypernova tidak berfungsi seperti layanan baru kami.  Ini adalah sistem rendering murni.  Ini dipanggil dari layanan Rail monolitik kami, yang disebut Monorail, dan hanya mengembalikan cuplikan HTML untuk komponen yang diberikan khusus.  Dalam banyak kasus, "snippet" ini mewakili bagian terbesar dari halaman, dan Rails hanya menyediakan tata letak halaman.  Dengan teknologi lawas, bagian dari halaman dapat dihubungkan bersama menggunakan ERB.  Bagaimanapun, Hypernova tidak memuat data apa pun yang diperlukan untuk membentuk halaman.  Ini adalah tugas Rails. <br><br>  Dengan demikian, Hyperloop dan Hypernova memiliki kinerja komputasi yang serupa.  Pada saat yang sama, Hypernova, sebagai layanan produksi dan pemrosesan volume lalu lintas yang signifikan, menyediakan bidang yang baik untuk pengujian, yang mengarah pada pemahaman tentang bagaimana penggantian Hypernova akan berperilaku dalam kondisi pertempuran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cee/51a/2f7/cee51a2f7e198d242ce8e5294f4e972f.png"></div><br>  <i><font color="#999999">Alur Kerja Hypernova</font></i> <br><br>  Inilah cara kerja Hypernova.  Permintaan pengguna datang ke aplikasi Rails utama kami, Monorail, yang mengumpulkan properti komponen Bereaksi yang perlu ditampilkan pada halaman dan membuat permintaan ke Hypernova, melewati properti dan nama komponen ini.  Hypernova merender komponen dengan properti untuk menghasilkan kode HTML yang perlu dikembalikan ke aplikasi Monorail, yang kemudian menyematkan kode ini dalam templat halaman dan mengirimkan semuanya kembali ke klien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/d7d/35b/86dd7d35b582f66de058a0aa60f5ad0a.png"></div><br>  <i><font color="#999999">Mengirim halaman yang sudah jadi ke klien</font></i> <br><br>  Jika terjadi keadaan darurat (ini bisa menjadi kesalahan atau waktu tunggu respons) di Hypernova, ada opsi mundur, saat menggunakan komponen dan propertinya yang disematkan di halaman tanpa HTML yang dihasilkan di server, setelah itu semua ini dikirim ke klien dan diberikan di sana semoga berhasil.  Ini membawa kami pada fakta bahwa kami tidak menganggap layanan Hypernova sebagai bagian penting dari sistem.  Sebagai hasilnya, kami dapat memungkinkan terjadinya sejumlah kegagalan dan situasi tertentu di mana timeout dipicu.  Dengan menyesuaikan batas waktu permintaan, kami, berdasarkan pengamatan, mengaturnya ke sekitar level P95.  Akibatnya, tidak mengherankan bahwa sistem bekerja dengan tingkat respons batas waktu dasar kurang dari 5%. <br><br>  Dalam situasi ketika lalu lintas mencapai nilai puncak, kami dapat melihat bahwa hingga 40% permintaan ke Hypernova ditutup oleh timeout di Monorail.  Di sisi Hypernova, kami melihat puncak <code>BadRequestError: Request aborted</code> ketinggian rendah.  Kesalahan ini, di samping itu, ada dalam kondisi normal, sementara dalam operasi normal, karena arsitektur solusi, kesalahan yang tersisa tidak terlalu terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/746/8c1/192/7468c11924fcf883eb3a6e73c734a263.png"></div><br>  <i><font color="#999999">Nilai batas waktu puncak (garis merah)</font></i> <br><br>  Karena sistem kami dapat bekerja tanpa Hypernova, kami tidak terlalu memperhatikan fitur-fitur ini, mereka dianggap lebih sebagai hal yang menjengkelkan, daripada masalah serius.  Kami menjelaskan masalah ini dengan fitur platform, karena peluncuran aplikasi lambat karena operasi pengumpulan sampah awal yang agak sulit, karena kekhasan kompilasi kode dan penyimpanan data, dan karena alasan lain.  Kami berharap bahwa rilis baru React atau Node akan mencakup peningkatan kinerja yang akan mengurangi kekurangan dari lambatnya peluncuran layanan. <br><br>  Saya curiga bahwa apa yang terjadi kemungkinan besar merupakan hasil dari penyeimbangan muatan yang buruk atau konsekuensi dari masalah dalam penyebaran solusi, ketika peningkatan keterlambatan dimanifestasikan karena beban komputasi yang berlebihan pada proses.  Saya menambahkan lapisan tambahan ke sistem untuk mencatat informasi tentang jumlah permintaan yang diproses secara bersamaan oleh proses individu, serta untuk mencatat kasus di mana proses menerima lebih dari satu permintaan untuk diproses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/5c2/70c/ce15c270c4ccdcd301f40fad7312e769.png"></div><br>  <i><font color="#999999">Hasil penelitian</font></i> <br><br>  Kami menganggap lambatnya layanan sebagai biang keladinya keterlambatan, tetapi kenyataannya masalah itu disebabkan oleh permintaan paralel yang berjuang untuk waktu CPU.  Menurut hasil pengukuran, ternyata waktu yang dihabiskan oleh permintaan untuk mengantisipasi penyelesaian pemrosesan permintaan lainnya sesuai dengan waktu yang dihabiskan untuk memproses permintaan.  Selain itu, ini berarti bahwa peningkatan penundaan karena pemrosesan permintaan secara simultan terlihat sama dengan peningkatan penundaan karena peningkatan kompleksitas komputasi kode, yang mengarah pada peningkatan beban pada sistem saat memproses setiap permintaan. <br><br>  Ini, di samping itu, membuatnya lebih jelas bahwa <code>BadRequestError: Request aborted</code> tidak dapat dengan percaya diri dijelaskan oleh startup sistem yang lambat.  Kesalahan berlanjut dari kode parsing dari badan permintaan, dan terjadi ketika klien membatalkan permintaan sebelum server dapat sepenuhnya membaca tubuh permintaan.  Klien berhenti bekerja, menutup koneksi, merampas kami dari data yang diperlukan untuk melanjutkan memproses permintaan.  Sangat mungkin bahwa ini terjadi karena kami mulai memproses permintaan, setelah itu perulangan acara ternyata menjadi render yang diblokir untuk permintaan lain, dan kemudian kami kembali ke tugas yang terputus untuk menyelesaikannya, tetapi sebagai hasilnya ternyata klien yang mengirimi kami permintaan ini sudah terputus, membatalkan permintaan.  Selain itu, data yang dikirim dalam permintaan ke Hypernova cukup banyak, rata-rata, di wilayah beberapa ratus kilobyte, dan ini, tentu saja, tidak berkontribusi untuk memperbaiki situasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b4/b62/bc6/0b4b62bc6a1b5e902413711b0d3272e0.png"></div><br>  <i><font color="#999999">Galat yang disebabkan oleh pemutusan klien yang tidak menunggu jawaban</font></i> <br><br>  Kami memutuskan untuk menangani masalah ini dengan menggunakan beberapa alat standar yang kami miliki pengalaman yang cukup.  Kita berbicara tentang server proxy terbalik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nginx</a> ) dan load balancer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HAProxy</a> ). <br><br><h2>  <font color="#3AC1EF">Membalikkan proxy dan load balancing</font> </h2><br>  Untuk memanfaatkan arsitektur prosesor multi-core, kami menjalankan beberapa proses Hypernova menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster</a> Node.js bawaan.  Karena proses ini independen, kami dapat secara bersamaan memproses permintaan yang masuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9df/cbe/aae/9dfcbeaae2d82fa13007670288d8b461.png"></div><br>  <i><font color="#999999">Pemrosesan paralel permintaan tiba secara bersamaan</font></i> <br><br>  Masalahnya di sini adalah bahwa setiap proses Node benar-benar sibuk sepanjang waktu untuk memproses satu permintaan, termasuk membaca isi permintaan yang dikirim dari klien (Monorail memainkan perannya dalam kasus ini).  Meskipun kita dapat membaca banyak pertanyaan dalam satu proses pada saat yang bersamaan, ketika sampai pada rendering, ia mengarah ke pergantian operasi komputasi. <br><br>  Penggunaan sumber daya proses Node terkait dengan kecepatan klien dan jaringan. <br><br>  Sebagai solusi untuk masalah ini, kami dapat mempertimbangkan server proxy reverse buffering, yang akan memungkinkan kami untuk mempertahankan sesi komunikasi dengan klien.  Inspirasi untuk ide ini adalah server web unicorn, yang kami gunakan untuk aplikasi Rails kami.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip-prinsip yang</a> dinyatakan oleh unicorn dengan sempurna menjelaskan mengapa demikian.  Untuk tujuan ini kami menggunakan nginx.  Nginx membaca permintaan dari klien ke buffer, dan meneruskan permintaan ke server Node hanya setelah itu sepenuhnya dibaca.  Sesi transfer data ini dilakukan pada mesin lokal, melalui antarmuka loopback atau menggunakan soket domain Unix, dan ini jauh lebih cepat dan lebih dapat diandalkan daripada mentransfer data antara komputer yang terpisah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/50e/77b/a2050e77b5ff48219773729978481244.png"></div><br>  <i><font color="#999999">Nginx buffer permintaan dan kemudian mengirimkannya ke server Node</font></i> <br><br>  Karena kenyataan bahwa nginx sekarang terlibat dalam permintaan membaca, kami dapat mencapai pemuatan proses Node yang lebih seragam. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/eb0/875/beaeb08758e4926cb3072670993f606f.png"></div><br>  <i><font color="#999999">Pemuatan proses yang seragam menggunakan nginx</font></i> <br><br>  Selain itu, kami menggunakan nginx untuk menangani beberapa permintaan yang tidak memerlukan akses ke proses Node.  Lapisan deteksi dan perutean layanan kami menggunakan <code>/ping</code> permintaan yang tidak membuat beban besar pada sistem untuk memverifikasi komunikasi antara host.  Memproses semua ini di nginx menghilangkan sumber signifikan beban kerja tambahan (walaupun kecil) untuk Node.js. <br><br>  Peningkatan selanjutnya menyangkut penyeimbangan muatan.  Kita perlu membuat keputusan berdasarkan informasi tentang distribusi permintaan antar proses Node.  Modul <code>cluster</code> mendistribusikan permintaan sesuai dengan algoritma round-robin, dalam kebanyakan kasus dengan upaya untuk mem-bypass proses yang tidak menanggapi permintaan.  Dengan pendekatan ini, setiap proses menerima permintaan sesuai prioritas. <br><br>  Modul <code>cluster</code> mendistribusikan koneksi, bukan permintaan, jadi semua ini tidak berfungsi sesuai kebutuhan.  Situasi menjadi lebih buruk ketika koneksi terus-menerus digunakan.  Setiap koneksi permanen dari klien terikat pada alur kerja tunggal tertentu, yang mempersulit distribusi tugas yang efisien. <br><br>  Algoritma round-robin bagus ketika ada variabilitas yang rendah dalam penundaan permintaan.  Misalnya, dalam situasi yang digambarkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/883/4f2/ed5/8834f2ed56f7410de5f306f15e66e5e9.png"></div><br>  <i><font color="#999999">Algoritma round-robin dan koneksi melalui mana permintaan diterima secara stabil</font></i> <br><br>  Algoritma ini sudah tidak begitu baik ketika Anda harus memproses permintaan dari berbagai jenis, untuk pemrosesan yang mungkin memerlukan biaya waktu yang sama sekali berbeda.  Permintaan terbaru yang dikirim ke proses tertentu terpaksa menunggu penyelesaian pemrosesan semua permintaan yang dikirim sebelumnya, bahkan jika ada proses lain yang memiliki kemampuan untuk memproses permintaan tersebut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/381/8c8/0373818c8632668b96f2ae77c32c9be2.png"></div><br>  <i><font color="#999999">Beban proses tidak merata</font></i> <br><br>  Jika Anda mendistribusikan kueri yang diperlihatkan di atas secara lebih rasional, Anda mendapatkan sesuatu seperti yang ditunjukkan pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a3/b32/9448a3b328094d81d73480e6b0e9d6d6.png"></div><br>  <i><font color="#999999">Distribusi permintaan secara rasional</font></i> <br><br>  Dengan pendekatan ini, menunggu diminimalkan dan menjadi mungkin untuk mengirim respons terhadap permintaan lebih cepat. <br><br>  Ini dapat dicapai dengan menempatkan permintaan dalam antrian, dan menugaskan mereka untuk suatu proses hanya ketika tidak sibuk memproses permintaan lain.  Untuk tujuan ini kami menggunakan HAProxy. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fda/2cc/367/fda2cc367f401ef351cad7bff55a13ea.png"></div><br>  <i><font color="#999999">HAProxy dan proses load balancing</font></i> <br><br>  Ketika kami menggunakan HAProxy untuk menyeimbangkan beban di Hypernova, kami sepenuhnya menghilangkan puncak waktu habis, serta kesalahan <code>BadRequestErrors</code> . <br><br>  Permintaan simultan juga merupakan penyebab utama keterlambatan selama operasi normal, pendekatan ini mengurangi penundaan tersebut.  Salah satu konsekuensi dari ini adalah bahwa sekarang hanya 2% dari permintaan ditutup oleh batas waktu, dan bukan 5%, dengan pengaturan batas waktu yang sama.  Fakta bahwa kami berhasil pindah dari situasi dengan kesalahan 40% ke situasi dengan pemicu waktu habis pada 2% kasus menunjukkan bahwa kami bergerak ke arah yang benar.  Akibatnya, hari ini pengguna kami melihat layar memuat situs web jauh lebih jarang.  Perlu dicatat bahwa stabilitas sistem akan sangat penting bagi kami dengan transisi yang diharapkan ke sistem baru yang tidak memiliki mekanisme cadangan yang sama dengan yang dimiliki Hypernova. <br><br><h2>  <font color="#3AC1EF">Detail tentang sistem dan pengaturannya</font> </h2><br>  Agar semua ini berfungsi, Anda perlu mengkonfigurasi aplikasi nginx, HAProxy dan Node.  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> aplikasi serupa yang menggunakan nginx dan HAProxy, menganalisis yang mana, Anda dapat memahami perangkat sistem yang dimaksud.  Contoh ini didasarkan pada sistem yang kami gunakan dalam produksi, tetapi disederhanakan dan dimodifikasi sehingga dapat dieksekusi di latar depan atas nama pengguna yang tidak berkepentingan.  Dalam produksi, semuanya harus dikonfigurasikan menggunakan semacam pengawas (kami menggunakan runit, atau, lebih sering, kubernetes). <br><br>  <a href="">Konfigurasi nginx</a> cukup standar, menggunakan server yang mendengarkan pada port 9000, dikonfigurasi untuk permintaan proxy ke server HAProxy, yang mendengarkan pada port 9001 (dalam konfigurasi kami, kami menggunakan soket domain Unix). <br><br>  Selain itu, server ini memotong permintaan ke titik akhir <code>/ping</code> untuk secara langsung melayani permintaan yang ditujukan untuk memeriksa konektivitas jaringan.         nginx ,     <code>worker_processes</code>  1,     nginx â€”           HAProxy  Node-.  ,       ,    ,  Hypernova,     ( ).             . <br><br>  Node.js <code>cluster</code>        .        HAProxy,        <code>cluster</code> ,    .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pool-hall</a> .  â€” ,        ,   ,   <code>cluster</code> ,        .  <a href=""></a>   <code>pool-hall</code>     ,      . <br><br>  <a href=""> HAProxy</a> ,     9001       ,    9002  9005.     â€” <code>maxconn 1</code> ,     .          .       HAProxy (    8999). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/232/d95/515/232d95515b1541bccfab440f8fe12cc8.png"></div><br> <i><font color="#999999">  HAProxy</font></i> <br><br> HAProxy            .    ,    <code>maxconn</code> .    <code>static-rr</code> (static round-robin),  ,  ,       .   ,      round-robin, ,        , ,   ,     .     ,          ,   .      . <br><br> ,       ,        .       (   ).         ,   ,     ,   ,     .  ,                   ,        . <br><br><h2> <font color="#3AC1EF">  HAProxy</font> </h2><br>         HAProxy.       ,         ,    ,               .  ,    ,    (  )   .      ,        ,    <code>cluster</code> .     ,    . <br><br>       <code>ab</code> (Apache Benchmark)   10000   .       -   .       : <br><br><pre> <code class="hljs powershell">ab <span class="hljs-literal"><span class="hljs-literal">-l</span></span> <span class="hljs-literal"><span class="hljs-literal">-c</span></span> &lt;CONCURRENCY&gt; <span class="hljs-literal"><span class="hljs-literal">-n</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> http://&lt;HOSTNAME&gt;:<span class="hljs-number"><span class="hljs-number">9000</span></span>/render</code> </pre> <br>     15    4-  -,    <code>ab</code>     ,        .       ( <code>concurrency=5</code> ),    ( <code>concurrency=13</code> ),     ,        ( <code>concurrency=20</code> ).      ,      . <br><br>         ,  -,      .          ,      .       ,  ,   ,     ,       .  ,     ,       ,     . <br><br>    ,   â€”      . <br><br>     <code>maxconn 1</code>     ,  ,         . <br><br>      HTTP  TCP  ,    ,     ,  .   ,      <code>maxconn</code> ,       .     ,            ,          (, ,    ). <br><br>  ,         , ,   ,  ,      ,       . <br><br>    â€”  ,     .    <code>option redispatch</code>    <code>retries 3</code> ,    ,          ,   , ,    ,   .            . <br><br>     ,  - ,       .        ,       .   ,          ,     .     100    ,        10 ,    ,    .        ,      .   ,            <code>accept</code> . <br><br>      ,        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">backlog</a> )    ,    .       SYN-ACK ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   , ,        ACK  ).      ,      ,     ,       ,      . <br><br>      ,   ,    ,   ,       .    ,       ,      1.   <code>maxconn</code>                .     0  ,   ,     ,  ,           ,     .       ,     .         -  ,      ,         .  <code>abortonclose</code>        ,    .  ,        <code>abortonclose</code> .            nginx. <br><br>  ,     ,    .       (    )   ,       ,        ,     ,       ,  .  HAProxy          ,      ,        (       ).               ,     ,         ,    HTML.          ,   ,       .  ,       ,       (     ,  ,     ).            ,   ,            .   ,  ,   ,  .           HAProxy,            MAINT    HAProxy. <br><br>   ,     ,   ,  <code>server.close</code>  Node.js    ,     HAProxy   ,       ,      ,      .     ,     ,       ,     ,   ,     . <br><br>  ,  ,    <code>balance first</code> ,           (   <code>worker1</code> )        15%   ,    ,   ,     <code>balance static-rr</code> .        ,       Â«Â» .      .     (12 ),  , , -      .   ,  ,       ,   Â«Â»     Â«Â».        . <br><br> , ,      Node <code>server.maxconnections</code> , ( ,   ),   ,  ,   ,         .        ,    <code>maxconnection</code> ,      ,  ,    .     JavaScript,          (        ).  ,    ,        ,          .  ,     ,   ,      HAProxy  Node    ,       .     ,        ,         . <br><br>   ,      ,   , , <a href=""></a> . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>     Node.js      .     , , ,    -.      Node.js    .   , ,       ,    ,   ,        , ,  nginx  HAProxy. <br><br> ,   Airbnb  ,   Node.js     . <br><br>  <b>Pembaca yang budiman!</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah Anda menggunakan rendering sisi server dalam proyek Anda? </font></font><br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418009/">https://habr.com/ru/post/id418009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417997/index.html">Mulai dengan diri Anda sendiri, atau 60 hari Kubuntu</a></li>
<li><a href="../id417999/index.html">Bahasa Inggris: Perspektif Insinyur</a></li>
<li><a href="../id418001/index.html">5 model kerja tim yang efektif</a></li>
<li><a href="../id418005/index.html">Pengembang perangkat lunak tidak setuju dengan definisi "perangkat keras khusus" dari FSB</a></li>
<li><a href="../id418007/index.html">Pengembangan lintas platform dengan .NET, pemrograman reaktif, pola MVVM, dan pembuatan kode</a></li>
<li><a href="../id418011/index.html">Halaman Tunggal dan SEO. Rahasia Optimasi</a></li>
<li><a href="../id418013/index.html">Intel Core i7-8086K (bagian 3)</a></li>
<li><a href="../id418015/index.html">Vasyuki baru. Perkembangan inovatif Moskow hingga 2100</a></li>
<li><a href="../id418017/index.html">Analisis perilaku Trojan Pegasus di jaringan</a></li>
<li><a href="../id418023/index.html">Pointer dalam C lebih abstrak dari yang Anda kira</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>