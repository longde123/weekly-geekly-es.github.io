<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüíª ü•´ üëåüèΩ D√©bogage des fuites de m√©moire cach√©es dans Ruby üôã üë©üèø‚Äçü§ù‚Äçüë®üèæ üèÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 2015, j'ai √©crit sur les outils fournis par Ruby pour d√©tecter les fuites de m√©moire g√©r√©e . La plupart du temps, l'article parlait de fuites facil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©bogage des fuites de m√©moire cach√©es dans Ruby</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473408/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/sf/qs/vxsfqsmdrslng_xf3oslr5os3ge.jpeg"></div><br>  En 2015, j'ai √©crit sur les outils fournis par Ruby pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tecter les fuites de m√©moire g√©r√©e</a> .  La plupart du temps, l'article parlait de fuites faciles √† g√©rer.  Cette fois, je vais parler des outils et astuces que vous pouvez utiliser pour √©liminer les fuites qui ne sont pas si faciles √† analyser dans Ruby.  En particulier, je vais parler de mwrap, heaptrack, iseq_collector et chap. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cd/bda/07b/5cdbda07b31678a618b6f6205f5f9722.png"></div><br><h1>  Fuites de m√©moire non g√©r√©es </h1><br>  Ce petit programme provoque une fuite avec un appel direct √† malloc.  Il commence avec une consommation de 16 Mo de flux RSS et se termine avec 118 Mo.  Le code place en m√©moire 100 000 blocs de 1024 octets et en supprime 50 000. <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'fiddle'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'objspace'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">`</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{Process.pid} -o rss -h`.strip.to_i * 1024 puts "RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}" end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374</span></span></span></span></code> </pre> <br>  Bien que RSS fasse 118 Mo, notre objet Ruby ne conna√Æt que trois m√©gaoctets.  Dans l'analyse, nous ne voyons qu'une tr√®s petite partie de cette tr√®s grande fuite de m√©moire. <br><br>  Un v√©ritable exemple d'une telle fuite est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crit par Oleg Dashevsky</a> , je vous recommande de lire ce merveilleux article. <br><br><h1>  Appliquer Mwrap </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mwrap</a> est un profileur de m√©moire pour Ruby qui surveille toutes les allocations de donn√©es en m√©moire en interceptant malloc et d'autres fonctions de cette famille.  Il intercepte les appels qui passent et lib√®rent de la m√©moire √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LD_PRELOAD</a> .  Il utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liburcu</a> pour le comptage et peut suivre les compteurs d'allocation et de suppression pour chaque point d'appel, en code C et Ruby.  Mwrap est de petite taille, environ deux fois plus grand que RSS pour un programme profil√©, et environ deux fois plus lent. <br><br>  Il diff√®re de nombreuses autres biblioth√®ques par sa tr√®s petite taille et son support Ruby.  Il suit les emplacements dans les fichiers Ruby et n'est pas limit√© aux backtracks de niveau C valgrind + masif et aux profileurs similaires.  Cela simplifie consid√©rablement l'isolement des sources de probl√®mes. <br><br>  Pour utiliser le profileur, vous devez ex√©cuter l'application via le shell Mwrap, il impl√©mentera l'environnement LD_PRELOAD et ex√©cutera le binaire Ruby. <br><br>  Ajoutons Mwrap √† notre script: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'mwrap'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_leaks</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mwrap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocations</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frees</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age_total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_lifespan</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;&lt;</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((total / allocations.to_f)</span></span></span></span> * (allocations - frees)), allocations, frees] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results.sort! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|(_, growth_a), (_, growth_b)|</span></span> growth_b &lt;=&gt; growth_a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">20</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|location, growth, allocations, frees|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> growth == <span class="hljs-number"><span class="hljs-number">0</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{location}</span></span></span><span class="hljs-string"> growth: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{growth.to_i}</span></span></span><span class="hljs-string"> allocs/frees (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{allocations}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{frees}</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear leak_memory GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Maintenant, ex√©cutez le script avec le wrapper Mwrap: <br><br><pre> <code class="ruby hljs">% gem install mwrap % mwrap ruby leak.rb leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">51200000</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">100000</span></span>/<span class="hljs-number"><span class="hljs-number">50000</span></span>) leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">4008</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Mwrap a correctement d√©tect√© une fuite dans le script (50 000 * 1024).  Et non seulement d√©termin√©, mais aussi isol√© une ligne sp√©cifique ( <code>i = Fiddle.malloc(1024)</code> ), ce qui a conduit √† une fuite.  Le profileur l'a correctement li√© aux appels √† <code>Fiddle.free</code> . <br><br>  Il est important de noter que nous avons affaire √† une √©valuation.  Mwrap surveille la m√©moire partag√©e allou√©e par l'homologue de num√©rotation, puis surveille la lib√©ration de m√©moire.  Mais si vous avez un point d'appel qui alloue des blocs de m√©moire de diff√©rentes tailles, le r√©sultat sera inexact.  Nous avons acc√®s √† l'√©valuation: <code>((total / allocations) * (allocations - frees))</code> <br><br>  De plus, pour simplifier le suivi des fuites, Mwrap suit <code>age_total</code> , qui est la somme de la dur√©e de vie de chaque objet lib√©r√©, et suit √©galement <code>max_lifespan</code> , la dur√©e de vie de l'objet le plus ancien au point d'appel.  Si <code>age_total / frees</code> important, la consommation de m√©moire augmente malgr√© de nombreuses collectes de place. <br><br>  Mwrap a plusieurs aides pour r√©duire le bruit.  <code>Mwrap.clear</code> tout le stockage interne.  <code>Mwrap.quiet {}</code> forcera Mwrap √† suivre le bloc de code. <br><br>  Une autre caract√©ristique distinctive de Mwrap est le suivi du nombre total d'octets allou√©s et lib√©r√©s.  Supprimez <code>clear</code> du script et ex√©cutez-le: <br><br><pre> <code class="ruby hljs">usage puts <span class="hljs-string"><span class="hljs-string">"Tracked size: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691</span></span></code> </pre> <br>  Le r√©sultat est tr√®s int√©ressant, car malgr√© la taille RSS de 130 Mo, Mwrap ne voit que 91 Mo.  Cela sugg√®re que nous avons gonfl√© notre processus.  L'ex√©cution sans Mwrap montre que dans une situation normale, le processus prend 118 Mo, et dans ce cas simple, la diff√©rence √©tait de 12 Mo.  Le mod√®le d'allocation / lib√©ration a conduit √† la fragmentation.  Cette connaissance peut √™tre tr√®s utile, dans certains cas, les processus glocc malloc non configur√©s se fragmentent tellement que la tr√®s grande quantit√© de m√©moire utilis√©e dans RSS est en fait libre. <br><br><h1>  Mwrap peut-il isoler une ancienne fuite de tapis rouge? </h1><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son article,</a> Oleg discute d'une mani√®re tr√®s approfondie d'isoler une fuite tr√®s mince dans le tapis rouge.  Il y a beaucoup de d√©tails.  Il est tr√®s important de prendre des mesures.  Si vous ne cr√©ez pas de chronologie pour le processus RSS, il est peu probable que vous puissiez vous d√©barrasser de toute fuite. <br><br>  Entrons dans une machine √† remonter le temps et montrons √† quel point il est plus facile d'utiliser Mwrap pour de telles fuites. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">red_carpet_leak</span></span></span><span class="hljs-function"> 100</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markdown</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redcarpet</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Markdown</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Redcarpet::Render::HTML, extensions = {})</span></span></span></span> markdown.render(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear red_carpet_leak GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Redcarpet 3.3.2: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000)</code> </pre> <br>  Redcarpet 3.5.0: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000)</code> </pre> <br>  Si vous pouvez vous permettre d'ex√©cuter le processus √† la moiti√© de la vitesse en le red√©marrant simplement dans la prod Mwrap avec la journalisation du r√©sultat dans un fichier, vous pouvez identifier un large √©ventail de fuites de m√©moire. <br><br><h1>  Fuite myst√©rieuse </h1><br>  R√©cemment, Rails a √©t√© mis √† jour vers la version 6. En g√©n√©ral, l'exp√©rience a √©t√© tr√®s positive, les performances sont rest√©es √† peu pr√®s les m√™mes.  Rails 6 a de tr√®s bonnes fonctionnalit√©s que nous utiliserons (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zeitwerk</a> ).  Rails a chang√© la fa√ßon dont les mod√®les ont √©t√© rendus, ce qui a n√©cessit√© quelques modifications pour la compatibilit√©.  Quelques jours apr√®s la mise √† jour, nous avons remarqu√© une augmentation du flux RSS pour la t√¢che Sidekiq. <br><br>  Mwrap a signal√© une forte augmentation de la consommation de m√©moire en raison de son allocation ( <a href="">lien</a> ): <br><br><pre> <code class="ruby hljs"> source.encode! <span class="hljs-comment"><span class="hljs-comment"># Now, validate that the source we got back from the template # handler is valid in the default_internal. This is for handlers # that handle encoding but screw up unless source.valid_encoding? raise WrongEncodingError.new(source, Encoding.default_internal) end begin mod.module_eval(source, identifier, 0) rescue SyntaxError # Account for when code in the template is not syntactically valid; eg if we're using # ERB and the user writes &lt;%= foo( %&gt;, attempting to call a helper `foo` and interpolate # the result into the template, but missing an end parenthesis. raise SyntaxErrorInTemplate.new(self, original_source) end end def handle_render_error(view, e) if e.is_a?(Template::Error)</span></span></code> </pre> <br>  Au d√©but, nous √©tions tr√®s perplexes.  Nous essayions de comprendre pourquoi m√©content de Mwrap?  Peut-√™tre qu'il s'est cass√©?  Alors que la consommation de m√©moire augmentait, les tas de rubis sont rest√©s inchang√©s. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/79b/b60/7d079bb600f7d072515d081bb584c500.png"><br><br>  Deux millions d'emplacements dans le tas ne consommaient que 78 Mo (40 octets par emplacement).  Les lignes et les tableaux peuvent prendre plus de place, mais cela n'explique toujours pas la consommation de m√©moire anormale que nous avons observ√©e.  Cela a √©t√© confirm√© lorsque j'ai <code>rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all</code> . <br><br>  O√π est pass√© le souvenir? <br><br><h1>  Heaptrack </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heaptrack</a> est un profileur de m√©moire de tas pour Linux. <br><br>  Milian Wolff a parfaitement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqu√© le</a> fonctionnement du profileur et en a parl√© dans plusieurs discours ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> ).  En fait, il s'agit d'un profileur de tas natif tr√®s efficace qui, avec l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libunwind,</a> recueille les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traces</a> des applications profil√©es.  Il fonctionne nettement plus rapidement que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valgrind / Massif</a> et a la capacit√© de le rendre beaucoup plus pratique pour le profilage temporaire dans la prod.  Il peut √™tre attach√© √† un processus d√©j√† en cours! <br><br>  Comme avec la plupart des profileurs de tas, lors de l'appel de toutes les fonctions de la famille malloc, Heaptrack doit compter.  Cette proc√©dure ralentit d√©finitivement un peu le processus. <br><br>  √Ä mon avis, l'architecture ici est la meilleure de toutes.  L'interception est effectu√©e √† l'aide de <code>LD_PRELOAD</code> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDB</a> pour charger le profileur.  √Ä l'aide d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier FIFO sp√©cial,</a> il transf√®re les donn√©es du processus profil√© le plus rapidement possible.  Le wrapper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">heaptrack</a> est un simple script shell qui facilite la recherche d'un probl√®me.  Le deuxi√®me processus lit les informations du FIFO et compresse √† la vol√©e les donn√©es de suivi.  √âtant donn√© que Heaptrack fonctionne avec des ¬´morceaux¬ª, vous pouvez analyser le profil en quelques secondes apr√®s le d√©but du profilage, en plein milieu de la session.  Copiez simplement le fichier de profil vers un autre emplacement et lancez l'interface graphique Heaptrack. <br><br>  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ticket GitLab</a> m'a parl√© de la possibilit√© m√™me de lancer Heaptrack.  S'ils pouvaient l'ex√©cuter, alors je le peux. <br><br>  Notre application s'ex√©cute dans un conteneur, et je dois le red√©marrer avec <code>--cap-add=SYS_PTRACE</code> , cela permet √† GDB d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ptrace</a> , qui est n√©cessaire pour que Heaptrack s'injecte lui-m√™me.  J'ai √©galement besoin d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petit hack</a> pour que le fichier shell applique <code>root</code> au profil du processus non <code>root</code> (nous avons lanc√© notre application Discourse dans le conteneur sous un compte limit√©). <br><br>  Une fois que tout a √©t√© fait, il ne reste plus qu'√† ex√©cuter <code>heaptrack -p PID</code> et attendre que les r√©sultats apparaissent.  Heaptrack s'est av√©r√© √™tre un excellent outil, il √©tait tr√®s facile de suivre tout ce qui se passe avec des fuites de m√©moire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/9ad/a55/72c9ada55ca01cb02e06d1b433fab705.png"><br><br>  Sur le graphique, vous voyez deux sauts, l'un d√ª √† <code>cppjieba</code> , l'autre √† <code>objspace_xmalloc0</code> dans Ruby. <br><br>  Je connaissais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cppjieba</a> .  La segmentation de la langue chinoise co√ªte cher, vous avez besoin de gros dictionnaires, donc ce n'est pas une fuite.  Mais qu'en est-il de l'allocation de m√©moire dans Ruby, qui ne me dit toujours pas cela? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/340/72a/c57/34072ac5776eea391854dabe54f18056.png"><br><br>  Le gain principal est li√© √† <code>iseq_set_sequence</code> dans <code>compile.c</code> .  Il s'av√®re que la fuite est due √† des s√©quences d'instructions.  Cela a effac√© la fuite d√©couverte par Mwrap.  Sa cause √©tait <code>mod.module_eval(source, identifier, 0)</code> , qui a cr√©√© des s√©quences d'instructions qui n'ont pas √©t√© supprim√©es de la m√©moire. <br><br>  Si, dans une analyse r√©trospective, j'avais soigneusement consid√©r√© un vidage de tas de Ruby, alors j'aurais remarqu√© tous ces IMEMO, car ils sont inclus dans ce vidage.  Ils sont simplement invisibles lors des diagnostics en cours. <br><br>  √Ä partir de ce moment, le d√©bogage √©tait assez simple.  J'ai suivi tous les appels vers le module eval et jet√© ce qu'il a √©valu√©.  J'ai constat√© que nous ajoutons encore et encore des m√©thodes √† une grande classe.  Voici une vue simplifi√©e du bug rencontr√©: <br><br><pre> <code class="python hljs">require <span class="hljs-string"><span class="hljs-string">'securerandom'</span></span> module BigModule; end <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_methods</span></span></span><span class="hljs-function"> 10</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> = "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_</span></span></span><span class="hljs-function">#{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-function">}; #{"</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">;" * 100}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigModule</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSS</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">16164</span></span> ObjectSpace size <span class="hljs-number"><span class="hljs-number">2869</span></span> leak_methods usage <span class="hljs-comment"><span class="hljs-comment"># RSS: 123096 ObjectSpace size 5583</span></span></code> </pre> <br>  Ruby a une classe pour stocker les s√©quences d'instructions <code>RubyVM::InstructionSequence</code> : <code>RubyVM::InstructionSequence</code> .  Cependant, Ruby est trop paresseux pour cr√©er ces objets wrapper, car les stocker inutilement est inefficace.  Koichi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sasada a</a> cr√©√© la d√©pendance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">iseq_collector</a> .  Si nous ajoutons ce code, nous pouvons trouver notre m√©moire cach√©e: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iseq_collector'</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ObjectSpace.memsize_of_all_iseq / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 98747 ObjectSpace.memsize_of_all_iseq</span></span></code> </pre> <br>  mat√©rialise chaque s√©quence d'instructions, ce qui peut augmenter l√©g√®rement la consommation de m√©moire du processus et donner au garbage collector un peu plus de travail. <br><br>  Si, par exemple, nous calculons le nombre d'ISEQ avant et apr√®s le d√©marrage du collecteur, nous verrons qu'apr√®s le d√©marrage d' <code>ObjectSpace.memsize_of_all_iseq</code> notre compteur de la classe <code>RubyVM::InstructionSequence</code> de 0 √† 11128 (dans cet exemple): <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_iseqs</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectSpace</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RubyVM::InstructionSequence)</span></span></span></span>.count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Ces emballages resteront pendant toute la dur√©e de vie de la m√©thode, ils devront √™tre visit√©s avec une ex√©cution compl√®te du ramasse-miettes.  Notre probl√®me a √©t√© r√©solu en r√©utilisant la classe responsable du rendu des mod√®les de courrier √©lectronique ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif 2</a> ). <br><br><h1>  chap </h1><br>  Lors du d√©bogage, j'ai utilis√© un outil tr√®s int√©ressant.  Il y a quelques ann√©es, Tim Boddy a sorti un outil interne utilis√© par VMWare pour analyser les fuites de m√©moire et a ouvert son code.  Voici la seule vid√©o √† ce sujet que j'ai r√©ussi √† trouver: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.youtube.com/watch?v=EZ2n3kGtVDk</a> .  Contrairement √† la plupart des outils similaires, celui-ci n'a aucun effet sur le processus ex√©cutable.  Il peut simplement √™tre appliqu√© aux fichiers du vidage principal, tandis que glibc est utilis√© comme un allocateur (il n'y a pas de support pour jemalloc / tcmalloc, etc.). <br><br>  Avec chap, il est tr√®s facile de d√©tecter la fuite que j'avais.  Peu de distributions ont un binaire chap, mais vous pouvez facilement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compiler √† partir du code source</a> .  Il est tr√®s activement soutenu. <br><br><pre> <code class="plaintext hljs"># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes.</code> </pre> <br>  Chap peut utiliser des signatures pour rechercher des emplacements de m√©moire diff√©rente, et il peut compl√©ter GDB.  Lors du d√©bogage dans Ruby, il peut √™tre tr√®s utile pour d√©terminer la m√©moire utilis√©e par le processus.  Il montre la m√©moire totale utilis√©e, parfois la glibc malloc peut se fragmenter tellement que le volume utilis√© peut √™tre tr√®s diff√©rent du RSS r√©el.  Vous pouvez lire la discussion: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Feature # 14759: [PATCH] set M_ARENA_MAX for glibc malloc - Ruby master - Ruby Issue Tracking System</a> .  Chap est capable de compter correctement toute la m√©moire utilis√©e et de fournir une analyse approfondie de son allocation. <br><br>  De plus, chap peut √™tre int√©gr√© dans les workflows pour d√©tecter automatiquement les fuites et signaler de tels assemblages. <br><br><h1>  Travaux de suivi </h1><br>  Ce tour de d√©bogage m'a fait poser quelques questions li√©es √† nos bo√Ætes √† outils d'aide: <br><br><ul><li>  Je voudrais avoir un support pour la capture de trames de pile d'appels de Ruby dans Heaptrack.  Milian est √©galement int√©ress√© par ceci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">412929 - Pouvons-nous saisir un cadre de Ruby land?</a> <br></li><li>  J'aimerais que Ruby prenne en charge des capacit√©s de diagnostic plus larges: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://bugs.ruby-lang.org/issues/16245</a> <br></li><li>  J'aimerais que Mwrap soit un peu plus facile √† utiliser dans la prod.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lisez ici</a> . </li></ul><br><h1>  R√©sum√© </h1><br>  Notre bo√Æte √† outils d'aujourd'hui pour le d√©bogage de fuites de m√©moire tr√®s complexes est bien meilleure qu'elle ne l'√©tait il y a 4 ans!  Mwrap, Heaptrack et chap sont des outils tr√®s puissants pour r√©soudre les probl√®mes de m√©moire qui surviennent pendant le d√©veloppement et l'exploitation. <br><br>  Si vous recherchez une simple fuite de m√©moire dans Ruby, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon article de 2015</a> , pour la plupart, il est pertinent. <br><br>  J'esp√®re que vous trouverez cela plus facile la prochaine fois que vous commencerez √† d√©boguer une fuite de m√©moire native complexe. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473408/">https://habr.com/ru/post/fr473408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473392/index.html">Comment lancer un nouveau site bancaire. 2e partie</a></li>
<li><a href="../fr473394/index.html">Vous mentez tous! √Ä propos de la publicit√© CRM</a></li>
<li><a href="../fr473396/index.html">Nous avons besoin d'une autre bitrix</a></li>
<li><a href="../fr473400/index.html">Technologie de synth√®se vocale de haute qualit√©, l√©g√®re et adaptable utilisant LPCNet</a></li>
<li><a href="../fr473406/index.html">Marathon gratuit "Data Science et IA: apprendre √† la machine √† √©crire le script de la s√©rie"</a></li>
<li><a href="../fr473412/index.html">Cr√©ation d'un plugin pour Clang Static Analyzer pour rechercher les d√©bordements d'entiers</a></li>
<li><a href="../fr473416/index.html">Programme de la conf√©rence ZeroNights 2019</a></li>
<li><a href="../fr473418/index.html">OSCP - S√©curit√© offensive</a></li>
<li><a href="../fr473420/index.html">Nous ouvrons la saison des PHP-Meetups √† Nizhny Novgorod le 2 novembre</a></li>
<li><a href="../fr473424/index.html">ARM annonce les solutions graphiques Mali-G57 Valhall et Mali-D37, les neuroprocesseurs Ethos-N57 et N37</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>