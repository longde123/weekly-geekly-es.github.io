<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💻 🥫 👌🏽 Débogage des fuites de mémoire cachées dans Ruby 🙋 👩🏿‍🤝‍👨🏾 🏄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 2015, j'ai écrit sur les outils fournis par Ruby pour détecter les fuites de mémoire gérée . La plupart du temps, l'article parlait de fuites facil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Débogage des fuites de mémoire cachées dans Ruby</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473408/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/sf/qs/vxsfqsmdrslng_xf3oslr5os3ge.jpeg"></div><br>  En 2015, j'ai écrit sur les outils fournis par Ruby pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">détecter les fuites de mémoire gérée</a> .  La plupart du temps, l'article parlait de fuites faciles à gérer.  Cette fois, je vais parler des outils et astuces que vous pouvez utiliser pour éliminer les fuites qui ne sont pas si faciles à analyser dans Ruby.  En particulier, je vais parler de mwrap, heaptrack, iseq_collector et chap. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cd/bda/07b/5cdbda07b31678a618b6f6205f5f9722.png"></div><br><h1>  Fuites de mémoire non gérées </h1><br>  Ce petit programme provoque une fuite avec un appel direct à malloc.  Il commence avec une consommation de 16 Mo de flux RSS et se termine avec 118 Mo.  Le code place en mémoire 100 000 blocs de 1024 octets et en supprime 50 000. <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'fiddle'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'objspace'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">`</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{Process.pid} -o rss -h`.strip.to_i * 1024 puts "RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}" end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374</span></span></span></span></code> </pre> <br>  Bien que RSS fasse 118 Mo, notre objet Ruby ne connaît que trois mégaoctets.  Dans l'analyse, nous ne voyons qu'une très petite partie de cette très grande fuite de mémoire. <br><br>  Un véritable exemple d'une telle fuite est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit par Oleg Dashevsky</a> , je vous recommande de lire ce merveilleux article. <br><br><h1>  Appliquer Mwrap </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mwrap</a> est un profileur de mémoire pour Ruby qui surveille toutes les allocations de données en mémoire en interceptant malloc et d'autres fonctions de cette famille.  Il intercepte les appels qui passent et libèrent de la mémoire à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LD_PRELOAD</a> .  Il utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liburcu</a> pour le comptage et peut suivre les compteurs d'allocation et de suppression pour chaque point d'appel, en code C et Ruby.  Mwrap est de petite taille, environ deux fois plus grand que RSS pour un programme profilé, et environ deux fois plus lent. <br><br>  Il diffère de nombreuses autres bibliothèques par sa très petite taille et son support Ruby.  Il suit les emplacements dans les fichiers Ruby et n'est pas limité aux backtracks de niveau C valgrind + masif et aux profileurs similaires.  Cela simplifie considérablement l'isolement des sources de problèmes. <br><br>  Pour utiliser le profileur, vous devez exécuter l'application via le shell Mwrap, il implémentera l'environnement LD_PRELOAD et exécutera le binaire Ruby. <br><br>  Ajoutons Mwrap à notre script: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'mwrap'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_leaks</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mwrap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocations</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frees</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age_total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_lifespan</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;&lt;</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((total / allocations.to_f)</span></span></span></span> * (allocations - frees)), allocations, frees] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results.sort! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|(_, growth_a), (_, growth_b)|</span></span> growth_b &lt;=&gt; growth_a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">20</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|location, growth, allocations, frees|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> growth == <span class="hljs-number"><span class="hljs-number">0</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{location}</span></span></span><span class="hljs-string"> growth: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{growth.to_i}</span></span></span><span class="hljs-string"> allocs/frees (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{allocations}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{frees}</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear leak_memory GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Maintenant, exécutez le script avec le wrapper Mwrap: <br><br><pre> <code class="ruby hljs">% gem install mwrap % mwrap ruby leak.rb leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">51200000</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">100000</span></span>/<span class="hljs-number"><span class="hljs-number">50000</span></span>) leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">4008</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Mwrap a correctement détecté une fuite dans le script (50 000 * 1024).  Et non seulement déterminé, mais aussi isolé une ligne spécifique ( <code>i = Fiddle.malloc(1024)</code> ), ce qui a conduit à une fuite.  Le profileur l'a correctement lié aux appels à <code>Fiddle.free</code> . <br><br>  Il est important de noter que nous avons affaire à une évaluation.  Mwrap surveille la mémoire partagée allouée par l'homologue de numérotation, puis surveille la libération de mémoire.  Mais si vous avez un point d'appel qui alloue des blocs de mémoire de différentes tailles, le résultat sera inexact.  Nous avons accès à l'évaluation: <code>((total / allocations) * (allocations - frees))</code> <br><br>  De plus, pour simplifier le suivi des fuites, Mwrap suit <code>age_total</code> , qui est la somme de la durée de vie de chaque objet libéré, et suit également <code>max_lifespan</code> , la durée de vie de l'objet le plus ancien au point d'appel.  Si <code>age_total / frees</code> important, la consommation de mémoire augmente malgré de nombreuses collectes de place. <br><br>  Mwrap a plusieurs aides pour réduire le bruit.  <code>Mwrap.clear</code> tout le stockage interne.  <code>Mwrap.quiet {}</code> forcera Mwrap à suivre le bloc de code. <br><br>  Une autre caractéristique distinctive de Mwrap est le suivi du nombre total d'octets alloués et libérés.  Supprimez <code>clear</code> du script et exécutez-le: <br><br><pre> <code class="ruby hljs">usage puts <span class="hljs-string"><span class="hljs-string">"Tracked size: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691</span></span></code> </pre> <br>  Le résultat est très intéressant, car malgré la taille RSS de 130 Mo, Mwrap ne voit que 91 Mo.  Cela suggère que nous avons gonflé notre processus.  L'exécution sans Mwrap montre que dans une situation normale, le processus prend 118 Mo, et dans ce cas simple, la différence était de 12 Mo.  Le modèle d'allocation / libération a conduit à la fragmentation.  Cette connaissance peut être très utile, dans certains cas, les processus glocc malloc non configurés se fragmentent tellement que la très grande quantité de mémoire utilisée dans RSS est en fait libre. <br><br><h1>  Mwrap peut-il isoler une ancienne fuite de tapis rouge? </h1><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son article,</a> Oleg discute d'une manière très approfondie d'isoler une fuite très mince dans le tapis rouge.  Il y a beaucoup de détails.  Il est très important de prendre des mesures.  Si vous ne créez pas de chronologie pour le processus RSS, il est peu probable que vous puissiez vous débarrasser de toute fuite. <br><br>  Entrons dans une machine à remonter le temps et montrons à quel point il est plus facile d'utiliser Mwrap pour de telles fuites. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">red_carpet_leak</span></span></span><span class="hljs-function"> 100</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markdown</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redcarpet</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Markdown</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Redcarpet::Render::HTML, extensions = {})</span></span></span></span> markdown.render(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear red_carpet_leak GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Redcarpet 3.3.2: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000)</code> </pre> <br>  Redcarpet 3.5.0: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000)</code> </pre> <br>  Si vous pouvez vous permettre d'exécuter le processus à la moitié de la vitesse en le redémarrant simplement dans la prod Mwrap avec la journalisation du résultat dans un fichier, vous pouvez identifier un large éventail de fuites de mémoire. <br><br><h1>  Fuite mystérieuse </h1><br>  Récemment, Rails a été mis à jour vers la version 6. En général, l'expérience a été très positive, les performances sont restées à peu près les mêmes.  Rails 6 a de très bonnes fonctionnalités que nous utiliserons (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zeitwerk</a> ).  Rails a changé la façon dont les modèles ont été rendus, ce qui a nécessité quelques modifications pour la compatibilité.  Quelques jours après la mise à jour, nous avons remarqué une augmentation du flux RSS pour la tâche Sidekiq. <br><br>  Mwrap a signalé une forte augmentation de la consommation de mémoire en raison de son allocation ( <a href="">lien</a> ): <br><br><pre> <code class="ruby hljs"> source.encode! <span class="hljs-comment"><span class="hljs-comment"># Now, validate that the source we got back from the template # handler is valid in the default_internal. This is for handlers # that handle encoding but screw up unless source.valid_encoding? raise WrongEncodingError.new(source, Encoding.default_internal) end begin mod.module_eval(source, identifier, 0) rescue SyntaxError # Account for when code in the template is not syntactically valid; eg if we're using # ERB and the user writes &lt;%= foo( %&gt;, attempting to call a helper `foo` and interpolate # the result into the template, but missing an end parenthesis. raise SyntaxErrorInTemplate.new(self, original_source) end end def handle_render_error(view, e) if e.is_a?(Template::Error)</span></span></code> </pre> <br>  Au début, nous étions très perplexes.  Nous essayions de comprendre pourquoi mécontent de Mwrap?  Peut-être qu'il s'est cassé?  Alors que la consommation de mémoire augmentait, les tas de rubis sont restés inchangés. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/79b/b60/7d079bb600f7d072515d081bb584c500.png"><br><br>  Deux millions d'emplacements dans le tas ne consommaient que 78 Mo (40 octets par emplacement).  Les lignes et les tableaux peuvent prendre plus de place, mais cela n'explique toujours pas la consommation de mémoire anormale que nous avons observée.  Cela a été confirmé lorsque j'ai <code>rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all</code> . <br><br>  Où est passé le souvenir? <br><br><h1>  Heaptrack </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heaptrack</a> est un profileur de mémoire de tas pour Linux. <br><br>  Milian Wolff a parfaitement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqué le</a> fonctionnement du profileur et en a parlé dans plusieurs discours ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> ).  En fait, il s'agit d'un profileur de tas natif très efficace qui, avec l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libunwind,</a> recueille les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traces</a> des applications profilées.  Il fonctionne nettement plus rapidement que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valgrind / Massif</a> et a la capacité de le rendre beaucoup plus pratique pour le profilage temporaire dans la prod.  Il peut être attaché à un processus déjà en cours! <br><br>  Comme avec la plupart des profileurs de tas, lors de l'appel de toutes les fonctions de la famille malloc, Heaptrack doit compter.  Cette procédure ralentit définitivement un peu le processus. <br><br>  À mon avis, l'architecture ici est la meilleure de toutes.  L'interception est effectuée à l'aide de <code>LD_PRELOAD</code> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDB</a> pour charger le profileur.  À l'aide d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier FIFO spécial,</a> il transfère les données du processus profilé le plus rapidement possible.  Le wrapper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">heaptrack</a> est un simple script shell qui facilite la recherche d'un problème.  Le deuxième processus lit les informations du FIFO et compresse à la volée les données de suivi.  Étant donné que Heaptrack fonctionne avec des «morceaux», vous pouvez analyser le profil en quelques secondes après le début du profilage, en plein milieu de la session.  Copiez simplement le fichier de profil vers un autre emplacement et lancez l'interface graphique Heaptrack. <br><br>  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ticket GitLab</a> m'a parlé de la possibilité même de lancer Heaptrack.  S'ils pouvaient l'exécuter, alors je le peux. <br><br>  Notre application s'exécute dans un conteneur, et je dois le redémarrer avec <code>--cap-add=SYS_PTRACE</code> , cela permet à GDB d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ptrace</a> , qui est nécessaire pour que Heaptrack s'injecte lui-même.  J'ai également besoin d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petit hack</a> pour que le fichier shell applique <code>root</code> au profil du processus non <code>root</code> (nous avons lancé notre application Discourse dans le conteneur sous un compte limité). <br><br>  Une fois que tout a été fait, il ne reste plus qu'à exécuter <code>heaptrack -p PID</code> et attendre que les résultats apparaissent.  Heaptrack s'est avéré être un excellent outil, il était très facile de suivre tout ce qui se passe avec des fuites de mémoire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/9ad/a55/72c9ada55ca01cb02e06d1b433fab705.png"><br><br>  Sur le graphique, vous voyez deux sauts, l'un dû à <code>cppjieba</code> , l'autre à <code>objspace_xmalloc0</code> dans Ruby. <br><br>  Je connaissais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cppjieba</a> .  La segmentation de la langue chinoise coûte cher, vous avez besoin de gros dictionnaires, donc ce n'est pas une fuite.  Mais qu'en est-il de l'allocation de mémoire dans Ruby, qui ne me dit toujours pas cela? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/340/72a/c57/34072ac5776eea391854dabe54f18056.png"><br><br>  Le gain principal est lié à <code>iseq_set_sequence</code> dans <code>compile.c</code> .  Il s'avère que la fuite est due à des séquences d'instructions.  Cela a effacé la fuite découverte par Mwrap.  Sa cause était <code>mod.module_eval(source, identifier, 0)</code> , qui a créé des séquences d'instructions qui n'ont pas été supprimées de la mémoire. <br><br>  Si, dans une analyse rétrospective, j'avais soigneusement considéré un vidage de tas de Ruby, alors j'aurais remarqué tous ces IMEMO, car ils sont inclus dans ce vidage.  Ils sont simplement invisibles lors des diagnostics en cours. <br><br>  À partir de ce moment, le débogage était assez simple.  J'ai suivi tous les appels vers le module eval et jeté ce qu'il a évalué.  J'ai constaté que nous ajoutons encore et encore des méthodes à une grande classe.  Voici une vue simplifiée du bug rencontré: <br><br><pre> <code class="python hljs">require <span class="hljs-string"><span class="hljs-string">'securerandom'</span></span> module BigModule; end <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_methods</span></span></span><span class="hljs-function"> 10</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> = "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_</span></span></span><span class="hljs-function">#{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-function">}; #{"</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">;" * 100}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigModule</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSS</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">16164</span></span> ObjectSpace size <span class="hljs-number"><span class="hljs-number">2869</span></span> leak_methods usage <span class="hljs-comment"><span class="hljs-comment"># RSS: 123096 ObjectSpace size 5583</span></span></code> </pre> <br>  Ruby a une classe pour stocker les séquences d'instructions <code>RubyVM::InstructionSequence</code> : <code>RubyVM::InstructionSequence</code> .  Cependant, Ruby est trop paresseux pour créer ces objets wrapper, car les stocker inutilement est inefficace.  Koichi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sasada a</a> créé la dépendance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">iseq_collector</a> .  Si nous ajoutons ce code, nous pouvons trouver notre mémoire cachée: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iseq_collector'</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ObjectSpace.memsize_of_all_iseq / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 98747 ObjectSpace.memsize_of_all_iseq</span></span></code> </pre> <br>  matérialise chaque séquence d'instructions, ce qui peut augmenter légèrement la consommation de mémoire du processus et donner au garbage collector un peu plus de travail. <br><br>  Si, par exemple, nous calculons le nombre d'ISEQ avant et après le démarrage du collecteur, nous verrons qu'après le démarrage d' <code>ObjectSpace.memsize_of_all_iseq</code> notre compteur de la classe <code>RubyVM::InstructionSequence</code> de 0 à 11128 (dans cet exemple): <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_iseqs</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectSpace</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RubyVM::InstructionSequence)</span></span></span></span>.count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Ces emballages resteront pendant toute la durée de vie de la méthode, ils devront être visités avec une exécution complète du ramasse-miettes.  Notre problème a été résolu en réutilisant la classe responsable du rendu des modèles de courrier électronique ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif 2</a> ). <br><br><h1>  chap </h1><br>  Lors du débogage, j'ai utilisé un outil très intéressant.  Il y a quelques années, Tim Boddy a sorti un outil interne utilisé par VMWare pour analyser les fuites de mémoire et a ouvert son code.  Voici la seule vidéo à ce sujet que j'ai réussi à trouver: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.youtube.com/watch?v=EZ2n3kGtVDk</a> .  Contrairement à la plupart des outils similaires, celui-ci n'a aucun effet sur le processus exécutable.  Il peut simplement être appliqué aux fichiers du vidage principal, tandis que glibc est utilisé comme un allocateur (il n'y a pas de support pour jemalloc / tcmalloc, etc.). <br><br>  Avec chap, il est très facile de détecter la fuite que j'avais.  Peu de distributions ont un binaire chap, mais vous pouvez facilement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compiler à partir du code source</a> .  Il est très activement soutenu. <br><br><pre> <code class="plaintext hljs"># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes.</code> </pre> <br>  Chap peut utiliser des signatures pour rechercher des emplacements de mémoire différente, et il peut compléter GDB.  Lors du débogage dans Ruby, il peut être très utile pour déterminer la mémoire utilisée par le processus.  Il montre la mémoire totale utilisée, parfois la glibc malloc peut se fragmenter tellement que le volume utilisé peut être très différent du RSS réel.  Vous pouvez lire la discussion: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Feature # 14759: [PATCH] set M_ARENA_MAX for glibc malloc - Ruby master - Ruby Issue Tracking System</a> .  Chap est capable de compter correctement toute la mémoire utilisée et de fournir une analyse approfondie de son allocation. <br><br>  De plus, chap peut être intégré dans les workflows pour détecter automatiquement les fuites et signaler de tels assemblages. <br><br><h1>  Travaux de suivi </h1><br>  Ce tour de débogage m'a fait poser quelques questions liées à nos boîtes à outils d'aide: <br><br><ul><li>  Je voudrais avoir un support pour la capture de trames de pile d'appels de Ruby dans Heaptrack.  Milian est également intéressé par ceci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">412929 - Pouvons-nous saisir un cadre de Ruby land?</a> <br></li><li>  J'aimerais que Ruby prenne en charge des capacités de diagnostic plus larges: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://bugs.ruby-lang.org/issues/16245</a> <br></li><li>  J'aimerais que Mwrap soit un peu plus facile à utiliser dans la prod.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lisez ici</a> . </li></ul><br><h1>  Résumé </h1><br>  Notre boîte à outils d'aujourd'hui pour le débogage de fuites de mémoire très complexes est bien meilleure qu'elle ne l'était il y a 4 ans!  Mwrap, Heaptrack et chap sont des outils très puissants pour résoudre les problèmes de mémoire qui surviennent pendant le développement et l'exploitation. <br><br>  Si vous recherchez une simple fuite de mémoire dans Ruby, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon article de 2015</a> , pour la plupart, il est pertinent. <br><br>  J'espère que vous trouverez cela plus facile la prochaine fois que vous commencerez à déboguer une fuite de mémoire native complexe. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473408/">https://habr.com/ru/post/fr473408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473392/index.html">Comment lancer un nouveau site bancaire. 2e partie</a></li>
<li><a href="../fr473394/index.html">Vous mentez tous! À propos de la publicité CRM</a></li>
<li><a href="../fr473396/index.html">Nous avons besoin d'une autre bitrix</a></li>
<li><a href="../fr473400/index.html">Technologie de synthèse vocale de haute qualité, légère et adaptable utilisant LPCNet</a></li>
<li><a href="../fr473406/index.html">Marathon gratuit "Data Science et IA: apprendre à la machine à écrire le script de la série"</a></li>
<li><a href="../fr473412/index.html">Création d'un plugin pour Clang Static Analyzer pour rechercher les débordements d'entiers</a></li>
<li><a href="../fr473416/index.html">Programme de la conférence ZeroNights 2019</a></li>
<li><a href="../fr473418/index.html">OSCP - Sécurité offensive</a></li>
<li><a href="../fr473420/index.html">Nous ouvrons la saison des PHP-Meetups à Nizhny Novgorod le 2 novembre</a></li>
<li><a href="../fr473424/index.html">ARM annonce les solutions graphiques Mali-G57 Valhall et Mali-D37, les neuroprocesseurs Ethos-N57 et N37</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>