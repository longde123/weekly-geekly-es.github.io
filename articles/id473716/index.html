<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 🗂️ 👜 Widget yang digerakkan mouse. Seret dan letakkan di dalam jendela ⛷️ ↘️ 🏎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemahaman yang biasa tentang Drag and Drop (D&D) mengasumsikan bahwa, misalnya, tautan ke file diambil dari satu widget dan dipindahkan dengan mouse k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Widget yang digerakkan mouse. Seret dan letakkan di dalam jendela</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473716/"><p> Pemahaman yang biasa tentang Drag and Drop (D&amp;D) mengasumsikan bahwa, misalnya, tautan ke file diambil dari satu widget dan dipindahkan dengan mouse ke jendela atau widget lain.  Selanjutnya, kita akan berbicara bukan tentang fungsi perpustakaan D &amp; D, tetapi tentang implementasi kita sendiri dalam memindahkan widget di dalam jendela dan fungsionalitas terkait.  Kode ini lebih sebagai contoh daripada aplikasi praktis konkret, ditulis dalam gaya C dengan kelas-kelas.  Editornya adalah CodeBlocks 17.12, yang berhenti mogok di Ubuntu x64 dibandingkan dengan versi ke-16. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/e1/2g/ve/e12gvery3tvo4tlu5z_2mrdkppy.png" alt="gambar"></div><a name="habracut"></a><br><p>  Ada wadah widget GtkFixed, yang dapat menyimpan widget lain pada koordinat tertentu, konsep klasik pembuatan aplikasi pada GTK melibatkan penggunaan wadah widget GtkBox (dan lainnya) untuk meregangkan jendela dengan benar dan mengisi ruang.  Wadah tersebut diregangkan ke ukuran jendela (dan ke batas widget lainnya), atau dikurangi menjadi ukuran widget anak sebagai aturan. <br></p><p>  Kode ini dibagi menjadi main.cpp, main.hpp, movable_widgets.hpp.  Saya tidak memilih file implementasi secara terpisah.  Konten main.cpp sangat khas: <br><br></p><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movable_widgets.hpp"</span></span></span><span class="hljs-meta"> void builder_init(gpointer user_data) { appdata *data=(appdata*) user_data; GError *</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = NULL; GtkBuilder *builder = gtk_builder_new(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!gtk_builder_add_from_file (builder, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"window.glade"</span></span></span><span class="hljs-meta">, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     g_critical ("   : %s", error-&gt;message); g_error_free (error); } data-&gt;win=GTK_WIDGET(gtk_builder_get_object(builder, "window1")); data-&gt;notebook=GTK_NOTEBOOK(gtk_builder_get_object(builder, "notebook1")); gtk_notebook_remove_page(data-&gt;notebook,0); ///    gtk_builder_connect_signals (builder,data); g_clear_object(&amp;builder); } void application_activate(GtkApplication *application, gpointer user_data) { appdata *data=(appdata*) user_data; builder_init(data); gtk_widget_set_size_request(data-&gt;win,320,240); gtk_application_add_window(data-&gt;app,GTK_WINDOW(data-&gt;win)); page_body *page=new page_body(data, G_OBJECT(data-&gt;notebook)); const gchar *text ="&lt;span foreground=\"blue\" size=\"x-large\"&gt;Blue text&lt;/span&gt;" ; GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), text); GtkWidget *image=gtk_image_new_from_file("opennet2.gif"); GtkWidget *image2=gtk_image_new_from_file("n_temp.png"); page-&gt;add_widget(label,label_t,10,10); page-&gt;add_widget(image,image_t,20,20); page-&gt;add_widget(image2,image_t,40,40); gtk_widget_show_all(data-&gt;win); } void application_shutdown(const GtkApplication *application, gpointer user_data) {} int main (int argc, char *argv[]) { appdata data; gtk_init (&amp;argc, &amp;argv); gint res; data.app = gtk_application_new("gtk3.org", G_APPLICATION_FLAGS_NONE); g_signal_connect(data.app, "activate", G_CALLBACK(application_activate), &amp;data); g_signal_connect(data.app, "shutdown", G_CALLBACK(application_shutdown), &amp;data); res = g_application_run(G_APPLICATION(data.app), 0, NULL); return 0; }</span></span></span></span></code> </pre> <br><p>  Beberapa widget dibuat dari deskripsi XML (function builder_init), bagian lain secara terprogram (halaman-&gt; add_widget).  Fungsi Gtk_widget_show_all (data-&gt; win);  diperlukan untuk tampilan widget berulang dan isinya.  GTK secara independen menghapus konten widget saat dihapus, khususnya widget anak lainnya.  Pada saat fungsi callback application_shutdown dijalankan, jendela utama dan semua widget konten telah dihapus. <br></p><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdlib.h&gt; #define restrict __restrict__ class appdata { public: char *glade_name=(char*)"window.glade"; GtkApplication *restrict app; GtkWidget *restrict win; GtkNotebook *restrict notebook; GArray *restrict pages; }; #endif</span></span></span></span></code> </pre><br>  Bidang halaman adalah array pointer ke kelas dengan konten halaman, dalam contoh ini tidak digunakan, karena 1 tab hanya digunakan.  Menggunakan batasan adalah amatir.  Secara teoritis, memberikan peningkatan kinerja tertentu.  Dalam hal ini, tidak perlu digunakan. <br><br><p>  Widget yang dimasukkan itu sendiri ditempatkan dalam wadah jenis GtkEventBox.  Dia mengumpulkan acara <br>  klik tombol.  Juga wadah opsional dari tipe GtkFrame untuk menampilkan widget dalam bingkai ketika mengklik tombol kiri mouse.  Operasi penggantian kontainer cukup cepat.  Tab itu sendiri, tempat widget dimasukkan, memiliki hierarki lampiran berikut: GtkScrolledWindow-&gt; GtkViewport-&gt; GtkFixed.  Awalnya, widget bertipe GtkWidget, yang dikonversi oleh makro ke tipe GtkViewport, GtkFixed.  Saya akan menekankan <br>  memperhatikan tampilan makro <br>  InsertedWidgetWithProperty * widget_with_property = &amp; g_array_index (widget, InsertedWidgetWithProperty, i); <br>  karena paling mudah untuk membuat kesalahan di sini.  Parameter x_correction, y_correction - koordinat klik mouse relatif terhadap widget GtkEvent yang dimasukkan.  Bendera button_not_pressed digunakan untuk menampilkan wadah bingkai dengan benar.  Secara logika, dapat dipahami bahwa jika salah satu tombol mouse diklik pada widget yang dimasukkan, maka itu harus ditempatkan dalam bingkai.  Yaitu, peristiwa klik tombol dan peristiwa pelepasan tombol tidak dipasangkan, tidak seperti peristiwa enter-notify-event dan event-notify-event, yang dikaitkan dengan perubahan dalam bentuk kursor.  Jika x_correction, parameter button_not_pressed adalah resmi, yaitu, mereka harus ditempatkan di bagian pribadi, flag click_order digunakan untuk menampilkan widget saat ini di atas sisanya. <br><br></p><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> widget_ptr; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> eventbox; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> frame; <span class="hljs-comment"><span class="hljs-comment">//   GtkWidget *restrict pmenu; widget_type type; bool button_not_pressed; } InsertedWidgetWithProperty; class page_body { public: GtkWidget *restrict scrolledwindow; GtkWidget *restrict viewport; GtkWidget *restrict fixed; GArray *restrict widgets=g_array_new(FALSE, TRUE, sizeof(InsertedWidgetWithProperty)); GtkAdjustment *restrict h_adj; GtkAdjustment *restrict v_adj; int num_of_current_widget=0; double x_correction=0; double y_correction=0; GtkWidget *restrict window; ///      int widget_count=0; bool click_order=FALSE; //TRUE -  page_body(appdata *data, GObject *container) { window=data-&gt;win; h_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); v_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); scrolledwindow=gtk_scrolled_window_new(h_adj, v_adj); viewport=gtk_viewport_new(h_adj, v_adj); fixed=gtk_fixed_new(); gtk_container_add(GTK_CONTAINER(scrolledwindow),GTK_WIDGET(viewport)); gtk_container_add(GTK_CONTAINER(viewport),GTK_WIDGET(fixed)); if(GTK_IS_NOTEBOOK(container)) { gtk_notebook_append_page ((GtkNotebook*)container,scrolledwindow,NULL); } else if(GTK_IS_WIDGET(container)) { gtk_container_add(GTK_CONTAINER(container),scrolledwindow); } g_signal_connect(fixed,"motion-notify-event",G_CALLBACK(fixed_motion_notify), this); g_signal_connect(scrolledwindow,"destroy",G_CALLBACK(scrolled_window_destroy_cb), this); } ~page_body() { int i=widgets-&gt;len; if(widget_count&gt;0) { for(i; i&gt;=0; i--) { InsertedWidgetWithProperty *widget_with_property; widget_with_property=&amp;g_array_index(widgets,InsertedWidgetWithProperty,i); } } g_array_free(widgets,TRUE); } void add_widget(GtkWidget *widget, widget_type type, int x, int y) { ++widget_count; InsertedWidgetWithProperty *widget_with_property=(InsertedWidgetWithProperty*) g_malloc0(sizeof(InsertedWidgetWithProperty)); widget_with_property-&gt;eventbox=gtk_event_box_new(); widget_with_property-&gt;type=type; widget_with_property-&gt;widget_ptr=widget; gtk_container_add(GTK_CONTAINER(widget_with_property-&gt;eventbox),widget); gtk_fixed_put(GTK_FIXED(fixed),widget_with_property-&gt;eventbox,x,y); widget_with_property-&gt;pmenu=gtk_menu_new(); GtkWidget *menu_items = gtk_menu_item_new_with_label (""); gtk_widget_show(menu_items); gtk_menu_shell_append (GTK_MENU_SHELL (widget_with_property-&gt;pmenu), menu_items); g_signal_connect(widget_with_property-&gt;eventbox,"button-press-event",G_CALLBACK(eventbox_press_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"button-release-event",G_CALLBACK(eventbox_release_cb),this); g_signal_connect(menu_items,"activate",G_CALLBACK(menu_delete_activate),this); g_signal_connect(widget_with_property-&gt;eventbox,"leave-notify-event",G_CALLBACK(eventbox_leave_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"enter-notify-event",G_CALLBACK(eventbox_enter_cb),this); gtk_widget_set_events(widget_with_property-&gt;eventbox,GDK_LEAVE_NOTIFY_MASK|GDK_ENTER_NOTIFY_MASK|GDK_STRUCTURE_MASK); g_array_append_val(widgets, *widget_with_property); } inline void change_cursor(char *cursor_name) { GdkDisplay *display; GdkCursor *cursor; display = gtk_widget_get_display (window); if(cursor_name) cursor = gdk_cursor_new_from_name (display, cursor_name); else cursor = gdk_cursor_new_from_name (display, "default"); GdkWindow *gdkwindow=gtk_widget_get_window (window); gdk_window_set_cursor (gdkwindow, cursor); } inline void delete_widget(int i) { InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(this-&gt;widgets,InsertedWidgetWithProperty,i); GtkWidget *eventbox=widget_with_property-&gt;eventbox; g_object_ref(eventbox); gtk_container_remove(GTK_CONTAINER(this-&gt;fixed),eventbox); if(widget_with_property-&gt;frame!=NULL) { gtk_widget_destroy(widget_with_property-&gt;frame); } gtk_widget_destroy(widget_with_property-&gt;eventbox); this-&gt;widgets=g_array_remove_index_fast(this-&gt;widgets,i); --this-&gt;widget_count; } };</span></span></code> </pre><br>  Rumus untuk menghitung koordinat widget sehingga tidak bergerak ke arah mana pun ketika Anda mengklik tombol mouse di atasnya.  Ini melibatkan koordinat klik relatif terhadap widget, <br>  GtkFixed koordinat relatif terhadap jendela aplikasi, koordinat jendela relatif terhadap layar. <br>  Faktor koreksi +25 agak membingungkan saya, tetapi saya tidak tahu bagaimana lebih mudah untuk menulis.  Saya memeriksa pekerjaan dalam versi Ubuntu 15.10, 16.04, 18.04.  Perbandingan dengan 0 dan -1 dilakukan sehingga widget yang dimasukkan tidak dihapus dari area yang dapat digulir.  Scrolling itu sendiri disediakan oleh widget GtkScrolledWindow. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixed_motion_notify</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x_win, y_win, x_fixed, y_fixed; gtk_window_get_position(GTK_WINDOW(page-&gt;window),&amp;x_win,&amp;y_win); gtk_widget_translate_coordinates(page-&gt;window,page-&gt;fixed,x_win,y_win,&amp;x_fixed,&amp;y_fixed); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_y=(-y_fixed+y_win)*<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_x=(-x_fixed+x_win); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x_corr=page-&gt;x_correction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y_corr=page-&gt;y_correction; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_x=event-&gt;motion.x_root-x_corr-x_win-correction_x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_y=event-&gt;motion.y_root-y_corr-y_fixed-correction_y; InsertedWidgetWithProperty *widget_with_property=&amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); GtkWidget *fixed=page-&gt;fixed; GtkWidget *eventbox=widget_with_property-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_x&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_y&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_y=<span class="hljs-number"><span class="hljs-number">0</span></span>; gtk_fixed_move(GTK_FIXED(fixed), eventbox, position_x, position_y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Sisa fungsi panggilan balik.  Diimplementasikan penghapusan widget individu melalui menu konteks dengan tombol kanan mouse.  Menghapus kelas page_body digantung dari peristiwa penghapusan GtkScrolledWindow. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrolled_window_destroy_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *object, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> page; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">menu_delete_activate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkMenuItem *menuitem, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;delete_widget(page-&gt;num_of_current_widget); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_leave_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_enter_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-string"><span class="hljs-string">"pointer"</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_press_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;x_correction=event-&gt;button.x; page-&gt;y_correction=event-&gt;button.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; InsertedWidgetWithProperty *widget_compare; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i; i&lt;=page-&gt;widgets-&gt;len; i++) { widget_compare=(InsertedWidgetWithProperty*) page-&gt;widgets-&gt;data+i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget==widget_compare-&gt;eventbox) { page-&gt;num_of_current_widget=i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;button_not_pressed==FALSE) { GtkWidget *eventbox=widget_compare-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(page-&gt;click_order) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; gtk_widget_translate_coordinates(page-&gt;fixed, eventbox,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,&amp;x, &amp;y); gtk_container_remove(GTK_CONTAINER(page-&gt;fixed),eventbox); gtk_fixed_put(GTK_FIXED(page-&gt;fixed),eventbox,-x,-y); } g_object_ref(widget_compare-&gt;widget_ptr); gtk_container_remove(GTK_CONTAINER(eventbox),widget_compare-&gt;widget_ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;frame==<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) widget_compare-&gt;frame=gtk_frame_new(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); gtk_container_add(GTK_CONTAINER(widget_compare-&gt;frame),widget_compare-&gt;widget_ptr); gtk_container_add(GTK_CONTAINER(eventbox),widget_compare-&gt;frame); gtk_widget_show_all(eventbox); widget_compare-&gt;button_not_pressed=TRUE; } <span class="hljs-comment"><span class="hljs-comment">///   const gint RIGHT_CLICK = 3; if (event-&gt;type == GDK_BUTTON_PRESS) { GdkEventButton *bevent = (GdkEventButton *) event; if (bevent-&gt;button == RIGHT_CLICK) { gtk_menu_popup(GTK_MENU(widget_compare-&gt;pmenu), NULL, NULL, NULL, NULL, bevent-&gt;button, bevent-&gt;time); } } return FALSE; } gboolean eventbox_release_cb (GtkWidget *eventbox, GdkEvent *event, gpointer user_data) { page_body *page=(page_body*) user_data; InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); ///      ,    if(widget_with_property-&gt;button_not_pressed==TRUE) { widget_with_property-&gt;frame=(GtkWidget*) g_object_ref(widget_with_property-&gt;frame); widget_with_property-&gt;widget_ptr=(GtkWidget*) g_object_ref(widget_with_property-&gt;widget_ptr); GtkWidget *frame=widget_with_property-&gt;frame; GtkWidget *widget=widget_with_property-&gt;widget_ptr; gtk_container_remove(GTK_CONTAINER(eventbox), frame); gtk_container_remove(GTK_CONTAINER(frame), widget); gtk_container_add(GTK_CONTAINER(eventbox), widget); widget_with_property-&gt;button_not_pressed=FALSE; } }</span></span></code> </pre><br>  Terima kasih atas perhatian anda <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/SanyaZ7/movable_widgets_on_GtkFixed-</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473716/">https://habr.com/ru/post/id473716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473704/index.html">Kawan vs. bukan bro</a></li>
<li><a href="../id473706/index.html">Zoia: CMS reaktif ringan untuk pengembangan situs web yang cepat</a></li>
<li><a href="../id473708/index.html">Mobil listrik buatan rumah - semuanya tidak seperti yang Anda pikirkan</a></li>
<li><a href="../id473710/index.html">Prinsip-prinsip dokumentasi dan lokalisasi, atau cara mendapatkan lokalisasi yang baik dengan biaya minimal</a></li>
<li><a href="../id473714/index.html">Bagaimana saya sampai pada spesifikasi formal prosesor RISC-V di F #</a></li>
<li><a href="../id473718/index.html">Cara menambahkan cek ke NoVerify tanpa menulis satu baris kode Go</a></li>
<li><a href="../id473720/index.html">Dua cara untuk membuat unit test yang andal</a></li>
<li><a href="../id473722/index.html">Isolasi jarak jauh, kecemasan dan depresi</a></li>
<li><a href="../id473726/index.html">Tidak cukup hanya tahu apa itu Mutex, Semaphore, dan async / tunggu. Anda perlu tahu segalanya dari kuanta</a></li>
<li><a href="../id473728/index.html">Implementasi pemantauan yang khas. Nikolay Sivko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>