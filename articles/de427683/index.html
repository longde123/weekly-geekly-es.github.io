<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Æ ‚ÜòÔ∏è üêª Warum das Portieren √ºber einen Ganzzahl√ºberlauf keine gute Idee ist üîí ü•† üå∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf undefiniertes Verhalten und Compileroptimierungen, insbesondere im Zusammenhang mit einem vorzeichenbehafteten Ga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum das Portieren √ºber einen Ganzzahl√ºberlauf keine gute Idee ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/427683/">  <b>Dieser Artikel konzentriert sich auf undefiniertes Verhalten und Compileroptimierungen, insbesondere im Zusammenhang mit einem vorzeichenbehafteten Ganzzahl√ºberlauf.</b> <br><br>  <b>Anmerkung des √úbersetzers: Auf</b> Russisch gibt es keine eindeutige Entsprechung im verwendeten Kontext des Wortes ‚ÄûWrap‚Äú / ‚ÄûWrapping‚Äú.  Es gibt einen mathematischen Begriff " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbertragung</a> ", der dem beschriebenen Ph√§nomen nahe kommt, und der Begriff "√úbertragsflag" ist ein Mechanismus zum Setzen eines Flags in Prozessoren w√§hrend eines Ganzzahl√ºberlaufs.  Eine andere √úbersetzungsoption kann der Ausdruck "Drehung / Umdrehen / Umdrehen um Null" sein.  Es spiegelt die Bedeutung von "Wrap" besser wider als "Carry", weil  zeigt den √úbergang von Zahlen beim √úberlaufen vom positiven zum negativen Bereich.  Wie sich jedoch herausstellte, sehen diese W√∂rter im Text f√ºr Testleser ungew√∂hnlich aus.  Der Einfachheit halber werden wir in Zukunft das Wort "√úbertragung" als √úbersetzung des Begriffs "Wrap" verwenden. <br><br>  Compiler der C-Sprache (und C ++) orientieren sich in ihrer Arbeit zunehmend am Konzept des <i>unbestimmten Verhaltens</i> - der Vorstellung, dass das Verhalten eines Programms f√ºr einige Operationen nicht durch den Standard geregelt wird und dass der Compiler beim Generieren von Objektcode das Recht hat, von der Annahme auszugehen, dass das Programm solche Operationen nicht ausf√ºhrt.  Viele Programmierer haben gegen diesen Ansatz Einw√§nde erhoben, da sich der generierte Code in diesem Fall m√∂glicherweise nicht als Autor des beabsichtigten Programms verh√§lt.  Dieses Problem wird immer akuter, da Compiler ausgefeiltere Optimierungsmethoden verwenden, die wahrscheinlich auf dem Konzept des unbestimmten Verhaltens basieren werden. <br><a name="habracut"></a><br>  In diesem Zusammenhang ist ein Beispiel mit einem vorzeichenbehafteten Ganzzahl√ºberlauf indikativ.  Die meisten C-Entwickler schreiben Code f√ºr Maschinen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zus√§tzlichen Code</a> zur Darstellung von Ganzzahlen verwenden, und die Addition und Subtraktion in dieser Darstellung wird auf genau dieselbe Weise in vorzeichenloser Arithmetik implementiert.  Wenn die Summe von zwei positiven Ganzzahlen mit einem Vorzeichen √ºberl√§uft - das hei√üt, sie wird gr√∂√üer als der Typ -, gibt der Prozessor einen Wert zur√ºck, der als bin√§res Komplement der vorzeichenbehafteten Zahl interpretiert wird und als negativ betrachtet wird.  Dieses Ph√§nomen wird als "√úbertragung" bezeichnet, da das Ergebnis, das die Obergrenze des Wertebereichs erreicht, "√ºbertragen" wird und an der unteren Grenze beginnt. <br><br>  Aus diesem Grund k√∂nnen Sie diesen Code manchmal in C sehen: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a + <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; a) { <span class="hljs-comment"><span class="hljs-comment">//  puts("input too large!"); return; }</span></span></code> </pre> <br>  Die Aufgabe der <i>if-Anweisung</i> besteht darin, eine √úberlaufbedingung zu erkennen (in diesem Fall nach dem Hinzuf√ºgen von 1000 zum Wert der Variablen <i>a</i> ) und einen Fehler zu melden.  Das Problem ist, dass in C ein vorzeichenbehafteter Ganzzahl√ºberlauf einer der F√§lle von undefiniertem Verhalten ist.  Seit einiger Zeit betrachten Compiler solche Bedingungen immer als falsch: Wenn Sie einer anderen Zahl 1000 (oder eine andere positive Zahl) hinzuf√ºgen, kann das Ergebnis nicht unter dem Anfangswert liegen.  Wenn ein √úberlauf auftritt, liegt ein undefiniertes Verhalten vor, und dies nicht zuzulassen, ist (anscheinend) bereits das Anliegen des Programmierers.  Daher kann der Compiler entscheiden, dass der bedingte Operator zu Optimierungszwecken vollst√§ndig entfernt werden kann (schlie√ülich ist die Bedingung immer falsch, sie wirkt sich auf nichts aus, sodass Sie darauf verzichten k√∂nnen). <br><br>  Das Problem ist, dass der Compiler bei dieser Optimierung die vom Programmierer speziell hinzugef√ºgte Pr√ºfung entfernt hat, um undefiniertes Verhalten zu erkennen und zu verarbeiten.  Hier k√∂nnen Sie sehen, wie dies in der Praxis geschieht.  (Hinweis: Die Website godbolt.org, auf der das Beispiel gehostet wird, ist sehr cool! Sie k√∂nnen den Code bearbeiten und sofort sehen, wie verschiedene Compiler ihn verarbeiten, und es gibt viele davon. Experimentieren Sie!).  Beachten Sie, dass der Compiler die Pr√ºfung auf √úberlauf nicht entfernt, wenn Sie den Typ in vorzeichenlos √§ndern, da das Verhalten mit vorzeichenlosem √úberlauf in C definiert ist (genauer gesagt, bei vorzeichenloser Arithmetik wird das Ergebnis √ºbertragen, sodass ein √úberlauf tats√§chlich nicht auftritt). <br><br>  Also ist das falsch?  Jemand sagt ja, obwohl es offensichtlich ist, dass viele Compiler-Entwickler diese Entscheidung f√ºr legal halten.  Wenn ich das richtig verstehe, lauten die Hauptargumente der Unterst√ºtzer (edit: implementierungsabh√§ngig) der √úbertragung w√§hrend des √úberlaufs wie folgt: <br><br><ul><li>  √úberlaufen ist ein n√ºtzliches Verhalten. </li><li>  Migration ist das Verhalten, das Programmierer erwarten. </li><li>  Die Semantik des unbestimmten √úberlaufverhaltens bietet keinen sp√ºrbaren Vorteil. </li><li>  Der C-Sprachstandard f√ºr undefiniertes Verhalten erm√∂glicht es der Implementierung, "die Situation vollst√§ndig zu ignorieren und das Ergebnis ist unvorhersehbar". Dies gibt dem Compiler jedoch nicht das Recht, den Code unter der Annahme zu optimieren, dass die Situation mit undefiniertem Verhalten √ºberhaupt nicht auftritt. </li></ul><br>  Lassen Sie uns nacheinander jeden Punkt analysieren: <br><br>  <b>√úberlaufmigration - N√ºtzliches Verhalten?</b> <br><br>  Die Migration ist vor allem dann n√ºtzlich, wenn Sie einen bereits aufgetretenen √úberlauf verfolgen m√ºssen.  (Wenn es andere Probleme gibt, die durch √úbertragung gel√∂st werden k√∂nnen und nicht mit vorzeichenlosen Ganzzahlvariablen gel√∂st werden k√∂nnen, kann ich mich nicht sofort an solche Beispiele erinnern, und ich vermute, dass es nur wenige davon gibt).  W√§hrend die √úbertragung das Problem der Verwendung falsch √ºbergelaufener Variablen wirklich vereinfacht, ist sie definitiv kein Allheilmittel (denken Sie an die Multiplikation oder Addition von zwei unbekannten Gr√∂√üen mit einem unbekannten Vorzeichen). <br><br>  In trivialen F√§llen, in denen Sie mit der √úbertragung lediglich den aufgetretenen √úberlauf verfolgen k√∂nnen, ist es auch nicht schwierig, im Voraus zu wissen, ob er √ºberhaupt auftreten wird.  Unser Beispiel kann wie folgt umgeschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; INT_MAX - <span class="hljs-number"><span class="hljs-number">1000</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    puts("input too large!"); return; } int b = a + 1000;</span></span></code> </pre> <br>  Das hei√üt, anstatt die Summe zu berechnen und dann herauszufinden, ob ein √úberlauf aufgetreten ist oder nicht, und das Ergebnis auf mathematische Konsistenz zu √ºberpr√ºfen, k√∂nnen Sie √ºberpr√ºfen, ob die Summe die maximale Anzahl √ºberschreitet, zu der der Typ passt.  (Wenn das Vorzeichen beider Operanden unbekannt ist, muss die √úberpr√ºfung sehr kompliziert sein, dies gilt jedoch auch f√ºr die √úberpr√ºfung w√§hrend der √úbertragung.) <br><br>  Angesichts all dessen finde ich das Argument nicht √ºberzeugend, dass die √úbertragung in den meisten F√§llen n√ºtzlich ist. <br><br>  <b>Ist Migration das Verhalten, das Programmierer erwarten?</b> <br><br>  Es ist schwieriger, mit diesem Argument zu argumentieren, da es offensichtlich ist, dass der Code von mindestens <i>einigen</i> C-Programmierern eine √úbertragungssemantik mit einem vorzeichenbehafteten Ganzzahl√ºberlauf voraussetzt.  Diese Tatsache allein reicht jedoch nicht aus, um eine solche Semantik als vorzuziehen zu betrachten (beachten Sie, dass Sie bei einigen Compilern diese bei Bedarf aktivieren k√∂nnen). <br><br>  Eine offensichtliche L√∂sung f√ºr das Problem (Programmierer erwarten dieses Verhalten) besteht darin, den Compiler zu warnen, wenn er den Code optimiert, vorausgesetzt, es gibt kein undefiniertes Verhalten.  Wie wir im Beispiel auf godbolt.org √ºber den obigen Link gesehen haben, tun Compiler dies leider nicht immer (Gcc-Version 7.3 - ja, aber Version 8.1 - nein, es gibt also einen Schritt zur√ºck). <br><br>  <b>Gibt die Semantik des unbestimmten √úberlaufverhaltens keinen sp√ºrbaren Vorteil?</b> <br><br>  Wenn diese Bemerkung in allen F√§llen zutrifft, w√ºrde sie als starkes Argument f√ºr die Tatsache dienen, dass Compiler standardm√§√üig die √úbertragungssemantik einhalten sollten, da es wahrscheinlich besser w√§re, √úberlaufpr√ºfungen zuzulassen, auch wenn dieser Mechanismus aus technischer Sicht falsch ist - obwohl w√§re, weil es in m√∂glicherweise defektem Code verwendet werden kann. <br><br>  Ich gehe davon aus, dass diese Optimierung (Entfernen von √úberpr√ºfungen mathematisch widerspr√ºchlicher Bedingungen) in normalen C-Programmen oft vernachl√§ssigt werden kann, da ihre Autoren die beste Leistung anstreben und den Code dennoch manuell optimieren: Das hei√üt, wenn es offensichtlich ist, dass diese <i>if-Anweisung</i> eine Bedingung enth√§lt , was niemals wahr sein wird, wird der Programmierer es wahrscheinlich selbst entfernen.  Tats√§chlich fand ich heraus, dass in mehreren Studien die Wirksamkeit einer solchen Optimierung in Frage gestellt, getestet und im Rahmen von Kontrolltests als praktisch unbedeutend befunden wurde.  Obwohl diese Optimierung in der Sprache C fast nie einen Vorteil bringt, sind Codegeneratoren und Compileroptimierungen gr√∂√ütenteils universell und k√∂nnen in anderen Sprachen verwendet werden - und f√ºr sie ist diese Schlussfolgerung m√∂glicherweise falsch.  Nehmen wir die C ++ - Sprache mit ihrer Tradition, sich auf den Optimierer zu verlassen, um redundante Konstruktionen im Vorlagencode zu entfernen, anstatt sie manuell auszuf√ºhren.  Es gibt jedoch Sprachen, die vom Transporter in C konvertiert werden, und der redundante Code in ihnen wird auch von C-Compilern optimiert. <br><br>  Selbst wenn Sie st√§ndig nach √úberl√§ufen suchen, ist es keineswegs eine Tatsache, dass die <i>direkten</i> Kosten f√ºr die √úbertragung ganzzahliger Variablen selbst auf Computern mit zus√§tzlichem Code minimal sind.  Die Mips-Architektur kann beispielsweise nur arithmetische Operationen in Registern fester Gr√∂√üe (32 Bit) ausf√ºhren.  Der Typ <i>short int</i> hat in der Regel eine Gr√∂√üe von 16 Bit und <i>char</i> - 8 Bit;  Wenn eine Variable eines dieser Typen im Register gespeichert ist, vergr√∂√üert sich ihre Gr√∂√üe. Um sie korrekt zu √ºbertragen, muss mindestens eine zus√§tzliche Operation ausgef√ºhrt und m√∂glicherweise ein zus√§tzliches Register verwendet werden (um die entsprechende Bitmaske aufzunehmen).  Ich muss zugeben, dass ich mich lange nicht mehr mit dem Code f√ºr Mips befasst habe, daher bin ich mir nicht sicher, welche Kosten diese Vorg√§nge genau verursachen, aber ich bin mir sicher, dass er nicht Null ist und dass bei anderen RISC-Architekturen dieselben Probleme auftreten k√∂nnen. <br><br>  <b>Verbietet ein Sprachstandard die Vermeidung von Variablenumbruch, wenn dies von der Architektur beabsichtigt ist?</b> <br><br>  Wenn Sie schauen, ist dieses Argument besonders schwach.  Sein Kern ist, dass der Standard der Implementierung (dem Compiler) angeblich erlaubt, "unbestimmtes Verhalten" nur in begrenztem Umfang zu interpretieren.  Im Text der Norm selbst - in dem Fragment, auf das sich die Bef√ºrworter der √úbertragung berufen - wird Folgendes gesagt (dies ist Teil der Definition des Begriffs ‚Äûunbestimmtes Verhalten‚Äú): <br><br>  HINWEIS: <i>Undefiniertes Verhalten kann darin bestehen, die Situation vollst√§ndig zu ignorieren, w√§hrend das Ergebnis unvorhersehbar ist.</i> <br><br>  Die Idee ist, dass die Worte ‚Äûdie Situation vollst√§ndig ignorieren‚Äú nicht darauf hindeuten, dass ein Ereignis, das zu undefiniertem Verhalten f√ºhrt - beispielsweise ein √úberlauf w√§hrend des Hinzuf√ºgens -, nicht auftreten kann, sondern dass der Compiler in diesem Fall weiterhin wie in arbeiten sollte als nie passiert, aber ber√ºcksichtigen Sie auch das Ergebnis, das sich herausstellt, wenn er dem Prozessor eine Anfrage zur Durchf√ºhrung einer solchen Operation sendet (mit anderen Worten, als ob der Quellcode auf einfache und naive Weise in Maschinencode √ºbersetzt worden w√§re). <br><br>  Zun√§chst ist zu beachten, dass dieser Text als ‚ÄûAnmerkung‚Äú angegeben wird und daher gem√§√ü der in der Einleitung zur Norm genannten ISO-Richtlinie nicht normativ ist (dh nichts vorschreiben kann): <br><br>  <i>In √úbereinstimmung mit Teil 3 der ISO / IEC-Richtlinien dienen dieses Vorwort, die Einf√ºhrung in den Text, die Anmerkungen, Fu√ünoten und Beispiele auch nur zu Informationszwecken.</i> <br><br>  Da diese Passage ‚Äûunbestimmtes Verhalten‚Äú eine Notiz ist, schreibt sie nichts vor.  Bitte beachten Sie, dass die aktuelle Definition von ‚Äûunbestimmtem Verhalten‚Äú lautet: <br><br>  <i>Verhalten aufgrund der Verwendung eines unertr√§glichen oder falschen Software-Designs oder falscher Daten, f√ºr die</i> <b><i>diese Internationale Norm keine Anforderungen stellt</i></b> <i>.</i> <br><br>  Ich habe die Hauptidee hervorgehoben: Es werden keine Anforderungen an unbestimmtes Verhalten gestellt.  Die Liste der ‚Äûm√∂glichen Arten von undefiniertem Verhalten‚Äú in der Notiz enth√§lt nur Beispiele und kann nicht die endg√ºltige Vorschrift sein.  Der Ausdruck ‚Äûstellt keine Anforderungen‚Äú kann nicht anders interpretiert werden. <br><br>  Einige, die dieses Argument entwickeln, argumentieren, dass das Sprachkomitee bei der Formulierung dieser W√∂rter unabh√§ngig vom Text <i>bedeutete,</i> dass das Verhalten als Ganzes so weit wie m√∂glich der Architektur der Hardware entsprechen sollte, auf der das Programm ausgef√ºhrt wird, was eine naive √úbersetzung impliziert in Maschinencode.  Dies mag zutreffen, obwohl ich keine Beweise (zum Beispiel historische Dokumente) f√ºr dieses Argument gesehen habe.  Selbst wenn dies so w√§re, ist es keine Tatsache, dass diese Aussage f√ºr die aktuelle Version des Textes gilt. <br><br>  <b>Letzte Gedanken</b> <br><br>  Die Argumente f√ºr die √úbertragung sind weitgehend unhaltbar.  Das vielleicht st√§rkste Argument ergibt sich, wenn wir sie kombinieren: Weniger erfahrene Programmierer (die die Feinheiten der C-Sprache und das unbestimmte Verhalten darin nicht kennen) z√§hlen manchmal auf die Portierung und verringern die Leistung nicht - obwohl letzteres nicht in allen F√§llen zutrifft und der erste Teil nicht schl√ºssig ist wenn Sie es separat betrachten. <br><br>  Pers√∂nlich w√ºrde ich es vorziehen, √úberl√§ufe zu blockieren (Einfangen) anstatt zu wickeln.  Das hei√üt, das Programm st√ºrzt ab und funktioniert nicht weiter - mit unsicherem Verhalten oder m√∂glicherweise falschen Ergebnissen, da in beiden F√§llen eine Sicherheitsanf√§lligkeit auftritt.  Eine solche L√∂sung wird nat√ºrlich die Leistung auf den meisten (?) Architekturen, insbesondere auf x86, geringf√ºgig verringern, andererseits werden √úberlauffehler sofort erkannt und sie k√∂nnen auf diesem Weg keine falschen Ergebnisse nutzen oder falsche Ergebnisse erzielen Programme.  Dar√ºber hinaus k√∂nnten Compiler mit diesem Ansatz theoretisch redundante √úberlaufpr√ºfungen sicher entfernen, da dies <i>sicherlich</i> nicht passieren wird, obwohl, wie ich sehe, weder Clang noch GCC diese Gelegenheit nutzen. <br><br>  Gl√ºcklicherweise sind sowohl Unterbrechung als auch Portierung in dem Compiler implementiert, den ich am h√§ufigsten verwende, n√§mlich GCC.  Um zwischen den Modi zu wechseln, werden die <i>Befehlszeilenargumente -ftrapv</i> und <i>-fwrapv</i> verwendet. <br><br>  Nat√ºrlich gibt es viele Aktionen, die zu undefiniertem Verhalten f√ºhren - ein ganzzahliger √úberlauf ist nur eine davon.  Ich halte es √ºberhaupt nicht f√ºr sinnvoll, all diese F√§lle als unbestimmtes Verhalten zu interpretieren, und ich bin sicher, dass es viele spezifische Situationen gibt, in denen die Semantik durch die Sprache bestimmt oder zumindest dem Ermessen der Implementierungen √ºberlassen werden sollte.  Und ich habe Angst vor zu freien Interpretationen dieses Konzepts durch Compilerhersteller: Wenn das Verhalten des Compilers nicht den intuitiven Vorstellungen der Entwickler entspricht, insbesondere derjenigen, die den Text des Standards pers√∂nlich lesen, kann dies zu echten Fehlern f√ºhren.  Wenn der Leistungsgewinn in diesem Fall vernachl√§ssigbar ist, ist es besser, solche Interpretationen aufzugeben.  In einem der folgenden Beitr√§ge werde ich mich wahrscheinlich mit einigen dieser Probleme befassen. <br><br>  Nachtrag (vom 24. August 2018) <br><br>  Mir wurde klar, dass vieles davon besser geschrieben werden k√∂nnte.  Im Folgenden fasse ich meine Worte kurz zusammen, erkl√§re sie und f√ºge ein paar kleinere Bemerkungen hinzu: <br><br><ul><li>  Ich habe nicht argumentiert, dass unbestimmtes Verhalten dem √úberlauf vorzuziehen ist - vielmehr ist die √úbertragung <i>in der Praxis</i> <i>nicht viel besser als</i> unbestimmtes Verhalten.  Insbesondere k√∂nnen Sicherheitsprobleme im ersten und im zweiten Fall auftreten - und ich wette, dass viele der Schwachstellen, die durch nicht rechtzeitig abgefangene √úberl√§ufe verursacht wurden (mit Ausnahme derjenigen, f√ºr die der Compiler f√ºr das L√∂schen fehlerhafter √úberpr√ºfungen verantwortlich ist), tats√§chlich entstanden sind - aufgrund der √úbertragung des Ergebnisses, jedoch nicht aufgrund eines undefinierten Verhaltens im Zusammenhang mit dem √úberlauf. </li><li>  Der einzige wirkliche Vorteil der √úbertragung besteht darin, dass √úberlaufpr√ºfungen nicht gel√∂scht werden.  Obwohl Sie auf diese Weise den Code vor einigen Angriffsszenarien sch√ºtzen k√∂nnen, ist es wahrscheinlich, dass einige der √úberl√§ufe √ºberhaupt nicht √ºberpr√ºft werden (d. H. Der Programmierer vergisst, eine solche √úberpr√ºfung hinzuzuf√ºgen) und unbemerkt bleiben. </li><li>  Wenn das Sicherheitsproblem nicht so wichtig ist und die hohe Geschwindigkeit des Programms in den Vordergrund tritt, f√ºhrt undefiniertes Verhalten zumindest in einigen F√§llen zu einer rentableren Optimierung und einer h√∂heren Produktivit√§tssteigerung.  Wenn die Sicherheit an erster Stelle steht, ist die Portierung mit Sicherheitsl√ºcken behaftet. </li><li>  Wenn Sie also zwischen Unterbrechung, √úbertragung und undefiniertem Verhalten w√§hlen, gibt es nur sehr wenige Aufgaben, bei denen die √úbertragung hilfreich sein kann. </li><li>  Was die √úberpr√ºfung des aufgetretenen √úberlaufs betrifft, glaube ich, dass das Verlassen sch√§dlich ist, da dadurch der falsche Eindruck entsteht, dass sie funktionieren und immer funktionieren werden.  Durch das Unterbrechen von √úberl√§ufen wird dieses Problem vermieden.  angemessene Warnungen - mildern Sie es. </li><li>  Ich denke, dass jeder Entwickler, der sicherheitskritischen Code schreibt, im Idealfall die Semantik der Sprache, in der er schreibt, gut beherrschen und sich ihrer Fallstricke bewusst sein sollte.  F√ºr C bedeutet dies, dass Sie die Semantik des √úberlaufs und die Feinheiten des undefinierten Verhaltens kennen m√ºssen.  Es ist traurig, dass einige Programmierer nicht auf dieses Niveau angewachsen sind. </li><li>  Ich bin auf die Behauptung gesto√üen, dass "die meisten C-Programmierer Migration als Standardverhalten erwarten", aber ich kenne die Beweise daf√ºr nicht.  (In dem Artikel habe ich "einige Programmierer" geschrieben, weil ich einige Beispiele aus dem wirklichen Leben kenne, und im Allgemeinen bezweifle ich, dass irgendjemand damit streiten wird). </li><li>  Es gibt zwei verschiedene Probleme: Was der C-Sprachstandard erfordert und welche Compiler implementieren sollten.  Mir gef√§llt (allgemein), wie der Standard undefiniertes √úberlaufverhalten definiert.  In diesem Beitrag spreche ich dar√ºber, was Compiler tun sollten. </li><li>  Wenn der √úberlauf unterbrochen wird, muss nicht jeder Vorgang √ºberpr√ºft werden.  Im Idealfall verh√§lt sich das Programm mit diesem Ansatz entweder konsistent in Bezug auf mathematische Regeln oder funktioniert nicht mehr.  In diesem Fall wird das Vorhandensein eines ‚Äûvor√ºbergehenden √úberlaufs‚Äú m√∂glich, der nicht zum Auftreten eines falschen Ergebnisses f√ºhrt.  Dann k√∂nnen sowohl der Ausdruck <i>a + b - b</i> als auch der Ausdruck <i>(a * b) / b</i> auf a optimiert werden (ersterer ist auch w√§hrend der √úbertragung m√∂glich, letzterer ist jedoch nicht mehr vorhanden). </li></ul><br>  <b>Hinweis</b>  Die √úbersetzung des Artikels wird mit Genehmigung des Autors im Blog ver√∂ffentlicht.  Originaltext: Davin McCall " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wrap on Integer Overflow ist keine gute Idee</a> ". <br><br>  Zus√§tzliche verwandte Links vom PVS-Studio-Team: <br><br><ol><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Undefiniertes Verhalten ist n√§her als Sie denken</a> . </li><li>  Will Dietz, Peng Li, John Regehr und Vikram Adve.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum Integer-√úberlauf in C / C ++</a> . </li><li>  V1026.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Variable wird in der Schleife inkrementiert.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bei einem vorzeichenbehafteten Ganzzahl√ºberlauf tritt ein undefiniertes Verhalten auf</a> . </li><li>  Stapel√ºberlauf  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist der vorzeichenbehaftete Ganzzahl√ºberlauf in C ++ immer noch undefiniertes Verhalten?</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427683/">https://habr.com/ru/post/de427683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427671/index.html">Sberbank und Yandex haben die Beru-Handelsplattform, die russische Version von Amazon, offiziell gestartet</a></li>
<li><a href="../de427673/index.html">Maschinelles Lernen @ booking.com</a></li>
<li><a href="../de427675/index.html">Papiere bitte. Wie ein neuronales Netzwerk uns hilft, Kunden zu verifizieren und Betr√ºger zu fangen</a></li>
<li><a href="../de427679/index.html">Wenn die Entscheidung getroffen wird, dauert es anderthalb Jahre, bis das Limit f√ºr zollfreie Eink√§ufe auf Null gesetzt ist</a></li>
<li><a href="../de427681/index.html">Ziehen und wischen Sie in RecyclerView. Teil 1: ItemTouchHelper</a></li>
<li><a href="../de427685/index.html">FSB gegen Satelliten-Internet von ausl√§ndischen Betreibern</a></li>
<li><a href="../de427687/index.html">√úberweisung f√ºr Gesch√§ftsanwendungen DentalTap-Architektur</a></li>
<li><a href="../de427689/index.html">Bier direkt aus der Wolke</a></li>
<li><a href="../de427691/index.html">Erstellen eines einfachen Chat-Bots in VK unter Python 3</a></li>
<li><a href="../de427693/index.html">Das Buch ‚ÄûSchwerkraft. Die letzte Versuchung von Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>