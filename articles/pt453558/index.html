<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚀 🧒🏼 👩‍⚖️ Introdução ao Machine Learning 👩🏾‍🤝‍👩🏽 📧 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O curso completo em russo pode ser encontrado neste link . 
 O curso de inglês original está disponível neste link . 



 Novas palestras são agendada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução ao Machine Learning</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  O curso completo em russo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br>  O curso de inglês original está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Novas palestras são agendadas a cada 2-3 dias.</i> <br><br><h2>  Entrevista com Sebastian Trun, CEO da Udacity </h2><br>  "Olá novamente, eu sou Paige e você é meu convidado hoje, Sebastian." <br>  Oi, eu sou Sebastian! <br>  - ... um homem que tem uma carreira incrível, que conseguiu fazer muitas coisas incríveis!  Você é co-fundador da Udacity, fundou o Google X, é professor em Stanford.  Você vem pesquisando e aprendendo profundamente por toda a sua carreira.  O que lhe trouxe mais satisfação e em quais áreas você recebeu mais recompensas pelo trabalho realizado? <br>  - Francamente, eu realmente amo estar no Vale do Silício!  Eu gosto de estar perto de pessoas que são muito mais inteligentes do que eu e sempre considerei a tecnologia como uma ferramenta que muda as regras do jogo de várias maneiras - da educação à logística, saúde, etc.  Tudo isso muda tão rapidamente, e há um desejo incrível de ser um participante dessas mudanças, de observá-las.  Você olha para os arredores e entende que a maior parte do que vê ao seu redor não funciona como deveria - você sempre pode inventar algo novo! <br>  - Bem, essa é uma visão muito otimista da tecnologia!  Qual foi o maior eureka ao longo de sua carreira? <br>  - Senhor, havia tantos!  Lembro-me de um dia em que Larry Page me ligou e sugeriu a criação de carros de piloto automático que pudessem dirigir por todas as ruas da Califórnia.  Naquela época, eu era considerado um especialista, era classificado entre eles e eu era a mesma pessoa que disse "não, isso não pode ser feito".  Depois disso, Larry me convenceu de que, em princípio, é possível fazer isso, você só precisa começar e tentar.  E nós conseguimos!  Foi o momento em que percebi que mesmo os especialistas estão errados e dizendo "não" somos 100% pessimistas.  Acho que deveríamos estar mais abertos ao novo. <br>  - Ou, por exemplo, se Larry Page ligar e disser: "Ei, faça algo legal como o Google X" e você terá algo muito legal! <br>  - Sim, com certeza, não precisa reclamar!  Quero dizer, tudo isso é um processo que passa por muita discussão no caminho da implementação.  Tenho muita sorte de trabalhar e tenho orgulho disso, no Google X e em outros projetos. <br>  - Incrível!  Portanto, este curso é sobre como trabalhar com o TensorFlow.  Você tem experiência com o TensorFlow ou talvez esteja familiarizado (ouvido) com ele? <br>  Sim!  Eu literalmente amo o TensorFlow, é claro!  No meu próprio laboratório, nós o usamos com frequência e muito, um dos trabalhos mais significativos baseados no TensorFlow foi lançado há cerca de dois anos.  Aprendemos que o iPhone e o Android podem ser mais eficazes na detecção de câncer de pele do que os melhores dermatologistas do mundo.  Publicamos nossa pesquisa na Nature e isso criou uma espécie de comoção na medicina. <br>  - Isso parece incrível!  Então você conhece e ama o TensorFlow, o que é ótimo em si!  Você já trabalhou com o TensorFlow 2.0? <br>  - Não, infelizmente ainda não tive tempo. <br>  - Ele vai ser incrível!  Todos os alunos deste curso trabalharão com esta versão. <br>  - Eu os invejo!  Definitivamente vou tentar! <br>  Ótimo!  Em nosso curso, há muitos estudantes que em sua vida nunca se envolveram em aprendizado de máquina, a partir da palavra "completamente".  Para eles, o campo pode ser novo, talvez para alguém que esteja programando seja novo.  Que conselho você daria para eles? <br>  - Gostaria que eles permanecessem abertos - a novas idéias, técnicas, soluções, posições.  O aprendizado de máquina é realmente mais fácil que a programação.  No processo de programação, é necessário levar em consideração cada caso nos dados de origem, adaptar a lógica e as regras do programa.  No momento, usando o TensorFlow e o aprendizado de máquina, você basicamente treina o computador usando exemplos, permitindo que o computador encontre as regras. <br>  - Isso é incrivelmente interessante!  Mal posso esperar para contar aos alunos deste curso um pouco mais sobre aprendizado de máquina!  Sebastian, obrigado por reservar um tempo para vir até nós hoje! <br>  Obrigado!  Fique em contato! <br><br><h2>  O que é aprendizado de máquina? </h2><br>  Então, vamos começar com a seguinte tarefa - dados de entrada e saída. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Quando você tiver o valor 0 como valor de entrada, 32 como valor de saída.Quando você tiver 8 como valor de entrada, 46,4 como valor de saída.  Quando você tem 15 como valor de entrada, 59 como valor de saída e assim por diante. <br><br>  Dê uma olhada nesses valores e deixe-me fazer uma pergunta.  Você pode determinar qual será a saída se recebermos 38 na entrada? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Se você respondeu 100,4, estava certo! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Então, como poderíamos resolver esse problema?  Se você observar atentamente os valores, poderá ver que eles estão relacionados pela expressão: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Onde C - graus Celsius (valores de entrada), F - Fahrenheit (valores de saída). <br><br>  O que seu cérebro acabou de fazer - comparou valores de entrada e valores de saída e encontrou um modelo comum (conexão, dependência) entre eles - é isso que o aprendizado de máquina faz. <br><br>  Com base nos valores de entrada e saída, os algoritmos de aprendizado de máquina encontrarão um algoritmo adequado para converter valores de entrada em valores de saída.  Isso pode ser representado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Vejamos um exemplo.  Imagine que queremos desenvolver um programa que converta graus Celsius em graus Fahrenheit usando a fórmula <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  A solução, ao abordar do ponto de vista do desenvolvimento tradicional de software, pode ser implementada em qualquer linguagem de programação usando a função: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Então o que nós temos?  A função pega um valor de entrada C, calcula o valor de saída de F usando um algoritmo explícito e, em seguida, retorna o valor calculado. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Por outro lado, na abordagem de aprendizado de máquina, temos apenas valores de entrada e saída, mas não o próprio algoritmo: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  A abordagem de aprendizado de máquina baseia-se no uso de redes neurais para encontrar a relação entre os valores de entrada e saída. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Você pode pensar em redes neurais como uma pilha de camadas, cada uma das quais consiste em matemática (fórmulas) e variáveis ​​internas conhecidas anteriormente.  O valor de entrada entra na rede neural e passa por uma pilha de camadas de neurônios.  Ao passar pelas camadas, o valor de entrada é convertido de acordo com a matemática (fórmulas fornecidas) e os valores das variáveis ​​internas das camadas, produzindo um valor de saída. <br><br>  Para que a rede neural seja capaz de aprender e determinar a relação correta entre os valores de entrada e saída, precisamos treiná-la - treiná-la. <br><br>  Nós treinamos a rede neural através de tentativas repetidas de combinar valores de entrada com valores de saída. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  No processo de treinamento, o “ajuste” (seleção) dos valores das variáveis ​​internas nas camadas da rede neural ocorre até que a rede aprenda a gerar os valores de saída correspondentes aos valores de entrada correspondentes. <br><br>  Como veremos mais adiante, para treinar uma rede neural e permitir que ela selecione os valores mais adequados de variáveis ​​internas, milhares ou dezenas de milhares de iterações (treinamentos) são executadas. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Como uma versão simplificada do entendimento do aprendizado de máquina, você pode imaginar algoritmos de aprendizado de máquina como funções que selecionam os valores de variáveis ​​internas, para que os valores de entrada corretos correspondam aos valores de saída corretos. <br><br>  Existem muitos tipos de arquiteturas de redes neurais.  No entanto, independentemente da arquitetura escolhida, a matemática interna (quais cálculos são executados e em que ordem) permanecerá inalterada durante o treinamento.  Em vez de mudar a matemática, as variáveis ​​internas (pesos e compensações) mudam durante o treinamento. <br><br>  Por exemplo, na tarefa de converter de graus Celsius em Fahrenheit, o modelo começa multiplicando o valor de entrada por um determinado número (peso) e adicionando outro valor (deslocamento).  O treinamento do modelo consiste em encontrar valores adequados para essas variáveis, sem alterar as operações realizadas de multiplicação e adição. <br><br>  Mas uma coisa legal para se pensar!  Se você resolveu o problema de converter graus Celsius em Fahrenheit, indicado no vídeo e no texto abaixo, provavelmente o resolveu porque tinha alguma experiência ou conhecimento anterior sobre como realizar esse tipo de conversão de graus Celsius em Fahrenheit.  Por exemplo, você pode saber apenas que 0 graus Celsius corresponde a 32 graus Fahrenheit.  Por outro lado, os sistemas baseados no aprendizado de máquina não têm conhecimento prévio de suporte para resolver o problema.  Eles aprendem a resolver esses problemas, não com base no conhecimento anterior e em sua completa ausência. <br><br>  Chega de conversa - vá para a parte prática da palestra! <br><br><h2>  CoLab: converta graus Celsius em graus Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A versão russa do código-fonte do CoLab</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão em inglês do código-fonte do CoLab</a> . <br><br><h2>  Noções básicas: aprendendo o primeiro modelo </h2><br>  Bem-vindo ao CoLab, onde treinaremos nosso primeiro modelo de aprendizado de máquina! <br><br>  Procuraremos manter a simplicidade do material apresentado e apresentar apenas os conceitos básicos necessários para o trabalho.  Os CoLabs subsequentes conterão técnicas mais avançadas. <br><br>  A tarefa que resolveremos é a conversão de graus Celsius em graus Fahrenheit.  A fórmula de conversão é a seguinte: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>z</mi><mi>e</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="19.962ex" height="2.419ex" viewBox="0 -780.1 8594.7 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-76" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-65" x="3053" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-7A" x="3520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-65" x="3988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-73" x="4455" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-31" x="4924" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-2C" x="5425" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-38" x="5870" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-2B" x="6592" y="0"></use><g transform="translate(7593,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>z</mi><mi>e</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ vezes 1,8 + 32 </script></p><br><br>  Obviamente, seria mais fácil escrever uma função de conversão em Python ou em qualquer outra linguagem de programação que realizasse cálculos diretos, mas, neste caso, não seria aprendizado de máquina :) <br><br>  Em vez disso, alimentamos na entrada TensorFlow os graus de entrada em graus Celsius que temos (0, 8, 15, 22, 38) e seus graus correspondentes em Fahrenheit (32, 46, 59, 72, 100).  Em seguida, treinaremos o modelo de forma que corresponda aproximadamente à fórmula acima. <br><br><h3>  Dependências de importação </h3><br>  A primeira coisa que importamos é o <code>TensorFlow</code> .  Aqui e a seguir chamamos abreviadamente <code>tf</code> .  Também configuramos o nível de registro - apenas erros. <br><br>  Em seguida, importe o <code>NumPy</code> como <code>np</code> .  <code>Numpy</code> nos ajuda a apresentar nossos dados como listagens de alto desempenho. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Preparação de dados de treinamento </h3><br>  Como vimos anteriormente, a técnica de aprendizado de máquina com o professor é baseada na busca de um algoritmo para converter dados de entrada em saída.  Como a tarefa deste CoLab é criar um modelo que possa produzir o resultado da conversão de graus Celsius em graus Fahrenheit, crie duas listas - <code>celsius_q</code> e <code>fahrenheit_a</code> , que usamos ao treinar nosso modelo. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Alguma terminologia de aprendizado de máquina: <br><br><ul><li>  <b>Propriedade</b> é o valor de entrada do nosso modelo.  Nesse caso, o valor unitário é graus Celsius. </li><li>  <b>Os rótulos</b> são os valores de saída que nosso modelo prevê.  Nesse caso, o valor unitário é graus Fahrenheit. </li><li>  <b>Um exemplo</b> é um par de valores de entrada e saída usados ​​para treinamento.  Nesse caso, este é um par de valores de <code>celsius_q</code> e <code>fahrenheit_a</code> sob um determinado índice, por exemplo, (22,72). </li></ul><br><h2>  Crie um modelo </h2><br>  Em seguida, criamos um modelo.  Usaremos o modelo mais simplificado - o modelo de uma rede totalmente conectada (rede <code>Dense</code> ).  Como a tarefa é bastante trivial, a rede também consistirá em uma única camada com um único neurônio. <br><br><h4>  Construindo uma rede </h4><br>  <code>tf.keras.layers.Dense</code> a camada <code>l0</code> ( <b>l</b> ayer e zero) e a criaremos inicializando <code>tf.keras.layers.Dense</code> com os seguintes parâmetros: <br><br><ul><li>  <code>input_shape=[1]</code> - este parâmetro determina a dimensão do parâmetro de entrada - um único valor.  Matriz 1 × 1 com um único valor.  Como essa é a primeira (e única) camada, a dimensão dos dados de entrada corresponde à dimensão de todo o modelo.  O único valor é um valor de ponto flutuante representando graus Celsius. </li><li>  <code>units=1</code> - este parâmetro determina o número de neurônios na camada.  O número de neurônios determina quantas variáveis ​​da camada interna serão usadas no treinamento para encontrar uma solução para o problema.  Como essa é a última camada, sua dimensão é igual à dimensão do resultado - o valor de saída do modelo - um único número de ponto flutuante representando graus Fahrenheit.  (Em uma rede multicamada, o tamanho e a forma da camada <code>input_shape</code> devem corresponder ao tamanho e forma da próxima camada). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Converter camadas em modelo </h4><br>  Uma vez definidas as camadas, elas precisam ser convertidas em um modelo.  <code>Sequential</code> modelo <code>Sequential</code> toma como argumentos a lista de camadas na ordem em que devem ser aplicadas - do valor de entrada ao valor de saída. <br><br>  Nosso modelo possui apenas uma camada - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Nota</b> <br>  Muitas vezes, você encontrará a definição de camadas diretamente na função de modelo, em vez de sua descrição preliminar e uso subseqüente: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Compilamos um modelo com uma função de perda e otimização </h3><br>  Antes do treinamento, o modelo deve ser compilado (montado).  Ao compilar para o treinamento, você precisa: <br><br><ul><li>  <b>função de perda</b> - uma maneira de medir a que distância o valor previsto está do valor de saída desejado (uma diferença mensurável é chamada de "perda"). </li><li>  <b>função de otimização</b> - uma maneira de ajustar variáveis ​​internas para reduzir perdas. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  A função de perda e a função de otimização são usadas durante o treinamento do modelo ( <code>model.fit(...)</code> mencionado abaixo) para executar cálculos iniciais em cada ponto e otimizar os valores. <br><br>  A ação de calcular as perdas atuais e a melhoria subsequente desses valores no modelo é exatamente o que é o treinamento (uma iteração). <br><br>  Durante o treinamento, a função de otimização é usada para calcular ajustes nos valores das variáveis ​​internas.  O objetivo é ajustar os valores das variáveis ​​internas de tal maneira no modelo (e isso, de fato, é uma função matemática) para que elas reflitam o mais próximo possível a expressão existente para converter graus Celsius em graus Fahrenheit. <br><br>  O TensorFlow usa análise numérica para executar esses tipos de operações de otimização, e toda essa complexidade está oculta aos nossos olhos, portanto, não entraremos em detalhes neste curso. <br><br>  O que é útil saber sobre estas opções: <br><br>  A função de perda (erro padrão) e a função de otimização (Adam) usadas neste exemplo são padrão para modelos tão simples, mas muitos outros estão disponíveis além deles.  Nesta fase, não nos importamos com o funcionamento dessas funções. <br><br>  Você deve prestar atenção à função de otimização e o parâmetro é o coeficiente da <code>learning rate</code> , que em nosso exemplo é <code>0.1</code> .  Este é o tamanho da etapa usada ao ajustar os valores internos das variáveis.  Se o valor for muito pequeno, serão necessárias muitas iterações de treinamento para treinar o modelo.  Demais - a precisão cai.  Encontrar um bom valor para o coeficiente da taxa de aprendizado requer algumas tentativas e erros, geralmente varia de <code>0.01</code> (por padrão) a <code>0.1</code> . <br><br><h4>  Treinamos o modelo </h4><br>  O treinamento do modelo é realizado pelo método de <code>fit</code> . <br><br>  Durante o treinamento, o modelo recebe graus Celsius na entrada, realiza transformações usando os valores de variáveis ​​internas (chamadas de "pesos") e retorna valores que devem corresponder a graus Fahrenheit.  Como os valores iniciais dos pesos são definidos arbitrariamente, os valores resultantes estarão longe dos valores corretos.  A diferença entre o resultado desejado e o real é calculada usando a função de perda, e a função de otimização determina como os pesos devem ser ajustados. <br><br>  Esse ciclo de cálculos, comparações e ajustes é controlado dentro do método de <code>fit</code> .  O primeiro argumento é o valor de entrada, o segundo argumento é o valor de saída desejado.  O argumento das <code>epochs</code> determina quantas vezes esse ciclo de treinamento deve ser concluído.  O argumento <code>verbose</code> controla o nível de log. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  Nos vídeos a seguir, abordaremos os detalhes de como tudo isso funciona e como exatamente as camadas totalmente conectadas (camadas <code>Dense</code> ) "sob o capô". <br><br><h4>  Exibir estatísticas de treinamento </h4><br>  O método de <code>fit</code> retorna um objeto que contém informações sobre alterações nas perdas a cada iteração subsequente.  Podemos usar esse objeto para criar um cronograma de perdas apropriado.  Alta perda significa que os graus Fahrenheit previstos pelo modelo estão longe dos valores reais na matriz <code>fahrenheit_a</code> . <br><br>  Para visualização, usaremos o <code>Matplotlib</code> .  Como você pode ver, nosso modelo melhora muito rapidamente desde o início e, em seguida, chega a uma melhoria estável e lenta até que os resultados se tornem "próximos" - perfeitos no final do treinamento. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Usamos o modelo para previsões. </h4><br>  Agora, temos um modelo que foi treinado nos valores de entrada <code>celsius_q</code> e nos valores de saída <code>fahrenheit_a</code> para determinar o relacionamento entre eles.  Podemos usar o método de previsão para calcular os graus Fahrenheit pelos quais anteriormente não conhecíamos os graus Celsius correspondentes. <br><br>  Por exemplo, quanto é 100,0 graus Celsius Fahrenheit?  Tente adivinhar antes de executar o código abaixo. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Conclusão: <br><br> <code>[[211.29639]] <br></code> <br><br>  A resposta correta é 100 × 1,8 + 32 = 212, então nosso modelo se saiu muito bem! <br><br>  <b>Revisão</b> <br><br><ul><li>  Criamos um modelo usando a camada <code>Dense</code> . </li><li>  Nós a treinamos com 3.500 exemplos (7 pares de valores, 500 iterações de treinamento) </li></ul><br>  Nosso modelo ajustou os valores das variáveis ​​internas (pesos) na camada <code>Dense</code> forma a retornar os valores corretos dos graus Fahrenheit a um valor de entrada arbitrário de graus Celsius. <br><br><h3>  Olhamos para os pesos </h3><br>  Vamos exibir os valores das variáveis ​​internas da camada <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Conclusão: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  O valor da primeira variável é próximo a ~ 1,8 e o segundo a ~ 32.  Esses valores (1,8 e 32) são valores diretos na fórmula para converter graus Celsius em graus Fahrenheit. <br><br>  Isso é realmente muito próximo dos valores reais na fórmula!  Consideraremos esse ponto com mais detalhes nos vídeos a seguir, onde mostraremos como a camada <code>Dense</code> funciona, mas por enquanto você só precisa saber que um neurônio com uma única entrada e saída contém matemática simples - <code>y = mx + b</code> (como uma equação direta), que nada mais é do que nossa fórmula para converter graus Celsius em graus Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Como as representações são iguais, os valores das variáveis ​​internas do modelo devem convergir para os apresentados na fórmula real, o que aconteceu no final. <br><br>  Com a presença de neurônios adicionais, valores adicionais de entrada e valores de saída, a fórmula se torna um pouco mais complicada, mas a essência permanece a mesma. <br><br><h4>  Um pouco de experimentação </h4><br>  Por diversão!  O que acontece se criarmos mais camadas <code>Dense</code> com mais neurônios, que por sua vez conterão mais variáveis ​​internas? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Conclusão: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Como você deve ter notado, o modelo atual também é capaz de prever muito bem os graus correspondentes de Fahrenheit.  No entanto, se observarmos os valores das variáveis ​​internas (pesos) dos neurônios por camadas, não veremos valores semelhantes a 1,8 e 32.  A complexidade adicional do modelo oculta a forma "simples" de converter graus Celsius em graus Fahrenheit. <br><br>  Fique conectado e, na próxima parte, veremos como as camadas densas funcionam "sob o capô". <br><br><h3>  Breve resumo </h3><br>  Parabéns!  Você acabou de treinar seu primeiro modelo.  Na prática, vimos como, por valores de entrada e saída, o modelo aprendeu a multiplicar o valor de entrada por 1,8 e adicionar 32 a ele para obter o resultado correto. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Isso foi realmente impressionante, considerando quantas linhas de código precisamos escrever: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  O exemplo acima é um plano geral para todos os programas de aprendizado de máquina.  Você usará construções semelhantes para criar e treinar redes neurais e resolver problemas subseqüentes. <br><br><h3>  Processo de treinamento </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de treinamento (ocorrendo no método </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) consiste em uma sequência muito simples de ações, cujo resultado deve ser o valor das variáveis ​​internas, fornecendo os resultados o mais próximo possível do original. </font><font style="vertical-align: inherit;">O processo de otimização pelo qual tais resultados são alcançados, chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descida gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , utiliza análise numérica para encontrar os valores mais adequados para as variáveis ​​internas do modelo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para participar do aprendizado de máquina, você, em princípio, não precisa entender esses detalhes. Mas para aqueles que ainda estão interessados ​​em aprender mais: a descida do gradiente por meio de iterações altera um pouco os valores dos parâmetros, “puxando-os” na direção certa, até que os melhores resultados sejam obtidos. Nesse caso, “melhores resultados” (melhores valores) significam que qualquer alteração subsequente no parâmetro apenas piorará o resultado do modelo. Uma função que mede o quão bom ou ruim é um modelo em cada iteração é chamada de “função de perda”, e o objetivo de cada “puxar” (ajuste de valores internos) é reduzir o valor da função de perda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de treinamento começa com o bloco "distribuição direta", no qual os parâmetros de entrada vão para a entrada da rede neural, seguem os neurônios ocultos e depois vão para o fim de semana. O modelo então aplica transformações internas nos valores de entrada e variáveis ​​internas para prever a resposta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nosso exemplo, o valor de entrada é a temperatura em graus Celsius e o modelo previu o valor correspondente em graus Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim que o valor é previsto, é calculada a diferença entre o valor previsto e o correto. A diferença é chamada de "perda" e é uma forma de medir o quão bem o modelo funcionou. O valor da perda é calculado pela função de perda, que determinamos por um dos argumentos ao chamar o método </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após o cálculo do valor da perda, as variáveis ​​internas (pesos e deslocamentos) de todas as camadas da rede neural são ajustadas para minimizar o valor da perda, a fim de aproximar o valor da saída ao valor de referência inicial correto. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse processo de otimização é chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descida de gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um algoritmo de otimização específico é usado para calcular um novo valor para cada variável interna quando o método é chamado </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No exemplo acima, usamos um algoritmo de otimização </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não é necessário entender os princípios do processo de treinamento para este curso; no entanto, se você tiver curiosidade suficiente, poderá encontrar mais informações no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Curso de falha</font></a><font style="vertical-align: inherit;"> do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(A tradução e a parte prática de todo o curso estão estabelecidas nos planos de publicação do autor). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, você já deve estar familiarizado com os seguintes termos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriedade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valor de entrada do nosso modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pares de entrada + saída;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valores de saída do modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camadas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma coleção de nós unidos em uma rede neural;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : representação da sua rede neural;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denso e totalmente conectado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cada nó em uma camada é conectado a cada nó da camada anterior.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos e compensações</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : modelar variáveis ​​internas;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a diferença entre o valor de saída desejado e o valor de saída real do modelo;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  «»       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propagação de retorno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : calculando os valores das variáveis ​​internas de acordo com um algoritmo de otimização, começando na camada de saída e em direção à camada de entrada através de todas as camadas intermediárias.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Camadas de sentido </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte anterior, criamos um modelo que converte graus Celsius em graus Fahrenheit usando uma rede neural simples para encontrar a relação entre graus Celsius e graus Fahrenheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa rede consiste em uma única camada totalmente conectada. </font><font style="vertical-align: inherit;">Mas o que é uma camada totalmente conectada? </font><font style="vertical-align: inherit;">Para descobrir isso, vamos criar uma rede neural mais complexa com 3 parâmetros de entrada, uma camada oculta com dois neurônios e uma camada de saída com um único neurônio.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que uma rede neural pode ser imaginada como um conjunto de camadas, cada uma das quais consiste em nós chamados neurônios. Os neurônios de cada nível podem ser conectados aos neurônios de cada camada subseqüente. O tipo de camada em que cada neurônio de uma camada é conectada um ao outro neurônio da camada seguinte é chamado de camada densa (camada </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">totalmente conectada (totalmente conectada) ou densa (camada </font><font style="vertical-align: inherit;">). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, quando usamos camadas totalmente conectadas </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informamos que os neurônios dessa camada devem estar conectados a todos os neurônios da camada anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar a rede neural acima, as seguintes expressões são suficientes para nós:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, descobrimos o que são os neurônios e como eles estão relacionados. Mas como as camadas totalmente conectadas realmente funcionam? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para entender o que realmente está acontecendo lá e o que eles estão fazendo, precisamos olhar "por baixo do capô" e desmontar a matemática interna dos neurônios. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que nosso modelo receba três parâmetros - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- os neurônios de nossa rede. Lembra que dissemos que um neurônio tem variáveis ​​internas? Assim, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> são o neurónio variáveis mais interna, também conhecido como o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peso</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deslocamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. São os valores dessas variáveis ​​que são ajustados no processo de aprendizado para obter os resultados mais precisos da comparação dos valores de entrada com a saída. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que você definitivamente deve ter em mente é que a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matemática interna do neurônio permanece inalterada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em outras palavras, durante o processo de treinamento, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pesos e deslocamentos </font><font style="vertical-align: inherit;">mudam </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você começa a aprender o aprendizado de máquina, pode parecer estranho - o fato de realmente funcionar, mas é assim que o aprendizado de máquina funciona! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao nosso exemplo de conversão de graus Celsius em graus Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com um único neurônio, temos apenas um peso e um deslocamento. Você sabe o que? É exatamente assim que a fórmula para converter graus Celsius em graus Fahrenheit se parece. Se substituirmos o </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em vez de </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obteremos o modelo final de transformação! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se retornarmos aos resultados do nosso modelo a partir da parte prática, prestaremos atenção ao fato de que os indicadores de peso e deslocamento foram "calibrados" de maneira a corresponder aproximadamente aos valores da fórmula.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos propositalmente apenas um exemplo tão prático para mostrar claramente a comparação exata entre pesos e compensações. Colocando o aprendizado de máquina em prática, nunca podemos comparar os valores das variáveis ​​com o algoritmo de destino dessa maneira, como no exemplo acima. Como podemos fazer isso? De jeito nenhum, porque nós nem conhecemos o algoritmo de destino! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo os problemas do aprendizado de máquina, testamos várias arquiteturas de redes neurais com um número diferente de neurônios - por tentativa e erro, encontramos as arquiteturas e modelos mais precisos e esperamos que eles resolvam a tarefa no processo de aprendizado. Na próxima parte prática, poderemos estudar exemplos específicos dessa abordagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fique em contato, porque agora a diversão começa!</font></font><br><br><h3>  Sumário </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta lição, aprendemos abordagens básicas no aprendizado de máquina e aprendemos como as camadas ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-layers) </font><font style="vertical-align: inherit;">totalmente conectadas </font><font style="vertical-align: inherit;">funcionam. </font><font style="vertical-align: inherit;">Você treinou seu primeiro modelo para converter graus Celsius em graus Fahrenheit. </font><font style="vertical-align: inherit;">Você também aprendeu os termos básicos usados ​​no aprendizado de máquina, como propriedades, exemplos, rótulos. </font><font style="vertical-align: inherit;">Entre outras coisas, você escreveu as principais linhas de código em Python, que são a espinha dorsal de qualquer algoritmo de aprendizado de máquina. </font><font style="vertical-align: inherit;">Você viu que em algumas linhas de código você pode criar, treinar e solicitar uma previsão de uma rede neural usando </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... e call to action padrão - inscreva-se, coloque um plus e compartilhe :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versão em vídeo do artigo</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegrama: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453558/">https://habr.com/ru/post/pt453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453542/index.html">O robô de quatro patas conseguiu rebocar um avião pesando 3,3 toneladas</a></li>
<li><a href="../pt453544/index.html">Decodificador de sete segmentos usando saídas diretas e inversas de um contador BCD</a></li>
<li><a href="../pt453546/index.html">Precisa de um teclado pequeno - faça você mesmo</a></li>
<li><a href="../pt453548/index.html">Revivemos o freio Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../pt453554/index.html">Como o Starlink da SpaceX mudou</a></li>
<li><a href="../pt453562/index.html">Eventos digitais em Moscou, de 27 de maio a 2 de junho</a></li>
<li><a href="../pt453564/index.html">Realize - desenvolvendo um jogo de lógica no Unity</a></li>
<li><a href="../pt453566/index.html">Restaurar a lenda: um pedido de troca de dados abertos que pode ajudar na restauração de Notre Dame</a></li>
<li><a href="../pt453568/index.html">Reconstruindo um ícone: uma chamada para o compartilhamento de dados abertos para ajudar a restaurar Notre-Dame</a></li>
<li><a href="../pt453570/index.html">Microsoft Edge para macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>