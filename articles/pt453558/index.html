<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚ÄçüöÄ üßíüèº üë©‚Äç‚öñÔ∏è Introdu√ß√£o ao Machine Learning üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üìß üì¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O curso completo em russo pode ser encontrado neste link . 
 O curso de ingl√™s original est√° dispon√≠vel neste link . 



 Novas palestras s√£o agendada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o ao Machine Learning</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  O curso completo em russo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br>  O curso de ingl√™s original est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Novas palestras s√£o agendadas a cada 2-3 dias.</i> <br><br><h2>  Entrevista com Sebastian Trun, CEO da Udacity </h2><br>  "Ol√° novamente, eu sou Paige e voc√™ √© meu convidado hoje, Sebastian." <br>  Oi, eu sou Sebastian! <br>  - ... um homem que tem uma carreira incr√≠vel, que conseguiu fazer muitas coisas incr√≠veis!  Voc√™ √© co-fundador da Udacity, fundou o Google X, √© professor em Stanford.  Voc√™ vem pesquisando e aprendendo profundamente por toda a sua carreira.  O que lhe trouxe mais satisfa√ß√£o e em quais √°reas voc√™ recebeu mais recompensas pelo trabalho realizado? <br>  - Francamente, eu realmente amo estar no Vale do Sil√≠cio!  Eu gosto de estar perto de pessoas que s√£o muito mais inteligentes do que eu e sempre considerei a tecnologia como uma ferramenta que muda as regras do jogo de v√°rias maneiras - da educa√ß√£o √† log√≠stica, sa√∫de, etc.  Tudo isso muda t√£o rapidamente, e h√° um desejo incr√≠vel de ser um participante dessas mudan√ßas, de observ√°-las.  Voc√™ olha para os arredores e entende que a maior parte do que v√™ ao seu redor n√£o funciona como deveria - voc√™ sempre pode inventar algo novo! <br>  - Bem, essa √© uma vis√£o muito otimista da tecnologia!  Qual foi o maior eureka ao longo de sua carreira? <br>  - Senhor, havia tantos!  Lembro-me de um dia em que Larry Page me ligou e sugeriu a cria√ß√£o de carros de piloto autom√°tico que pudessem dirigir por todas as ruas da Calif√≥rnia.  Naquela √©poca, eu era considerado um especialista, era classificado entre eles e eu era a mesma pessoa que disse "n√£o, isso n√£o pode ser feito".  Depois disso, Larry me convenceu de que, em princ√≠pio, √© poss√≠vel fazer isso, voc√™ s√≥ precisa come√ßar e tentar.  E n√≥s conseguimos!  Foi o momento em que percebi que mesmo os especialistas est√£o errados e dizendo "n√£o" somos 100% pessimistas.  Acho que dever√≠amos estar mais abertos ao novo. <br>  - Ou, por exemplo, se Larry Page ligar e disser: "Ei, fa√ßa algo legal como o Google X" e voc√™ ter√° algo muito legal! <br>  - Sim, com certeza, n√£o precisa reclamar!  Quero dizer, tudo isso √© um processo que passa por muita discuss√£o no caminho da implementa√ß√£o.  Tenho muita sorte de trabalhar e tenho orgulho disso, no Google X e em outros projetos. <br>  - Incr√≠vel!  Portanto, este curso √© sobre como trabalhar com o TensorFlow.  Voc√™ tem experi√™ncia com o TensorFlow ou talvez esteja familiarizado (ouvido) com ele? <br>  Sim!  Eu literalmente amo o TensorFlow, √© claro!  No meu pr√≥prio laborat√≥rio, n√≥s o usamos com frequ√™ncia e muito, um dos trabalhos mais significativos baseados no TensorFlow foi lan√ßado h√° cerca de dois anos.  Aprendemos que o iPhone e o Android podem ser mais eficazes na detec√ß√£o de c√¢ncer de pele do que os melhores dermatologistas do mundo.  Publicamos nossa pesquisa na Nature e isso criou uma esp√©cie de como√ß√£o na medicina. <br>  - Isso parece incr√≠vel!  Ent√£o voc√™ conhece e ama o TensorFlow, o que √© √≥timo em si!  Voc√™ j√° trabalhou com o TensorFlow 2.0? <br>  - N√£o, infelizmente ainda n√£o tive tempo. <br>  - Ele vai ser incr√≠vel!  Todos os alunos deste curso trabalhar√£o com esta vers√£o. <br>  - Eu os invejo!  Definitivamente vou tentar! <br>  √ìtimo!  Em nosso curso, h√° muitos estudantes que em sua vida nunca se envolveram em aprendizado de m√°quina, a partir da palavra "completamente".  Para eles, o campo pode ser novo, talvez para algu√©m que esteja programando seja novo.  Que conselho voc√™ daria para eles? <br>  - Gostaria que eles permanecessem abertos - a novas id√©ias, t√©cnicas, solu√ß√µes, posi√ß√µes.  O aprendizado de m√°quina √© realmente mais f√°cil que a programa√ß√£o.  No processo de programa√ß√£o, √© necess√°rio levar em considera√ß√£o cada caso nos dados de origem, adaptar a l√≥gica e as regras do programa.  No momento, usando o TensorFlow e o aprendizado de m√°quina, voc√™ basicamente treina o computador usando exemplos, permitindo que o computador encontre as regras. <br>  - Isso √© incrivelmente interessante!  Mal posso esperar para contar aos alunos deste curso um pouco mais sobre aprendizado de m√°quina!  Sebastian, obrigado por reservar um tempo para vir at√© n√≥s hoje! <br>  Obrigado!  Fique em contato! <br><br><h2>  O que √© aprendizado de m√°quina? </h2><br>  Ent√£o, vamos come√ßar com a seguinte tarefa - dados de entrada e sa√≠da. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Quando voc√™ tiver o valor 0 como valor de entrada, 32 como valor de sa√≠da.Quando voc√™ tiver 8 como valor de entrada, 46,4 como valor de sa√≠da.  Quando voc√™ tem 15 como valor de entrada, 59 como valor de sa√≠da e assim por diante. <br><br>  D√™ uma olhada nesses valores e deixe-me fazer uma pergunta.  Voc√™ pode determinar qual ser√° a sa√≠da se recebermos 38 na entrada? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Se voc√™ respondeu 100,4, estava certo! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Ent√£o, como poder√≠amos resolver esse problema?  Se voc√™ observar atentamente os valores, poder√° ver que eles est√£o relacionados pela express√£o: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Onde C - graus Celsius (valores de entrada), F - Fahrenheit (valores de sa√≠da). <br><br>  O que seu c√©rebro acabou de fazer - comparou valores de entrada e valores de sa√≠da e encontrou um modelo comum (conex√£o, depend√™ncia) entre eles - √© isso que o aprendizado de m√°quina faz. <br><br>  Com base nos valores de entrada e sa√≠da, os algoritmos de aprendizado de m√°quina encontrar√£o um algoritmo adequado para converter valores de entrada em valores de sa√≠da.  Isso pode ser representado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Vejamos um exemplo.  Imagine que queremos desenvolver um programa que converta graus Celsius em graus Fahrenheit usando a f√≥rmula <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  A solu√ß√£o, ao abordar do ponto de vista do desenvolvimento tradicional de software, pode ser implementada em qualquer linguagem de programa√ß√£o usando a fun√ß√£o: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Ent√£o o que n√≥s temos?  A fun√ß√£o pega um valor de entrada C, calcula o valor de sa√≠da de F usando um algoritmo expl√≠cito e, em seguida, retorna o valor calculado. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Por outro lado, na abordagem de aprendizado de m√°quina, temos apenas valores de entrada e sa√≠da, mas n√£o o pr√≥prio algoritmo: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  A abordagem de aprendizado de m√°quina baseia-se no uso de redes neurais para encontrar a rela√ß√£o entre os valores de entrada e sa√≠da. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Voc√™ pode pensar em redes neurais como uma pilha de camadas, cada uma das quais consiste em matem√°tica (f√≥rmulas) e vari√°veis ‚Äã‚Äãinternas conhecidas anteriormente.  O valor de entrada entra na rede neural e passa por uma pilha de camadas de neur√¥nios.  Ao passar pelas camadas, o valor de entrada √© convertido de acordo com a matem√°tica (f√≥rmulas fornecidas) e os valores das vari√°veis ‚Äã‚Äãinternas das camadas, produzindo um valor de sa√≠da. <br><br>  Para que a rede neural seja capaz de aprender e determinar a rela√ß√£o correta entre os valores de entrada e sa√≠da, precisamos trein√°-la - trein√°-la. <br><br>  N√≥s treinamos a rede neural atrav√©s de tentativas repetidas de combinar valores de entrada com valores de sa√≠da. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  No processo de treinamento, o ‚Äúajuste‚Äù (sele√ß√£o) dos valores das vari√°veis ‚Äã‚Äãinternas nas camadas da rede neural ocorre at√© que a rede aprenda a gerar os valores de sa√≠da correspondentes aos valores de entrada correspondentes. <br><br>  Como veremos mais adiante, para treinar uma rede neural e permitir que ela selecione os valores mais adequados de vari√°veis ‚Äã‚Äãinternas, milhares ou dezenas de milhares de itera√ß√µes (treinamentos) s√£o executadas. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Como uma vers√£o simplificada do entendimento do aprendizado de m√°quina, voc√™ pode imaginar algoritmos de aprendizado de m√°quina como fun√ß√µes que selecionam os valores de vari√°veis ‚Äã‚Äãinternas, para que os valores de entrada corretos correspondam aos valores de sa√≠da corretos. <br><br>  Existem muitos tipos de arquiteturas de redes neurais.  No entanto, independentemente da arquitetura escolhida, a matem√°tica interna (quais c√°lculos s√£o executados e em que ordem) permanecer√° inalterada durante o treinamento.  Em vez de mudar a matem√°tica, as vari√°veis ‚Äã‚Äãinternas (pesos e compensa√ß√µes) mudam durante o treinamento. <br><br>  Por exemplo, na tarefa de converter de graus Celsius em Fahrenheit, o modelo come√ßa multiplicando o valor de entrada por um determinado n√∫mero (peso) e adicionando outro valor (deslocamento).  O treinamento do modelo consiste em encontrar valores adequados para essas vari√°veis, sem alterar as opera√ß√µes realizadas de multiplica√ß√£o e adi√ß√£o. <br><br>  Mas uma coisa legal para se pensar!  Se voc√™ resolveu o problema de converter graus Celsius em Fahrenheit, indicado no v√≠deo e no texto abaixo, provavelmente o resolveu porque tinha alguma experi√™ncia ou conhecimento anterior sobre como realizar esse tipo de convers√£o de graus Celsius em Fahrenheit.  Por exemplo, voc√™ pode saber apenas que 0 graus Celsius corresponde a 32 graus Fahrenheit.  Por outro lado, os sistemas baseados no aprendizado de m√°quina n√£o t√™m conhecimento pr√©vio de suporte para resolver o problema.  Eles aprendem a resolver esses problemas, n√£o com base no conhecimento anterior e em sua completa aus√™ncia. <br><br>  Chega de conversa - v√° para a parte pr√°tica da palestra! <br><br><h2>  CoLab: converta graus Celsius em graus Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A vers√£o russa do c√≥digo-fonte do CoLab</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o em ingl√™s do c√≥digo-fonte do CoLab</a> . <br><br><h2>  No√ß√µes b√°sicas: aprendendo o primeiro modelo </h2><br>  Bem-vindo ao CoLab, onde treinaremos nosso primeiro modelo de aprendizado de m√°quina! <br><br>  Procuraremos manter a simplicidade do material apresentado e apresentar apenas os conceitos b√°sicos necess√°rios para o trabalho.  Os CoLabs subsequentes conter√£o t√©cnicas mais avan√ßadas. <br><br>  A tarefa que resolveremos √© a convers√£o de graus Celsius em graus Fahrenheit.  A f√≥rmula de convers√£o √© a seguinte: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>z</mi><mi>e</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="19.962ex" height="2.419ex" viewBox="0 -780.1 8594.7 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-76" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-65" x="3053" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-7A" x="3520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-65" x="3988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMATHI-73" x="4455" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-31" x="4924" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-2C" x="5425" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-38" x="5870" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-2B" x="6592" y="0"></use><g transform="translate(7593,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhmh9hkGOEFoCKBUId6v-NK73VoaQ#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>z</mi><mi>e</mi><mi>s</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ vezes 1,8 + 32 </script></p><br><br>  Obviamente, seria mais f√°cil escrever uma fun√ß√£o de convers√£o em Python ou em qualquer outra linguagem de programa√ß√£o que realizasse c√°lculos diretos, mas, neste caso, n√£o seria aprendizado de m√°quina :) <br><br>  Em vez disso, alimentamos na entrada TensorFlow os graus de entrada em graus Celsius que temos (0, 8, 15, 22, 38) e seus graus correspondentes em Fahrenheit (32, 46, 59, 72, 100).  Em seguida, treinaremos o modelo de forma que corresponda aproximadamente √† f√≥rmula acima. <br><br><h3>  Depend√™ncias de importa√ß√£o </h3><br>  A primeira coisa que importamos √© o <code>TensorFlow</code> .  Aqui e a seguir chamamos abreviadamente <code>tf</code> .  Tamb√©m configuramos o n√≠vel de registro - apenas erros. <br><br>  Em seguida, importe o <code>NumPy</code> como <code>np</code> .  <code>Numpy</code> nos ajuda a apresentar nossos dados como listagens de alto desempenho. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Prepara√ß√£o de dados de treinamento </h3><br>  Como vimos anteriormente, a t√©cnica de aprendizado de m√°quina com o professor √© baseada na busca de um algoritmo para converter dados de entrada em sa√≠da.  Como a tarefa deste CoLab √© criar um modelo que possa produzir o resultado da convers√£o de graus Celsius em graus Fahrenheit, crie duas listas - <code>celsius_q</code> e <code>fahrenheit_a</code> , que usamos ao treinar nosso modelo. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Alguma terminologia de aprendizado de m√°quina: <br><br><ul><li>  <b>Propriedade</b> √© o valor de entrada do nosso modelo.  Nesse caso, o valor unit√°rio √© graus Celsius. </li><li>  <b>Os r√≥tulos</b> s√£o os valores de sa√≠da que nosso modelo prev√™.  Nesse caso, o valor unit√°rio √© graus Fahrenheit. </li><li>  <b>Um exemplo</b> √© um par de valores de entrada e sa√≠da usados ‚Äã‚Äãpara treinamento.  Nesse caso, este √© um par de valores de <code>celsius_q</code> e <code>fahrenheit_a</code> sob um determinado √≠ndice, por exemplo, (22,72). </li></ul><br><h2>  Crie um modelo </h2><br>  Em seguida, criamos um modelo.  Usaremos o modelo mais simplificado - o modelo de uma rede totalmente conectada (rede <code>Dense</code> ).  Como a tarefa √© bastante trivial, a rede tamb√©m consistir√° em uma √∫nica camada com um √∫nico neur√¥nio. <br><br><h4>  Construindo uma rede </h4><br>  <code>tf.keras.layers.Dense</code> a camada <code>l0</code> ( <b>l</b> ayer e zero) e a criaremos inicializando <code>tf.keras.layers.Dense</code> com os seguintes par√¢metros: <br><br><ul><li>  <code>input_shape=[1]</code> - este par√¢metro determina a dimens√£o do par√¢metro de entrada - um √∫nico valor.  Matriz 1 √ó 1 com um √∫nico valor.  Como essa √© a primeira (e √∫nica) camada, a dimens√£o dos dados de entrada corresponde √† dimens√£o de todo o modelo.  O √∫nico valor √© um valor de ponto flutuante representando graus Celsius. </li><li>  <code>units=1</code> - este par√¢metro determina o n√∫mero de neur√¥nios na camada.  O n√∫mero de neur√¥nios determina quantas vari√°veis ‚Äã‚Äãda camada interna ser√£o usadas no treinamento para encontrar uma solu√ß√£o para o problema.  Como essa √© a √∫ltima camada, sua dimens√£o √© igual √† dimens√£o do resultado - o valor de sa√≠da do modelo - um √∫nico n√∫mero de ponto flutuante representando graus Fahrenheit.  (Em uma rede multicamada, o tamanho e a forma da camada <code>input_shape</code> devem corresponder ao tamanho e forma da pr√≥xima camada). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Converter camadas em modelo </h4><br>  Uma vez definidas as camadas, elas precisam ser convertidas em um modelo.  <code>Sequential</code> modelo <code>Sequential</code> toma como argumentos a lista de camadas na ordem em que devem ser aplicadas - do valor de entrada ao valor de sa√≠da. <br><br>  Nosso modelo possui apenas uma camada - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Nota</b> <br>  Muitas vezes, voc√™ encontrar√° a defini√ß√£o de camadas diretamente na fun√ß√£o de modelo, em vez de sua descri√ß√£o preliminar e uso subseq√ºente: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Compilamos um modelo com uma fun√ß√£o de perda e otimiza√ß√£o </h3><br>  Antes do treinamento, o modelo deve ser compilado (montado).  Ao compilar para o treinamento, voc√™ precisa: <br><br><ul><li>  <b>fun√ß√£o de perda</b> - uma maneira de medir a que dist√¢ncia o valor previsto est√° do valor de sa√≠da desejado (uma diferen√ßa mensur√°vel √© chamada de "perda"). </li><li>  <b>fun√ß√£o de otimiza√ß√£o</b> - uma maneira de ajustar vari√°veis ‚Äã‚Äãinternas para reduzir perdas. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  A fun√ß√£o de perda e a fun√ß√£o de otimiza√ß√£o s√£o usadas durante o treinamento do modelo ( <code>model.fit(...)</code> mencionado abaixo) para executar c√°lculos iniciais em cada ponto e otimizar os valores. <br><br>  A a√ß√£o de calcular as perdas atuais e a melhoria subsequente desses valores no modelo √© exatamente o que √© o treinamento (uma itera√ß√£o). <br><br>  Durante o treinamento, a fun√ß√£o de otimiza√ß√£o √© usada para calcular ajustes nos valores das vari√°veis ‚Äã‚Äãinternas.  O objetivo √© ajustar os valores das vari√°veis ‚Äã‚Äãinternas de tal maneira no modelo (e isso, de fato, √© uma fun√ß√£o matem√°tica) para que elas reflitam o mais pr√≥ximo poss√≠vel a express√£o existente para converter graus Celsius em graus Fahrenheit. <br><br>  O TensorFlow usa an√°lise num√©rica para executar esses tipos de opera√ß√µes de otimiza√ß√£o, e toda essa complexidade est√° oculta aos nossos olhos, portanto, n√£o entraremos em detalhes neste curso. <br><br>  O que √© √∫til saber sobre estas op√ß√µes: <br><br>  A fun√ß√£o de perda (erro padr√£o) e a fun√ß√£o de otimiza√ß√£o (Adam) usadas neste exemplo s√£o padr√£o para modelos t√£o simples, mas muitos outros est√£o dispon√≠veis al√©m deles.  Nesta fase, n√£o nos importamos com o funcionamento dessas fun√ß√µes. <br><br>  Voc√™ deve prestar aten√ß√£o √† fun√ß√£o de otimiza√ß√£o e o par√¢metro √© o coeficiente da <code>learning rate</code> , que em nosso exemplo √© <code>0.1</code> .  Este √© o tamanho da etapa usada ao ajustar os valores internos das vari√°veis.  Se o valor for muito pequeno, ser√£o necess√°rias muitas itera√ß√µes de treinamento para treinar o modelo.  Demais - a precis√£o cai.  Encontrar um bom valor para o coeficiente da taxa de aprendizado requer algumas tentativas e erros, geralmente varia de <code>0.01</code> (por padr√£o) a <code>0.1</code> . <br><br><h4>  Treinamos o modelo </h4><br>  O treinamento do modelo √© realizado pelo m√©todo de <code>fit</code> . <br><br>  Durante o treinamento, o modelo recebe graus Celsius na entrada, realiza transforma√ß√µes usando os valores de vari√°veis ‚Äã‚Äãinternas (chamadas de "pesos") e retorna valores que devem corresponder a graus Fahrenheit.  Como os valores iniciais dos pesos s√£o definidos arbitrariamente, os valores resultantes estar√£o longe dos valores corretos.  A diferen√ßa entre o resultado desejado e o real √© calculada usando a fun√ß√£o de perda, e a fun√ß√£o de otimiza√ß√£o determina como os pesos devem ser ajustados. <br><br>  Esse ciclo de c√°lculos, compara√ß√µes e ajustes √© controlado dentro do m√©todo de <code>fit</code> .  O primeiro argumento √© o valor de entrada, o segundo argumento √© o valor de sa√≠da desejado.  O argumento das <code>epochs</code> determina quantas vezes esse ciclo de treinamento deve ser conclu√≠do.  O argumento <code>verbose</code> controla o n√≠vel de log. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  Nos v√≠deos a seguir, abordaremos os detalhes de como tudo isso funciona e como exatamente as camadas totalmente conectadas (camadas <code>Dense</code> ) "sob o cap√¥". <br><br><h4>  Exibir estat√≠sticas de treinamento </h4><br>  O m√©todo de <code>fit</code> retorna um objeto que cont√©m informa√ß√µes sobre altera√ß√µes nas perdas a cada itera√ß√£o subsequente.  Podemos usar esse objeto para criar um cronograma de perdas apropriado.  Alta perda significa que os graus Fahrenheit previstos pelo modelo est√£o longe dos valores reais na matriz <code>fahrenheit_a</code> . <br><br>  Para visualiza√ß√£o, usaremos o <code>Matplotlib</code> .  Como voc√™ pode ver, nosso modelo melhora muito rapidamente desde o in√≠cio e, em seguida, chega a uma melhoria est√°vel e lenta at√© que os resultados se tornem "pr√≥ximos" - perfeitos no final do treinamento. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Usamos o modelo para previs√µes. </h4><br>  Agora, temos um modelo que foi treinado nos valores de entrada <code>celsius_q</code> e nos valores de sa√≠da <code>fahrenheit_a</code> para determinar o relacionamento entre eles.  Podemos usar o m√©todo de previs√£o para calcular os graus Fahrenheit pelos quais anteriormente n√£o conhec√≠amos os graus Celsius correspondentes. <br><br>  Por exemplo, quanto √© 100,0 graus Celsius Fahrenheit?  Tente adivinhar antes de executar o c√≥digo abaixo. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Conclus√£o: <br><br> <code>[[211.29639]] <br></code> <br><br>  A resposta correta √© 100 √ó 1,8 + 32 = 212, ent√£o nosso modelo se saiu muito bem! <br><br>  <b>Revis√£o</b> <br><br><ul><li>  Criamos um modelo usando a camada <code>Dense</code> . </li><li>  N√≥s a treinamos com 3.500 exemplos (7 pares de valores, 500 itera√ß√µes de treinamento) </li></ul><br>  Nosso modelo ajustou os valores das vari√°veis ‚Äã‚Äãinternas (pesos) na camada <code>Dense</code> forma a retornar os valores corretos dos graus Fahrenheit a um valor de entrada arbitr√°rio de graus Celsius. <br><br><h3>  Olhamos para os pesos </h3><br>  Vamos exibir os valores das vari√°veis ‚Äã‚Äãinternas da camada <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  O valor da primeira vari√°vel √© pr√≥ximo a ~ 1,8 e o segundo a ~ 32.  Esses valores (1,8 e 32) s√£o valores diretos na f√≥rmula para converter graus Celsius em graus Fahrenheit. <br><br>  Isso √© realmente muito pr√≥ximo dos valores reais na f√≥rmula!  Consideraremos esse ponto com mais detalhes nos v√≠deos a seguir, onde mostraremos como a camada <code>Dense</code> funciona, mas por enquanto voc√™ s√≥ precisa saber que um neur√¥nio com uma √∫nica entrada e sa√≠da cont√©m matem√°tica simples - <code>y = mx + b</code> (como uma equa√ß√£o direta), que nada mais √© do que nossa f√≥rmula para converter graus Celsius em graus Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Como as representa√ß√µes s√£o iguais, os valores das vari√°veis ‚Äã‚Äãinternas do modelo devem convergir para os apresentados na f√≥rmula real, o que aconteceu no final. <br><br>  Com a presen√ßa de neur√¥nios adicionais, valores adicionais de entrada e valores de sa√≠da, a f√≥rmula se torna um pouco mais complicada, mas a ess√™ncia permanece a mesma. <br><br><h4>  Um pouco de experimenta√ß√£o </h4><br>  Por divers√£o!  O que acontece se criarmos mais camadas <code>Dense</code> com mais neur√¥nios, que por sua vez conter√£o mais vari√°veis ‚Äã‚Äãinternas? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Como voc√™ deve ter notado, o modelo atual tamb√©m √© capaz de prever muito bem os graus correspondentes de Fahrenheit.  No entanto, se observarmos os valores das vari√°veis ‚Äã‚Äãinternas (pesos) dos neur√¥nios por camadas, n√£o veremos valores semelhantes a 1,8 e 32.  A complexidade adicional do modelo oculta a forma "simples" de converter graus Celsius em graus Fahrenheit. <br><br>  Fique conectado e, na pr√≥xima parte, veremos como as camadas densas funcionam "sob o cap√¥". <br><br><h3>  Breve resumo </h3><br>  Parab√©ns!  Voc√™ acabou de treinar seu primeiro modelo.  Na pr√°tica, vimos como, por valores de entrada e sa√≠da, o modelo aprendeu a multiplicar o valor de entrada por 1,8 e adicionar 32 a ele para obter o resultado correto. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Isso foi realmente impressionante, considerando quantas linhas de c√≥digo precisamos escrever: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  O exemplo acima √© um plano geral para todos os programas de aprendizado de m√°quina.  Voc√™ usar√° constru√ß√µes semelhantes para criar e treinar redes neurais e resolver problemas subseq√ºentes. <br><br><h3>  Processo de treinamento </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de treinamento (ocorrendo no m√©todo </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) consiste em uma sequ√™ncia muito simples de a√ß√µes, cujo resultado deve ser o valor das vari√°veis ‚Äã‚Äãinternas, fornecendo os resultados o mais pr√≥ximo poss√≠vel do original. </font><font style="vertical-align: inherit;">O processo de otimiza√ß√£o pelo qual tais resultados s√£o alcan√ßados, chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descida gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , utiliza an√°lise num√©rica para encontrar os valores mais adequados para as vari√°veis ‚Äã‚Äãinternas do modelo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para participar do aprendizado de m√°quina, voc√™, em princ√≠pio, n√£o precisa entender esses detalhes. Mas para aqueles que ainda est√£o interessados ‚Äã‚Äãem aprender mais: a descida do gradiente por meio de itera√ß√µes altera um pouco os valores dos par√¢metros, ‚Äúpuxando-os‚Äù na dire√ß√£o certa, at√© que os melhores resultados sejam obtidos. Nesse caso, ‚Äúmelhores resultados‚Äù (melhores valores) significam que qualquer altera√ß√£o subsequente no par√¢metro apenas piorar√° o resultado do modelo. Uma fun√ß√£o que mede o qu√£o bom ou ruim √© um modelo em cada itera√ß√£o √© chamada de ‚Äúfun√ß√£o de perda‚Äù, e o objetivo de cada ‚Äúpuxar‚Äù (ajuste de valores internos) √© reduzir o valor da fun√ß√£o de perda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de treinamento come√ßa com o bloco "distribui√ß√£o direta", no qual os par√¢metros de entrada v√£o para a entrada da rede neural, seguem os neur√¥nios ocultos e depois v√£o para o fim de semana. O modelo ent√£o aplica transforma√ß√µes internas nos valores de entrada e vari√°veis ‚Äã‚Äãinternas para prever a resposta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nosso exemplo, o valor de entrada √© a temperatura em graus Celsius e o modelo previu o valor correspondente em graus Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim que o valor √© previsto, √© calculada a diferen√ßa entre o valor previsto e o correto. A diferen√ßa √© chamada de "perda" e √© uma forma de medir o qu√£o bem o modelo funcionou. O valor da perda √© calculado pela fun√ß√£o de perda, que determinamos por um dos argumentos ao chamar o m√©todo </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o c√°lculo do valor da perda, as vari√°veis ‚Äã‚Äãinternas (pesos e deslocamentos) de todas as camadas da rede neural s√£o ajustadas para minimizar o valor da perda, a fim de aproximar o valor da sa√≠da ao valor de refer√™ncia inicial correto. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse processo de otimiza√ß√£o √© chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descida de gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um algoritmo de otimiza√ß√£o espec√≠fico √© usado para calcular um novo valor para cada vari√°vel interna quando o m√©todo √© chamado </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No exemplo acima, usamos um algoritmo de otimiza√ß√£o </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© necess√°rio entender os princ√≠pios do processo de treinamento para este curso; no entanto, se voc√™ tiver curiosidade suficiente, poder√° encontrar mais informa√ß√µes no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Curso de falha</font></a><font style="vertical-align: inherit;"> do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(A tradu√ß√£o e a parte pr√°tica de todo o curso est√£o estabelecidas nos planos de publica√ß√£o do autor). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, voc√™ j√° deve estar familiarizado com os seguintes termos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriedade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valor de entrada do nosso modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pares de entrada + sa√≠da;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valores de sa√≠da do modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camadas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma cole√ß√£o de n√≥s unidos em uma rede neural;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : representa√ß√£o da sua rede neural;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denso e totalmente conectado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cada n√≥ em uma camada √© conectado a cada n√≥ da camada anterior.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos e compensa√ß√µes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : modelar vari√°veis ‚Äã‚Äãinternas;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a diferen√ßa entre o valor de sa√≠da desejado e o valor de sa√≠da real do modelo;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  ¬´¬ª       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propaga√ß√£o de retorno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : calculando os valores das vari√°veis ‚Äã‚Äãinternas de acordo com um algoritmo de otimiza√ß√£o, come√ßando na camada de sa√≠da e em dire√ß√£o √† camada de entrada atrav√©s de todas as camadas intermedi√°rias.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Camadas de sentido </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte anterior, criamos um modelo que converte graus Celsius em graus Fahrenheit usando uma rede neural simples para encontrar a rela√ß√£o entre graus Celsius e graus Fahrenheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa rede consiste em uma √∫nica camada totalmente conectada. </font><font style="vertical-align: inherit;">Mas o que √© uma camada totalmente conectada? </font><font style="vertical-align: inherit;">Para descobrir isso, vamos criar uma rede neural mais complexa com 3 par√¢metros de entrada, uma camada oculta com dois neur√¥nios e uma camada de sa√≠da com um √∫nico neur√¥nio.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que uma rede neural pode ser imaginada como um conjunto de camadas, cada uma das quais consiste em n√≥s chamados neur√¥nios. Os neur√¥nios de cada n√≠vel podem ser conectados aos neur√¥nios de cada camada subseq√ºente. O tipo de camada em que cada neur√¥nio de uma camada √© conectada um ao outro neur√¥nio da camada seguinte √© chamado de camada densa (camada </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">totalmente conectada (totalmente conectada) ou densa (camada </font><font style="vertical-align: inherit;">). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, quando usamos camadas totalmente conectadas </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informamos que os neur√¥nios dessa camada devem estar conectados a todos os neur√¥nios da camada anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar a rede neural acima, as seguintes express√µes s√£o suficientes para n√≥s:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, descobrimos o que s√£o os neur√¥nios e como eles est√£o relacionados. Mas como as camadas totalmente conectadas realmente funcionam? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para entender o que realmente est√° acontecendo l√° e o que eles est√£o fazendo, precisamos olhar "por baixo do cap√¥" e desmontar a matem√°tica interna dos neur√¥nios. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que nosso modelo receba tr√™s par√¢metros - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- os neur√¥nios de nossa rede. Lembra que dissemos que um neur√¥nio tem vari√°veis ‚Äã‚Äãinternas? Assim, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o o neur√≥nio vari√°veis mais interna, tamb√©m conhecido como o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peso</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deslocamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. S√£o os valores dessas vari√°veis ‚Äã‚Äãque s√£o ajustados no processo de aprendizado para obter os resultados mais precisos da compara√ß√£o dos valores de entrada com a sa√≠da. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que voc√™ definitivamente deve ter em mente √© que a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matem√°tica interna do neur√¥nio permanece inalterada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em outras palavras, durante o processo de treinamento, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pesos e deslocamentos </font><font style="vertical-align: inherit;">mudam </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando voc√™ come√ßa a aprender o aprendizado de m√°quina, pode parecer estranho - o fato de realmente funcionar, mas √© assim que o aprendizado de m√°quina funciona! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao nosso exemplo de convers√£o de graus Celsius em graus Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com um √∫nico neur√¥nio, temos apenas um peso e um deslocamento. Voc√™ sabe o que? √â exatamente assim que a f√≥rmula para converter graus Celsius em graus Fahrenheit se parece. Se substituirmos o </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em vez de </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obteremos o modelo final de transforma√ß√£o! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se retornarmos aos resultados do nosso modelo a partir da parte pr√°tica, prestaremos aten√ß√£o ao fato de que os indicadores de peso e deslocamento foram "calibrados" de maneira a corresponder aproximadamente aos valores da f√≥rmula.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos propositalmente apenas um exemplo t√£o pr√°tico para mostrar claramente a compara√ß√£o exata entre pesos e compensa√ß√µes. Colocando o aprendizado de m√°quina em pr√°tica, nunca podemos comparar os valores das vari√°veis ‚Äã‚Äãcom o algoritmo de destino dessa maneira, como no exemplo acima. Como podemos fazer isso? De jeito nenhum, porque n√≥s nem conhecemos o algoritmo de destino! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo os problemas do aprendizado de m√°quina, testamos v√°rias arquiteturas de redes neurais com um n√∫mero diferente de neur√¥nios - por tentativa e erro, encontramos as arquiteturas e modelos mais precisos e esperamos que eles resolvam a tarefa no processo de aprendizado. Na pr√≥xima parte pr√°tica, poderemos estudar exemplos espec√≠ficos dessa abordagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fique em contato, porque agora a divers√£o come√ßa!</font></font><br><br><h3>  Sum√°rio </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta li√ß√£o, aprendemos abordagens b√°sicas no aprendizado de m√°quina e aprendemos como as camadas ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-layers) </font><font style="vertical-align: inherit;">totalmente conectadas </font><font style="vertical-align: inherit;">funcionam. </font><font style="vertical-align: inherit;">Voc√™ treinou seu primeiro modelo para converter graus Celsius em graus Fahrenheit. </font><font style="vertical-align: inherit;">Voc√™ tamb√©m aprendeu os termos b√°sicos usados ‚Äã‚Äãno aprendizado de m√°quina, como propriedades, exemplos, r√≥tulos. </font><font style="vertical-align: inherit;">Entre outras coisas, voc√™ escreveu as principais linhas de c√≥digo em Python, que s√£o a espinha dorsal de qualquer algoritmo de aprendizado de m√°quina. </font><font style="vertical-align: inherit;">Voc√™ viu que em algumas linhas de c√≥digo voc√™ pode criar, treinar e solicitar uma previs√£o de uma rede neural usando </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... e call to action padr√£o - inscreva-se, coloque um plus e compartilhe :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vers√£o em v√≠deo do artigo</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegrama: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453558/">https://habr.com/ru/post/pt453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453542/index.html">O rob√¥ de quatro patas conseguiu rebocar um avi√£o pesando 3,3 toneladas</a></li>
<li><a href="../pt453544/index.html">Decodificador de sete segmentos usando sa√≠das diretas e inversas de um contador BCD</a></li>
<li><a href="../pt453546/index.html">Precisa de um teclado pequeno - fa√ßa voc√™ mesmo</a></li>
<li><a href="../pt453548/index.html">Revivemos o freio Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../pt453554/index.html">Como o Starlink da SpaceX mudou</a></li>
<li><a href="../pt453562/index.html">Eventos digitais em Moscou, de 27 de maio a 2 de junho</a></li>
<li><a href="../pt453564/index.html">Realize - desenvolvendo um jogo de l√≥gica no Unity</a></li>
<li><a href="../pt453566/index.html">Restaurar a lenda: um pedido de troca de dados abertos que pode ajudar na restaura√ß√£o de Notre Dame</a></li>
<li><a href="../pt453568/index.html">Reconstruindo um √≠cone: uma chamada para o compartilhamento de dados abertos para ajudar a restaurar Notre-Dame</a></li>
<li><a href="../pt453570/index.html">Microsoft Edge para macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>