<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüî¨ üëãüèæ üåî Principios de funcionamiento del protocolo EIGRP üçê ‚ö°Ô∏è üôáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo hablar√° sobre EIGRP y discutir√° c√≥mo funciona este protocolo. EIGRP es un protocolo de vector de distancia, a veces se dice que es h√≠bri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principios de funcionamiento del protocolo EIGRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420667/"> Este art√≠culo hablar√° sobre EIGRP y discutir√° c√≥mo funciona este protocolo.  EIGRP es un protocolo de vector de distancia, a veces se dice que es h√≠brido, pero no lo es.  Lea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comienzo del art√≠culo</a> sobre OSPF y comprender√° por qu√© EIGRP es un protocolo de vector remoto.  EIGRP es un protocolo avanzado de enrutamiento din√°mico de vector de distancia desarrollado por Cisco.  Vamos a hacerlo bien.  Utilizaremos la siguiente topolog√≠a: <br><br><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ed/cbb/733/4edcbb7335c70442a6ad9c1e4754e851.jpg" alt="Mi imagen"></a> <a name="habracut"></a><br><br>  Ejecute EIGRP en vIOS1 y vIOS2, vea c√≥mo se transmite la informaci√≥n entre los enrutadores.  Tan pronto como EIGRP se activa en el enrutador, el enrutador comienza a enviar paquetes de saludo.  Tambi√©n enumeramos otros tipos de mensajes que se usan en EIGRP. <br><br><ul><li>  Hola: los enrutadores usan paquetes de saludo para descubrir vecinos.  Los paquetes de multidifusi√≥n se env√≠an y no requieren confirmaci√≥n de recepci√≥n. </li><li>  Actualizaci√≥n: contiene informaci√≥n sobre el cambio de rutas.  Se env√≠an solo a los enrutadores afectados por la actualizaci√≥n.  Estos paquetes se pueden enviar a un enrutador espec√≠fico (unidifusi√≥n) o grupo de enrutadores (multidifusi√≥n).  La recepci√≥n de un paquete de actualizaci√≥n se confirma enviando un ACK. </li><li>  Consulta: cuando el enrutador calcula la ruta y no tiene un sucesor factible, env√≠a un paquete de consulta a sus vecinos para determinar si tienen un sucesor factible para este destino.  Por lo general, los paquetes de consulta se env√≠an por multidifusi√≥n, pero puede haber unidifusi√≥n.  La recepci√≥n del paquete de consulta se confirma enviando el ACK por el receptor del paquete. </li><li>  Responder: el enrutador env√≠a un paquete de respuesta en respuesta al paquete de consulta.  Los paquetes de respuesta se env√≠an unicast al que envi√≥ el paquete de consulta.  La recepci√≥n de un paquete de respuesta se confirma enviando un ACK. </li><li>  ACK: un paquete que confirma la recepci√≥n de paquetes de actualizaci√≥n, consulta y respuesta.  Los paquetes ACK se env√≠an unicast y contienen un n√∫mero de confirmaci√≥n.  De hecho, estos son paquetes de saludo que no transmiten datos.  Se utiliza la entrega no garantizada. </li></ul><br>  Tambi√©n hay paquetes SIA, pero hablaremos de ellos a continuaci√≥n. <br>  Los paquetes se env√≠an a la direcci√≥n de multidifusi√≥n 224.0.0.10 cada 5 segundos (Hello Timer), Hold Timer es de 15 segundos = 3 intervalos de saludo, si durante este temporizador no se recibieron paquetes de saludo de un vecino, entonces el vecino se elimina de la lista de vecinos.  El paquete se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/144/cd2/7a5/144cd27a50a78ca0aeb70c7e4b15cfae.jpg" alt="Mi imagen"><br><br>  El paquete contiene los par√°metros de los coeficientes (K1, K2, K3, K4, K5, K6), el Temporizador de retenci√≥n y el n√∫mero del Sistema aut√≥nomo.  Los coeficientes (K1, K2, K3, K4, K5, K6) se utilizan para calcular la m√©trica, y hablaremos de ellos m√°s adelante, as√≠ como los temporizadores EIGRP.  Ahora es importante hablar sobre el Sistema Aut√≥nomo (AS).  Para activar EIGRP, se debe asignar un n√∫mero a un proceso EIGRP espec√≠fico, como en OSPF.  Pero a diferencia de OSPF, esta opci√≥n no se puede seleccionar aleatoriamente para cada enrutador, debe ser la misma para todos los enrutadores.  Si el enrutador recibe un paquete de saludo con un AS diferente, no habr√° relaci√≥n de vecino. <br><br>  Para que los enrutadores se conviertan en vecinos, se deben cumplir las siguientes condiciones: <br><br><ul><li>  los enrutadores deben estar autenticados, </li><li>  los enrutadores deben estar en el mismo AS, </li><li>  Las relaciones de vecindad deben establecerse en las direcciones principales (cuando llega un paquete de saludo, el enrutador verifica si la direcci√≥n del remitente de la red pertenece a la direcci√≥n principal de la interfaz), </li><li>  los valores de los coeficientes K deben coincidir. </li></ul><br>  Para que los enrutadores se conviertan en vecinos EIGRP, no tienen que coincidir con el tiempo de saludo y espera.  El enrutador utiliza los valores del temporizador recibidos del vecino.  Si se cambia el temporizador Hello o Hold en uno de los enrutadores, los vecinos de este enrutador utilizar√°n estos valores.  Para que el enrutador use otros valores, es necesario cambiar el temporizador en la interfaz correspondiente del vecino.  Despu√©s de intercambiar paquetes de saludo, se env√≠a un paquete de actualizaci√≥n, pero a√∫n no contiene rutas, contiene el indicador Init, que informa a los enrutadores sobre el inicio del intercambio de informaci√≥n sobre rutas.  Este paquete se env√≠a directamente a la direcci√≥n del enrutador.  Despu√©s de intercambiar tales mensajes, cada enrutador env√≠a un paquete de actualizaci√≥n con rutas a la direcci√≥n de multidifusi√≥n 224.0.0.10: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/0da/c1c/dd90dac1c80680d40681289160f1898b.jpg" alt="Mi imagen"><br><br>  Como puede ver, el paquete de actualizaci√≥n no contiene ninguna m√©trica, sino solo informaci√≥n como ancho de banda, retraso, MTU, etc. Una vez recibida esta informaci√≥n, el enrutador calcula la m√©trica utilizando los coeficientes K1-K6.  Estos paquetes pueden enviarse a un enrutador espec√≠fico o multidifusi√≥n.  En general, hay tres tipos de actualizaciones: <br><br><ul><li>  No peri√≥dico (no peri√≥dico): las actualizaciones se env√≠an no a intervalos regulares, sino cuando la topolog√≠a o la m√©trica cambian; </li><li>  Parcial (parcial): no toda la informaci√≥n de la tabla de enrutamiento se transmite en actualizaciones, sino solo cambios; </li><li>  Limitado: las actualizaciones se env√≠an solo a los enrutadores involucrados. </li></ul><br>  Los vecindarios a nivel de paquete se ven as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/588/fe6/68a588fe6adbe793d98c2b57b7da301e.jpg" alt="Mi imagen"><br><br>  Puede notar que, adem√°s del saludo y la actualizaci√≥n que enumeramos, tambi√©n hay un saludo (ACK) y el n√∫mero es igual al n√∫mero de paquetes de actualizaci√≥n enviados a la direcci√≥n de multidifusi√≥n.  Se trata del protocolo RTP.  El protocolo RTP controla el proceso de transmisi√≥n de paquetes EIGRP y proporciona: <br><br><ul><li>  Entrega garantizada de paquetes. </li><li>  Preservar el orden de los paquetes. </li></ul><br>  Estas son las cosas.  Que tenemos  Las rutas intercambiaron paquetes de actualizaci√≥n y ahora es el momento de construir una tabla de enrutamiento.  Cada actualizaci√≥n se procesa y se sustituyen los datos (ancho de banda, retraso, etc.) en una f√≥rmula especial, se calcula la m√©trica: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/0ab/062/cc60ab0622cbe1abb96521c2520b96ee.jpg" alt="Mi imagen"><br><br>  Tal f√≥rmula se ve incre√≠ble, pero lo mejor de esto es que es posible que no lo sepas, solo s√© que existe algo as√≠.  Y otro buen truco es que los coeficientes EIGRP predeterminados son: <br><br><ul><li>  K1 = 1 </li><li>  K2 = 0 </li><li>  K3 = 1 </li><li>  K4 = 0 </li><li>  K5 = 0 </li></ul><br>  Y la f√≥rmula simplemente se convierte en m√©trica = ancho de banda + retraso.  Por lo tanto, es tan importante que los coeficientes en todos los enrutadores sean los mismos, para que no haya problemas debido a las diferentes m√©tricas en los enrutadores.  Hablemos de los datos en Actualizaci√≥n con un poco m√°s de detalle. <br><br><ul><li>  Ancho de banda: se selecciona el valor m√≠nimo entre los canales de ancho de banda que conducen a la red y se env√≠a a Actualizar. </li><li>  Retraso: resume el retraso de todos los canales que conducen a esta red. </li><li>  Fiabilidad: la peor medida de fiabilidad en todo momento, basada en keepalive </li><li>  Carga: el peor indicador de carga de enlaces en todo momento, seg√∫n la velocidad de paquetes y el ancho de banda configurado en la interfaz </li><li>  MTU es la MTU m√°s peque√±a hasta el final.  A pesar de que se utiliza en la Actualizaci√≥n, no participa en el c√°lculo de la m√©trica en s√≠. </li></ul><br>  Como se dijo anteriormente, el ancho de banda y la demora se usan por defecto.  Los par√°metros restantes rara vez son necesarios cuando se necesitan, pero con la ayuda de ellos es posible un ajuste m√°s fino de la m√©trica.  Por lo tanto, en el paquete de actualizaci√≥n, el enrutador pasa la ruta y los datos asociados con √©l, no transmite la m√©trica en s√≠.  El enrutador que recibi√≥ la actualizaci√≥n calcula la m√©trica de acuerdo con la f√≥rmula y, seg√∫n las m√©tricas, decide si la ruta se dirige o no a la tabla de enrutamiento.  Tambi√©n es importante tener en cuenta que el <b>enrutador transmite solo las rutas que utiliza.</b>  Veamos c√≥mo construir una tabla de topolog√≠a. <br><br>  <b>Tabla de topolog√≠a</b> : una lista de rutas aprendidas de cada vecino.  La tabla de topolog√≠a tambi√©n almacena la m√©trica que informa cada vecino para cada ruta (AD) y la m√©trica que utilizar√° el enrutador local para llegar a la ruta a trav√©s del vecino (FD). <br><br>  Es necesario explicar qu√© son AD y FD.  Configuraremos EIGRP en todos nuestros enrutadores.  Adem√°s, para evitar n√∫meros complejos en la m√©trica, cambiamos los coeficientes de K1 = 1 K2 = 0 K3 = 1 K4 = 0 K5 = 0 a K1 = 0 K2 = 0 K3 = 1 K4 = 0 K5 = 0. Por lo tanto, tendremos 256 * F√≥rmula de retraso y tambi√©n obtenemos una manera f√°cil de manipular las m√©tricas cambiando el par√°metro de retraso en las interfaces.  Teniendo en cuenta que en las interfaces demora = 1 segundo, cada enlace, si usa la terminolog√≠a OSPF, cuesta 256. Veamos cu√°l es la tabla de topolog√≠a en vIOS1: <br><blockquote>  vIOS1 # show topolog√≠a de ip eigrp <br>  Tabla de topolog√≠a EIGRP-IPv4 para AS (1) / ID (192.168.1.1) <br>  C√≥digos: P - Pasivo, A - Activo, U - Actualizaci√≥n, Q - Consulta, R - Respuesta, <br>  r - Estado de respuesta, s - Estado de sia <br><br>  P 192.168.3.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.35.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de 192.168.14.4 (512/256), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 3 sucesores, FD es 768 <br>  a trav√©s de 192.168.12.2 (768/512), GigabitEthernet0 / 3 <br>  a trav√©s de 192.168.13.3 (768/512), GigabitEthernet0 / 0 <br>  a trav√©s de 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Si observa, por ejemplo, en la red: 192.168.5.0/24, notar√° tres rutas a trav√©s de vIOS2, vIOS3 y vIOS4 con las mismas m√©tricas.  Para 192.168.5.0/24 FD, para todas las rutas es igual a - 768 y AD - 512. D√©jenos una definici√≥n de otro art√≠culo e intentemos explicar: <br><br><ul><li>  <b>La distancia anunciada (AD)</b> , tambi√©n conocida como distancia informada (RD), es el costo de la distancia entre el enrutador vecino que anuncia la ruta y la red de destino. </li><li>  <b>Distancia factible (FD)</b> : el costo de la distancia desde el enrutador local a la red de destino = AD, que anuncia el enrutador vecino + el costo de la distancia entre el enrutador local y el enrutador vecino. </li></ul><br><blockquote>  P 192.168.5.0/24, 3 sucesores, FD es 768 a trav√©s de 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Examinemos esta fila de la tabla de topolog√≠a en vIOS1.  vIOS1 aprendi√≥ sobre la ruta de vIOS4 (192.168.14.4).  Como vIOS1 separa tres enlaces de 192.168.5.0/24, la m√©trica FD con nuestra configuraci√≥n ser√° 3 * 256 = 768.  Y AD es la m√©trica de ruta relativa al enrutador (vIOS4) que anunci√≥ esta red.  AD es la m√©trica FD de esta ruta en vIOS4.  Veamos la tabla de topolog√≠a en vIOS4: <br><blockquote>  P 192.168.5.0/24, 1 sucesores, FD es 512 a trav√©s de 192.168.45.5 (512/256), GigabitEthernet0 / 1 </blockquote><br>  AD en vIOS1 = FD en vIOS4.  Silencioso confuso, pero trata de explicar la l√≥gica del trabajo.  El enrutador que anuncia la ruta env√≠a los par√°metros (ancho de banda, retraso, etc.) de la ruta en el mensaje de actualizaci√≥n sin tener en cuenta el enlace entre el enrutador que se anuncia.  Es decir, vIOS4 solo tiene en cuenta los par√°metros de dos enlaces: vIOS4 Gi0 / 1 - vIOS5 Gi0 / 1 y vIOS5 Gi0 / 0 - VPC.  Habiendo recibido la actualizaci√≥n, vIOS1, sustituyendo los par√°metros obtenidos en la f√≥rmula, calcula qu√©?  As√≠ es: AD = 512.  Despu√©s de tomar los par√°metros de enlace de donde vino la ruta, vIOS1 Gi0 / 2 - vIOS4 Gi0 / 2 y los sustituye en la f√≥rmula nuevamente.  Cuenta, obtiene el n√∫mero 256 y lo suma con AD (512), obtenemos FD - 768. ¬°Estas son las cosas!  ¬øPero por qu√© todo este ritual? <br>  Y todo para crear una regla especial llamada <b>condici√≥n factible</b> , que es uno de los medios de protecci√≥n contra la formaci√≥n de bucles y la convergencia r√°pida. <br>  Definamos los siguientes t√©rminos: <br><br><ul><li>  El sucesor es un enrutador adyacente con una ruta sin bucles y la ruta de menor costo a la red de destino. </li><li>  Sucesor factible: enrutador de respaldo con ruta sin bucles (el sucesor factible AD debe ser menor que FD de la ruta del sucesor actual). </li><li>  Condici√≥n factible: el sucesor factible AD debe ser menor que el FD de la ruta del sucesor actual. </li></ul><br>  Para explicar c√≥mo funciona todo y mostrar las sutilezas, debe cambiar algunas m√©tricas.  Hagamos lo siguiente, cambie el retraso para que tengamos tales m√©tricas de enlace: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/678/c11/c2b/678c11c2b0f9b1dabb87a01ac62ff9e4.jpg" alt="Mi imagen"><br><br>  Esto se hace usando el comando de retraso en la interfaz.  Ahora hemos dicho: delay = 1 y la m√©trica es 256. Veamos qu√© m√©tricas obtenemos para la red 192.168.5.0/24 en el enrutador vIOS1: <br><br><ul><li>  A trav√©s de vIOS2 - FD = 2304, AD = 1280 </li><li>  A trav√©s de vIOS4 - FD = 1024, AD = 768 </li><li>  A trav√©s de vIOS3 - FD = 1536, AD = 768 </li></ul><br>  Como vemos que el mejor FD ser√° para la ruta a trav√©s de vIOS4, se agregar√° a la tabla de enrutamiento general, esta ruta se llama <b>Sucesor</b> : <br><blockquote>  vIOS1 # show ip route eigrp <br>  C√≥digos: L - local, C - conectado, S - est√°tico, R - RIP, M - m√≥vil, B - BGP <br>  D - EIGRP, EX - EIGRP externo, O - OSPF, IA - OSPF entre √°reas <br>  N1 - OSPF NSSA externo tipo 1, N2 - OSPF NSSA externo tipo 2 <br>  E1 - OSPF externo tipo 1, E2 - OSPF externo tipo 2 <br>  i - IS-IS, su - Resumen IS-IS, L1 - IS-IS nivel-1, L2 - IS-IS nivel-2 <br>  ia - √°rea inter IS-IS, * - candidato predeterminado, U - ruta est√°tica por usuario <br>  o - ODR, P - ruta est√°tica descargada peri√≥dicamente, H - NHRP, l - LISP <br>  a - ruta de aplicaci√≥n <br>  + - ruta replicada,% - anulaci√≥n del siguiente salto, p - anulaciones de PfR <br><br>  La puerta de enlace de √∫ltimo recurso no est√° configurada <br><br>  D 192.168.2.0/24 [90/512] a trav√©s de 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] a trav√©s de 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 </blockquote><br>  Lo que suceder√° con las otras dos rutas: se verificar√° la condici√≥n FS (condici√≥n factible).  La ruta a trav√©s de vIOS3 pasa esta condici√≥n AD (a trav√©s de vIOS3) = 768 &lt;1024 = FD (a trav√©s de vIOS1).  Por lo tanto, esta ruta, aunque no se agregar√° a la tabla de enrutamiento general, se almacenar√° en las tablas de topolog√≠a: <br><blockquote>  vIOS1 # show topolog√≠a de ip eigrp <br>  Tabla de topolog√≠a EIGRP-IPv4 para AS (1) / ID (192.168.1.1) <br>  C√≥digos: P - Pasivo, A - Activo, U - Actualizaci√≥n, Q - Consulta, R - Respuesta, <br>  r - Estado de respuesta, s - Estado de sia <br><br>  P 192.168.3.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  a trav√©s de 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  a trav√©s de 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 2 <br>  <b>P 192.168.5.0/24, 1 sucesores, FD es 1024</b> <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  <b>a trav√©s de 192.168.13.3 (1536/768), GigabitEthernet0 / 0</b> </blockquote><br>  No tiene la m√©trica de la mejor ruta, es decir, no es un Sucesor, pero desempe√±a el papel de una ruta de respaldo y, si el Sucesor se pierde, inmediatamente toma su lugar.  Esto logra una convergencia muy r√°pida del protocolo, pero m√°s sobre eso m√°s adelante.  Esta ruta se llama <b>Sucesor factible</b> .  ¬øY qu√© pasar√° con la tercera ruta?  Nada, no cumple la condici√≥n de FC (1280&gt; 1024) y no se tendr√° en cuenta para protegerlo del bucle.  Todas las rutas recibidas a trav√©s de la Actualizaci√≥n pero no probadas por FC se pueden ver usando el comando show ip eigrp topology all-links.  No est√° claro por qu√© la condici√≥n FS protege contra la formaci√≥n de bucles, ahora intentemos explicarlo.  Es importante saber que cuando se estudia el protocolo EIGRP, es vital comprender el principio de la condici√≥n FC y el prop√≥sito para el cual se utiliza.  Considere una topolog√≠a ligeramente modificada (se agreg√≥ un enlace entre vIOS2 y vIOS4), y tambi√©n use la m√©trica m√°s primitiva: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/050/472/7340504727cf56fa62300883800f363f.jpg" alt="Mi imagen"><br><br>  La ruta a la red 192.168.5.0/24 ser√° la misma con AD y FD: <br><br><ul><li>  vIOS4: a trav√©s de vIOS5, AD = 5, FD = 10. </li><li>  vIOS1: a trav√©s de vIOS4, AD = 10, FD = 11. </li><li>  vIOS3: a trav√©s de vIOS1, AD = 11, FD = 12. </li></ul><br>  Pero vIOS4 recibir√° una actualizaci√≥n de vIOS2, que contendr√° la ruta a la red 192.168.5.0/24 a trav√©s de vIOS2 con la m√©trica - AD = 12, FD = 15.  Est√° claro que no puede ser un Sucesor, si de repente esta ruta ser√≠a elegida por el Sucesor factible, entonces si el Sucesor cae en vIOS4 y el sucesor selecciona esta ruta, se producir√≠a un bucle.  Pero FC no permitir√° establecer esta ruta como FS como AD = 12&gt; 10 = FD.  La ruta a vIOS2 contiene la ruta a trav√©s de vIOS4 y, en cualquier caso, su AD tambi√©n incluye FD vIOS4.  Es decir, AD en vIOS2 contiene los siguientes enlaces: <br><blockquote>  12 = AD en vIOS2 = Gi0 / 3 vIOS3 + Gi0 / 2 vIOS4 + Gi0 / 1 vIOS5 + eth0 VPC5, donde Gi0 / 1 vIOS5 + eth0 VPC5 = FD = 10 - esto es FD vIOS4 y es imposible que AD &lt;FD sea menos </blockquote><br>  Por lo tanto, la condici√≥n FC verifica la ruta para la presencia de s√≠ misma en esta ruta.  Solo las rutas que satisfacen esta condici√≥n pueden garantizar que no haya bucles.  Puede haber casos en los que la ruta no crea un bucle, pero al mismo tiempo no satisface la condici√≥n de FC, no la usaremos, en tales casos elegimos la estabilidad de la red.  Si profundiza, la condici√≥n es bastante simple e intuitiva.  El algoritmo que selecciona las mejores rutas en el protocolo EIGRP se llama <b>DUAL</b> .  Ahora considere el protocolo EIGRP a la cuesti√≥n de la convergencia en la p√©rdida de la ruta principal.  Volvamos a nuestra vieja topolog√≠a grande e imaginemos que vIOS4 se ha ido.  Dependiendo de c√≥mo desapareci√≥ vIOS4, el comportamiento ser√° ligeramente diferente, pero ser√° diferente cuando se active el desencadenador.  Si, por ejemplo, deshabilitamos la interfaz Gi 0/2 en vIOS1, entonces vIOS1 detecta inmediatamente la p√©rdida de un vecino y comienza a actuar, si el vecino desaparece sin previo aviso, Hold Timer funcionar√° despu√©s de que no reciba paquetes de saludo durante 15 segundos: <br><blockquote>  D 192.168.2.0/24 [90/512] a trav√©s de 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] a trav√©s de 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] a trav√©s de 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br><br>  P 192.168.3.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  a trav√©s de 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  a trav√©s de 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 sucesores, FD es 512 <br>  a trav√©s de Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 sucesores, FD es 768 <br>  a trav√©s de Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 sucesores, FD es 256 <br>  a trav√©s de Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 1 sucesores, FD es 1024 <br>  a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  a trav√©s de 192.168.13.3 (1536/768), GigabitEthernet0 / 0 </blockquote><br>  Traje la tabla de enrutamiento y topolog√≠a nuevamente por conveniencia, de modo que para comprender c√≥mo actuar√° el enrutador en cada ruta, debes saber en qu√© estado se encontraban antes.  Por ejemplo, la ruta que discutimos anteriormente, la ruta 192.168.5.0/24 se perder√°, pero ten√≠a FS en la tabla de topolog√≠a y, por lo tanto, tan pronto como se pierda la ruta principal, ocupar√° su lugar en la tabla de enrutamiento.  Una pregunta interesante es qu√© pasar√° con las rutas sin FS.  Pero un poco de hardware: <br><br>  Las entradas en la tabla de topolog√≠a pueden estar en dos estados: activo y pasivo.  La ruta est√° en un estado pasivo cuando la ruta es estable y no se busca la mejor ruta.  En estado activo, si est√° buscando la mejor ruta.  Se realiza una b√∫squeda de ruta cuando no hay un sucesor factible para la red de destino.  El enrutador, en busca de una ruta mejor, env√≠a una solicitud (env√≠a un paquete de consulta) a cada enrutador vecino.  Si el vecino tiene una ruta a la red de destino, responde (env√≠a un paquete de respuesta), si no hay una ruta, el vecino env√≠a una solicitud a sus vecinos.  El enrutador compara todos los FD para llegar a una red espec√≠fica, selecciona la ruta con el FD m√°s peque√±o y lo coloca en la tabla de enrutamiento.  La tabla de topolog√≠a puede almacenar 6 rutas a la red del destinatario (principal y de respaldo). <br><br>  Las rutas que se perdieron y no ten√≠an FS cambiar√°n a Activo y vIOS1 comenzar√° a preguntar sobre sus vecinos restantes.  Esto se realiza mediante mensajes de consulta.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 enviar√° mensajes de consulta a los enrutadores vIOS2 y vIOS3, donde indicar√° claramente qu√© rutas necesita; en nuestro caso, tales rutas ser√°n 192.168.14.0/24, 192.168.45.0/24. Con este mensaje, vIOS1 tambi√©n informa a los enrutadores que las rutas a trav√©s de vIOS1 a estas redes no se pueden usar. Esto se hace especificando el par√°metro Delay: Infifnity en la m√©trica de esta ruta, es decir, la m√©trica es infinitamente grande. Tan pronto como los enrutadores reciban dichos mensajes, eliminar√°n estas rutas a trav√©s de vIOS1. Esta tecnolog√≠a se llama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Poison Reverse tambi√©n se usa para mensajes de actualizaci√≥n, hablar√© de esto un poco m√°s tarde. Despu√©s de recibir una consulta con una solicitud de rutas 192.168.14.0/24, 192.168.45.0/24, vIOS2 y vIOS3 ver√°n si tienen estas rutas, que usan, si las hay, enviar√°n inmediatamente una respuesta con nuevas m√©tricas para estas rutas. vIOS2 y vIOS3, como sabemos, no perdieron sus rutas, por lo que enviar√°n inmediatamente una respuesta. Si el enrutador que tambi√©n se le solicita no tiene esta ruta, reenviar√° la consulta a sus vecinos y as√≠ sucesivamente. vIOS1 esperar√° la respuesta de vIOS2, vIOS3 y luego Active Timer entrar√° en escena, que comenzar√° tan pronto como se env√≠e la consulta: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el intervalo de tiempo durante el cual la ruta puede permanecer en el estado activo. Si el temporizador caduca antes de que se reciban todas las respuestas de los vecinos (Respuesta), el enrutador pone la ruta en un estado atascado en activo. Adem√°s, las relaciones del vecindario se rompen con aquellos vecinos de quienes no se recibi√≥ respuesta. Por defecto, este temporizador es de 3 minutos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, si la respuesta no se recibe en 3 minutos, a pesar de los paquetes de saludo, el vecindario se romper√° y esto es muy malo. A pesar de que 3 minutos es como una eternidad para tales protocolos, tales situaciones son posibles con grandes topolog√≠as. Para protegerse contra la ruptura err√≥nea de la relaci√≥n del vecindario, se inventaron mensajes especiales: SIA-Query y SIA-Reply.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para mejorar la respuesta del enrutador al estado de la ruta activa, se introducen adicionalmente dos tipos de mensajes: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consulta SIA: se env√≠a despu√©s de 1,5 minutos (predeterminado) para verificar el estado de un enrutador conectado directamente. </font><font style="vertical-align: inherit;">Para que, si se pierde la ruta que est√° detr√°s del vecino (mientras la conexi√≥n con el vecino es normal), las relaciones de vecindario con el enrutador conectado directamente no se restablecen. </font><font style="vertical-align: inherit;">No requiere confirmaci√≥n de recibo. </font><font style="vertical-align: inherit;">Despu√©s de enviar tres mensajes y no recibir una respuesta, el vecino se considera inactivo y la ruta se elimina de la tabla de topolog√≠a.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Reply: se envi√≥ en respuesta a SIA-Query. </font><font style="vertical-align: inherit;">No requiere confirmaci√≥n de recibo.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de 1,5 minutos, si no se recibe la respuesta a cualquier consulta, se env√≠a la consulta SIA, que no requiere una nueva ruta, pero solo necesita enviar una respuesta SIA, para asegurarse de que el vecino est√© en orden, simplemente no puede encontrar la correcta ruta </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pienso en c√≥mo reacciona el enrutador a la p√©rdida de la ruta en el caso de que haya FS o no, dijimos lo suficiente. Solo es necesario hacer cambios a lo siguiente. No proporcionamos una definici√≥n correcta de FD, la m√©trica que calculamos de acuerdo con la f√≥rmula cuando recibimos una ruta por primera vez o cuando el estado de la ruta cambia a√∫n m√°s, ser√≠a correcto llamar a CD - Distancia calculada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD es el mejor indicador para una ruta dada que se haya obtenido, y es √©l quien participa en la verificaci√≥n de FC. </font><font style="vertical-align: inherit;">Muy a menudo, FD = CD es la mejor ruta, pero veamos c√≥mo FD ha cambiado despu√©s del colapso del vecindario con vIOS4:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 sucesores, FD es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a trav√©s de 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.536 mil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 768), GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya no tenemos una ruta con CD = 1024, la mejor ruta a trav√©s de vIOS3 es CD = 1536, pero como puede ver, FD = 1024, que se solucion√≥ cuando hab√≠a una ruta a trav√©s de vIOS4. </font><font style="vertical-align: inherit;">FD se actualizar√° solo cuando esta ruta pase al estado Activo. </font><font style="vertical-align: inherit;">Hasta que el estado cambie de Pasivo a Activo, FD tampoco cambiar√°. </font><font style="vertical-align: inherit;">Las actualizaciones regulares no se aplican a √©l. </font><font style="vertical-align: inherit;">Un comentario m√°s. </font><font style="vertical-align: inherit;">Hagamos este experimento: devuelva el vecindario con vIOS4, CD a trav√©s de vIOS3 = 1536 y a trav√©s de vIOS2 = 2048. Aumente el retraso del canal entre vIOS1 y vIOS3 para que sea m√°s grande que el CD de vIOS2:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 sucesores, FD es 1024 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a trav√©s de 192.168.14.4 (1024/768), GigabitEthernet0 / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a trav√©s de 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.304</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 768), GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vemos el CD a trav√©s de vIOS3 = 2304, pero se mantuvo FS ya que AD no cambi√≥ y la condici√≥n de FC se cumpli√≥, como antes. </font><font style="vertical-align: inherit;">Nos hacemos una pregunta: ¬øqu√© sucede cuando se pierde una ruta a trav√©s de vIOS2? </font><font style="vertical-align: inherit;">La respuesta esperada y l√≥gica, como nos ense√±aron, es FS, ¬°pero no! </font><font style="vertical-align: inherit;">Como todav√≠a hay una ruta a trav√©s de vIOS2 con CD = 2048 &lt;2304, la ruta pasar√° al estado Activo y volver√° a calcular la m√©trica para ella y seleccionar√° la mejor ruta a pesar de que ten√≠a una ruta de respaldo. </font><font style="vertical-align: inherit;">Observamos la tabla de topolog√≠a y obtenemos:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 sucesores, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD es 2048 a</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trav√©s de 192.168.12.2 (2048/1280), GigabitEthernet0 / 3 a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trav√©s de 192.168.13.3 (2304/768), GigabitEthernet0 / 0</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se utilizar√° la ruta a trav√©s de vIOS2 y, como se√±al√≥ FD, tambi√©n cambi√≥ debido a la transici√≥n de la ruta al estado Activo. </font><font style="vertical-align: inherit;">Y la ruta a trav√©s de vIOS3 nuevamente comparte el destino del repuesto.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reglas divididas de horizonte dividido y veneno en EIGRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que en RIP, EIGRP usa la regla Split Horizon: si se puede acceder a una ruta a trav√©s de una interfaz espec√≠fica, esta ruta no se incluye en la actualizaci√≥n que se env√≠a a trav√©s de esta interfaz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, si vIOS4 recibe una ruta a la red 192.168.0.0/24 desde vIOS1, no enviar√° esta ruta a Actualizar a trav√©s de la interfaz a la que est√° conectado vIOS1. Para ser m√°s precisos, imagine que vIOS1 comenz√≥ a hablar sobre la red 192.168.0.0/24. Envi√© la actualizaci√≥n a vIOS4, vIOS4 la recibir√° y, por regla general, Split Horizon no deber√≠a enviar su actualizaci√≥n con esta ruta a vIOS1, pero en realidad lo enviar√° con una m√©trica infinita. Como si vIOS4 dice vIOS1- "No te atrevas a usar la ruta a la red 192.168.0.0/24 a trav√©s de m√≠, recib√≠ esta ruta de ti y si la usas, habr√° un bucle".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invertir veneno: indica una ruta inalcanzable utilizando una m√©trica cuando se pierde. </font><font style="vertical-align: inherit;">En EIGRP, esto se hace usando el par√°metro Delay. </font><font style="vertical-align: inherit;">Indicamos anteriormente c√≥mo se usa esta tecnolog√≠a cuando vIOS1 perdi√≥ contacto con vIOS4. </font><font style="vertical-align: inherit;">De lo anterior sobre Split Horizon, podemos concluir que la tecnolog√≠a Poison Reverse se usa no solo en los mensajes de consulta, sino tambi√©n en la actualizaci√≥n. </font><font style="vertical-align: inherit;">Adem√°s, Poison Reverse puede violar la regla de Split Horizon y enviar una actualizaci√≥n con m√©tricas infinitas desde la interfaz desde la que recibi√≥ esta actualizaci√≥n. </font><font style="vertical-align: inherit;">Estas dos reglas, junto con la cl√°usula FC, proporcionan protecci√≥n de protocolo EIGRP contra bucles.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routers de trozos </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como optimizaci√≥n, se introdujo una funci√≥n especial para los enrutadores en el protocolo: Stub. </font><font style="vertical-align: inherit;">Algo as√≠ como la zona Stub en OSPF, pero aqu√≠ hay un principio de operaci√≥n ligeramente diferente. </font><font style="vertical-align: inherit;">Al configurar el enrutador en modo stub, inmediatamente informa en paquetes Hello a su vecino sobre su estado y, dependiendo del modo stub, puede enviar ciertos tipos de rutas:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS5 # eigrp stub [conectado | </font><font style="vertical-align: inherit;">mapa de fugas | </font><font style="vertical-align: inherit;">solo recepci√≥n | </font><font style="vertical-align: inherit;">redistribuido | </font><font style="vertical-align: inherit;">est√°tica | </font><font style="vertical-align: inherit;">resumen]</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opciones de comando de stub de Eigrp: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sin opciones (predeterminado): conectado y resumen; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conectado: permite que el enrutador de c√≥digo auxiliar env√≠e rutas conectadas, pero solo para las interfaces cuyas direcciones se encuentran en las redes especificadas por el comando de red; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mapa de fugas: permite prefijos din√°micos basados ‚Äã‚Äãen el mapa de fugas; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo recepci√≥n: evita que el enrutador de c√≥digo auxiliar env√≠e rutas; </font></font></li><li> redistributed ‚Äî  stub   redistributed ; </li><li> static ‚Äî  stub   static ,  ,      ; </li><li> summary ‚Äî  stub     (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero la caracter√≠stica principal de esta configuraci√≥n es que si el enrutador sabe que su vecino est√° en la funci√≥n Stub, no le enviar√° consultas para las rutas que se han vuelto activas. </font><font style="vertical-align: inherit;">Por ejemplo, si configuramos vIOS5 como Stub, vIOS2-4 se enterar√° de esto y, si se pierden rutas, no envenenar√°n la consulta. </font><font style="vertical-align: inherit;">Teniendo en cuenta qu√© problemas pueden surgir en ausencia de respuesta, ser√≠a bueno enviar consultas solo donde tenga sentido. </font><font style="vertical-align: inherit;">Esto es importante en grandes topolog√≠as donde la convergencia puede ser un proceso complejo. </font><font style="vertical-align: inherit;">Por lo tanto, si hay un enrutador que es final y solo las redes de usuarios est√°n conectadas a √©l (relativamente hablando, solo tiene un vecino), entonces es mejor pensar en configurarlo como un Stub.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunas palabras sobre temporizadores </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hablamos sobre algunos de ellos, si observa el resultado del comando show ip eigrp neighbours, veremos lo siguiente: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 # show ip eigrp neighbours </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIGRP-IPv4 Neighbours for AS (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H Address Interface Hold Uptime SRTT RTO Q Seq </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sec) (ms) Cnt Num </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 192.168.14.4 Gi0 / 2 11 00:48:43 23 138 0 168 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 192.168.12.2 Gi0 / 3 12 02:31:12 6100 0258 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 192.168.13.3 Gi0 / 0 10 2d13h </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7100 0291 vIOS1 #</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay temporizadores que requieren explicaci√≥n. </font><font style="vertical-align: inherit;">Si, en respuesta al env√≠o de cualquier paquete de multidifusi√≥n que requiera confirmaci√≥n de recepci√≥n, no se ha enviado un acuse de recibo (ACK), entonces el paquete de unidifusi√≥n se transmitir√° al vecino que no est√° respondiendo. </font><font style="vertical-align: inherit;">Si la confirmaci√≥n no se recibi√≥ incluso despu√©s de que se enviaron 16 paquetes de unidifusi√≥n, el vecino se considera inactivo.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo suave de ida y vuelta (SRTT)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el tiempo entre enviar un paquete a un vecino y recibir la confirmaci√≥n de √©l. </font><font style="vertical-align: inherit;">Medido en milisegundos. </font><font style="vertical-align: inherit;">La f√≥rmula de c√°lculo es propietaria.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temporizador de flujo de multidifusi√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el valor m√°ximo del intervalo en segundos durante el cual el enrutador esperar√° el paquete ACK despu√©s de enviar el paquete EIGRP a la direcci√≥n de multidifusi√≥n antes de cambiar al env√≠o de unidifusi√≥n. </font><font style="vertical-align: inherit;">Se calcula sobre la base de SRTT, la f√≥rmula de c√°lculo en s√≠ es propietaria.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo de espera de retransmisi√≥n (RTO):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intervalo entre el env√≠o de paquetes de unidifusi√≥n. </font><font style="vertical-align: inherit;">Se calcula sobre la base de SRTT, la f√≥rmula de c√°lculo en s√≠ es propietaria.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre esto pienso terminar el art√≠culo. </font><font style="vertical-align: inherit;">A continuaci√≥n hay un enlace √∫til:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cisconinja.wordpress.com/2009/09/18/eigrp-sia-query-and-sia-reply </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru/wiki/EIGRP</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=FYUK7blhCZk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un seminario web sobre EIGRP durante aproximadamente 4 horas y media. </font><font style="vertical-align: inherit;">Requerido para ver)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html#anc9</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420667/">https://habr.com/ru/post/es420667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420657/index.html">An√°lisis: de cuyo dinero Elon Musk podr√° retirar a Tesla del intercambio</a></li>
<li><a href="../es420659/index.html">Campa√±a USB de HRF (Human Rights Foundation) "Flash Drives for Freedom"</a></li>
<li><a href="../es420661/index.html">Infraestructura continua en la nube</a></li>
<li><a href="../es420663/index.html">M√©tricas simples y una forma de ahorrar tiempo al buscar problemas en la infraestructura</a></li>
<li><a href="../es420665/index.html">Creaci√≥n de una aplicaci√≥n en .NET Core y Kubernetes: nuestra experiencia</a></li>
<li><a href="../es420669/index.html">Descripci√≥n general del mercado de automatizaci√≥n empresarial: soluciones para empresas de construcci√≥n y administraci√≥n de viviendas y servicios p√∫blicos</a></li>
<li><a href="../es420671/index.html">[Ekaterinburg, anuncio] UralJS # 9 - tres informes sobre microservicios, pruebas y registro de errores en el frente</a></li>
<li><a href="../es420673/index.html">Docker para Symfony 4: de LAN a producci√≥n</a></li>
<li><a href="../es420675/index.html">SOC son personas. "Hola, estamos buscando talento" o de d√≥nde provienen los analistas del centro de monitoreo y respuesta a ataques cibern√©ticos</a></li>
<li><a href="../es420677/index.html">La historia de c√≥mo Epson proporcion√≥ al planeta 30 millones de "f√°bricas"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>