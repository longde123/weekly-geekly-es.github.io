<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎓 👩🏼‍🤝‍👨🏿 🐅 Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode für reguläre Ausdrücke 👨🏾‍🤝‍👨🏽 ☦️ 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Täglich finden in Badoo 17 Milliarden Veranstaltungen, 60 Millionen Benutzersitzungen und eine Vielzahl virtueller Termine statt. Jedes Ereignis wird ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode für reguläre Ausdrücke</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433054/"><p><img src="https://habrastorage.org/webt/kz/rl/nu/kzrlnugblhii_j4jrsqzdk9fsgo.jpeg"></p><br><p>  Täglich finden in Badoo 17 Milliarden Veranstaltungen, 60 Millionen Benutzersitzungen und eine Vielzahl virtueller Termine statt.  Jedes Ereignis wird übersichtlich in relationalen Datenbanken gespeichert und anschließend in SQL und darüber hinaus analysiert. </p><br><p>  Moderne verteilte Transaktionsdatenbanken mit Dutzenden von Terabyte Daten - ein wahres Wunder der Technik.  SQL als Verkörperung der relationalen Algebra in den meisten Standardimplementierungen erlaubt es uns jedoch noch nicht, Abfragen in Form von geordneten Tupeln zu formulieren. </p><br><p>  Im letzten Artikel einer Reihe über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuelle</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maschinen</a> werde ich über einen alternativen Ansatz zum Finden interessanter Sitzungen sprechen - die reguläre Ausdrucks-Engine ( <a href="">Pig Match</a> ), die für Ereignissequenzen definiert ist. </p><br><p>  Virtuelle Maschine, Bytecode und Compiler sind kostenlos enthalten! </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil, Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil, Optimierung</a> <br>  Dritter Teil, angewendet (aktuell) </p><br><h1 id="o-sobytiyah-i-sessiyah">  Über Ereignisse und Sitzungen </h1><br><p>  Angenommen, wir haben bereits ein Data Warehouse, mit dem Sie die Ereignisse jeder Benutzersitzung schnell und nacheinander anzeigen können. </p><br><p> Wir möchten Sitzungen anhand von Anforderungen wie "Alle Sitzungen zählen, bei denen eine bestimmte Teilsequenz von Ereignissen vorhanden ist", "Teile einer Sitzung, die durch ein bestimmtes Muster beschrieben wurden", "Den Teil der Sitzung zurückgeben, der nach einem bestimmten Muster stattgefunden hat" oder "Zählen, wie viele Sitzungen bestimmte Teile erreicht haben" suchen Vorlage. "  Dies kann für eine Vielzahl von Analysetypen nützlich sein: Suche nach verdächtigen Sitzungen, Trichteranalyse usw. </p><br><p>  Die gewünschten Teilsequenzen müssen irgendwie beschrieben werden.  In ihrer einfachsten Form ähnelt diese Aufgabe dem Auffinden eines Teilstrings in einem Text.  Wir wollen ein leistungsfähigeres Werkzeug - reguläre Ausdrücke.  Moderne Implementierungen von Engines für reguläre Ausdrücke verwenden am häufigsten (Sie haben es erraten!) Virtuelle Maschinen. </p><br><p>  Die Erstellung kleiner virtueller Maschinen zum Abgleichen von Sitzungen mit regulären Ausdrücken wird nachstehend erläutert.  Aber zuerst werden wir die Definitionen klarstellen. </p><br><p>  <em>Ein Ereignis</em> besteht aus einem Ereignistyp, einer Zeit, einem Kontext und einer Reihe von Attributen, die für jeden Typ spezifisch sind. </p><br><p>  <em>Der Typ</em> und der <em>Kontext</em> jedes Ereignisses sind Ganzzahlen aus vordefinierten Listen.  Wenn bei den Ereignistypen alles klar ist, ist der Kontext beispielsweise die Nummer des Bildschirms, auf dem das angegebene Ereignis aufgetreten ist. </p><br><p>  <em>Ein</em> Ereignisattribut ist eine beliebige Ganzzahl, deren Bedeutung durch den Ereignistyp bestimmt wird.  Ein Ereignis hat möglicherweise keine oder mehrere Attribute. </p><br><p>  <em>Eine Sitzung</em> ist eine Folge von Ereignissen, die nach Zeit sortiert sind. </p><br><p>  Aber kommen wir endlich zur Sache.  Das Summen ließ nach, und ich ging auf die Bühne. </p><br><h1 id="sravnivaem-po-bumazhke">  Vergleiche auf einem Stück Papier </h1><br><p><img src="https://habrastorage.org/webt/gu/ec/dw/guecdwuc3rhjl1oc6cvuk-4ec9k.jpeg"></p><br><p>  Ein Merkmal dieser virtuellen Maschine ist die Passivität in Bezug auf Eingabeereignisse.  Wir möchten nicht die gesamte Sitzung im Speicher behalten und der virtuellen Maschine ermöglichen, unabhängig von Ereignis zu Ereignis zu wechseln.  Stattdessen werden Ereignisse nacheinander aus der Sitzung in die virtuelle Maschine eingespeist. </p><br><p>  Definieren wir die Schnittstellenfunktionen: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">matcher *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *matcher)</span></span></span></span>;</code> </pre> <br><p>  Wenn mit den Funktionen matcher_create und matcher_destroy alles klar ist, ist matcher_accept einen Kommentar wert.  Die Funktion matcher_accept empfängt eine Instanz der virtuellen Maschine und des nächsten Ereignisses (32 Bit, wobei 16 Bit für den Ereignistyp und 16 Bit für den Kontext) und gibt einen Code zurück, in dem erläutert wird, was der Benutzercode als Nächstes tun soll: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { <span class="hljs-comment"><span class="hljs-comment">//       MATCH_NEXT, //    ,      MATCH_OK, //       ,      MATCH_FAIL, //     MATCH_ERROR, } match_result;</span></span></code> </pre><br><p>  Opcodes der virtuellen Maschine: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { <span class="hljs-comment"><span class="hljs-comment">//  ,      OP_ABORT, //      ( -  ) OP_NAME, //     ( -  ) OP_SCREEN, //    OP_NEXT, //    OP_MATCH, } matcher_opcode;</span></span></code> </pre><br><p>  Die Hauptschleife einer virtuellen Maschine: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP() \ (*m-&gt;ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG() \ ((void)(m-&gt;ip += 2), (m-&gt;ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + m-&gt;ip[-1]) for (;;) { uint8_t instruction = NEXT_OP(); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(); if (event_name(next_event) != name) return MATCH_FAIL; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(); if (event_screen(next_event) != screen) return MATCH_FAIL; break; } case OP_NEXT:{ return MATCH_NEXT; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre> <br><p>  In dieser einfachen Version stimmt unsere virtuelle Maschine das durch Bytecode beschriebene Muster nacheinander mit eingehenden Ereignissen ab.  Insofern ist dies einfach kein sehr präziser Vergleich der <em>Präfixe</em> zweier Zeilen: der gewünschten Vorlage und der Eingabezeile. </p><br><p>  Präfixe sind Präfixe, aber wir möchten die gewünschten Muster nicht nur am Anfang, sondern auch an einer beliebigen Stelle in der Sitzung finden.  Die naive Lösung besteht darin, den Abgleich von jedem Sitzungsereignis neu zu starten.  Dies impliziert jedoch die mehrfache Betrachtung jedes Ereignisses und das Essen algorithmischer Babys. </p><br><p>  <a href="">Das Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel der</a> Serie simuliert praktisch den Neustart eines Matches mithilfe von Rollback (englisches Backtracking).  Der Code im Beispiel sieht natürlich schlanker aus als der hier angegebene, aber das Problem ist nicht behoben: Jedes der Ereignisse muss mehrmals überprüft werden. </p><br><p>  So kannst du nicht leben. </p><br><h1 id="ya-esche-raz-ya-i-snova-ya">  Ich, ich wieder und ich wieder </h1><br><p><img src="https://habrastorage.org/webt/bq/ue/gt/bquegtp3mpd4rxv65f1fk-svdjk.jpeg"></p><br><p>  Lassen Sie uns das Problem noch einmal skizzieren: Wir müssen die Vorlage mit eingehenden Ereignissen abgleichen, beginnend mit jedem der Ereignisse, die einen neuen Vergleich starten.  Warum machen wir das nicht einfach?  Lassen Sie die virtuelle Maschine eingehende Ereignisse in mehreren Threads bearbeiten! </p><br><p>  Dazu benötigen wir eine neue Entität - einen Stream.  Jeder Thread speichert einen einzelnen Zeiger - auf die aktuelle Anweisung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher_thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; } matcher_thread;</code> </pre><br><p>  Natürlich werden wir jetzt in der virtuellen Maschine selbst den expliziten Zeiger nicht speichern.  Es wird durch zwei Thread-Listen ersetzt (mehr dazu weiter unten): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytecode; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the current event */</span></span> matcher_thread current_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> current_thread_num; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the event to follow */</span></span> matcher_thread next_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> next_thread_num; } matcher;</code> </pre><br><p>  Und hier ist die aktualisierte Hauptschleife: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP(thread) \ (*(thread).ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG(thread) \ ((void)((thread).ip += 2), ((thread).ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + (thread).ip[-1]) /*         - */ add_current_thread(m, initial_thread(m)); //         for (size_t thread_i = 0; thread_i &lt; m-&gt;current_thread_num; thread_i++ ) { matcher_thread current_thread = m-&gt;current_threads[thread_i]; bool thread_done = false; while (!thread_done) { uint8_t instruction = NEXT_OP(current_thread); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(current_thread); //  ,      ,    //     next_threads,    if (event_name(next_event) != name) thread_done = true; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(current_thread); if (event_screen(next_event) != screen) thread_done = true; break; } case OP_NEXT:{ //    , ..      // next_threads add_next_thread(m, current_thread); thread_done = true; break; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } } /*      ,    */ swap_current_and_next(m); return MATCH_NEXT; #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre><br><p>  Bei jedem empfangenen Ereignis fügen wir zuerst einen neuen Thread zur Liste current_threads hinzu und überprüfen die Vorlage von Anfang an. Danach durchlaufen wir die Liste current_threads und folgen jedem Zeiger, indem wir den Anweisungen folgen. </p><br><p>  Wenn eine NEXT-Anweisung angetroffen wird, wird der Thread in die Liste next_threads eingefügt, dh er wartet auf den Empfang des nächsten Ereignisses. </p><br><p>  Wenn das Thread-Muster nicht mit dem empfangenen Ereignis übereinstimmt, wird ein solcher Thread einfach nicht zur Liste next_threads hinzugefügt. </p><br><p>  Der MATCH-Befehl beendet die Funktion sofort und meldet einen Rückkehrcode, dass das Muster mit der Sitzung übereinstimmt. </p><br><p>  Nach Abschluss des Crawls der Thread-Liste werden die aktuelle und die nächste Liste ausgetauscht. </p><br><p>  Eigentlich ist das alles.  Wir können sagen, dass wir buchstäblich das tun, was wir wollten: Gleichzeitig überprüfen wir mehrere Vorlagen und starten für jedes Sitzungsereignis einen neuen Übereinstimmungsprozess. </p><br><h1 id="mnozhestvennye-lichnosti-i-vetvleniya-v-shablonah">  Mehrere Identitäten und Zweige in Vorlagen </h1><br><p><img src="https://habrastorage.org/webt/8l/gv/-e/8lgv-e5bp1xhv0ksukeacrhasaq.jpeg"></p><br><p>  Die Suche nach einer Vorlage, die eine lineare Abfolge von Ereignissen beschreibt, ist natürlich nützlich, aber wir möchten vollständige reguläre Ausdrücke erhalten.  Und die Flows, die wir in der vorherigen Phase erstellt haben, sind auch hier nützlich. </p><br><p>  Angenommen, wir möchten eine Folge von zwei oder drei Ereignissen finden, die für uns von Interesse sind, so etwas wie ein regulärer Ausdruck in Zeilen: "a? Bc".  In dieser Reihenfolge ist das Symbol "a" optional.  Wie drücke ich es in Bytecode aus?  Einfach! </p><br><p>  Wir können <em>zwei</em> Threads starten, jeweils einen: mit dem Symbol "a" und ohne.  Zu diesem Zweck führen wir eine zusätzliche Anweisung (vom SPLIT-Typ addr1, addr2) ein, die zwei Threads von den angegebenen Adressen aus startet.  Neben SPLIT ist JUMP auch für uns nützlich, da die Ausführung einfach mit der im direkten Argument angegebenen Anweisung fortgesetzt wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { OP_ABORT, OP_NAME, OP_SCREEN, OP_NEXT, <span class="hljs-comment"><span class="hljs-comment">//     OP_JUMP, //         OP_SPLIT, OP_MATCH, //     OP_NUMBER_OF_OPS, } matcher_opcode;</span></span></code> </pre> <br><p>  Die Schleife selbst und der Rest der Anweisungen ändern sich nicht - wir stellen nur zwei neue Handler vor: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... case OP_JUMP:{ /*   ,      */ uint16_t offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, offset)); break; } case OP_SPLIT:{ /*        */ uint16_t left_offset = NEXT_ARG(current_thread); uint16_t right_offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, left_offset)); add_current_thread(m, create_thread(m, right_offset)); break; } // ...</span></span></code> </pre><br><p>  Beachten Sie, dass die Anweisungen der aktuellen Liste Threads hinzufügen, dh, sie funktionieren weiterhin im Kontext des aktuellen Ereignisses.  Der Thread, in dem der Zweig aufgetreten ist, wird nicht in die Liste der folgenden Threads aufgenommen. </p><br><p>  Das Erstaunlichste an dieser virtuellen Maschine mit regulären Ausdrücken ist, dass unsere Threads und dieses Anweisungspaar ausreichen, um fast alle Konstruktionen auszudrücken, die beim Abgleichen von Zeichenfolgen allgemein akzeptiert werden. </p><br><h1 id="regulyarnye-vyrazheniya-na-sobytiyah">  Regelmäßige Ausdrücke zu Ereignissen </h1><br><p>  Jetzt, da wir eine geeignete virtuelle Maschine und Tools dafür haben, können wir uns tatsächlich mit der Syntax für unsere regulären Ausdrücke befassen. </p><br><p>  Die manuelle Aufzeichnung von Opcodes für ernstere Programme wird schnell müde.  Das letzte Mal habe ich keinen vollwertigen Parser erstellt, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">echte</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzer hat</a> die Funktionen seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raddsl-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Beispiel der PigletC</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minisprache gezeigt</a> .  Ich war so beeindruckt von der Kürze des Codes, dass ich mit Hilfe von raddsl einen kleinen Compiler mit regulären Ausdrücken von Zeichenfolgen in hundert oder zweihundert in Python schrieb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Compiler</a> und seine Gebrauchsanweisung befinden sich auf GitHub.  Das Ergebnis des Compilers in Assemblersprache wird von einem Dienstprogramm verstanden, das zwei Dateien liest (ein Programm für eine virtuelle Maschine und eine Liste von Sitzungsereignissen zur Überprüfung). </p><br><p>  Zunächst beschränken wir uns auf die Art und den Kontext des Ereignisses.  Die Art des Ereignisses wird durch eine einzelne Zahl angegeben.  Wenn Sie einen Kontext angeben müssen, geben Sie ihn über einen Doppelpunkt an.  Das einfachste Beispiel: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13" # ,     13 NEXT NAME 13 MATCH</code> </pre> <br><p>  Nun ein Beispiel mit Kontext: </p><br><pre> <code class="plaintext hljs">python regexp/regexp.py "13:12" #  13,  12 NEXT NAME 13 SCREEN 12 MATCH</code> </pre> <br><p>  Aufeinanderfolgende Ereignisse müssen irgendwie getrennt sein (z. B. durch Leerzeichen): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13 11 10:9" 08:40:52 NEXT NAME 13 NEXT NAME 11 NEXT NAME 10 SCREEN 9 MATCH</code> </pre> <br><p>  Vorlage interessanter: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "12|13" SPLIT L0 L1 L0: NEXT NAME 12 JUMP L2 L1: NEXT NAME 13 L2: MATCH</code> </pre> <br><p>  Achten Sie auf die Zeilen, die mit einem Doppelpunkt enden.  Dies sind Tags.  Der SPLIT-Befehl erstellt zwei Threads, die die Ausführung von den Bezeichnungen L0 und L1 fortsetzen, und JUMP am Ende des ersten Ausführungszweigs fährt einfach bis zum Ende des Zweigs fort. </p><br><p>  Sie können wahrheitsgemäßer zwischen Ausdrucksketten wählen, indem Sie Teilsequenzen in Klammern gruppieren: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "(1 2 3)|4" SPLIT L0 L1 L0: NEXT NAME 1 NEXT NAME 2 NEXT NAME 3 JUMP L2 L1: NEXT NAME 4 L2: MATCH</code> </pre> <br><p>  Ein beliebiges Ereignis wird durch einen Punkt angezeigt: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py ". 1" NEXT NEXT NAME 1 MATCH</code> </pre> <br><p>  Wenn wir zeigen wollen, dass die Teilsequenz optional ist, setzen wir ein Fragezeichen danach: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1 2 3? 4" NEXT NAME 1 NEXT NAME 2 SPLIT L0 L1 L0: NEXT NAME 3 L1: NEXT NAME 4 MATCH</code> </pre> <br><p>  Natürlich sind auch mehrere reguläre Wiederholungen (Plus oder Sternchen) in regulären Ausdrücken üblich: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1+ 2" L0: NEXT NAME 1 SPLIT L0 L1 L1: NEXT NAME 2 MATCH</code> </pre> <br><p>  Hier führen wir den SPLIT-Befehl einfach viele Male aus und starten bei jedem Zyklus neue Threads. </p><br><p>  Ähnlich mit einem Sternchen: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1* 2" L0: SPLIT L1 L2 L1: NEXT NAME 1 JUMP L0 L2: NEXT NAME 2 MATCH</code> </pre> <br><p><img src="https://habrastorage.org/webt/g-/ud/3s/g-ud3s00i4ccyhf4lp5huusjlyu.jpeg"></p><br><h1 id="perspektiva">  Perspektive </h1><br><p>  Andere Erweiterungen der beschriebenen virtuellen Maschine können nützlich sein. </p><br><p>  Zum Beispiel kann es einfach erweitert werden, indem Ereignisattribute überprüft werden.  Für ein reales System nehme ich an, eine Syntax wie "1: 2 {3: 4, 5:&gt; 3}" zu verwenden, was bedeutet: Ereignis 1 in Kontext 2 mit Attribut 3 mit Wert 4 und Attributwert 5 größer als 3. Attribute hier Sie können es einfach in einem Array an die Funktion matcher_accept übergeben. </p><br><p>  Wenn Sie auch das Zeitintervall zwischen Ereignissen an matcher_accept übergeben, können Sie der Vorlagensprache eine Syntax hinzufügen, mit der Sie die Zeit zwischen Ereignissen überspringen können: "1 mindelta (120) 2", was bedeutet: Ereignis 1, dann ein Zeitraum von mindestens 120 Sekunden, Ereignis 2 In Kombination mit der Beibehaltung einer Teilsequenz können Sie so Informationen zum Benutzerverhalten zwischen zwei Teilsequenzen von Ereignissen sammeln. </p><br><p>  Andere nützliche Dinge, die relativ einfach hinzuzufügen sind, sind: Beibehalten von Teilsequenzen regulärer Ausdrücke, Trennen von gierigen und gewöhnlichen Sternchen- und Plus-Operatoren usw.  In Bezug auf die Theorie der Automaten ist unsere virtuelle Maschine ein nicht deterministischer endlicher Automat, für dessen Implementierung es nicht schwierig ist, solche Dinge zu tun. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Unser System wurde für schnelle Benutzeroberflächen entwickelt, daher ist die Sitzungsspeicher-Engine selbst geschrieben und speziell für den Durchgang durch alle Sitzungen optimiert.  Alle Milliarden von Ereignissen, die in Sitzungen aufgeteilt wurden, werden auf einem einzelnen Server in Sekundenschnelle mit Mustern verglichen. </p><br><p>  Wenn die Geschwindigkeit für Sie nicht so kritisch ist, kann ein ähnliches System als Erweiterung für ein Standard-Datenspeichersystem wie eine herkömmliche relationale Datenbank oder ein verteiltes Dateisystem konzipiert werden. </p><br><p>  Übrigens ist in den neuesten Versionen des <a href="">SQL-Standards bereits eine</a> ähnliche Funktion wie im Artikel beschrieben erschienen, und einzelne Datenbanken ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vertica</a> ) haben sie bereits implementiert.  Yandex ClickHouse implementiert seinerseits eine eigene SQL-ähnliche Sprache, verfügt jedoch auch über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ähnliche Funktionen</a> . </p><br><p>  Ich möchte von Ereignissen und regulären Ausdrücken ablenken und wiederholen, dass die Anwendbarkeit virtueller Maschinen viel umfassender ist, als es auf den ersten Blick erscheinen mag.  Diese Technik ist in allen Fällen geeignet und weit verbreitet, in denen klar zwischen den Grundelementen, die die System-Engine versteht, und dem "vorderen" Subsystem, dh einer DSL- oder Programmiersprache, unterschieden werden muss. </p><br><p>  Dies schließt eine Reihe von Artikeln über die verschiedenen Verwendungszwecke von Bytecode-Interpreten und virtuellen Maschinen ab.  Ich hoffe, den Lesern von Habr hat die Serie gefallen und natürlich beantworte ich gerne alle Fragen zum Thema. </p><br><h1 id="neformalnyy-spisok-literatury">  Informelle Referenzen </h1><br><p>  Bytecode-Interpreter für Programmiersprachen sind ein spezifisches Thema, und es gibt relativ wenig Literatur dazu.  Ich persönlich mochte Ian Craigs Buch Virtual Machines, obwohl es weniger die Implementierung von Interpreten als vielmehr abstrakte Maschinen beschreibt - mathematische Modelle, die verschiedenen Programmiersprachen zugrunde liegen. </p><br><p>  Im weiteren Sinne widmet sich ein weiteres Buch virtuellen Maschinen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Virtuelle Maschinen: Flexible Plattformen für Systeme und Prozesse“</a> („Virtuelle Maschinen: Vielseitige Plattformen für Systeme und Prozesse“).  Dies ist eine Einführung in die verschiedenen Anwendungen der Virtualisierung, die die Virtualisierung von Sprachen, Prozessen und Computerarchitekturen im Allgemeinen abdeckt. </p><br><p>  Die praktischen Aspekte der Entwicklung von Engines für reguläre Ausdrücke werden in der populären Compilerliteratur selten diskutiert.  Das Pig Match und das Beispiel aus dem ersten Artikel basieren auf Ideen aus einer erstaunlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelserie von</a> Russ Cox, einem der Entwickler der Google RE2-Engine. </p><br><p>  Die Theorie der regulären Ausdrücke wird in allen akademischen Lehrbüchern über Compiler vorgestellt.  Es ist üblich, sich auf das berühmte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Drachenbuch“</a> zu beziehen, aber ich würde empfehlen, mit dem obigen Link zu beginnen. </p><br><p>  Während ich an diesem Artikel arbeitete, verwendete ich zuerst ein interessantes System für die schnelle Entwicklung von Compilern für Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">raddsl</a> , das zum Stift des Benutzers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">true-grue gehört</a> (danke, Peter!).  Wenn Sie vor der Aufgabe stehen, eine Sprache als Prototyp zu erstellen oder schnell eine Art DSL zu entwickeln, sollten Sie darauf achten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433054/">https://habr.com/ru/post/de433054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433044/index.html">OpenJDK-Quellcode enthält zu viele Schimpfwörter</a></li>
<li><a href="../de433046/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 25. Datenkanäle: Einführung und Basisdienste</a></li>
<li><a href="../de433048/index.html">Wie 2019 die russischen Geschäfte verändern wird</a></li>
<li><a href="../de433050/index.html">Vom Flugzeugdesigner zum Programmierer in einem Jahr oder wie man ein Jedi wird</a></li>
<li><a href="../de433052/index.html">Snap & Flatpack - Tragödie der Gemeinschaften</a></li>
<li><a href="../de433056/index.html">Das Kommunikationsministerium verschärft die Regeln für Software mit Elementen ausländischer Herkunft</a></li>
<li><a href="../de433058/index.html">Quintett als grundlegende Einheit zur Beschreibung eines Themenbereichs</a></li>
<li><a href="../de433060/index.html">Warum ich Mikrobenchmarks nicht glaube</a></li>
<li><a href="../de433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Vergleichen Sie CCTV-Kameras</a></li>
<li><a href="../de433064/index.html">Incident Management: "Sie können nicht aufgeben" oder die Kunst, Kommas zu setzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>