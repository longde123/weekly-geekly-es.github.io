<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüéì üë©üèº‚Äçü§ù‚Äçüë®üèø üêÖ Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode f√ºr regul√§re Ausdr√ºcke üë®üèæ‚Äçü§ù‚Äçüë®üèΩ ‚ò¶Ô∏è üí≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="T√§glich finden in Badoo 17 Milliarden Veranstaltungen, 60 Millionen Benutzersitzungen und eine Vielzahl virtueller Termine statt. Jedes Ereignis wird ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode f√ºr regul√§re Ausdr√ºcke</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433054/"><p><img src="https://habrastorage.org/webt/kz/rl/nu/kzrlnugblhii_j4jrsqzdk9fsgo.jpeg"></p><br><p>  T√§glich finden in Badoo 17 Milliarden Veranstaltungen, 60 Millionen Benutzersitzungen und eine Vielzahl virtueller Termine statt.  Jedes Ereignis wird √ºbersichtlich in relationalen Datenbanken gespeichert und anschlie√üend in SQL und dar√ºber hinaus analysiert. </p><br><p>  Moderne verteilte Transaktionsdatenbanken mit Dutzenden von Terabyte Daten - ein wahres Wunder der Technik.  SQL als Verk√∂rperung der relationalen Algebra in den meisten Standardimplementierungen erlaubt es uns jedoch noch nicht, Abfragen in Form von geordneten Tupeln zu formulieren. </p><br><p>  Im letzten Artikel einer Reihe √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuelle</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maschinen</a> werde ich √ºber einen alternativen Ansatz zum Finden interessanter Sitzungen sprechen - die regul√§re Ausdrucks-Engine ( <a href="">Pig Match</a> ), die f√ºr Ereignissequenzen definiert ist. </p><br><p>  Virtuelle Maschine, Bytecode und Compiler sind kostenlos enthalten! </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil, Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil, Optimierung</a> <br>  Dritter Teil, angewendet (aktuell) </p><br><h1 id="o-sobytiyah-i-sessiyah">  √úber Ereignisse und Sitzungen </h1><br><p>  Angenommen, wir haben bereits ein Data Warehouse, mit dem Sie die Ereignisse jeder Benutzersitzung schnell und nacheinander anzeigen k√∂nnen. </p><br><p> Wir m√∂chten Sitzungen anhand von Anforderungen wie "Alle Sitzungen z√§hlen, bei denen eine bestimmte Teilsequenz von Ereignissen vorhanden ist", "Teile einer Sitzung, die durch ein bestimmtes Muster beschrieben wurden", "Den Teil der Sitzung zur√ºckgeben, der nach einem bestimmten Muster stattgefunden hat" oder "Z√§hlen, wie viele Sitzungen bestimmte Teile erreicht haben" suchen Vorlage. "  Dies kann f√ºr eine Vielzahl von Analysetypen n√ºtzlich sein: Suche nach verd√§chtigen Sitzungen, Trichteranalyse usw. </p><br><p>  Die gew√ºnschten Teilsequenzen m√ºssen irgendwie beschrieben werden.  In ihrer einfachsten Form √§hnelt diese Aufgabe dem Auffinden eines Teilstrings in einem Text.  Wir wollen ein leistungsf√§higeres Werkzeug - regul√§re Ausdr√ºcke.  Moderne Implementierungen von Engines f√ºr regul√§re Ausdr√ºcke verwenden am h√§ufigsten (Sie haben es erraten!) Virtuelle Maschinen. </p><br><p>  Die Erstellung kleiner virtueller Maschinen zum Abgleichen von Sitzungen mit regul√§ren Ausdr√ºcken wird nachstehend erl√§utert.  Aber zuerst werden wir die Definitionen klarstellen. </p><br><p>  <em>Ein Ereignis</em> besteht aus einem Ereignistyp, einer Zeit, einem Kontext und einer Reihe von Attributen, die f√ºr jeden Typ spezifisch sind. </p><br><p>  <em>Der Typ</em> und der <em>Kontext</em> jedes Ereignisses sind Ganzzahlen aus vordefinierten Listen.  Wenn bei den Ereignistypen alles klar ist, ist der Kontext beispielsweise die Nummer des Bildschirms, auf dem das angegebene Ereignis aufgetreten ist. </p><br><p>  <em>Ein</em> Ereignisattribut ist eine beliebige Ganzzahl, deren Bedeutung durch den Ereignistyp bestimmt wird.  Ein Ereignis hat m√∂glicherweise keine oder mehrere Attribute. </p><br><p>  <em>Eine Sitzung</em> ist eine Folge von Ereignissen, die nach Zeit sortiert sind. </p><br><p>  Aber kommen wir endlich zur Sache.  Das Summen lie√ü nach, und ich ging auf die B√ºhne. </p><br><h1 id="sravnivaem-po-bumazhke">  Vergleiche auf einem St√ºck Papier </h1><br><p><img src="https://habrastorage.org/webt/gu/ec/dw/guecdwuc3rhjl1oc6cvuk-4ec9k.jpeg"></p><br><p>  Ein Merkmal dieser virtuellen Maschine ist die Passivit√§t in Bezug auf Eingabeereignisse.  Wir m√∂chten nicht die gesamte Sitzung im Speicher behalten und der virtuellen Maschine erm√∂glichen, unabh√§ngig von Ereignis zu Ereignis zu wechseln.  Stattdessen werden Ereignisse nacheinander aus der Sitzung in die virtuelle Maschine eingespeist. </p><br><p>  Definieren wir die Schnittstellenfunktionen: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">matcher *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *matcher)</span></span></span></span>;</code> </pre> <br><p>  Wenn mit den Funktionen matcher_create und matcher_destroy alles klar ist, ist matcher_accept einen Kommentar wert.  Die Funktion matcher_accept empf√§ngt eine Instanz der virtuellen Maschine und des n√§chsten Ereignisses (32 Bit, wobei 16 Bit f√ºr den Ereignistyp und 16 Bit f√ºr den Kontext) und gibt einen Code zur√ºck, in dem erl√§utert wird, was der Benutzercode als N√§chstes tun soll: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { <span class="hljs-comment"><span class="hljs-comment">//       MATCH_NEXT, //    ,      MATCH_OK, //       ,      MATCH_FAIL, //     MATCH_ERROR, } match_result;</span></span></code> </pre><br><p>  Opcodes der virtuellen Maschine: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { <span class="hljs-comment"><span class="hljs-comment">//  ,      OP_ABORT, //      ( -  ) OP_NAME, //     ( -  ) OP_SCREEN, //    OP_NEXT, //    OP_MATCH, } matcher_opcode;</span></span></code> </pre><br><p>  Die Hauptschleife einer virtuellen Maschine: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP() \ (*m-&gt;ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG() \ ((void)(m-&gt;ip += 2), (m-&gt;ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + m-&gt;ip[-1]) for (;;) { uint8_t instruction = NEXT_OP(); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(); if (event_name(next_event) != name) return MATCH_FAIL; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(); if (event_screen(next_event) != screen) return MATCH_FAIL; break; } case OP_NEXT:{ return MATCH_NEXT; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre> <br><p>  In dieser einfachen Version stimmt unsere virtuelle Maschine das durch Bytecode beschriebene Muster nacheinander mit eingehenden Ereignissen ab.  Insofern ist dies einfach kein sehr pr√§ziser Vergleich der <em>Pr√§fixe</em> zweier Zeilen: der gew√ºnschten Vorlage und der Eingabezeile. </p><br><p>  Pr√§fixe sind Pr√§fixe, aber wir m√∂chten die gew√ºnschten Muster nicht nur am Anfang, sondern auch an einer beliebigen Stelle in der Sitzung finden.  Die naive L√∂sung besteht darin, den Abgleich von jedem Sitzungsereignis neu zu starten.  Dies impliziert jedoch die mehrfache Betrachtung jedes Ereignisses und das Essen algorithmischer Babys. </p><br><p>  <a href="">Das Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel der</a> Serie simuliert praktisch den Neustart eines Matches mithilfe von Rollback (englisches Backtracking).  Der Code im Beispiel sieht nat√ºrlich schlanker aus als der hier angegebene, aber das Problem ist nicht behoben: Jedes der Ereignisse muss mehrmals √ºberpr√ºft werden. </p><br><p>  So kannst du nicht leben. </p><br><h1 id="ya-esche-raz-ya-i-snova-ya">  Ich, ich wieder und ich wieder </h1><br><p><img src="https://habrastorage.org/webt/bq/ue/gt/bquegtp3mpd4rxv65f1fk-svdjk.jpeg"></p><br><p>  Lassen Sie uns das Problem noch einmal skizzieren: Wir m√ºssen die Vorlage mit eingehenden Ereignissen abgleichen, beginnend mit jedem der Ereignisse, die einen neuen Vergleich starten.  Warum machen wir das nicht einfach?  Lassen Sie die virtuelle Maschine eingehende Ereignisse in mehreren Threads bearbeiten! </p><br><p>  Dazu ben√∂tigen wir eine neue Entit√§t - einen Stream.  Jeder Thread speichert einen einzelnen Zeiger - auf die aktuelle Anweisung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher_thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; } matcher_thread;</code> </pre><br><p>  Nat√ºrlich werden wir jetzt in der virtuellen Maschine selbst den expliziten Zeiger nicht speichern.  Es wird durch zwei Thread-Listen ersetzt (mehr dazu weiter unten): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytecode; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the current event */</span></span> matcher_thread current_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> current_thread_num; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the event to follow */</span></span> matcher_thread next_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> next_thread_num; } matcher;</code> </pre><br><p>  Und hier ist die aktualisierte Hauptschleife: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP(thread) \ (*(thread).ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG(thread) \ ((void)((thread).ip += 2), ((thread).ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + (thread).ip[-1]) /*         - */ add_current_thread(m, initial_thread(m)); //         for (size_t thread_i = 0; thread_i &lt; m-&gt;current_thread_num; thread_i++ ) { matcher_thread current_thread = m-&gt;current_threads[thread_i]; bool thread_done = false; while (!thread_done) { uint8_t instruction = NEXT_OP(current_thread); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(current_thread); //  ,      ,    //     next_threads,    if (event_name(next_event) != name) thread_done = true; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(current_thread); if (event_screen(next_event) != screen) thread_done = true; break; } case OP_NEXT:{ //    , ..      // next_threads add_next_thread(m, current_thread); thread_done = true; break; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } } /*      ,    */ swap_current_and_next(m); return MATCH_NEXT; #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre><br><p>  Bei jedem empfangenen Ereignis f√ºgen wir zuerst einen neuen Thread zur Liste current_threads hinzu und √ºberpr√ºfen die Vorlage von Anfang an. Danach durchlaufen wir die Liste current_threads und folgen jedem Zeiger, indem wir den Anweisungen folgen. </p><br><p>  Wenn eine NEXT-Anweisung angetroffen wird, wird der Thread in die Liste next_threads eingef√ºgt, dh er wartet auf den Empfang des n√§chsten Ereignisses. </p><br><p>  Wenn das Thread-Muster nicht mit dem empfangenen Ereignis √ºbereinstimmt, wird ein solcher Thread einfach nicht zur Liste next_threads hinzugef√ºgt. </p><br><p>  Der MATCH-Befehl beendet die Funktion sofort und meldet einen R√ºckkehrcode, dass das Muster mit der Sitzung √ºbereinstimmt. </p><br><p>  Nach Abschluss des Crawls der Thread-Liste werden die aktuelle und die n√§chste Liste ausgetauscht. </p><br><p>  Eigentlich ist das alles.  Wir k√∂nnen sagen, dass wir buchst√§blich das tun, was wir wollten: Gleichzeitig √ºberpr√ºfen wir mehrere Vorlagen und starten f√ºr jedes Sitzungsereignis einen neuen √úbereinstimmungsprozess. </p><br><h1 id="mnozhestvennye-lichnosti-i-vetvleniya-v-shablonah">  Mehrere Identit√§ten und Zweige in Vorlagen </h1><br><p><img src="https://habrastorage.org/webt/8l/gv/-e/8lgv-e5bp1xhv0ksukeacrhasaq.jpeg"></p><br><p>  Die Suche nach einer Vorlage, die eine lineare Abfolge von Ereignissen beschreibt, ist nat√ºrlich n√ºtzlich, aber wir m√∂chten vollst√§ndige regul√§re Ausdr√ºcke erhalten.  Und die Flows, die wir in der vorherigen Phase erstellt haben, sind auch hier n√ºtzlich. </p><br><p>  Angenommen, wir m√∂chten eine Folge von zwei oder drei Ereignissen finden, die f√ºr uns von Interesse sind, so etwas wie ein regul√§rer Ausdruck in Zeilen: "a? Bc".  In dieser Reihenfolge ist das Symbol "a" optional.  Wie dr√ºcke ich es in Bytecode aus?  Einfach! </p><br><p>  Wir k√∂nnen <em>zwei</em> Threads starten, jeweils einen: mit dem Symbol "a" und ohne.  Zu diesem Zweck f√ºhren wir eine zus√§tzliche Anweisung (vom SPLIT-Typ addr1, addr2) ein, die zwei Threads von den angegebenen Adressen aus startet.  Neben SPLIT ist JUMP auch f√ºr uns n√ºtzlich, da die Ausf√ºhrung einfach mit der im direkten Argument angegebenen Anweisung fortgesetzt wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { OP_ABORT, OP_NAME, OP_SCREEN, OP_NEXT, <span class="hljs-comment"><span class="hljs-comment">//     OP_JUMP, //         OP_SPLIT, OP_MATCH, //     OP_NUMBER_OF_OPS, } matcher_opcode;</span></span></code> </pre> <br><p>  Die Schleife selbst und der Rest der Anweisungen √§ndern sich nicht - wir stellen nur zwei neue Handler vor: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... case OP_JUMP:{ /*   ,      */ uint16_t offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, offset)); break; } case OP_SPLIT:{ /*        */ uint16_t left_offset = NEXT_ARG(current_thread); uint16_t right_offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, left_offset)); add_current_thread(m, create_thread(m, right_offset)); break; } // ...</span></span></code> </pre><br><p>  Beachten Sie, dass die Anweisungen der aktuellen Liste Threads hinzuf√ºgen, dh, sie funktionieren weiterhin im Kontext des aktuellen Ereignisses.  Der Thread, in dem der Zweig aufgetreten ist, wird nicht in die Liste der folgenden Threads aufgenommen. </p><br><p>  Das Erstaunlichste an dieser virtuellen Maschine mit regul√§ren Ausdr√ºcken ist, dass unsere Threads und dieses Anweisungspaar ausreichen, um fast alle Konstruktionen auszudr√ºcken, die beim Abgleichen von Zeichenfolgen allgemein akzeptiert werden. </p><br><h1 id="regulyarnye-vyrazheniya-na-sobytiyah">  Regelm√§√üige Ausdr√ºcke zu Ereignissen </h1><br><p>  Jetzt, da wir eine geeignete virtuelle Maschine und Tools daf√ºr haben, k√∂nnen wir uns tats√§chlich mit der Syntax f√ºr unsere regul√§ren Ausdr√ºcke befassen. </p><br><p>  Die manuelle Aufzeichnung von Opcodes f√ºr ernstere Programme wird schnell m√ºde.  Das letzte Mal habe ich keinen vollwertigen Parser erstellt, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">echte</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzer hat</a> die Funktionen seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raddsl-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Beispiel der PigletC</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minisprache gezeigt</a> .  Ich war so beeindruckt von der K√ºrze des Codes, dass ich mit Hilfe von raddsl einen kleinen Compiler mit regul√§ren Ausdr√ºcken von Zeichenfolgen in hundert oder zweihundert in Python schrieb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Compiler</a> und seine Gebrauchsanweisung befinden sich auf GitHub.  Das Ergebnis des Compilers in Assemblersprache wird von einem Dienstprogramm verstanden, das zwei Dateien liest (ein Programm f√ºr eine virtuelle Maschine und eine Liste von Sitzungsereignissen zur √úberpr√ºfung). </p><br><p>  Zun√§chst beschr√§nken wir uns auf die Art und den Kontext des Ereignisses.  Die Art des Ereignisses wird durch eine einzelne Zahl angegeben.  Wenn Sie einen Kontext angeben m√ºssen, geben Sie ihn √ºber einen Doppelpunkt an.  Das einfachste Beispiel: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13" # ,     13 NEXT NAME 13 MATCH</code> </pre> <br><p>  Nun ein Beispiel mit Kontext: </p><br><pre> <code class="plaintext hljs">python regexp/regexp.py "13:12" #  13,  12 NEXT NAME 13 SCREEN 12 MATCH</code> </pre> <br><p>  Aufeinanderfolgende Ereignisse m√ºssen irgendwie getrennt sein (z. B. durch Leerzeichen): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13 11 10:9" 08:40:52 NEXT NAME 13 NEXT NAME 11 NEXT NAME 10 SCREEN 9 MATCH</code> </pre> <br><p>  Vorlage interessanter: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "12|13" SPLIT L0 L1 L0: NEXT NAME 12 JUMP L2 L1: NEXT NAME 13 L2: MATCH</code> </pre> <br><p>  Achten Sie auf die Zeilen, die mit einem Doppelpunkt enden.  Dies sind Tags.  Der SPLIT-Befehl erstellt zwei Threads, die die Ausf√ºhrung von den Bezeichnungen L0 und L1 fortsetzen, und JUMP am Ende des ersten Ausf√ºhrungszweigs f√§hrt einfach bis zum Ende des Zweigs fort. </p><br><p>  Sie k√∂nnen wahrheitsgem√§√üer zwischen Ausdrucksketten w√§hlen, indem Sie Teilsequenzen in Klammern gruppieren: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "(1 2 3)|4" SPLIT L0 L1 L0: NEXT NAME 1 NEXT NAME 2 NEXT NAME 3 JUMP L2 L1: NEXT NAME 4 L2: MATCH</code> </pre> <br><p>  Ein beliebiges Ereignis wird durch einen Punkt angezeigt: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py ". 1" NEXT NEXT NAME 1 MATCH</code> </pre> <br><p>  Wenn wir zeigen wollen, dass die Teilsequenz optional ist, setzen wir ein Fragezeichen danach: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1 2 3? 4" NEXT NAME 1 NEXT NAME 2 SPLIT L0 L1 L0: NEXT NAME 3 L1: NEXT NAME 4 MATCH</code> </pre> <br><p>  Nat√ºrlich sind auch mehrere regul√§re Wiederholungen (Plus oder Sternchen) in regul√§ren Ausdr√ºcken √ºblich: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1+ 2" L0: NEXT NAME 1 SPLIT L0 L1 L1: NEXT NAME 2 MATCH</code> </pre> <br><p>  Hier f√ºhren wir den SPLIT-Befehl einfach viele Male aus und starten bei jedem Zyklus neue Threads. </p><br><p>  √Ñhnlich mit einem Sternchen: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1* 2" L0: SPLIT L1 L2 L1: NEXT NAME 1 JUMP L0 L2: NEXT NAME 2 MATCH</code> </pre> <br><p><img src="https://habrastorage.org/webt/g-/ud/3s/g-ud3s00i4ccyhf4lp5huusjlyu.jpeg"></p><br><h1 id="perspektiva">  Perspektive </h1><br><p>  Andere Erweiterungen der beschriebenen virtuellen Maschine k√∂nnen n√ºtzlich sein. </p><br><p>  Zum Beispiel kann es einfach erweitert werden, indem Ereignisattribute √ºberpr√ºft werden.  F√ºr ein reales System nehme ich an, eine Syntax wie "1: 2 {3: 4, 5:&gt; 3}" zu verwenden, was bedeutet: Ereignis 1 in Kontext 2 mit Attribut 3 mit Wert 4 und Attributwert 5 gr√∂√üer als 3. Attribute hier Sie k√∂nnen es einfach in einem Array an die Funktion matcher_accept √ºbergeben. </p><br><p>  Wenn Sie auch das Zeitintervall zwischen Ereignissen an matcher_accept √ºbergeben, k√∂nnen Sie der Vorlagensprache eine Syntax hinzuf√ºgen, mit der Sie die Zeit zwischen Ereignissen √ºberspringen k√∂nnen: "1 mindelta (120) 2", was bedeutet: Ereignis 1, dann ein Zeitraum von mindestens 120 Sekunden, Ereignis 2 In Kombination mit der Beibehaltung einer Teilsequenz k√∂nnen Sie so Informationen zum Benutzerverhalten zwischen zwei Teilsequenzen von Ereignissen sammeln. </p><br><p>  Andere n√ºtzliche Dinge, die relativ einfach hinzuzuf√ºgen sind, sind: Beibehalten von Teilsequenzen regul√§rer Ausdr√ºcke, Trennen von gierigen und gew√∂hnlichen Sternchen- und Plus-Operatoren usw.  In Bezug auf die Theorie der Automaten ist unsere virtuelle Maschine ein nicht deterministischer endlicher Automat, f√ºr dessen Implementierung es nicht schwierig ist, solche Dinge zu tun. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Unser System wurde f√ºr schnelle Benutzeroberfl√§chen entwickelt, daher ist die Sitzungsspeicher-Engine selbst geschrieben und speziell f√ºr den Durchgang durch alle Sitzungen optimiert.  Alle Milliarden von Ereignissen, die in Sitzungen aufgeteilt wurden, werden auf einem einzelnen Server in Sekundenschnelle mit Mustern verglichen. </p><br><p>  Wenn die Geschwindigkeit f√ºr Sie nicht so kritisch ist, kann ein √§hnliches System als Erweiterung f√ºr ein Standard-Datenspeichersystem wie eine herk√∂mmliche relationale Datenbank oder ein verteiltes Dateisystem konzipiert werden. </p><br><p>  √úbrigens ist in den neuesten Versionen des <a href="">SQL-Standards bereits eine</a> √§hnliche Funktion wie im Artikel beschrieben erschienen, und einzelne Datenbanken ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vertica</a> ) haben sie bereits implementiert.  Yandex ClickHouse implementiert seinerseits eine eigene SQL-√§hnliche Sprache, verf√ºgt jedoch auch √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√§hnliche Funktionen</a> . </p><br><p>  Ich m√∂chte von Ereignissen und regul√§ren Ausdr√ºcken ablenken und wiederholen, dass die Anwendbarkeit virtueller Maschinen viel umfassender ist, als es auf den ersten Blick erscheinen mag.  Diese Technik ist in allen F√§llen geeignet und weit verbreitet, in denen klar zwischen den Grundelementen, die die System-Engine versteht, und dem "vorderen" Subsystem, dh einer DSL- oder Programmiersprache, unterschieden werden muss. </p><br><p>  Dies schlie√üt eine Reihe von Artikeln √ºber die verschiedenen Verwendungszwecke von Bytecode-Interpreten und virtuellen Maschinen ab.  Ich hoffe, den Lesern von Habr hat die Serie gefallen und nat√ºrlich beantworte ich gerne alle Fragen zum Thema. </p><br><h1 id="neformalnyy-spisok-literatury">  Informelle Referenzen </h1><br><p>  Bytecode-Interpreter f√ºr Programmiersprachen sind ein spezifisches Thema, und es gibt relativ wenig Literatur dazu.  Ich pers√∂nlich mochte Ian Craigs Buch Virtual Machines, obwohl es weniger die Implementierung von Interpreten als vielmehr abstrakte Maschinen beschreibt - mathematische Modelle, die verschiedenen Programmiersprachen zugrunde liegen. </p><br><p>  Im weiteren Sinne widmet sich ein weiteres Buch virtuellen Maschinen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûVirtuelle Maschinen: Flexible Plattformen f√ºr Systeme und Prozesse‚Äú</a> (‚ÄûVirtuelle Maschinen: Vielseitige Plattformen f√ºr Systeme und Prozesse‚Äú).  Dies ist eine Einf√ºhrung in die verschiedenen Anwendungen der Virtualisierung, die die Virtualisierung von Sprachen, Prozessen und Computerarchitekturen im Allgemeinen abdeckt. </p><br><p>  Die praktischen Aspekte der Entwicklung von Engines f√ºr regul√§re Ausdr√ºcke werden in der popul√§ren Compilerliteratur selten diskutiert.  Das Pig Match und das Beispiel aus dem ersten Artikel basieren auf Ideen aus einer erstaunlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelserie von</a> Russ Cox, einem der Entwickler der Google RE2-Engine. </p><br><p>  Die Theorie der regul√§ren Ausdr√ºcke wird in allen akademischen Lehrb√ºchern √ºber Compiler vorgestellt.  Es ist √ºblich, sich auf das ber√ºhmte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûDrachenbuch‚Äú</a> zu beziehen, aber ich w√ºrde empfehlen, mit dem obigen Link zu beginnen. </p><br><p>  W√§hrend ich an diesem Artikel arbeitete, verwendete ich zuerst ein interessantes System f√ºr die schnelle Entwicklung von Compilern f√ºr Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">raddsl</a> , das zum Stift des Benutzers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">true-grue geh√∂rt</a> (danke, Peter!).  Wenn Sie vor der Aufgabe stehen, eine Sprache als Prototyp zu erstellen oder schnell eine Art DSL zu entwickeln, sollten Sie darauf achten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433054/">https://habr.com/ru/post/de433054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433044/index.html">OpenJDK-Quellcode enth√§lt zu viele Schimpfw√∂rter</a></li>
<li><a href="../de433046/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 25. Datenkan√§le: Einf√ºhrung und Basisdienste</a></li>
<li><a href="../de433048/index.html">Wie 2019 die russischen Gesch√§fte ver√§ndern wird</a></li>
<li><a href="../de433050/index.html">Vom Flugzeugdesigner zum Programmierer in einem Jahr oder wie man ein Jedi wird</a></li>
<li><a href="../de433052/index.html">Snap & Flatpack - Trag√∂die der Gemeinschaften</a></li>
<li><a href="../de433056/index.html">Das Kommunikationsministerium versch√§rft die Regeln f√ºr Software mit Elementen ausl√§ndischer Herkunft</a></li>
<li><a href="../de433058/index.html">Quintett als grundlegende Einheit zur Beschreibung eines Themenbereichs</a></li>
<li><a href="../de433060/index.html">Warum ich Mikrobenchmarks nicht glaube</a></li>
<li><a href="../de433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Vergleichen Sie CCTV-Kameras</a></li>
<li><a href="../de433064/index.html">Incident Management: "Sie k√∂nnen nicht aufgeben" oder die Kunst, Kommas zu setzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>