<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòï üë®‚Äçüè´ ü§ê Analitik data prediktif - pemodelan dan validasi üìÄ üïµüèª ü§ûüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sajikan kepada Anda terjemahan sebuah bab dari buku Hands-On Data Science dengan Anaconda 
 ‚ÄúAnalitik data prediktif - pemodelan dan validasi‚Äù 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analitik data prediktif - pemodelan dan validasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428321/">  Saya sajikan kepada Anda terjemahan sebuah bab dari buku Hands-On Data Science dengan Anaconda <br>  <b>‚ÄúAnalitik data prediktif - pemodelan dan validasi‚Äù</b> <br><br><img src="https://habrastorage.org/webt/eg/b0/jk/egb0jk10gh3cnlxzozestcagccc.png" height="500" width="300"><br><br>  Tujuan utama kami dalam melakukan berbagai analisis data adalah mencari pola untuk memprediksi apa yang akan terjadi di masa depan.  Untuk pasar saham, peneliti dan pakar melakukan berbagai tes untuk memahami mekanisme pasar.  Dalam hal ini, Anda dapat mengajukan banyak pertanyaan.  Apa yang akan menjadi tingkat indeks pasar dalam lima tahun ke depan?  Berapa kisaran harga berikutnya untuk IBM?  Akankah volatilitas pasar meningkat atau menurun di masa depan?  Apa dampaknya jika pemerintah mengubah kebijakan pajaknya?  Apa keuntungan dan kerugian potensial jika satu negara memulai perang dagang dengan negara lain?  Bagaimana kita memprediksi perilaku konsumen dengan menganalisis beberapa variabel terkait?  Bisakah kita memprediksi kemungkinan bahwa seorang mahasiswa pascasarjana akan berhasil lulus?  Bisakah kita menemukan hubungan antara perilaku spesifik dari satu penyakit tertentu? <br><br>  Karena itu, kami akan mempertimbangkan topik-topik berikut: <br><br><ul><li>  Memahami Analisis Data Prediktif </li><li>  Kumpulan data yang berguna </li><li>  Peramalan Acara Masa Depan </li><li>  Pemilihan model </li><li>  Uji Kausalitas Granger </li></ul><a name="habracut"></a><br><h2>  Memahami Analisis Data Prediktif </h2><br>  Orang mungkin memiliki banyak pertanyaan tentang acara mendatang. <br><br><ul><li>  Seorang investor, jika dia bisa memprediksi pergerakan harga saham di masa depan, dia bisa mendapat untung besar. </li><li>  Perusahaan, jika mereka dapat memprediksi tren produk mereka, mereka dapat meningkatkan harga saham dan pangsa pasar mereka. </li><li>  Pemerintah, jika mereka dapat memprediksi dampak populasi yang menua pada masyarakat dan ekonomi, mereka akan memiliki lebih banyak insentif untuk mengembangkan kebijakan yang lebih baik dalam hal anggaran negara dan keputusan strategis terkait lainnya. </li><li>  Universitas, jika mereka dapat dengan baik memahami permintaan pasar dalam hal kualitas dan keterampilan untuk lulusan mereka, mereka dapat mengembangkan serangkaian program yang lebih baik atau meluncurkan program baru untuk memenuhi kebutuhan tenaga kerja di masa depan. </li></ul><br>  Untuk prognosis yang lebih baik, peneliti harus mempertimbangkan banyak pertanyaan.  Misalnya, apakah data sampel terlalu kecil?  Bagaimana cara menghapus variabel yang hilang?  Apakah kumpulan data ini bias dalam hal prosedur pengumpulan data?  Bagaimana perasaan kita tentang ekstrem atau emisi?  Apa itu musim dan bagaimana kita menghadapinya?  Model apa yang harus kita gunakan?  Bab ini akan membahas beberapa masalah ini.  Mari kita mulai dengan dataset yang berguna. <br><br><h1>  Kumpulan data yang berguna </h1><br>  Salah satu sumber data terbaik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UCI Machine Learning Repository</a> .  Setelah mengunjungi situs kami akan melihat daftar berikut: <br><br><img src="https://habrastorage.org/webt/p2/sa/47/p2sa47ajhhmjdwnigi4vg19raue.png"><br><br>  Misalnya, jika Anda memilih dataset pertama (Abalon), kita akan melihat yang berikut ini.  Untuk menghemat ruang, hanya bagian atas yang ditampilkan: <br><br><img src="https://habrastorage.org/webt/g2/6i/u4/g26iu42u1yln7fvxz4oj_cybzxm.png"><br><br>  Dari sini, pengguna dapat mengunduh dataset dan menemukan definisi variabel.  Kode berikut dapat digunakan untuk memuat dataset: <br><br><pre><code class="bash hljs">dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"UCIdatasets"</span></span> path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) dim(.UCIdatasets) head(.UCIdatasets)</code> </pre> <br>  Output yang sesuai ditunjukkan di sini: <br><br><img src="https://habrastorage.org/webt/sk/rn/8j/skrn8jh3kygkqwxfvpzza2xnnzk.png"><br><br>  Dari kesimpulan sebelumnya, kita tahu bahwa di set data ada 427 pengamatan (set data).  Untuk masing-masing dari mereka, kami memiliki 7 fungsi terkait, seperti <i>Nama, Data_Tip, Default_Task, Attribute_Types, N_In Situ</i> (jumlah instance), <i>N_Attributes</i> (jumlah atribut) dan <i>Tahun</i> .  Variabel yang disebut <i>Default_Task</i> dapat diartikan sebagai penggunaan utama dari setiap kumpulan data.  Misalnya, dataset pertama yang disebut <i>Abalone</i> dapat digunakan untuk <i>Klasifikasi</i> .  Fungsi <i>unik ()</i> dapat digunakan untuk mencari semua <i>Default_Task yang</i> mungkin ditampilkan di sini: <br><br><img src="https://habrastorage.org/webt/ul/4-/fj/ul4-fjckb20uvcz1iif9yup4wem.png"><br><br><h3>  Paket R AppliedPredictiveModeling </h3><br>  Paket ini mencakup banyak kumpulan data berguna yang dapat digunakan untuk bab ini dan lainnya.  Cara termudah untuk menemukan kumpulan data ini adalah dengan fungsi <i>help () yang</i> ditampilkan di sini: <br><br><pre> <code class="bash hljs">library(AppliedPredictiveModeling) <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(package=AppliedPredictiveModeling)</code> </pre><br>  Di sini kami menunjukkan beberapa contoh memuat dataset ini.  Untuk memuat satu set data, kami menggunakan fungsi <i>data ()</i> .  Untuk dataset pertama yang disebut <i>abalone</i> , kami memiliki kode berikut: <br><br><pre> <code class="bash hljs">library(AppliedPredictiveModeling) data(abalone) dim(abalone) head(abalone)</code> </pre><br>  Outputnya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/wb/ah/sb/wbahsbbuw2teuts6nhjhiqawm4g.png"><br><br>  Terkadang, satu set data besar mencakup beberapa set sub-data: <br><br><pre> <code class="bash hljs">library(AppliedPredictiveModeling) data(solubility) ls(pattern=<span class="hljs-string"><span class="hljs-string">"sol"</span></span>)</code> </pre><br><pre> <code class="bash hljs">[1] <span class="hljs-string"><span class="hljs-string">"solTestX"</span></span> <span class="hljs-string"><span class="hljs-string">"solTestXtrans"</span></span> <span class="hljs-string"><span class="hljs-string">"solTestY"</span></span> [4] <span class="hljs-string"><span class="hljs-string">"solTrainX"</span></span> <span class="hljs-string"><span class="hljs-string">"solTrainXtrans"</span></span> <span class="hljs-string"><span class="hljs-string">"solTrainY"</span></span></code> </pre><br>  Untuk memuat setiap kumpulan data, kita bisa menggunakan fungsi <i>dim ()</i> , <i>head ()</i> , <i>tail ()</i> dan <i>ringkasan ()</i> . <br><br><h3>  Analisis Rangkaian Waktu </h3><br>  Rangkaian waktu dapat didefinisikan sebagai satu set nilai yang diperoleh pada saat-saat bersamaan, seringkali dengan interval yang sama di antara mereka.  Ada periode yang berbeda, seperti tahunan, triwulanan, bulanan, mingguan, dan harian.  Untuk deret waktu PDB (produk domestik bruto) biasanya kita gunakan triwulanan atau tahunan.  Untuk kutipan - frekuensi tahunan, bulanan dan harian.  Dengan menggunakan kode berikut, kami dapat memperoleh data PDB AS triwulanan dan untuk periode tahunan: <br><br><pre> <code class="bash hljs">ath&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPannual"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) head(.usGDPannual)</code> </pre> <br><pre> <code class="bash hljs">YEAR GDP 1 1930 92.2 2 1931 77.4 3 1932 59.5 4 1933 57.2 5 1934 66.8 6 1935 74.3</code> </pre><br><pre> <code class="bash hljs">dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPquarterly"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) head(.usGDPquarterly)</code> </pre><br><pre> <code class="bash hljs"> DATE GDP_CURRENT GDP2009DOLLAR 1 1947Q1 243.1 1934.5 2 1947Q2 246.3 1932.3 3 1947Q3 250.1 1930.3 4 1947Q4 260.3 1960.7 5 1948Q1 266.2 1989.5 6 1948Q2 272.9 2021.9</code> </pre><br>  Namun, kami memiliki banyak pertanyaan untuk analisis deret waktu.  Misalnya, dari sudut pandang ekonomi makro, kita memiliki siklus bisnis atau ekonomi.  Industri atau perusahaan mungkin memiliki musim.  Misalnya, menggunakan industri pertanian, petani akan menghabiskan lebih banyak di musim semi dan musim gugur dan lebih sedikit di musim dingin.  Untuk pengecer, mereka akan memiliki arus uang yang besar pada akhir tahun. <br><br>  Untuk memanipulasi seri waktu, kita bisa menggunakan banyak fitur berguna yang termasuk dalam paket R, yang disebut <i>timeSeries</i> .  Dalam contoh, kami mengambil data rata-rata harian dengan frekuensi mingguan: <br><br><pre> <code class="bash hljs">library(timeSeries) data(MSFT) x &lt;- MSFT by &lt;- timeSequence(from = start(x), to = end(x), by = <span class="hljs-string"><span class="hljs-string">"week"</span></span>) y&lt;-aggregate(x,by,mean)</code> </pre><br>  Kita juga bisa menggunakan fungsi <i>head ()</i> untuk melihat beberapa pengamatan: <br><pre> <code class="bash hljs">head(x)</code> </pre><br><pre> <code class="bash hljs">GMT Open High Low Close Volume 2000-09-27 63.4375 63.5625 59.8125 60.6250 53077800 2000-09-28 60.8125 61.8750 60.6250 61.3125 26180200 2000-09-29 61.0000 61.3125 58.6250 60.3125 37026800 2000-10-02 60.5000 60.8125 58.2500 59.1250 29281200 2000-10-03 59.5625 59.8125 56.5000 56.5625 42687000 2000-10-04 56.3750 56.5625 54.5000 55.4375 68226700</code> </pre><br><pre> <code class="bash hljs">head(y)</code> </pre> <br><pre> <code class="bash hljs">GMT Open High Low Close Volume 2000-09-27 63.4375 63.5625 59.8125 60.6250 53077800 2000-10-04 59.6500 60.0750 57.7000 58.5500 40680380 2000-10-11 54.9750 56.4500 54.1625 55.0875 36448900 2000-10-18 53.0375 54.2500 50.8375 52.1375 50631280 2000-10-25 61.7875 64.1875 60.0875 62.3875 86457340 2000-11-01 66.1375 68.7875 65.8500 67.9375 53496000</code> </pre> <br><br><h2>  Peramalan Acara Masa Depan </h2><br>  Ada banyak metode yang bisa kita gunakan ketika mencoba memprediksi masa depan, seperti moving average, regresi, autoregresi, dll. Pertama, mari kita mulai dengan yang paling sederhana untuk moving average: <br><br><pre> <code class="bash hljs">movingAverageFunction&lt;- <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(data,n=10){ out= data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> n:length(data)){ out[i] = mean(data[(i-n+1):i]) } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>(out) }</code> </pre> <br>  Dalam kode sebelumnya, nilai default untuk jumlah periode adalah 10. Kita bisa menggunakan dataset yang disebut MSFT yang termasuk dalam paket R yang disebut <i>timeSeries</i> (lihat kode berikut): <br><br><pre> <code class="bash hljs">library(timeSeries) data(MSFT) p&lt;-MSFT<span class="hljs-variable"><span class="hljs-variable">$Close</span></span> <span class="hljs-comment"><span class="hljs-comment"># ma&lt;-movingAverageFunction(p,3) head(p)</span></span></code> </pre> <br><pre> <code class="bash hljs">[1] 60.6250 61.3125 60.3125 59.1250 56.5625 55.4375</code> </pre> <br><pre> <code class="bash hljs">head(ma)</code> </pre> <br><pre> <code class="bash hljs">[1] 60.62500 61.31250 60.75000 60.25000 58.66667 57.04167</code> </pre> <br><pre> <code class="bash hljs">mean(p[1:3])</code> </pre> <br><pre> <code class="bash hljs">[1] 60.75</code> </pre> <br><pre> <code class="bash hljs">mean(p[2:4])</code> </pre> <br><pre> <code class="bash hljs">[1] 60.25</code> </pre> <br>  Dalam mode manual, kami menemukan bahwa rata-rata dari tiga nilai pertama <i>x</i> cocok dengan nilai ketiga <i>y</i> .  Di satu sisi, kita bisa menggunakan rata-rata bergerak untuk memprediksi masa depan. <br><br>  Dalam contoh berikut, kami akan menunjukkan cara mengevaluasi pengembalian pasar yang diharapkan tahun depan.  Di sini kami menggunakan indeks S &amp; P500 dan nilai historis rata-rata tahunan sebagai nilai yang kami harapkan.  Beberapa perintah pertama digunakan untuk memuat dataset terkait bernama <i>.sp500monthly</i> .  Tujuan dari program ini adalah untuk menilai rata-rata tahunan rata-rata dan interval kepercayaan 90 persen: <br><br><pre> <code class="bash hljs">library(data.table) path&lt;-<span class="hljs-string"><span class="hljs-string">'http://canisius.edu/~yany/RData/'</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">'sp500monthly.RData'</span></span> link&lt;-paste(path,dataSet,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(link)) <span class="hljs-comment"><span class="hljs-comment">#head(.sp500monthly,2) p&lt;-.sp500monthly$ADJ.CLOSE n&lt;-length(p) logRet&lt;-log(p[2:n]/p[1:(n-1)]) years&lt;-format(.sp500monthly$DATE[2:n],"%Y") y&lt;-data.frame(.sp500monthly$DATE[2:n],years,logRet) colnames(y)&lt;-c("DATE","YEAR","LOGRET") y2&lt;- data.table(y) z&lt;-y2[,sum(LOGRET),by=YEAR] z2&lt;-na.omit(z) annualRet&lt;-data.frame(z2$YEAR,exp(z2[,2])-1) n&lt;-nrow(annualRet) std&lt;-sd(annualRet[,2]) stdErr&lt;-std/sqrt(n) ourMean&lt;-mean(annualRet[,2]) min2&lt;-ourMean-2*stdErr max2&lt;-ourMean+2*stdErr cat("[min mean max ]\n")</span></span></code> </pre> <br><pre> <code class="bash hljs">[min mean max ]</code> </pre><br><pre> <code class="bash hljs">cat(min2,ourMean,max2,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre> <code class="bash hljs">0.05032956 0.09022369 0.1301178</code> </pre><br>  Seperti yang Anda lihat dari hasilnya, pengembalian tahunan rata-rata historis untuk S &amp; P500 adalah 9%.  Tetapi kami tidak dapat mengatakan bahwa profitabilitas indeks tahun depan akan menjadi 9%, karena  bisa dari 5% hingga 13%, dan ini adalah fluktuasi besar. <br><br><h3>  Musiman </h3><br>  Dalam contoh berikut, kami menunjukkan penggunaan autokorelasi.  Pertama, kami mengunduh paket R yang disebut <i>astsa</i> , yang merupakan kependekan dari analisis deret waktu statistik.  Lalu kami memuat PDB AS dengan frekuensi triwulanan: <br><br><pre> <code class="bash hljs">library(astsa) path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPquarterly"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) x&lt;-.usGDPquarterly<span class="hljs-variable"><span class="hljs-variable">$DATE</span></span> y&lt;-.usGDPquarterly<span class="hljs-variable"><span class="hljs-variable">$GDP_CURRENT</span></span> plot(x,y) diff4 = diff(y,4) acf2(diff4,24)</code> </pre> <br>  Dalam kode di atas, fungsi <i>diff ()</i> menerima perbedaan, misalnya, nilai saat ini dikurangi nilai sebelumnya.  Nilai input kedua menunjukkan penundaan.  Fungsi yang disebut <i>acf2 ()</i> digunakan untuk membangun dan mencetak seri waktu ACF dan PACF.  ACF adalah singkatan dari fungsi autocovariance, dan PACF adalah singkatan dari autocorrelation function.  Grafik yang relevan ditunjukkan di sini: <br><br><img src="https://habrastorage.org/webt/n6/89/sv/n689svzvvvik4co4abbgzeobtnw.png" height="400" width="300"><br><br><h3>  <b>Visualisasi komponen</b> </h3><br>  Jelas, konsep dan set data akan jauh lebih dimengerti jika kita bisa menggunakan grafik.  Contoh pertama menunjukkan fluktuasi dalam PDB AS selama lima dekade terakhir: <br><br><pre> <code class="bash hljs">path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPannual"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) title&lt;-<span class="hljs-string"><span class="hljs-string">"US GDP"</span></span> xTitle&lt;-<span class="hljs-string"><span class="hljs-string">"Year"</span></span> yTitle&lt;-<span class="hljs-string"><span class="hljs-string">"US annual GDP"</span></span> x&lt;-.usGDPannual<span class="hljs-variable"><span class="hljs-variable">$YEAR</span></span> y&lt;-.usGDPannual<span class="hljs-variable"><span class="hljs-variable">$GDP</span></span> plot(x,y,main=title,xlab=xTitle,ylab=yTitle)</code> </pre> <br>  Jadwal yang sesuai ditunjukkan di sini: <br><br><img src="https://habrastorage.org/webt/rz/9z/h8/rz9zh8qa22budzolcuushzzgwow.png" height="400" width="300"><br><br>  Jika kami menggunakan skala logaritmik untuk PDB, kami akan memiliki kode dan grafik berikut: <br><br><pre> <code class="bash hljs">yTitle&lt;-<span class="hljs-string"><span class="hljs-string">"Log US annual GDP"</span></span> plot(x,<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y),main=title,xlab=xTitle,ylab=yTitle)</code> </pre> <br>  Bagan berikut ini dekat dengan garis lurus: <br><br><img src="https://habrastorage.org/webt/ae/f_/a6/aef_a6iuo4ielgslci9ry0vf1c8.png" height="400" width="300"><br><br><h3>  Paket R - LiblineaR </h3><br>  Paket ini adalah model prediksi linier berdasarkan LIBLINEAR C / C ++ Library.  Berikut adalah salah satu contoh penggunaan dataset <i>iris</i> .  Program mencoba memprediksi kategori mana yang dimiliki pabrik yang menggunakan data pelatihan: <br><br><pre> <code class="bash hljs">library(LiblineaR) data(iris) attach(iris) x=iris[,1:4] y=factor(iris[,5]) train=sample(1:dim(iris)[1],100) xTrain=x[train,];xTest=x[-train,] yTrain=y[train]; yTest=y[-train] s=scale(xTrain,center=TRUE,scale=TRUE) <span class="hljs-comment"><span class="hljs-comment"># tryTypes=c(0:7) tryCosts=c(1000,1,0.001) bestCost=NA bestAcc=0 bestType=NA # for(ty in tryTypes){ for(co in tryCosts){ acc=LiblineaR(data=s,target=yTrain,type=ty,cost=co,bias=1,cross=5,verbose=FALSE) cat("Results for C=",co,": ",acc," accuracy.\n",sep="") if(acc&gt;bestAcc){ bestCost=co bestAcc=acc bestType=ty } } } cat("Best model type is:",bestType,"\n") cat("Best cost is:",bestCost,"\n") cat("Best accuracy is:",bestAcc,"\n") # Re-train best model with best cost value. m=LiblineaR(data=s,target=yTrain,type=bestType,cost=bestCost,bias=1,verbose=FALSE) # Scale the test data s2=scale(xTest,attr(s,"scaled:center"),attr(s,"scaled:scale")) pr=FALSE; # Make prediction if(bestType==0 || bestType==7) pr=TRUE p=predict(m,s2,proba=pr,decisionValues=TRUE) res=table(p$predictions,yTest) # Display confusion matrix print(res) # Compute Balanced Classification Rate BCR=mean(c(res[1,1]/sum(res[,1]),res[2,2]/sum(res[,2]),res[3,3]/sum(res[,3]))) print(BCR)</span></span></code> </pre><br>  Kesimpulannya adalah sebagai berikut.  BCR adalah tingkat klasifikasi yang seimbang.  Untuk taruhan ini, semakin tinggi semakin baik: <br><br><pre> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best model type is:"</span></span>,bestType,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre> <code class="bash hljs">Best model <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> is: 4</code> </pre> <br><pre> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best cost is:"</span></span>,bestCost,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre> <code class="bash hljs">Best cost is: 1</code> </pre> <br><pre> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best accuracy is:"</span></span>,bestAcc,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre> <code class="bash hljs">Best accuracy is: 0.98</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(res) yTest setosa versicolor virginica setosa 16 0 0 versicolor 0 17 0 virginica 0 3 14 <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(BCR)</code> </pre><br><pre> <code class="bash hljs">[1] 0.95</code> </pre> <br><h3>  Paket R - eclust </h3><br>  Paket ini adalah pengelompokan berorientasi menengah untuk model prediksi yang ditafsirkan dalam data dimensi tinggi.  Pertama, mari kita lihat kumpulan data yang disebut <i>simdata</i> yang berisi data simulasi untuk suatu paket: <br><br><pre> <code class="bash hljs">library(eclust) data(<span class="hljs-string"><span class="hljs-string">"simdata"</span></span>) dim(simdata)</code> </pre><br><pre> <code class="bash hljs">[1] 100 502</code> </pre> <br><pre> <code class="bash hljs">simdata[1:5, 1:6]</code> </pre><br><pre> <code class="bash hljs"> YE Gene1 Gene2 Gene3 Gene4 [1,] -94.131497 0 -0.4821629 0.1298527 0.4228393 0.36643188 [2,] 7.134990 0 -1.5216289 -0.3304428 -0.4384459 1.57602830 [3,] 1.974194 0 0.7590055 -0.3600983 1.9006443 -1.47250061 [4,] -44.855010 0 0.6833635 1.8051352 0.1527713 -0.06442029 [5,] 23.547378 0 0.4587626 -0.3996984 -0.5727255 -1.75716775</code> </pre><br><pre> <code class="bash hljs">table(simdata[,<span class="hljs-string"><span class="hljs-string">"E"</span></span>])</code> </pre><br><pre> <code class="bash hljs">0 1 50 50</code> </pre><br>  Kesimpulan sebelumnya menunjukkan bahwa dimensi data adalah 100 kali 502. <b>Y</b> adalah vektor respons kontinu, dan <b>E</b> adalah variabel lingkungan biner untuk metode ECLUST.  <b>E = 0</b> untuk tidak terpapar (n = 50) dan <b>E = 1</b> untuk terpapar (n = 50). <br><br>  Program R berikut mengevaluasi Fisher z-transform: <br><br><pre> <code class="bash hljs">library(eclust) data(<span class="hljs-string"><span class="hljs-string">"simdata"</span></span>) X = simdata[,c(-1,-2)] firstCorr&lt;-cor(X[1:50,]) secondCorr&lt;-cor(X[51:100,]) score&lt;-u_fisherZ(n0=100,cor0=firstCorr,n1=100,cor1=secondCorr) dim(score)</code> </pre> <br><pre> <code class="bash hljs">[1] 500 500</code> </pre><br><pre> <code class="bash hljs">score[1:5,1:5]</code> </pre><br><pre> <code class="bash hljs"> Gene1 Gene2 Gene3 Gene4 Gene5 Gene1 1.000000 -8.062020 6.260050 -8.133437 -7.825391 Gene2 -8.062020 1.000000 9.162208 -7.431822 -7.814067 Gene3 6.260050 9.162208 1.000000 8.072412 6.529433 Gene4 -8.133437 -7.431822 8.072412 1.000000 -5.099261 Gene5 -7.825391 -7.814067 6.529433 -5.099261 1.000000</code> </pre><br>  Kami mendefinisikan Fisher z-transform.  Dengan asumsi bahwa kita memiliki seperangkat <b>n</b> pasangan <b>x</b> <i>i</i> dan <b>y</b> <i>i</i> , kita dapat memperkirakan korelasinya menggunakan rumus berikut: <br><br><img src="https://habrastorage.org/webt/rn/7c/gq/rn7cgq57sb0htzxqrypdk20keqo.png"><br><br>  Di sini <b>p</b> adalah korelasi antara dua variabel, dan <img src="https://habrastorage.org/webt/f5/uq/fm/f5uqfmo1am-aj0zhkkrswmlglka.png" height="30" width="20">  dan <img src="https://habrastorage.org/webt/ew/sg/o0/ewsgo0q-nftlketprnpqlgvxgw4.png" height="20" width="20">  adalah alat sampel untuk variabel acak <b>x</b> dan <b>y</b> .  Nilai <b>z</b> didefinisikan sebagai: <br><br><img src="https://habrastorage.org/webt/se/u4/-t/seu4-tahwcqhc9iz0sgcw7lnmsi.png" height="400" width="500"><br><br>  <b>Ini</b> adalah fungsi logaritma natural, dan <b>arctanh ()</b> adalah fungsi tangen hiperbolik terbalik. <br><br><h1>  Pemilihan model </h1><br>  Saat menemukan model yang baik, terkadang kita dihadapkan pada kekurangan / kelebihan data.  Contoh berikut dipinjam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> .  Ini menunjukkan masalah bekerja dengan ini dan bagaimana kita dapat menggunakan regresi linier dengan fitur polinomial untuk memperkirakan fungsi-fungsi non-linear.  Fungsi yang ditentukan: <br><br><img src="https://habrastorage.org/webt/s8/cx/ey/s8cxeys7x5so7oet9x1gywgjle4.png" height="200" width="300"><br><br>  Dalam program selanjutnya, kami mencoba menggunakan model linear dan polinomial untuk memperkirakan persamaan.  Kode yang sedikit dimodifikasi ditampilkan di sini.  Program ini menggambarkan efek dari kekurangan / kelebihan data pada model: <br><br><pre> <code class="bash hljs">import sklearn import numpy as np import matplotlib.pyplot as plt from sklearn.pipeline import Pipeline from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression from sklearn.model_selection import cross_val_score <span class="hljs-comment"><span class="hljs-comment"># np.random.seed(123) n= 30 # number of samples degrees = [1, 4, 15] def true_fun(x): return np.cos(1.5*np.pi*x) x = np.sort(np.random.rand(n)) y = true_fun(x) + np.random.randn(n) * 0.1 plt.figure(figsize=(14, 5)) title="Degree {}\nMSE = {:.2e}(+/- {:.2e})" name1="polynomial_features" name2="linear_regression" name3="neg_mean_squared_error" # for i in range(len(degrees)): ax=plt.subplot(1,len(degrees),i+1) plt.setp(ax, xticks=(), yticks=()) pFeatures=PolynomialFeatures(degree=degrees[i],include_bias=False) linear_regression = LinearRegression() pipeline=Pipeline([(name1,pFeatures),(name2,linear_regression)]) pipeline.fit(x[:,np.newaxis],y) scores=cross_val_score(pipeline,x[:,np.newaxis],y,scoring=name3,cv=10) xTest = np.linspace(0, 1, 100) plt.plot(xTest,pipeline.predict(xTest[:,np.newaxis]),label="Model") plt.plot(xTest,true_fun(xTest),label="True function") plt.scatter(x,y,edgecolor='b',s=20,label="Samples") plt.xlabel("x") plt.ylabel("y") plt.xlim((0,1)) plt.ylim((-2,2)) plt.legend(loc="best") plt.title(title.format(degrees[i],-scores.mean(),scores.std())) plt.show()</span></span></code> </pre><br>  Grafik yang dihasilkan ditunjukkan di sini: <br><br><img src="https://habrastorage.org/webt/nz/4q/io/nz4qioulhxn9jmgwprxj2e_zffo.png"><br><br><h3>  Paket python - model-catwalk </h3><br>  Contohnya dapat ditemukan di <a href="">sini</a> . <br><br>  Beberapa baris kode pertama ditampilkan di sini: <br><br><pre> <code class="bash hljs">import datetime import pandas from sqlalchemy import create_engine from metta import metta_io as metta from catwalk.storage import FSModelStorageEngine, CSVMatrixStore from catwalk.model_trainers import ModelTrainer from catwalk.predictors import Predictor from catwalk.evaluation import ModelEvaluator from catwalk.utils import save_experiment_and_get_hash <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(FSModelStorageEngine)</code> </pre> <br>  Kesimpulan yang sesuai ditunjukkan di sini.  Untuk menghemat ruang, hanya bagian atas yang disajikan: <br><br><pre> <code class="bash hljs">Help on class FSModelStorageEngine <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> module catwalk.storage: class FSModelStorageEngine(ModelStorageEngine) | Method resolution order: | FSModelStorageEngine | ModelStorageEngine | builtins.object | | Methods defined here: | | __init__(self, *args, **kwargs) | Initialize self. See <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(self)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> accurate signature. | | get_store(self, model_hash) | | ----------------------------------------------------------------------</code> </pre><br><pre> <code class="bash hljs">| Data descriptors inherited from ModelStorageEngine: | | __dict__ | dictionary <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance variables (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined) | | __weakref__ | list of weak references to the object (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined)</code> </pre><br><h3>  Paket python - sklearn </h3><br>  Karena <i>sklearn</i> adalah paket yang sangat berguna, ada baiknya menunjukkan lebih banyak contoh penggunaan paket ini.  Contoh yang diberikan di sini menunjukkan cara menggunakan paket untuk mengklasifikasikan dokumen berdasarkan topik menggunakan pendekatan bag-of-words. <br>  Contoh ini menggunakan matriks <i>scipy.sparse</i> untuk menyimpan objek dan menunjukkan berbagai pengklasifikasi yang secara efisien dapat memproses matriks jarang.  Contoh ini menggunakan dataset 20 newsgroup.  Ini akan diunduh secara otomatis dan kemudian di-cache.  File zip berisi file input dan dapat diunduh di <a href="">sini</a> .  Kode tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Untuk menghemat ruang, hanya beberapa baris pertama yang ditampilkan: <br><br><pre> <code class="bash hljs">import logging import numpy as np from optparse import OptionParser import sys from time import time import matplotlib.pyplot as plt from sklearn.datasets import fetch_20newsgroups from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.feature_extraction.text import HashingVectorizer from sklearn.feature_selection import SelectFromModel</code> </pre><br>  Output yang sesuai ditunjukkan di sini: <br><br><img src="https://habrastorage.org/webt/i-/tb/sv/i-tbsvgaud04-iz5chghtgp2zqq.png"><br><br>  Ada tiga indikator untuk setiap metode: penilaian, waktu pelatihan dan waktu pengujian. <br><br><h3>  Paket Julia - QuantEcon </h3><br>  Ambil contoh, penggunaan rantai Markov: <br><br><pre> <code class="bash hljs">using QuantEcon P = [0.4 0.6; 0.2 0.8]; mc = MarkovChain(P) x = simulate(mc, 100000); mean(x .== 1) <span class="hljs-comment"><span class="hljs-comment"># mc2 = MarkovChain(P, ["employed", "unemployed"]) simulate(mc2, 4)</span></span></code> </pre> <br>  Hasil: <br><br><img src="https://habrastorage.org/webt/6x/ru/4p/6xru4ppkn3ebq_sa6etrwlefdeu.png"><br><br>  Tujuan dari contoh ini adalah untuk melihat bagaimana seseorang dari satu status ekonomi di masa depan berubah menjadi orang lain.  Pertama, mari kita lihat tabel berikut: <br><br><img src="https://habrastorage.org/webt/1y/so/ho/1ysoho1nccj6fr7_zyh_ebvrcbu.png"><br><br>  Mari kita lihat oval paling kiri dengan status "buruk".  0,9 berarti bahwa seseorang dengan status ini memiliki peluang 90% untuk tetap miskin, dan 10% masuk ke kelas menengah.  Itu dapat diwakili oleh matriks berikut, nol adalah di mana tidak ada tepi antara node: <br><br><img src="https://habrastorage.org/webt/5o/cn/m4/5ocnm45t6i6i_nalizeusknyjxi.png" height="200" width="400"><br><br>  Dikatakan bahwa dua keadaan, x dan y, saling terkait jika ada bilangan bulat positif j dan k, seperti: <br><br><img src="https://habrastorage.org/webt/rb/d9/_l/rbd9_lo7hsj78rafch1eposdsgy.png"><br><br>  Rantai Markov <i>P</i> disebut irreducible jika semua negara terhubung;  yaitu, jika <i>x</i> dan <i>y</i> dilaporkan untuk masing-masing (x, y).  Kode berikut akan mengkonfirmasi ini: <br><br><pre> <code class="bash hljs">using QuantEcon P = [0.9 0.1 0.0; 0.4 0.4 0.2; 0.1 0.1 0.8]; mc = MarkovChain(P) is_irreducible(mc)</code> </pre><br>  Grafik berikut menunjukkan kasus yang ekstrem, karena status orang miskin di masa mendatang adalah 100% miskin: <br><br><img src="https://habrastorage.org/webt/xj/1h/u_/xj1hu_jmqywzhb1plv68dvy0sgk.png" height="600" width="400"><br><br>  Kode berikut juga akan mengkonfirmasi ini, karena hasilnya akan <i>salah</i> : <br><br><pre> <code class="bash hljs">using QuantEcon P2 = [1.0 0.0 0.0; 0.1 0.8 0.1; 0.0 0.2 0.8]; mc2 = MarkovChain(P2) is_irreducible(mc2)</code> </pre><br><h1>  Uji Kausalitas Granger </h1><br>  Uji kausalitas Granger digunakan untuk menentukan apakah satu rangkaian waktu merupakan faktor dan memberikan informasi yang berguna untuk memprediksi yang kedua.  Kode berikut menggunakan <i>dataset</i> bernama <i>ChickEgg</i> sebagai ilustrasi.  Kumpulan data memiliki dua kolom, jumlah ayam dan jumlah telur, dengan cap waktu: <br><br><pre> <code class="bash hljs">library(lmtest) data(ChickEgg) dim(ChickEgg)</code> </pre><br><pre> <code class="bash hljs">[1] 54 2</code> </pre> <br><pre> <code class="bash hljs">ChickEgg[1:5,]</code> </pre> <br><pre> <code class="bash hljs">chicken egg [1,] 468491 3581 [2,] 449743 3532 [3,] 436815 3327 [4,] 444523 3255 [5,] 433937 3156</code> </pre> <br>  Pertanyaannya adalah, dapatkah kita menggunakan jumlah telur tahun ini untuk memprediksi jumlah ayam tahun depan? <br><br>  Jika demikian, maka jumlah ayam akan menjadi alasan Granger untuk jumlah telur.  Jika ini bukan masalahnya, kami katakan bahwa jumlah ayam bukan alasan Granger untuk jumlah telur.  Ini kode yang relevan: <br><br><pre> <code class="bash hljs">library(lmtest) data(ChickEgg) grangertest(chicken~egg, order = 3, data = ChickEgg)</code> </pre> <br><br><pre> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: chicken ~ Lags(chicken, 1:3) + Lags(egg, 1:3) Model 2: chicken ~ Lags(chicken, 1:3) Res.Df Df F Pr(&gt;F) 1 44 2 47 -3 5.405 0.002966 ** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  Pada model 1, kami mencoba menggunakan lag ayam ditambah lag telur untuk menjelaskan jumlah anak ayam. <br><br>  Karena  nilai <b>P</b> cukup kecil (signifikan pada 0,01), kami mengatakan bahwa jumlah telur adalah alasan Granger untuk jumlah ayam. <br><br>  Tes berikut menunjukkan bahwa data pada ayam tidak dapat digunakan untuk memprediksi periode berikut: <br><br><pre> <code class="bash hljs">grangertest(egg~chicken, order = 3, data = ChickEgg)</code> </pre><br><pre> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: egg ~ Lags(egg, 1:3) + Lags(chicken, 1:3) Model 2: egg ~ Lags(egg, 1:3) Res.Df Df F Pr(&gt;F) 1 44 2 47 -3 0.5916 0.6238</code> </pre><br>  Dalam contoh berikut, kami memeriksa profitabilitas IBM dan S &amp; P500 untuk mengetahui bahwa mereka adalah alasan Granger untuk yang lain. <br><br>  Pertama, kami mendefinisikan fungsi hasil: <br><br><pre> <code class="bash hljs">ret_f&lt;-<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(x,ticker=<span class="hljs-string"><span class="hljs-string">""</span></span>){ n&lt;-nrow(x) p&lt;-x[,6] ret&lt;-p[2:n]/p[1:(n-1)]-1 output&lt;-data.frame(x[2:n,1],ret) name&lt;-paste(<span class="hljs-string"><span class="hljs-string">"RET_"</span></span>,toupper(ticker),sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) colnames(output)&lt;-c(<span class="hljs-string"><span class="hljs-string">"DATE"</span></span>,name) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>(output) }</code> </pre><br><pre> <code class="bash hljs">&gt;x&lt;-read.csv(<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/data/ibmDaily.csv"</span></span>,header=T) ibmRet&lt;-ret_f(x,<span class="hljs-string"><span class="hljs-string">"ibm"</span></span>) x&lt;-read.csv(<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/data/^gspcDaily.csv"</span></span>,header=T) mktRet&lt;-ret_f(x,<span class="hljs-string"><span class="hljs-string">"mkt"</span></span>) final&lt;-merge(ibmRet,mktRet) head(final)</code> </pre><br><pre> <code class="bash hljs"> DATE RET_IBM RET_MKT 1 1962-01-03 0.008742545 0.0023956877 2 1962-01-04 -0.009965497 -0.0068887673 3 1962-01-05 -0.019694350 -0.0138730891 4 1962-01-08 -0.018750380 -0.0077519519 5 1962-01-09 0.011829467 0.0004340133 6 1962-01-10 0.001798526 -0.0027476933</code> </pre><br>  Sekarang fungsi dapat dipanggil dengan nilai input.  Tujuan dari program ini adalah untuk menguji apakah kita dapat menggunakan jeda pasar untuk menjelaskan keuntungan IBM.  Dengan cara yang sama, kami memeriksa untuk menjelaskan keterlambatan pendapatan pasar IBM: <br><br><pre> <code class="bash hljs">library(lmtest) grangertest(RET_IBM ~ RET_MKT, order = 1, data =final)</code> </pre><br><pre> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: RET_IBM ~ Lags(RET_IBM, 1:1) + Lags(RET_MKT, 1:1) Model 2: RET_IBM ~ Lags(RET_IBM, 1:1) Res.Df Df F Pr(&gt;F) 1 14149 2 14150 -1 24.002 9.729e-07 *** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  Hasil menunjukkan bahwa S &amp; P500 dapat digunakan untuk menjelaskan profitabilitas IBM untuk periode berikutnya, karena secara statistik signifikan pada 0,1%.  Kode berikut akan memeriksa untuk melihat apakah kelambatan IBM menjelaskan perubahan dalam S &amp; P500: <br><br><pre> <code class="bash hljs">grangertest(RET_MKT ~ RET_IBM, order = 1, data =final)</code> </pre><br><pre> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: RET_MKT ~ Lags(RET_MKT, 1:1) + Lags(RET_IBM, 1:1) Model 2: RET_MKT ~ Lags(RET_MKT, 1:1) Res.Df Df F Pr(&gt;F) 1 14149 2 14150 -1 7.5378 0.006049 ** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  Hasilnya menunjukkan bahwa selama periode ini, pengembalian IBM dapat digunakan untuk menjelaskan indeks S &amp; P500 untuk periode berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428321/">https://habr.com/ru/post/id428321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428307/index.html">Java Challengers # 1: Metode Overloading di JVM</a></li>
<li><a href="../id428311/index.html">TrustZone: OS tepercaya dan aplikasinya</a></li>
<li><a href="../id428313/index.html">Telegram pada MacOS [mungkin] juga secara lokal menyimpan korespondensi dalam bentuk yang dapat diakses</a></li>
<li><a href="../id428315/index.html">5 ketakutan pengembang yang telah kami atasi</a></li>
<li><a href="../id428317/index.html">Bereaksi kait - menang atau kalah?</a></li>
<li><a href="../id428327/index.html">Apa yang harus diperhatikan: Peraturan Identifikasi Elektronik eIDAS Eropa</a></li>
<li><a href="../id428329/index.html">Pelatihan penguatan: parsing video game</a></li>
<li><a href="../id428333/index.html">2018 RAIF Hackathon AI Hackathon Hasil</a></li>
<li><a href="../id428335/index.html">Pembaruan Shortcut Siri</a></li>
<li><a href="../id428337/index.html">Menghibur JavaScript: Tanpa kurung kurawal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>