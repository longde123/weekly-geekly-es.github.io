<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèø üëÅÔ∏è üë≤üèª Gesti√≥n de secretos con HashiCorp Vault üë©üèΩ‚Äçü§ù‚Äçüë®üèæ ü§ô üîä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øC√≥mo guardar secretos? ¬øEn el repositorio, en el sistema de implementaci√≥n o en el sistema de gesti√≥n de configuraci√≥n? ¬øEn una computadora personal,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gesti√≥n de secretos con HashiCorp Vault</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/438740/">  ¬øC√≥mo guardar secretos?  ¬øEn el repositorio, en el sistema de implementaci√≥n o en el sistema de gesti√≥n de configuraci√≥n?  ¬øEn una computadora personal, en servidores o tal vez en una caja debajo de la cama?  ¬øY c√≥mo gestionar los secretos para evitar fugas? <br><br>  <strong>Sergey Noskov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Albibek</a> ), el jefe del grupo de seguridad de la informaci√≥n de la plataforma de Avito</strong> , conoce la respuesta a estas preguntas y compartir√° con nosotros.  En Avito, la B√≥veda HashiCorp ha estado utilizando activamente la B√≥veda HashiCorp durante dos a√±os, tiempo durante el cual obtuvieron golpes y bombearon experiencia al nivel "Maestro". <br><br>  En el art√≠culo hablaremos exhaustivamente sobre Vault: qu√© es, d√≥nde y c√≥mo se usa en la empresa, c√≥mo Avito maneja los secretos usando HashiCorp Vault, c√≥mo se usan Puppet y Kubernetes, casos de uso con Puppet y otros SCM, qu√© problemas surgen, qu√© perjudica la seguridad y desarrolladores, y, por supuesto, comparten ideas sobre c√≥mo solucionarlo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDdDPU6moTs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><h2>  ¬øQu√© es un secreto? </h2><br>  Cualquier informaci√≥n confidencial: <br><br><ul><li>  inicio de sesi√≥n y contrase√±a, por ejemplo, a la base de datos; </li><li>  Claves API </li><li>  Clave de certificado del servidor (* .google.com) </li><li>  clave de certificado de cliente (socios, dinero Yandex, QIWI); </li><li>  clave para firmar aplicaciones m√≥viles. </li></ul><br>  Toda la informaci√≥n que queremos mantener en secreto, la llamamos un secreto.  Esto crea un problema de almacenamiento: almacenar en el repositorio es incorrecto, en forma cifrada; debe guardar las claves de cifrado en alg√∫n lugar. <br><br>  <strong>HashiCorp Vault</strong> es una de las buenas soluciones al problema. <br><br><ul><li>  Almacena y gestiona llaves de forma segura. </li><li>  Afilado en el mundo de los microservicios, desde el propio microservicio. </li><li>  <strong>HashiCorp Vault</strong> ha hecho mucho para autenticar y autorizar el acceso a secretos, como las ACL y el principio de privilegios m√≠nimos. </li><li>  Interfaz REST con JSON. </li><li>  La seguridad no es perfecta, pero a un nivel bastante alto. </li></ul><br>  En mi opini√≥n, esta es una herramienta bastante conveniente. <br><br><h2>  ¬øQu√© hay de nuevo en HashiCorp Vault? <br></h2><br>  La herramienta se est√° desarrollando y en los √∫ltimos a√±os han aparecido muchas caracter√≠sticas interesantes: encabezados CORS para GUI sin intermediarios;  GUI incorporada;  integraci√≥n nativa con Kubernetes;  plugins para backends l√≥gicos y de autenticaci√≥n y framework. <br><br>  La mayor√≠a de los cambios que personalmente me gustaron son la <strong>capacidad de no escribir extensiones y adiciones</strong> que quedar√°n fuera de la herramienta. <br><br>  Por ejemplo, hay Vault, desea expandirlo: escriba l√≥gica adicional o su propia interfaz de usuario para la automatizaci√≥n, que automatizar√° algo.  Antes de los cambios, tuve que generar un servicio adicional que Vault enfrenta y que representa todas las solicitudes: primero las solicitudes van al servicio, luego a Vault.  Esto es malo porque en el servicio intermedio puede haber un nivel reducido de seguridad y todos los secretos lo atraviesan.  <strong>¬°Los riesgos de seguridad son mucho mayores cuando el secreto pasa por varios puntos a la vez!</strong> <br><br><h2>  Problema de pollo y huevo <br></h2><br>  Cuando plantea el problema de almacenar informaci√≥n confidencial y decide cifrar, tan pronto como cifra algo, su secreto se mueve desde el lugar de cifrado hasta el lugar donde se almacena la clave.  Esto sucede todo el tiempo: tan pronto como haya guardado un secreto en alg√∫n lugar o haya cambiado uno existente, tendr√° otro y comenzar√° un c√≠rculo encantado: <strong>d√≥nde guardar el secreto para acceder al secreto</strong> . <br><br>  El secreto para acceder al secreto es esa parte de la seguridad llamada <strong>autenticaci√≥n</strong> .  La seguridad tiene otra parte: la <strong>autorizaci√≥n.</strong>  En el proceso de autorizaci√≥n, se verifica si el usuario puede acceder exactamente donde est√° solicitando.  En el caso de Vault, hay un tercero de confianza que decide si revela el secreto o no.  La autorizaci√≥n solo resuelve parcialmente el problema. <br><br><h2>  B√≥veda HashiCorp en Avito <br></h2><br>  En Avito, HashiCorp se instala en la √∫nica instalaci√≥n grande en toda la red.  HashiCorp Vault tiene muchos backends diferentes.  Tambi√©n utilizamos el backend basado en el <strong>C√≥nsul</strong> de HashiCorp, porque Vault solo puede soportar su propia tolerancia a fallas a trav√©s del c√≥nsul. <br><br>  <strong>Unseal</strong> es una forma de no mantener la llave maestra en un solo lugar.  Cuando se inicia Vault, cifra todo en una clave, y nuevamente aparece el problema del huevo y la gallina: d√≥nde guardar un secreto, que cifrar√° todos los dem√°s secretos.  Para evitar este problema, Vault proporciona una clave compuesta, que requiere varias partes de la clave, que distribuimos a varios empleados.  En Avito, configuramos Unseal en las opciones para 3 personas de 7. Si iniciamos Vault, al menos 3 personas deben ingresar e ingresar su parte de la clave para que comience a funcionar.  La clave se divide en 7 partes y puede traer cualquiera de ellas. <br><br>  Hemos preparado un peque√±o Vault de prueba, un sandbox para desarrolladores donde pueden jugar.  Tiene la forma de un contenedor Docker y crea secretos simples para que las personas puedan tocar la herramienta con las manos y sentirse c√≥modos.  No hay C√≥nsul y agrupaci√≥n en la caja de arena, es solo un sistema de archivos en el que Vault contiene secretos cifrados y un peque√±o script para inicializar. <br><br>  Esto es lo que ahora almacenamos en Vault: <br><br><ul><li>  Casi todos los secretos para los microservicios de Kubernetes: contrase√±as de bases de datos, claves API, todo lo anterior. </li><li>  Secretos para colocar en los servidores "de hierro" y LXC. </li><li>  Tambi√©n ponemos secretos para las compilaciones de CI / CD en TeamCity en Vault.  La cobertura no es del 100%, pero es bastante aceptable. </li><li>  Las claves de todos los certificados: PKI interna, CA externas, por ejemplo, GeoTrust y similares. </li><li>  Secretos comunes para equipos. </li></ul><br>  En el interior, Vault almacena todo solo en JSON, no siempre es conveniente y requiere acciones adicionales del desarrollador, por lo que b√°sicamente publicamos secretos en forma de archivo. <br><br><blockquote>  Intentamos entregar secretos en forma de archivos. <br></blockquote><br>  No le decimos al desarrollador: "¬°Ve a Vault, toma un secreto!", Pero coloca el archivo en el disco y di: "Desarrollador, aparecer√° un archivo en tu disco, toma el secreto y ya descubriremos c√≥mo obtenerlo de Vault y traerlo a ti ". <br><img src="https://habrastorage.org/webt/rg/9o/mj/rg9omjizdszcnw0lzrr_iogfosc.png"><br><br>  Adoptamos un acuerdo simple para los campos JSON, en el que indicamos con qu√© derechos cargar el archivo.  Estos son metadatos para el sistema de archivos, y el campo de datos es una cadena codificada con el secreto mismo, que se convertir√° en el contenido del archivo. <br><br><h2>  Marioneta + Hiera + B√≥veda <br></h2><br>  Casi toda la infraestructura de Avito usa Puppet, implementa todos los servidores. <br><br>  Puppet tiene una herramienta conveniente para organizar jerarqu√≠as: <strong>Hiera</strong> .  Vault se integra muy bien con Hiera a trav√©s de un m√≥dulo adicional, porque la solicitud de valor-clave se env√≠a a esta biblioteca, y Vault es la base de datos de valor-clave en s√≠, pero con todas las caracter√≠sticas de seguridad, con cifrado transparente y la posibilidad de elegir el acceso clave. <br><br>  Por lo tanto, lo primero que implementamos es Vault in Puppet, pero con una adici√≥n: tenemos una capa intermedia llamada <strong>Router backend</strong> .  Backend del enrutador: un m√≥dulo Hiera separado, solo archivos en el disco que dice a d√≥nde debe ir Hiera para obtener la clave, en Vault o en otro lugar. <br><br>  Es necesario para que Hiera no vaya a la B√≥veda constantemente, porque ella siempre recorre toda la jerarqu√≠a.  Este no es un problema o carga de Vault, sino una caracter√≠stica de Hiera.  Por lo tanto, si deja solo el m√≥dulo para Vault sin el backend del enrutador, el Puppet master tardar√° mucho tiempo en recopilar la configuraci√≥n para el agente Puppet, ya que verificar√° cada clave en el Vault. <br><img src="https://habrastorage.org/webt/dv/di/f6/dvdif6z09jpflg98zykbwf7l7cq.png"><br><br>  Para Puppet, el problema de las gallinas y los huevos se resuelve debido al hecho de que la parte que autoriza es el Puppet master.  Es √©l quien da el secreto para acceder al secreto.  El Puppet master tiene acceso a todos los secretos a la vez, pero cada host solo puede recibir el que est√° destinado para √©l.  El host en el Puppet master ya est√° autorizado por su certificado, que se genera localmente y no deja los l√≠mites del host.  En principio, el secreto para acceder al secreto permanece, pero esto no es tan cr√≠tico. <br><br>  Nuestro proceso de revelar un nuevo secreto en Puppet consiste en los siguientes pasos. <br><br><ul><li>  Tomamos un secreto en alguna parte: alguien nos lo da o lo apaga. </li><li>  Poner un secreto en Vault, con una jerarqu√≠a como en Hiera: <strong>/puppet/role/www/site.ssl.key</strong> . </li><li>  Registramos un prefijo en el manifiesto de Puppet, que indica que el archivo est√° en Vault y d√≥nde obtenerlo. </li><li>  Escribimos la ruta en Vault en YAML para el enrutador Hiera y el backend para que Hiera pueda encontrarlo. </li><li>  Tire de la solicitud a trav√©s de GIT al repositorio de manifiesto. </li><li>  Ejecute o espere a que se ejecute el agente de Puppet. </li></ul><br>  Los agentes t√≠teres se escapan con nosotros cada 30 minutos, por lo que debe esperar un poco hasta que se revele el secreto.  Esto no causa problemas: <strong>no compartimos secretos todos los d√≠as</strong> .  Mientras Kubernetes no est√© involucrado en el negocio, no hay muchos gastos generales y estamos listos para poner secretos en Vault con nuestras manos con una automatizaci√≥n m√≠nima. <br><br>  Una ventaja adicional es que obtenemos el "chip" Hiera: el <strong>secreto puede establecerse inmediatamente para un grupo de hosts</strong> o dependiendo del rol del host, que establecemos en el rol variable. <br><br>  El √∫nico <strong>peligro</strong> : si tiene Puppet y usa Hiera, no sustituya nada que entre en las plantillas de variables porque muchos datos y variables se recopilan del lado del cliente.  Si un atacante sustituye un hecho en el cliente, el maestro de marionetas le dar√° los secretos de otras personas.  <strong>Aseg√∫rese de verificar las variables</strong> : use solo aquellas que Puppet-master no permita determinar en el lado del cliente. <br><br><h2>  ¬øQu√© hacer con SCM sin un asistente? <br></h2><br>  Si de repente no tienes Puppet, lo m√°s probable es que sea Ansible.  Para Chef y otros SCM centralizados, sus soluciones son un complemento que puede acceder a Vault.  Ofrezco varias opciones que se pueden implementar con Ansible. <br><br><h3>  Agente local <br></h3><br>  Localmente para el servidor, genere un token, que en realidad es la contrase√±a para acceder a la B√≥veda.  El token es v√°lido todo el tiempo.  Puede actualizarlo o automatizarlo.  Con esta ficha vas a la B√≥veda y te quitas tus secretos. <br><br>  La idea es que en su servidor donde necesita entregar secretos, el agente que viene a Vault est√° girando, mira todos los secretos y los pone en forma de archivos.  Usamos el agente en varios servidores separados donde no hay Puppet. <br><br>  <strong>Contras:</strong> <br><br><ul><li>  El token es f√°cil de ingresar en un segmento peque√±o, pero si tiene varias docenas de servidores implementados por d√≠a, tendr√° que generar un token para cada servidor y prescribir una pol√≠tica.  Esto es inconveniente. </li><li>  El token necesita ser actualizado. </li><li>  Agrupar servidores por rol, prop√≥sito o hechos es dif√≠cil, debe sincronizarse con Vault. </li></ul><br><h3>  Cifrado de tr√°nsito <br></h3><br>  Vault tiene una funci√≥n de cifrado de tr√°nsito, cuya esencia es que Vault act√∫a como un <strong>servidor de cifrado</strong> .  Simplemente le trae texto sin formato, y √©l, en su clave privada, que solo √©l tiene, cifra y emite el texto cerrado.  Luego, elige qui√©n puede descifrar este texto cerrado. <br><br>  Ansible tiene una entidad, tambi√©n llamada Vault.  Esta no es una B√≥veda HashiCorp, sino una <strong>B√≥veda Ansible</strong> .  No hay necesidad de confundir, y los secretos se pueden almacenar tanto en el primero como en el segundo.  Ansible tiene un complemento listo para entregar secretos de Hashicorp Vault.  Si le da acceso personal a Vault, puede descifrar secretos.  Cuando lanza Ansible, va a Vault en su nombre, descifra los secretos que est√°n encriptados en el repositorio y lo pone en producci√≥n. <br><br>  Tambi√©n hay un inconveniente: <strong>cada administrador tiene acceso a los secretos</strong> .  Pero hay una auditor√≠a: Vault sabe c√≥mo mantener un registro de actividad sobre qu√© usuario entr√≥, qu√© secreto leyeron, a cu√°l tuvo acceso.  Siempre sabes qui√©n, cu√°ndo y qu√© hizo con un secreto.  Esta opci√≥n me parece buena. <br><br><h3>  Gran defecto # 1 <br></h3><br>  El mayor inconveniente que nos causa el mayor dolor es que en Vault no se puede delegar el control total a ninguna <strong>parte de los</strong> <strong>datos a</strong> nadie.  En Vault, el acceso al secreto se lleva a cabo de manera similar a los de UNIX: los nombres suelen estar separados por barras y el resultado es un "directorio".  Cuando tienes ese camino, a veces quieres tomar parte del camino y d√°rselo a otra persona para que lo controle. <br><img src="https://habrastorage.org/webt/w-/hq/gf/w-hqgfwmxgok3_dimlgnn8baxag.png"><br><br>  Por ejemplo, usted obtuvo certificados, llamados <strong>/ certs</strong> , y desea entregarlos a oficiales de seguridad individuales que se ocupan de PKI.  Vault no puede hacer esto.  No puede otorgar el derecho de emitir derechos dentro de este prefijo, de modo que los propios guardias de seguridad puedan distribuir los derechos de los certificados a otra persona. <br><br>  <strong>Vault no tiene la capacidad de otorgar derechos selectivos para otorgar derechos</strong> .  Tan pronto como otorg√≥ el derecho de otorgar derechos, tambi√©n dio la oportunidad de obtener acceso completo a todos los secretos.  En otras palabras, no puede dar acceso a la parte de Vault. <br><br>  Este es uno de los mayores problemas.  Tengo una idea de c√≥mo resolverlo, te lo contar√© m√°s tarde. <br><br><h2>  Kubernetes <br></h2><br>  En RIT ++, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habl√©</a> sobre un sistema separado que implementamos para <strong>Kubernetes</strong> : sirve como un tercero, va a la API, verifica el acceso y luego solicita un secreto en Vault. <br><br>  Ahora nuestro sistema ha perdido relevancia, porque en Vault 0.9, apareci√≥ el soporte nativo para Kubernetes.  Ahora Vault mismo sabe c√≥mo ir a Kubernetes y asegurarse de que se permita el acceso al secreto.  Lo hace con un <strong>token de cuenta de servicio</strong> .  Por ejemplo, cuando tiene un pod desplegado, hay un <strong>JWT</strong> especial, firmado y autorizado para √©l, dise√±ado para solicitudes a la API de Kubernetes.  Con un token, tambi√©n puede iniciar sesi√≥n en Vault y obtener secretos espec√≠ficamente para su espacio de nombres. <br><br>  Todo se hace al nivel de Vault.  Es cierto que ser√° necesario iniciar un rol para cada espacio de nombres, es decir, decirle a Vault que existe dicho espacio de nombres, habr√° autorizaci√≥n y registrar d√≥nde ir a Kubernetes.  Esto se hace una vez, y luego Vault ir√° a la API, confirmar√° la validez del JWT y emitir√° su propio token de acceso. <br><br><h3>  Reglas de Kubernetes <br></h3><br>  En t√©rminos de nombre del servicio y metadatos adicionales, confiamos en los desarrolladores.  Existe una peque√±a posibilidad de que los desarrolladores puedan obtener accidental o intencionalmente los secretos de otros servicios que giran en un espacio de nombres, por lo que introdujimos una regla: <strong>un servicio</strong> , <strong>un espacio de nombres.</strong> <br><br>  Nuevo microservicio?  Obtenga un nuevo espacio de nombres con sus secretos.  No puede cruzar la frontera hacia la vecina: hay su propio token de cuenta de servicio.  <strong>La frontera de seguridad en Kubernetes en este momento es el espacio de nombres.</strong>  Si en dos espacios de nombres diferentes necesita un secreto, c√≥pielo. <br><br>  Kubernetes tiene <strong>secretos kubernetes</strong> .  Se almacenan en etcd en Kubernetes en forma no encriptada y se pueden "iluminar" en el tablero de instrumentos o cuando se inicia Kubectl get pods.  Si la autenticaci√≥n en etcd est√° deshabilitada en su cl√∫ster, o si le dio a alguien acceso completo de solo lectura, entonces todos los secretos son visibles para √©l.  Es por eso que introdujimos dos reglas: est√° <strong>prohibido usar secretos de kubernetes</strong> y est√° <strong>prohibido especificar secretos en variables de entorno en manifiestos</strong> .  Si escribe un secreto en el entorno en despliegue.yaml, esto es malo, porque el manifiesto en s√≠ puede ser visto por cualquiera que no sea perezoso. <br><br><h3>  Entrega Kubernetes <br></h3><br>  Como dije, de alguna manera debemos poner el archivo en Kubernetes.  Tenemos alg√∫n tipo de secreto: la esencia, la contrase√±a, que est√° escrita en JSON en Vault.  ¬øC√≥mo convertirlo en un archivo dentro del contenedor en Kubernetes ahora? <br><img src="https://habrastorage.org/webt/gm/ki/wb/gmkiwblvlm7ca4hiwmvhhx14wxu.png"><br><br>  La primera opci√≥n de entrega. <br><br><ul><li>  Iniciamos un contenedor init especial. </li><li>  Se parte de nuestra imagen. </li><li>  La imagen contiene una peque√±a utilidad que va a Vault con el token de cuenta de servicio, toma el secreto y lo coloca en el volumen Compartido. </li><li>  Para la utilidad, se monta un volumen compartido especial solo en la memoria TMPFS para que los secretos no pasen por el disco. </li><li>  Init-container va a Vault, pone en este volumen en forma de archivos todos los secretos que encuentra en la ruta especificada. </li><li>  A continuaci√≥n, el volumen compartido se monta en el contenedor principal en el que se requiere. </li><li>  Cuando se inicia el contenedor principal, inmediatamente obtiene lo que el desarrollador necesita: secretos en forma de un archivo en el disco. </li></ul><br>  El desarrollador solo necesita recordar el camino en el que se encuentra su secreto. <br><br>  Usamos algo como este prefijo: <br><br><pre><code class="plaintext hljs">/k8s/&lt;cluster&gt;/&lt;namespace&gt;/&lt;service&gt;/some_secret</code> </pre> <br>  El nombre del prefijo contiene el nombre del cl√∫ster, el espacio de nombres y el nombre del servicio.  Cada servicio tiene su propio secreto, cada espacio de nombres tiene su propio secreto. <br><br>  La segunda opci√≥n es su <strong>propio punto de entrada</strong> .  Ahora nos estamos moviendo hacia √©l en Avito, porque los desarrolladores tienen problemas con init-container.  En el diagrama, esta opci√≥n est√° a la derecha. <br><br>  No todos pueden permitirse su propio punto de entrada.  Podemos, as√≠ que en cada contenedor forzamos nuestro punto de entrada especial. <br><br>  Nuestro punto de entrada hace lo mismo que init-container: va a Vault con un token de cuenta de servicio, toma secretos y los apaga.  Adem√°s de los archivos, los vuelve a colocar en el entorno.  Tiene la oportunidad de ejecutar la aplicaci√≥n como lo recomienda el concepto de la aplicaci√≥n <strong>Twelve-Factor</strong> : la aplicaci√≥n toma todas las configuraciones, incluidos los secretos, de las variables de entorno. <br><br>  Las variables de entorno no son visibles en el manifiesto y el tablero, ya que se configuran mediante PID 1 (el proceso del contenedor principal) al inicio.  Estas no son variables de entorno de despliegue.yaml, sino variables de entorno establecidas por punto de entrada en el proceso.  No son visibles en el tablero, no son visibles, incluso si realiza kubectl exec en un contenedor, porque en este caso se inicia otro proceso, paralelo al PID1. <br><br><h3>  Flujo de trabajo <br></h3><br>  Desde el punto de vista organizacional, el proceso es el siguiente.  El desarrollador aprende del defensor de la seguridad o de la documentaci√≥n que no debe guardar secretos en el repositorio, sino solo en Vault.  Luego viene a nosotros y nos pregunta d√≥nde guardar secretos: env√≠a una solicitud a seguridad para establecer un prefijo.  En el futuro, puede crear un prefijo sin una solicitud, inmediatamente al crear un servicio. <br><br>  El desarrollador est√° esperando, y esto es malo, porque  lo principal para √©l es el tiempo de comercializaci√≥n.  Luego lee las instrucciones, trata con archivos largos: "inserte esa l√≠nea all√≠, inserte esta l√≠nea aqu√≠".  Un desarrollador nunca antes hab√≠a iniciado un contenedor init, pero se ve obligado a resolverlo y registrarlo en deploy.yaml (diagrama de tim√≥n). <br><br> <code>Commit -&gt; deploy -&gt; feel pain -&gt; fix -&gt; repeat</code> <br> <br>  Se compromete, espera a que TeamCity se despliegue, ve errores en TeamCity, comienza a sentir dolor, trata de arreglar algo, experimenta dolor nuevamente.  Adem√°s, se superpone que cada lanzamiento en TeamCity todav√≠a se puede poner en cola.  A veces, un desarrollador no puede resolverlo por s√≠ mismo, viene a nosotros y lo resolvemos juntos. <br><br>  B√°sicamente, el desarrollador sufre debido a sus propios errores: <strong>contenedor de inicio especificado incorrectamente o no ley√≥ la documentaci√≥n</strong> . <br><br>  La seguridad tambi√©n tiene problemas.  El guardia de seguridad recibe una aplicaci√≥n en la que siempre hay poca informaci√≥n, y todav√≠a descubrimos las preguntas que faltan: averiguar los nombres de los cl√∫steres, el espacio de nombres del servicio, ya que el desarrollador no los indica en la aplicaci√≥n y ni siquiera siempre sabe qu√© es.  Cuando descubrimos todo, creamos pol√≠ticas y roles en Vault, prescribimos pol√≠ticas a grupos y, junto con el desarrollador, comenzamos a descubrir d√≥nde y por qu√© cometi√≥ un error, y juntos leemos los registros. <br><br>  La unidad "Arquitectura" ayuda a resolver el problema ocult√°ndose del desarrollador de despliegue.yaml.  Est√°n desarrollando una pieza que genera todo para el desarrollador, incluido el punto de entrada.  Debido al hecho de que sustituimos nuestro punto de entrada, podemos usarlo no solo para entregar secretos, sino tambi√©n para otras cosas que puede necesitar hacer al inicio. <br><br><h3>  Problemas obvios con los secretos de Kubernetes. <br></h3><br><ul><li>  <strong>Flujo</strong> de <strong>trabajo muy complicado</strong> tanto para el desarrollador como para el guardia de seguridad. </li><li>  <strong>No puedes delegar nada a nadie.</strong>  El guardia de seguridad tiene acceso completo a la B√≥veda, y el acceso parcial no es posible (ver Big Flaw # 1). </li><li>  Las dificultades surgen al mover desarrolladores de un cl√∫ster a otro, de un espacio de nombres a otro, cuando se necesitan secretos compartidos, porque inicialmente se supone que los diferentes secretos son diferentes en diferentes cl√∫steres. </li></ul><br>  Decimos: ‚Äú¬øPor qu√© necesitas secretos de producci√≥n en el cl√∫ster de desarrollo?  Obtenga un secreto de prueba, ¬°adelante!  Como resultado, hay <strong>minas</strong> <strong>y secretos</strong> que son dif√≠ciles de manejar.  Si el secreto ha cambiado, no debe olvidarse de √©l, vaya y c√°mbielo por todas partes, y aunque no hay forma de determinar que es el mismo secreto, excepto por el nombre del servicio. <br><br><h3>  Idea: Kubernetes KMS <br></h3><br>  En las nuevas versiones de Kubernetes, el subsistema KMS, Servicio de administraci√≥n de claves, es una nueva funci√≥n de cifrado secreto de Kubernetes.  En v1.11 estaba en estado alfa, en v1.12 se transfiri√≥ a beta. <br><img src="https://habrastorage.org/webt/yq/nw/i9/yqnwi9a_t6atxpxdu_qrtu0qz80.png"><br>  <em>La imagen es del sitio del proyecto del proveedor de KMS para Vault, y hay un error en ella.</em>  <em>Si lo encuentra, escriba en los comentarios.</em> <br><br>  El significado de KMS es eliminar un √∫nico inconveniente: el almacenamiento de datos sin cifrar en etcd. <br><br>  KMS, como Ansible, puede hacer esto. <br><br><ul><li>  Ve a alg√∫n lado, encripta el secreto nativo de Kubernetes y ponlo en forma encriptada. </li><li>  Si es necesario, entregue a la c√°psula, descifre y coloque en forma descifrada. </li></ul><br>  Los desarrolladores han escrito un servicio especial que hace esto usando cifrado de tr√°nsito.  La idea parece estar funcionando, pero es importante recordar que los secretos dejan de estar solo bajo el control de Vault y van a otra parte, dentro del √°rea de responsabilidad de los administradores de Kubernetes. <br><br>  Contras KMS. <br><br><ul><li>  <strong>Descentralizaci√≥n del almacenamiento</strong> : <strong>toma de control de Vault a Kubernetes (etcd)</strong> .  Los secretos se vuelven incontrolables por Vault, y es bueno como un dep√≥sito centralizado de secretos.  Resulta que la mitad de los secretos en Vault, y la otra mitad en otro lugar. </li><li>  <strong>Soluci√≥n solo de Kubernetes</strong> .  Si tienes una infraestructura solo de Kubernetes, recoges Vault y casi no piensas lo que est√° almacenado all√≠, porque  contiene solo las claves de cifrado que administra correctamente: rotar regularmente, etc. Los secretos est√°n en Kubernetes, y esto es conveniente. </li><li>  <strong>Es dif√≠cil compartir secretos entre grupos</strong> .  Para cada nuevo cl√∫ster, debe comenzar de nuevo, copiando secretos como en el caso de una sola B√≥veda puede no funcionar. </li></ul><br>  Pros de KMS. <br><br><ul><li>  <strong>Soporte nativo</strong> en Kubernetes, incluida la ocultaci√≥n al mostrar el entorno. </li><li>  <strong>Autorizaci√≥n en el √°rea de responsabilidad de Kubernetes</strong> . </li><li>  <strong>Pr√°cticamente no se necesita soporte de Vault</strong> . </li><li>  <strong>Rotaci√≥n de llave fuera de la caja</strong> . </li></ul><br><h2>  CI / CD: TeamCity <br></h2><br>  Todo es simple en TeamCity, porque JetBrains escribi√≥ un complemento que puede prescribir secretos para acceder al secreto, encriptarlos con TeamCity y luego sustituirlo en porcentaje en la plantilla en alg√∫n lugar de la plantilla.  En este momento, el agente TeamCity mismo va a Vault, toma el secreto y lo trae a la compilaci√≥n como par√°metro. <br><br>  Se necesitan algunos secretos durante la implementaci√≥n, por ejemplo, migraci√≥n de base de datos o alertas en Slack.  AppRole se inicia para cada proyecto; la configuraci√≥n tambi√©n contiene un secreto (datos para AppRole), pero se ingresa en modo de solo escritura; TeamCity no permite leerlo m√°s tarde. <br><br>  TeamCity se encarga de que cuando un secreto ingrese a los registros de compilaci√≥n, se disfrace autom√°ticamente.  Como resultado, el secreto no "pasa" a trav√©s del disco o se borra del disco utilizando las herramientas de TeamCity.  Como resultado, toda la seguridad del secreto est√° bien garantizada por TeamCity y el complemento, y no se requieren bailes adicionales con una pandereta <br><br><h3>  ¬øCI / CD no es TeamCity? <br></h3><br>  Estos son los principales problemas a considerar si est√° utilizando un sistema diferente (no TeamCity) como CI. <br><br><ul><li>  Aislamiento: limite el alcance de un secreto a un proyecto, equipo, etc. </li><li>  Qui√©n autoriza el acceso al secreto. </li><li>  Excluya la capacidad de ver el secreto de la parte que autoriza. </li><li>  Una etapa separada de la compilaci√≥n es importar el secreto a los archivos. </li><li>  Limpia despu√©s de ti mismo. </li></ul><br>  Como resultado, lo m√°s probable es que escriba algo muy similar al complemento TeamCity para su CI / CD.  La parte que autoriza aqu√≠ probablemente sea CI / CD, y ser√° ella quien decidir√° si esta compilaci√≥n puede tener acceso a este secreto y si debe proporcionar el secreto en funci√≥n de los resultados. <br><br>  Es importante no olvidar <strong>limpiar los resultados de la compilaci√≥n al final del ensamblaje</strong> , si se colocaron en un disco, o asegurarse de que solo est√©n en la memoria. <br><br><h2>  Certificaciones <br></h2><br>  Los certificados no tienen nada de especial: utilizamos Vault principalmente para su almacenamiento. <br><img src="https://habrastorage.org/webt/ix/ye/4j/ixye4jru2blznsbq2jxmljomqi8.png"><br><br>  Vault tiene un back-end PKI especial para emitir certificados, en el que puede crear una Autoridad de certificaci√≥n y firmar nuevos certificados.  Tenemos una PKI interna √∫nica ... La CA ra√≠z y la CA de segundo nivel existen por separado, y ya administramos la CA de tercer nivel a trav√©s de Vault.  Para almacenar certificados emitidos de cualquier nivel, incluidos los certificados firmados por CA externas, utilizamos un prefijo separado y colocamos all√≠ casi todos los certificados v√°lidos para fines de contabilidad y monitoreo.  El formato para almacenar certificados es propietario, adecuado para almacenar una clave privada separada y el certificado en s√≠. <br><br><h2>  Resumen <br></h2><br>  <strong>Demasiado trabajo manual</strong> para el guardia de seguridad, <strong>demasiado umbral de entrada para el desarrollador</strong> y sin herramientas de delegaci√≥n integradas, aunque realmente quiero ... <br><br>  Como ser  Entonces comienzan los sue√±os. <br><br><h2>  Ideas: como hacerlo mejor <br></h2><br>  ¬øC√≥mo puedo deshacerme de un mont√≥n de copias de un secreto? <br><br><h3>  Entrega maestro-esclavo <br></h3><br>  Tenemos un secreto maestro y un demonio especial que camina, mira el secreto y sus metadatos, lo pone donde sea necesario, resulta ser un secreto esclavo.  En el camino donde el demonio envi√≥ al esclavo, nada se puede cambiar a mano, porque el demonio vendr√° y volver√° a colocar el secreto maestro encima del esclavo. <br><br>  Al principio quer√≠amos hacer un mecanismo de enlace simb√≥lico para indicar simplemente: "¬°Busque este secreto all√≠!", Como en Linux.  Result√≥ que hay problemas con los derechos de acceso: no se sabe c√≥mo verificar los derechos de acceso, como en Linux o no, con rutas principales, con transiciones entre puntos de montaje.  Hay demasiados momentos ambiguos y posibilidades de cometer un error, por lo que rechazamos los enlaces simb√≥licos. <br><br><h3>  Autorizaci√≥n de propiedad <br></h3><br>  Lo segundo que queremos hacer es <strong>determinar el propietario de cada secreto</strong> .  Por defecto, el secreto pertenece a la persona que lo cre√≥.  Si es necesario, puede ampliar el √°rea de responsabilidad de la unidad emitiendo un grupo de propietarios. <br><br>  Cuando aprendamos a delegar, le daremos al propietario el derecho a un secreto, y √©l podr√° hacer con el secreto lo que quiera. <br><br><ul><li>  Difundido en k8s: se genera una pol√≠tica, se crea una copia esclava. </li><li>  Propagaci√≥n en el servidor: se genera una pol√≠tica, se crea una copia esclava. </li><li>  Difundido en CI / CD - ... </li><li>  Transferencia a otro propietario. </li><li>  Dar nuevo acceso, generar nuevas ACL. </li></ul><br>  Ahora somos responsables de todos los secretos y la seguridad, pero queremos transferir la responsabilidad al creador.  <strong>La seguridad no se ver√° afectada</strong> , porque la persona que nos solicit√≥ mantener un secreto comprende que necesita mantener un secreto de manera segura y es consciente de su responsabilidad. <br><br>  Como es el propietario del secreto, para la opci√≥n de entrega maestro-esclavo, podr√≠a elegir d√≥nde y en qu√© formato se le debe entregar el secreto.  Resulta que el propietario maneja todo por s√≠ mismo, no hay necesidad de enviar solicitudes, puede tomar el prefijo necesario usted mismo, tambi√©n puede crear y eliminar secretos usted mismo. <br><br><h3>  Delegaci√≥n a trav√©s de plantillas de ACL <br></h3><br>  La pol√≠tica de acceso de la Lista de control de acceso en Vault se divide en dos partes: <br><br><ul><li>  Lista de control de acceso en la vista cl√°sica, que describe el acceso al prefijo, qu√© forma de leer y escribir, qu√© solo leer, etc. </li><li>  Al crear una ACL dentro, puede escribir un asterisco al final, lo que significa "este prefijo y todo lo que est√° debajo".  El prefijo se puede asignar como una operaci√≥n separada, dada al usuario o grupo, es decir, adjuntada a varias entidades diferentes. </li></ul><br>  En este momento, solo el administrador de Vault puede cambiar la ACL.  Despu√©s de obtener acceso a dicha ACL, puede prescribir todo lo que desee dentro, por ejemplo, la <code>path ‚Äú*‚Äù { capabilities = [sudo, ...] }</code> , y obtener acceso completo.  Esta es la esencia de <strong>Biggest Flaw</strong> # 1: <strong>es imposible prohibir cambiar el</strong> <strong>contenido de ACL.</strong> <br><br>  Queremos establecer las ACL con una plantilla preparada que contenga la ruta y los marcadores de posici√≥n en los que se permite generar nuevas ACL para esta plantilla. <br><br><h4>  Ejemplo <br></h4><br>  A continuaci√≥n se muestra la fuente amarilla, la ruta de acceso de la ACL est√°ndar terminada de Vault y las acciones permitidas en esta ruta.  Lo consideramos como una ACL para obtener permiso para cambiar otra ACL a continuaci√≥n, que se proporciona en forma de plantilla. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Queremos delegar el acceso a / k8s, permitimos que solo se generen dichas plantillas.  Por ejemplo, otorgue acceso de solo lectura a un cl√∫ster espec√≠fico, espacio de nombres, servicio, pero no cambie el campo de capacidades. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Adem√°s, queremos dar permiso para vincular estas ACL y emitir diferentes derechos. <br><br>  Aplicamos la plantilla para otorgar derechos al desarrollador.  Al <code>$ vault write policy-mgr/create/k8s-microservice ...</code> plantillas, ejecut√≥ el <code>$ vault write policy-mgr/create/k8s-microservice ...</code>  Y como resultado, obtuvimos una ACL que establece cluster = prod, namespace = ..., service = ... etc.  Los derechos se establecieron autom√°ticamente, se cre√≥ una pol√≠tica con el nombre <code>/k8s/some-srv</code> ; este es solo el nombre de ACL que se puede generar a partir de la plantilla. <br><img src="https://habrastorage.org/webt/ro/ih/ur/roihurfk7gxhvrv-hjpik6lctxc.png"><br><br>  Como resultado, el desarrollador, a nuestra discreci√≥n, asigna esta ACL a cualquier persona que quiera, y se convierte en el propietario, puede administrarla en secreto: eliminar, dar y quitar a usuarios y grupos.  Ahora la persona misma es responsable de su prefijo: administra todos los secretos, genera ACL de acuerdo con la plantilla, puede asignar ACL a los que desee.  Naturalmente, tambi√©n podemos limitarlo. <br><br>  Toda la magia funciona con la nueva entidad Vault: <strong>complementos</strong> .  Son un servicio separado, muy similar al que mencion√© al principio, y funcionan casi exactamente igual.  La √∫nica diferencia importante es que no son representantes.  Los complementos se lanzan "al costado" de Vault, y lanza su proceso principal de Vault.  Debido a esto, todas las solicitudes no pasan por el servicio, sino a Vault, que ya interact√∫a con el complemento y le env√≠a una solicitud verificada y aprobada. <br><br>  Sobre los complementos, c√≥mo est√°n organizados y c√≥mo escribirlos, puede leerlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Vault</a> .  Es mejor escribirlos en Go, que es bastante simple, porque  Hay un marco para Go.  Vault se comunica con el complemento a trav√©s de grpc, lo lanza como un servicio, pero no se asuste, no lo toca, todo ya est√° en el marco.  Simplemente escribe una aplicaci√≥n REST m√°s o menos est√°ndar en la que especifica puntos finales, les da funciones listas para usar, controladores que tendr√°n l√≥gica en ellos. <br><br>  No tengas miedo de romper algo en la B√≥veda principal.  Un complemento es un servicio separado.  Incluso si su complemento entr√≥ en p√°nico y se bloque√≥, no interrumpir√° el trabajo de Vault.  Vault simplemente reiniciar√° el complemento y continuar√° funcionando. <br><br>  Adem√°s, hay configuraciones adicionales para el complemento en s√≠: siempre verifica las sumas hash para que nadie cambie el binario.  <strong>Se proporciona la seguridad de ejecutar complementos</strong> . <br><br><h2>  Enlaces utiles: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.vaultproject.io</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/jovandeginste/hiera-router</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/jsok/hiera-vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.owasp.org/index.php/Security_Champions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog.jetbrains.com/teamcity/2017/09/vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/oracle/kubernetes-vault-kms-plugin</a> </li></ul><br><blockquote>  Hablaremos sobre DevOps y seguridad, CI / CD, k8s, Puppet y todo eso en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> (el m√°s cercano en San Petersburgo en abril) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOpsConf</a> .  Ven y comparte tu experiencia o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mira</a> a los dem√°s.  Para no olvidar, suscr√≠base al blog y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n informativo</a> , en el que le recordaremos los plazos y recopilaremos materiales √∫tiles. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438740/">https://habr.com/ru/post/438740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438726/index.html">Y Combinator: c√≥mo cerrar una empresa</a></li>
<li><a href="../438730/index.html">HomoLudens: Happy Birthday, Sid Meyer (+ todos los art√≠culos en ruso)</a></li>
<li><a href="../438732/index.html">Mediciones de radioaficionados: an√°lisis de se√±al de bus I2C</a></li>
<li><a href="../438734/index.html">Mara√±a de personas de ideas afines</a></li>
<li><a href="../438736/index.html">DevDay for Managers: Administre TI</a></li>
<li><a href="../438746/index.html">En el camino hacia los principios f√≠sicos de la evoluci√≥n biol√≥gica. Continuaci√≥n</a></li>
<li><a href="../438748/index.html">Infraestructura como c√≥digo, ganamos a escala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../438750/index.html">Civilizaci√≥n de Springs, 4/5</a></li>
<li><a href="../438752/index.html">Contabilidad directamente en el banco: c√≥mo hacer felices a los empresarios individuales</a></li>
<li><a href="../438754/index.html">C√≥mo hicimos el monitoreo de red para 14,000 objetos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>