<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😮 🖐️ 🔡 Der neue Raumschiffoperator in C ++ 20 🤾🏻 🔇 🌁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 fügt einen neuen Operator namens "Raumschiff" hinzu: <=> . Vor nicht allzu langer Zeit veröffentlichte Simon Brand einen Beitrag , der detaill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der neue Raumschiffoperator in C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458242/"> C ++ 20 fügt einen neuen Operator namens "Raumschiff" hinzu: <code>&lt;=&gt;</code> .  Vor nicht allzu langer Zeit veröffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simon Brand</a> einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> , der detaillierte konzeptionelle Informationen darüber enthielt, was dieser Operator ist und für welche Zwecke er verwendet wird.  Die Hauptaufgabe dieses Beitrags besteht darin, die spezifischen Anwendungen des „seltsamen“ neuen Operators und seines analogen <code>operator==</code> und einige Empfehlungen für seine Verwendung in der täglichen Codierung zu formulieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"></div><a name="habracut"></a><br><h2>  Vergleich </h2><br>  Es ist nicht ungewöhnlich, Code wie den folgenden zu sehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Hinweis: Aufmerksame Leser werden feststellen, dass dies sogar noch weniger ausführlich ist, als es im Code vor C ++ 20 sein sollte.</i>  <i>Dazu später mehr.</i> <br><br>  Sie müssen viel Standardcode schreiben, um sicherzustellen, dass unser Typ mit etwas vom gleichen Typ vergleichbar ist.  Ok, wir werden es für eine Weile herausfinden.  Dann kommt jemand, der so schreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Das erste, was Sie bemerken werden, ist, dass das Programm nicht kompiliert wird. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Das Problem ist, dass <code>constexpr</code> in der Vergleichsfunktion vergessen wurde.  Dann fügen <code>constexpr</code> allen Vergleichsoperatoren <code>constexpr</code> hinzu.  Einige Tage später wird jemand den <code>is_gt</code> hinzufügen. <code>is_gt</code> jedoch, dass nicht alle Vergleichsoperatoren eine Ausnahmespezifikation haben und Sie denselben mühsamen Prozess <code>noexcept</code> , bei dem jeder der 5 Überladungen <code>noexcept</code> hinzugefügt wird. <br><br>  Hier hilft uns der neue C ++ 20-Raumschiffbetreiber.  Mal sehen, wie Sie den ursprünglichen <code>IntWrapper</code> in der C ++ 20-Welt schreiben können: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Der erste Unterschied, den Sie möglicherweise bemerken, ist die neue Aufnahme von <code>&lt;compare&gt;</code> .  Der <code>&lt;compare&gt;</code> -Header ist dafür verantwortlich, den Compiler mit allen Arten von Vergleichskategorien zu füllen, die für den Raumschiffoperator erforderlich sind, damit er einen Typ zurückgibt, der für unsere Standardfunktion geeignet ist.  Im obigen Snippet <code>std::strong_ordering</code> der Rückgabetyp von <code>auto</code> <code>std::strong_ordering</code> . <br><br>  Wir haben nicht nur 5 zusätzliche Zeilen gelöscht, sondern müssen auch nicht einmal etwas bestimmen, der Compiler wird dies für uns tun.  <code>is_lt</code> bleibt unverändert und funktioniert nur, während <code>is_lt</code> bleibt, obwohl wir dies in unserem Standardoperator <code>operator&lt;=&gt;</code> nicht explizit angegeben haben.  Das ist gut, aber einige Leute <code>is_lt</code> vielleicht, warum <code>is_lt</code> kompiliert werden darf, auch wenn der Raumschiffoperator überhaupt nicht verwendet wird.  Lassen Sie uns die Antwort auf diese Frage finden. <br><br><h2>  Ausdrücke umschreiben </h2><br>  In C ++ 20 wird der Compiler in ein neues Konzept eingeführt, das sich auf „umgeschriebene“ Ausdrücke bezieht.  Der Raumschiffoperator ist zusammen mit <code>operator==</code> einer der ersten beiden Kandidaten, die neu geschrieben werden können.  Ein genaueres Beispiel für das Umschreiben von Ausdrücken finden Sie in dem Beispiel in <code>is_lt</code> . <br><br>  Während der Behebung der Überlastung wählt der Compiler aus einer Reihe der am besten geeigneten Kandidaten aus, von denen jeder dem von uns benötigten Operator entspricht.  Der Auswahlprozess ändert sich für Vergleichs- und Äquivalenzoperationen geringfügig, wenn der Compiler auch spezielle transkribierte und synthetisierte Kandidaten sammeln muss ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Für unseren Ausdruck <code>a &lt; b</code> Standard an, dass wir nach Typ <code>a</code> für <code>operator&lt;=&gt;</code> oder <code>operator&lt;=&gt;</code> suchen können, die diesen Typ akzeptieren.  Dies macht der Compiler und stellt fest, dass der Typ <code>a</code> tatsächlich <code>IntWrapper::operator&lt;=&gt;</code> .  Der Compiler darf dann diesen Operator verwenden und den Ausdruck <code>a &lt; b</code> als <code>(a &lt;=&gt; b) &lt; 0</code> umschreiben.  Dieser umgeschriebene Ausdruck wird dann als Kandidat für eine normale Überlastungsauflösung verwendet. <br><br>  Sie können fragen, warum dieser umgeschriebene Ausdruck korrekt ist.  Die Richtigkeit des Ausdrucks ergibt sich tatsächlich aus der Semantik, die der Raumschiffoperator bereitstellt.  <code>&lt;=&gt;</code> ist ein Drei-Wege-Vergleich, der impliziert, dass Sie nicht nur ein binäres Ergebnis erhalten, sondern auch eine Reihenfolge (in den meisten Fällen).  Wenn Sie eine Bestellung haben, können Sie diese Bestellung in Form von Vergleichsvorgängen ausdrücken.  Ein kurzes Beispiel: Ausdruck 4 &lt;=&gt; 5 in C ++ 20 gibt das Ergebnis <code>std::strong_ordering::less</code> .  Das Ergebnis von <code>std::strong_ordering::less</code> impliziert, dass <code>4</code> nicht nur von <code>5</code> verschieden ist, sondern auch strikt unter diesem Wert liegt, wodurch die Anwendung der Operation <code>(4 &lt;=&gt; 5) &lt; 0</code> korrekt und genau ist, um unser Ergebnis zu beschreiben. <br><br>  Unter Verwendung der obigen Informationen kann der Compiler jeden verallgemeinerten Vergleichsoperator (d. H. <code>&lt;</code> , <code>&gt;</code> Usw.) nehmen und ihn in Bezug auf den Raumschiffoperator umschreiben.  Im Standard wird ein umgeschriebener Ausdruck häufig als <code>(a &lt;=&gt; b) @ 0</code> wobei <code>@</code> eine beliebige Vergleichsoperation darstellt. <br><br><h2>  Ausdrücke synthetisieren </h2><br>  Die Leser haben möglicherweise einen subtilen Verweis auf die oben genannten „synthetisierten“ Ausdrücke bemerkt und spielen auch eine Rolle bei diesem Prozess des Umschreibens von Aussagen.  Betrachten Sie die folgende Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Wenn wir unsere ursprüngliche Definition für <code>IntWrapper</code> , wird dieser Code nicht kompiliert. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Dies ist vor C ++ 20 <code>IntWrapper</code> dieses Problem zu lösen, müssen Sie <code>IntWrapper</code> einige zusätzliche <code>friend</code> Funktionen <code>IntWrapper</code> , die sich auf der linken Seite des <code>int</code> .  Wenn Sie versuchen, dieses Beispiel mit dem Compiler und der <code>IntWrapper</code> C ++ 20-Definition zu <code>IntWrapper</code> , stellen Sie möglicherweise fest, dass es wieder funktioniert.  Schauen wir uns an, warum der obige Code in C ++ 20 noch kompiliert wird. <br><br>  Beim Auflösen von Überladungen sammelt der Compiler auch das, was der Standard als "synthetisierte" Kandidaten bezeichnet, oder einen neu geschriebenen Ausdruck mit der umgekehrten Reihenfolge der Parameter.  Im obigen Beispiel versucht der Compiler, den umgeschriebenen Ausdruck <code>(42 &lt;=&gt; a) &lt; 0</code> , stellt jedoch fest, dass keine Konvertierung von <code>IntWrapper</code> nach <code>int</code> , um die linke Seite zu erfüllen, sodass der umgeschriebene Ausdruck verworfen wird.  Der Compiler ruft auch den "synthetisierten" Ausdruck <code>0 &lt; (a &lt;=&gt; 42)</code> und erkennt, dass eine Konvertierung von <code>int</code> nach <code>IntWrapper</code> über seinen Konvertierungskonstruktor erfolgt, sodass dieser Kandidat verwendet wird. <br><br>  Der Zweck synthetisierter Ausdrücke besteht darin, die Verwirrung beim Schreiben von Vorlagen für Freundfunktionen zu vermeiden, um die Lücken zu füllen, in die Ihr Objekt von anderen Typen konvertiert werden kann.  Synthetisierte Ausdrücke werden auf <code>0 @ (b &lt;=&gt; a)</code> verallgemeinert. <br><br><h2>  Komplexere Typen </h2><br>  Der vom Compiler generierte Raumschiffoperator stoppt nicht bei einzelnen Mitgliedern von Klassen, sondern generiert die richtigen Vergleiche für alle Unterobjekte in Ihren Typen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Der Compiler weiß, wie Klassenmitglieder, die Arrays sind, in ihre Liste von Unterobjekten erweitert und rekursiv verglichen werden.  Wenn Sie die Hauptteile dieser Funktionen selbst schreiben möchten, profitieren Sie natürlich weiterhin vom Umschreiben von Ausdrücken durch den Compiler. <br><br><h2>  Sieht aus wie eine Ente, schwimmt wie eine Ente und quakt wie <code>operator==</code> </h2><br>  Einige sehr kluge Leute im Standardisierungskomitee haben bemerkt, dass der Raumschiffbetreiber immer einen lexikografischen Vergleich von Elementen durchführen wird, egal was passiert.  Die bedingungslose Ausführung von lexikografischen Vergleichen kann insbesondere mit dem Gleichheitsoperator zu ineffizientem Code führen. <br><br>  Ein kanonisches Beispiel für den Vergleich zweier Zeilen.  Wenn Sie die Zeichenfolge <code>"foobar"</code> und sie mit == mit der Zeichenfolge <code>"foo"</code> vergleichen, können Sie davon ausgehen, dass diese Operation nahezu konstant ist.  Ein effektiver String-Vergleichsalgorithmus lautet wie folgt: <br><br><ul><li>  Vergleichen Sie zunächst die Größe der beiden Zeilen.  Wenn die Größen unterschiedlich sind, geben Sie <code>false</code> </li><li>  Andernfalls gehen Sie Schritt für Schritt durch jedes Element aus zwei Zeilen und vergleichen Sie sie, bis ein Unterschied vorliegt oder alle Elemente enden.  Geben Sie das Ergebnis zurück. </li></ul><br>  In Übereinstimmung mit den Regeln des Raumschiffoperators müssen wir zunächst jedes Element vergleichen, bis wir eines finden, das anders ist.  In unserem Beispiel <code>"foobar"</code> und <code>"foo"</code> nur beim Vergleich von <code>'b'</code> und <code>'\0'</code> schließlich <code>false</code> . <br><br>  Um dem entgegenzuwirken, gab es Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> , in dem detailliert beschrieben wird, wie der Compiler den <code>operator==</code> unabhängig vom Raumschiffoperator neu schreibt und generiert.  Unser <code>IntWrapper</code> kann wie folgt geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Noch ein Schritt ... es gibt jedoch gute Nachrichten;  Sie müssen den obigen Code nicht wirklich schreiben, da das Schreiben des <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> ausreicht, damit der Compiler implizit einen separaten und effizienteren <code>operator==</code> für Sie generiert! <br><br>  Der Compiler wendet eine leicht modifizierte "Umschreib" -Regel an, die spezifisch für <code>==</code> und <code>!=</code> Ist. In diesen Operatoren werden sie als <code>operator&lt;=&gt;</code> <code>operator==</code> und nicht als <code>operator&lt;=&gt;</code> umgeschrieben.  Dies bedeutet, dass <code>!=</code> Auch von der Optimierung profitiert. <br><br><h2>  Alter Code wird nicht kaputt gehen </h2><br>  An dieser Stelle könnte man denken: Nun, wenn der Compiler diese Operation zum Umschreiben des Operators ausführen darf, was passiert, wenn ich versuche, den Compiler zu überlisten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Die Antwort ist keine große Sache.  Das Überlastungsauflösungsmodell in C ++ ist die Arena, in der alle Kandidaten aufeinander treffen.  In dieser besonderen Schlacht haben wir drei davon: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (umgeschrieben) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthetisiert) <br><br>  Wenn wir in C ++ 17 Überlastungsauflösungsregeln übernehmen würden, wäre das Ergebnis dieses Aufrufs gemischt, aber die C ++ 20-Überlastungsauflösungsregeln wurden geändert, damit der Compiler diese Situation auf die logischste Überladung auflösen kann. <br><br>  Es gibt eine Überlastungsauflösungsphase, in der der Compiler eine Reihe zusätzlicher Durchgänge ausführen muss.  In C ++ 20 ist ein neuer Mechanismus erschienen, bei dem Überladungen bevorzugt werden, die nicht überschrieben oder synthetisiert werden. <code>IntWrapper::operator&lt;</code> wird unser <code>IntWrapper::operator&lt;</code> Überladen zum besten Kandidaten und löst Mehrdeutigkeiten auf.  Der gleiche Mechanismus verhindert die Verwendung synthetisierter Kandidaten anstelle der üblichen umgeschriebenen Ausdrücke. <br><br><h2>  Letzte Gedanken </h2><br>  Der Raumschiffoperator ist eine willkommene Ergänzung zu C ++, da er dazu beitragen kann, Ihren Code zu vereinfachen und weniger zu schreiben, und manchmal ist weniger besser.  Also schnall dich an und kontrolliere dein C ++ 20 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raumschiff</a> ! <br><br>  Wir empfehlen Ihnen dringend, den Raumschiff-Operator auszuprobieren. Er ist ab sofort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2019</a> unter <code>/std:c++latest</code> verfügbar.  Hinweis: Änderungen am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> sind in Visual Studio 2019 Version 16.2 verfügbar.  Bitte beachten Sie, dass der Raumschiffoperator Teil von C ++ 20 ist und bis zum Abschluss von C ++ 20 einige Änderungen unterliegen kann. <br><br>  Wie immer erwarten wir Ihr Feedback.  Sie können Kommentare per E-Mail an <a href="">visualcpp@microsoft.com</a> , über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter @visualc</a> oder Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Visual Cpp senden</a> . <br><br>  Wenn Sie in VS 2019 auf andere Probleme mit MSVC stoßen, teilen Sie uns dies bitte über die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Problem</a> melden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“ mit</a> , entweder vom Installationsprogramm oder von der Visual Studio-IDE selbst.  Für Vorschläge oder Fehlerberichte schreiben Sie uns über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458242/">https://habr.com/ru/post/de458242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458220/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 304 (vom 24. bis 30. Juni)</a></li>
<li><a href="../de458224/index.html">Die Software für die Boeing-737 Max wurde von Outsourcern geschrieben, die 9 US-Dollar pro Stunde verdienen</a></li>
<li><a href="../de458228/index.html">Warum brauchen wir virtuelle Funktionen?</a></li>
<li><a href="../de458230/index.html">Wie KI, Drohnen und Kameras unsere Straßen und Brücken schützen</a></li>
<li><a href="../de458240/index.html">Wie künstliche Intelligenz, Drohnen und Kameras die Sicherheit von Straßen und Brücken gewährleisten</a></li>
<li><a href="../de458244/index.html">Eine endlose und lächerliche Liste dessen, was Sie wissen müssen, um öffentliche Wi-Fi-Netzwerke sicher nutzen zu können</a></li>
<li><a href="../de458246/index.html">Zufällige Zufälle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen präsentiert wurde</a></li>
<li><a href="../de458248/index.html">Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</a></li>
<li><a href="../de458250/index.html">BTRFS für die Kleinsten</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>