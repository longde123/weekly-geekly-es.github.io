<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÆ üñêÔ∏è üî° Der neue Raumschiffoperator in C ++ 20 ü§æüèª üîá üåÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 f√ºgt einen neuen Operator namens "Raumschiff" hinzu: <=> . Vor nicht allzu langer Zeit ver√∂ffentlichte Simon Brand einen Beitrag , der detaill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der neue Raumschiffoperator in C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458242/"> C ++ 20 f√ºgt einen neuen Operator namens "Raumschiff" hinzu: <code>&lt;=&gt;</code> .  Vor nicht allzu langer Zeit ver√∂ffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simon Brand</a> einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> , der detaillierte konzeptionelle Informationen dar√ºber enthielt, was dieser Operator ist und f√ºr welche Zwecke er verwendet wird.  Die Hauptaufgabe dieses Beitrags besteht darin, die spezifischen Anwendungen des ‚Äûseltsamen‚Äú neuen Operators und seines analogen <code>operator==</code> und einige Empfehlungen f√ºr seine Verwendung in der t√§glichen Codierung zu formulieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"></div><a name="habracut"></a><br><h2>  Vergleich </h2><br>  Es ist nicht ungew√∂hnlich, Code wie den folgenden zu sehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Hinweis: Aufmerksame Leser werden feststellen, dass dies sogar noch weniger ausf√ºhrlich ist, als es im Code vor C ++ 20 sein sollte.</i>  <i>Dazu sp√§ter mehr.</i> <br><br>  Sie m√ºssen viel Standardcode schreiben, um sicherzustellen, dass unser Typ mit etwas vom gleichen Typ vergleichbar ist.  Ok, wir werden es f√ºr eine Weile herausfinden.  Dann kommt jemand, der so schreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Das erste, was Sie bemerken werden, ist, dass das Programm nicht kompiliert wird. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Das Problem ist, dass <code>constexpr</code> in der Vergleichsfunktion vergessen wurde.  Dann f√ºgen <code>constexpr</code> allen Vergleichsoperatoren <code>constexpr</code> hinzu.  Einige Tage sp√§ter wird jemand den <code>is_gt</code> hinzuf√ºgen. <code>is_gt</code> jedoch, dass nicht alle Vergleichsoperatoren eine Ausnahmespezifikation haben und Sie denselben m√ºhsamen Prozess <code>noexcept</code> , bei dem jeder der 5 √úberladungen <code>noexcept</code> hinzugef√ºgt wird. <br><br>  Hier hilft uns der neue C ++ 20-Raumschiffbetreiber.  Mal sehen, wie Sie den urspr√ºnglichen <code>IntWrapper</code> in der C ++ 20-Welt schreiben k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Der erste Unterschied, den Sie m√∂glicherweise bemerken, ist die neue Aufnahme von <code>&lt;compare&gt;</code> .  Der <code>&lt;compare&gt;</code> -Header ist daf√ºr verantwortlich, den Compiler mit allen Arten von Vergleichskategorien zu f√ºllen, die f√ºr den Raumschiffoperator erforderlich sind, damit er einen Typ zur√ºckgibt, der f√ºr unsere Standardfunktion geeignet ist.  Im obigen Snippet <code>std::strong_ordering</code> der R√ºckgabetyp von <code>auto</code> <code>std::strong_ordering</code> . <br><br>  Wir haben nicht nur 5 zus√§tzliche Zeilen gel√∂scht, sondern m√ºssen auch nicht einmal etwas bestimmen, der Compiler wird dies f√ºr uns tun.  <code>is_lt</code> bleibt unver√§ndert und funktioniert nur, w√§hrend <code>is_lt</code> bleibt, obwohl wir dies in unserem Standardoperator <code>operator&lt;=&gt;</code> nicht explizit angegeben haben.  Das ist gut, aber einige Leute <code>is_lt</code> vielleicht, warum <code>is_lt</code> kompiliert werden darf, auch wenn der Raumschiffoperator √ºberhaupt nicht verwendet wird.  Lassen Sie uns die Antwort auf diese Frage finden. <br><br><h2>  Ausdr√ºcke umschreiben </h2><br>  In C ++ 20 wird der Compiler in ein neues Konzept eingef√ºhrt, das sich auf ‚Äûumgeschriebene‚Äú Ausdr√ºcke bezieht.  Der Raumschiffoperator ist zusammen mit <code>operator==</code> einer der ersten beiden Kandidaten, die neu geschrieben werden k√∂nnen.  Ein genaueres Beispiel f√ºr das Umschreiben von Ausdr√ºcken finden Sie in dem Beispiel in <code>is_lt</code> . <br><br>  W√§hrend der Behebung der √úberlastung w√§hlt der Compiler aus einer Reihe der am besten geeigneten Kandidaten aus, von denen jeder dem von uns ben√∂tigten Operator entspricht.  Der Auswahlprozess √§ndert sich f√ºr Vergleichs- und √Ñquivalenzoperationen geringf√ºgig, wenn der Compiler auch spezielle transkribierte und synthetisierte Kandidaten sammeln muss ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  F√ºr unseren Ausdruck <code>a &lt; b</code> Standard an, dass wir nach Typ <code>a</code> f√ºr <code>operator&lt;=&gt;</code> oder <code>operator&lt;=&gt;</code> suchen k√∂nnen, die diesen Typ akzeptieren.  Dies macht der Compiler und stellt fest, dass der Typ <code>a</code> tats√§chlich <code>IntWrapper::operator&lt;=&gt;</code> .  Der Compiler darf dann diesen Operator verwenden und den Ausdruck <code>a &lt; b</code> als <code>(a &lt;=&gt; b) &lt; 0</code> umschreiben.  Dieser umgeschriebene Ausdruck wird dann als Kandidat f√ºr eine normale √úberlastungsaufl√∂sung verwendet. <br><br>  Sie k√∂nnen fragen, warum dieser umgeschriebene Ausdruck korrekt ist.  Die Richtigkeit des Ausdrucks ergibt sich tats√§chlich aus der Semantik, die der Raumschiffoperator bereitstellt.  <code>&lt;=&gt;</code> ist ein Drei-Wege-Vergleich, der impliziert, dass Sie nicht nur ein bin√§res Ergebnis erhalten, sondern auch eine Reihenfolge (in den meisten F√§llen).  Wenn Sie eine Bestellung haben, k√∂nnen Sie diese Bestellung in Form von Vergleichsvorg√§ngen ausdr√ºcken.  Ein kurzes Beispiel: Ausdruck 4 &lt;=&gt; 5 in C ++ 20 gibt das Ergebnis <code>std::strong_ordering::less</code> .  Das Ergebnis von <code>std::strong_ordering::less</code> impliziert, dass <code>4</code> nicht nur von <code>5</code> verschieden ist, sondern auch strikt unter diesem Wert liegt, wodurch die Anwendung der Operation <code>(4 &lt;=&gt; 5) &lt; 0</code> korrekt und genau ist, um unser Ergebnis zu beschreiben. <br><br>  Unter Verwendung der obigen Informationen kann der Compiler jeden verallgemeinerten Vergleichsoperator (d. H. <code>&lt;</code> , <code>&gt;</code> Usw.) nehmen und ihn in Bezug auf den Raumschiffoperator umschreiben.  Im Standard wird ein umgeschriebener Ausdruck h√§ufig als <code>(a &lt;=&gt; b) @ 0</code> wobei <code>@</code> eine beliebige Vergleichsoperation darstellt. <br><br><h2>  Ausdr√ºcke synthetisieren </h2><br>  Die Leser haben m√∂glicherweise einen subtilen Verweis auf die oben genannten ‚Äûsynthetisierten‚Äú Ausdr√ºcke bemerkt und spielen auch eine Rolle bei diesem Prozess des Umschreibens von Aussagen.  Betrachten Sie die folgende Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Wenn wir unsere urspr√ºngliche Definition f√ºr <code>IntWrapper</code> , wird dieser Code nicht kompiliert. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Dies ist vor C ++ 20 <code>IntWrapper</code> dieses Problem zu l√∂sen, m√ºssen Sie <code>IntWrapper</code> einige zus√§tzliche <code>friend</code> Funktionen <code>IntWrapper</code> , die sich auf der linken Seite des <code>int</code> .  Wenn Sie versuchen, dieses Beispiel mit dem Compiler und der <code>IntWrapper</code> C ++ 20-Definition zu <code>IntWrapper</code> , stellen Sie m√∂glicherweise fest, dass es wieder funktioniert.  Schauen wir uns an, warum der obige Code in C ++ 20 noch kompiliert wird. <br><br>  Beim Aufl√∂sen von √úberladungen sammelt der Compiler auch das, was der Standard als "synthetisierte" Kandidaten bezeichnet, oder einen neu geschriebenen Ausdruck mit der umgekehrten Reihenfolge der Parameter.  Im obigen Beispiel versucht der Compiler, den umgeschriebenen Ausdruck <code>(42 &lt;=&gt; a) &lt; 0</code> , stellt jedoch fest, dass keine Konvertierung von <code>IntWrapper</code> nach <code>int</code> , um die linke Seite zu erf√ºllen, sodass der umgeschriebene Ausdruck verworfen wird.  Der Compiler ruft auch den "synthetisierten" Ausdruck <code>0 &lt; (a &lt;=&gt; 42)</code> und erkennt, dass eine Konvertierung von <code>int</code> nach <code>IntWrapper</code> √ºber seinen Konvertierungskonstruktor erfolgt, sodass dieser Kandidat verwendet wird. <br><br>  Der Zweck synthetisierter Ausdr√ºcke besteht darin, die Verwirrung beim Schreiben von Vorlagen f√ºr Freundfunktionen zu vermeiden, um die L√ºcken zu f√ºllen, in die Ihr Objekt von anderen Typen konvertiert werden kann.  Synthetisierte Ausdr√ºcke werden auf <code>0 @ (b &lt;=&gt; a)</code> verallgemeinert. <br><br><h2>  Komplexere Typen </h2><br>  Der vom Compiler generierte Raumschiffoperator stoppt nicht bei einzelnen Mitgliedern von Klassen, sondern generiert die richtigen Vergleiche f√ºr alle Unterobjekte in Ihren Typen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Der Compiler wei√ü, wie Klassenmitglieder, die Arrays sind, in ihre Liste von Unterobjekten erweitert und rekursiv verglichen werden.  Wenn Sie die Hauptteile dieser Funktionen selbst schreiben m√∂chten, profitieren Sie nat√ºrlich weiterhin vom Umschreiben von Ausdr√ºcken durch den Compiler. <br><br><h2>  Sieht aus wie eine Ente, schwimmt wie eine Ente und quakt wie <code>operator==</code> </h2><br>  Einige sehr kluge Leute im Standardisierungskomitee haben bemerkt, dass der Raumschiffbetreiber immer einen lexikografischen Vergleich von Elementen durchf√ºhren wird, egal was passiert.  Die bedingungslose Ausf√ºhrung von lexikografischen Vergleichen kann insbesondere mit dem Gleichheitsoperator zu ineffizientem Code f√ºhren. <br><br>  Ein kanonisches Beispiel f√ºr den Vergleich zweier Zeilen.  Wenn Sie die Zeichenfolge <code>"foobar"</code> und sie mit == mit der Zeichenfolge <code>"foo"</code> vergleichen, k√∂nnen Sie davon ausgehen, dass diese Operation nahezu konstant ist.  Ein effektiver String-Vergleichsalgorithmus lautet wie folgt: <br><br><ul><li>  Vergleichen Sie zun√§chst die Gr√∂√üe der beiden Zeilen.  Wenn die Gr√∂√üen unterschiedlich sind, geben Sie <code>false</code> </li><li>  Andernfalls gehen Sie Schritt f√ºr Schritt durch jedes Element aus zwei Zeilen und vergleichen Sie sie, bis ein Unterschied vorliegt oder alle Elemente enden.  Geben Sie das Ergebnis zur√ºck. </li></ul><br>  In √úbereinstimmung mit den Regeln des Raumschiffoperators m√ºssen wir zun√§chst jedes Element vergleichen, bis wir eines finden, das anders ist.  In unserem Beispiel <code>"foobar"</code> und <code>"foo"</code> nur beim Vergleich von <code>'b'</code> und <code>'\0'</code> schlie√ülich <code>false</code> . <br><br>  Um dem entgegenzuwirken, gab es Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> , in dem detailliert beschrieben wird, wie der Compiler den <code>operator==</code> unabh√§ngig vom Raumschiffoperator neu schreibt und generiert.  Unser <code>IntWrapper</code> kann wie folgt geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Noch ein Schritt ... es gibt jedoch gute Nachrichten;  Sie m√ºssen den obigen Code nicht wirklich schreiben, da das Schreiben des <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> ausreicht, damit der Compiler implizit einen separaten und effizienteren <code>operator==</code> f√ºr Sie generiert! <br><br>  Der Compiler wendet eine leicht modifizierte "Umschreib" -Regel an, die spezifisch f√ºr <code>==</code> und <code>!=</code> Ist. In diesen Operatoren werden sie als <code>operator&lt;=&gt;</code> <code>operator==</code> und nicht als <code>operator&lt;=&gt;</code> umgeschrieben.  Dies bedeutet, dass <code>!=</code> Auch von der Optimierung profitiert. <br><br><h2>  Alter Code wird nicht kaputt gehen </h2><br>  An dieser Stelle k√∂nnte man denken: Nun, wenn der Compiler diese Operation zum Umschreiben des Operators ausf√ºhren darf, was passiert, wenn ich versuche, den Compiler zu √ºberlisten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Die Antwort ist keine gro√üe Sache.  Das √úberlastungsaufl√∂sungsmodell in C ++ ist die Arena, in der alle Kandidaten aufeinander treffen.  In dieser besonderen Schlacht haben wir drei davon: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (umgeschrieben) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthetisiert) <br><br>  Wenn wir in C ++ 17 √úberlastungsaufl√∂sungsregeln √ºbernehmen w√ºrden, w√§re das Ergebnis dieses Aufrufs gemischt, aber die C ++ 20-√úberlastungsaufl√∂sungsregeln wurden ge√§ndert, damit der Compiler diese Situation auf die logischste √úberladung aufl√∂sen kann. <br><br>  Es gibt eine √úberlastungsaufl√∂sungsphase, in der der Compiler eine Reihe zus√§tzlicher Durchg√§nge ausf√ºhren muss.  In C ++ 20 ist ein neuer Mechanismus erschienen, bei dem √úberladungen bevorzugt werden, die nicht √ºberschrieben oder synthetisiert werden. <code>IntWrapper::operator&lt;</code> wird unser <code>IntWrapper::operator&lt;</code> √úberladen zum besten Kandidaten und l√∂st Mehrdeutigkeiten auf.  Der gleiche Mechanismus verhindert die Verwendung synthetisierter Kandidaten anstelle der √ºblichen umgeschriebenen Ausdr√ºcke. <br><br><h2>  Letzte Gedanken </h2><br>  Der Raumschiffoperator ist eine willkommene Erg√§nzung zu C ++, da er dazu beitragen kann, Ihren Code zu vereinfachen und weniger zu schreiben, und manchmal ist weniger besser.  Also schnall dich an und kontrolliere dein C ++ 20 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raumschiff</a> ! <br><br>  Wir empfehlen Ihnen dringend, den Raumschiff-Operator auszuprobieren. Er ist ab sofort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2019</a> unter <code>/std:c++latest</code> verf√ºgbar.  Hinweis: √Ñnderungen am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> sind in Visual Studio 2019 Version 16.2 verf√ºgbar.  Bitte beachten Sie, dass der Raumschiffoperator Teil von C ++ 20 ist und bis zum Abschluss von C ++ 20 einige √Ñnderungen unterliegen kann. <br><br>  Wie immer erwarten wir Ihr Feedback.  Sie k√∂nnen Kommentare per E-Mail an <a href="">visualcpp@microsoft.com</a> , √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter @visualc</a> oder Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Visual Cpp senden</a> . <br><br>  Wenn Sie in VS 2019 auf andere Probleme mit MSVC sto√üen, teilen Sie uns dies bitte √ºber die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûProblem</a> melden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äú mit</a> , entweder vom Installationsprogramm oder von der Visual Studio-IDE selbst.  F√ºr Vorschl√§ge oder Fehlerberichte schreiben Sie uns √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458242/">https://habr.com/ru/post/de458242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458220/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 304 (vom 24. bis 30. Juni)</a></li>
<li><a href="../de458224/index.html">Die Software f√ºr die Boeing-737 Max wurde von Outsourcern geschrieben, die 9 US-Dollar pro Stunde verdienen</a></li>
<li><a href="../de458228/index.html">Warum brauchen wir virtuelle Funktionen?</a></li>
<li><a href="../de458230/index.html">Wie KI, Drohnen und Kameras unsere Stra√üen und Br√ºcken sch√ºtzen</a></li>
<li><a href="../de458240/index.html">Wie k√ºnstliche Intelligenz, Drohnen und Kameras die Sicherheit von Stra√üen und Br√ºcken gew√§hrleisten</a></li>
<li><a href="../de458244/index.html">Eine endlose und l√§cherliche Liste dessen, was Sie wissen m√ºssen, um √∂ffentliche Wi-Fi-Netzwerke sicher nutzen zu k√∂nnen</a></li>
<li><a href="../de458246/index.html">Zuf√§llige Zuf√§lle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen pr√§sentiert wurde</a></li>
<li><a href="../de458248/index.html">Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</a></li>
<li><a href="../de458250/index.html">BTRFS f√ºr die Kleinsten</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>