<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öæÔ∏è üçæ üëæ Von der API zuerst bei Swagger bis zum Einzelvertrag bei RAML üë©üèº‚Äç‚öïÔ∏è üßÄ ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo% Benutzername%! 

 Sie wissen wahrscheinlich, was APIs sind und wie viel davon in Ihrem Projekt abh√§ngt. Dar√ºber hinaus glaube ich auch, dass Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Von der API zuerst bei Swagger bis zum Einzelvertrag bei RAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419525/"><img src="https://habrastorage.org/webt/cj/pv/it/cjpvit3gxuwcyybj7ifn7xzv8gw.png" alt="Bild"><br><br>  Hallo% Benutzername%! <br><br>  Sie wissen wahrscheinlich, was APIs sind und wie viel davon in Ihrem Projekt abh√§ngt.  Dar√ºber hinaus glaube ich auch, dass Sie bereits mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Ansatz der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> vertraut sind und dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swagger</a> und seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offene API</a> einige der beliebtesten Tools sind, mit denen er folgen kann. <br><br>  In diesem Artikel m√∂chte ich jedoch zun√§chst auf den Ansatz zur Implementierung der API eingehen, der sich konzeptionell von dem unterscheidet, was Swagger und Apiary bieten.  An der Spitze der Idee steht das Konzept des <i>Einzelvertrags</i> und die M√∂glichkeit seiner Implementierung auf Basis von RAML 1.0. <br><br>  Unter dem Schnitt: <br><br><ul><li>  Zuerst eine kurze Beschreibung der Prinzipien der API; </li><li>  <i>Einzelvertrag</i> - Einf√ºhrung eines Konzepts, Voraussetzungen f√ºr das Erscheinen, Pr√ºfung der M√∂glichkeit seiner Umsetzung auf der Grundlage von OAS (Swagger); </li><li>  RAML + Anmerkungen + √úberlagerungen als Basis f√ºr <i>Einzelvertr√§ge</i> , Beispiele; </li><li>  RAML-Probleme, konzeptionelle Meinungsverschiedenheiten von Entwicklern; </li><li>  Die Idee eines SaaS-Dienstes basiert auf der obigen Idee (Prototypbild oben). </li></ul><br><br><a name="habracut"></a><br><h2>  Von der API zuerst bei Swagger bis zum Einzelvertrag bei RAML </h2><br>  Beim Entwurf moderner Softwaresysteme entsteht h√§ufig die Aufgabe, Schnittstellen f√ºr die Interaktion ihrer Komponenten miteinander zu koordinieren und zu entwickeln.  In den letzten zehn Jahren haben SPA und dicke mobile Anwendungen, die √ºber APIs mit dem Server interagieren, eine immense Popularit√§t und Entwicklung erlangt.  Fr√ºher wurde die Entwicklung einer interaktiven Website durch schrittweise Bearbeitung des serverseitigen Codes durchgef√ºhrt, um HTML-Markups mit anschlie√üender √úbertragung an den Browser des Clients zu generieren. Jetzt hat sich die Entwicklung dynamischer Webanwendungen auf die Erstellung einer einzigen Service-API und die parallele Entwicklung vieler Anwendungen (einschlie√ülich SPA) verlagert mit dieser API als Hauptdatenquelle.  Mit diesem Ansatz k√∂nnen Sie Aufgaben bequemer teilen, Teams organisieren, die sich nur auf bestimmte Technologien spezialisiert haben (spezialisiertere Spezialisten anziehen), die parallele Entwicklung in den ersten Phasen organisieren und einen einzigen Kommunikationspunkt erstellen - eine API-Schnittstelle. <br><br>  Ein solcher einzelner Kommunikationspunkt erfordert eine formale und eindeutige Definition. Dieses Dokument ist eine API-Spezifikation.  Um API-Spezifikationen heute zu entwickeln und zu dokumentieren, werden verschiedene Technologien und Sprachen verwendet, zum Beispiel: OAS (Swagger), Apiary und RAML. <br><br>  Die folgenden drei Punkte bestimmen die Art des ersten API-Ansatzes: <br><br><ol><li>  Die API sollte die allererste Client-Schnittstelle der entwickelten Anwendung sein. </li><li>  Zun√§chst wird eine API-Spezifikation entwickelt und dann der Software-Teil der Clients. </li><li>  Die Lebensphasen einer API sollten mit den Lebensphasen ihrer Dokumentation √ºbereinstimmen. </li></ol><br>  Wenn wir den Prozess auf der Grundlage des Vorstehenden betrachten, steht die API-Spezifikation im Mittelpunkt des Entwicklungsprozesses, und alle Knoten, aus denen das System besteht und die diese API als Interaktions-Gateway verwenden, sind Clients der API-Spezifikation.  Somit kann der Serverteil des Systems als dieselbe Client-Spezifikations-API betrachtet werden, wie jeder andere Knoten, der die API verwendet, um mit ihm zu kommunizieren.  Anwendungsdom√§nenmodelle m√ºssen nicht mit den in der API-Spezifikation beschriebenen Modellen √ºbereinstimmen.  Ihre m√∂glichen absichtlichen √úbereinstimmungen mit Klassenstrukturen im Clientanwendungscode oder mit Datenbankschemastrukturen werden eher eingef√ºhrt, um den Entwicklungsprozess zu vereinfachen, beispielsweise wenn ein Codegenerator gem√§√ü der OAS-Spezifikation verwendet wird.  Logischerweise kann das Obige unter der Definition eines <i>Einzelvertrags zusammengefasst werden</i> .  <i>Einzelvertrag</i> - viele Kunden. <br><br><h3>  Einzelvertrag.  Vertragstools und Bibliotheken </h3><br><blockquote>  Der Begriff <i>Einzelvertrag</i> beansprucht keine Teilnahme an Kritik f√ºr seine Verwendung im Text des Artikels.  Ihre Anwendung ist in diesem Zusammenhang pers√∂nlich meine Idee. </blockquote>  Wenn wir das API-Konzept <i>zun√§chst</i> auf einen allgemeineren <i>Einzelvertrag erweitern,</i> k√∂nnen wir die API-Spezifikation nicht nur als formale Beschreibung der Schnittstelle zwischen den Komponenten des Systems betrachten, sondern auch als <i>Einzelvertrag,</i> der von einer beliebigen Anzahl externer Bibliotheken und Tools als Konfigurationsquelle verwendet wird.  In diesem Fall k√∂nnen diese Tools und Bibliotheken zusammen mit SPA oder mobilen Anwendungen als Vertragskunden wahrgenommen werden.  Beispiele f√ºr solche Kunden sind: <br><br><ul><li>  Dokumentationsgenerator </li><li>  Mock-Server-API </li><li>  Stresstest-Service </li><li>  Anforderungs- / Antwortvalidierungsbibliothek </li><li>  Codegenerator </li><li>  UI-Generator </li><li>  usw. </li></ul><br>  <i>Ein einzelner Vertrag</i> f√ºr solche Clients ist eine einzelne Konfigurationsdatei und Datenquelle.  Vertragsinstrumente funktionieren nur auf der Grundlage von Informationen, die aus einem bestimmten Vertrag stammen.  F√ºr die volle Funktionalit√§t heterogener Clients wie des API-Mock-Servers reicht nat√ºrlich eine API-Beschreibung nicht aus. Zus√§tzliche Metainformationen werden ben√∂tigt, z. B. eine Beschreibung der Beziehung zwischen den GET-Anforderungsparametern (Ressourcen-ID) und den Daten, die der Server zur√ºckgeben soll, Hinweise auf die Antwortfelder und Abfrageparameter zum Organisieren der Paginierung.  Ferner wird dieses Beispiel genauer betrachtet.  Gleichzeitig m√ºssen spezifische Informationen f√ºr bestimmte Instrumente vorhanden sein und untrennbar mit dem Hauptdokument verbunden sein, da dies sonst gegen das Konzept eines einzelnen Vertrags verst√∂√üt. <br><br><h3>  Swagger (OAS) als Einzelvertragsbeschreibungstool </h3><br>  Mit den auf dem Markt beliebtesten Swagger (OAS) und Apiary (Blueprint) k√∂nnen Sie HTTP-APIs in speziellen Sprachen beschreiben: Offene API basierend auf YAML oder JSON, Blueprint basierend auf Markdown, wodurch die Spezifikationen leicht lesbar sind.  Es gibt auch viele Tools und Bibliotheken, die von der gro√üen Open-Source-Community erstellt wurden.  Swagger ist derzeit weit verbreitet und, k√∂nnte man sagen, zuerst zum De-facto-Standard der API geworden.  Viele externe Systeme unterst√ºtzen den Import von Swagger-Spezifikationen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoapUI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Readme.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apigee</a> usw.  Dar√ºber hinaus k√∂nnen Benutzer mit dem vorhandenen SaaS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swagger Hub</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apiary</a> Projekte erstellen, eigene Spezifikationen hochladen oder erstellen, die integrierten Dokumentationsgeneratoren und Mock-Server verwenden sowie Links ver√∂ffentlichen, um von au√üen auf sie zuzugreifen. <br><br>  Swagger sieht zusammen mit OAS 3.0 ziemlich sicher aus und seine Funktionalit√§t zur Beschreibung der API (besonders einfach) reicht in den meisten F√§llen aus.  Das Folgende ist eine Liste der Vor- und Nachteile von Swagger: <br><br>  Vorteile: <br><br><ul><li>  Klare und leicht lesbare Beschreibungssprache; </li><li>  Gro√üe Open-Source-Community; </li><li>  Viele offizielle und Open-Source-Editoren, Generatoren, Bibliotheken; </li><li>  Die Anwesenheit eines Kernentwicklungsteams, das st√§ndig an der Entwicklung und Verbesserung des Formats arbeitet; </li><li>  Shareware Hub f√ºr Spezifikationen; </li><li>  Detaillierte offizielle Dokumentation; </li><li>  Niedrige Eintrittsschwelle. </li></ul><br>  Nachteile: <br><br><ul><li>  Schwache Modularit√§tsunterst√ºtzung; </li><li>  Fehlen automatisch generierter Beispiele f√ºr Abfrageantworten basierend auf einer Beschreibung ihrer Strukturen; </li><li>  Es gibt h√§ufig Probleme mit der schlechten Stabilit√§t von SmartBear-Produkten (Prahlerautoren) und der sp√§ten Reaktion des Entwicklers darauf (die Meinung basiert ausschlie√ülich auf pers√∂nlichen Nutzungserfahrungen und der Erfahrung unseres Teams). </li></ul><br>  Die Hauptbeschr√§nkung, die die Verwendung von OAS als Mittel zur Beschreibung eines <i>Einzelvertrags</i> nicht zul√§sst, ist jedoch das Fehlen der M√∂glichkeit, benutzerdefinierte Metainformationen anzuh√§ngen, um zus√§tzliche Parameter von Zielwerkzeugen / -bibliotheken zu beschreiben. <br>  Daher m√ºssen alle Tools, die auf der Grundlage von Swagger-Spezifikationen arbeiten, mit den Informationen zufrieden sein, die das Grundformat unterst√ºtzen. <br><br>  Beispielsweise erfordert die Implementierung eines Smart-Mock-API-Servers mehr Informationen, als ein Spezifikationsdokument bereitstellen kann, weshalb die integrierte Swagger Hub-Mock-API nur gef√§lschte Daten basierend auf Datentypen / -strukturen generieren kann, die aus einem Spezifikationsdokument erhalten wurden.  Zweifellos reicht dies nicht aus, und eine solche Mock-Server-Funktionalit√§t kann nur von einem einfachen API-Client erf√ºllt werden. <br><br>  In unserem Unternehmen war w√§hrend der Entwicklung eines der Projekte (React SPA + API-Server) die folgende Mock-Server-Funktionalit√§t erforderlich: <br><br><ul><li>  Nachahmung der Paginierung.  Der Server sollte keine vollst√§ndig zuf√§lligen Werte der Felder currentPage, nextPage, pagesTotal als Antwort auf Listenanforderungen zur√ºckgeben, sondern in der Lage sein, das tats√§chliche Verhalten des Paginierungsmechanismus mit der Generierung der Werte dieser Metapolen in Abh√§ngigkeit vom vom Client empfangenen Seitenwert zu simulieren. </li><li>  Erzeugen von Antwortk√∂rpern, die verschiedene Datens√§tze enthalten, abh√§ngig von dem spezifischen Parameter der eingehenden Anforderung; </li><li>  Die F√§higkeit, echte Beziehungen zwischen gef√§lschten Objekten aufzubauen: <i>Das</i> Feld <i>foo_id</i> der <i>Bar-</i> Entit√§t sollte sich auf die zuvor generierte <i>Foo-</i> Entit√§t beziehen.  Dies kann erreicht werden, indem dem Mock-Server Unterst√ºtzung f√ºr Idempotenz hinzugef√ºgt wird. </li><li>  Nachahmung der Arbeit verschiedener Autorisierungsmethoden: OAuth2, JWT usw. </li></ul><br>  Ohne all dies ist es sehr schwierig, SPA parallel zur Entwicklung des Serverteils des Systems zu entwickeln.  Gleichzeitig ist ein solcher Mock-Server aus dem oben beschriebenen Grund fast unm√∂glich zu implementieren, ohne zus√§tzliche spezifische Metainformationen, die direkt in der API-Spezifikation gespeichert werden k√∂nnten, und sie √ºber das erforderliche Verhalten bei der Simulation des n√§chsten Endpunkts zu informieren.  Dieses Problem kann gel√∂st werden, indem die erforderlichen Parameter in Form einer separaten Datei mit Konfigurationen parallel zur grundlegenden OAS-Spezifikation hinzugef√ºgt werden. In diesem Fall m√ºssen Sie diese beiden unterschiedlichen Quellen jedoch separat unterst√ºtzen. <br><br>  Wenn es mehr als einen Mock-Server mit Tools gibt, die nach diesem Prinzip in der Entwicklungsprozessumgebung arbeiten, erhalten wir einen ‚ÄûZoo‚Äú von Tools, von denen jedes mit seiner eigenen einzigartigen Funktionalit√§t gezwungen ist, eine eigene eindeutige Konfigurationsdatei zu haben, die logisch mit der Basis-API verkn√ºpft ist -Spezifikationen, aber tats√§chlich getrennt gelegen und "ihr eigenes Leben" leben. <br><br><img src="https://habrastorage.org/webt/-1/2j/nx/-12jnxo_wzra4vl923py0d4hgnk.png" alt="Bild"><br><br>  Problem: Der Entwickler muss die Relevanz aller Konfigurationen beibehalten, nachdem er die Versionen der Basisspezifikation ge√§ndert hat, h√§ufig an v√∂llig anderen Orten und in v√∂llig anderen Formaten. <br><br>  Einige Beispiele f√ºr Dienste, die nach einem √§hnlichen Prinzip arbeiten: <br><br><ul><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoapUI</a></i> ist ein System zum Testen von REST- und SOAP-Schnittstellen.  Unterst√ºtzt den Import eines Projekts aus der Swagger-Spezifikation.  Beim √Ñndern der grundlegenden Swagger-Spezifikation bleibt die Konfiguration eines Projekts basierend auf einer Liste von API-Aufrufen parallel bestehen und erfordert eine manuelle Synchronisierung. </li><li>  Andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SmartBear-</a> Produkte; </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apigee</a></i> ist ein API-Lifecycle-Management-Service.  Es verwendet Swagger-Spezifikationen als Vorlagen, auf deren Grundlage es seine Konfigurationen interner Dienste initialisieren kann.  Es gibt auch keine automatische Synchronisation. </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Readme.io</a></i> ist ein Dienst, mit dem Sie eine sch√∂ne Dokumentation basierend auf der Swagger-Spezifikation erstellen k√∂nnen. Au√üerdem verf√ºgt er √ºber einen Mechanismus zum Verfolgen von √Ñnderungen an der Basisspezifikation und zum L√∂sen von Konflikten durch Aktualisieren der Projektkonfiguration auf der Dienstseite.  Dies erforderte sicherlich eine unn√∂tige Komplexit√§t bei der Entwicklung dieses Dienstes. </li></ul><br>  Sie k√∂nnen dieser Liste viele andere Dienste hinzuf√ºgen, die die Integrationsfunktion mit der Swagger-Spezifikation bereitstellen.  Integration bedeutet f√ºr die meisten von ihnen das √ºbliche Kopieren der Grundstruktur der Swagger-Spezifikation und die anschlie√üende automatische Vervollst√§ndigung der lokalen Konfigurationsfelder, ohne die Synchronisation mit √Ñnderungen an der Grundspezifikation zu unterst√ºtzen. <br><br><h3>  RAML, Anmerkungen, √úberlagerungen </h3><br>  Der Wunsch, ein Tool zu finden, das die zuvor erw√§hnte OAS-Einschr√§nkung ausschlie√üt und es uns erm√∂glicht, die Spezifikation als einen einzigen Vertrag f√ºr alle Client-Tools zu betrachten, hat uns dazu gebracht, uns mit der RAML-Sprache vertraut zu machen.  Es ist genug √ºber RAML geschrieben, Sie k√∂nnen es zum Beispiel hier lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.infoq.com/articles/power-of-raml</a> .  RAML-Entwickler haben versucht, die Sprachunterst√ºtzung f√ºr Modularit√§t auf der Ebene ihres Konzepts zu verankern.  Jetzt kann jedes Unternehmen oder jeder einzelne Entwickler seine eigenen W√∂rterb√ºcher erstellen oder vorgefertigte √∂ffentliche W√∂rterb√ºcher verwenden, um die API zu entwerfen, vorgefertigte Datenmodelle neu zu definieren und zu erben.  Ab Version 1.0 unterst√ºtzt RAML 5 verschiedene Arten externer Module: <i>Include, Library, Extension, Trait, Overlay</i> , sodass jedes Modul je nach Aufgabe so flexibel wie m√∂glich verwendet werden kann. <br><br>  Es ist an der Zeit, die Hauptm√∂glichkeit von RAML zu diskutieren, die aus Gr√ºnden, die nicht vollst√§ndig verstanden wurden, keine Analoga in OAS und Blueprint - Annotations enth√§lt. <br><blockquote>  Anmerkungen in RAML sind die M√∂glichkeit, benutzerdefinierte Metadaten an die zugrunde liegenden Sprachstrukturen anzuh√§ngen. </blockquote>  Es war diese RAML-Funktion, die zum Grund f√ºr das Schreiben dieses Artikels wurde. <br><br>  Ein Beispiel: <br><br><pre><code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Example API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> # Annotation <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> block may be placed <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> file annotationTypes: validation-rules: description: | Describes <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> validation rules <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the model properties. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> validation library allowedTargets: [ TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string[] <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip: description: | Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Documentation generator <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> showing tips allowedTargets: [ <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>, DocumentationItem, TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Intelligent mock <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> allowedTargets: [ Example ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Article: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: id: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> title: string paragraphs: Paragraph[] createdAt: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string (validation-rules): ["regex:/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?Z?/"] Paragraph: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> (validation-rules): ["min:0"] content: string (validation-rules): ["max-length:1024"] /articles/{articleId}: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip): This endpoint <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> deprecated description: <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> Article <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ID responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Article</code> </pre> <br>  Benutzeranmerkungsstrukturen selbst m√ºssen klare Beschreibungen in RAML enthalten.  Hierzu wird ein spezieller Abschnitt <i>annotationTypes</i> verwendet, dessen Definitionen auch in das externe Modul √ºbernommen werden k√∂nnen.  Auf diese Weise k√∂nnen spezielle Parameter eines externen Tools in Form von Anmerkungen definiert werden, die an die Basisdefinition der RAML-API angeh√§ngt sind.  Um zu vermeiden, dass die Grundspezifikation mit einer gro√üen Anzahl von Anmerkungen f√ºr verschiedene externe Tools √ºberladen wird, wird die M√∂glichkeit unterst√ºtzt, sie in separate Dateien zu √ºbertragen - <i>√úberlagerungen</i> (und auch <i>Erweiterungen</i> ) mit Klassifizierung nach Umfang.  In der RAML-Dokumentation ( <a href="">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#overlays</a> ) wird Folgendes √ºber Overlays gesagt: <br><blockquote>  Ein Overlay f√ºgt Knoten einer RAML-API-Definition hinzu oder √ºberschreibt sie, w√§hrend die verhaltensbezogenen und funktionalen Aspekte beibehalten werden.  Bestimmte Knoten einer RAML-API-Definition geben das Verhalten einer API an: ihre Ressourcen, Methoden, Parameter, K√∂rper, Antworten usw.  Diese Knoten k√∂nnen nicht durch Anwenden einer √úberlagerung ge√§ndert werden.  Im Gegensatz dazu befassen sich andere Knoten, wie z. B. Beschreibungen oder Anmerkungen, mit Problemen, die √ºber die funktionale Schnittstelle hinausgehen, wie z. B. die menschenorientierte beschreibende Dokumentation in einer bestimmten Sprache oder Implementierungs- oder Verifizierungsinformationen zur Verwendung in automatisierten Tools.  Diese Knoten k√∂nnen durch Anwenden einer √úberlagerung ge√§ndert werden. <br><br>  √úberlagerungen sind besonders wichtig, um die Schnittstelle von der Implementierung zu trennen.  Overlays erm√∂glichen separate Lebenszyklen f√ºr die Verhaltensaspekte der API, die streng kontrolliert werden m√ºssen, z. B. ein Vertrag zwischen dem API-Anbieter und seinen Verbrauchern, im Vergleich zu solchen, die nur wenig Kontrolle ben√∂tigen, wie z. B. die menschen- oder implementierungsorientierten Aspekte, die sich entwickeln k√∂nnen verschiedene Schritte.  Das Hinzuf√ºgen von Hooks zum Testen und √úberwachen von Tools, das Anh√§ngen von Metadaten, die f√ºr eine Registrierung von APIs relevant sind, oder das Bereitstellen aktualisierter oder √ºbersetzter menschlicher Dokumentation kann beispielsweise erreicht werden, ohne dass Aspekte der Verhaltensaspekte der API ge√§ndert werden.  Diese Dinge k√∂nnen durch einen strengen Versions- und √Ñnderungsverwaltungsprozess gesteuert werden. </blockquote>  Mit anderen Worten, diese Funktionalit√§t erm√∂glicht es Ihnen, "die Spreu von der Spreu zu trennen", beispielsweise die Hauptbeschreibung der API-Spezifikation, von zus√§tzlichen Metainformationen, die f√ºr ein bestimmtes Werkzeug spezifisch sind, das sie f√ºr die Arbeit verwendet.  Metainformationen in jeder einzelnen √úberlagerung werden in Form von Anmerkungen an verschiedene Bl√∂cke der Spezifikation ‚Äûgeh√§ngt‚Äú. <br><br>  Ein Beispiel f√ºr eine Grundstruktur: <br><br><pre> <code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Phrases API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Phrase: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: content: string /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: queryParameters: whoSaid: string responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Phrase</code> </pre><br>  √úberlagerung: <br><pre> <code class="hljs vbscript">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> Overlay usage: Applies annotations <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Intelligent mock <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> extends: example_for_article_2_1.raml annotationTypes: condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> type: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> allowedTargets: Example /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/json: examples: firstExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Hamlet content: <span class="hljs-string"><span class="hljs-string">"To be, or not to be?"</span></span> secondExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Homer Simpson content: <span class="hljs-string"><span class="hljs-string">"D'oh!"</span></span></code> </pre><br>  Dadurch wird es m√∂glich, einen einzigen Vertrag zu implementieren: Alle Funktions-, Verhaltens- und Metainformationen werden an einem einzigen Ort gespeichert und versioniert, und Vertragstools - Kunden des Vertrags - m√ºssen Unterst√ºtzung f√ºr die in dieser Spezifikation verwendeten Anmerkungen haben.  Auf der anderen Seite k√∂nnen die Tools selbst ihre eigenen Anforderungen an Anmerkungen darstellen, die an der Spezifikation ‚Äûaufgeh√§ngt‚Äú werden m√ºssen - dies bietet ein breiteres Spektrum an M√∂glichkeiten bei der Entwicklung von Vertrags-Tools. <br><br>  Das obige Konzept ist in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/w1/0i/aj/w10iajxxllknypbvu6gwcvwrtkc.png" alt="Bild"><br><br>  Unter den Minuspunkten dieses Ansatzes kann die hohe Komplexit√§t der manuellen Synchronisation der Basisspezifikationsdatei und jeder der √úberlagerungen herausgestellt werden: Wenn Sie die Struktur der Grundspezifikation aktualisieren, m√ºssen Sie die erforderlichen √Ñnderungen in den Strukturen der √úberlagerungen anwenden.  Dieses Problem wird schwerwiegender, wenn mehr als eine √úberlagerung angezeigt wird. <br><br>  Eine m√∂gliche und naheliegendste L√∂sung w√§re die Entwicklung eines speziellen Editors oder Add-Ons f√ºr den vorhandenen Online-RAML-Editor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mulesoft/api-designer</a> .  Der Bearbeitungsbereich bleibt unver√§ndert, es k√∂nnen jedoch Registerkarten erstellt werden: Jede neue Registerkarte ist ein Fenster zum Bearbeiten der ihr zugewiesenen √úberlagerung.  Beim Bearbeiten der Grundstruktur der Spezifikation im Hauptfenster √§ndern sich auch die Strukturen in allen erstellten Registerkarten. Wenn eine Inkompatibilit√§t der neuen Struktur mit vorhandenen Anmerkungen in Registerkarten√ºberlagerungen festgestellt wird, wird eine Warnung angezeigt.  Eine detailliertere Betrachtung eines solchen Herausgebers ist ein separates Thema und verdient ernsthafte Beachtung. <br><br><h3>  Bestehende Entwicklungen </h3><br>  Bei der Suche nach vorhandenen L√∂sungen, die der Verwirklichung der Idee nahe kommen, Anmerkungen als Mittel zur Beschreibung von Metainformationen zu verwenden, wurden die folgenden L√∂sungen gefunden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/raml-org/raml-annotations</a> Repository mit offiziellen Anmerkungen, die von der RAML-Entwicklergemeinde genehmigt wurden.  In der aktuellen Version sind nur OAuth2-Annotationen verf√ºgbar.  Sie k√∂nnen von externen Tools verwendet werden, um Metainformationen zu erhalten, die Aspekte der OAuth2-Implementierung f√ºr die entwickelte API-Spezifikation beschreiben. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/petrochenko-pavel-a/raml-annotations</a> Benutzeranmerkungsbibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ petrochenko-pavel-a</a> mit einer logischen Gruppierung nach Anwendungsbereich.  Das Projekt ist experimenteller, veranschaulicht jedoch perfekt die Idee der Verwendung von Anmerkungen.  Die interessantesten Anmerkungsgruppen: <br><ul><li>  <i>AdditionalValidation.raml</i> - Anmerkungen zur Beschreibung zus√§tzlicher Regeln f√ºr die Validierung von Spezifikationsmodellen.  Sie k√∂nnen beispielsweise von der Serverbibliothek zum Validieren von Abfragen gem√§√ü der RAML-Spezifikation verwendet werden. </li><li>  <i>mock.raml</i> - Anmerkungen zur Beschreibung der Details des Mock-Servers basierend auf der RAML-Spezifikation; </li><li>  <i>semanticContexts.raml</i> - Anmerkungen, die auf den semantischen Kontext der einzelnen deklarierten Strukturbl√∂cke der RAML-Spezifikation verweisen; </li><li>  <i>strukturelle.raml</i> - Anmerkungen, die die Rolle einer separaten RAML-Entit√§t in der Gesamtstruktur des beschriebenen Dom√§nenmodells verdeutlichen; </li><li>  <i>uiCore.raml</i> - ein Beispiel f√ºr Anmerkungen, die von UI-Generierungswerkzeugen basierend auf der RAML-Spezifikation verwendet werden k√∂nnen; </li></ul></li></ul><br>  Das Repository enth√§lt auch Bibliotheken von Dienstprogrammtypen, die zur Verwendung als Grundelemente zur Beschreibung von Datenstrukturen der RAML-Spezifikation geeignet sind. <br><br><h3>  RAML-Probleme </h3><br>  Trotz der Funktionalit√§t, des Fortschritts der Grundidee und der Aufmerksamkeit gro√üer Softwarehersteller (Cisco, Spotify, VMware usw.) hat RAML heute ernsthafte Probleme, die im Hinblick auf sein erfolgreiches Schicksal fatal werden k√∂nnen: <br><br><ul><li>  Kleine und fragmentierte Open-Source-Community; </li><li>  Eine unverst√§ndliche Strategie des Hauptentwicklers von RAML ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mulesoft</a> .  Das Unternehmen entwickelt Produkte, die nur eine Kopie bestehender OAS-basierter L√∂sungen (in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anypoint Platform enthalten</a> ) sind, anstatt Services zu erstellen, die die Vorteile von RAML gegen√ºber Swagger hervorheben. </li><li>  Die Konsequenz des ersten Absatzes: eine kleine Anzahl von Open-Source-Bibliotheken / Tools; </li><li>  H√∂here Eintrittsschwelle als OAS (das ist seltsam, aber viele Leute denken so); </li><li>  Aufgrund der gro√üen Anzahl von Fehlern und Problemen mit UX / UI ist der Hauptdienst, der v√∂llig ungeeignet ist und Benutzer abwehrt, der Einstiegspunkt in RAML - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://anypoint.mulesoft.com/</a> . </li></ul><br><h3>  Konzeptionelle Meinungsverschiedenheit.  Erste Schlussfolgerung </h3><br>  Innerhalb der Community gibt es Widerspr√ºche bez√ºglich des Grundkonzepts.  Jemand denkt, dass RAML eine <i>Modelldefinitionssprache ist</i> , und jemand denkt, dass es eine <i>API-Definitionssprache</i> wie OAS oder Blueprint ist (Leute, die sich RAML-Entwickler nennen, erw√§hnen dies oft in verschiedenen Kommentaren).  Das Konzept der <i>Modelldefinitionssprache</i> w√ºrde es innerhalb der RAML-Spezifikation erm√∂glichen, das Dom√§nenmodell der Dom√§ne zu beschreiben, ohne eng an den Kontext der API-Ressourcenbeschreibung gebunden zu sein, wodurch der Horizont der Optionen f√ºr die Verwendung der Spezifikation mit externen Tools erweitert wird (was tats√§chlich die Grundlage f√ºr die Existenz dieses <i>Einzelvertrags</i> schafft!).  Hier ist eine Definition des Konzepts einer Ressource auf der Website readhat docs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://restful-api-design.readthedocs.io/en/latest/resources.html</a> , ich empfehle √ºbrigens jedem, diesen wunderbaren Leitfaden zum API-Design zu lesen): <br><blockquote>  Wir nennen Informationen, die verf√ºgbare <b><i>Ressourcentypen</i></b> , ihr Verhalten und ihre Beziehungen beschreiben, <b><i>das Ressourcenmodell einer API</i></b> .  <i><b>Das Ressourcenmodell</b></i> kann als RESTful-Zuordnung des <b><i>Anwendungsdatenmodells angesehen werden</i></b> . </blockquote>  Im RAML- <i><b>Anwendungsdatenmodell</b></i> sind dies Typen, die im Typenblock deklariert sind, und das <b><i>Ressourcenmodell einer API</i></b> wird im <i>Ressourcen-</i> RAML-Block beschrieben.  Daher m√ºssen Sie in der Lage sein, diese <i><b>Zuordnung</b></i> zu beschreiben.  Die aktuelle Implementierung von RAML erm√∂glicht jedoch, dass eine solche <b><i>Zuordnung</i></b> nur 1 zu 1 erfolgt, dh dass Typen "wie sie sind" in der Ressourcen-API-Deklaration verwendet werden. <br><br>  Ich denke, dies ist das Hauptproblem der Sprache, deren L√∂sung es RAML erm√∂glicht, √ºber die <i>API-Definitionssprache</i> hinauszugehen und eine vollwertige <i>Modelldefinitionssprache zu werden</i> : eine allgemeinere Sprache (anstelle von OAS oder Blueprint), die zur Beschreibung der einzelnen Vertr√§ge von Systemen verwendet wird, die im Wesentlichen den formalen Kern bilden viele ihrer Komponenten. <br><br>  Das oben Gesagte macht RAML zu einem schwachen Spieler, der derzeit nicht in der Lage ist, den Wettbewerb gegen Swagger zu gewinnen.  Vielleicht hat der Hauptentwickler von RAML deshalb drastische Ma√ünahmen ergriffen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Https://blogs.mulesoft.com/dev/api-dev/open-api-raml-better-together/</a> <br><br><h3>  Die Idee von RAML SaaS mit einem Vertrag </h3><br>  Basierend auf dem Konzept des <i>Einzelvertrags</i> , ausgehend von der Idee, eine OAS-basierte Swagger-Spezifikations-API f√ºr Spezifikationen zu hosten und sich auf die M√∂glichkeit von RAML zu st√ºtzen, Metainformationen zu deklarieren und die Basisspezifikation mithilfe von Overlays zu teilen, schl√§gt die Idee einer alternativen SaaS-L√∂sung zum Hosten und Verwalten von Spezifikationen basierend auf der RAML-Sprache vor √úbertreffen Sie den Swagger Hub und das Bienenhaus in Bezug auf Umfang und Qualit√§t der m√∂glichen Funktionen. <br><br>  Der neue Dienst wird in Analogie zum Swagger-Hub das Hosting von Benutzervertr√§gen mit der Bereitstellung eines Online-Editors und die M√∂glichkeit sein, Dokumentationsvorschauen mit Echtzeit-Updates anzuzeigen.  Der Hauptunterschied sollte das Vorhandensein eines Katalogs von Vertrags-Plug-Ins sein, die in den Service integriert sind und von denen jeder Benutzer API-Spezifikationen in seinem aktuellen Projekt installieren kann.  F√ºr die Installation m√ºssen die erforderlichen RAML-Anmerkungen implementiert werden, die in der Plugin-Dokumentation angegeben sind.  Nachdem Sie dem Projekt ein neues Plug-In hinzugef√ºgt haben, wird im Code-Editor-Fenster eine neue Registerkarte hinzugef√ºgt, wenn Sie zu diesem wechseln. Die Bearbeitungsanmerkungen des installierten Plug-Ins werden verf√ºgbar.  Die Struktur der Basisspezifikation sollte automatisch in allen Registerkarten dupliziert werden, die den Plugins entsprechen.  Wenn Konflikte zwischen der Grundstruktur und bereits vorhandenen Anmerkungen auftreten, sollte ein spezieller Mechanismus Optionen f√ºr seine L√∂sung anbieten oder diese automatisch l√∂sen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/5g/go/le5ggomtfukodgechbdyhugpafq.png" alt="Bild"></div><br>  Technisch gesehen ist jede Registerkarte eine Abstraktion des RAML-Overlays, die Anmerkungen zu jedem bestimmten Plugin enth√§lt.  Dies stellt sicher, dass die Spezifikation mit jedem Tool kompatibel ist, das RAML 1.0 unterst√ºtzt. <br><br>  Das Plugin-Verzeichnis muss f√ºr die Erweiterung durch die Open Source-Community ge√∂ffnet sein.  Es ist auch m√∂glich, kostenpflichtige Plug-Ins zu implementieren, die als Anreiz f√ºr die Entwicklung neuer Plug-Ins dienen k√∂nnen. <br><br>  M√∂gliche Plugins: API-Dokumentation mit Unterst√ºtzung f√ºr eine gro√üe Anzahl von Anmerkungen zur flexiblen Parametrisierung des Renderings, ‚Äûintelligenter‚Äú Mock-Server (aus dem obigen Beispiel), herunterladbare Bibliotheken zur Validierung von Anforderungen oder zur Codegenerierung, Debugging-Tools f√ºr ausgehende API-Anforderungen f√ºr mobile Anwendungen (Caching-Proxy), Lasttests Mit der Einrichtung von Flusstests durch Anmerkungen werden verschiedene Plugins f√ºr die Integration mit externen Diensten erstellt. <br><br>  Diese Idee des Dienstes enth√§lt klare Vorteile gegen√ºber vorhandenen Diensten f√ºr die Verwaltung von API-Spezifikationen, und ihre Implementierung ebnet den Weg f√ºr eine m√∂gliche √Ñnderung des Ansatzes f√ºr die Implementierung externer Systeme, die in irgendeiner Weise mit der API zusammenh√§ngen. <br><br><h3>  Zweite Schlussfolgerung </h3><br>  Der Zweck dieses Artikels besteht nicht darin, Swagger, Apiary oder andere De-facto-Standardtools f√ºr die Entwicklung von APIs zu kritisieren, sondern den konzeptionellen Unterschied zum Ansatz der von RAML gef√∂rderten Entwurfsspezifikationen zu untersuchen, zun√§chst das Konzept des <i>Vertrags</i> einzuf√ºhren und die M√∂glichkeit seiner Implementierung auf der Grundlage von RAML zu pr√ºfen.  Ein weiteres Ziel war der Wunsch, die wohlverdiente Aufmerksamkeit der Entwickler auf RAML f√ºr die weitere m√∂gliche Entwicklung seiner Community zu lenken. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Seite RAML</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlaffer Kanal</a> <br>  <a href="">Spezifikation</a> <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419525/">https://habr.com/ru/post/de419525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419511/index.html">Typ (T) vs. TypeOf‚ü®T‚ü©</a></li>
<li><a href="../de419513/index.html">Konfigurieren Sie die Kennwortsicherheitsrichtlinie in Zimbra</a></li>
<li><a href="../de419515/index.html">Wie ein ‚Äûmarkenfreies‚Äú Startup 240 Millionen US-Dollar bekam, um Amazon zu besiegen</a></li>
<li><a href="../de419519/index.html">Tipps f√ºr Handyspiele: Teil 1, Softstart</a></li>
<li><a href="../de419523/index.html">Das PVS-Studio-Team ist beim Schreiben von Artikeln unvoreingenommen</a></li>
<li><a href="../de419527/index.html">Wie der Herzschlag klingt: Konvertieren des Papierkardiogramms in das WAV-Format</a></li>
<li><a href="../de419531/index.html">Das perfekte Paar f√ºr Ihre Ohren ausw√§hlen: zehn praktische Tipps</a></li>
<li><a href="../de419535/index.html">Update auf Toaster</a></li>
<li><a href="../de419537/index.html">CyberDemons: K√ºnstliche Intelligenz DOOM 2016</a></li>
<li><a href="../de419539/index.html">Offenes Webinar "Asynchrone Programmierung in Python"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>