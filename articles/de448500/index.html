<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💐 ☝🏽 👨🏽‍🎓 Lösen eines einfachen Crackme für Sega Mega Drive 🐇 🧛🏾 🎡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle, 





 Trotz meiner großartigen Erfahrung beim Umkehren von Spielen für Sega Mega Drive ich mich nie dafür entschieden, dafür zu knacke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lösen eines einfachen Crackme für Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Hallo an alle, </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Trotz meiner großartigen Erfahrung beim Umkehren von Spielen für <code>Sega Mega Drive</code> ich mich nie dafür entschieden, dafür zu knacken, und sie sind mir im Internet nicht aufgefallen.  Aber neulich gab es einen lustigen Crackie, der lösen wollte.  Ich teile mit Ihnen die Entscheidung ... <a name="habracut"></a></p><br><h2 id="opisanie">  Beschreibung </h2><br><p>  Beschreibung der Aufgabe und Rum selbst können hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">heruntergeladen werden</a> . </p><br><p>  Trotz der Tatsache, dass in der Ressourcenliste Hydra angegeben ist, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Smd Ida Tools</a> der Standard unter den Tools zum Debuggen und Umkehren von Spielen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Sega</a> .  Es hat alles, was Sie brauchen, um diese Creme zu lösen: </p><br><ul><li>  Rumlader für Ida </li><li>  Debugger </li><li>  RAM-VDP-Speicher anzeigen und ändern </li><li>  Zeigen Sie fast vollständige Informationen zu VDP an </li></ul><br><p>  Wir legen die neueste Version in den Plugins für Ide ab und schauen uns an, was wir haben. </p><br><h2 id="reshenie">  Lösung </h2><br><p>  Der Start eines Shogi-Spiels beginnt mit der Ausführung des <code>Reset</code> Vektors.  Ein Zeiger darauf befindet sich im zweiten DWORD vom Anfang des Rums. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Wir sehen einige nicht identifizierte Funktionen ab Adresse <code>0x27A</code> .  Mal sehen, was da ist. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  Aus eigener Erfahrung möchte ich sagen, dass dies normalerweise so aussieht, als würde man darauf warten, dass der <code>VBLANK</code> Interrupt abgeschlossen ist.  Mal sehen, wo sonst die Variable <code>byte_FF0026</code> wird: </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Wir sehen, dass das Nullbit gerade im <code>VBLANK</code> Interrupt gesetzt ist.  Wir rufen also die Variable <code>vblank_ready</code> und die Funktion, in der sie überprüft wird, ist <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Als nächstes wird die Funktion <code>sub_60E</code> per Code aufgerufen.  Mal sehen, was da ist: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  Was der erste Befehl in die <code>VDP_CTRL</code> schreibt, ist der <code>VDP</code> Steuerbefehl.  Um herauszufinden, was sie tut, stehen wir auf diesem Befehl und drücken die <code>J</code> Taste: </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Wir sehen, dass der Eintrag in <code>CRAM</code> (dem Ort, an dem die Paletten gespeichert sind) initialisiert wird.  Dies bedeutet, dass der gesamte nachfolgende Funktionscode einfach eine Art Anfangspalette festlegt.  Dementsprechend kann die Funktion <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Wir sehen, dass ein Befehl erneut an <code>VDP_CTRL</code> übertragen wird. <code>VDP_CTRL</code> dann erneut <code>J</code> und stellen Sie fest, dass dieser Befehl die Aufzeichnung im Videospeicher initialisiert: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Um zu verstehen, was dort in den Videospeicher übertragen wird, macht es keinen Sinn.  Deshalb rufen wir einfach die Funktion <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Hier passiert fast das Gleiche wie in der vorherigen Funktion. Ohne auf Details <code>load_vdp_data2</code> , rufen wir einfach die Funktion <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  Es gibt bereits mehr Code.  Außerdem wird in dieser Funktion eine andere Funktion aufgerufen.  Schauen wir genau dort hin - in <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Wir sehen, dass im <code>D0</code> Register der Befehl für <code>VDP_CTRL</code> , in <code>D1</code> - dem Wert, mit dem <code>VRAM</code> gefüllt wird, und in <code>D2</code> und <code>D3</code> - der Breite und Höhe der Füllung (weil sich zwei Zyklen herausstellen: intern und extern).  Rufen Sie die Funktion fill_vram_by_addr auf. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Wir kehren zur vorherigen Funktion zurück.  Sobald der Wert im <code>D0</code> Register als Befehl für <code>VDP_CTRL</code> , drücken Sie die Taste <code>J</code> für den Wert.  Wir bekommen: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Aus der Erfahrung mit dem Umkehren von Spielen zu Sega kann ich wieder sagen, dass dieser Befehl die Aufzeichnung von Mapping-Kacheln initialisiert.  Adressen, die in 90% der Fälle mit <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> <code>$Dxxx</code> , sind Adressen von Regionen mit denselben Zuordnungen.  Was sind Zuordnungen: <br>  Mit diesen Werten können Sie festlegen, wo diese oder jene Kachel auf dem Bildschirm angezeigt werden soll (eine Kachel ist ein Quadrat mit <code>8x8</code> x <code>8x8</code> Pixel). </p><br><p>  Die Funktion kann also als <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  Der erste Befehl initialisiert den Datensatz unter der Adresse <code>$F000</code> .  Ein Hinweis: Unter den Adressen der " <em>Zuordnung</em> " befindet sich noch eine Region, in der die Sprite-Tabelle gespeichert ist (dies sind ihre Positionen, Kacheln, auf die sie zeigen usw.). Finden Sie heraus, welche Region für das Debuggen verantwortlich ist.  <code>init_other_mappings</code> benötigen wir dies jedoch nicht. Rufen Sie einfach die Funktion <code>init_other_mappings</code> . </p><br><p>  Wir sehen auch, dass in dieser Funktion zwei Variablen initialisiert werden: <code>word_FF000A</code> und <code>word_FF000C</code> .  Aus eigener Erfahrung (ja, entscheidet er) werde ich sagen, dass wenn zwei Variablen im Adressraum in der Nähe sind und mit der Zuordnung verknüpft sind, sie in den meisten Fällen die Koordinaten eines Objekts sind (z. B. eines Sprites).  Daher schlage ich vor, sie <code>sprite_pos_x</code> und <code>sprite_pos_y</code> .  Der Fehler in <code>x</code> und <code>y</code> seitdem zulässig  weiter unter Debugging wird es leicht zu beheben sein. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Da die Schleife im Code weiter geht, können wir davon ausgehen, dass wir die grundlegende Initialisierung abgeschlossen haben.  Jetzt können Sie sich den <code>VBLANK</code> Interrupt <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  Wir sehen, dass zwei Variablen inkrementieren (was seltsam ist, in der Liste der Links zu jeder von ihnen ist es absolut leer).  Da sie jedoch einmal pro Frame aktualisiert werden, können Sie sie als <code>timer1</code> und <code>timer2</code> . </p><br><p>  Als nächstes wird die Funktion <code>sub_2FE</code> .  Mal sehen, was da ist: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  Und dort - arbeiten Sie mit dem <code>IO_CT1_DATA</code> Port (verantwortlich für den ersten Joystick).  Die <code>sub_310</code> wird in das Register <code>A0</code> geladen und an die Funktion <code>sub_310</code> .  Wir gehen dorthin: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Meine Erfahrung hilft mir wieder.  Wenn Sie den Code sehen, der mit dem Joystick funktioniert, und zwei Variablen im Speicher, speichert eine die <code>pressed keys</code> und die zweite die <code>held keys</code> , d. H.  nur Tasten gedrückt und gehalten.  Nennen wir also diese Variablen: <code>pressed_keys</code> und <code>held_keys</code> .  Und dann kann die Funktion als <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Rufen Sie die Funktion als <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Handler-Schleife </h2><br><p>  Jetzt sieht alles viel klarer aus: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Dieser Zyklus reagiert also auf die gedrückten Tasten und führt die entsprechenden Aktionen aus.  Lassen Sie uns jede der in der Schleife aufgerufenen Funktionen durchgehen. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  Es gibt viel Code.  Beginnen wir mit der ersten Funktion namens: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Sie tut nichts - es mag zunächst so scheinen.  Nur von der aktuellen Funktion zurückzukehren ist <code>rts</code> .  Aber weil  es treten nur Sprünge ( <code>bsr</code> ) auf, was bedeutet, dass <code>rts</code> uns zurück zur <code>rts</code> zurückbringt.  Ich würde diese Funktion als <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Als nächstes sehen wir den Aufruf der Variablen <code>word_FF000E</code> .  Es wird nirgendwo verwendet, außer für die aktuelle Funktion, und der Zweck war mir zunächst nicht klar.  Wenn Sie genau hinschauen, können wir davon ausgehen, dass diese Variable nur für eine kleine Verzögerung zwischen der Verarbeitung von Tastenanschlägen benötigt wird.  ( <em>Es ist in diesem Rum bereits schlecht implementiert, aber ich denke, ohne diese Variable wäre es viel schlimmer</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  Als nächstes haben wir eine große Menge Code, der die <code>sprite_pos_y</code> <code>sprite_pos_x</code> und <code>sprite_pos_y</code> irgendwie verarbeitet, was nur eines sagen kann - dies ist erforderlich, um das Auswahlsprite um das im Alphabet ausgewählte Zeichen anzuzeigen. </p><br><p>  Jetzt können Sie die Funktion sicher als <code>update_selection</code> .  Lass uns weitermachen. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  Der Code prüft, ob die Bits einiger gedrückter Tasten gesetzt sind, und ruft bestimmte Funktionen auf.  Schauen wir sie uns an. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Eine Art schamanische Magie.  Zuerst wird das <code>WORD</code> aus der Variablen <code>word_FF0018</code> entnommen, dann wird eine interessante Anweisung ausgeführt: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Dieser Befehl springt einfach zu der darauf folgenden Anweisung. </p><br><p>  Als nächstes kommt eine weitere Magie: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  Der Wert im Register <code>D0</code> wird oben auf den Stapel gelegt.  Es ist erwähnenswert, dass sowohl für Shogi als auch für einige <code>x86</code> die Rücksprungadresse der Funktion, wenn sie aufgerufen wird, oben auf dem Stapel abgelegt wird.  Dementsprechend setzt der erste Befehl eine Adresse oben, und der zweite hebt sie vom Stapel ab und macht einen Übergang entlang dieser.  <u>Guter Trick</u> . </p><br><p>  Jetzt müssen Sie verstehen, was dieser Wert in der Variablen ist, die dann durchlaufen wird.  Aber zuerst rufen wir diese Variable <code>jmp_addr</code> . </p><br><p>  Und die Funktionen werden so heißen: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Finden Sie heraus, wo diese Variable ausgefüllt ist.  Wir sehen uns die Referenzliste an: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  Es gibt nur einen Ort, an den in diese Variable geschrieben werden kann.  Schauen wir ihn uns an. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Hier wird abhängig von der Koordinate des Sprites (denken Sie daran, dass dies höchstwahrscheinlich die Adresse des ausgewählten Zeichens ist) dieser oder jener Wert eingegeben.  Wir sehen den folgenden Codeabschnitt: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  Der vorhandene Wert wird um 4 Bits nach rechts verschoben, ein neuer Wert wird in das niedrige Byte eingefügt und das Ergebnis wird erneut in die Variable eingegeben.  <code>jmp_addr</code> speichert unsere Variable <code>jmp_addr</code> die Zeichen, die wir auf dem Schlüsseleingabebildschirm eingeben können.  Beachten Sie auch, dass die Größe der Variablen <code>WORD</code> . </p><br><p>  Tatsächlich kann die Funktion <code>update_jmp_addr</code> als <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Jetzt haben wir nur noch eine Funktion in der Schleife, die nicht erkannt wird.  Und es heißt <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Sein Code ähnelt dem Code der Funktion <code>update_jmp_addr</code> , nur am Ende haben wir einen Funktionsaufruf <code>sub_45E</code> .  Schauen wir uns das an. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Wir sehen, dass die Nummer <code>#$4B1E2003</code> in das <code>D0</code> Register eingetragen ist, das dann an <code>VDP_CTRL</code> gesendet <code>VDP_CTRL</code> , was bedeutet, dass es sich um einen anderen <code>VDP</code> Steuerbefehl handelt.  Wir drücken <code>J</code> , wir erhalten einen Befehl zum Aufzeichnen in der Region mit der Zuordnung von <code>$Cxxx</code> . </p><br><p>  Als nächstes arbeitet der Code mit der Variablen <code>byte_FF0014</code> , die nur in der aktuellen Funktion verwendet wird.  Wenn Sie sich die Verwendung genau ansehen, werden Sie feststellen, dass maximal <code>4</code> installiert werden können.  Ich gehe davon aus, dass dies die aktuelle Länge des eingegebenen Schlüssels ist.  Lass es uns überprüfen. </p><br><h4 id="zapuskaem-otladchik">  Führen Sie den Debugger aus </h4><br><p>  Ich werde den Debugger von <code>Smd Ida Tools</code> , aber tatsächlich werden einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gens KMod</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gens ReRecording</a> ausreichen.  Die Hauptsache ist, dass es eine Funktion zur Anzeige von Adressen im Speicher gibt. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Meine Theorie wurde bestätigt.  Die Variable <code>byte_FF0014</code> kann nun <code>key_length</code> . </p><br><p>  Es gibt noch eine andere Variable: <code>dword_FF0010</code> , die ebenfalls nur in der aktuellen Funktion verwendet wird, und deren Inhalt wird nach dem Hinzufügen zum ursprünglichen Befehl in <code>D0</code> (Rückruf, dies war die Nummer <code>#$4B1E2003</code> ) an <code>VDP_CTRL</code> gesendet.  Ohne nachzudenken, habe ich die Variable <code>add_to_vdp_cmd</code> . </p><br><p>  Was macht diese Funktion?  Ich gehe davon aus, dass sie das eingegebene Zeichen zeichnet.  Dies zu <code>sub_45E</code> ist einfach - indem Sie den Debugger starten und den Status vergleichen, bevor Sie die Funktion <code>sub_45E</code> aufrufen und danach: </p><br><p>  An: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Nachher: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  Ich hatte recht - diese Funktion zeichnet das eingegebene Zeichen.  Wir nennen es <code>do_draw_input_char</code> und die Funktion, die es aufruft ( <code>sub_414</code> ), ist <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Was jetzt? </h2><br><p>  Lassen Sie uns zunächst überprüfen, ob die Variable, die wir <code>jmp_addr</code> genannt <code>jmp_addr</code> den eingegebenen Schlüssel wirklich speichert.  Wir werden dieselbe <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Wie Sie sehen können, war die Vermutung wahr.  Was gibt uns das?  Wir können zu jeder Adresse springen.  Aber welches?  In der Liste der Funktionen sind schließlich alle sortiert: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Dann habe ich einfach angefangen, durch den Code zu scrollen, bis ich Folgendes gefunden habe: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  Das trainierte Auge sah die Folge von <code>$4E, $75</code> am Ende nicht zugeordneter Bytes.  Dies ist der Opcode des <code>rts</code> Befehls, d.h.  Rückkehr von der Funktion.  Diese nicht zugewiesenen Bytes können also der Code einer Funktion sein.  Versuchen wir, sie als Code zu kennzeichnen, und drücken Sie <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Dies ist offensichtlich ein Funktionscode.  Sie können auch <code>P</code> drücken, um den Code zu einer Funktion zu machen.  Merken Sie sich diesen Namen: <code>sub_D3C</code> . </p><br><p>  Dann entsteht der Gedanke: Was ist, wenn Sie auf <code>sub_D3C</code> springen?  Es hört sich gut an, obwohl ein einziger Sprung hier offensichtlich nicht ausreicht, weil  Es gab keine Links mehr zur Variablen <code>word_FF0020</code> . </p><br><p>  Dann kam mir ein anderer Gedanke: Was wäre, wenn wir nach einem anderen solchen nicht zugewiesenen Code suchen würden?  Öffnen Sie den <code>Binary search</code> (Alt + B), geben Sie die Sequenz <code>4E 75</code> ein und aktivieren Sie das Kontrollkästchen <code>Find all occurrences</code> <code>Binary search</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Klicken Sie auf <code></code> , um die Suche zu starten. Wir erhalten die folgenden Ergebnisse. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Mindestens zwei weitere Stellen im Rum können einen Funktionscode enthalten. Sie müssen diese überprüfen.  Wir klicken auf die erste der Optionen, scrollen ein wenig nach oben und sehen wieder eine Folge von undefinierten Bytes.  Bezeichnen Sie sie als Funktion?  Ja!  Drücken Sie <code>P</code> wo die Bytes beginnen: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Cool!  Jetzt haben wir die Funktion <code>sub_34C</code> .  Wir versuchen, dasselbe mit den letzten gefundenen Optionen zu wiederholen, und ... wir bekommen einen Mist.  Es gibt so viele Bytes vor <code>4E 75</code> dass nicht klar ist, wo die Funktion beginnt.  Und natürlich sind nicht alle dieser obigen Bytes Code, weil  viele doppelte Bytes. </p><br><h3 id="opredelyaem-nachalo-funkcii">  Bestimmen Sie den Beginn der Funktion </h3><br><p>  Es ist für uns am einfachsten, den Anfang der Funktion zu finden, wenn wir herausfinden, wo die Daten enden.  Wie kann man das machen?  Eigentlich gar nicht kompliziert: </p><br><ol><li>  Wir drehen vor dem Beginn der Daten (es wird einen Link vom Code zu ihnen geben) </li><li>  Wir folgen dem Link und suchen nach einem Zyklus, in dem die Größe dieser Daten erscheinen soll </li><li>  Markieren Sie das Array </li></ol><br><p>  Also führen wir den ersten Absatz durch ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... und wir sehen sofort, dass in einem Zyklus von unserem Array 4 Datenbytes gleichzeitig (weil <code>move.l</code> ) nach <code>VDP_DATA</code> .  Als nächstes sehen wir die Nummer <code>2047</code> .  Auf den ersten <code>dbf</code> scheint die endgültige Größe des Arrays <code>2047 * 4</code> , aber die <code>dbf</code> basierte Schleife führt mehr <code>+1</code> Iteration aus, weil  Der zuletzt verglichene Wert ist nicht <code>0</code> , sondern <code>-1</code> . </p><br><p>  Gesamt: Die Größe des Arrays beträgt <code>2048 * 4 = 8192</code> .  Bezeichnen Sie Bytes als Array.  Klicken Sie dazu auf <code>*</code> und geben Sie die Größe an: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Wir drehen uns zum Ende des Arrays und sehen dort Bytes, die genau die Bytes des Codes sind: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Jetzt haben wir die Funktion <code>sub_2D86</code> und wir haben alles, um diesen Riss zu lösen!  Mal sehen, was die neu erstellte Funktion macht. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  Und es legt einfach den Wert <code>#$4147</code> in das Register <code>D1</code> und ruft die Funktion <code>sub_34C</code> .  Schau sie dir an. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  Wir sehen, dass hier der Wert der Variablen <code>word_FF0020</code> .  Wenn Sie sich die Links dazu ansehen, sehen wir eine andere Stelle, an der der Datensatz in dieser Variablen stattfindet, und genau an dieser Stelle wollte ich durch die Variable <code>jmp_addr</code> springen.  Dies bestätigt die Vermutung, dass <code>sub_D3C</code> definitiv zu <code>sub_D3C</code> springen <code>sub_D3C</code> . </p><br><p>  Aber was als nächstes geschah, war zu faul, um es zu verstehen, also warf ich den Rum in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GHIDRA</a> , fand diese Funktion und sah mir den dekompilierten Code an: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Wir sehen, dass die Variable mit dem seltsamen Namen <code>in_D1w</code> , und auch die Variable <code>DAT_00ff0020</code> , die mit ihrer Adresse an das <code>word_FF0020</code> erwähnte <code>DAT_00ff0020</code> erinnert. </p><br><p>  <code>in_D1w</code> sagt uns, dass dieser Wert aus dem Register <code>D1</code> oder vielmehr aus seiner jüngeren WORD-Hälfte entnommen wird, und setzt das Register <code>D1</code> Funktion, die es übergibt.  <code>#$4147</code> du dich an <code>#$4147</code> ?  Sie müssen dieses Register also als Eingabeargument für die Funktion festlegen. </p><br><p>  Klicken Sie dazu im Fenster mit dem dekompilierten Code mit der rechten Maustaste auf den Funktionsnamen und wählen Sie den Menüpunkt <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Um anzuzeigen, dass die Funktion ein Argument über ein bestimmtes Register führt, und zwar nicht über die Standardmethode für die aktuelle Aufrufkonvention, müssen Sie das Kontrollkästchen <code>Use Custom Storage</code> und auf das Symbol mit dem <u>grünen Plus</u> klicken: </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Eine Position für das neue Eingabeargument wird angezeigt.  Wir doppelklicken darauf und erhalten einen Dialog, der den Typ und das Medium des Arguments angibt: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  Im dekompilierten Code sehen wir, dass <code>in_D1w</code> vom Typ <code>in_D1w</code> ist, was bedeutet, dass wir es im <code>ushort</code> angeben.  Klicken <code>Add</code> dann auf die Schaltfläche <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Eine Position zeigt das Medium des Arguments an. Wir müssen das <code>D1w</code> Register in <code>Location</code> angeben und auf <code>OK</code> klicken: </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  Der dekompilierte Code hat folgende Form: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Wir <code>param_1</code> dass unser <code>param_1</code> Wert konstant ist, von der aufrufenden Funktion übergeben wird und gleich <code>#$4147</code> .  Was sollte dann der Wert von <code>DAT_00ff0020</code> ?  Wir betrachten: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Weil  <code>xor</code> - die Operation ist reversibel, alle konstanten Zahlen können miteinander gestritten werden und erhalten den gewünschten Wert der Variablen <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Es stellt sich heraus, dass der Wert der Variablen <code>0x4553</code> sein <code>0x4553</code> .  Es scheint, ich habe bereits einen Ort gesehen, an dem ein solcher Wert festgelegt ist ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Schlussfolgerungen und Entscheidung </h2><br><p>  Wir kommen zu folgenden Ergebnissen: </p><br><ol><li>  Zuerst müssen Sie zur Adresse <code>0x0D3C</code> , dazu müssen Sie den Code <code>0D3C</code> </li><li>  <code>0x2D86</code> zu der Funktion bei <code>0x2D86</code> , die den Wert von <code>D1</code> auf Register <code>#$4147</code> setzt. Dazu müssen Sie den Code <code>2D86</code> </li></ol><br><p>  Experimentell finden wir die Taste heraus, die gedrückt werden muss, um die eingegebene Taste zu überprüfen: <code>B</code>  Wir versuchen: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Vielen Dank! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448500/">https://habr.com/ru/post/de448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448488/index.html">Angst und Abscheu vor DevSecOps</a></li>
<li><a href="../de448490/index.html">So starten Sie die DevOps-Transformation</a></li>
<li><a href="../de448492/index.html">Was ist DevOps?</a></li>
<li><a href="../de448496/index.html">.NET Core unter Linux, DevOps zu Pferd</a></li>
<li><a href="../de448498/index.html">"Russland 404": Wie viel freies Internet bleibt noch zu leben</a></li>
<li><a href="../de448504/index.html">Sie sammelten für alle "Habrom" das Nachschlagewerk "Von wem es ausgestellt wurde ..." für Pässe. Auf Gesundheit herunterladen</a></li>
<li><a href="../de448506/index.html">Die Matrix ist 20 Jahre alt: Wie Wachowski Cyberpunk machte, der die Agenda für eine ganze Generation bestimmte</a></li>
<li><a href="../de448510/index.html">Acer im Jahr 2019: Was ist, wenn Sie alle Fliegen von den Gaming-Laptops entfernen?</a></li>
<li><a href="../de448516/index.html">Entwickeln oder erstellen Sie eine Basis für Roboter auf der ARDUINO-Plattform, und wir steuern Sensoren und Videos über ein Smartphone an einen Computer</a></li>
<li><a href="../de448518/index.html">Wie sehe ich ein Schwarzes Loch?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>