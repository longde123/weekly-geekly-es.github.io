<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê ‚òùüèΩ üë®üèΩ‚Äçüéì L√∂sen eines einfachen Crackme f√ºr Sega Mega Drive üêá üßõüèæ üé°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle, 





 Trotz meiner gro√üartigen Erfahrung beim Umkehren von Spielen f√ºr Sega Mega Drive ich mich nie daf√ºr entschieden, daf√ºr zu knacke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L√∂sen eines einfachen Crackme f√ºr Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Hallo an alle, </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Trotz meiner gro√üartigen Erfahrung beim Umkehren von Spielen f√ºr <code>Sega Mega Drive</code> ich mich nie daf√ºr entschieden, daf√ºr zu knacken, und sie sind mir im Internet nicht aufgefallen.  Aber neulich gab es einen lustigen Crackie, der l√∂sen wollte.  Ich teile mit Ihnen die Entscheidung ... <a name="habracut"></a></p><br><h2 id="opisanie">  Beschreibung </h2><br><p>  Beschreibung der Aufgabe und Rum selbst k√∂nnen hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">heruntergeladen werden</a> . </p><br><p>  Trotz der Tatsache, dass in der Ressourcenliste Hydra angegeben ist, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Smd Ida Tools</a> der Standard unter den Tools zum Debuggen und Umkehren von Spielen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Sega</a> .  Es hat alles, was Sie brauchen, um diese Creme zu l√∂sen: </p><br><ul><li>  Rumlader f√ºr Ida </li><li>  Debugger </li><li>  RAM-VDP-Speicher anzeigen und √§ndern </li><li>  Zeigen Sie fast vollst√§ndige Informationen zu VDP an </li></ul><br><p>  Wir legen die neueste Version in den Plugins f√ºr Ide ab und schauen uns an, was wir haben. </p><br><h2 id="reshenie">  L√∂sung </h2><br><p>  Der Start eines Shogi-Spiels beginnt mit der Ausf√ºhrung des <code>Reset</code> Vektors.  Ein Zeiger darauf befindet sich im zweiten DWORD vom Anfang des Rums. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Wir sehen einige nicht identifizierte Funktionen ab Adresse <code>0x27A</code> .  Mal sehen, was da ist. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  Aus eigener Erfahrung m√∂chte ich sagen, dass dies normalerweise so aussieht, als w√ºrde man darauf warten, dass der <code>VBLANK</code> Interrupt abgeschlossen ist.  Mal sehen, wo sonst die Variable <code>byte_FF0026</code> wird: </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Wir sehen, dass das Nullbit gerade im <code>VBLANK</code> Interrupt gesetzt ist.  Wir rufen also die Variable <code>vblank_ready</code> und die Funktion, in der sie √ºberpr√ºft wird, ist <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Als n√§chstes wird die Funktion <code>sub_60E</code> per Code aufgerufen.  Mal sehen, was da ist: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  Was der erste Befehl in die <code>VDP_CTRL</code> schreibt, ist der <code>VDP</code> Steuerbefehl.  Um herauszufinden, was sie tut, stehen wir auf diesem Befehl und dr√ºcken die <code>J</code> Taste: </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Wir sehen, dass der Eintrag in <code>CRAM</code> (dem Ort, an dem die Paletten gespeichert sind) initialisiert wird.  Dies bedeutet, dass der gesamte nachfolgende Funktionscode einfach eine Art Anfangspalette festlegt.  Dementsprechend kann die Funktion <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Wir sehen, dass ein Befehl erneut an <code>VDP_CTRL</code> √ºbertragen wird. <code>VDP_CTRL</code> dann erneut <code>J</code> und stellen Sie fest, dass dieser Befehl die Aufzeichnung im Videospeicher initialisiert: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Um zu verstehen, was dort in den Videospeicher √ºbertragen wird, macht es keinen Sinn.  Deshalb rufen wir einfach die Funktion <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Hier passiert fast das Gleiche wie in der vorherigen Funktion. Ohne auf Details <code>load_vdp_data2</code> , rufen wir einfach die Funktion <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  Es gibt bereits mehr Code.  Au√üerdem wird in dieser Funktion eine andere Funktion aufgerufen.  Schauen wir genau dort hin - in <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Wir sehen, dass im <code>D0</code> Register der Befehl f√ºr <code>VDP_CTRL</code> , in <code>D1</code> - dem Wert, mit dem <code>VRAM</code> gef√ºllt wird, und in <code>D2</code> und <code>D3</code> - der Breite und H√∂he der F√ºllung (weil sich zwei Zyklen herausstellen: intern und extern).  Rufen Sie die Funktion fill_vram_by_addr auf. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Wir kehren zur vorherigen Funktion zur√ºck.  Sobald der Wert im <code>D0</code> Register als Befehl f√ºr <code>VDP_CTRL</code> , dr√ºcken Sie die Taste <code>J</code> f√ºr den Wert.  Wir bekommen: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Aus der Erfahrung mit dem Umkehren von Spielen zu Sega kann ich wieder sagen, dass dieser Befehl die Aufzeichnung von Mapping-Kacheln initialisiert.  Adressen, die in 90% der F√§lle mit <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> <code>$Dxxx</code> , sind Adressen von Regionen mit denselben Zuordnungen.  Was sind Zuordnungen: <br>  Mit diesen Werten k√∂nnen Sie festlegen, wo diese oder jene Kachel auf dem Bildschirm angezeigt werden soll (eine Kachel ist ein Quadrat mit <code>8x8</code> x <code>8x8</code> Pixel). </p><br><p>  Die Funktion kann also als <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  Der erste Befehl initialisiert den Datensatz unter der Adresse <code>$F000</code> .  Ein Hinweis: Unter den Adressen der " <em>Zuordnung</em> " befindet sich noch eine Region, in der die Sprite-Tabelle gespeichert ist (dies sind ihre Positionen, Kacheln, auf die sie zeigen usw.). Finden Sie heraus, welche Region f√ºr das Debuggen verantwortlich ist.  <code>init_other_mappings</code> ben√∂tigen wir dies jedoch nicht. Rufen Sie einfach die Funktion <code>init_other_mappings</code> . </p><br><p>  Wir sehen auch, dass in dieser Funktion zwei Variablen initialisiert werden: <code>word_FF000A</code> und <code>word_FF000C</code> .  Aus eigener Erfahrung (ja, entscheidet er) werde ich sagen, dass wenn zwei Variablen im Adressraum in der N√§he sind und mit der Zuordnung verkn√ºpft sind, sie in den meisten F√§llen die Koordinaten eines Objekts sind (z. B. eines Sprites).  Daher schlage ich vor, sie <code>sprite_pos_x</code> und <code>sprite_pos_y</code> .  Der Fehler in <code>x</code> und <code>y</code> seitdem zul√§ssig  weiter unter Debugging wird es leicht zu beheben sein. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Da die Schleife im Code weiter geht, k√∂nnen wir davon ausgehen, dass wir die grundlegende Initialisierung abgeschlossen haben.  Jetzt k√∂nnen Sie sich den <code>VBLANK</code> Interrupt <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  Wir sehen, dass zwei Variablen inkrementieren (was seltsam ist, in der Liste der Links zu jeder von ihnen ist es absolut leer).  Da sie jedoch einmal pro Frame aktualisiert werden, k√∂nnen Sie sie als <code>timer1</code> und <code>timer2</code> . </p><br><p>  Als n√§chstes wird die Funktion <code>sub_2FE</code> .  Mal sehen, was da ist: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  Und dort - arbeiten Sie mit dem <code>IO_CT1_DATA</code> Port (verantwortlich f√ºr den ersten Joystick).  Die <code>sub_310</code> wird in das Register <code>A0</code> geladen und an die Funktion <code>sub_310</code> .  Wir gehen dorthin: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Meine Erfahrung hilft mir wieder.  Wenn Sie den Code sehen, der mit dem Joystick funktioniert, und zwei Variablen im Speicher, speichert eine die <code>pressed keys</code> und die zweite die <code>held keys</code> , d. H.  nur Tasten gedr√ºckt und gehalten.  Nennen wir also diese Variablen: <code>pressed_keys</code> und <code>held_keys</code> .  Und dann kann die Funktion als <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Rufen Sie die Funktion als <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Handler-Schleife </h2><br><p>  Jetzt sieht alles viel klarer aus: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Dieser Zyklus reagiert also auf die gedr√ºckten Tasten und f√ºhrt die entsprechenden Aktionen aus.  Lassen Sie uns jede der in der Schleife aufgerufenen Funktionen durchgehen. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  Es gibt viel Code.  Beginnen wir mit der ersten Funktion namens: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Sie tut nichts - es mag zun√§chst so scheinen.  Nur von der aktuellen Funktion zur√ºckzukehren ist <code>rts</code> .  Aber weil  es treten nur Spr√ºnge ( <code>bsr</code> ) auf, was bedeutet, dass <code>rts</code> uns zur√ºck zur <code>rts</code> zur√ºckbringt.  Ich w√ºrde diese Funktion als <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Als n√§chstes sehen wir den Aufruf der Variablen <code>word_FF000E</code> .  Es wird nirgendwo verwendet, au√üer f√ºr die aktuelle Funktion, und der Zweck war mir zun√§chst nicht klar.  Wenn Sie genau hinschauen, k√∂nnen wir davon ausgehen, dass diese Variable nur f√ºr eine kleine Verz√∂gerung zwischen der Verarbeitung von Tastenanschl√§gen ben√∂tigt wird.  ( <em>Es ist in diesem Rum bereits schlecht implementiert, aber ich denke, ohne diese Variable w√§re es viel schlimmer</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  Als n√§chstes haben wir eine gro√üe Menge Code, der die <code>sprite_pos_y</code> <code>sprite_pos_x</code> und <code>sprite_pos_y</code> irgendwie verarbeitet, was nur eines sagen kann - dies ist erforderlich, um das Auswahlsprite um das im Alphabet ausgew√§hlte Zeichen anzuzeigen. </p><br><p>  Jetzt k√∂nnen Sie die Funktion sicher als <code>update_selection</code> .  Lass uns weitermachen. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  Der Code pr√ºft, ob die Bits einiger gedr√ºckter Tasten gesetzt sind, und ruft bestimmte Funktionen auf.  Schauen wir sie uns an. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Eine Art schamanische Magie.  Zuerst wird das <code>WORD</code> aus der Variablen <code>word_FF0018</code> entnommen, dann wird eine interessante Anweisung ausgef√ºhrt: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Dieser Befehl springt einfach zu der darauf folgenden Anweisung. </p><br><p>  Als n√§chstes kommt eine weitere Magie: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  Der Wert im Register <code>D0</code> wird oben auf den Stapel gelegt.  Es ist erw√§hnenswert, dass sowohl f√ºr Shogi als auch f√ºr einige <code>x86</code> die R√ºcksprungadresse der Funktion, wenn sie aufgerufen wird, oben auf dem Stapel abgelegt wird.  Dementsprechend setzt der erste Befehl eine Adresse oben, und der zweite hebt sie vom Stapel ab und macht einen √úbergang entlang dieser.  <u>Guter Trick</u> . </p><br><p>  Jetzt m√ºssen Sie verstehen, was dieser Wert in der Variablen ist, die dann durchlaufen wird.  Aber zuerst rufen wir diese Variable <code>jmp_addr</code> . </p><br><p>  Und die Funktionen werden so hei√üen: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Finden Sie heraus, wo diese Variable ausgef√ºllt ist.  Wir sehen uns die Referenzliste an: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  Es gibt nur einen Ort, an den in diese Variable geschrieben werden kann.  Schauen wir ihn uns an. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Hier wird abh√§ngig von der Koordinate des Sprites (denken Sie daran, dass dies h√∂chstwahrscheinlich die Adresse des ausgew√§hlten Zeichens ist) dieser oder jener Wert eingegeben.  Wir sehen den folgenden Codeabschnitt: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  Der vorhandene Wert wird um 4 Bits nach rechts verschoben, ein neuer Wert wird in das niedrige Byte eingef√ºgt und das Ergebnis wird erneut in die Variable eingegeben.  <code>jmp_addr</code> speichert unsere Variable <code>jmp_addr</code> die Zeichen, die wir auf dem Schl√ºsseleingabebildschirm eingeben k√∂nnen.  Beachten Sie auch, dass die Gr√∂√üe der Variablen <code>WORD</code> . </p><br><p>  Tats√§chlich kann die Funktion <code>update_jmp_addr</code> als <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Jetzt haben wir nur noch eine Funktion in der Schleife, die nicht erkannt wird.  Und es hei√üt <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Sein Code √§hnelt dem Code der Funktion <code>update_jmp_addr</code> , nur am Ende haben wir einen Funktionsaufruf <code>sub_45E</code> .  Schauen wir uns das an. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Wir sehen, dass die Nummer <code>#$4B1E2003</code> in das <code>D0</code> Register eingetragen ist, das dann an <code>VDP_CTRL</code> gesendet <code>VDP_CTRL</code> , was bedeutet, dass es sich um einen anderen <code>VDP</code> Steuerbefehl handelt.  Wir dr√ºcken <code>J</code> , wir erhalten einen Befehl zum Aufzeichnen in der Region mit der Zuordnung von <code>$Cxxx</code> . </p><br><p>  Als n√§chstes arbeitet der Code mit der Variablen <code>byte_FF0014</code> , die nur in der aktuellen Funktion verwendet wird.  Wenn Sie sich die Verwendung genau ansehen, werden Sie feststellen, dass maximal <code>4</code> installiert werden k√∂nnen.  Ich gehe davon aus, dass dies die aktuelle L√§nge des eingegebenen Schl√ºssels ist.  Lass es uns √ºberpr√ºfen. </p><br><h4 id="zapuskaem-otladchik">  F√ºhren Sie den Debugger aus </h4><br><p>  Ich werde den Debugger von <code>Smd Ida Tools</code> , aber tats√§chlich werden einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gens KMod</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gens ReRecording</a> ausreichen.  Die Hauptsache ist, dass es eine Funktion zur Anzeige von Adressen im Speicher gibt. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Meine Theorie wurde best√§tigt.  Die Variable <code>byte_FF0014</code> kann nun <code>key_length</code> . </p><br><p>  Es gibt noch eine andere Variable: <code>dword_FF0010</code> , die ebenfalls nur in der aktuellen Funktion verwendet wird, und deren Inhalt wird nach dem Hinzuf√ºgen zum urspr√ºnglichen Befehl in <code>D0</code> (R√ºckruf, dies war die Nummer <code>#$4B1E2003</code> ) an <code>VDP_CTRL</code> gesendet.  Ohne nachzudenken, habe ich die Variable <code>add_to_vdp_cmd</code> . </p><br><p>  Was macht diese Funktion?  Ich gehe davon aus, dass sie das eingegebene Zeichen zeichnet.  Dies zu <code>sub_45E</code> ist einfach - indem Sie den Debugger starten und den Status vergleichen, bevor Sie die Funktion <code>sub_45E</code> aufrufen und danach: </p><br><p>  An: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Nachher: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  Ich hatte recht - diese Funktion zeichnet das eingegebene Zeichen.  Wir nennen es <code>do_draw_input_char</code> und die Funktion, die es aufruft ( <code>sub_414</code> ), ist <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Was jetzt? </h2><br><p>  Lassen Sie uns zun√§chst √ºberpr√ºfen, ob die Variable, die wir <code>jmp_addr</code> genannt <code>jmp_addr</code> den eingegebenen Schl√ºssel wirklich speichert.  Wir werden dieselbe <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Wie Sie sehen k√∂nnen, war die Vermutung wahr.  Was gibt uns das?  Wir k√∂nnen zu jeder Adresse springen.  Aber welches?  In der Liste der Funktionen sind schlie√ülich alle sortiert: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Dann habe ich einfach angefangen, durch den Code zu scrollen, bis ich Folgendes gefunden habe: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  Das trainierte Auge sah die Folge von <code>$4E, $75</code> am Ende nicht zugeordneter Bytes.  Dies ist der Opcode des <code>rts</code> Befehls, d.h.  R√ºckkehr von der Funktion.  Diese nicht zugewiesenen Bytes k√∂nnen also der Code einer Funktion sein.  Versuchen wir, sie als Code zu kennzeichnen, und dr√ºcken Sie <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Dies ist offensichtlich ein Funktionscode.  Sie k√∂nnen auch <code>P</code> dr√ºcken, um den Code zu einer Funktion zu machen.  Merken Sie sich diesen Namen: <code>sub_D3C</code> . </p><br><p>  Dann entsteht der Gedanke: Was ist, wenn Sie auf <code>sub_D3C</code> springen?  Es h√∂rt sich gut an, obwohl ein einziger Sprung hier offensichtlich nicht ausreicht, weil  Es gab keine Links mehr zur Variablen <code>word_FF0020</code> . </p><br><p>  Dann kam mir ein anderer Gedanke: Was w√§re, wenn wir nach einem anderen solchen nicht zugewiesenen Code suchen w√ºrden?  √ñffnen Sie den <code>Binary search</code> (Alt + B), geben Sie die Sequenz <code>4E 75</code> ein und aktivieren Sie das Kontrollk√§stchen <code>Find all occurrences</code> <code>Binary search</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Klicken Sie auf <code></code> , um die Suche zu starten. Wir erhalten die folgenden Ergebnisse. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Mindestens zwei weitere Stellen im Rum k√∂nnen einen Funktionscode enthalten. Sie m√ºssen diese √ºberpr√ºfen.  Wir klicken auf die erste der Optionen, scrollen ein wenig nach oben und sehen wieder eine Folge von undefinierten Bytes.  Bezeichnen Sie sie als Funktion?  Ja!  Dr√ºcken Sie <code>P</code> wo die Bytes beginnen: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Cool!  Jetzt haben wir die Funktion <code>sub_34C</code> .  Wir versuchen, dasselbe mit den letzten gefundenen Optionen zu wiederholen, und ... wir bekommen einen Mist.  Es gibt so viele Bytes vor <code>4E 75</code> dass nicht klar ist, wo die Funktion beginnt.  Und nat√ºrlich sind nicht alle dieser obigen Bytes Code, weil  viele doppelte Bytes. </p><br><h3 id="opredelyaem-nachalo-funkcii">  Bestimmen Sie den Beginn der Funktion </h3><br><p>  Es ist f√ºr uns am einfachsten, den Anfang der Funktion zu finden, wenn wir herausfinden, wo die Daten enden.  Wie kann man das machen?  Eigentlich gar nicht kompliziert: </p><br><ol><li>  Wir drehen vor dem Beginn der Daten (es wird einen Link vom Code zu ihnen geben) </li><li>  Wir folgen dem Link und suchen nach einem Zyklus, in dem die Gr√∂√üe dieser Daten erscheinen soll </li><li>  Markieren Sie das Array </li></ol><br><p>  Also f√ºhren wir den ersten Absatz durch ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... und wir sehen sofort, dass in einem Zyklus von unserem Array 4 Datenbytes gleichzeitig (weil <code>move.l</code> ) nach <code>VDP_DATA</code> .  Als n√§chstes sehen wir die Nummer <code>2047</code> .  Auf den ersten <code>dbf</code> scheint die endg√ºltige Gr√∂√üe des Arrays <code>2047 * 4</code> , aber die <code>dbf</code> basierte Schleife f√ºhrt mehr <code>+1</code> Iteration aus, weil  Der zuletzt verglichene Wert ist nicht <code>0</code> , sondern <code>-1</code> . </p><br><p>  Gesamt: Die Gr√∂√üe des Arrays betr√§gt <code>2048 * 4 = 8192</code> .  Bezeichnen Sie Bytes als Array.  Klicken Sie dazu auf <code>*</code> und geben Sie die Gr√∂√üe an: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Wir drehen uns zum Ende des Arrays und sehen dort Bytes, die genau die Bytes des Codes sind: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Jetzt haben wir die Funktion <code>sub_2D86</code> und wir haben alles, um diesen Riss zu l√∂sen!  Mal sehen, was die neu erstellte Funktion macht. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  Und es legt einfach den Wert <code>#$4147</code> in das Register <code>D1</code> und ruft die Funktion <code>sub_34C</code> .  Schau sie dir an. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  Wir sehen, dass hier der Wert der Variablen <code>word_FF0020</code> .  Wenn Sie sich die Links dazu ansehen, sehen wir eine andere Stelle, an der der Datensatz in dieser Variablen stattfindet, und genau an dieser Stelle wollte ich durch die Variable <code>jmp_addr</code> springen.  Dies best√§tigt die Vermutung, dass <code>sub_D3C</code> definitiv zu <code>sub_D3C</code> springen <code>sub_D3C</code> . </p><br><p>  Aber was als n√§chstes geschah, war zu faul, um es zu verstehen, also warf ich den Rum in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GHIDRA</a> , fand diese Funktion und sah mir den dekompilierten Code an: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Wir sehen, dass die Variable mit dem seltsamen Namen <code>in_D1w</code> , und auch die Variable <code>DAT_00ff0020</code> , die mit ihrer Adresse an das <code>word_FF0020</code> erw√§hnte <code>DAT_00ff0020</code> erinnert. </p><br><p>  <code>in_D1w</code> sagt uns, dass dieser Wert aus dem Register <code>D1</code> oder vielmehr aus seiner j√ºngeren WORD-H√§lfte entnommen wird, und setzt das Register <code>D1</code> Funktion, die es √ºbergibt.  <code>#$4147</code> du dich an <code>#$4147</code> ?  Sie m√ºssen dieses Register also als Eingabeargument f√ºr die Funktion festlegen. </p><br><p>  Klicken Sie dazu im Fenster mit dem dekompilierten Code mit der rechten Maustaste auf den Funktionsnamen und w√§hlen Sie den Men√ºpunkt <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Um anzuzeigen, dass die Funktion ein Argument √ºber ein bestimmtes Register f√ºhrt, und zwar nicht √ºber die Standardmethode f√ºr die aktuelle Aufrufkonvention, m√ºssen Sie das Kontrollk√§stchen <code>Use Custom Storage</code> und auf das Symbol mit dem <u>gr√ºnen Plus</u> klicken: </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Eine Position f√ºr das neue Eingabeargument wird angezeigt.  Wir doppelklicken darauf und erhalten einen Dialog, der den Typ und das Medium des Arguments angibt: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  Im dekompilierten Code sehen wir, dass <code>in_D1w</code> vom Typ <code>in_D1w</code> ist, was bedeutet, dass wir es im <code>ushort</code> angeben.  Klicken <code>Add</code> dann auf die Schaltfl√§che <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Eine Position zeigt das Medium des Arguments an. Wir m√ºssen das <code>D1w</code> Register in <code>Location</code> angeben und auf <code>OK</code> klicken: </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  Der dekompilierte Code hat folgende Form: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Wir <code>param_1</code> dass unser <code>param_1</code> Wert konstant ist, von der aufrufenden Funktion √ºbergeben wird und gleich <code>#$4147</code> .  Was sollte dann der Wert von <code>DAT_00ff0020</code> ?  Wir betrachten: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Weil  <code>xor</code> - die Operation ist reversibel, alle konstanten Zahlen k√∂nnen miteinander gestritten werden und erhalten den gew√ºnschten Wert der Variablen <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Es stellt sich heraus, dass der Wert der Variablen <code>0x4553</code> sein <code>0x4553</code> .  Es scheint, ich habe bereits einen Ort gesehen, an dem ein solcher Wert festgelegt ist ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Schlussfolgerungen und Entscheidung </h2><br><p>  Wir kommen zu folgenden Ergebnissen: </p><br><ol><li>  Zuerst m√ºssen Sie zur Adresse <code>0x0D3C</code> , dazu m√ºssen Sie den Code <code>0D3C</code> </li><li>  <code>0x2D86</code> zu der Funktion bei <code>0x2D86</code> , die den Wert von <code>D1</code> auf Register <code>#$4147</code> setzt. Dazu m√ºssen Sie den Code <code>2D86</code> </li></ol><br><p>  Experimentell finden wir die Taste heraus, die gedr√ºckt werden muss, um die eingegebene Taste zu √ºberpr√ºfen: <code>B</code>  Wir versuchen: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Vielen Dank! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448500/">https://habr.com/ru/post/de448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448488/index.html">Angst und Abscheu vor DevSecOps</a></li>
<li><a href="../de448490/index.html">So starten Sie die DevOps-Transformation</a></li>
<li><a href="../de448492/index.html">Was ist DevOps?</a></li>
<li><a href="../de448496/index.html">.NET Core unter Linux, DevOps zu Pferd</a></li>
<li><a href="../de448498/index.html">"Russland 404": Wie viel freies Internet bleibt noch zu leben</a></li>
<li><a href="../de448504/index.html">Sie sammelten f√ºr alle "Habrom" das Nachschlagewerk "Von wem es ausgestellt wurde ..." f√ºr P√§sse. Auf Gesundheit herunterladen</a></li>
<li><a href="../de448506/index.html">Die Matrix ist 20 Jahre alt: Wie Wachowski Cyberpunk machte, der die Agenda f√ºr eine ganze Generation bestimmte</a></li>
<li><a href="../de448510/index.html">Acer im Jahr 2019: Was ist, wenn Sie alle Fliegen von den Gaming-Laptops entfernen?</a></li>
<li><a href="../de448516/index.html">Entwickeln oder erstellen Sie eine Basis f√ºr Roboter auf der ARDUINO-Plattform, und wir steuern Sensoren und Videos √ºber ein Smartphone an einen Computer</a></li>
<li><a href="../de448518/index.html">Wie sehe ich ein Schwarzes Loch?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>