<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üïØÔ∏è üë≥ Python GIL est-il vraiment mort? üå† üõ†Ô∏è üíé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Lundi prochain, les cours commenceront dans le nouveau groupe du cours Python Developer , ce qui signifie que nous avons le temps de p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python GIL est-il vraiment mort?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/458694/">  Bonjour √† tous!  Lundi prochain, les cours commenceront dans le nouveau groupe du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours Python Developer</a> , ce qui signifie que nous avons le temps de publier un autre mat√©riel int√©ressant, ce que nous allons faire maintenant.  Bonne lecture. <br><br><img src="https://habrastorage.org/webt/jb/cq/wj/jbcqwjrmctxos6x_uzhptngfd9y.png"><br><br>  En 2003, Intel a sorti le nouveau processeur Pentium 4 ¬´HT¬ª.  Ce processeur overclock√© √† 3GHz et pris en charge la technologie d'hyper-threading. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/9d/z1/es/9dz1esccmgms80liftaeolcqiui.jpeg"><br><br>  Au cours des ann√©es suivantes, Intel et AMD ont eu du mal √† obtenir les meilleures performances de bureau en augmentant la vitesse du bus, la taille du cache L2 et en r√©duisant la taille de la matrice pour minimiser la latence.  En 2004, le mod√®le HT avec une fr√©quence de 3 GHz a √©t√© remplac√© par le mod√®le 580 Prescott avec overclocking √† 4 GHz. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AmwzUrL3vMc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Il semblait que pour aller de l'avant, il √©tait juste n√©cessaire d'augmenter la fr√©quence d'horloge, cependant, les nouveaux processeurs souffraient d'une forte consommation d'√©nergie et d'une dissipation thermique. <br><br>  Votre processeur de bureau d√©livre-t-il 4 GHz aujourd'hui?  Il est peu probable, car le chemin vers l'am√©lioration des performances passe finalement par l'augmentation des vitesses de bus et l'augmentation du nombre de c≈ìurs.  En 2006, Intel Core 2 a remplac√© le Pentium 4 et avait une vitesse d'horloge beaucoup plus faible. <br><br>  Outre la sortie de processeurs multic≈ìurs pour un large public d'utilisateurs, quelque chose d'autre s'est produit en 2006.  Python 2.5 a enfin vu le jour!  Il √©tait d√©j√† accompagn√© d'une version b√™ta du mot cl√© with, que vous connaissez et aimez tous. <br><br>  Python 2.5 avait une limitation majeure lorsqu'il s'agissait d'utiliser Intel Core 2 ou AMD Athlon X2. <br>  C'√©tait un GIL. <br><br><h2>  Qu'est-ce qu'un GIL? </h2><br>  GIL (Global Interpreter Lock) est une valeur bool√©enne dans l'interpr√©teur Python prot√©g√© par un mutex.  Le verrou est utilis√© dans la boucle de calcul de bytecode CPython principal pour d√©terminer le thread qui ex√©cute actuellement les instructions. <br><br>  CPython prend en charge l'utilisation de plusieurs threads dans un seul interpr√©teur, mais les threads doivent demander l'acc√®s au GIL afin d'effectuer des op√©rations de bas niveau.  En retour, cela signifie que les d√©veloppeurs Python peuvent utiliser du code asynchrone, du multithreading et ne plus avoir √† se soucier de bloquer des variables ou des plantages au niveau du processeur pendant les blocages. <br><br>  GIL simplifie la programmation Python multithread. <br><br><img src="https://habrastorage.org/webt/lg/yz/3h/lgyz3hoq07fkumzp4axuuiqxplk.gif"><br><br>  GIL nous dit √©galement que bien que CPython puisse √™tre multi-thread, un seul thread √† la fois peut √™tre ex√©cut√©.  Cela signifie que votre processeur quad-core fait quelque chose comme √ßa (√† l'exception de l'√©cran bleu, esp√©rons-le). <br><br>  La version actuelle de GIL a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©t√© √©crite en 2009</a> pour prendre en charge les fonctions asynchrones et est rest√©e intacte m√™me apr√®s de nombreuses tentatives de suppression de principe ou de modification des exigences. <br><br>  Toute suggestion de suppression du GIL √©tait justifi√©e par le fait que le verrouillage global de l'interpr√©teur ne devrait pas d√©grader les performances du code √† thread unique.  Quiconque a tent√© d'activer l'hyperthreading en 2003 comprendra de quoi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">je parle</a> . <br><br><h2>  Abandon de Gil dans CPython </h2><br>  Si vous voulez vraiment parall√©liser le code dans CPython, vous devrez utiliser plusieurs processus. <br><br>  Dans CPython 2.6, le module de <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multitraitement a</a></i> √©t√© ajout√© √† la biblioth√®que standard.  Le multiprocessing a masqu√© la g√©n√©ration de processus en CPython (chaque processus ayant son propre GIL). <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Process <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, name <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Process(target=f, args=(<span class="hljs-string"><span class="hljs-string">'bob'</span></span>,)) p.start() p.join()</code> </pre> <br><br>  Les processus sont cr√©√©s, les commandes leur sont envoy√©es √† l'aide de modules compil√©s et de fonctions Python, puis ils sont rejoints au processus principal. <br><br>  Le multitraitement prend √©galement en charge l'utilisation de variables via une file d'attente ou un canal.  Elle a un objet de verrouillage, qui est utilis√© pour verrouiller des objets dans le processus principal et √©crire √† partir d'autres processus. <br><br>  Le multitraitement pr√©sente un inconv√©nient majeur.  Il supporte une charge de calcul importante, qui affecte √† la fois le temps de traitement et l'utilisation de la m√©moire.  Le temps de d√©marrage de CPython m√™me sans aucun site est de 100 √† 200 ms (consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b</a> pour en savoir plus). <br><br>  Par cons√©quent, vous pouvez avoir du code parall√®le dans CPython, mais vous devez toujours planifier soigneusement le travail des processus de longue dur√©e qui partagent plusieurs objets. <br><br>  Une autre alternative peut √™tre d'utiliser un package tiers tel que Twisted. <br><br><h2>  PEP554 et la mort de GIL? </h2><br>  Donc, permettez-moi de vous rappeler que le multithreading en CPython est simple, mais en r√©alit√© ce n'est pas de la parall√©lisation, mais le multitraitement est parall√®le, mais implique une surcharge importante. <br><br>  <i>Et s'il y avait une meilleure fa√ßon?</i> <br>  La cl√© pour contourner le GIL r√©side dans le nom, le verrouillage global de l'interpr√©teur fait partie de l'√©tat global de l'interpr√©teur.  Les processus CPython peuvent avoir plusieurs interpr√®tes et, par cons√©quent, plusieurs verrous, cependant, cette fonction est rarement utilis√©e, car l'acc√®s √† celui-ci se fait uniquement via la C-API. <br><br>  Une des fonctionnalit√©s de CPython 3.8 est PEP554, une impl√©mentation de sous-interpr√®tes et d'API avec un nouveau module d' <code>interpreters</code> dans la biblioth√®que standard. <br><br>  Cela vous permet de cr√©er plusieurs interpr√®tes √† partir de Python en un seul processus.  Une autre innovation de Python 3.8 est que tous les interpr√®tes auront leur propre GIL. <br><br><img src="https://habrastorage.org/webt/bq/nc/m2/bqncm29jhm-ytakgrlkasbfe_6y.png"><br><br>  √âtant donn√© que l'√©tat de l'interpr√©teur contient une r√©gion allou√©e en m√©moire, une collection de tous les pointeurs vers les objets Python (locaux et globaux), les sous-interpr√®tes de PEP554 ne peuvent pas acc√©der aux variables globales des autres interpr√®tes. <br><br>  Comme le multiprocessing, les interpr√®tes partageant des objets consistent √† les s√©rialiser et √† utiliser le formulaire IPC (r√©seau, disque ou m√©moire partag√©e).  Il existe de nombreuses fa√ßons de s√©rialiser des objets en Python, par exemple le module <code>marshal</code> , le module <code>pickle</code> ou des m√©thodes plus standardis√©es comme <code>json</code> ou <code>simplexml</code> .  Chacun d'eux a ses avantages et ses inconv√©nients, et tous donnent une charge de calcul. <br><br>  Il serait pr√©f√©rable d'avoir un espace m√©moire commun qui peut √™tre modifi√© et contr√¥l√© par un processus sp√©cifique.  Ainsi, les objets peuvent √™tre envoy√©s par l'interpr√®te principal et re√ßus par un autre interpr√®te.  Ce sera l'espace m√©moire g√©r√© pour la recherche de pointeurs PyObject, auquel chaque interpr√®te peut acc√©der, tandis que le processus principal g√®re les verrous. <br><br><img src="https://habrastorage.org/webt/be/ww/d8/bewwd8ju-3akmyhs7ujq7xmyliy.png"><br><br>  Une API pour cela est toujours en cours de d√©veloppement, mais elle ressemblera probablement √† ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _xxsubinterpreters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> interpreters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> marshal <span class="hljs-comment"><span class="hljs-comment"># Create a sub-interpreter interpid = interpreters.create() # If you had a function that generated some data arry = list(range(0,100)) # Create a channel channel_id = interpreters.channel_create() # Pre-populate the interpreter with a module interpreters.run_string(interpid, "import marshal; import _xxsubinterpreters as interpreters") # Define a def run(interpid, channel_id): interpreters.run_string(interpid, tw.dedent(""" arry_raw = interpreters.channel_recv(channel_id) arry = marshal.loads(arry_raw) result = [1,2,3,4,5] # where you would do some calculating result_raw = marshal.dumps(result) interpreters.channel_send(channel_id, result_raw) """), shared=dict( channel_id=channel_id ), ) inp = marshal.dumps(arry) interpreters.channel_send(channel_id, inp) # Run inside a thread t = threading.Thread(target=run, args=(interpid, channel_id)) t.start() # Sub interpreter will process. Feel free to do anything else now. output = interpreters.channel_recv(channel_id) interpreters.channel_release(channel_id) output_arry = marshal.loads(output) print(output_arry)</span></span></code> </pre> <br><br>  Cet exemple utilise NumPy.  Le tableau numpy est envoy√© sur le canal, il est s√©rialis√© √† l'aide du module <code>marshal</code> , puis le sous-interpr√®te traite les donn√©es (sur un GIL s√©par√©), il peut donc y avoir un probl√®me de parall√©lisation associ√© au CPU, ce qui est id√©al pour les sous-interpr√®tes. <br><br><h4>  <b>√áa a l'air inefficace</b> </h4><br>  Le module <code>marshal</code> fonctionne tr√®s rapidement, mais pas aussi rapidement que le partage d'objets directement depuis la m√©moire. <br><br>  PEP574 introduit un nouveau protocole de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pickle (v5)</a> qui prend en charge la possibilit√© de traiter les tampons de m√©moire s√©par√©ment du reste du flux de pickle.  Pour les objets de donn√©es volumineux, la s√©rialisation de tous en une seule fois et la d√©s√©rialisation √† partir d'un sous-interpr√©teur ajoutera beaucoup de surcharge. <br><br>  La nouvelle API peut √™tre impl√©ment√©e (purement hypoth√©tiquement) comme suit - <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _xxsubinterpreters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> interpreters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-comment"><span class="hljs-comment"># Create a sub-interpreter interpid = interpreters.create() # If you had a function that generated a numpy array arry = [5,4,3,2,1] # Create a channel channel_id = interpreters.channel_create() # Pre-populate the interpreter with a module interpreters.run_string(interpid, "import pickle; import _xxsubinterpreters as interpreters") buffers=[] # Define a def run(interpid, channel_id): interpreters.run_string(interpid, tw.dedent(""" arry_raw = interpreters.channel_recv(channel_id) arry = pickle.loads(arry_raw) print(f"Got: {arry}") result = arry[::-1] result_raw = pickle.dumps(result, protocol=5) interpreters.channel_send(channel_id, result_raw) """), shared=dict( channel_id=channel_id, ), ) input = pickle.dumps(arry, protocol=5, buffer_callback=buffers.append) interpreters.channel_send(channel_id, input) # Run inside a thread t = threading.Thread(target=run, args=(interpid, channel_id)) t.start() # Sub interpreter will process. Feel free to do anything else now. output = interpreters.channel_recv(channel_id) interpreters.channel_release(channel_id) output_arry = pickle.loads(output) print(f"Got back: {output_arry}")</span></span></code> </pre> <br><h4>  <b>Il semble √† motifs</b> </h4><br>  Essentiellement, cet exemple est construit sur l'utilisation de l'API de sous-interpr√®tes de bas niveau.  Si vous n'avez pas utilis√© la biblioth√®que <code>multiprocessing</code> , certains probl√®mes vous sembleront familiers.  Ce n'est pas aussi simple que le traitement de flux, vous ne pouvez pas simplement, par exemple, ex√©cuter cette fonction avec une telle liste de donn√©es d'entr√©e dans des interpr√®tes s√©par√©s (pour l'instant). <br><br>  D√®s que ce PEP fusionnera avec d'autres, je pense que nous verrons plusieurs nouvelles API dans PyPi. <br><br><h3>  Combien de frais g√©n√©raux le sous-interpr√®te a-t-il? </h3><br>  <b>R√©ponse courte:</b> plus qu'un flux, moins qu'un processus. <br>  <b>R√©ponse longue: L'</b> interpr√©teur a son propre √©tat, il devra donc cloner et initialiser ce qui suit, malgr√© le fait que PEP554 simplifie la cr√©ation de sous-interpr√®tes: <br><br><ul><li>  Modules dans l' <code>importlib</code> <code>__main__</code> et <code>importlib</code> ; </li><li>  Le contenu du dictionnaire <code>sys</code> ; </li><li>  Fonctions int√©gr√©es ( <code>print()</code> , <code>assert</code> , etc.); </li><li>  Streams; </li><li>  Configuration du noyau. </li></ul><br><br>  La configuration du noyau peut √™tre facilement clon√©e depuis la m√©moire, mais l'importation de modules n'est pas si simple.  L'importation de modules en Python est lente, donc si la cr√©ation d'un sous-interpr√©teur signifie l'importation de modules dans un espace de noms diff√©rent √† chaque fois, les avantages sont r√©duits. <br><br><h3>  Et asyncio? </h3><br>  L'impl√©mentation existante de la <code>asyncio</code> √©v√©nements <code>asyncio</code> dans la biblioth√®que standard cr√©e des cadres de pile pour l'√©valuation, et <code>asyncio</code> √©galement l'√©tat dans l'interpr√©teur principal (et partage donc le GIL). <br><br>  Apr√®s avoir combin√© PEP554, probablement d√©j√† en Python 3.9, une impl√©mentation alternative de la boucle d'√©v√©nements peut √™tre utilis√©e (bien que personne ne l'ait encore fait), qui ex√©cute des m√©thodes asynchrones dans des sous-interpr√®tes en parall√®le. <br><br><h3>  √áa a l'air cool, enveloppez-moi aussi! </h3><br>  Enfin, pas vraiment. <br>  √âtant donn√© que CPython fonctionne sur le m√™me interpr√©teur depuis si longtemps, de nombreuses parties de la base de code utilisent ¬´Runtime State¬ª au lieu de ¬´Interpreter State¬ª, donc si PEP554 √©tait introduit maintenant, il y aurait encore beaucoup de probl√®mes. <br><br>  Par exemple, l'√©tat du garbage collector (dans les versions 3.7 &lt;) appartient au runtime. <br><br>  Lors des changements pendant les sprints PyCon, l'√©tat du garbage collector a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commenc√© √† se d√©placer</a> vers l'interpr√©teur, de sorte que chaque sous-interpr√®te aurait son propre garbage collector (comme il se doit). <br><br>  Un autre probl√®me est qu'il y a des variables ¬´globales¬ª qui sont rest√©es dans la base de code CPython avec de nombreuses extensions en C. Par cons√©quent, lorsque les gens ont soudainement commenc√© √† parall√©liser correctement leur code, nous avons vu des probl√®mes. <br><br>  Un autre probl√®me est que les descripteurs de fichiers appartiennent au processus, donc si vous avez un fichier ouvert pour l'√©criture dans un interpr√©teur, le sous-interpr√®te ne pourra pas acc√©der √† ce fichier (sans autres modifications de CPython). <br><br>  Bref, de nombreux probl√®mes doivent encore √™tre r√©solus. <br><br><h2>  Conclusion: GIL est-il encore vrai? </h2><br>  GIL continuera d'√™tre utilis√© pour les applications monothread.  Par cons√©quent, m√™me lorsque vous suivez PEP554, votre code √† thread unique ne deviendra soudainement pas parall√®le. <br>  Si vous voulez √©crire du code parall√®le en Python 3.8, vous aurez des probl√®mes de parall√©lisation associ√©s au processeur, mais c'est aussi un billet pour le futur! <br><br><h2>  Quand? </h2><br>  Pickle v5 et le partage de m√©moire pour le multitraitement seront tr√®s probablement en Python 3.8 (octobre 2019), et des sous-interpr√®tes appara√Ætront entre les versions 3.8 et 3.9. <br>  Si vous souhaitez jouer avec les exemples pr√©sent√©s, j'ai cr√©√© une branche distincte avec tout le code n√©cessaire: <a href="">https://github.com/tonybaloney/cpython/tree/subinterpreters.</a> <br><br>  Qu'en pensez-vous?  √âcrivez vos commentaires et rendez-vous sur le parcours. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458694/">https://habr.com/ru/post/fr458694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458684/index.html">L'ICANN supprime le seuil de prix pour le domaine .org - pourquoi la communaut√© informatique s'y oppose et que se passera-t-il ensuite</a></li>
<li><a href="../fr458686/index.html">@Pythonetc juin 2019</a></li>
<li><a href="../fr458688/index.html">Trucs et astuces de ma cha√Æne Telegram @pythonetc, juin 2019</a></li>
<li><a href="../fr458690/index.html">Automatisez-le! Comment nous avons am√©lior√© les tests d'int√©gration</a></li>
<li><a href="../fr458692/index.html">"Peut-√™tre" monade via async / attendre en C # (pas de t√¢ches!)</a></li>
<li><a href="../fr458696/index.html">Texturation, ou ce que vous devez savoir pour devenir un artiste de surface. Partie 3. PBR et mat√©riaux</a></li>
<li><a href="../fr458698/index.html">Le chemin de la paix et le chemin de la guerre dans les projets informatiques</a></li>
<li><a href="../fr458702/index.html">Chiens de tra√Æneau: ce que vous devez savoir √† leur sujet et comment ils ont √©t√© amen√©s</a></li>
<li><a href="../fr458704/index.html">Mise en place d'un syst√®me DLP sur l'exemple du retail</a></li>
<li><a href="../fr458706/index.html">Les Gopniks sont maintenant sur les march√©s √©trangers, ou "Pourquoi est-il si difficile de trouver un programmeur normal?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>